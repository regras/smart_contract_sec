{{
  "language": "Solidity",
  "sources": {
    "src/base/DecodersAndSanitizers/Protocols/ITB/cork/FullCorkDecoderAndSanitizer.sol": {
      "content": "/* SPDX-License-Identifier: UNLICENSED */\npragma solidity ^0.8.0;\n\nimport {CorkDecoderAndSanitizer} from \"./CorkDecoderAndSanitizer.sol\";\nimport {ITBPositionDecoderAndSanitizer} from \"../ITBPositionDecoderAndSanitizer.sol\";\n\ncontract FullCorkDecoderAndSanitizer is CorkDecoderAndSanitizer, ITBPositionDecoderAndSanitizer {\n    \n}"
    },
    "src/base/DecodersAndSanitizers/Protocols/ITB/cork/CorkDecoderAndSanitizer.sol": {
      "content": "/* SPDX-License-Identifier: UNLICENSED */\npragma solidity ^0.8.0;\n\nimport '../common/ITBContractDecoderAndSanitizer.sol';\n\nabstract contract CorkDecoderAndSanitizer is ITBContractDecoderAndSanitizer {\n    type Id is bytes32;\n\n    function updatePositionConfig(address _vault, Id, uint) external pure returns (bytes memory addressesFound) {\n        addressesFound = abi.encodePacked(_vault);\n    }\n\n    function updateVaultSupervisor(address _vault_supervisor) external pure returns (bytes memory addressesFound) {\n        addressesFound = abi.encodePacked(_vault_supervisor);\n    }\n\n    function update1InchRouter(address _router) external pure returns (bytes memory addressesFound) {\n        addressesFound = abi.encodePacked(_router);\n    }\n\n    function depositLv(uint, uint) external pure returns (bytes memory addressesFound) {\n        // Nothing to sanitize or return\n        return addressesFound;\n    }\n\n    function swapPaToRa(bytes memory, uint) external pure returns (bytes memory addressesFound) {\n        // Nothing to sanitize or return\n        return addressesFound;\n    }\n\n    function swapCtDsToRa(uint, uint) external pure returns (bytes memory addressesFound) {\n        // Nothing to sanitize or return\n        return addressesFound;\n    }\n\n    function swapDsPaToRa(uint, uint) external pure returns (bytes memory addressesFound) {\n        // Nothing to sanitize or return\n        return addressesFound;\n    }\n\n    function redeemExpiredCt(address _ct, uint, uint) external pure returns (bytes memory addressesFound) {\n        addressesFound = abi.encodePacked(_ct);\n    }\n\n    function startWithdrawal(uint, uint) external pure returns (bytes memory addressesFound) {\n        // Nothing to sanitize or return\n        return addressesFound;\n    }\n\n    function claimWithdrawal(bytes32) external pure returns (bytes memory addressesFound) {\n        // Nothing to sanitize or return\n        return addressesFound;\n    }\n\n    function completeWithdrawal(uint, uint) external pure returns (bytes memory addressesFound) {\n        // Nothing to sanitize or return\n        return addressesFound;\n    }\n\n    function completeNextWithdrawal(uint) external pure returns (bytes memory addressesFound) {\n        // Nothing to sanitize or return\n        return addressesFound;\n    }\n\n    function completeNextWithdrawals(uint) external pure returns (bytes memory addressesFound) {\n        // Nothing to sanitize or return\n        return addressesFound;\n    }\n\n    function overrideWithdrawalIndexes(uint, uint) external pure returns (bytes memory addressesFound) {\n        // Nothing to sanitize or return\n        return addressesFound;\n    }\n\n    function assemble(uint) external pure returns (bytes memory addressesFound) {\n        // Nothing to sanitize or return\n        return addressesFound;\n    }\n\n    function disassemble(uint, uint) external pure returns (bytes memory addressesFound) {\n        // Nothing to sanitize or return\n        return addressesFound;\n    }\n\n    function fullDisassemble(uint) external pure returns (bytes memory addressesFound) {\n        // Nothing to sanitize or return\n        return addressesFound;\n    }\n\n    function redeemExpiredCtByConfig(uint, uint) external pure returns (bytes memory addressesFound) {\n        // Nothing to sanitize or return\n        return addressesFound;\n    }\n}"
    },
    "src/base/DecodersAndSanitizers/Protocols/ITB/ITBPositionDecoderAndSanitizer.sol": {
      "content": "/* SPDX-License-Identifier: UNLICENSED */\npragma solidity ^0.8.0;\n\nimport {BaseDecoderAndSanitizer} from \"src/base/DecodersAndSanitizers/BaseDecoderAndSanitizer.sol\";\n\n// ITB Decoders\nimport {ExecutableDecoderAndSanitizer} from\n    \"src/base/DecodersAndSanitizers/Protocols/ITB/common/ExecutableDecoderAndSanitizer.sol\";\nimport {WithdrawableDecoderAndSanitizer} from\n    \"src/base/DecodersAndSanitizers/Protocols/ITB/common/WithdrawableDecoderAndSanitizer.sol\";\n\ncontract ITBPositionDecoderAndSanitizer is\n    BaseDecoderAndSanitizer,\n    ExecutableDecoderAndSanitizer,\n    WithdrawableDecoderAndSanitizer\n{\n//============================== HANDLE FUNCTION COLLISIONS ===============================\n}\n"
    },
    "src/base/DecodersAndSanitizers/Protocols/ITB/common/ITBContractDecoderAndSanitizer.sol": {
      "content": "/* SPDX-License-Identifier: UNLICENSED */\npragma solidity ^0.8.0;\n\nimport \"./WithdrawableDecoderAndSanitizer.sol\";\nimport \"./Ownable2StepDecoderAndSanitizer.sol\";\n\n/// @title Decoder and sanitizer for ITBContract\n/// @author IntoTheBlock Corp\nabstract contract ITBContractDecoderAndSanitizer is WithdrawableDecoderAndSanitizer, Ownable2StepDecoderAndSanitizer {\n    function approveToken(address _token, address _guy, uint256) external pure returns (bytes memory addressesFound) {\n        addressesFound = abi.encodePacked(_token, _guy);\n    }\n\n    function revokeToken(address _token, address _guy) external pure returns (bytes memory addressesFound) {\n        addressesFound = abi.encodePacked(_token, _guy);\n    }\n}\n"
    },
    "src/base/DecodersAndSanitizers/BaseDecoderAndSanitizer.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.21;\n\nimport {DecoderCustomTypes} from \"src/interfaces/DecoderCustomTypes.sol\";\n\ncontract BaseDecoderAndSanitizer {\n    error BaseDecoderAndSanitizer__FunctionSelectorNotSupported();\n    //============================== IMMUTABLES ===============================\n\n    function approve(address spender, uint256) external pure returns (bytes memory addressesFound) {\n        addressesFound = abi.encodePacked(spender);\n    }\n\n    function transfer(address _to, uint256) external pure returns (bytes memory addressesFound) {\n        addressesFound = abi.encodePacked(_to);\n    }\n\n    function claimFees(address feeAsset) external pure returns (bytes memory addressesFound) {\n        addressesFound = abi.encodePacked(feeAsset);\n    }\n\n    function claimYield(address yieldAsset) external pure returns (bytes memory addressesFound) {\n        addressesFound = abi.encodePacked(yieldAsset);\n    }\n\n    function withdrawNonBoringToken(address token, uint256 /*amount*/ )\n        external\n        pure\n        returns (bytes memory addressesFound)\n    {\n        addressesFound = abi.encodePacked(token);\n    }\n\n    function withdrawNativeFromDrone() external pure returns (bytes memory addressesFound) {\n        return addressesFound;\n    }\n\n    //============================== FALLBACK ===============================\n    /**\n     * @notice The purpose of this function is to revert with a known error,\n     *         so that during merkle tree creation we can verify that a\n     *         leafs decoder and sanitizer implments the required function\n     *         selector.\n     */\n    fallback() external {\n        revert BaseDecoderAndSanitizer__FunctionSelectorNotSupported();\n    }\n}\n"
    },
    "src/base/DecodersAndSanitizers/Protocols/ITB/common/ExecutableDecoderAndSanitizer.sol": {
      "content": "/* SPDX-License-Identifier: UNLICENSED */\npragma solidity ^0.8.0;\n\n/// @title Decoder and sanitizer for Executable\n/// @author IntoTheBlock Corp\nabstract contract ExecutableDecoderAndSanitizer {\n    function removeExecutor(address /*_executor*/ ) external pure returns (bytes memory addressesFound) {\n        return addressesFound;\n    }\n}\n"
    },
    "src/base/DecodersAndSanitizers/Protocols/ITB/common/WithdrawableDecoderAndSanitizer.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\n/// @title Decoder and sanitizer for Withdrawable\n/// @author IntoTheBlock Corp\nabstract contract WithdrawableDecoderAndSanitizer {\n    function withdraw(address, /*_asset_address*/ uint256) external pure virtual returns (bytes memory addressesFound) {\n        return addressesFound;\n    }\n\n    function withdrawAll(address /*_asset_address*/ ) external pure returns (bytes memory addressesFound) {\n        return addressesFound;\n    }\n}\n"
    },
    "src/base/DecodersAndSanitizers/Protocols/ITB/common/Ownable2StepDecoderAndSanitizer.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\n/// @title Decoder and sanitizer for Ownable2Step from @openzeppelin/contracts/access/Ownable2Step.sol\n/// @author IntoTheBlock Corp\nabstract contract Ownable2StepDecoderAndSanitizer {\n    function acceptOwnership() external pure returns (bytes memory addressesFound) {\n        // Nothing to sanitize or return\n        return addressesFound;\n    }\n}\n"
    },
    "src/interfaces/DecoderCustomTypes.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.21;\n\ncontract DecoderCustomTypes {\n    // ========================================= BALANCER =========================================\n    struct JoinPoolRequest {\n        address[] assets;\n        uint256[] maxAmountsIn;\n        bytes userData;\n        bool fromInternalBalance;\n    }\n\n    struct ExitPoolRequest {\n        address[] assets;\n        uint256[] minAmountsOut;\n        bytes userData;\n        bool toInternalBalance;\n    }\n\n    enum SwapKind {\n        GIVEN_IN,\n        GIVEN_OUT\n    }\n\n    struct SingleSwap {\n        bytes32 poolId;\n        SwapKind kind;\n        address assetIn;\n        address assetOut;\n        uint256 amount;\n        bytes userData;\n    }\n\n    struct FundManagement {\n        address sender;\n        bool fromInternalBalance;\n        address recipient;\n        bool toInternalBalance;\n    }\n\n    // ========================================= UNISWAP V3 =========================================\n\n    struct MintParams {\n        address token0;\n        address token1;\n        uint24 fee;\n        int24 tickLower;\n        int24 tickUpper;\n        uint256 amount0Desired;\n        uint256 amount1Desired;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        address recipient;\n        uint256 deadline;\n    }\n\n    struct IncreaseLiquidityParams {\n        uint256 tokenId;\n        uint256 amount0Desired;\n        uint256 amount1Desired;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        uint256 deadline;\n    }\n\n    struct DecreaseLiquidityParams {\n        uint256 tokenId;\n        uint128 liquidity;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        uint256 deadline;\n    }\n\n    struct CollectParams {\n        uint256 tokenId;\n        address recipient;\n        uint128 amount0Max;\n        uint128 amount1Max;\n    }\n\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    struct ExactInputParamsRouter02 {\n        bytes path;\n        address recipient;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    struct PancakeSwapExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    // ========================================= UNISWAP V4 =========================================\n    \n    struct SwapParams {\n        /// Whether to swap token0 for token1 or vice versa\n        bool zeroForOne;\n        /// The desired input amount if negative (exactIn), or the desired output amount if positive (exactOut)\n        int256 amountSpecified;\n        /// The sqrt price at which, if reached, the swap will stop executing\n        uint160 sqrtPriceLimitX96;\n    }\n\n    struct PoolKey {\n        /// @notice The lower currency of the pool, sorted numerically\n        address currency0;\n        /// @notice The higher currency of the pool, sorted numerically\n        address currency1;\n        /// @notice The pool LP fee, capped at 1_000_000. If the highest bit is 1, the pool has a dynamic fee and must be exactly equal to 0x800000\n        uint24 fee;\n        /// @notice Ticks that involve positions must be a multiple of tick spacing\n        int24 tickSpacing;\n        /// @notice The hooks of the pool\n        address hooks;\n    }\n\n    /// @dev comes from IV4 Router\n    struct ExactInputSingleParams {\n        PoolKey poolKey;\n        bool zeroForOne;\n        uint128 amountIn;\n        uint128 amountOutMinimum;\n        bytes hookData;\n    }\n\n     /// @notice Parameters for a single-hop exact-output swap\n    struct ExactOutputSingleParams {\n        PoolKey poolKey;\n        bool zeroForOne;\n        uint128 amountOut;\n        uint128 amountInMaximum;\n        bytes hookData;\n    }\n\n\n    // ========================================= MORPHO BLUE =========================================\n\n    struct MarketParams {\n        address loanToken;\n        address collateralToken;\n        address oracle;\n        address irm;\n        uint256 lltv;\n    }\n\n    // ========================================= 1INCH =========================================\n\n    struct SwapDescription {\n        address srcToken;\n        address dstToken;\n        address payable srcReceiver;\n        address payable dstReceiver;\n        uint256 amount;\n        uint256 minReturnAmount;\n        uint256 flags;\n    }\n\n    // ========================================= PENDLE =========================================\n    struct TokenInput {\n        // TOKEN DATA\n        address tokenIn;\n        uint256 netTokenIn;\n        address tokenMintSy;\n        // AGGREGATOR DATA\n        address pendleSwap;\n        SwapData swapData;\n    }\n\n    struct TokenOutput {\n        // TOKEN DATA\n        address tokenOut;\n        uint256 minTokenOut;\n        address tokenRedeemSy;\n        // AGGREGATOR DATA\n        address pendleSwap;\n        SwapData swapData;\n    }\n\n    struct ApproxParams {\n        uint256 guessMin;\n        uint256 guessMax;\n        uint256 guessOffchain; // pass 0 in to skip this variable\n        uint256 maxIteration; // every iteration, the diff between guessMin and guessMax will be divided by 2\n        uint256 eps; // the max eps between the returned result & the correct result, base 1e18. Normally this number will be set\n            // to 1e15 (1e18/1000 = 0.1%)\n    }\n\n    struct SwapData {\n        SwapType swapType;\n        address extRouter;\n        bytes extCalldata;\n        bool needScale;\n    }\n\n    enum SwapType {\n        NONE,\n        KYBERSWAP,\n        ONE_INCH,\n        // ETH_WETH not used in Aggregator\n        ETH_WETH\n    }\n\n    struct LimitOrderData {\n        address limitRouter;\n        uint256 epsSkipMarket; // only used for swap operations, will be ignored otherwise\n        FillOrderParams[] normalFills;\n        FillOrderParams[] flashFills;\n        bytes optData;\n    }\n\n    struct FillOrderParams {\n        Order order;\n        bytes signature;\n        uint256 makingAmount;\n    }\n\n    struct Order {\n        uint256 salt;\n        uint256 expiry;\n        uint256 nonce;\n        OrderType orderType;\n        address token;\n        address YT;\n        address maker;\n        address receiver;\n        uint256 makingAmount;\n        uint256 lnImpliedRate;\n        uint256 failSafeRate;\n        bytes permit;\n    }\n\n    enum OrderType {\n        SY_FOR_PT,\n        PT_FOR_SY,\n        SY_FOR_YT,\n        YT_FOR_SY\n    }\n\n    // ========================================= EIGEN LAYER =========================================\n\n    struct QueuedWithdrawalParams {\n        // Array of strategies that the QueuedWithdrawal contains\n        address[] strategies;\n        // Array containing the amount of shares in each Strategy in the `strategies` array\n        uint256[] shares;\n        // The address of the withdrawer\n        address withdrawer;\n    }\n\n    struct Withdrawal {\n        // The address that originated the Withdrawal\n        address staker;\n        // The address that the staker was delegated to at the time that the Withdrawal was created\n        address delegatedTo;\n        // The address that can complete the Withdrawal + will receive funds when completing the withdrawal\n        address withdrawer;\n        // Nonce used to guarantee that otherwise identical withdrawals have unique hashes\n        uint256 nonce;\n        // Block number when the Withdrawal was created\n        uint32 startBlock;\n        // Array of strategies that the Withdrawal contains\n        address[] strategies;\n        // Array containing the amount of shares in each Strategy in the `strategies` array\n        uint256[] shares;\n    }\n\n    struct SignatureWithExpiry {\n        // the signature itself, formatted as a single bytes object\n        bytes signature;\n        // the expiration timestamp (UTC) of the signature\n        uint256 expiry;\n    }\n\n    struct EarnerTreeMerkleLeaf {\n        address earner;\n        bytes32 earnerTokenRoot;\n    }\n\n    struct TokenTreeMerkleLeaf {\n        address token;\n        uint256 cumulativeEarnings;\n    }\n\n    struct RewardsMerkleClaim {\n        uint32 rootIndex;\n        uint32 earnerIndex;\n        bytes earnerTreeProof;\n        EarnerTreeMerkleLeaf earnerLeaf;\n        uint32[] tokenIndices;\n        bytes[] tokenTreeProofs;\n        TokenTreeMerkleLeaf[] tokenLeaves;\n    }\n\n    // ========================================= CCIP =========================================\n\n    // If extraArgs is empty bytes, the default is 200k gas limit.\n    struct EVM2AnyMessage {\n        bytes receiver; // abi.encode(receiver address) for dest EVM chains\n        bytes data; // Data payload\n        EVMTokenAmount[] tokenAmounts; // Token transfers\n        address feeToken; // Address of feeToken. address(0) means you will send msg.value.\n        bytes extraArgs; // Populate this with _argsToBytes(EVMExtraArgsV2)\n    }\n\n    /// @dev RMN depends on this struct, if changing, please notify the RMN maintainers.\n    struct EVMTokenAmount {\n        address token; // token address on the local chain.\n        uint256 amount; // Amount of tokens.\n    }\n\n    struct EVMExtraArgsV1 {\n        uint256 gasLimit;\n    }\n\n    // ========================================= OFT =========================================\n\n    struct SendParam {\n        uint32 dstEid; // Destination endpoint ID.\n        bytes32 to; // Recipient address.\n        uint256 amountLD; // Amount to send in local decimals.\n        uint256 minAmountLD; // Minimum amount to send in local decimals.\n        bytes extraOptions; // Additional options supplied by the caller to be used in the LayerZero message.\n        bytes composeMsg; // The composed message for the send() operation.\n        bytes oftCmd; // The OFT command to be executed, unused in default OFT implementations.\n    }\n\n    struct MessagingFee {\n        uint256 nativeFee;\n        uint256 lzTokenFee;\n    }\n    // ========================================= L1StandardBridge =========================================\n\n    struct WithdrawalTransaction {\n        uint256 nonce;\n        address sender;\n        address target;\n        uint256 value;\n        uint256 gasLimit;\n        bytes data;\n    }\n\n    struct OutputRootProof {\n        bytes32 version;\n        bytes32 stateRoot;\n        bytes32 messagePasserStorageRoot;\n        bytes32 latestBlockhash;\n    }\n\n    // ========================================= Mantle L1StandardBridge =========================================\n\n    struct MantleWithdrawalTransaction {\n        uint256 nonce;\n        address sender;\n        address target;\n        uint256 mntValue;\n        uint256 value;\n        uint256 gasLimit;\n        bytes data;\n    }\n\n    // ========================================= Linea Bridge =========================================\n\n    struct ClaimMessageWithProofParams {\n        bytes32[] proof;\n        uint256 messageNumber;\n        uint32 leafIndex;\n        address from;\n        address to;\n        uint256 fee;\n        uint256 value;\n        address payable feeRecipient;\n        bytes32 merkleRoot;\n        bytes data;\n    }\n\n    // ========================================= Scroll Bridge =========================================\n\n    struct L2MessageProof {\n        uint256 batchIndex;\n        bytes merkleProof;\n    }\n\n    // ========================================= Camelot V3 =========================================\n\n    struct CamelotMintParams {\n        address token0;\n        address token1;\n        int24 tickLower;\n        int24 tickUpper;\n        uint256 amount0Desired;\n        uint256 amount1Desired;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        address recipient;\n        uint256 deadline;\n    }\n    // ========================================= Velodrome V3 =========================================\n\n    struct VelodromeMintParams {\n        address token0;\n        address token1;\n        int24 tickSpacing;\n        int24 tickLower;\n        int24 tickUpper;\n        uint256 amount0Desired;\n        uint256 amount1Desired;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        address recipient;\n        uint256 deadline;\n        uint160 sqrtPriceX96;\n    }\n\n    // ========================================= Karak =========================================\n\n    struct QueuedWithdrawal {\n        address staker;\n        address delegatedTo;\n        uint256 nonce;\n        uint256 start;\n        WithdrawRequest request;\n    }\n\n    struct WithdrawRequest {\n        address[] vaults;\n        uint256[] shares;\n        address withdrawer;\n    }\n\n    // ========================================= Term Finance ==================================\n\n    /// @dev TermAuctionOfferSubmission represents an offer submission to offeror an amount of money for a specific interest rate\n    struct TermAuctionOfferSubmission {\n        /// @dev For an existing offer this is the unique onchain identifier for this offer. For a new offer this is a randomized input that will be used to generate the unique onchain identifier.\n        bytes32 id;\n        /// @dev The address of the offeror\n        address offeror;\n        /// @dev Hash of the offered price as a percentage of the initial loaned amount vs amount returned at maturity. This stores 9 decimal places\n        bytes32 offerPriceHash;\n        /// @dev The maximum amount of purchase tokens that can be lent\n        uint256 amount;\n        /// @dev The address of the ERC20 purchase token\n        address purchaseToken;\n    }\n\n    // ========================================= Dolomite Finance ==================================\n\n    enum BalanceCheckFlag {\n        Both,\n        From,\n        To,\n        None\n    }\n\n    // ========================================= Silo Finance ==================================\n    /// @dev There are 2 types of accounting in the system: for non-borrowable collateral deposit called \"protected\" and\n    ///      for borrowable collateral deposit called \"collateral\". System does\n    ///      identical calculations for each type of accounting but it uses different data. To avoid code duplication\n    ///      this enum is used to decide which data should be read.\n    enum CollateralType {\n        Protected, // default\n        Collateral\n    }\n\n    enum ActionType {\n        Deposit,\n        Mint,\n        Repay,\n        RepayShares\n    }\n\n    struct Action {\n        // what do you want to do?\n        uint8 actionType;\n        // which Silo are you interacting with?\n        address silo;\n        // what asset do you want to use?\n        address asset;\n        // options specific for actions\n        bytes options;\n    }\n\n    struct AnyAction {\n        // how much assets or shares do you want to use?\n        uint256 amount;\n        // are you using Protected, Collateral\n        uint8 assetType;\n    }\n\n    // ========================================= LBTC Bridge ==================================\n    struct DepositBridgeAction {\n        uint256 fromChain;\n        bytes32 fromContract;\n        uint256 toChain;\n        address toContract;\n        address recipient;\n        uint64 amount;\n        uint256 nonce;\n    }\n\n    // ========================================= Odos ==================================\n    \n    struct swapTokenInfo {\n        address inputToken;\n        uint256 inputAmount;\n        address inputReceiver;\n        address outputToken;\n        uint256 outputQuote;\n        uint256 outputMin;\n        address outputReceiver;\n    }\n\n    struct swapTokenInfoOogaBooga {\n        address inputToken;\n        uint256 inputAmount;\n        address outputToken;\n        uint256 outputQuote;\n        uint256 outputMin;\n        address outputReceiver;\n    }\n    // ========================================= Level ==================================\n    \n    /// @dev for reference \n    //enum OrderType {\n    //    MINT,\n    //    REDEEM\n    //}\n    \n    struct LevelOrder {\n        uint8 order_type;\n        address benefactor;\n        address beneficiary;\n        address collateral_asset;\n        uint256 collateral_amount;\n        uint256 lvlusd_amount;\n    }    \n\n    struct Route {\n        address[] addresses;\n        uint256[] ratios;\n    }\n\n\n    // ========================================= Royco ==================================\n    struct APOffer { // RecipeMarketHub\n        uint256 offerID;\n        bytes32 targetMarketHash;\n        address ap;\n        address fundingVault;\n        uint256 quantity;\n        uint256 expiry;\n        address[] incentivesRequested;\n        uint256[] incentiveAmountsRequested;\n    }\n    struct APOfferVault { // VaultMarketHub (renamed to avoid collision)\n        uint256 offerID;\n        address targetVault;\n        address ap;\n        address fundingVault;\n        uint256 expiry;\n        address[] incentivesRequested;\n        uint256[] incentivesRatesRequested;\n    }\n\n    struct Reward {\n        uint48 startEpoch;\n        uint48 endEpoch;\n        address token;\n        uint256 rewardRate;\n    }\n\n    // ========================================= Permit2 ==================================\n    \n    struct TokenSpenderPair {\n        address token; \n        address spender;\n    }\n\n    // ========================================= OnChainQueue ==================================\n    \n    struct OnChainWithdraw {\n        uint96 nonce; // read from state, used to make it impossible for request Ids to be repeated.\n        address user; // msg.sender\n        address assetOut; // input sanitized\n        uint128 amountOfShares; // input transfered in\n        uint128 amountOfAssets; // derived from amountOfShares and price\n        uint40 creationTime; // time withdraw was made\n        uint24 secondsToMaturity; // in contract, from withdrawAsset?\n        uint24 secondsToDeadline; // in contract, from withdrawAsset? To get the deadline you take the creationTime add seconds to maturity, add the secondsToDeadline\n    }\n}\n\n"
    }
  },
  "settings": {
    "remappings": [
      "@solmate/=lib/solmate/src/",
      "@forge-std/=lib/forge-std/src/",
      "@ds-test/=lib/forge-std/lib/ds-test/src/",
      "ds-test/=lib/forge-std/lib/ds-test/src/",
      "@openzeppelin/=lib/openzeppelin-contracts/",
      "@ccip/=lib/ccip/",
      "@oapp-auth/=lib/OAppAuth/src/",
      "@devtools-oapp-evm/=lib/OAppAuth/lib/devtools/packages/oapp-evm/contracts/oapp/",
      "@layerzerolabs/lz-evm-messagelib-v2/=lib/OAppAuth/node_modules/@layerzerolabs/lz-evm-messagelib-v2/",
      "@layerzerolabs/lz-evm-protocol-v2/=lib/OAppAuth/lib/LayerZero-V2/packages/layerzero-v2/evm/protocol/",
      "@layerzerolabs/oapp-evm/=lib/OAppAuth/lib/devtools/packages/oapp-evm/",
      "@lz-oapp-evm/=lib/OAppAuth/lib/LayerZero-V2/packages/layerzero-v2/evm/oapp/contracts/oapp/",
      "LayerZero-V2/=lib/OAppAuth/lib/",
      "OAppAuth/=lib/OAppAuth/",
      "ccip/=lib/ccip/contracts/",
      "erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/",
      "forge-std/=lib/forge-std/src/",
      "halmos-cheatcodes/=lib/OAppAuth/lib/openzeppelin-contracts/lib/halmos-cheatcodes/src/",
      "openzeppelin-contracts/=lib/openzeppelin-contracts/",
      "solidity-bytes-utils/=lib/OAppAuth/node_modules/solidity-bytes-utils/",
      "solmate/=lib/solmate/src/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "metadata": {
      "useLiteralContent": false,
      "bytecodeHash": "ipfs",
      "appendCBOR": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "evmVersion": "shanghai",
    "viaIR": false,
    "libraries": {}
  }
}}