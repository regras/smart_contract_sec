{{
  "language": "Solidity",
  "sources": {
    "src/proposals/20250501/SparkEthereum_20250501.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.25;\n\nimport { Ethereum } from 'spark-address-registry/Ethereum.sol';\n\nimport { ICapAutomator } from \"sparklend-cap-automator/interfaces/ICapAutomator.sol\";\n\nimport { SparkPayloadEthereum } from \"../../SparkPayloadEthereum.sol\";\n\n/**\n * @title  May 1, 2025 Spark Ethereum Proposal\n * @notice Spark Liquidity Layer:\n *         - Onboard SparkLend USDT\n *         - Onboard AAVE Core USDT\n *         SparkLend:\n *         - Update DAI IRM\n *         - Update USDS IRM\n *         - Update USDC IRM\n *         - Update USDT IRM\n *         - Adjust USDT Cap Automator Parameters\n * @author Phoenix Labs\n * Forum:  https://forum.sky.money/t/may-1-2025-proposed-changes-to-spark-for-upcoming-spell/26288\n * Vote:   https://vote.makerdao.com/polling/QmfJ5yDF\n *         https://vote.makerdao.com/polling/QmQM99z5\n *         https://vote.makerdao.com/polling/Qmdc28Ag\n *         https://vote.makerdao.com/polling/QmeNB8S1\n *         https://vote.makerdao.com/polling/Qmee2jez\n *         https://vote.makerdao.com/polling/QmfBmrxq\n *         https://vote.makerdao.com/polling/QmZ2vydY\n */\ncontract SparkEthereum_20250501 is SparkPayloadEthereum {\n\n    address constant DAI_USDS_IRM  = 0x7729E1CE24d7c4A82e76b4A2c118E328C35E6566;  // DAI  and USDS use the same params, same IRM\n    address constant USDC_USDT_IRM = 0x7F2fc6A7E3b3c658A84999b26ad2013C4Dc87061;  // USDC and USDT use the same params, same IRM\n\n    address constant AAVE_CORE_AUSDT = 0x23878914EFE38d27C4D67Ab83ed1b93A74D4086a;\n\n    function _postExecute() internal override {\n        LISTING_ENGINE.POOL_CONFIGURATOR().setReserveInterestRateStrategyAddress(Ethereum.DAI,  DAI_USDS_IRM);\n        LISTING_ENGINE.POOL_CONFIGURATOR().setReserveInterestRateStrategyAddress(Ethereum.USDS, DAI_USDS_IRM);\n        LISTING_ENGINE.POOL_CONFIGURATOR().setReserveInterestRateStrategyAddress(Ethereum.USDC, USDC_USDT_IRM);\n        LISTING_ENGINE.POOL_CONFIGURATOR().setReserveInterestRateStrategyAddress(Ethereum.USDT, USDC_USDT_IRM);\n\n        _onboardAaveToken(Ethereum.USDT_ATOKEN, 100_000_000e6, uint256(50_000_000e6) / 1 days);\n        _onboardAaveToken(AAVE_CORE_AUSDT,      50_000_000e6,  uint256(25_000_000e6) / 1 days);\n\n        ICapAutomator capAutomator = ICapAutomator(Ethereum.CAP_AUTOMATOR);\n\n        capAutomator.setSupplyCapConfig({ asset: Ethereum.USDT, max: 500_000_000, gap: 100_000_000, increaseCooldown: 12 hours });\n        capAutomator.setBorrowCapConfig({ asset: Ethereum.USDT, max: 450_000_000, gap: 50_000_000,  increaseCooldown: 12 hours });\n    }\n\n}\n"
    },
    "lib/spark-address-registry/src/Ethereum.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity >=0.8.0;\n\nlibrary Ethereum {\n\n    /******************************************************************************************************************/\n    /*** Token Addresses                                                                                            ***/\n    /******************************************************************************************************************/\n\n    address internal constant CBBTC  = 0xcbB7C0000aB88B473b1f5aFd9ef808440eed33Bf;\n    address internal constant DAI    = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n    address internal constant EZETH  = 0xbf5495Efe5DB9ce00f80364C8B423567e58d2110;\n    address internal constant GNO    = 0x6810e776880C02933D47DB1b9fc05908e5386b96;\n    address internal constant LBTC   = 0x8236a87084f8B84306f72007F36F2618A5634494;\n    address internal constant MKR    = 0x9f8F72aA9304c8B593d555F12eF6589cC3A579A2;\n    address internal constant RETH   = 0xae78736Cd615f374D3085123A210448E74Fc6393;\n    address internal constant RSETH  = 0xA1290d69c65A6Fe4DF752f95823fae25cB99e5A7;\n    address internal constant SDAI   = 0x83F20F44975D03b1b09e64809B757c47f942BEeA;\n    address internal constant SUSDC  = 0xBc65ad17c5C0a2A4D159fa5a503f4992c7B545FE;\n    address internal constant SUSDE  = 0x9D39A5DE30e57443BfF2A8307A4256c8797A3497;\n    address internal constant SUSDS  = 0xa3931d71877C0E7a3148CB7Eb4463524FEc27fbD;\n    address internal constant TBTC   = 0x18084fbA666a33d37592fA2633fD49a74DD93a88;\n    address internal constant USDC   = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\n    address internal constant USDE   = 0x4c9EDD5852cd905f086C759E8383e09bff1E68B3;\n    address internal constant USDS   = 0xdC035D45d973E3EC169d2276DDab16f1e407384F;\n    address internal constant USCC   = 0x14d60E7FDC0D71d8611742720E4C50E7a974020c;\n    address internal constant USDT   = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\n    address internal constant USTB   = 0x43415eB6ff9DB7E26A15b704e7A3eDCe97d31C4e;\n    address internal constant WBTC   = 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599;\n    address internal constant WEETH  = 0xCd5fE23C85820F7B72D0926FC9b05b43E359b7ee;\n    address internal constant WETH   = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address internal constant WSTETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;\n\n    /******************************************************************************************************************/\n    /*** MakerDAO Addresses                                                                                         ***/\n    /******************************************************************************************************************/\n\n    address internal constant CHIEF       = 0x0a3f6849f78076aefaDf113F5BED87720274dDC0;\n    address internal constant DAI_USDS    = 0x3225737a9Bbb6473CB4a45b7244ACa2BeFdB276A;\n    address internal constant PAUSE_PROXY = 0xBE8E3e3618f7474F8cB1d074A26afFef007E98FB;\n    address internal constant POT         = 0x197E90f9FAD81970bA7976f33CbD77088E5D7cf7;\n    address internal constant PSM         = 0xf6e72Db5454dd049d0788e411b06CfAF16853042;  // Lite PSM\n    address internal constant VAT         = 0x35D1b3F3D7966A1DFe207aa4514C12a259A0492B;\n\n    /******************************************************************************************************************/\n    /*** SparkDAO Addresses                                                                                         ***/\n    /******************************************************************************************************************/\n\n    address internal constant SPARK_PROXY   = 0x3300f198988e4C9C63F75dF86De36421f06af8c4;\n    address internal constant SPARK_REWARDS = 0xbaf21A27622Db71041Bd336a573DDEdC8eB65122;\n\n    /******************************************************************************************************************/\n    /*** Allocation System Addresses                                                                                ***/\n    /******************************************************************************************************************/\n\n    address internal constant ALLOCATOR_BUFFER   = 0xc395D150e71378B47A1b8E9de0c1a83b75a08324;\n    address internal constant ALLOCATOR_ORACLE   = 0xc7B91C401C02B73CBdF424dFaaa60950d5040dB7;\n    address internal constant ALLOCATOR_REGISTRY = 0xCdCFA95343DA7821fdD01dc4d0AeDA958051bB3B;\n    address internal constant ALLOCATOR_ROLES\t = 0x9A865A710399cea85dbD9144b7a09C889e94E803;\n    address internal constant ALLOCATOR_VAULT\t = 0x691a6c29e9e96dd897718305427Ad5D534db16BA;\n\n    /******************************************************************************************************************/\n    /*** Spark Liquidity Layer Addresses                                                                            ***/\n    /******************************************************************************************************************/\n\n    address internal constant ALM_CONTROLLER  = 0xF8Dff673b555a225e149218C5005FC88f4a13870;\n    address internal constant ALM_PROXY       = 0x1601843c5E9bC251A3272907010AFa41Fa18347E;\n    address internal constant ALM_RATE_LIMITS = 0x7A5FD5cf045e010e62147F065cEAe59e5344b188;\n\n    address internal constant ALM_FREEZER  = 0x90D8c80C028B4C09C0d8dcAab9bbB057F0513431;\n    address internal constant ALM_RELAYER  = 0x8a25A24EDE9482C4Fc0738F99611BE58F1c839AB;\n    address internal constant ALM_RELAYER2 = 0x8Cc0Cb0cfB6B7e548cfd395B833c05C346534795;\n\n    /******************************************************************************************************************/\n    /*** Ethena Addresses                                                                                           ***/\n    /******************************************************************************************************************/\n\n    address internal constant ETHENA_MINTER = 0xe3490297a08d6fC8Da46Edb7B6142E4F461b62D3;\n\n    /******************************************************************************************************************/\n    /*** Aave Addresses                                                                                             ***/\n    /******************************************************************************************************************/\n\n    address internal constant ATOKEN_CORE_USDS = 0x32a6268f9Ba3642Dda7892aDd74f1D34469A4259;\n    address internal constant ATOKEN_CORE_USDC = 0x98C23E9d8f34FEFb1B7BD6a91B7FF122F4e16F5c;\n\n    /******************************************************************************************************************/\n    /*** Blackrock BUIDL Addresses                                                                                  ***/\n    /******************************************************************************************************************/\n\n    address internal constant BUIDL          = 0x7712c34205737192402172409a8F7ccef8aA2AEc;\n    address internal constant BUIDL_REDEEM   = 0x31D3F59Ad4aAC0eeE2247c65EBE8Bf6E9E470a53;  // Circle redeem\n    address internal constant BUIDLI         = 0x6a9DA2D710BB9B700acde7Cb81F10F1fF8C89041;\n    address internal constant BUIDLI_DEPOSIT = 0xD1917664bE3FdAea377f6E8D5BF043ab5C3b1312;\n    address internal constant BUIDLI_REDEEM  = 0x8780Dd016171B91E4Df47075dA0a947959C34200;  // Offchain redeem\n\n    /******************************************************************************************************************/\n    /*** Centrifuge Addresses                                                                                       ***/\n    /******************************************************************************************************************/\n\n    address internal constant JTRSY       = 0x8c213ee79581Ff4984583C6a801e5263418C4b86;\n    address internal constant JTRSY_VAULT = 0x36036fFd9B1C6966ab23209E073c68Eb9A992f50;\n\n    /******************************************************************************************************************/\n    /*** Curve Addresses                                                                                            ***/\n    /******************************************************************************************************************/\n\n    address internal constant CURVE_SUSDSUSDT = 0x00836Fe54625BE242BcFA286207795405ca4fD10;\n    address internal constant CURVE_USDCUSDT  = 0x4f493B7dE8aAC7d55F71853688b1F7C8F0243C85;\n\n    /******************************************************************************************************************/\n    /*** Fluid Addresses                                                                                            ***/\n    /******************************************************************************************************************/\n\n    address internal constant FLUID_SUSDS = 0x2BBE31d63E6813E3AC858C04dae43FB2a72B0D11;\n\n    /******************************************************************************************************************/\n    /*** Maple Addresses                                                                                            ***/\n    /******************************************************************************************************************/\n\n    address internal constant SYRUP_USDC = 0x80ac24aA929eaF5013f6436cdA2a7ba190f5Cc0b;\n\n    /******************************************************************************************************************/\n    /*** Morpho Addresses                                                                                           ***/\n    /******************************************************************************************************************/\n\n    address internal constant MORPHO              = 0xBBBBBbbBBb9cC5e90e3b3Af64bdAF62C37EEFFCb;\n    address internal constant MORPHO_DEFAULT_IRM  = 0x870aC11D48B15DB9a138Cf899d20F13F79Ba00BC;\n    address internal constant MORPHO_SUSDE_ORACLE = 0x5D916980D5Ae1737a8330Bf24dF812b2911Aae25;\n    address internal constant MORPHO_USDE_ORACLE  = 0xaE4750d0813B5E37A51f7629beedd72AF1f9cA35;\n    address internal constant MORPHO_VAULT_DAI_1  = 0x73e65DBD630f90604062f6E02fAb9138e713edD9;\n\n    /******************************************************************************************************************/\n    /*** Superstate Addresses                                                                                       ***/\n    /******************************************************************************************************************/\n\n    address internal constant SUPERSTATE_REDEMPTION = 0x4c21B7577C8FE8b0B0669165ee7C8f67fa1454Cf;\n\n    /******************************************************************************************************************/\n    /*** SparkLend - Core Protocol Addresses                                                                        ***/\n    /******************************************************************************************************************/\n\n    address internal constant AAVE_ORACLE                      = 0x8105f69D9C41644c6A0803fDA7D03Aa70996cFD9;\n    address internal constant ACL_MANAGER                      = 0xdA135Cd78A086025BcdC87B038a1C462032b510C;\n    address internal constant DAI_TREASURY                     = 0x856900aa78e856a5df1a2665eE3a66b2487cD68f;\n    address internal constant EMISSION_MANAGER                 = 0xf09e48dd4CA8e76F63a57ADd428bB06fee7932a4;\n    address internal constant INCENTIVES                       = 0x4370D3b6C9588E02ce9D22e684387859c7Ff5b34;\n    address internal constant POOL                             = 0xC13e21B648A5Ee794902342038FF3aDAB66BE987;\n    address internal constant POOL_ADDRESSES_PROVIDER          = 0x02C3eA4e34C0cBd694D2adFa2c690EECbC1793eE;\n    address internal constant POOL_ADDRESSES_PROVIDER_REGISTRY = 0x03cFa0C4622FF84E50E75062683F44c9587e6Cc1;\n    address internal constant POOL_CONFIGURATOR                = 0x542DBa469bdE58FAeE189ffB60C6b49CE60E0738;\n    address internal constant TREASURY                         = 0xb137E7d16564c81ae2b0C8ee6B55De81dd46ECe5;\n    address internal constant TREASURY_CONTROLLER              = 0x92eF091C5a1E01b3CE1ba0D0150C84412d818F7a;\n    address internal constant WETH_GATEWAY                     = 0xBD7D6a9ad7865463DE44B05F04559f65e3B11704;\n\n    /******************************************************************************************************************/\n    /*** SparkLend - Reserve Token Addresses                                                                        ***/\n    /******************************************************************************************************************/\n\n    address internal constant CBBTC_ATOKEN            = 0xb3973D459df38ae57797811F2A1fd061DA1BC123;\n    address internal constant CBBTC_STABLE_DEBT_TOKEN = 0x26a76E2fa1EaDbe7C30f0c333059Bcc3642c28d2;\n    address internal constant CBBTC_DEBT_TOKEN        = 0x661fE667D2103eb52d3632a3eB2cAbd123F27938;\n\n    address internal constant DAI_ATOKEN             = 0x4DEDf26112B3Ec8eC46e7E31EA5e123490B05B8B;\n    address internal constant DAI_STABLE_DEBT_TOKEN  = 0xfe2B7a7F4cC0Fb76f7Fc1C6518D586F1e4559176;\n    address internal constant DAI_DEBT_TOKEN         = 0xf705d2B7e92B3F38e6ae7afaDAA2fEE110fE5914;\n\n    address internal constant GNO_ATOKEN             = 0x7b481aCC9fDADDc9af2cBEA1Ff2342CB1733E50F;\n    address internal constant GNO_STABLE_DEBT_TOKEN  = 0xbf13910620722D4D4F8A03962894EB3335Bf4FaE;\n    address internal constant GNO_DEBT_TOKEN         = 0x57a2957651DA467fCD4104D749f2F3684784c25a;\n\n    address internal constant RETH_ATOKEN             = 0x9985dF20D7e9103ECBCeb16a84956434B6f06ae8;\n    address internal constant RETH_STABLE_DEBT_TOKEN  = 0xa9a4037295Ea3a168DC3F65fE69FdA524d52b3e1;\n    address internal constant RETH_DEBT_TOKEN         = 0xBa2C8F2eA5B56690bFb8b709438F049e5Dd76B96;\n\n    address internal constant SDAI_ATOKEN             = 0x78f897F0fE2d3B5690EbAe7f19862DEacedF10a7;\n    address internal constant SDAI_STABLE_DEBT_TOKEN  = 0xEc6C6aBEd4DC03299EFf82Ac8A0A83643d3cB335;\n    address internal constant SDAI_DEBT_TOKEN         = 0xaBc57081C04D921388240393ec4088Aa47c6832B;\n\n    address internal constant USDC_ATOKEN             = 0x377C3bd93f2a2984E1E7bE6A5C22c525eD4A4815;\n    address internal constant USDC_STABLE_DEBT_TOKEN  = 0x887Ac022983Ff083AEb623923789052A955C6798;\n    address internal constant USDC_DEBT_TOKEN         = 0x7B70D04099CB9cfb1Db7B6820baDAfB4C5C70A67;\n\n    address internal constant USDT_ATOKEN             = 0xe7dF13b8e3d6740fe17CBE928C7334243d86c92f;\n    address internal constant USDT_STABLE_DEBT_TOKEN  = 0x0Dae62F953Ceb2E969fB4dE85f3F9074fa920776;\n    address internal constant USDT_DEBT_TOKEN         = 0x529b6158d1D2992E3129F7C69E81a7c677dc3B12;\n\n    address internal constant WBTC_ATOKEN             = 0x4197ba364AE6698015AE5c1468f54087602715b2;\n    address internal constant WBTC_STABLE_DEBT_TOKEN  = 0x4b29e6cBeE62935CfC92efcB3839eD2c2F35C1d9;\n    address internal constant WBTC_DEBT_TOKEN         = 0xf6fEe3A8aC8040C3d6d81d9A4a168516Ec9B51D2;\n\n    address internal constant WEETH_ATOKEN            = 0x3CFd5C0D4acAA8Faee335842e4f31159fc76B008;\n    address internal constant WEETH_STABLE_DEBT_TOKEN = 0x5B1F8aF3E6C0BF4d20e8e5220a4e4A3A8fA6Dc0A;\n    address internal constant WEETH_DEBT_TOKEN        = 0xc2bD6d2fEe70A0A73a33795BdbeE0368AeF5c766;\n\n    address internal constant WETH_ATOKEN             = 0x59cD1C87501baa753d0B5B5Ab5D8416A45cD71DB;\n    address internal constant WETH_STABLE_DEBT_TOKEN  = 0x3c6b93D38ffA15ea995D1BC950d5D0Fa6b22bD05;\n    address internal constant WETH_DEBT_TOKEN         = 0x2e7576042566f8D6990e07A1B61Ad1efd86Ae70d;\n\n    address internal constant WSTETH_ATOKEN            = 0x12B54025C112Aa61fAce2CDB7118740875A566E9;\n    address internal constant WSTETH_STABLE_DEBT_TOKEN = 0x9832D969a0c8662D98fFf334A4ba7FeE62b109C2;\n    address internal constant WSTETH_DEBT_TOKEN        = 0xd5c3E3B566a42A6110513Ac7670C1a86D76E13E6;\n\n    /******************************************************************************************************************/\n    /*** SparkLend - Auxiliary Protocol Addresses                                                                   ***/\n    /******************************************************************************************************************/\n\n    address internal constant CAP_AUTOMATOR      = 0x2276f52afba7Cf2525fd0a050DF464AC8532d0ef;\n    address internal constant FREEZER_MOM        = 0x237e3985dD7E373F2ec878EC1Ac48A228Cf2e7a3;\n    address internal constant KILL_SWITCH_ORACLE = 0x909A86f78e1cdEd68F9c2Fe2c9CD922c401abe82;\n\n    /******************************************************************************************************************/\n    /*** SparkLend - Emergency Spells                                                                               ***/\n    /******************************************************************************************************************/\n\n    address internal constant SPELL_FREEZE_ALL       = 0x9e2890BF7f8D5568Cc9e5092E67Ba00C8dA3E97f;\n    address internal constant SPELL_FREEZE_DAI       = 0xa2039bef2c5803d66E4e68F9E23a942E350b938c;\n    address internal constant SPELL_PAUSE_ALL        = 0x425b0de240b4c2DC45979DB782A355D090Dc4d37;\n    address internal constant SPELL_PAUSE_DAI        = 0xCacB88e39112B56278db25b423441248cfF94241;\n    address internal constant SPELL_REMOVE_MULTISIG  = 0xE47AB4919F6F5459Dcbbfbe4264BD4630c0169A9;\n\n    /******************************************************************************************************************/\n    /*** SparkLend - Implementation Addresses                                                                       ***/\n    /******************************************************************************************************************/\n\n    address internal constant A_TOKEN_IMPL             = 0x6175ddEc3B9b38c88157C10A01ed4A3fa8639cC6;\n    address internal constant DAI_TREASURY_IMPL        = 0xF1E57711Eb5F897b415de1aEFCB64d9BAe58D312;\n    address internal constant INCENTIVES_IMPL          = 0x0ee554F6A1f7a4Cb4f82D4C124DdC2AD3E37fde1;\n    address internal constant POOL_CONFIGURATOR_IMPL   = 0xF7b656C95420194b79687fc86D965FB51DA4799F;\n    address internal constant POOL_IMPL                = 0x5aE329203E00f76891094DcfedD5Aca082a50e1b;\n    address internal constant STABLE_DEBT_TOKEN_IMPL   = 0x026a5B6114431d8F3eF2fA0E1B2EDdDccA9c540E;\n    address internal constant TREASURY_IMPL            = 0xF1E57711Eb5F897b415de1aEFCB64d9BAe58D312;\n    address internal constant VARIABLE_DEBT_TOKEN_IMPL = 0x86C71796CcDB31c3997F8Ec5C2E3dB3e9e40b985;\n\n    /******************************************************************************************************************/\n    /*** SparkLend - Config Engine Addresses                                                                        ***/\n    /******************************************************************************************************************/\n\n    address internal constant CONFIG_ENGINE             = 0x3254F7cd0565aA67eEdC86c2fB608BE48d5cCd78;\n    address internal constant PROXY_ADMIN               = 0x883A82BDd3d07ae6ACfD151020faD350df25087e;\n    address internal constant RATES_FACTORY             = 0xfE57e187EF6285e90d7049e6a21571aa47cF11a2;\n    address internal constant TRANSPARENT_PROXY_FACTORY = 0x777803CbDD89D5D5Bc1DdD2151B51b0B07F6bf37;\n\n    /******************************************************************************************************************/\n    /*** SparkLend - Data Provider Addresses                                                                        ***/\n    /******************************************************************************************************************/\n\n    address internal constant PROTOCOL_DATA_PROVIDER     = 0xFc21d6d146E6086B8359705C8b28512a983db0cb;\n    address internal constant UI_INCENTIVE_DATA_PROVIDER = 0xA7F8A757C4f7696c015B595F51B2901AC0121B18;\n    address internal constant UI_POOL_DATA_PROVIDER      = 0xF028c2F4b19898718fD0F77b9b881CbfdAa5e8Bb;\n    address internal constant WALLET_BALANCE_PROVIDER    = 0xd2AeF86F51F92E8e49F42454c287AE4879D1BeDc;\n\n    /******************************************************************************************************************/\n    /*** SparkLend - Library Addresses                                                                              ***/\n    /******************************************************************************************************************/\n\n    address internal constant BORROW_LOGIC      = 0x4662C88C542F0954F8CccCDE4542eEc32d7E7e9a;\n    address internal constant BRIDGE_LOGIC      = 0x2C54924711E479E639032704146b865E12f0C6D1;\n    address internal constant EMODE_LOGIC       = 0x2Ad00613A66D71Ff2B0607fB3C4632C47a50DADe;\n    address internal constant FLASH_LOAN_LOGIC  = 0x7f44e1c1dE70059D7cc483378BEFeE2a030CE247;\n    address internal constant LIQUIDATION_LOGIC = 0x6aEa92693C527bC2c7B3171C6f2598d67d619088;\n    address internal constant POOL_LOGIC        = 0x1761a0f74032963B6Ad0774C5EBF4586c0bD7604;\n    address internal constant SUPPLY_LOGIC      = 0x46256841e36b7557BB8e4c706beD38b17A9EB2c1;\n\n    /******************************************************************************************************************/\n    /*** Cross-Domain Addresses                                                                                     ***/\n    /******************************************************************************************************************/\n\n    address internal constant CCTP_TOKEN_MESSENGER = 0xBd3fa81B58Ba92a82136038B25aDec7066af3155;\n\n    address internal constant OPTIMISM_DSR_FORWARDER    = 0x4042127DecC0cF7cc0966791abebf7F76294DeF3;\n    address internal constant WORLD_CHAIN_DSR_FORWARDER = 0xA34437dAAE56A7CC6DC757048933D7777b3e547B;\n\n    /******************************************************************************************************************/\n    /*** Arbitrum Addresses                                                                                         ***/\n    /******************************************************************************************************************/\n\n    address internal constant ARBITRUM_DSR_FORWARDER = 0x7F36E7F562Ee3f320644F6031e03E12a02B85799;\n    address internal constant ARBITRUM_SSR_FORWARDER = 0x1A229AdbAC83A948226783F2A3257B52006247D5;\n\n    address internal constant ARBITRUM_ESCROW        = 0xA10c7CE4b876998858b1a9E12b10092229539400;\n    address internal constant ARBITRUM_SKY_GOV_RELAY = 0x9ba25c289e351779E0D481Ba37489317c34A899d;\n    address internal constant ARBITRUM_TOKEN_BRIDGE  = 0x84b9700E28B23F873b82c1BEb23d86C091b6079E;\n\n    /******************************************************************************************************************/\n    /*** Base Addresses                                                                                             ***/\n    /******************************************************************************************************************/\n\n    address internal constant BASE_DSR_FORWARDER = 0x8Ed551D485701fe489c215E13E42F6fc59563e0e;\n    address internal constant BASE_SSR_FORWARDER = 0xB2833392527f41262eB0E3C7b47AFbe030ef188E;\n\n    address internal constant BASE_ESCROW        = 0x7F311a4D48377030bD810395f4CCfC03bdbe9Ef3;\n    address internal constant BASE_SKY_GOV_RELAY = 0x1Ee0AE8A993F2f5abDB51EAF4AC2876202b65c3b;\n    address internal constant BASE_TOKEN_BRIDGE  = 0xA5874756416Fa632257eEA380CAbd2E87cED352A;\n\n    /******************************************************************************************************************/\n    /*** Multisigs                                                                                                  ***/\n    /******************************************************************************************************************/\n\n    address internal constant FREEZER_MULTISIG           = 0x44efFc473e81632B12486866AA1678edbb7BEeC3;\n    address internal constant SPARKLEND_REWARDS_MULTISIG = 0x8076807464DaC94Ac8Aa1f7aF31b58F73bD88A27;\n    address internal constant SPARK_REWARDS_MULTISIG     = 0xF649956f43825d4d7295a50EDdBe1EDC814A3a83;\n\n    /******************************************************************************************************************/\n    /*** User Action Addresses                                                                                      ***/\n    /******************************************************************************************************************/\n\n    address internal constant USER_ACTIONS_PSM_VARIANT1 = 0x52d298Ff9e77E71C2EB1992260520E7b15257d99;\n\n}\n"
    },
    "lib/sparklend-cap-automator/src/interfaces/ICapAutomator.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.13;\n\nimport { IPool }             from \"aave-v3-core/contracts/interfaces/IPool.sol\";\nimport { IPoolConfigurator } from \"aave-v3-core/contracts/interfaces/IPoolConfigurator.sol\";\n\ninterface ICapAutomator {\n\n    /**********************************************************************************************/\n    /*** Events                                                                                 ***/\n    /**********************************************************************************************/\n\n    /**\n     *  @dev   Event to log the setting of a new supply cap config.\n     *  @param asset            The address of the asset for which the config was set.\n     *  @param max              Maximum allowed supply cap.\n     *  @param gap              A gap between the supply and the supply cap that is being maintained.\n     *  @param increaseCooldown A minimum period of time that needs to elapse between consequent cap increases.\n     */\n    event SetSupplyCapConfig(address indexed asset, uint256 max, uint256 gap, uint256 increaseCooldown);\n\n    /**\n     *  @dev   Event to log the setting of a new borrow cap config.\n     *  @param asset            The address of the asset for which the config was set.\n     *  @param max              Maximum allowed borrow cap.\n     *  @param gap              A gap between the borrows and the borrow cap that is being maintained.\n     *  @param increaseCooldown A minimum period of time that needs to elapse between consequent cap increases.\n     */\n    event SetBorrowCapConfig(address indexed asset, uint256 max, uint256 gap, uint256 increaseCooldown);\n\n    /**\n     *  @dev   Event to log the removing of a supply cap config.\n     *  @param asset The address of the asset for which supply config was removed.\n     */\n    event RemoveSupplyCapConfig(address indexed asset);\n\n    /**\n     *  @dev   Event to log the removing of a borrow cap config.\n     *  @param asset The address of the asset for which borrow config was removed.\n     */\n    event RemoveBorrowCapConfig(address indexed asset);\n\n    /**\n     *  @dev   Event to log the update of the supply cap.\n     *  @param asset        The address of the asset which supply cap was updated.\n     *  @param oldSupplyCap The old supply cap.\n     *  @param newSupplyCap The newly set supply cap.\n     */\n    event UpdateSupplyCap(address indexed asset, uint256 oldSupplyCap, uint256 newSupplyCap);\n\n    /**\n     *  @dev   Event to log the update of the borrow cap.\n     *  @param asset        The address of the asset which borrow cap was updated.\n     *  @param oldBorrowCap The old borrow cap.\n     *  @param newBorrowCap The newly set borrow cap.\n     */\n    event UpdateBorrowCap(address indexed asset, uint256 oldBorrowCap, uint256 newBorrowCap);\n\n    /**********************************************************************************************/\n    /*** Storage Variables                                                                      ***/\n    /**********************************************************************************************/\n\n    /**\n     *  @dev    Returns the address of the pool configurator.\n     *  @return poolConfigurator The address of the pool configurator.\n     */\n    function poolConfigurator() external view returns (IPoolConfigurator poolConfigurator);\n\n    /**\n     *  @dev    Returns the address of the data provider.\n     *  @return pool The address of the data provider.\n     */\n    function pool() external view returns (IPool pool);\n\n    /**\n     *  @dev    Returns current configuration for automatic supply cap management.\n     *  @param  asset            The address of the asset which config is going to be returned.\n     *  @return max              Maximum allowed supply cap.\n     *  @return gap              A gap between the supply and the supply cap that is being maintained.\n     *  @return increaseCooldown A minimum period of time that needs to elapse between consequent cap increases.\n     *  @return lastUpdateBlock  The block of the last cap update.\n     *  @return lastIncreaseTime The timestamp of the last cap increase.\n     */\n    function supplyCapConfigs(address asset) external view returns (\n        uint48 max,\n        uint48 gap,\n        uint48 increaseCooldown,\n        uint48 lastUpdateBlock,\n        uint48 lastIncreaseTime\n    );\n\n    /**\n     *  @dev    Returns current configuration for automatic borrow cap management.\n     *  @param  asset            The address of the asset which config is going to be returned.\n     *  @return max              Maximum allowed borrow cap.\n     *  @return gap              A gap between the borrows and the borrow cap that is being maintained.\n     *  @return increaseCooldown A minimum period of time that needs to elapse between consequent cap increases.\n     *  @return lastUpdateBlock  The block of the last cap update.\n     *  @return lastIncreaseTime The timestamp of the last cap increase.\n     */\n    function borrowCapConfigs(address asset) external view returns (\n        uint48 max,\n        uint48 gap,\n        uint48 increaseCooldown,\n        uint48 lastUpdateBlock,\n        uint48 lastIncreaseTime\n    );\n\n    /**********************************************************************************************/\n    /*** Owner Functions                                                                        ***/\n    /**********************************************************************************************/\n\n    /**\n     *  @dev   Function creating (or re-setting) a configuration for automatic supply cap management.\n     *  @param asset            The address of the asset that is going to be managed.\n     *  @param max              Maximum allowed supply cap.\n     *  @param gap              A gap between the supply and the supply cap that is being maintained.\n     *  @param increaseCooldown A minimum period of time that needs to elapse between consequent cap increases.\n     */\n    function setSupplyCapConfig(\n        address asset,\n        uint256 max,\n        uint256 gap,\n        uint256 increaseCooldown\n    ) external;\n\n    /**\n     *  @dev   Function creating (or re-setting) a configuration for automatic borrow cap management.\n     *  @param asset            The address of the asset that is going to be managed.\n     *  @param max              Maximum allowed borrow cap.\n     *  @param gap              A gap between the borrows and the borrow cap that is being maintained.\n     *  @param increaseCooldown A minimum period of time that needs to elapse between consequent cap increases.\n     */\n    function setBorrowCapConfig(\n        address asset,\n        uint256 max,\n        uint256 gap,\n        uint256 increaseCooldown\n    ) external;\n\n    /**\n     *  @dev   Function removing a configuration for automatic supply cap management.\n     *  @param asset The address of the asset for which the configuration is going to be removed.\n     */\n    function removeSupplyCapConfig(address asset) external;\n\n    /**\n     *  @dev   Function removing a configuration for automatic borrow cap management.\n     *  @param asset The address of the asset for which the configuration is going to be removed.\n     */\n    function removeBorrowCapConfig(address asset) external;\n\n    /**********************************************************************************************/\n    /*** Public Functions                                                                       ***/\n    /**********************************************************************************************/\n\n    /**\n     *  @dev    A public function that updates supply cap on market of a given asset.\n     *          The supply cap is going to be set to the value equal\n     *          to the sum of current supply and the supply cap gap.\n     *          The cap is only going to be increased if the required cooldown time has passed.\n     *          Calling this function more than once per block will not have any additional effect.\n     *  @param  asset        The address of the asset which cap is going to be updated.\n     *  @return newSupplyCap A newly set supply cap, or the old one if it was not updated.\n     */\n    function execSupply(address asset) external returns (uint256 newSupplyCap);\n\n    /**\n     *  @dev    A public function that updates borrow cap on market of a given asset.\n     *          The borrow cap is going to be set to the values equal\n     *          to the sum of current borrows and the borrow cap gap.\n     *          The caps is only going to be increased if the required cooldown time has passed.\n     *          Calling this function more than once per block will not have any additional effect.\n     *  @param  asset        The address of the asset which cap is going to be updated.\n     *  @return newBorrowCap A newly set borrow cap, or the old one if it was not updated.\n     */\n    function execBorrow(address asset) external returns (uint256 newBorrowCap);\n\n    /**\n     *  @dev    A public function that updates supply and borrow caps on market of a given asset.\n     *          The supply and borrow caps are going to be set to, respectively, the values equal\n     *          to the sum of current supply and the supply cap gap and the sum of current borrows and the borrow cap gap.\n     *          The caps are only going to be increased if the required cooldown time has passed.\n     *          Calling this function more than once per block will not have any additional effect.\n     *  @param  asset        The address of the asset which caps are going to be updated.\n     *  @return newSupplyCap A newly set supply cap, or the old one if it was not updated.\n     *  @return newBorrowCap A newly set borrow cap, or the old one if it was not updated.\n     */\n    function exec(address asset) external returns (uint256 newSupplyCap, uint256 newBorrowCap);\n}\n"
    },
    "src/SparkPayloadEthereum.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\nimport './AaveV3PayloadBase.sol';\n\nimport { Arbitrum } from 'spark-address-registry/Arbitrum.sol';\nimport { Base }     from 'spark-address-registry/Base.sol';\nimport { Ethereum } from 'spark-address-registry/Ethereum.sol';\nimport { Gnosis }   from 'spark-address-registry/Gnosis.sol';\n\nimport { IExecutor } from 'spark-gov-relay/src/interfaces/IExecutor.sol';\n\nimport { AMBForwarder }      from \"xchain-helpers/forwarders/AMBForwarder.sol\";\nimport { ArbitrumForwarder } from \"xchain-helpers/forwarders/ArbitrumForwarder.sol\";\nimport { OptimismForwarder } from \"xchain-helpers/forwarders/OptimismForwarder.sol\";\n\nimport { SLLHelpers } from './libraries/SLLHelpers.sol';\n\n/**\n * @dev Base smart contract for Ethereum.\n * @author Phoenix Labs\n */\nabstract contract SparkPayloadEthereum is\n    AaveV3PayloadBase(IEngine(Ethereum.CONFIG_ENGINE))\n{\n\n    // These need to be immutable (delegatecall) and can only be set in constructor\n    address public immutable PAYLOAD_ARBITRUM;\n    address public immutable PAYLOAD_BASE;\n    address public immutable PAYLOAD_GNOSIS;\n\n    function execute() public override {\n        super.execute();\n\n        if (PAYLOAD_ARBITRUM != address(0)) {\n            ArbitrumForwarder.sendMessageL1toL2({\n                l1CrossDomain: ArbitrumForwarder.L1_CROSS_DOMAIN_ARBITRUM_ONE,\n                target:        Arbitrum.SPARK_RECEIVER,\n                message:       _encodePayloadQueue(PAYLOAD_ARBITRUM),\n                gasLimit:      1_000_000,\n                maxFeePerGas:  50e9,\n                baseFee:       block.basefee\n            });\n        }\n        if (PAYLOAD_BASE != address(0)) {\n            OptimismForwarder.sendMessageL1toL2({\n                l1CrossDomain: OptimismForwarder.L1_CROSS_DOMAIN_BASE,\n                target:        Base.SPARK_RECEIVER,\n                message:       _encodePayloadQueue(PAYLOAD_BASE),\n                gasLimit:      1_000_000\n            });\n        }\n        if (PAYLOAD_GNOSIS != address(0)) {\n            AMBForwarder.sendMessageEthereumToGnosisChain({\n                target:   Gnosis.AMB_EXECUTOR,\n                message:  _encodePayloadQueue(PAYLOAD_GNOSIS),\n                gasLimit: 1_000_000\n            });\n        }\n    }\n\n    function getPoolContext() public pure override returns (IEngine.PoolContext memory) {\n        return IEngine.PoolContext({networkName: 'Ethereum', networkAbbreviation: 'Eth'});\n    }\n\n    function _encodePayloadQueue(address _payload) internal pure returns (bytes memory) {\n        address[] memory targets        = new address[](1);\n        uint256[] memory values         = new uint256[](1);\n        string[] memory signatures      = new string[](1);\n        bytes[] memory calldatas        = new bytes[](1);\n        bool[] memory withDelegatecalls = new bool[](1);\n\n        targets[0]           = _payload;\n        values[0]            = 0;\n        signatures[0]        = 'execute()';\n        calldatas[0]         = '';\n        withDelegatecalls[0] = true;\n\n        return abi.encodeCall(IExecutor.queue, (\n            targets,\n            values,\n            signatures,\n            calldatas,\n            withDelegatecalls\n        ));\n    }\n    \n    function _upgradeController(address oldController, address newController) internal {\n        SLLHelpers.upgradeMainnetController(\n            oldController,\n            newController\n        );\n    }\n\n    function _onboardAaveToken(address token, uint256 depositMax, uint256 depositSlope) internal {\n        SLLHelpers.onboardAaveToken(\n            Ethereum.ALM_RATE_LIMITS,\n            token,\n            depositMax,\n            depositSlope\n        );\n    }\n\n    function _onboardERC4626Vault(address vault, uint256 depositMax, uint256 depositSlope) internal {\n        SLLHelpers.onboardERC4626Vault(\n            Ethereum.ALM_RATE_LIMITS,\n            vault,\n            depositMax,\n            depositSlope\n        );\n    }\n\n    function _onboardCurvePool(\n        address controller,\n        address pool,\n        uint256 maxSlippage,\n        uint256 swapMax,\n        uint256 swapSlope,\n        uint256 depositMax,\n        uint256 depositSlope,\n        uint256 withdrawMax,\n        uint256 withdrawSlope\n    ) internal {\n        SLLHelpers.onboardCurvePool(\n            controller,\n            Ethereum.ALM_RATE_LIMITS,\n            pool,\n            maxSlippage,\n            swapMax,\n            swapSlope,\n            depositMax,\n            depositSlope,\n            withdrawMax,\n            withdrawSlope\n        );\n    }\n\n}\n"
    },
    "lib/sparklend-kill-switch/lib/aave-v3-core/contracts/interfaces/IPool.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\nimport {IPoolAddressesProvider} from './IPoolAddressesProvider.sol';\nimport {DataTypes} from '../protocol/libraries/types/DataTypes.sol';\n\n/**\n * @title IPool\n * @author Aave\n * @notice Defines the basic interface for an Aave Pool.\n */\ninterface IPool {\n  /**\n   * @dev Emitted on mintUnbacked()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address initiating the supply\n   * @param onBehalfOf The beneficiary of the supplied assets, receiving the aTokens\n   * @param amount The amount of supplied assets\n   * @param referralCode The referral code used\n   */\n  event MintUnbacked(\n    address indexed reserve,\n    address user,\n    address indexed onBehalfOf,\n    uint256 amount,\n    uint16 indexed referralCode\n  );\n\n  /**\n   * @dev Emitted on backUnbacked()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param backer The address paying for the backing\n   * @param amount The amount added as backing\n   * @param fee The amount paid in fees\n   */\n  event BackUnbacked(address indexed reserve, address indexed backer, uint256 amount, uint256 fee);\n\n  /**\n   * @dev Emitted on supply()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address initiating the supply\n   * @param onBehalfOf The beneficiary of the supply, receiving the aTokens\n   * @param amount The amount supplied\n   * @param referralCode The referral code used\n   */\n  event Supply(\n    address indexed reserve,\n    address user,\n    address indexed onBehalfOf,\n    uint256 amount,\n    uint16 indexed referralCode\n  );\n\n  /**\n   * @dev Emitted on withdraw()\n   * @param reserve The address of the underlying asset being withdrawn\n   * @param user The address initiating the withdrawal, owner of aTokens\n   * @param to The address that will receive the underlying\n   * @param amount The amount to be withdrawn\n   */\n  event Withdraw(address indexed reserve, address indexed user, address indexed to, uint256 amount);\n\n  /**\n   * @dev Emitted on borrow() and flashLoan() when debt needs to be opened\n   * @param reserve The address of the underlying asset being borrowed\n   * @param user The address of the user initiating the borrow(), receiving the funds on borrow() or just\n   * initiator of the transaction on flashLoan()\n   * @param onBehalfOf The address that will be getting the debt\n   * @param amount The amount borrowed out\n   * @param interestRateMode The rate mode: 1 for Stable, 2 for Variable\n   * @param borrowRate The numeric rate at which the user has borrowed, expressed in ray\n   * @param referralCode The referral code used\n   */\n  event Borrow(\n    address indexed reserve,\n    address user,\n    address indexed onBehalfOf,\n    uint256 amount,\n    DataTypes.InterestRateMode interestRateMode,\n    uint256 borrowRate,\n    uint16 indexed referralCode\n  );\n\n  /**\n   * @dev Emitted on repay()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The beneficiary of the repayment, getting his debt reduced\n   * @param repayer The address of the user initiating the repay(), providing the funds\n   * @param amount The amount repaid\n   * @param useATokens True if the repayment is done using aTokens, `false` if done with underlying asset directly\n   */\n  event Repay(\n    address indexed reserve,\n    address indexed user,\n    address indexed repayer,\n    uint256 amount,\n    bool useATokens\n  );\n\n  /**\n   * @dev Emitted on swapBorrowRateMode()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user swapping his rate mode\n   * @param interestRateMode The current interest rate mode of the position being swapped: 1 for Stable, 2 for Variable\n   */\n  event SwapBorrowRateMode(\n    address indexed reserve,\n    address indexed user,\n    DataTypes.InterestRateMode interestRateMode\n  );\n\n  /**\n   * @dev Emitted on borrow(), repay() and liquidationCall() when using isolated assets\n   * @param asset The address of the underlying asset of the reserve\n   * @param totalDebt The total isolation mode debt for the reserve\n   */\n  event IsolationModeTotalDebtUpdated(address indexed asset, uint256 totalDebt);\n\n  /**\n   * @dev Emitted when the user selects a certain asset category for eMode\n   * @param user The address of the user\n   * @param categoryId The category id\n   */\n  event UserEModeSet(address indexed user, uint8 categoryId);\n\n  /**\n   * @dev Emitted on setUserUseReserveAsCollateral()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user enabling the usage as collateral\n   */\n  event ReserveUsedAsCollateralEnabled(address indexed reserve, address indexed user);\n\n  /**\n   * @dev Emitted on setUserUseReserveAsCollateral()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user enabling the usage as collateral\n   */\n  event ReserveUsedAsCollateralDisabled(address indexed reserve, address indexed user);\n\n  /**\n   * @dev Emitted on rebalanceStableBorrowRate()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user for which the rebalance has been executed\n   */\n  event RebalanceStableBorrowRate(address indexed reserve, address indexed user);\n\n  /**\n   * @dev Emitted on flashLoan()\n   * @param target The address of the flash loan receiver contract\n   * @param initiator The address initiating the flash loan\n   * @param asset The address of the asset being flash borrowed\n   * @param amount The amount flash borrowed\n   * @param interestRateMode The flashloan mode: 0 for regular flashloan, 1 for Stable debt, 2 for Variable debt\n   * @param premium The fee flash borrowed\n   * @param referralCode The referral code used\n   */\n  event FlashLoan(\n    address indexed target,\n    address initiator,\n    address indexed asset,\n    uint256 amount,\n    DataTypes.InterestRateMode interestRateMode,\n    uint256 premium,\n    uint16 indexed referralCode\n  );\n\n  /**\n   * @dev Emitted when a borrower is liquidated.\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n   * @param user The address of the borrower getting liquidated\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n   * @param liquidatedCollateralAmount The amount of collateral received by the liquidator\n   * @param liquidator The address of the liquidator\n   * @param receiveAToken True if the liquidators wants to receive the collateral aTokens, `false` if he wants\n   * to receive the underlying collateral asset directly\n   */\n  event LiquidationCall(\n    address indexed collateralAsset,\n    address indexed debtAsset,\n    address indexed user,\n    uint256 debtToCover,\n    uint256 liquidatedCollateralAmount,\n    address liquidator,\n    bool receiveAToken\n  );\n\n  /**\n   * @dev Emitted when the state of a reserve is updated.\n   * @param reserve The address of the underlying asset of the reserve\n   * @param liquidityRate The next liquidity rate\n   * @param stableBorrowRate The next stable borrow rate\n   * @param variableBorrowRate The next variable borrow rate\n   * @param liquidityIndex The next liquidity index\n   * @param variableBorrowIndex The next variable borrow index\n   */\n  event ReserveDataUpdated(\n    address indexed reserve,\n    uint256 liquidityRate,\n    uint256 stableBorrowRate,\n    uint256 variableBorrowRate,\n    uint256 liquidityIndex,\n    uint256 variableBorrowIndex\n  );\n\n  /**\n   * @dev Emitted when the protocol treasury receives minted aTokens from the accrued interest.\n   * @param reserve The address of the reserve\n   * @param amountMinted The amount minted to the treasury\n   */\n  event MintedToTreasury(address indexed reserve, uint256 amountMinted);\n\n  /**\n   * @notice Mints an `amount` of aTokens to the `onBehalfOf`\n   * @param asset The address of the underlying asset to mint\n   * @param amount The amount to mint\n   * @param onBehalfOf The address that will receive the aTokens\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   */\n  function mintUnbacked(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external;\n\n  /**\n   * @notice Back the current unbacked underlying with `amount` and pay `fee`.\n   * @param asset The address of the underlying asset to back\n   * @param amount The amount to back\n   * @param fee The amount paid in fees\n   * @return The backed amount\n   */\n  function backUnbacked(address asset, uint256 amount, uint256 fee) external returns (uint256);\n\n  /**\n   * @notice Supplies an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\n   * - E.g. User supplies 100 USDC and gets in return 100 aUSDC\n   * @param asset The address of the underlying asset to supply\n   * @param amount The amount to be supplied\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n   *   is a different wallet\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   */\n  function supply(address asset, uint256 amount, address onBehalfOf, uint16 referralCode) external;\n\n  /**\n   * @notice Supply with transfer approval of asset to be supplied done via permit function\n   * see: https://eips.ethereum.org/EIPS/eip-2612 and https://eips.ethereum.org/EIPS/eip-713\n   * @param asset The address of the underlying asset to supply\n   * @param amount The amount to be supplied\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n   *   is a different wallet\n   * @param deadline The deadline timestamp that the permit is valid\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   * @param permitV The V parameter of ERC712 permit sig\n   * @param permitR The R parameter of ERC712 permit sig\n   * @param permitS The S parameter of ERC712 permit sig\n   */\n  function supplyWithPermit(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode,\n    uint256 deadline,\n    uint8 permitV,\n    bytes32 permitR,\n    bytes32 permitS\n  ) external;\n\n  /**\n   * @notice Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\n   * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\n   * @param asset The address of the underlying asset to withdraw\n   * @param amount The underlying amount to be withdrawn\n   *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\n   * @param to The address that will receive the underlying, same as msg.sender if the user\n   *   wants to receive it on his own wallet, or a different address if the beneficiary is a\n   *   different wallet\n   * @return The final amount withdrawn\n   */\n  function withdraw(address asset, uint256 amount, address to) external returns (uint256);\n\n  /**\n   * @notice Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower\n   * already supplied enough collateral, or he was given enough allowance by a credit delegator on the\n   * corresponding debt token (StableDebtToken or VariableDebtToken)\n   * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet\n   *   and 100 stable/variable debt tokens, depending on the `interestRateMode`\n   * @param asset The address of the underlying asset to borrow\n   * @param amount The amount to be borrowed\n   * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable\n   * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   * @param onBehalfOf The address of the user who will receive the debt. Should be the address of the borrower itself\n   * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator\n   * if he has been given credit delegation allowance\n   */\n  function borrow(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode,\n    uint16 referralCode,\n    address onBehalfOf\n  ) external;\n\n  /**\n   * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned\n   * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address\n   * @param asset The address of the borrowed underlying asset previously borrowed\n   * @param amount The amount to repay\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n   * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n   * @param onBehalfOf The address of the user who will get his debt reduced/removed. Should be the address of the\n   * user calling the function if he wants to reduce/remove his own debt, or the address of any other\n   * other borrower whose debt should be removed\n   * @return The final amount repaid\n   */\n  function repay(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode,\n    address onBehalfOf\n  ) external returns (uint256);\n\n  /**\n   * @notice Repay with transfer approval of asset to be repaid done via permit function\n   * see: https://eips.ethereum.org/EIPS/eip-2612 and https://eips.ethereum.org/EIPS/eip-713\n   * @param asset The address of the borrowed underlying asset previously borrowed\n   * @param amount The amount to repay\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n   * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n   * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the\n   * user calling the function if he wants to reduce/remove his own debt, or the address of any other\n   * other borrower whose debt should be removed\n   * @param deadline The deadline timestamp that the permit is valid\n   * @param permitV The V parameter of ERC712 permit sig\n   * @param permitR The R parameter of ERC712 permit sig\n   * @param permitS The S parameter of ERC712 permit sig\n   * @return The final amount repaid\n   */\n  function repayWithPermit(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode,\n    address onBehalfOf,\n    uint256 deadline,\n    uint8 permitV,\n    bytes32 permitR,\n    bytes32 permitS\n  ) external returns (uint256);\n\n  /**\n   * @notice Repays a borrowed `amount` on a specific reserve using the reserve aTokens, burning the\n   * equivalent debt tokens\n   * - E.g. User repays 100 USDC using 100 aUSDC, burning 100 variable/stable debt tokens\n   * @dev  Passing uint256.max as amount will clean up any residual aToken dust balance, if the user aToken\n   * balance is not enough to cover the whole debt\n   * @param asset The address of the borrowed underlying asset previously borrowed\n   * @param amount The amount to repay\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n   * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n   * @return The final amount repaid\n   */\n  function repayWithATokens(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode\n  ) external returns (uint256);\n\n  /**\n   * @notice Allows a borrower to swap his debt between stable and variable mode, or vice versa\n   * @param asset The address of the underlying asset borrowed\n   * @param interestRateMode The current interest rate mode of the position being swapped: 1 for Stable, 2 for Variable\n   */\n  function swapBorrowRateMode(address asset, uint256 interestRateMode) external;\n\n  /**\n   * @notice Rebalances the stable interest rate of a user to the current stable rate defined on the reserve.\n   * - Users can be rebalanced if the following conditions are satisfied:\n   *     1. Usage ratio is above 95%\n   *     2. the current supply APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate, which means that too\n   *        much has been borrowed at a stable rate and suppliers are not earning enough\n   * @param asset The address of the underlying asset borrowed\n   * @param user The address of the user to be rebalanced\n   */\n  function rebalanceStableBorrowRate(address asset, address user) external;\n\n  /**\n   * @notice Allows suppliers to enable/disable a specific supplied asset as collateral\n   * @param asset The address of the underlying asset supplied\n   * @param useAsCollateral True if the user wants to use the supply as collateral, false otherwise\n   */\n  function setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external;\n\n  /**\n   * @notice Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1\n   * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives\n   *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n   * @param user The address of the borrower getting liquidated\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n   * @param receiveAToken True if the liquidators wants to receive the collateral aTokens, `false` if he wants\n   * to receive the underlying collateral asset directly\n   */\n  function liquidationCall(\n    address collateralAsset,\n    address debtAsset,\n    address user,\n    uint256 debtToCover,\n    bool receiveAToken\n  ) external;\n\n  /**\n   * @notice Allows smartcontracts to access the liquidity of the pool within one transaction,\n   * as long as the amount taken plus a fee is returned.\n   * @dev IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept\n   * into consideration. For further details please visit https://docs.aave.com/developers/\n   * @param receiverAddress The address of the contract receiving the funds, implementing IFlashLoanReceiver interface\n   * @param assets The addresses of the assets being flash-borrowed\n   * @param amounts The amounts of the assets being flash-borrowed\n   * @param interestRateModes Types of the debt to open if the flash loan is not returned:\n   *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver\n   *   1 -> Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n   *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n   * @param onBehalfOf The address  that will receive the debt in the case of using on `modes` 1 or 2\n   * @param params Variadic packed params to pass to the receiver as extra information\n   * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   */\n  function flashLoan(\n    address receiverAddress,\n    address[] calldata assets,\n    uint256[] calldata amounts,\n    uint256[] calldata interestRateModes,\n    address onBehalfOf,\n    bytes calldata params,\n    uint16 referralCode\n  ) external;\n\n  /**\n   * @notice Allows smartcontracts to access the liquidity of the pool within one transaction,\n   * as long as the amount taken plus a fee is returned.\n   * @dev IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept\n   * into consideration. For further details please visit https://docs.aave.com/developers/\n   * @param receiverAddress The address of the contract receiving the funds, implementing IFlashLoanSimpleReceiver interface\n   * @param asset The address of the asset being flash-borrowed\n   * @param amount The amount of the asset being flash-borrowed\n   * @param params Variadic packed params to pass to the receiver as extra information\n   * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   */\n  function flashLoanSimple(\n    address receiverAddress,\n    address asset,\n    uint256 amount,\n    bytes calldata params,\n    uint16 referralCode\n  ) external;\n\n  /**\n   * @notice Returns the user account data across all the reserves\n   * @param user The address of the user\n   * @return totalCollateralBase The total collateral of the user in the base currency used by the price feed\n   * @return totalDebtBase The total debt of the user in the base currency used by the price feed\n   * @return availableBorrowsBase The borrowing power left of the user in the base currency used by the price feed\n   * @return currentLiquidationThreshold The liquidation threshold of the user\n   * @return ltv The loan to value of The user\n   * @return healthFactor The current health factor of the user\n   */\n  function getUserAccountData(\n    address user\n  )\n    external\n    view\n    returns (\n      uint256 totalCollateralBase,\n      uint256 totalDebtBase,\n      uint256 availableBorrowsBase,\n      uint256 currentLiquidationThreshold,\n      uint256 ltv,\n      uint256 healthFactor\n    );\n\n  /**\n   * @notice Initializes a reserve, activating it, assigning an aToken and debt tokens and an\n   * interest rate strategy\n   * @dev Only callable by the PoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param aTokenAddress The address of the aToken that will be assigned to the reserve\n   * @param stableDebtAddress The address of the StableDebtToken that will be assigned to the reserve\n   * @param variableDebtAddress The address of the VariableDebtToken that will be assigned to the reserve\n   * @param interestRateStrategyAddress The address of the interest rate strategy contract\n   */\n  function initReserve(\n    address asset,\n    address aTokenAddress,\n    address stableDebtAddress,\n    address variableDebtAddress,\n    address interestRateStrategyAddress\n  ) external;\n\n  /**\n   * @notice Drop a reserve\n   * @dev Only callable by the PoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   */\n  function dropReserve(address asset) external;\n\n  /**\n   * @notice Updates the address of the interest rate strategy contract\n   * @dev Only callable by the PoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param rateStrategyAddress The address of the interest rate strategy contract\n   */\n  function setReserveInterestRateStrategyAddress(\n    address asset,\n    address rateStrategyAddress\n  ) external;\n\n  /**\n   * @notice Sets the configuration bitmap of the reserve as a whole\n   * @dev Only callable by the PoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param configuration The new configuration bitmap\n   */\n  function setConfiguration(\n    address asset,\n    DataTypes.ReserveConfigurationMap calldata configuration\n  ) external;\n\n  /**\n   * @notice Returns the configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The configuration of the reserve\n   */\n  function getConfiguration(\n    address asset\n  ) external view returns (DataTypes.ReserveConfigurationMap memory);\n\n  /**\n   * @notice Returns the configuration of the user across all the reserves\n   * @param user The user address\n   * @return The configuration of the user\n   */\n  function getUserConfiguration(\n    address user\n  ) external view returns (DataTypes.UserConfigurationMap memory);\n\n  /**\n   * @notice Returns the normalized income of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve's normalized income\n   */\n  function getReserveNormalizedIncome(address asset) external view returns (uint256);\n\n  /**\n   * @notice Returns the normalized variable debt per unit of asset\n   * @dev WARNING: This function is intended to be used primarily by the protocol itself to get a\n   * \"dynamic\" variable index based on time, current stored index and virtual rate at the current\n   * moment (approx. a borrower would get if opening a position). This means that is always used in\n   * combination with variable debt supply/balances.\n   * If using this function externally, consider that is possible to have an increasing normalized\n   * variable debt that is not equivalent to how the variable debt index would be updated in storage\n   * (e.g. only updates with non-zero variable debt supply)\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve normalized variable debt\n   */\n  function getReserveNormalizedVariableDebt(address asset) external view returns (uint256);\n\n  /**\n   * @notice Returns the state and configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The state and configuration data of the reserve\n   */\n  function getReserveData(address asset) external view returns (DataTypes.ReserveData memory);\n\n  /**\n   * @notice Validates and finalizes an aToken transfer\n   * @dev Only callable by the overlying aToken of the `asset`\n   * @param asset The address of the underlying asset of the aToken\n   * @param from The user from which the aTokens are transferred\n   * @param to The user receiving the aTokens\n   * @param amount The amount being transferred/withdrawn\n   * @param balanceFromBefore The aToken balance of the `from` user before the transfer\n   * @param balanceToBefore The aToken balance of the `to` user before the transfer\n   */\n  function finalizeTransfer(\n    address asset,\n    address from,\n    address to,\n    uint256 amount,\n    uint256 balanceFromBefore,\n    uint256 balanceToBefore\n  ) external;\n\n  /**\n   * @notice Returns the list of the underlying assets of all the initialized reserves\n   * @dev It does not include dropped reserves\n   * @return The addresses of the underlying assets of the initialized reserves\n   */\n  function getReservesList() external view returns (address[] memory);\n\n  /**\n   * @notice Returns the address of the underlying asset of a reserve by the reserve id as stored in the DataTypes.ReserveData struct\n   * @param id The id of the reserve as stored in the DataTypes.ReserveData struct\n   * @return The address of the reserve associated with id\n   */\n  function getReserveAddressById(uint16 id) external view returns (address);\n\n  /**\n   * @notice Returns the PoolAddressesProvider connected to this contract\n   * @return The address of the PoolAddressesProvider\n   */\n  function ADDRESSES_PROVIDER() external view returns (IPoolAddressesProvider);\n\n  /**\n   * @notice Updates the protocol fee on the bridging\n   * @param bridgeProtocolFee The part of the premium sent to the protocol treasury\n   */\n  function updateBridgeProtocolFee(uint256 bridgeProtocolFee) external;\n\n  /**\n   * @notice Updates flash loan premiums. Flash loan premium consists of two parts:\n   * - A part is sent to aToken holders as extra, one time accumulated interest\n   * - A part is collected by the protocol treasury\n   * @dev The total premium is calculated on the total borrowed amount\n   * @dev The premium to protocol is calculated on the total premium, being a percentage of `flashLoanPremiumTotal`\n   * @dev Only callable by the PoolConfigurator contract\n   * @param flashLoanPremiumTotal The total premium, expressed in bps\n   * @param flashLoanPremiumToProtocol The part of the premium sent to the protocol treasury, expressed in bps\n   */\n  function updateFlashloanPremiums(\n    uint128 flashLoanPremiumTotal,\n    uint128 flashLoanPremiumToProtocol\n  ) external;\n\n  /**\n   * @notice Configures a new category for the eMode.\n   * @dev In eMode, the protocol allows very high borrowing power to borrow assets of the same category.\n   * The category 0 is reserved as it's the default for volatile assets\n   * @param id The id of the category\n   * @param config The configuration of the category\n   */\n  function configureEModeCategory(uint8 id, DataTypes.EModeCategory memory config) external;\n\n  /**\n   * @notice Returns the data of an eMode category\n   * @param id The id of the category\n   * @return The configuration data of the category\n   */\n  function getEModeCategoryData(uint8 id) external view returns (DataTypes.EModeCategory memory);\n\n  /**\n   * @notice Allows a user to use the protocol in eMode\n   * @param categoryId The id of the category\n   */\n  function setUserEMode(uint8 categoryId) external;\n\n  /**\n   * @notice Returns the eMode the user is using\n   * @param user The address of the user\n   * @return The eMode id\n   */\n  function getUserEMode(address user) external view returns (uint256);\n\n  /**\n   * @notice Resets the isolation mode total debt of the given asset to zero\n   * @dev It requires the given asset has zero debt ceiling\n   * @param asset The address of the underlying asset to reset the isolationModeTotalDebt\n   */\n  function resetIsolationModeTotalDebt(address asset) external;\n\n  /**\n   * @notice Returns the percentage of available liquidity that can be borrowed at once at stable rate\n   * @return The percentage of available liquidity to borrow, expressed in bps\n   */\n  function MAX_STABLE_RATE_BORROW_SIZE_PERCENT() external view returns (uint256);\n\n  /**\n   * @notice Returns the total fee on flash loans\n   * @return The total fee on flashloans\n   */\n  function FLASHLOAN_PREMIUM_TOTAL() external view returns (uint128);\n\n  /**\n   * @notice Returns the part of the bridge fees sent to protocol\n   * @return The bridge fee sent to the protocol treasury\n   */\n  function BRIDGE_PROTOCOL_FEE() external view returns (uint256);\n\n  /**\n   * @notice Returns the part of the flashloan fees sent to protocol\n   * @return The flashloan fee sent to the protocol treasury\n   */\n  function FLASHLOAN_PREMIUM_TO_PROTOCOL() external view returns (uint128);\n\n  /**\n   * @notice Returns the maximum number of reserves supported to be listed in this Pool\n   * @return The maximum number of reserves supported\n   */\n  function MAX_NUMBER_RESERVES() external view returns (uint16);\n\n  /**\n   * @notice Mints the assets accrued through the reserve factor to the treasury in the form of aTokens\n   * @param assets The list of reserves for which the minting needs to be executed\n   */\n  function mintToTreasury(address[] calldata assets) external;\n\n  /**\n   * @notice Rescue and transfer tokens locked in this contract\n   * @param token The address of the token\n   * @param to The address of the recipient\n   * @param amount The amount of token to transfer\n   */\n  function rescueTokens(address token, address to, uint256 amount) external;\n\n  /**\n   * @notice Supplies an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\n   * - E.g. User supplies 100 USDC and gets in return 100 aUSDC\n   * @dev Deprecated: Use the `supply` function instead\n   * @param asset The address of the underlying asset to supply\n   * @param amount The amount to be supplied\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n   *   is a different wallet\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   */\n  function deposit(address asset, uint256 amount, address onBehalfOf, uint16 referralCode) external;\n}\n"
    },
    "lib/sparklend-kill-switch/lib/aave-v3-core/contracts/interfaces/IPoolConfigurator.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\nimport {ConfiguratorInputTypes} from '../protocol/libraries/types/ConfiguratorInputTypes.sol';\n\n/**\n * @title IPoolConfigurator\n * @author Aave\n * @notice Defines the basic interface for a Pool configurator.\n */\ninterface IPoolConfigurator {\n  /**\n   * @dev Emitted when a reserve is initialized.\n   * @param asset The address of the underlying asset of the reserve\n   * @param aToken The address of the associated aToken contract\n   * @param stableDebtToken The address of the associated stable rate debt token\n   * @param variableDebtToken The address of the associated variable rate debt token\n   * @param interestRateStrategyAddress The address of the interest rate strategy for the reserve\n   */\n  event ReserveInitialized(\n    address indexed asset,\n    address indexed aToken,\n    address stableDebtToken,\n    address variableDebtToken,\n    address interestRateStrategyAddress\n  );\n\n  /**\n   * @dev Emitted when borrowing is enabled or disabled on a reserve.\n   * @param asset The address of the underlying asset of the reserve\n   * @param enabled True if borrowing is enabled, false otherwise\n   */\n  event ReserveBorrowing(address indexed asset, bool enabled);\n\n  /**\n   * @dev Emitted when flashloans are enabled or disabled on a reserve.\n   * @param asset The address of the underlying asset of the reserve\n   * @param enabled True if flashloans are enabled, false otherwise\n   */\n  event ReserveFlashLoaning(address indexed asset, bool enabled);\n\n  /**\n   * @dev Emitted when the collateralization risk parameters for the specified asset are updated.\n   * @param asset The address of the underlying asset of the reserve\n   * @param ltv The loan to value of the asset when used as collateral\n   * @param liquidationThreshold The threshold at which loans using this asset as collateral will be considered undercollateralized\n   * @param liquidationBonus The bonus liquidators receive to liquidate this asset\n   */\n  event CollateralConfigurationChanged(\n    address indexed asset,\n    uint256 ltv,\n    uint256 liquidationThreshold,\n    uint256 liquidationBonus\n  );\n\n  /**\n   * @dev Emitted when stable rate borrowing is enabled or disabled on a reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @param enabled True if stable rate borrowing is enabled, false otherwise\n   */\n  event ReserveStableRateBorrowing(address indexed asset, bool enabled);\n\n  /**\n   * @dev Emitted when a reserve is activated or deactivated\n   * @param asset The address of the underlying asset of the reserve\n   * @param active True if reserve is active, false otherwise\n   */\n  event ReserveActive(address indexed asset, bool active);\n\n  /**\n   * @dev Emitted when a reserve is frozen or unfrozen\n   * @param asset The address of the underlying asset of the reserve\n   * @param frozen True if reserve is frozen, false otherwise\n   */\n  event ReserveFrozen(address indexed asset, bool frozen);\n\n  /**\n   * @dev Emitted when a reserve is paused or unpaused\n   * @param asset The address of the underlying asset of the reserve\n   * @param paused True if reserve is paused, false otherwise\n   */\n  event ReservePaused(address indexed asset, bool paused);\n\n  /**\n   * @dev Emitted when a reserve is dropped.\n   * @param asset The address of the underlying asset of the reserve\n   */\n  event ReserveDropped(address indexed asset);\n\n  /**\n   * @dev Emitted when a reserve factor is updated.\n   * @param asset The address of the underlying asset of the reserve\n   * @param oldReserveFactor The old reserve factor, expressed in bps\n   * @param newReserveFactor The new reserve factor, expressed in bps\n   */\n  event ReserveFactorChanged(\n    address indexed asset,\n    uint256 oldReserveFactor,\n    uint256 newReserveFactor\n  );\n\n  /**\n   * @dev Emitted when the borrow cap of a reserve is updated.\n   * @param asset The address of the underlying asset of the reserve\n   * @param oldBorrowCap The old borrow cap\n   * @param newBorrowCap The new borrow cap\n   */\n  event BorrowCapChanged(address indexed asset, uint256 oldBorrowCap, uint256 newBorrowCap);\n\n  /**\n   * @dev Emitted when the supply cap of a reserve is updated.\n   * @param asset The address of the underlying asset of the reserve\n   * @param oldSupplyCap The old supply cap\n   * @param newSupplyCap The new supply cap\n   */\n  event SupplyCapChanged(address indexed asset, uint256 oldSupplyCap, uint256 newSupplyCap);\n\n  /**\n   * @dev Emitted when the liquidation protocol fee of a reserve is updated.\n   * @param asset The address of the underlying asset of the reserve\n   * @param oldFee The old liquidation protocol fee, expressed in bps\n   * @param newFee The new liquidation protocol fee, expressed in bps\n   */\n  event LiquidationProtocolFeeChanged(address indexed asset, uint256 oldFee, uint256 newFee);\n\n  /**\n   * @dev Emitted when the unbacked mint cap of a reserve is updated.\n   * @param asset The address of the underlying asset of the reserve\n   * @param oldUnbackedMintCap The old unbacked mint cap\n   * @param newUnbackedMintCap The new unbacked mint cap\n   */\n  event UnbackedMintCapChanged(\n    address indexed asset,\n    uint256 oldUnbackedMintCap,\n    uint256 newUnbackedMintCap\n  );\n\n  /**\n   * @dev Emitted when the category of an asset in eMode is changed.\n   * @param asset The address of the underlying asset of the reserve\n   * @param oldCategoryId The old eMode asset category\n   * @param newCategoryId The new eMode asset category\n   */\n  event EModeAssetCategoryChanged(address indexed asset, uint8 oldCategoryId, uint8 newCategoryId);\n\n  /**\n   * @dev Emitted when a new eMode category is added.\n   * @param categoryId The new eMode category id\n   * @param ltv The ltv for the asset category in eMode\n   * @param liquidationThreshold The liquidationThreshold for the asset category in eMode\n   * @param liquidationBonus The liquidationBonus for the asset category in eMode\n   * @param oracle The optional address of the price oracle specific for this category\n   * @param label A human readable identifier for the category\n   */\n  event EModeCategoryAdded(\n    uint8 indexed categoryId,\n    uint256 ltv,\n    uint256 liquidationThreshold,\n    uint256 liquidationBonus,\n    address oracle,\n    string label\n  );\n\n  /**\n   * @dev Emitted when a reserve interest strategy contract is updated.\n   * @param asset The address of the underlying asset of the reserve\n   * @param oldStrategy The address of the old interest strategy contract\n   * @param newStrategy The address of the new interest strategy contract\n   */\n  event ReserveInterestRateStrategyChanged(\n    address indexed asset,\n    address oldStrategy,\n    address newStrategy\n  );\n\n  /**\n   * @dev Emitted when an aToken implementation is upgraded.\n   * @param asset The address of the underlying asset of the reserve\n   * @param proxy The aToken proxy address\n   * @param implementation The new aToken implementation\n   */\n  event ATokenUpgraded(\n    address indexed asset,\n    address indexed proxy,\n    address indexed implementation\n  );\n\n  /**\n   * @dev Emitted when the implementation of a stable debt token is upgraded.\n   * @param asset The address of the underlying asset of the reserve\n   * @param proxy The stable debt token proxy address\n   * @param implementation The new aToken implementation\n   */\n  event StableDebtTokenUpgraded(\n    address indexed asset,\n    address indexed proxy,\n    address indexed implementation\n  );\n\n  /**\n   * @dev Emitted when the implementation of a variable debt token is upgraded.\n   * @param asset The address of the underlying asset of the reserve\n   * @param proxy The variable debt token proxy address\n   * @param implementation The new aToken implementation\n   */\n  event VariableDebtTokenUpgraded(\n    address indexed asset,\n    address indexed proxy,\n    address indexed implementation\n  );\n\n  /**\n   * @dev Emitted when the debt ceiling of an asset is set.\n   * @param asset The address of the underlying asset of the reserve\n   * @param oldDebtCeiling The old debt ceiling\n   * @param newDebtCeiling The new debt ceiling\n   */\n  event DebtCeilingChanged(address indexed asset, uint256 oldDebtCeiling, uint256 newDebtCeiling);\n\n  /**\n   * @dev Emitted when the the siloed borrowing state for an asset is changed.\n   * @param asset The address of the underlying asset of the reserve\n   * @param oldState The old siloed borrowing state\n   * @param newState The new siloed borrowing state\n   */\n  event SiloedBorrowingChanged(address indexed asset, bool oldState, bool newState);\n\n  /**\n   * @dev Emitted when the bridge protocol fee is updated.\n   * @param oldBridgeProtocolFee The old protocol fee, expressed in bps\n   * @param newBridgeProtocolFee The new protocol fee, expressed in bps\n   */\n  event BridgeProtocolFeeUpdated(uint256 oldBridgeProtocolFee, uint256 newBridgeProtocolFee);\n\n  /**\n   * @dev Emitted when the total premium on flashloans is updated.\n   * @param oldFlashloanPremiumTotal The old premium, expressed in bps\n   * @param newFlashloanPremiumTotal The new premium, expressed in bps\n   */\n  event FlashloanPremiumTotalUpdated(\n    uint128 oldFlashloanPremiumTotal,\n    uint128 newFlashloanPremiumTotal\n  );\n\n  /**\n   * @dev Emitted when the part of the premium that goes to protocol is updated.\n   * @param oldFlashloanPremiumToProtocol The old premium, expressed in bps\n   * @param newFlashloanPremiumToProtocol The new premium, expressed in bps\n   */\n  event FlashloanPremiumToProtocolUpdated(\n    uint128 oldFlashloanPremiumToProtocol,\n    uint128 newFlashloanPremiumToProtocol\n  );\n\n  /**\n   * @dev Emitted when the reserve is set as borrowable/non borrowable in isolation mode.\n   * @param asset The address of the underlying asset of the reserve\n   * @param borrowable True if the reserve is borrowable in isolation, false otherwise\n   */\n  event BorrowableInIsolationChanged(address asset, bool borrowable);\n\n  /**\n   * @notice Initializes multiple reserves.\n   * @param input The array of initialization parameters\n   */\n  function initReserves(ConfiguratorInputTypes.InitReserveInput[] calldata input) external;\n\n  /**\n   * @dev Updates the aToken implementation for the reserve.\n   * @param input The aToken update parameters\n   */\n  function updateAToken(ConfiguratorInputTypes.UpdateATokenInput calldata input) external;\n\n  /**\n   * @notice Updates the stable debt token implementation for the reserve.\n   * @param input The stableDebtToken update parameters\n   */\n  function updateStableDebtToken(\n    ConfiguratorInputTypes.UpdateDebtTokenInput calldata input\n  ) external;\n\n  /**\n   * @notice Updates the variable debt token implementation for the asset.\n   * @param input The variableDebtToken update parameters\n   */\n  function updateVariableDebtToken(\n    ConfiguratorInputTypes.UpdateDebtTokenInput calldata input\n  ) external;\n\n  /**\n   * @notice Configures borrowing on a reserve.\n   * @dev Can only be disabled (set to false) if stable borrowing is disabled\n   * @param asset The address of the underlying asset of the reserve\n   * @param enabled True if borrowing needs to be enabled, false otherwise\n   */\n  function setReserveBorrowing(address asset, bool enabled) external;\n\n  /**\n   * @notice Configures the reserve collateralization parameters.\n   * @dev All the values are expressed in bps. A value of 10000, results in 100.00%\n   * @dev The `liquidationBonus` is always above 100%. A value of 105% means the liquidator will receive a 5% bonus\n   * @param asset The address of the underlying asset of the reserve\n   * @param ltv The loan to value of the asset when used as collateral\n   * @param liquidationThreshold The threshold at which loans using this asset as collateral will be considered undercollateralized\n   * @param liquidationBonus The bonus liquidators receive to liquidate this asset\n   */\n  function configureReserveAsCollateral(\n    address asset,\n    uint256 ltv,\n    uint256 liquidationThreshold,\n    uint256 liquidationBonus\n  ) external;\n\n  /**\n   * @notice Enable or disable stable rate borrowing on a reserve.\n   * @dev Can only be enabled (set to true) if borrowing is enabled\n   * @param asset The address of the underlying asset of the reserve\n   * @param enabled True if stable rate borrowing needs to be enabled, false otherwise\n   */\n  function setReserveStableRateBorrowing(address asset, bool enabled) external;\n\n  /**\n   * @notice Enable or disable flashloans on a reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @param enabled True if flashloans need to be enabled, false otherwise\n   */\n  function setReserveFlashLoaning(address asset, bool enabled) external;\n\n  /**\n   * @notice Activate or deactivate a reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @param active True if the reserve needs to be active, false otherwise\n   */\n  function setReserveActive(address asset, bool active) external;\n\n  /**\n   * @notice Freeze or unfreeze a reserve. A frozen reserve doesn't allow any new supply, borrow\n   * or rate swap but allows repayments, liquidations, rate rebalances and withdrawals.\n   * @param asset The address of the underlying asset of the reserve\n   * @param freeze True if the reserve needs to be frozen, false otherwise\n   */\n  function setReserveFreeze(address asset, bool freeze) external;\n\n  /**\n   * @notice Sets the borrowable in isolation flag for the reserve.\n   * @dev When this flag is set to true, the asset will be borrowable against isolated collaterals and the\n   * borrowed amount will be accumulated in the isolated collateral's total debt exposure\n   * @dev Only assets of the same family (e.g. USD stablecoins) should be borrowable in isolation mode to keep\n   * consistency in the debt ceiling calculations\n   * @param asset The address of the underlying asset of the reserve\n   * @param borrowable True if the asset should be borrowable in isolation, false otherwise\n   */\n  function setBorrowableInIsolation(address asset, bool borrowable) external;\n\n  /**\n   * @notice Pauses a reserve. A paused reserve does not allow any interaction (supply, borrow, repay,\n   * swap interest rate, liquidate, atoken transfers).\n   * @param asset The address of the underlying asset of the reserve\n   * @param paused True if pausing the reserve, false if unpausing\n   */\n  function setReservePause(address asset, bool paused) external;\n\n  /**\n   * @notice Updates the reserve factor of a reserve.\n   * @param asset The address of the underlying asset of the reserve\n   * @param newReserveFactor The new reserve factor of the reserve\n   */\n  function setReserveFactor(address asset, uint256 newReserveFactor) external;\n\n  /**\n   * @notice Sets the interest rate strategy of a reserve.\n   * @param asset The address of the underlying asset of the reserve\n   * @param newRateStrategyAddress The address of the new interest strategy contract\n   */\n  function setReserveInterestRateStrategyAddress(\n    address asset,\n    address newRateStrategyAddress\n  ) external;\n\n  /**\n   * @notice Pauses or unpauses all the protocol reserves. In the paused state all the protocol interactions\n   * are suspended.\n   * @param paused True if protocol needs to be paused, false otherwise\n   */\n  function setPoolPause(bool paused) external;\n\n  /**\n   * @notice Updates the borrow cap of a reserve.\n   * @param asset The address of the underlying asset of the reserve\n   * @param newBorrowCap The new borrow cap of the reserve\n   */\n  function setBorrowCap(address asset, uint256 newBorrowCap) external;\n\n  /**\n   * @notice Updates the supply cap of a reserve.\n   * @param asset The address of the underlying asset of the reserve\n   * @param newSupplyCap The new supply cap of the reserve\n   */\n  function setSupplyCap(address asset, uint256 newSupplyCap) external;\n\n  /**\n   * @notice Updates the liquidation protocol fee of reserve.\n   * @param asset The address of the underlying asset of the reserve\n   * @param newFee The new liquidation protocol fee of the reserve, expressed in bps\n   */\n  function setLiquidationProtocolFee(address asset, uint256 newFee) external;\n\n  /**\n   * @notice Updates the unbacked mint cap of reserve.\n   * @param asset The address of the underlying asset of the reserve\n   * @param newUnbackedMintCap The new unbacked mint cap of the reserve\n   */\n  function setUnbackedMintCap(address asset, uint256 newUnbackedMintCap) external;\n\n  /**\n   * @notice Assign an efficiency mode (eMode) category to asset.\n   * @param asset The address of the underlying asset of the reserve\n   * @param newCategoryId The new category id of the asset\n   */\n  function setAssetEModeCategory(address asset, uint8 newCategoryId) external;\n\n  /**\n   * @notice Adds a new efficiency mode (eMode) category.\n   * @dev If zero is provided as oracle address, the default asset oracles will be used to compute the overall debt and\n   * overcollateralization of the users using this category.\n   * @dev The new ltv and liquidation threshold must be greater than the base\n   * ltvs and liquidation thresholds of all assets within the eMode category\n   * @param categoryId The id of the category to be configured\n   * @param ltv The ltv associated with the category\n   * @param liquidationThreshold The liquidation threshold associated with the category\n   * @param liquidationBonus The liquidation bonus associated with the category\n   * @param oracle The oracle associated with the category\n   * @param label A label identifying the category\n   */\n  function setEModeCategory(\n    uint8 categoryId,\n    uint16 ltv,\n    uint16 liquidationThreshold,\n    uint16 liquidationBonus,\n    address oracle,\n    string calldata label\n  ) external;\n\n  /**\n   * @notice Drops a reserve entirely.\n   * @param asset The address of the reserve to drop\n   */\n  function dropReserve(address asset) external;\n\n  /**\n   * @notice Updates the bridge fee collected by the protocol reserves.\n   * @param newBridgeProtocolFee The part of the fee sent to the protocol treasury, expressed in bps\n   */\n  function updateBridgeProtocolFee(uint256 newBridgeProtocolFee) external;\n\n  /**\n   * @notice Updates the total flash loan premium.\n   * Total flash loan premium consists of two parts:\n   * - A part is sent to aToken holders as extra balance\n   * - A part is collected by the protocol reserves\n   * @dev Expressed in bps\n   * @dev The premium is calculated on the total amount borrowed\n   * @param newFlashloanPremiumTotal The total flashloan premium\n   */\n  function updateFlashloanPremiumTotal(uint128 newFlashloanPremiumTotal) external;\n\n  /**\n   * @notice Updates the flash loan premium collected by protocol reserves\n   * @dev Expressed in bps\n   * @dev The premium to protocol is calculated on the total flashloan premium\n   * @param newFlashloanPremiumToProtocol The part of the flashloan premium sent to the protocol treasury\n   */\n  function updateFlashloanPremiumToProtocol(uint128 newFlashloanPremiumToProtocol) external;\n\n  /**\n   * @notice Sets the debt ceiling for an asset.\n   * @param newDebtCeiling The new debt ceiling\n   */\n  function setDebtCeiling(address asset, uint256 newDebtCeiling) external;\n\n  /**\n   * @notice Sets siloed borrowing for an asset\n   * @param siloed The new siloed borrowing state\n   */\n  function setSiloedBorrowing(address asset, bool siloed) external;\n}\n"
    },
    "src/AaveV3PayloadBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Address} from './libraries/Address.sol';\nimport {IAaveV3ConfigEngine as IEngine} from './interfaces/IAaveV3ConfigEngine.sol';\nimport {IV3RateStrategyFactory as Rates} from './interfaces/IV3RateStrategyFactory.sol';\n\nlibrary EngineFlags {\n  /// @dev magic value to be used as flag to keep unchanged any current configuration\n  /// Strongly assumes that the value `type(uint256).max - 42` will never be used, which seems reasonable\n  uint256 internal constant KEEP_CURRENT = type(uint256).max - 42;\n\n  /// @dev value to be used as flag for bool value true\n  uint256 internal constant ENABLED = 1;\n\n  /// @dev value to be used as flag for bool value false\n  uint256 internal constant DISABLED = 0;\n\n  /// @dev converts flag ENABLED DISABLED to bool\n  function toBool(uint256 flag) internal pure returns (bool) {\n    require(flag == 0 || flag == 1, 'INVALID_CONVERSION_TO_BOOL');\n    return flag == 1;\n  }\n\n  /// @dev converts bool to ENABLED DISABLED flags\n  function fromBool(bool isTrue) internal pure returns (uint256) {\n    return isTrue ? ENABLED : DISABLED;\n  }\n}\n\n\n/**\n * @dev Base smart contract for an Aave v3.0.1 configs update.\n * - Assumes this contract has the right permissions\n * - Connected to a IAaveV3ConfigEngine engine contact, which abstract the complexities of\n *   interaction with the Aave protocol.\n * - At the moment covering:\n *   - Listings of new assets on the pool.\n *   - Updates of caps (supply cap, borrow cap).\n *   - Updates of price feeds\n *   - Updates of interest rate strategies.\n *   - Updates of borrow parameters (flashloanable, stableRateModeEnabled, borrowableInIsolation, withSiloedBorrowing, reserveFactor)\n *   - Updates of collateral parameters (ltv, liq threshold, liq bonus, liq protocol fee, debt ceiling)\n * @author BGD Labs\n */\nabstract contract AaveV3PayloadBase {\n  using Address for address;\n\n  IEngine public immutable LISTING_ENGINE;\n\n  constructor(IEngine engine) {\n    LISTING_ENGINE = engine;\n  }\n\n  /// @dev to be overriden on the child if any extra logic is needed pre-listing\n  function _preExecute() internal virtual {}\n\n  /// @dev to be overriden on the child if any extra logic is needed post-listing\n  function _postExecute() internal virtual {}\n\n  function execute() public virtual {\n    _preExecute();\n\n    IEngine.Listing[] memory listings = newListings();\n    IEngine.ListingWithCustomImpl[] memory listingsCustom = newListingsCustom();\n    IEngine.CapsUpdate[] memory caps = capsUpdates();\n    IEngine.CollateralUpdate[] memory collaterals = collateralsUpdates();\n    IEngine.BorrowUpdate[] memory borrows = borrowsUpdates();\n    IEngine.PriceFeedUpdate[] memory priceFeeds = priceFeedsUpdates();\n    IEngine.RateStrategyUpdate[] memory rates = rateStrategiesUpdates();\n\n    if (listings.length != 0) {\n      address(LISTING_ENGINE).functionDelegateCall(\n        abi.encodeWithSelector(LISTING_ENGINE.listAssets.selector, getPoolContext(), listings)\n      );\n    }\n\n    if (listingsCustom.length != 0) {\n      address(LISTING_ENGINE).functionDelegateCall(\n        abi.encodeWithSelector(\n          LISTING_ENGINE.listAssetsCustom.selector,\n          getPoolContext(),\n          listingsCustom\n        )\n      );\n    }\n\n    if (borrows.length != 0) {\n      address(LISTING_ENGINE).functionDelegateCall(\n        abi.encodeWithSelector(LISTING_ENGINE.updateBorrowSide.selector, borrows)\n      );\n    }\n\n    if (collaterals.length != 0) {\n      address(LISTING_ENGINE).functionDelegateCall(\n        abi.encodeWithSelector(LISTING_ENGINE.updateCollateralSide.selector, collaterals)\n      );\n    }\n\n    if (rates.length != 0) {\n      address(LISTING_ENGINE).functionDelegateCall(\n        abi.encodeWithSelector(LISTING_ENGINE.updateRateStrategies.selector, rates)\n      );\n    }\n\n    if (priceFeeds.length != 0) {\n      address(LISTING_ENGINE).functionDelegateCall(\n        abi.encodeWithSelector(LISTING_ENGINE.updatePriceFeeds.selector, priceFeeds)\n      );\n    }\n\n    if (caps.length != 0) {\n      address(LISTING_ENGINE).functionDelegateCall(\n        abi.encodeWithSelector(LISTING_ENGINE.updateCaps.selector, caps)\n      );\n    }\n\n    _postExecute();\n  }\n\n  /** @dev Converts basis points to RAY units\n   * e.g. 10_00 (10.00%) will return 100000000000000000000000000\n   */\n  function _bpsToRay(uint256 amount) internal pure returns (uint256) {\n    return (amount * 1e27) / 10_000;\n  }\n\n  /// @dev to be defined in the child with a list of new assets to list\n  function newListings() public view virtual returns (IEngine.Listing[] memory) {}\n\n  /// @dev to be defined in the child with a list of new assets to list (with custom a/v/s tokens implementations)\n  function newListingsCustom()\n    public\n    view\n    virtual\n    returns (IEngine.ListingWithCustomImpl[] memory)\n  {}\n\n  /// @dev to be defined in the child with a list of caps to update\n  function capsUpdates() public view virtual returns (IEngine.CapsUpdate[] memory) {}\n\n  /// @dev to be defined in the child with a list of collaterals' params to update\n  function collateralsUpdates() public view virtual returns (IEngine.CollateralUpdate[] memory) {}\n\n  /// @dev to be defined in the child with a list of borrows' params to update\n  function borrowsUpdates() public view virtual returns (IEngine.BorrowUpdate[] memory) {}\n\n  /// @dev to be defined in the child with a list of priceFeeds to update\n  function priceFeedsUpdates() public view virtual returns (IEngine.PriceFeedUpdate[] memory) {}\n\n  /// @dev to be defined in the child with a list of set of parameters of rate strategies\n  function rateStrategiesUpdates()\n    public\n    view\n    virtual\n    returns (IEngine.RateStrategyUpdate[] memory)\n  {}\n\n  /// @dev the lack of support for immutable strings kinds of forces for this\n  /// Besides that, it can actually be useful being able to change the naming, but remote\n  function getPoolContext() public view virtual returns (IEngine.PoolContext memory);\n}\n"
    },
    "lib/spark-address-registry/src/Arbitrum.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity >=0.8.0;\n\nlibrary Arbitrum {\n\n    /******************************************************************************************************************/\n    /*** Token Addresses                                                                                            ***/\n    /******************************************************************************************************************/\n\n    address internal constant SUSDC = 0x940098b108fB7D0a7E374f6eDED7760787464609;\n    address internal constant SUSDS = 0xdDb46999F8891663a8F2828d25298f70416d7610;\n    address internal constant USDC  = 0xaf88d065e77c8cC2239327C5EDb3A432268e5831;\n    address internal constant USDS  = 0x6491c05A82219b8D1479057361ff1654749b876b;\n\n    /******************************************************************************************************************/\n    /*** Bridging Addresses                                                                                         ***/\n    /******************************************************************************************************************/\n\n    address internal constant CCTP_TOKEN_MESSENGER = 0x19330d10D9Cc8751218eaf51E8885D058642E08A;\n\n    address internal constant SKY_GOV_RELAY = 0x10E6593CDda8c58a1d0f14C5164B376352a55f2F;\n    address internal constant TOKEN_BRIDGE  = 0x13F7F24CA959359a4D710D32c715D4bce273C793;\n\n    /******************************************************************************************************************/\n    /*** PSM Addresses                                                                                              ***/\n    /******************************************************************************************************************/\n\n    address internal constant PSM3 = 0x2B05F8e1cACC6974fD79A673a341Fe1f58d27266;\n\n    /******************************************************************************************************************/\n    /*** Spark Liquidity Layer Addresses                                                                            ***/\n    /******************************************************************************************************************/\n\n    address internal constant ALM_CONTROLLER  = 0x98f567464e91e9B4831d3509024b7868f9F79ee1;\n    address internal constant ALM_PROXY       = 0x92afd6F2385a90e44da3a8B60fe36f6cBe1D8709;\n    address internal constant ALM_RATE_LIMITS = 0x19D08879851FB54C2dCc4bb32b5a1EA5E9Ad6838;\n\n    address internal constant ALM_FREEZER  = 0x90D8c80C028B4C09C0d8dcAab9bbB057F0513431;\n    address internal constant ALM_RELAYER  = 0x8a25A24EDE9482C4Fc0738F99611BE58F1c839AB;\n    address internal constant ALM_RELAYER2 = 0x8Cc0Cb0cfB6B7e548cfd395B833c05C346534795;\n\n    /******************************************************************************************************************/\n    /*** Aave Addresses                                                                                             ***/\n    /******************************************************************************************************************/\n\n    address internal constant ATOKEN_USDC = 0x724dc807b04555b71ed48a6896b6F41593b8C637;\n\n    /******************************************************************************************************************/\n    /*** Governance Relay Addresses                                                                                 ***/\n    /******************************************************************************************************************/\n\n    address internal constant SPARK_EXECUTOR = 0x65d946e533748A998B1f0E430803e39A6388f7a1;\n    address internal constant SPARK_RECEIVER = 0x212871A1C235892F86cAB30E937e18c94AEd8474;\n\n    /******************************************************************************************************************/\n    /*** SSR Oracle Addresses                                                                                       ***/\n    /******************************************************************************************************************/\n\n    address internal constant SSR_AUTH_ORACLE             = 0xEE2816c1E1eed14d444552654Ed3027abC033A36;\n    address internal constant SSR_BALANCER_RATE_PROVIDER  = 0xc0737f29b964e6fC8025F16B30f2eA4C2e2d6f22;\n    address internal constant SSR_CHAINLINK_RATE_PROVIDER = 0x84AB0c8C158A1cD0d215BE2746cCa668B79cc287;\n    address internal constant SSR_RECEIVER                = 0x567214Dc57a2385Abc4a756f523ddF0275305Cbc;\n\n    /******************************************************************************************************************/\n    /*** DSR Oracle Addresses                                                                                       ***/\n    /******************************************************************************************************************/\n\n    address internal constant DSR_AUTH_ORACLE            = 0xE206AEbca7B28e3E8d6787df00B010D4a77c32F3;\n    address internal constant DSR_RECEIVER               = 0xcA61540eC2AC74E6954FA558B4aF836d95eCb91b;\n    address internal constant DSR_BALANCER_RATE_PROVIDER = 0x73750DbD85753074e452B2C27fB9e3B0E75Ff3B8;\n\n    /******************************************************************************************************************/\n    /*** Multisigs                                                                                                  ***/\n    /******************************************************************************************************************/\n\n    address internal constant SPARK_REWARDS_MULTISIG = 0xF649956f43825d4d7295a50EDdBe1EDC814A3a83;\n\n}\n"
    },
    "lib/spark-address-registry/src/Base.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity >=0.8.0;\n\nlibrary Base {\n\n    /******************************************************************************************************************/\n    /*** Token Addresses                                                                                            ***/\n    /******************************************************************************************************************/\n\n    address internal constant CBBTC = 0xcbB7C0000aB88B473b1f5aFd9ef808440eed33Bf;\n    address internal constant SKY   = 0x60e3c701e65DEE30c23c9Fb78c3866479cc0944a;\n    address internal constant SUSDC = 0x3128a0F7f0ea68E7B7c9B00AFa7E41045828e858;\n    address internal constant SUSDS = 0x5875eEE11Cf8398102FdAd704C9E96607675467a;\n    address internal constant USDC  = 0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913;\n    address internal constant USDS  = 0x820C137fa70C8691f0e44Dc420a5e53c168921Dc;\n\n    /******************************************************************************************************************/\n    /*** Bridging Addresses                                                                                         ***/\n    /******************************************************************************************************************/\n\n    address internal constant CCTP_TOKEN_MESSENGER = 0x1682Ae6375C4E4A97e4B583BC394c861A46D8962;\n\n    address internal constant SKY_GOV_RELAY = 0xdD0BCc201C9E47c6F6eE68E4dB05b652Bb6aC255;\n    address internal constant TOKEN_BRIDGE  = 0xee44cdb68D618d58F75d9fe0818B640BD7B8A7B7;\n\n    /******************************************************************************************************************/\n    /*** PSM Addresses                                                                                              ***/\n    /******************************************************************************************************************/\n\n    address internal constant PSM3 = 0x1601843c5E9bC251A3272907010AFa41Fa18347E;\n\n    /******************************************************************************************************************/\n    /*** Spark Liquidity Layer Addresses                                                                            ***/\n    /******************************************************************************************************************/\n\n    address internal constant ALM_CONTROLLER  = 0xB94378b5347a3E199AF3575719F67A708a5D8b9B;\n    address internal constant ALM_PROXY       = 0x2917956eFF0B5eaF030abDB4EF4296DF775009cA;\n    address internal constant ALM_RATE_LIMITS = 0x983eC82E45C61a42FDDA7B3c43B8C767004c8A74;\n\n    address internal constant ALM_FREEZER  = 0x90D8c80C028B4C09C0d8dcAab9bbB057F0513431;\n    address internal constant ALM_RELAYER  = 0x8a25A24EDE9482C4Fc0738F99611BE58F1c839AB;\n    address internal constant ALM_RELAYER2 = 0x8Cc0Cb0cfB6B7e548cfd395B833c05C346534795;\n\n    /******************************************************************************************************************/\n    /*** Aave Addresses                                                                                             ***/\n    /******************************************************************************************************************/\n\n    address internal constant ATOKEN_USDC = 0x4e65fE4DbA92790696d040ac24Aa414708F5c0AB;\n\n    /******************************************************************************************************************/\n    /*** Fluid Addresses                                                                                            ***/\n    /******************************************************************************************************************/\n\n    address internal constant FLUID_SUSDS = 0xf62e339f21d8018940f188F6987Bcdf02A849619;\n\n    /******************************************************************************************************************/\n    /*** Morpho Addresses                                                                                           ***/\n    /******************************************************************************************************************/\n\n    address internal constant MORPHO             = 0xBBBBBbbBBb9cC5e90e3b3Af64bdAF62C37EEFFCb;\n    address internal constant MORPHO_DEFAULT_IRM = 0x46415998764C29aB2a25CbeA6254146D50D22687;\n    address internal constant MORPHO_VAULT_SUSDC = 0x7BfA7C4f149E7415b73bdeDfe609237e29CBF34A;\n\n    /******************************************************************************************************************/\n    /*** Governance Relay Addresses                                                                                 ***/\n    /******************************************************************************************************************/\n\n    address internal constant SPARK_EXECUTOR = 0xF93B7122450A50AF3e5A76E1d546e95Ac1d0F579;\n    address internal constant SPARK_RECEIVER = 0xfda082e00EF89185d9DB7E5DcD8c5505070F5A3B;\n\n    /******************************************************************************************************************/\n    /*** SSR Oracle Addresses                                                                                       ***/\n    /******************************************************************************************************************/\n\n    address internal constant SSR_AUTH_ORACLE             = 0x65d946e533748A998B1f0E430803e39A6388f7a1;\n    address internal constant SSR_BALANCER_RATE_PROVIDER  = 0x49aF4eE75Ae62C2229bb2486a59Aa1a999f050f0;\n    address internal constant SSR_CHAINLINK_RATE_PROVIDER = 0x026a5B6114431d8F3eF2fA0E1B2EDdDccA9c540E;\n    address internal constant SSR_RECEIVER                = 0x212871A1C235892F86cAB30E937e18c94AEd8474;\n\n    /******************************************************************************************************************/\n    /*** DSR Oracle Addresses (Legacy)                                                                              ***/\n    /******************************************************************************************************************/\n\n    address internal constant DSR_AUTH_ORACLE            = 0x2Dd2a2Fe346B5704380EfbF6Bd522042eC3E8FAe;\n    address internal constant DSR_RECEIVER               = 0xaDEAf02Ddb5Bed574045050B8096307bE66E0676;\n    address internal constant DSR_BALANCER_RATE_PROVIDER = 0xeC0C14Ea7fF20F104496d960FDEBF5a0a0cC14D0;\n\n    /******************************************************************************************************************/\n    /*** Multisigs                                                                                                  ***/\n    /******************************************************************************************************************/\n\n    address internal constant SPARK_REWARDS_MULTISIG = 0xF649956f43825d4d7295a50EDdBe1EDC814A3a83;\n\n}\n"
    },
    "lib/spark-address-registry/src/Gnosis.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity >=0.8.0;\n\nlibrary Gnosis {\n\n    /******************************************************************************************************************/\n    /*** Token Addresses                                                                                            ***/\n    /******************************************************************************************************************/\n\n    address internal constant GNO    = 0x9C58BAcC331c9aa871AFD802DB6379a98e80CEdb;\n    address internal constant WETH   = 0x6A023CCd1ff6F2045C3309768eAd9E68F978f6e1;\n    address internal constant WSTETH = 0x6C76971f98945AE98dD7d4DFcA8711ebea946eA6;\n    address internal constant WXDAI  = 0xe91D153E0b41518A2Ce8Dd3D7944Fa863463a97d;\n    address internal constant SXDAI  = 0xaf204776c7245bF4147c2612BF6e5972Ee483701;\n    address internal constant USDC   = 0xDDAfbb505ad214D7b80b1f830fcCc89B60fb7A83;\n    address internal constant USDCE  = 0x2a22f9c3b484c3629090FeED35F17Ff8F88f76F0;\n    address internal constant USDT   = 0x4ECaBa5870353805a9F068101A40E0f32ed605C6;\n    address internal constant EURE   = 0xcB444e90D8198415266c6a2724b7900fb12FC56E;\n\n    /******************************************************************************************************************/\n    /*** SparkLend - Core Protocol Addresses                                                                        ***/\n    /******************************************************************************************************************/\n\n    address internal constant AAVE_ORACLE                      = 0x8105f69D9C41644c6A0803fDA7D03Aa70996cFD9;\n    address internal constant ACL_MANAGER                      = 0x86C71796CcDB31c3997F8Ec5C2E3dB3e9e40b985;\n    address internal constant EMISSION_MANAGER                 = 0x4d988568b5f0462B08d1F40bA1F5f17ad2D24F76;\n    address internal constant INCENTIVES                       = 0x98e6BcBA7d5daFbfa4a92dAF08d3d7512820c30C;\n    address internal constant POOL                             = 0x2Dae5307c5E3FD1CF5A72Cb6F698f915860607e0;\n    address internal constant POOL_ADDRESSES_PROVIDER          = 0xA98DaCB3fC964A6A0d2ce3B77294241585EAbA6d;\n    address internal constant POOL_ADDRESSES_PROVIDER_REGISTRY = 0x49d24798d3b84965F0d1fc8684EF6565115e70c1;\n    address internal constant POOL_CONFIGURATOR                = 0x2Fc8823E1b967D474b47Ae0aD041c2ED562ab588;\n    address internal constant TREASURY                         = 0xb9E6DBFa4De19CCed908BcbFe1d015190678AB5f;\n    address internal constant TREASURY_CONTROLLER              = 0x8220096398c3Dc2644026E8864f5D80Ef613B437;\n    address internal constant WETH_GATEWAY                     = 0xBD7D6a9ad7865463DE44B05F04559f65e3B11704;\n\n    /******************************************************************************************************************/\n    /*** SparkLend - Reserve Token Addresses                                                                        ***/\n    /******************************************************************************************************************/\n\n    address internal constant GNO_ATOKEN            = 0x5671b0B8aC13DC7813D36B99C21c53F6cd376a14;\n    address internal constant GNO_STABLE_DEBT_TOKEN = 0x2f589BADbE2024a94f144ef24344aF91dE21a33c;\n    address internal constant GNO_DEBT_TOKEN        = 0xd4bAbF714964E399f95A7bb94B3DeaF22d9F575d;\n\n    address internal constant WETH_ATOKEN            = 0x629D562E92fED431122e865Cc650Bc6bdE6B96b0;\n    address internal constant WETH_STABLE_DEBT_TOKEN = 0xe21Bf3FB5A2b5Bf7BAE8c6F1696c4B097F5D2f93;\n    address internal constant WETH_DEBT_TOKEN        = 0x0aD6cCf9a2e81d4d48aB7db791e9da492967eb84;\n\n    address internal constant WSTETH_ATOKEN            = 0x9Ee4271E17E3a427678344fd2eE64663Cb78B4be;\n    address internal constant WSTETH_STABLE_DEBT_TOKEN = 0x0F0e336Ab69D9516A9acF448bC59eA0CE79E4a42;\n    address internal constant WSTETH_DEBT_TOKEN        = 0x3294dA2E28b29D1c08D556e2B86879d221256d31;\n\n    address internal constant WXDAI_ATOKEN            = 0xC9Fe2D32E96Bb364c7d29f3663ed3b27E30767bB;\n    address internal constant WXDAI_STABLE_DEBT_TOKEN = 0xab1B62A1346Acf534b581684940E2FD781F2EA22;\n    address internal constant WXDAI_DEBT_TOKEN        = 0x868ADfDf12A86422524EaB6978beAE08A0008F37;\n\n    address internal constant SXDAI_ATOKEN            = 0xE877b96caf9f180916bF2B5Ce7Ea8069e0123182;\n    address internal constant SXDAI_STABLE_DEBT_TOKEN = 0x2cF710377b3576287Be7cf352FF75D4472902789;\n    address internal constant SXDAI_DEBT_TOKEN        = 0x1022E390E2457A78E18AEEE0bBf0E96E482EeE19;\n\n    address internal constant USDC_ATOKEN            = 0x5850D127a04ed0B4F1FCDFb051b3409FB9Fe6B90;\n    address internal constant USDC_STABLE_DEBT_TOKEN = 0x40BF0Bf6AECeE50eCE10C74E81a52C654A467ae4;\n    address internal constant USDC_DEBT_TOKEN        = 0xBC4f20DAf4E05c17E93676D2CeC39769506b8219;\n\n    address internal constant USDCE_ATOKEN            = 0xA34DB0ee8F84C4B90ed268dF5aBbe7Dcd3c277ec;\n    address internal constant USDCE_STABLE_DEBT_TOKEN = 0xC5dfde524371F9424c81F453260B2CCd24936c15;\n    address internal constant USDCE_DEBT_TOKEN        = 0x397b97b572281d0b3e3513BD4A7B38050a75962b;\n\n    address internal constant USDT_ATOKEN            = 0x08B0cAebE352c3613302774Cd9B82D08afd7bDC4;\n    address internal constant USDT_STABLE_DEBT_TOKEN = 0x4cB3F681B5e393947BD1e5cAE84764f5892923C2;\n    address internal constant USDT_DEBT_TOKEN        = 0x3A98aBC6F46CA2Fc6c7d06eD02184D63C55e19B2;\n\n    address internal constant EURE_ATOKEN            = 0x6dc304337BF3EB397241d1889cAE7da638e6e782;\n    address internal constant EURE_STABLE_DEBT_TOKEN = 0x80F87B8F9c1199e468923D8EE87cEE311690FDA6;\n    address internal constant EURE_DEBT_TOKEN        = 0x0b33480d3FbD1E2dBE88c82aAbe191D7473759D5;\n\n    /******************************************************************************************************************/\n    /*** SparkLend - Implementation Addresses                                                                       ***/\n    /******************************************************************************************************************/\n\n    address internal constant A_TOKEN_IMPL             = 0x856900aa78e856a5df1a2665eE3a66b2487cD68f;\n    address internal constant INCENTIVES_IMPL          = 0x764b4AB9bCA18eB633d92368F725765Ebb8f047C;\n    address internal constant POOL_CONFIGURATOR_IMPL   = 0x6175ddEc3B9b38c88157C10A01ed4A3fa8639cC6;\n    address internal constant POOL_IMPL                = 0xCF86A65779e88bedfF0319FE13aE2B47358EB1bF;\n    address internal constant STABLE_DEBT_TOKEN_IMPL   = 0x4370D3b6C9588E02ce9D22e684387859c7Ff5b34;\n    address internal constant TREASURY_IMPL            = 0x571501be53711c372cE69De51865dD34B87698D5;\n    address internal constant VARIABLE_DEBT_TOKEN_IMPL = 0x0ee554F6A1f7a4Cb4f82D4C124DdC2AD3E37fde1;\n\n    /******************************************************************************************************************/\n    /*** SparkLend - Config Engine Addresses                                                                        ***/\n    /******************************************************************************************************************/\n\n    address internal constant PROXY_ADMIN               = 0xf76B8262dfd60fb7432C6b55E91f42b6da953647;\n    address internal constant CONFIG_ENGINE             = 0x36eddc380C7f370e5f05Da5Bd7F970a27f063e39;\n    address internal constant RATES_FACTORY             = 0xe04ba71E46fCd7DBB9334D8FBa13d476f38EB0f8;\n    address internal constant TRANSPARENT_PROXY_FACTORY = 0x91277b74a9d1Cc30fA0ff4927C287fe55E307D78;\n\n    /******************************************************************************************************************/\n    /*** SparkLend - Data Provider Addresses                                                                        ***/\n    /******************************************************************************************************************/\n\n    address internal constant PROTOCOL_DATA_PROVIDER     = 0x2a002054A06546bB5a264D57A81347e23Af91D18;\n    address internal constant UI_INCENTIVE_DATA_PROVIDER = 0xA7F8A757C4f7696c015B595F51B2901AC0121B18;\n    address internal constant UI_POOL_DATA_PROVIDER      = 0xF028c2F4b19898718fD0F77b9b881CbfdAa5e8Bb;\n    address internal constant WALLET_BALANCE_PROVIDER    = 0xd2AeF86F51F92E8e49F42454c287AE4879D1BeDc;\n\n    /******************************************************************************************************************/\n    /*** Governance Addresses                                                                                       ***/\n    /******************************************************************************************************************/\n\n    address constant AMB_EXECUTOR = 0xc4218C1127cB24a0D6c1e7D25dc34e10f2625f5A;\n\n    /******************************************************************************************************************/\n    /*** Multisigs                                                                                                  ***/\n    /******************************************************************************************************************/\n\n    address internal constant SPARK_REWARDS_MULTISIG = 0xF649956f43825d4d7295a50EDdBe1EDC814A3a83;\n\n}\n"
    },
    "lib/spark-gov-relay/src/interfaces/IExecutor.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity >=0.8.0;\n\nimport { IAccessControl } from 'openzeppelin-contracts/contracts/access/IAccessControl.sol';\n\n/**\n * @title  IExecutor\n * @author Aave\n * @notice Defines the interface for the Executor\n */\ninterface IExecutor is IAccessControl {\n\n    /******************************************************************************************************************/\n    /*** Errors                                                                                                     ***/\n    /******************************************************************************************************************/\n\n    error GracePeriodTooShort();\n    error OnlyQueuedActions();\n    error TimelockNotFinished();\n    error InvalidActionsSetId();\n    error EmptyTargets();\n    error InconsistentParamsLength();\n    error InsufficientBalance();\n\n    /******************************************************************************************************************/\n    /*** Enums                                                                                                      ***/\n    /******************************************************************************************************************/\n\n    /**\n     * @notice This enum contains all possible actions set states\n     */\n    enum ActionsSetState {\n        Queued,\n        Executed,\n        Canceled,\n        Expired\n    }\n\n    /******************************************************************************************************************/\n    /*** Events                                                                                                     ***/\n    /******************************************************************************************************************/\n\n    /**\n     * @notice This struct contains the data needed to execute a specified set of actions.\n     * @param  targets           Array of targets to call.\n     * @param  values            Array of values to pass in each call.\n     * @param  signatures        Array of function signatures to encode in each call by the actions which can be empty strings.\n     * @param  calldatas         Array of calldatas to pass in each call, appended to the signature at the same array index if not empty.\n     * @param  withDelegateCalls Array of whether to delegatecall for each call.\n     * @param  executionTime     Timestamp starting from which the actions set can be executed.\n     * @param  executed          True if the actions set has been executed, false otherwise.\n     * @param  canceled          True if the actions set has been canceled, false otherwise.\n     */\n    struct ActionsSet {\n        address[] targets;\n        uint256[] values;\n        string[] signatures;\n        bytes[] calldatas;\n        bool[] withDelegatecalls;\n        uint256 executionTime;\n        bool executed;\n        bool canceled;\n    }\n\n    /**\n     * @dev   Emitted when an ActionsSet is queued.\n     * @param id                Id of the ActionsSet.\n     * @param targets           Array of targets to be called by the actions set.\n     * @param values            Array of values to pass in each call by the actions set.\n     * @param signatures        Array of function signatures to encode in each call by the actions set.\n     * @param calldatas         Array of calldata to pass in each call by the actions set.\n     * @param withDelegatecalls Array of whether to delegatecall for each call of the actions set.\n     * @param executionTime     The timestamp at which this actions set can be executed.\n     **/\n    event ActionsSetQueued(\n        uint256 indexed id,\n        address[] targets,\n        uint256[] values,\n        string[] signatures,\n        bytes[] calldatas,\n        bool[] withDelegatecalls,\n        uint256 executionTime\n    );\n\n    /**\n     * @dev   Emitted when an ActionsSet is successfully executed.\n     * @param id                 Id of the ActionsSet.\n     * @param initiatorExecution The address that triggered the ActionsSet execution.\n     * @param returnedData       The returned data from the ActionsSet execution.\n     **/\n    event ActionsSetExecuted(\n        uint256 indexed id,\n        address indexed initiatorExecution,\n        bytes[] returnedData\n    );\n\n    /**\n     * @dev   Emitted when an ActionsSet is cancelled by the guardian.\n     * @param id Id of the ActionsSet.\n     **/\n    event ActionsSetCanceled(uint256 indexed id);\n\n    /**\n     * @dev   Emitted when the delay (between queueing and execution) is updated.\n     * @param oldDelay The value of the old delay.\n     * @param newDelay The value of the new delay.\n     **/\n    event DelayUpdate(uint256 oldDelay, uint256 newDelay);\n\n    /**\n     * @dev   Emitted when the grace period (between executionTime and expiration) is updated.\n     * @param oldGracePeriod The value of the old grace period.\n     * @param newGracePeriod The value of the new grace period.\n     **/\n    event GracePeriodUpdate(uint256 oldGracePeriod, uint256 newGracePeriod);\n\n    /******************************************************************************************************************/\n    /*** State variables                                                                                            ***/\n    /******************************************************************************************************************/\n\n    /**\n     * @notice The role that allows submission of a queued action.\n     **/\n    function SUBMISSION_ROLE() external view returns (bytes32);\n\n    /**\n     * @notice The role that allows a guardian to cancel a pending action.\n     **/\n    function GUARDIAN_ROLE() external view returns (bytes32);\n\n    /**\n     * @notice Returns the minimum grace period that can be set, 10 minutes.\n     */\n    function MINIMUM_GRACE_PERIOD() external view returns (uint256);\n\n     /**\n     * @notice Returns the total number of actions sets of the executor.\n     * @return The number of actions sets.\n     **/\n    function actionsSetCount() external view returns (uint256);\n\n    /**\n     * @notice Returns the delay (between queuing and execution)\n     * @return The value of the delay (in seconds)\n     **/\n    function delay() external view returns (uint256);\n\n    /**\n     * @notice Time after the execution time during which the actions set can be executed.\n     * @return The value of the grace period (in seconds)\n     **/\n    function gracePeriod() external view returns (uint256);\n\n    /******************************************************************************************************************/\n    /*** ActionSet functions                                                                                        ***/\n    /******************************************************************************************************************/\n\n    /**\n     * @notice Queue an ActionsSet.\n     * @dev    If a signature is empty, calldata is used for the execution, calldata is appended to signature otherwise.\n     * @param  targets           Array of targets to be called by the actions set.\n     * @param  values            Array of values to pass in each call by the actions set.\n     * @param  signatures        Array of function signatures to encode in each call by the actions which can be empty strings.\n     * @param  calldatas         Array of calldata to pass in each call by the actions set.\n     * @param  withDelegatecalls Array of whether to delegatecall for each call of the actions set.\n     **/\n    function queue(\n        address[] memory targets,\n        uint256[] memory values,\n        string[] memory signatures,\n        bytes[] memory calldatas,\n        bool[] memory withDelegatecalls\n    ) external;\n\n    /**\n     * @notice Execute the ActionsSet\n     * @param  actionsSetId The id of the ActionsSet to execute\n     **/\n    function execute(uint256 actionsSetId) external payable;\n\n    /**\n     * @notice Cancel the ActionsSet.\n     * @param  actionsSetId The id of the ActionsSet to cancel.\n     **/\n    function cancel(uint256 actionsSetId) external;\n\n    /******************************************************************************************************************/\n    /*** Admin functions                                                                                            ***/\n    /******************************************************************************************************************/\n\n    /**\n     * @notice Update the delay, time between queueing and execution of ActionsSet.\n     * @dev    It does not affect to actions set that are already queued.\n     * @param  delay The value of the delay (in seconds).\n     **/\n    function updateDelay(uint256 delay) external;\n\n    /**\n     * @notice Update the grace period, the period after the execution time during which an actions set can be executed\n     * @param  gracePeriod The value of the grace period (in seconds).\n     **/\n    function updateGracePeriod(uint256 gracePeriod) external;\n\n    /******************************************************************************************************************/\n    /*** Misc functions                                                                                             ***/\n    /******************************************************************************************************************/\n\n    /**\n     * @notice Allows to delegatecall a given target with an specific amount of value.\n     * @dev    This function is external so it allows to specify a defined msg.value for the delegate call, reducing\n     *         the risk that a delegatecall gets executed with more value than intended.\n     * @return The bytes returned by the delegate call.\n     **/\n    function executeDelegateCall(address target, bytes calldata data)\n        external\n        payable\n        returns (bytes memory);\n\n    /**\n     * @notice Allows to receive funds into the executor.\n     * @dev    Useful for actionsSet that needs funds to gets executed.\n     */\n    function receiveFunds() external payable;\n\n    /******************************************************************************************************************/\n    /*** View functions                                                                                             ***/\n    /******************************************************************************************************************/\n\n\n    /**\n     * @notice Returns the data of an actions set.\n     * @param  actionsSetId The id of the ActionsSet.\n     * @return The data of the ActionsSet.\n     **/\n     function getActionsSetById(uint256 actionsSetId) external view returns (ActionsSet memory);\n\n     /**\n      * @notice Returns the current state of an actions set.\n      * @param  actionsSetId The id of the ActionsSet.\n      * @return The current state of theI ActionsSet.\n      **/\n     function getCurrentState(uint256 actionsSetId) external view returns (ActionsSetState);\n\n}\n"
    },
    "lib/xchain-helpers/src/forwarders/AMBForwarder.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.0;\n\ninterface IArbitraryMessagingBridge {\n    function requireToPassMessage(address _contract, bytes memory _data, uint256 _gas) external returns (bytes32);\n}\n\nlibrary AMBForwarder {\n\n    address constant internal GNOSIS_AMB_ETHEREUM     = 0x4C36d2919e407f0Cc2Ee3c993ccF8ac26d9CE64e;\n    address constant internal GNOSIS_AMB_GNOSIS_CHAIN = 0x75Df5AF045d91108662D8080fD1FEFAd6aA0bb59;\n\n    function sendMessage(\n        address amb,\n        address target,\n        bytes memory message,\n        uint256 gasLimit\n    ) internal {\n        IArbitraryMessagingBridge(amb).requireToPassMessage(\n            target,\n            message,\n            gasLimit\n        );\n    }\n\n    function sendMessageEthereumToGnosisChain(\n        address target,\n        bytes memory message,\n        uint256 gasLimit\n    ) internal {\n        sendMessage(\n            GNOSIS_AMB_ETHEREUM,\n            target,\n            message,\n            gasLimit\n        );\n    }\n\n    function sendMessageGnosisChainToEthereum(\n        address target,\n        bytes memory message,\n        uint256 gasLimit\n    ) internal {\n        sendMessage(\n            GNOSIS_AMB_GNOSIS_CHAIN,\n            target,\n            message,\n            gasLimit\n        );\n    }\n    \n}\n"
    },
    "lib/xchain-helpers/src/forwarders/ArbitrumForwarder.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.0;\n\ninterface ICrossDomainArbitrum {\n    function createRetryableTicket(\n        address to,\n        uint256 l2CallValue,\n        uint256 maxSubmissionCost,\n        address excessFeeRefundAddress,\n        address callValueRefundAddress,\n        uint256 gasLimit,\n        uint256 maxFeePerGas,\n        bytes calldata data\n    ) external payable returns (uint256);\n    function calculateRetryableSubmissionFee(uint256 dataLength, uint256 baseFee) external view returns (uint256);\n}\n\ninterface IArbSys {\n    function sendTxToL1(address target, bytes calldata message) external;\n}\n\nlibrary ArbitrumForwarder {\n\n    address constant internal L1_CROSS_DOMAIN_ARBITRUM_ONE  = 0x4Dbd4fc535Ac27206064B68FfCf827b0A60BAB3f;\n    address constant internal L1_CROSS_DOMAIN_ARBITRUM_NOVA = 0xc4448b71118c9071Bcb9734A0EAc55D18A153949;\n    address constant internal L2_CROSS_DOMAIN               = 0x0000000000000000000000000000000000000064;\n\n    function sendMessageL1toL2(\n        address l1CrossDomain,\n        address target,\n        bytes memory message,\n        uint256 gasLimit,\n        uint256 maxFeePerGas,\n        uint256 baseFee\n    ) internal {\n        uint256 maxSubmission = ICrossDomainArbitrum(l1CrossDomain).calculateRetryableSubmissionFee(message.length, baseFee);\n        uint256 maxRedemption = gasLimit * maxFeePerGas;\n        ICrossDomainArbitrum(l1CrossDomain).createRetryableTicket{value: maxSubmission + maxRedemption}(\n            target,\n            0, // we always assume that l2CallValue = 0\n            maxSubmission,\n            address(0), // burn the excess gas\n            address(0), // burn the excess gas\n            gasLimit,\n            maxFeePerGas,\n            message\n        );\n    }\n\n    function sendMessageL2toL1(\n        address target,\n        bytes memory message\n    ) internal {\n        IArbSys(L2_CROSS_DOMAIN).sendTxToL1(\n            target,\n            message\n        );\n    }\n    \n}\n"
    },
    "lib/xchain-helpers/src/forwarders/OptimismForwarder.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.0;\n\ninterface ICrossDomainOptimism {\n    function sendMessage(address _target, bytes calldata _message, uint32 _gasLimit) external;\n}\n\nlibrary OptimismForwarder {\n\n    address constant internal L1_CROSS_DOMAIN_OPTIMISM    = 0x25ace71c97B33Cc4729CF772ae268934F7ab5fA1;\n    address constant internal L1_CROSS_DOMAIN_BASE        = 0x866E82a600A1414e583f7F13623F1aC5d58b0Afa;\n    address constant internal L1_CROSS_DOMAIN_WORLD_CHAIN = 0xf931a81D18B1766d15695ffc7c1920a62b7e710a;\n    address constant internal L2_CROSS_DOMAIN             = 0x4200000000000000000000000000000000000007;\n\n    function sendMessageL1toL2(\n        address l1CrossDomain,\n        address target,\n        bytes memory message,\n        uint32 gasLimit\n    ) internal {\n        ICrossDomainOptimism(l1CrossDomain).sendMessage(\n            target,\n            message,\n            gasLimit\n        );\n    }\n\n    function sendMessageL2toL1(\n        address target,\n        bytes memory message,\n        uint32 gasLimit\n    ) internal {\n        ICrossDomainOptimism(L2_CROSS_DOMAIN).sendMessage(\n            target,\n            message,\n            gasLimit\n        );\n    }\n    \n}\n"
    },
    "src/libraries/SLLHelpers.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\nimport { IAToken } from \"aave-v3-origin/src/core/contracts/interfaces/IAToken.sol\";\n\nimport { IERC20 }   from 'forge-std/interfaces/IERC20.sol';\nimport { IERC4626 } from 'forge-std/interfaces/IERC4626.sol';\n\nimport { IMetaMorpho } from \"metamorpho/interfaces/IMetaMorpho.sol\";\n\nimport { MarketParams, Id } from \"morpho-blue/src/interfaces/IMorpho.sol\";\nimport { MarketParamsLib }  from \"morpho-blue/src/libraries/MarketParamsLib.sol\";\n\nimport { Arbitrum } from 'spark-address-registry/Arbitrum.sol';\nimport { Base }     from 'spark-address-registry/Base.sol';\nimport { Ethereum } from 'spark-address-registry/Ethereum.sol';\n\nimport { ControllerInstance }              from \"spark-alm-controller/deploy/ControllerInstance.sol\";\nimport { MainnetControllerInit }           from \"spark-alm-controller/deploy/MainnetControllerInit.sol\";\nimport { ForeignControllerInit }           from \"spark-alm-controller/deploy/ForeignControllerInit.sol\";\nimport { MainnetController }               from \"spark-alm-controller/src/MainnetController.sol\";\nimport { ForeignController }               from \"spark-alm-controller/src/ForeignController.sol\";\nimport { RateLimitHelpers, RateLimitData } from \"spark-alm-controller/src/RateLimitHelpers.sol\";\n\nimport { CCTPForwarder }from \"xchain-helpers/forwarders/CCTPForwarder.sol\";\n\n/**\n * @notice Helper functions for Spark Liquidity Layer\n */\nlibrary SLLHelpers {\n\n    // This is the same on all chains\n    address private constant MORPHO = 0xBBBBBbbBBb9cC5e90e3b3Af64bdAF62C37EEFFCb;\n\n    // This is the same on all chains\n    address private constant ALM_RELAYER_BACKUP = 0x8Cc0Cb0cfB6B7e548cfd395B833c05C346534795;\n\n    bytes32 private constant LIMIT_4626_DEPOSIT   = keccak256(\"LIMIT_4626_DEPOSIT\");\n    bytes32 private constant LIMIT_4626_WITHDRAW  = keccak256(\"LIMIT_4626_WITHDRAW\");\n    bytes32 private constant LIMIT_AAVE_DEPOSIT   = keccak256(\"LIMIT_AAVE_DEPOSIT\");\n    bytes32 private constant LIMIT_AAVE_WITHDRAW  = keccak256(\"LIMIT_AAVE_WITHDRAW\");\n    bytes32 private constant LIMIT_USDS_MINT      = keccak256(\"LIMIT_USDS_MINT\");\n    bytes32 private constant LIMIT_USDS_TO_USDC   = keccak256(\"LIMIT_USDS_TO_USDC\");\n    bytes32 private constant LIMIT_USDC_TO_CCTP   = keccak256(\"LIMIT_USDC_TO_CCTP\");\n    bytes32 private constant LIMIT_USDC_TO_DOMAIN = keccak256(\"LIMIT_USDC_TO_DOMAIN\");\n    bytes32 private constant LIMIT_PSM_DEPOSIT    = keccak256(\"LIMIT_PSM_DEPOSIT\");\n    bytes32 private constant LIMIT_PSM_WITHDRAW   = keccak256(\"LIMIT_PSM_WITHDRAW\");\n    bytes32 private constant LIMIT_CURVE_DEPOSIT  = keccak256(\"LIMIT_CURVE_DEPOSIT\");\n    bytes32 private constant LIMIT_CURVE_SWAP     = keccak256(\"LIMIT_CURVE_SWAP\");\n    bytes32 private constant LIMIT_CURVE_WITHDRAW = keccak256(\"LIMIT_CURVE_WITHDRAW\");\n\n    /**\n     * @notice Activate the bare minimum for Spark Liquidity Layer\n     * @dev Sets PSM and CCTP rate limits.\n     */\n    function activateSparkLiquidityLayer(\n        address rateLimits,\n        address usdc,\n        address usds,\n        address susds,\n        RateLimitData memory usdcDeposit,\n        RateLimitData memory usdcWithdraw,\n        RateLimitData memory cctpEthereumDeposit\n    ) internal {\n        // PSM USDC\n        RateLimitHelpers.setRateLimitData(\n            RateLimitHelpers.makeAssetKey(\n                LIMIT_PSM_DEPOSIT,\n                usdc\n            ),\n            rateLimits,\n            usdcDeposit,\n            \"psmUsdcDepositLimit\",\n            6\n        );\n        RateLimitHelpers.setRateLimitData(\n            RateLimitHelpers.makeAssetKey(\n                LIMIT_PSM_WITHDRAW,\n                usdc\n            ),\n            rateLimits,\n            usdcWithdraw,\n            \"psmUsdcWithdrawLimit\",\n            6\n        );\n\n        // PSM USDS\n        RateLimitHelpers.setRateLimitData(\n            RateLimitHelpers.makeAssetKey(\n                LIMIT_PSM_DEPOSIT,\n                usds\n            ),\n            rateLimits,\n            RateLimitHelpers.unlimitedRateLimit(),\n            \"psmUsdsDepositLimit\",\n            18\n        );\n        RateLimitHelpers.setRateLimitData(\n            RateLimitHelpers.makeAssetKey(\n                LIMIT_PSM_WITHDRAW,\n                usds\n            ),\n            rateLimits,\n            RateLimitHelpers.unlimitedRateLimit(),\n            \"psmUsdsWithdrawLimit\",\n            18\n        );\n\n        // PSM sUSDS\n        RateLimitHelpers.setRateLimitData(\n            RateLimitHelpers.makeAssetKey(\n                LIMIT_PSM_DEPOSIT,\n                susds\n            ),\n            rateLimits,\n            RateLimitHelpers.unlimitedRateLimit(),\n            \"psmSusdsDepositLimit\",\n            18\n        );\n        RateLimitHelpers.setRateLimitData(\n            RateLimitHelpers.makeAssetKey(\n                LIMIT_PSM_WITHDRAW,\n                susds\n            ),\n            rateLimits,\n            RateLimitHelpers.unlimitedRateLimit(),\n            \"psmSusdsWithdrawLimit\",\n            18\n        );\n\n        // CCTP\n        RateLimitHelpers.setRateLimitData(\n            LIMIT_USDC_TO_CCTP,\n            rateLimits,\n            RateLimitHelpers.unlimitedRateLimit(),\n            \"usdcToCctpLimit\",\n            6\n        );\n        RateLimitHelpers.setRateLimitData(\n            RateLimitHelpers.makeDomainKey(\n                LIMIT_USDC_TO_DOMAIN,\n                0  // Ethereum domain id (https://developers.circle.com/stablecoins/evm-smart-contracts)\n            ),\n            rateLimits,\n            cctpEthereumDeposit,\n            \"usdcToCctpEthereumLimit\",\n            6\n        );\n    }\n\n    /**\n     * @notice Onboard an Aave token\n     * @dev This will set the deposit to the given numbers with\n     *      the withdraw limit set to unlimited.\n     */\n    function onboardAaveToken(\n        address rateLimits,\n        address token,\n        uint256 depositMax,\n        uint256 depositSlope\n    ) internal {\n        IERC20 underlying = IERC20(IAToken(token).UNDERLYING_ASSET_ADDRESS());\n\n        RateLimitHelpers.setRateLimitData(\n            RateLimitHelpers.makeAssetKey(\n                LIMIT_AAVE_DEPOSIT,\n                token\n            ),\n            rateLimits,\n            RateLimitData({\n                maxAmount : depositMax,\n                slope     : depositSlope\n            }),\n            \"atokenDepositLimit\",\n            underlying.decimals()\n        );\n        RateLimitHelpers.setRateLimitData(\n            RateLimitHelpers.makeAssetKey(\n                LIMIT_AAVE_WITHDRAW,\n                token\n            ),\n            rateLimits,\n            RateLimitHelpers.unlimitedRateLimit(),\n            \"atokenWithdrawLimit\",\n            underlying.decimals()\n        );\n    }\n\n    /**\n     * @notice Onboard an ERC4626 vault\n     * @dev This will set the deposit to the given numbers with\n     *      the withdraw limit set to unlimited.\n     */\n    function onboardERC4626Vault(\n        address rateLimits,\n        address vault,\n        uint256 depositMax,\n        uint256 depositSlope\n    ) internal {\n        IERC20 asset = IERC20(IERC4626(vault).asset());\n\n        RateLimitHelpers.setRateLimitData(\n            RateLimitHelpers.makeAssetKey(\n                LIMIT_4626_DEPOSIT,\n                vault\n            ),\n            rateLimits,\n            RateLimitData({\n                maxAmount : depositMax,\n                slope     : depositSlope\n            }),\n            \"vaultDepositLimit\",\n            asset.decimals()\n        );\n        RateLimitHelpers.setRateLimitData(\n            RateLimitHelpers.makeAssetKey(\n                LIMIT_4626_WITHDRAW,\n                vault\n            ),\n            rateLimits,\n            RateLimitHelpers.unlimitedRateLimit(),\n            \"vaultWithdrawLimit\",\n            asset.decimals()\n        );\n    }\n\n    /**\n     * @notice Onboard a Curve pool\n     */\n    function onboardCurvePool(\n        address controller,\n        address rateLimits,\n        address pool,\n        uint256 maxSlippage,\n        uint256 swapMax,\n        uint256 swapSlope,\n        uint256 depositMax,\n        uint256 depositSlope,\n        uint256 withdrawMax,\n        uint256 withdrawSlope\n    ) internal {\n        MainnetController(controller).setMaxSlippage(pool, maxSlippage);\n        if (swapMax != 0) {\n            RateLimitHelpers.setRateLimitData(\n                RateLimitHelpers.makeAssetKey(\n                    LIMIT_CURVE_SWAP,\n                    pool\n                ),\n                rateLimits,\n                RateLimitData({\n                    maxAmount : swapMax,\n                    slope     : swapSlope\n                }),\n                \"poolSwapLimit\",\n                18\n            );\n        }\n        if (depositMax != 0) {\n            RateLimitHelpers.setRateLimitData(\n                RateLimitHelpers.makeAssetKey(\n                    LIMIT_CURVE_DEPOSIT,\n                    pool\n                ),\n                rateLimits,\n                RateLimitData({\n                    maxAmount : depositMax,\n                    slope     : depositSlope\n                }),\n                \"poolDepositLimit\",\n                18\n            );\n        }\n        if (withdrawMax != 0) {\n            RateLimitHelpers.setRateLimitData(\n                RateLimitHelpers.makeAssetKey(\n                    LIMIT_CURVE_WITHDRAW,\n                    pool\n                ),\n                rateLimits,\n                RateLimitData({\n                    maxAmount : withdrawMax,\n                    slope     : withdrawSlope\n                }),\n                \"poolWithdrawLimit\",\n                18\n            );\n        }\n    }\n\n    function morphoIdleMarket(\n        address asset\n    ) internal pure returns (MarketParams memory) {\n        return MarketParams({\n            loanToken:       asset,\n            collateralToken: address(0),\n            oracle:          address(0),\n            irm:             address(0),\n            lltv:            0\n        });\n    }\n\n    /**\n     * @notice Activate a Morpho Vault\n     * @dev This will do the following:\n     *      - Add the relayer as an allocator\n     *      - Add the idle market for the underlying asset with unlimited size\n     *      - Set the supply queue to the idle market\n     */\n    function activateMorphoVault(\n        address vault,\n        address relayer\n    ) internal {\n        IERC20 asset = IERC20(IERC4626(vault).asset());\n        MarketParams memory idleMarket = morphoIdleMarket(address(asset));\n\n        IMetaMorpho(vault).setIsAllocator(\n            relayer,\n            true\n        );\n        IMetaMorpho(vault).submitCap(\n            idleMarket,\n            type(uint184).max\n        );\n        IMetaMorpho(vault).acceptCap(\n            idleMarket\n        );\n        Id[] memory supplyQueue = new Id[](1);\n        supplyQueue[0] = MarketParamsLib.id(idleMarket);\n        IMetaMorpho(vault).setSupplyQueue(supplyQueue);\n    }\n\n    function setUSDSMintRateLimit(\n        address rateLimits,\n        uint256 maxAmount,\n        uint256 slope\n    ) internal {\n        RateLimitHelpers.setRateLimitData(\n            LIMIT_USDS_MINT,\n            rateLimits,\n            RateLimitData({\n                maxAmount : maxAmount,\n                slope     : slope\n            }),\n            \"USDS mint limit\",\n            18\n        );\n    }\n\n    function setUSDSToUSDCRateLimit(\n        address rateLimits,\n        uint256 maxUsdcAmount,\n        uint256 slope\n    ) internal {\n        RateLimitHelpers.setRateLimitData(\n            LIMIT_USDS_TO_USDC,\n            rateLimits,\n            RateLimitData({\n                maxAmount : maxUsdcAmount,\n                slope     : slope\n            }),\n            \"Swap USDS to USDC limit\",\n            6\n        );\n    }\n\n    function setUSDCToCCTPRateLimit(\n        address rateLimits,\n        uint256 maxUsdcAmount,\n        uint256 slope\n    ) internal {\n        RateLimitHelpers.setRateLimitData(\n            LIMIT_USDC_TO_CCTP,\n            rateLimits,\n            RateLimitData({\n                maxAmount : maxUsdcAmount,\n                slope     : slope\n            }),\n            \"Send USDC to CCTP general limit\",\n            6\n        );\n    }\n\n    function setUSDCToDomainRateLimit(\n        address rateLimits,\n        uint32  destinationDomain,\n        uint256 maxUsdcAmount,\n        uint256 slope\n    ) internal {\n        RateLimitHelpers.setRateLimitData(\n            RateLimitHelpers.makeDomainKey(LIMIT_USDC_TO_DOMAIN, destinationDomain),\n            rateLimits,\n            RateLimitData({\n                maxAmount : maxUsdcAmount,\n                slope     : slope\n            }),\n            \"Send USDC via CCTP to a specific domain limit\",\n            6\n        );\n    }\n\n    function addrToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function upgradeMainnetController(address oldController, address newController) internal {\n        MainnetControllerInit.MintRecipient[] memory mintRecipients = new MainnetControllerInit.MintRecipient[](2);\n        mintRecipients[0] = MainnetControllerInit.MintRecipient({\n            domain        : CCTPForwarder.DOMAIN_ID_CIRCLE_BASE,\n            mintRecipient : addrToBytes32(Base.ALM_PROXY)\n        });\n        mintRecipients[1] = MainnetControllerInit.MintRecipient({\n            domain        : CCTPForwarder.DOMAIN_ID_CIRCLE_ARBITRUM_ONE,\n            mintRecipient : addrToBytes32(Arbitrum.ALM_PROXY)\n        });\n\n        MainnetControllerInit.upgradeController({\n            controllerInst: ControllerInstance({\n                almProxy   : Ethereum.ALM_PROXY,\n                controller : newController,\n                rateLimits : Ethereum.ALM_RATE_LIMITS\n            }),\n            configAddresses: MainnetControllerInit.ConfigAddressParams({\n                freezer       : Ethereum.ALM_FREEZER,\n                relayer       : Ethereum.ALM_RELAYER,\n                oldController : oldController\n            }),\n            checkAddresses: MainnetControllerInit.CheckAddressParams({\n                admin      : Ethereum.SPARK_PROXY,\n                proxy      : Ethereum.ALM_PROXY,\n                rateLimits : Ethereum.ALM_RATE_LIMITS,\n                vault      : Ethereum.ALLOCATOR_VAULT,\n                psm        : Ethereum.PSM,\n                daiUsds    : Ethereum.DAI_USDS,\n                cctp       : Ethereum.CCTP_TOKEN_MESSENGER\n            }),\n            mintRecipients: mintRecipients\n        });\n        MainnetController(newController).grantRole(MainnetController(newController).RELAYER(), ALM_RELAYER_BACKUP);\n    }\n\n    function upgradeForeignController(\n        ControllerInstance memory controllerInst,\n        ForeignControllerInit.ConfigAddressParams memory configAddresses,\n        ForeignControllerInit.CheckAddressParams memory checkAddresses\n    ) internal {\n        ForeignControllerInit.MintRecipient[] memory mintRecipients = new ForeignControllerInit.MintRecipient[](1);\n        mintRecipients[0] = ForeignControllerInit.MintRecipient({\n            domain        : CCTPForwarder.DOMAIN_ID_CIRCLE_ETHEREUM,\n            mintRecipient : addrToBytes32(Ethereum.ALM_PROXY)\n        });\n\n        ForeignControllerInit.upgradeController({\n            controllerInst: controllerInst,\n            configAddresses: configAddresses,\n            checkAddresses: checkAddresses,\n            mintRecipients: mintRecipients\n        });\n        ForeignController(controllerInst.controller).grantRole(ForeignController(controllerInst.controller).RELAYER(), ALM_RELAYER_BACKUP);\n    }\n\n}\n"
    },
    "lib/sparklend-kill-switch/lib/aave-v3-core/contracts/interfaces/IPoolAddressesProvider.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\n/**\n * @title IPoolAddressesProvider\n * @author Aave\n * @notice Defines the basic interface for a Pool Addresses Provider.\n */\ninterface IPoolAddressesProvider {\n  /**\n   * @dev Emitted when the market identifier is updated.\n   * @param oldMarketId The old id of the market\n   * @param newMarketId The new id of the market\n   */\n  event MarketIdSet(string indexed oldMarketId, string indexed newMarketId);\n\n  /**\n   * @dev Emitted when the pool is updated.\n   * @param oldAddress The old address of the Pool\n   * @param newAddress The new address of the Pool\n   */\n  event PoolUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the pool configurator is updated.\n   * @param oldAddress The old address of the PoolConfigurator\n   * @param newAddress The new address of the PoolConfigurator\n   */\n  event PoolConfiguratorUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the price oracle is updated.\n   * @param oldAddress The old address of the PriceOracle\n   * @param newAddress The new address of the PriceOracle\n   */\n  event PriceOracleUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the ACL manager is updated.\n   * @param oldAddress The old address of the ACLManager\n   * @param newAddress The new address of the ACLManager\n   */\n  event ACLManagerUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the ACL admin is updated.\n   * @param oldAddress The old address of the ACLAdmin\n   * @param newAddress The new address of the ACLAdmin\n   */\n  event ACLAdminUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the price oracle sentinel is updated.\n   * @param oldAddress The old address of the PriceOracleSentinel\n   * @param newAddress The new address of the PriceOracleSentinel\n   */\n  event PriceOracleSentinelUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the pool data provider is updated.\n   * @param oldAddress The old address of the PoolDataProvider\n   * @param newAddress The new address of the PoolDataProvider\n   */\n  event PoolDataProviderUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when a new proxy is created.\n   * @param id The identifier of the proxy\n   * @param proxyAddress The address of the created proxy contract\n   * @param implementationAddress The address of the implementation contract\n   */\n  event ProxyCreated(\n    bytes32 indexed id,\n    address indexed proxyAddress,\n    address indexed implementationAddress\n  );\n\n  /**\n   * @dev Emitted when a new non-proxied contract address is registered.\n   * @param id The identifier of the contract\n   * @param oldAddress The address of the old contract\n   * @param newAddress The address of the new contract\n   */\n  event AddressSet(bytes32 indexed id, address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the implementation of the proxy registered with id is updated\n   * @param id The identifier of the contract\n   * @param proxyAddress The address of the proxy contract\n   * @param oldImplementationAddress The address of the old implementation contract\n   * @param newImplementationAddress The address of the new implementation contract\n   */\n  event AddressSetAsProxy(\n    bytes32 indexed id,\n    address indexed proxyAddress,\n    address oldImplementationAddress,\n    address indexed newImplementationAddress\n  );\n\n  /**\n   * @notice Returns the id of the Aave market to which this contract points to.\n   * @return The market id\n   */\n  function getMarketId() external view returns (string memory);\n\n  /**\n   * @notice Associates an id with a specific PoolAddressesProvider.\n   * @dev This can be used to create an onchain registry of PoolAddressesProviders to\n   * identify and validate multiple Aave markets.\n   * @param newMarketId The market id\n   */\n  function setMarketId(string calldata newMarketId) external;\n\n  /**\n   * @notice Returns an address by its identifier.\n   * @dev The returned address might be an EOA or a contract, potentially proxied\n   * @dev It returns ZERO if there is no registered address with the given id\n   * @param id The id\n   * @return The address of the registered for the specified id\n   */\n  function getAddress(bytes32 id) external view returns (address);\n\n  /**\n   * @notice General function to update the implementation of a proxy registered with\n   * certain `id`. If there is no proxy registered, it will instantiate one and\n   * set as implementation the `newImplementationAddress`.\n   * @dev IMPORTANT Use this function carefully, only for ids that don't have an explicit\n   * setter function, in order to avoid unexpected consequences\n   * @param id The id\n   * @param newImplementationAddress The address of the new implementation\n   */\n  function setAddressAsProxy(bytes32 id, address newImplementationAddress) external;\n\n  /**\n   * @notice Sets an address for an id replacing the address saved in the addresses map.\n   * @dev IMPORTANT Use this function carefully, as it will do a hard replacement\n   * @param id The id\n   * @param newAddress The address to set\n   */\n  function setAddress(bytes32 id, address newAddress) external;\n\n  /**\n   * @notice Returns the address of the Pool proxy.\n   * @return The Pool proxy address\n   */\n  function getPool() external view returns (address);\n\n  /**\n   * @notice Updates the implementation of the Pool, or creates a proxy\n   * setting the new `pool` implementation when the function is called for the first time.\n   * @param newPoolImpl The new Pool implementation\n   */\n  function setPoolImpl(address newPoolImpl) external;\n\n  /**\n   * @notice Returns the address of the PoolConfigurator proxy.\n   * @return The PoolConfigurator proxy address\n   */\n  function getPoolConfigurator() external view returns (address);\n\n  /**\n   * @notice Updates the implementation of the PoolConfigurator, or creates a proxy\n   * setting the new `PoolConfigurator` implementation when the function is called for the first time.\n   * @param newPoolConfiguratorImpl The new PoolConfigurator implementation\n   */\n  function setPoolConfiguratorImpl(address newPoolConfiguratorImpl) external;\n\n  /**\n   * @notice Returns the address of the price oracle.\n   * @return The address of the PriceOracle\n   */\n  function getPriceOracle() external view returns (address);\n\n  /**\n   * @notice Updates the address of the price oracle.\n   * @param newPriceOracle The address of the new PriceOracle\n   */\n  function setPriceOracle(address newPriceOracle) external;\n\n  /**\n   * @notice Returns the address of the ACL manager.\n   * @return The address of the ACLManager\n   */\n  function getACLManager() external view returns (address);\n\n  /**\n   * @notice Updates the address of the ACL manager.\n   * @param newAclManager The address of the new ACLManager\n   */\n  function setACLManager(address newAclManager) external;\n\n  /**\n   * @notice Returns the address of the ACL admin.\n   * @return The address of the ACL admin\n   */\n  function getACLAdmin() external view returns (address);\n\n  /**\n   * @notice Updates the address of the ACL admin.\n   * @param newAclAdmin The address of the new ACL admin\n   */\n  function setACLAdmin(address newAclAdmin) external;\n\n  /**\n   * @notice Returns the address of the price oracle sentinel.\n   * @return The address of the PriceOracleSentinel\n   */\n  function getPriceOracleSentinel() external view returns (address);\n\n  /**\n   * @notice Updates the address of the price oracle sentinel.\n   * @param newPriceOracleSentinel The address of the new PriceOracleSentinel\n   */\n  function setPriceOracleSentinel(address newPriceOracleSentinel) external;\n\n  /**\n   * @notice Returns the address of the data provider.\n   * @return The address of the DataProvider\n   */\n  function getPoolDataProvider() external view returns (address);\n\n  /**\n   * @notice Updates the address of the data provider.\n   * @param newDataProvider The address of the new DataProvider\n   */\n  function setPoolDataProvider(address newDataProvider) external;\n}\n"
    },
    "lib/sparklend-kill-switch/lib/aave-v3-core/contracts/protocol/libraries/types/DataTypes.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nlibrary DataTypes {\n  struct ReserveData {\n    //stores the reserve configuration\n    ReserveConfigurationMap configuration;\n    //the liquidity index. Expressed in ray\n    uint128 liquidityIndex;\n    //the current supply rate. Expressed in ray\n    uint128 currentLiquidityRate;\n    //variable borrow index. Expressed in ray\n    uint128 variableBorrowIndex;\n    //the current variable borrow rate. Expressed in ray\n    uint128 currentVariableBorrowRate;\n    //the current stable borrow rate. Expressed in ray\n    uint128 currentStableBorrowRate;\n    //timestamp of last update\n    uint40 lastUpdateTimestamp;\n    //the id of the reserve. Represents the position in the list of the active reserves\n    uint16 id;\n    //aToken address\n    address aTokenAddress;\n    //stableDebtToken address\n    address stableDebtTokenAddress;\n    //variableDebtToken address\n    address variableDebtTokenAddress;\n    //address of the interest rate strategy\n    address interestRateStrategyAddress;\n    //the current treasury balance, scaled\n    uint128 accruedToTreasury;\n    //the outstanding unbacked aTokens minted through the bridging feature\n    uint128 unbacked;\n    //the outstanding debt borrowed against this asset in isolation mode\n    uint128 isolationModeTotalDebt;\n  }\n\n  struct ReserveConfigurationMap {\n    //bit 0-15: LTV\n    //bit 16-31: Liq. threshold\n    //bit 32-47: Liq. bonus\n    //bit 48-55: Decimals\n    //bit 56: reserve is active\n    //bit 57: reserve is frozen\n    //bit 58: borrowing is enabled\n    //bit 59: stable rate borrowing enabled\n    //bit 60: asset is paused\n    //bit 61: borrowing in isolation mode is enabled\n    //bit 62: siloed borrowing enabled\n    //bit 63: flashloaning enabled\n    //bit 64-79: reserve factor\n    //bit 80-115 borrow cap in whole tokens, borrowCap == 0 => no cap\n    //bit 116-151 supply cap in whole tokens, supplyCap == 0 => no cap\n    //bit 152-167 liquidation protocol fee\n    //bit 168-175 eMode category\n    //bit 176-211 unbacked mint cap in whole tokens, unbackedMintCap == 0 => minting disabled\n    //bit 212-251 debt ceiling for isolation mode with (ReserveConfiguration::DEBT_CEILING_DECIMALS) decimals\n    //bit 252-255 unused\n\n    uint256 data;\n  }\n\n  struct UserConfigurationMap {\n    /**\n     * @dev Bitmap of the users collaterals and borrows. It is divided in pairs of bits, one pair per asset.\n     * The first bit indicates if an asset is used as collateral by the user, the second whether an\n     * asset is borrowed by the user.\n     */\n    uint256 data;\n  }\n\n  struct EModeCategory {\n    // each eMode category has a custom ltv and liquidation threshold\n    uint16 ltv;\n    uint16 liquidationThreshold;\n    uint16 liquidationBonus;\n    // each eMode category may or may not have a custom oracle to override the individual assets price oracles\n    address priceSource;\n    string label;\n  }\n\n  enum InterestRateMode {NONE, STABLE, VARIABLE}\n\n  struct ReserveCache {\n    uint256 currScaledVariableDebt;\n    uint256 nextScaledVariableDebt;\n    uint256 currPrincipalStableDebt;\n    uint256 currAvgStableBorrowRate;\n    uint256 currTotalStableDebt;\n    uint256 nextAvgStableBorrowRate;\n    uint256 nextTotalStableDebt;\n    uint256 currLiquidityIndex;\n    uint256 nextLiquidityIndex;\n    uint256 currVariableBorrowIndex;\n    uint256 nextVariableBorrowIndex;\n    uint256 currLiquidityRate;\n    uint256 currVariableBorrowRate;\n    uint256 reserveFactor;\n    ReserveConfigurationMap reserveConfiguration;\n    address aTokenAddress;\n    address stableDebtTokenAddress;\n    address variableDebtTokenAddress;\n    uint40 reserveLastUpdateTimestamp;\n    uint40 stableDebtLastUpdateTimestamp;\n  }\n\n  struct ExecuteLiquidationCallParams {\n    uint256 reservesCount;\n    uint256 debtToCover;\n    address collateralAsset;\n    address debtAsset;\n    address user;\n    bool receiveAToken;\n    address priceOracle;\n    uint8 userEModeCategory;\n    address priceOracleSentinel;\n  }\n\n  struct ExecuteSupplyParams {\n    address asset;\n    uint256 amount;\n    address onBehalfOf;\n    uint16 referralCode;\n  }\n\n  struct ExecuteBorrowParams {\n    address asset;\n    address user;\n    address onBehalfOf;\n    uint256 amount;\n    InterestRateMode interestRateMode;\n    uint16 referralCode;\n    bool releaseUnderlying;\n    uint256 maxStableRateBorrowSizePercent;\n    uint256 reservesCount;\n    address oracle;\n    uint8 userEModeCategory;\n    address priceOracleSentinel;\n  }\n\n  struct ExecuteRepayParams {\n    address asset;\n    uint256 amount;\n    InterestRateMode interestRateMode;\n    address onBehalfOf;\n    bool useATokens;\n  }\n\n  struct ExecuteWithdrawParams {\n    address asset;\n    uint256 amount;\n    address to;\n    uint256 reservesCount;\n    address oracle;\n    uint8 userEModeCategory;\n  }\n\n  struct ExecuteSetUserEModeParams {\n    uint256 reservesCount;\n    address oracle;\n    uint8 categoryId;\n  }\n\n  struct FinalizeTransferParams {\n    address asset;\n    address from;\n    address to;\n    uint256 amount;\n    uint256 balanceFromBefore;\n    uint256 balanceToBefore;\n    uint256 reservesCount;\n    address oracle;\n    uint8 fromEModeCategory;\n  }\n\n  struct FlashloanParams {\n    address receiverAddress;\n    address[] assets;\n    uint256[] amounts;\n    uint256[] interestRateModes;\n    address onBehalfOf;\n    bytes params;\n    uint16 referralCode;\n    uint256 flashLoanPremiumToProtocol;\n    uint256 flashLoanPremiumTotal;\n    uint256 maxStableRateBorrowSizePercent;\n    uint256 reservesCount;\n    address addressesProvider;\n    uint8 userEModeCategory;\n    bool isAuthorizedFlashBorrower;\n  }\n\n  struct FlashloanSimpleParams {\n    address receiverAddress;\n    address asset;\n    uint256 amount;\n    bytes params;\n    uint16 referralCode;\n    uint256 flashLoanPremiumToProtocol;\n    uint256 flashLoanPremiumTotal;\n  }\n\n  struct FlashLoanRepaymentParams {\n    uint256 amount;\n    uint256 totalPremium;\n    uint256 flashLoanPremiumToProtocol;\n    address asset;\n    address receiverAddress;\n    uint16 referralCode;\n  }\n\n  struct CalculateUserAccountDataParams {\n    UserConfigurationMap userConfig;\n    uint256 reservesCount;\n    address user;\n    address oracle;\n    uint8 userEModeCategory;\n  }\n\n  struct ValidateBorrowParams {\n    ReserveCache reserveCache;\n    UserConfigurationMap userConfig;\n    address asset;\n    address userAddress;\n    uint256 amount;\n    InterestRateMode interestRateMode;\n    uint256 maxStableLoanPercent;\n    uint256 reservesCount;\n    address oracle;\n    uint8 userEModeCategory;\n    address priceOracleSentinel;\n    bool isolationModeActive;\n    address isolationModeCollateralAddress;\n    uint256 isolationModeDebtCeiling;\n  }\n\n  struct ValidateLiquidationCallParams {\n    ReserveCache debtReserveCache;\n    uint256 totalDebt;\n    uint256 healthFactor;\n    address priceOracleSentinel;\n  }\n\n  struct CalculateInterestRatesParams {\n    uint256 unbacked;\n    uint256 liquidityAdded;\n    uint256 liquidityTaken;\n    uint256 totalStableDebt;\n    uint256 totalVariableDebt;\n    uint256 averageStableBorrowRate;\n    uint256 reserveFactor;\n    address reserve;\n    address aToken;\n  }\n\n  struct InitReserveParams {\n    address asset;\n    address aTokenAddress;\n    address stableDebtAddress;\n    address variableDebtAddress;\n    address interestRateStrategyAddress;\n    uint16 reservesCount;\n    uint16 maxNumberReserves;\n  }\n}\n"
    },
    "lib/sparklend-kill-switch/lib/aave-v3-core/contracts/protocol/libraries/types/ConfiguratorInputTypes.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nlibrary ConfiguratorInputTypes {\n  struct InitReserveInput {\n    address aTokenImpl;\n    address stableDebtTokenImpl;\n    address variableDebtTokenImpl;\n    uint8 underlyingAssetDecimals;\n    address interestRateStrategyAddress;\n    address underlyingAsset;\n    address treasury;\n    address incentivesController;\n    string aTokenName;\n    string aTokenSymbol;\n    string variableDebtTokenName;\n    string variableDebtTokenSymbol;\n    string stableDebtTokenName;\n    string stableDebtTokenSymbol;\n    bytes params;\n  }\n\n  struct UpdateATokenInput {\n    address asset;\n    address treasury;\n    address incentivesController;\n    string name;\n    string symbol;\n    address implementation;\n    bytes params;\n  }\n\n  struct UpdateDebtTokenInput {\n    address asset;\n    address incentivesController;\n    string name;\n    string symbol;\n    address implementation;\n    bytes params;\n  }\n}\n"
    },
    "src/libraries/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n// From commit https://github.com/OpenZeppelin/openzeppelin-contracts/commit/8b778fa20d6d76340c5fac1ed66c80273f05b95a\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n  /**\n   * @dev Returns true if `account` is a contract.\n   *\n   * [IMPORTANT]\n   * ====\n   * It is unsafe to assume that an address for which this function returns\n   * false is an externally-owned account (EOA) and not a contract.\n   *\n   * Among others, `isContract` will return false for the following\n   * types of addresses:\n   *\n   *  - an externally-owned account\n   *  - a contract in construction\n   *  - an address where a contract will be created\n   *  - an address where a contract lived, but was destroyed\n   * ====\n   *\n   * [IMPORTANT]\n   * ====\n   * You shouldn't rely on `isContract` to protect against flash loan attacks!\n   *\n   * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n   * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n   * constructor.\n   * ====\n   */\n  function isContract(address account) internal view returns (bool) {\n    // This method relies on extcodesize/address.code.length, which returns 0\n    // for contracts in construction, since the code is only stored at the end\n    // of the constructor execution.\n\n    return account.code.length > 0;\n  }\n\n  /**\n   * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n   * `recipient`, forwarding all available gas and reverting on errors.\n   *\n   * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n   * of certain opcodes, possibly making contracts go over the 2300 gas limit\n   * imposed by `transfer`, making them unable to receive funds via\n   * `transfer`. {sendValue} removes this limitation.\n   *\n   * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n   *\n   * IMPORTANT: because control is transferred to `recipient`, care must be\n   * taken to not create reentrancy vulnerabilities. Consider using\n   * {ReentrancyGuard} or the\n   * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n   */\n  function sendValue(address payable recipient, uint256 amount) internal {\n    require(address(this).balance >= amount, 'Address: insufficient balance');\n\n    (bool success, ) = recipient.call{value: amount}('');\n    require(success, 'Address: unable to send value, recipient may have reverted');\n  }\n\n  /**\n   * @dev Performs a Solidity function call using a low level `call`. A\n   * plain `call` is an unsafe replacement for a function call: use this\n   * function instead.\n   *\n   * If `target` reverts with a revert reason, it is bubbled up by this\n   * function (like regular Solidity function calls).\n   *\n   * Returns the raw returned data. To convert to the expected return value,\n   * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n   *\n   * Requirements:\n   *\n   * - `target` must be a contract.\n   * - calling `target` with `data` must not revert.\n   *\n   * _Available since v3.1._\n   */\n  function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n    return functionCallWithValue(target, data, 0, 'Address: low-level call failed');\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n   * `errorMessage` as a fallback revert reason when `target` reverts.\n   *\n   * _Available since v3.1._\n   */\n  function functionCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    return functionCallWithValue(target, data, 0, errorMessage);\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n   * but also transferring `value` wei to `target`.\n   *\n   * Requirements:\n   *\n   * - the calling contract must have an ETH balance of at least `value`.\n   * - the called Solidity function must be `payable`.\n   *\n   * _Available since v3.1._\n   */\n  function functionCallWithValue(\n    address target,\n    bytes memory data,\n    uint256 value\n  ) internal returns (bytes memory) {\n    return functionCallWithValue(target, data, value, 'Address: low-level call with value failed');\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n   * with `errorMessage` as a fallback revert reason when `target` reverts.\n   *\n   * _Available since v3.1._\n   */\n  function functionCallWithValue(\n    address target,\n    bytes memory data,\n    uint256 value,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    require(address(this).balance >= value, 'Address: insufficient balance for call');\n    (bool success, bytes memory returndata) = target.call{value: value}(data);\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n   * but performing a static call.\n   *\n   * _Available since v3.3._\n   */\n  function functionStaticCall(address target, bytes memory data)\n    internal\n    view\n    returns (bytes memory)\n  {\n    return functionStaticCall(target, data, 'Address: low-level static call failed');\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n   * but performing a static call.\n   *\n   * _Available since v3.3._\n   */\n  function functionStaticCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal view returns (bytes memory) {\n    (bool success, bytes memory returndata) = target.staticcall(data);\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n   * but performing a delegate call.\n   *\n   * _Available since v3.4._\n   */\n  function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n    return functionDelegateCall(target, data, 'Address: low-level delegate call failed');\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n   * but performing a delegate call.\n   *\n   * _Available since v3.4._\n   */\n  function functionDelegateCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    (bool success, bytes memory returndata) = target.delegatecall(data);\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n  }\n\n  /**\n   * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n   * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n   *\n   * _Available since v4.8._\n   */\n  function verifyCallResultFromTarget(\n    address target,\n    bool success,\n    bytes memory returndata,\n    string memory errorMessage\n  ) internal view returns (bytes memory) {\n    if (success) {\n      if (returndata.length == 0) {\n        // only check isContract if the call was successful and the return data is empty\n        // otherwise we already know that it was a contract\n        require(isContract(target), 'Address: call to non-contract');\n      }\n      return returndata;\n    } else {\n      _revert(returndata, errorMessage);\n    }\n  }\n\n  /**\n   * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n   * revert reason or using the provided one.\n   *\n   * _Available since v4.3._\n   */\n  function verifyCallResult(\n    bool success,\n    bytes memory returndata,\n    string memory errorMessage\n  ) internal pure returns (bytes memory) {\n    if (success) {\n      return returndata;\n    } else {\n      _revert(returndata, errorMessage);\n    }\n  }\n\n  function _revert(bytes memory returndata, string memory errorMessage) private pure {\n    // Look for revert reason and bubble it up if present\n    if (returndata.length > 0) {\n      // The easiest way to bubble the revert reason is using memory via assembly\n      /// @solidity memory-safe-assembly\n      assembly {\n        let returndata_size := mload(returndata)\n        revert(add(32, returndata), returndata_size)\n      }\n    } else {\n      revert(errorMessage);\n    }\n  }\n}\n"
    },
    "src/interfaces/IAaveV3ConfigEngine.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IPool} from 'sparklend-v1-core/contracts/interfaces/IPool.sol';\nimport {IPoolConfigurator} from 'sparklend-v1-core/contracts/interfaces/IPoolConfigurator.sol';\nimport {IAaveOracle} from 'sparklend-v1-core/contracts/interfaces/IAaveOracle.sol';\nimport {IV3RateStrategyFactory} from './IV3RateStrategyFactory.sol';\n\n/// @dev Examples here assume the usage of the `AaveV3PayloadBase` base contracts\n/// contained in this same repository\ninterface IAaveV3ConfigEngine {\n  /**\n   * @dev Required for naming of a/v/s tokens\n   * Example (mock):\n   * PoolContext({\n   *   networkName: 'Polygon',\n   *   networkAbbreviation: 'Pol'\n   * })\n   */\n  struct PoolContext {\n    string networkName;\n    string networkAbbreviation;\n  }\n\n  /**\n   * @dev Example (mock):\n   * Listing({\n   *   asset: 0x7Fc66500c84A76Ad7e9c93437bFc5Ac33E2DDaE9,\n   *   assetSymbol: 'AAVE',\n   *   priceFeed: 0x547a514d5e3769680Ce22B2361c10Ea13619e8a9,\n   *   rateStrategyParams: Rates.RateStrategyParams({\n   *     optimalUsageRatio: _bpsToRay(80_00),\n   *     baseVariableBorrowRate: _bpsToRay(25), // 0.25%\n   *     variableRateSlope1: _bpsToRay(3_00),\n   *     variableRateSlope2: _bpsToRay(75_00),\n   *     stableRateSlope1: _bpsToRay(3_00),\n   *     stableRateSlope2: _bpsToRay(75_00),\n   *     baseStableRateOffset: _bpsToRay(2_00),\n   *     stableRateExcessOffset: _bpsToRay(3_00),\n   *     optimalStableToTotalDebtRatio: _bpsToRay(30_00)\n   *   }),\n   *   enabledToBorrow: EngineFlags.ENABLED,\n   *   flashloanable: EngineFlags.ENABLED,\n   *   stableRateModeEnabled: EngineFlags.DISABLED,\n   *   borrowableInIsolation: EngineFlags.ENABLED,\n   *   withSiloedBorrowing:, EngineFlags.DISABLED,\n   *   ltv: 70_50, // 70.5%\n   *   liqThreshold: 76_00, // 76%\n   *   liqBonus: 5_00, // 5%\n   *   reserveFactor: 10_00, // 10%\n   *   supplyCap: 100_000, // 100k AAVE\n   *   borrowCap: 60_000, // 60k AAVE\n   *   debtCeiling: 100_000, // 100k USD\n   *   liqProtocolFee: 10_00, // 10%\n   *   eModeCategory: 0, // No category\n   * }\n   */\n  struct Listing {\n    address asset;\n    string assetSymbol;\n    address priceFeed;\n    IV3RateStrategyFactory.RateStrategyParams rateStrategyParams; // Mandatory, no matter if enabled for borrowing or not\n    uint256 enabledToBorrow;\n    uint256 stableRateModeEnabled; // Only considered is enabledToBorrow == EngineFlags.ENABLED (true)\n    uint256 borrowableInIsolation; // Only considered is enabledToBorrow == EngineFlags.ENABLED (true)\n    uint256 withSiloedBorrowing; // Only considered if enabledToBorrow == EngineFlags.ENABLED (true)\n    uint256 flashloanable; // Independent from enabled to borrow: an asset can be flashloanble and not enabled to borrow\n    uint256 ltv; // Only considered if liqThreshold > 0\n    uint256 liqThreshold; // If `0`, the asset will not be enabled as collateral\n    uint256 liqBonus; // Only considered if liqThreshold > 0\n    uint256 reserveFactor; // Only considered if enabledToBorrow == EngineFlags.ENABLED (true)\n    uint256 supplyCap; // If passing any value distinct to EngineFlags.KEEP_CURRENT, always configured\n    uint256 borrowCap; // If passing any value distinct to EngineFlags.KEEP_CURRENT, always configured\n    uint256 debtCeiling; // Only considered if liqThreshold > 0\n    uint256 liqProtocolFee; // Only considered if liqThreshold > 0\n    uint8 eModeCategory; // If `O`, no eMode category will be set\n  }\n\n  struct TokenImplementations {\n    address aToken;\n    address vToken;\n    address sToken;\n  }\n\n  struct ListingWithCustomImpl {\n    Listing base;\n    TokenImplementations implementations;\n  }\n\n  /**\n   * @dev Example (mock):\n   * CapsUpdate({\n   *   asset: AaveV3EthereumAssets.AAVE_UNDERLYING,\n   *   supplyCap: 1_000_000,\n   *   borrowCap: EngineFlags.KEEP_CURRENT\n   * }\n   */\n  struct CapsUpdate {\n    address asset;\n    uint256 supplyCap; // Pass any value, of EngineFlags.KEEP_CURRENT to keep it as it is\n    uint256 borrowCap; // Pass any value, of EngineFlags.KEEP_CURRENT to keep it as it is\n  }\n\n  /**\n   * @dev Example (mock):\n   * PriceFeedUpdate({\n   *   asset: AaveV3EthereumAssets.AAVE_UNDERLYING,\n   *   priceFeed: 0x547a514d5e3769680Ce22B2361c10Ea13619e8a9\n   * })\n   */\n  struct PriceFeedUpdate {\n    address asset;\n    address priceFeed;\n  }\n\n  /**\n   * @dev Example (mock):\n   * CollateralUpdate({\n   *   asset: AaveV3EthereumAssets.AAVE_UNDERLYING,\n   *   ltv: 60_00,\n   *   liqThreshold: 70_00,\n   *   liqBonus: EngineFlags.KEEP_CURRENT,\n   *   debtCeiling: EngineFlags.KEEP_CURRENT,\n   *   liqProtocolFee: 7_00,\n   *   eModeCategory: EngineFlags.KEEP_CURRENT\n   * })\n   */\n  struct CollateralUpdate {\n    address asset;\n    uint256 ltv;\n    uint256 liqThreshold;\n    uint256 liqBonus;\n    uint256 debtCeiling;\n    uint256 liqProtocolFee;\n    uint256 eModeCategory;\n  }\n\n  /**\n   * @dev Example (mock):\n   * BorrowUpdate({\n   *   asset: AaveV3EthereumAssets.AAVE_UNDERLYING,\n   *   enabledToBorrow: EngineFlags.ENABLED,\n   *   flashloanable: EngineFlags.KEEP_CURRENT,\n   *   stableRateModeEnabled: EngineFlags.KEEP_CURRENT,\n   *   borrowableInIsolation: EngineFlags.KEEP_CURRENT,\n   *   withSiloedBorrowing: EngineFlags.KEEP_CURRENT,\n   *   reserveFactor: 15_00, // 15%\n   * })\n   */\n  struct BorrowUpdate {\n    address asset;\n    uint256 enabledToBorrow;\n    uint256 flashloanable;\n    uint256 stableRateModeEnabled;\n    uint256 borrowableInIsolation;\n    uint256 withSiloedBorrowing;\n    uint256 reserveFactor;\n  }\n\n  /**\n   * @dev Example (mock):\n   * RateStrategyUpdate({\n   *   asset: AaveV3OptimismAssets.USDT_UNDERLYING,\n   *   params: Rates.RateStrategyParams({\n   *     optimalUsageRatio: _bpsToRay(80_00),\n   *     baseVariableBorrowRate: EngineFlags.KEEP_CURRENT,\n   *     variableRateSlope1: EngineFlags.KEEP_CURRENT,\n   *     variableRateSlope2: _bpsToRay(75_00),\n   *     stableRateSlope1: EngineFlags.KEEP_CURRENT,\n   *     stableRateSlope2: _bpsToRay(75_00),\n   *     baseStableRateOffset: EngineFlags.KEEP_CURRENT,\n   *     stableRateExcessOffset: EngineFlags.KEEP_CURRENT,\n   *     optimalStableToTotalDebtRatio: EngineFlags.KEEP_CURRENT\n   *   })\n   * })\n   */\n  struct RateStrategyUpdate {\n    address asset;\n    IV3RateStrategyFactory.RateStrategyParams params;\n  }\n\n  /**\n   * @notice Performs full listing of the assets, in the Aave pool configured in this engine instance\n   * @param context `PoolContext` struct, effectively meta-data for naming of a/v/s tokens.\n   *   More information on the documentation of the struct.\n   * @param listings `Listing[]` list of declarative configs for every aspect of the asset listings.\n   *   More information on the documentation of the struct.\n   */\n  function listAssets(PoolContext memory context, Listing[] memory listings) external;\n\n  /**\n   * @notice Performs full listings of assets, in the Aave pool configured in this engine instance\n   * @dev This function allows more customization, especifically enables to set custom implementations\n   *   for a/v/s tokens.\n   *   IMPORTANT. Use it only if understanding the internals of the Aave v3 protocol\n   * @param context `PoolContext` struct, effectively meta-data for naming of a/v/s tokens.\n   *   More information on the documentation of the struct.\n   * @param listings `ListingWithCustomImpl[]` list of declarative configs for every aspect of the asset listings.\n   */\n  function listAssetsCustom(\n    PoolContext memory context,\n    ListingWithCustomImpl[] memory listings\n  ) external;\n\n  /**\n   * @notice Performs an update of the caps (supply, borrow) of the assets, in the Aave pool configured in this engine instance\n   * @param updates `CapsUpdate[]` list of declarative updates containing the new caps\n   *   More information on the documentation of the struct.\n   */\n  function updateCaps(CapsUpdate[] memory updates) external;\n\n  /**\n   * @notice Performs an update on the rate strategy params of the assets, in the Aave pool configured in this engine instance\n   * @dev The engine itself manages if a new rate strategy needs to be deployed or if an existing one can be re-used\n   * @param updates `RateStrategyUpdate[]` list of declarative updates containing the new rate strategy params\n   *   More information on the documentation of the struct.\n   */\n  function updateRateStrategies(RateStrategyUpdate[] memory updates) external;\n\n  /**\n   * @notice Performs an update of the collateral-related params of the assets, in the Aave pool configured in this engine instance\n   * @param updates `CollateralUpdate[]` list of declarative updates containing the new parameters\n   *   More information on the documentation of the struct.\n   */\n  function updateCollateralSide(CollateralUpdate[] memory updates) external;\n\n  /**\n   * @notice Performs an update of the price feed of the assets, in the Aave pool configured in this engine instance\n   * @param updates `PriceFeedUpdate[]` list of declarative updates containing the new parameters\n   *   More information on the documentation of the struct.\n   */\n  function updatePriceFeeds(PriceFeedUpdate[] memory updates) external;\n\n  /**\n   * @notice Performs an update of the borrow-related params of the assets, in the Aave pool configured in this engine instance\n   * @param updates `BorrowUpdate[]` list of declarative updates containing the new parameters\n   *   More information on the documentation of the struct.\n   */\n  function updateBorrowSide(BorrowUpdate[] memory updates) external;\n\n  function RATE_STRATEGIES_FACTORY() external view returns (IV3RateStrategyFactory);\n\n  function POOL() external view returns (IPool);\n\n  function POOL_CONFIGURATOR() external view returns (IPoolConfigurator);\n\n  function ORACLE() external view returns (IAaveOracle);\n\n  function ATOKEN_IMPL() external view returns (address);\n\n  function VTOKEN_IMPL() external view returns (address);\n\n  function STOKEN_IMPL() external view returns (address);\n\n  function REWARDS_CONTROLLER() external view returns (address);\n\n  function COLLECTOR() external view returns (address);\n}\n"
    },
    "src/interfaces/IV3RateStrategyFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IPoolAddressesProvider} from 'sparklend-v1-core/contracts/interfaces/IPoolAddressesProvider.sol';\nimport {IDefaultInterestRateStrategy} from 'sparklend-v1-core/contracts/interfaces/IDefaultInterestRateStrategy.sol';\n\ninterface IV3RateStrategyFactory {\n  event RateStrategyCreated(\n    address indexed strategy,\n    bytes32 indexed hashedParam,\n    RateStrategyParams params\n  );\n\n  /// @dev same parameters and the ones received on the constructor of DefaultReserveInterestRateStrategy\n  /// in practise defining the strategy itself\n  struct RateStrategyParams {\n    uint256 optimalUsageRatio;\n    uint256 baseVariableBorrowRate;\n    uint256 variableRateSlope1;\n    uint256 variableRateSlope2;\n    uint256 stableRateSlope1;\n    uint256 stableRateSlope2;\n    uint256 baseStableRateOffset;\n    uint256 stableRateExcessOffset;\n    uint256 optimalStableToTotalDebtRatio;\n  }\n\n  /**\n   * @notice Create new rate strategies from a list of parameters\n   * @dev If a strategy with exactly the same `RateStrategyParams` already exists, no creation happens but\n   *  its address is returned\n   * @param params `RateStrategyParams[]` list of parameters for multiple strategies\n   * @return address[] list of strategies\n   */\n  function createStrategies(RateStrategyParams[] memory params) external returns (address[] memory);\n\n  /**\n   * @notice Returns the identifier of a rate strategy from its parameters\n   * @param params `RateStrategyParams` the parameters of the rate strategy\n   * @return bytes32 the keccak256 hash generated from the `RateStrategyParams` parameters\n   *   to be used as identifier of the rate strategy on the factory\n   */\n  function strategyHashFromParams(RateStrategyParams memory params) external pure returns (bytes32);\n\n  /**\n   * @notice Returns all the strategies registered in the factory\n   * @return address[] list of strategies\n   */\n  function getAllStrategies() external view returns (address[] memory);\n\n  /**\n   * @notice Returns the a strategy added, given its parameters.\n   * @dev Only if the strategy is registered in the factory.\n   * @param params `RateStrategyParams` the parameters of the rate strategy\n   * @return address the address of the strategy\n   */\n  function getStrategyByParams(RateStrategyParams memory params) external view returns (address);\n\n  /**\n   * @notice From an asset in the Aave v3 pool, returns exclusively its parameters\n   * @param asset The address of the asset\n   * @return RateStrategyParams The parameters or the strategy, or empty RateStrategyParams struct\n   */\n  function getStrategyDataOfAsset(address asset) external view returns (RateStrategyParams memory);\n\n  /**\n   * @notice From a rate strategy address, returns its parameters\n   * @param strategy The address of the rate strategy\n   * @return RateStrategyParams Struct with the parameters of the strategy\n   */\n  function getStrategyData(\n    IDefaultInterestRateStrategy strategy\n  ) external view returns (RateStrategyParams memory);\n\n  function ADDRESSES_PROVIDER() external view returns (IPoolAddressesProvider);\n}\n"
    },
    "lib/metamorpho/lib/openzeppelin-contracts/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n"
    },
    "lib/spark-alm-controller/lib/aave-v3-origin/src/core/contracts/interfaces/IAToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC20} from '../dependencies/openzeppelin/contracts/IERC20.sol';\nimport {IScaledBalanceToken} from './IScaledBalanceToken.sol';\nimport {IInitializableAToken} from './IInitializableAToken.sol';\n\n/**\n * @title IAToken\n * @author Aave\n * @notice Defines the basic interface for an AToken.\n */\ninterface IAToken is IERC20, IScaledBalanceToken, IInitializableAToken {\n  /**\n   * @dev Emitted during the transfer action\n   * @param from The user whose tokens are being transferred\n   * @param to The recipient\n   * @param value The scaled amount being transferred\n   * @param index The next liquidity index of the reserve\n   */\n  event BalanceTransfer(address indexed from, address indexed to, uint256 value, uint256 index);\n\n  /**\n   * @notice Mints `amount` aTokens to `user`\n   * @param caller The address performing the mint\n   * @param onBehalfOf The address of the user that will receive the minted aTokens\n   * @param amount The amount of tokens getting minted\n   * @param index The next liquidity index of the reserve\n   * @return `true` if the the previous balance of the user was 0\n   */\n  function mint(\n    address caller,\n    address onBehalfOf,\n    uint256 amount,\n    uint256 index\n  ) external returns (bool);\n\n  /**\n   * @notice Burns aTokens from `user` and sends the equivalent amount of underlying to `receiverOfUnderlying`\n   * @dev In some instances, the mint event could be emitted from a burn transaction\n   * if the amount to burn is less than the interest that the user accrued\n   * @param from The address from which the aTokens will be burned\n   * @param receiverOfUnderlying The address that will receive the underlying\n   * @param amount The amount being burned\n   * @param index The next liquidity index of the reserve\n   */\n  function burn(address from, address receiverOfUnderlying, uint256 amount, uint256 index) external;\n\n  /**\n   * @notice Mints aTokens to the reserve treasury\n   * @param amount The amount of tokens getting minted\n   * @param index The next liquidity index of the reserve\n   */\n  function mintToTreasury(uint256 amount, uint256 index) external;\n\n  /**\n   * @notice Transfers aTokens in the event of a borrow being liquidated, in case the liquidators reclaims the aToken\n   * @param from The address getting liquidated, current owner of the aTokens\n   * @param to The recipient\n   * @param value The amount of tokens getting transferred\n   */\n  function transferOnLiquidation(address from, address to, uint256 value) external;\n\n  /**\n   * @notice Transfers the underlying asset to `target`.\n   * @dev Used by the Pool to transfer assets in borrow(), withdraw() and flashLoan()\n   * @param target The recipient of the underlying\n   * @param amount The amount getting transferred\n   */\n  function transferUnderlyingTo(address target, uint256 amount) external;\n\n  /**\n   * @notice Handles the underlying received by the aToken after the transfer has been completed.\n   * @dev The default implementation is empty as with standard ERC20 tokens, nothing needs to be done after the\n   * transfer is concluded. However in the future there may be aTokens that allow for example to stake the underlying\n   * to receive LM rewards. In that case, `handleRepayment()` would perform the staking of the underlying asset.\n   * @param user The user executing the repayment\n   * @param onBehalfOf The address of the user who will get his debt reduced/removed\n   * @param amount The amount getting repaid\n   */\n  function handleRepayment(address user, address onBehalfOf, uint256 amount) external;\n\n  /**\n   * @notice Allow passing a signed message to approve spending\n   * @dev implements the permit function as for\n   * https://github.com/ethereum/EIPs/blob/8a34d644aacf0f9f8f00815307fd7dd5da07655f/EIPS/eip-2612.md\n   * @param owner The owner of the funds\n   * @param spender The spender\n   * @param value The amount\n   * @param deadline The deadline timestamp, type(uint256).max for max deadline\n   * @param v Signature param\n   * @param s Signature param\n   * @param r Signature param\n   */\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n\n  /**\n   * @notice Returns the address of the underlying asset of this aToken (E.g. WETH for aWETH)\n   * @return The address of the underlying asset\n   */\n  function UNDERLYING_ASSET_ADDRESS() external view returns (address);\n\n  /**\n   * @notice Returns the address of the Aave treasury, receiving the fees on this aToken.\n   * @return Address of the Aave treasury\n   */\n  function RESERVE_TREASURY_ADDRESS() external view returns (address);\n\n  /**\n   * @notice Get the domain separator for the token\n   * @dev Return cached value if chainId matches cache, otherwise recomputes separator\n   * @return The domain separator of the token at current chain\n   */\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n  /**\n   * @notice Returns the nonce for owner.\n   * @param owner The address of the owner\n   * @return The nonce of the owner\n   */\n  function nonces(address owner) external view returns (uint256);\n\n  /**\n   * @notice Rescue and transfer tokens locked in this contract\n   * @param token The address of the token\n   * @param to The address of the recipient\n   * @param amount The amount of token to transfer\n   */\n  function rescueTokens(address token, address to, uint256 amount) external;\n}\n"
    },
    "lib/forge-std/src/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2;\n\n/// @dev Interface of the ERC20 standard as defined in the EIP.\n/// @dev This includes the optional name, symbol, and decimals metadata.\ninterface IERC20 {\n    /// @dev Emitted when `value` tokens are moved from one account (`from`) to another (`to`).\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /// @dev Emitted when the allowance of a `spender` for an `owner` is set, where `value`\n    /// is the new allowance.\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /// @notice Returns the amount of tokens in existence.\n    function totalSupply() external view returns (uint256);\n\n    /// @notice Returns the amount of tokens owned by `account`.\n    function balanceOf(address account) external view returns (uint256);\n\n    /// @notice Moves `amount` tokens from the caller's account to `to`.\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /// @notice Returns the remaining number of tokens that `spender` is allowed\n    /// to spend on behalf of `owner`\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /// @notice Sets `amount` as the allowance of `spender` over the caller's tokens.\n    /// @dev Be aware of front-running risks: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /// @notice Moves `amount` tokens from `from` to `to` using the allowance mechanism.\n    /// `amount` is then deducted from the caller's allowance.\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n\n    /// @notice Returns the name of the token.\n    function name() external view returns (string memory);\n\n    /// @notice Returns the symbol of the token.\n    function symbol() external view returns (string memory);\n\n    /// @notice Returns the decimals places of the token.\n    function decimals() external view returns (uint8);\n}\n"
    },
    "lib/forge-std/src/interfaces/IERC4626.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2;\n\nimport {IERC20} from \"./IERC20.sol\";\n\n/// @dev Interface of the ERC4626 \"Tokenized Vault Standard\", as defined in\n/// https://eips.ethereum.org/EIPS/eip-4626\ninterface IERC4626 is IERC20 {\n    event Deposit(address indexed sender, address indexed owner, uint256 assets, uint256 shares);\n\n    event Withdraw(\n        address indexed sender, address indexed receiver, address indexed owner, uint256 assets, uint256 shares\n    );\n\n    /// @notice Returns the address of the underlying token used for the Vault for accounting, depositing, and withdrawing.\n    /// @dev\n    /// - MUST be an ERC-20 token contract.\n    /// - MUST NOT revert.\n    function asset() external view returns (address assetTokenAddress);\n\n    /// @notice Returns the total amount of the underlying asset that is managed by Vault.\n    /// @dev\n    /// - SHOULD include any compounding that occurs from yield.\n    /// - MUST be inclusive of any fees that are charged against assets in the Vault.\n    /// - MUST NOT revert.\n    function totalAssets() external view returns (uint256 totalManagedAssets);\n\n    /// @notice Returns the amount of shares that the Vault would exchange for the amount of assets provided, in an ideal\n    /// scenario where all the conditions are met.\n    /// @dev\n    /// - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n    /// - MUST NOT show any variations depending on the caller.\n    /// - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n    /// - MUST NOT revert.\n    ///\n    /// NOTE: This calculation MAY NOT reflect the per-user price-per-share, and instead should reflect the\n    /// average-users price-per-share, meaning what the average user should expect to see when exchanging to and\n    /// from.\n    function convertToShares(uint256 assets) external view returns (uint256 shares);\n\n    /// @notice Returns the amount of assets that the Vault would exchange for the amount of shares provided, in an ideal\n    /// scenario where all the conditions are met.\n    /// @dev\n    /// - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n    /// - MUST NOT show any variations depending on the caller.\n    /// - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n    /// - MUST NOT revert.\n    ///\n    /// NOTE: This calculation MAY NOT reflect the per-user price-per-share, and instead should reflect the\n    /// average-users price-per-share, meaning what the average user should expect to see when exchanging to and\n    /// from.\n    function convertToAssets(uint256 shares) external view returns (uint256 assets);\n\n    /// @notice Returns the maximum amount of the underlying asset that can be deposited into the Vault for the receiver,\n    /// through a deposit call.\n    /// @dev\n    /// - MUST return a limited value if receiver is subject to some deposit limit.\n    /// - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of assets that may be deposited.\n    /// - MUST NOT revert.\n    function maxDeposit(address receiver) external view returns (uint256 maxAssets);\n\n    /// @notice Allows an on-chain or off-chain user to simulate the effects of their deposit at the current block, given\n    /// current on-chain conditions.\n    /// @dev\n    /// - MUST return as close to and no more than the exact amount of Vault shares that would be minted in a deposit\n    ///   call in the same transaction. I.e. deposit should return the same or more shares as previewDeposit if called\n    ///   in the same transaction.\n    /// - MUST NOT account for deposit limits like those returned from maxDeposit and should always act as though the\n    ///   deposit would be accepted, regardless if the user has enough tokens approved, etc.\n    /// - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n    /// - MUST NOT revert.\n    ///\n    /// NOTE: any unfavorable discrepancy between convertToShares and previewDeposit SHOULD be considered slippage in\n    /// share price or some other type of condition, meaning the depositor will lose assets by depositing.\n    function previewDeposit(uint256 assets) external view returns (uint256 shares);\n\n    /// @notice Mints shares Vault shares to receiver by depositing exactly amount of underlying tokens.\n    /// @dev\n    /// - MUST emit the Deposit event.\n    /// - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n    ///   deposit execution, and are accounted for during deposit.\n    /// - MUST revert if all of assets cannot be deposited (due to deposit limit being reached, slippage, the user not\n    ///   approving enough underlying tokens to the Vault contract, etc).\n    ///\n    /// NOTE: most implementations will require pre-approval of the Vault with the Vaults underlying asset token.\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\n\n    /// @notice Returns the maximum amount of the Vault shares that can be minted for the receiver, through a mint call.\n    /// @dev\n    /// - MUST return a limited value if receiver is subject to some mint limit.\n    /// - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of shares that may be minted.\n    /// - MUST NOT revert.\n    function maxMint(address receiver) external view returns (uint256 maxShares);\n\n    /// @notice Allows an on-chain or off-chain user to simulate the effects of their mint at the current block, given\n    /// current on-chain conditions.\n    /// @dev\n    /// - MUST return as close to and no fewer than the exact amount of assets that would be deposited in a mint call\n    ///   in the same transaction. I.e. mint should return the same or fewer assets as previewMint if called in the\n    ///   same transaction.\n    /// - MUST NOT account for mint limits like those returned from maxMint and should always act as though the mint\n    ///   would be accepted, regardless if the user has enough tokens approved, etc.\n    /// - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n    /// - MUST NOT revert.\n    ///\n    /// NOTE: any unfavorable discrepancy between convertToAssets and previewMint SHOULD be considered slippage in\n    /// share price or some other type of condition, meaning the depositor will lose assets by minting.\n    function previewMint(uint256 shares) external view returns (uint256 assets);\n\n    /// @notice Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.\n    /// @dev\n    /// - MUST emit the Deposit event.\n    /// - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the mint\n    ///   execution, and are accounted for during mint.\n    /// - MUST revert if all of shares cannot be minted (due to deposit limit being reached, slippage, the user not\n    ///   approving enough underlying tokens to the Vault contract, etc).\n    ///\n    /// NOTE: most implementations will require pre-approval of the Vault with the Vaults underlying asset token.\n    function mint(uint256 shares, address receiver) external returns (uint256 assets);\n\n    /// @notice Returns the maximum amount of the underlying asset that can be withdrawn from the owner balance in the\n    /// Vault, through a withdrawal call.\n    /// @dev\n    /// - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n    /// - MUST NOT revert.\n    function maxWithdraw(address owner) external view returns (uint256 maxAssets);\n\n    /// @notice Allows an on-chain or off-chain user to simulate the effects of their withdrawal at the current block,\n    /// given current on-chain conditions.\n    /// @dev\n    /// - MUST return as close to and no fewer than the exact amount of Vault shares that would be burned in a withdraw\n    ///   call in the same transaction. I.e. withdraw should return the same or fewer shares as previewWithdraw if\n    ///   called\n    ///   in the same transaction.\n    /// - MUST NOT account for withdrawal limits like those returned from maxWithdraw and should always act as though\n    ///   the withdrawal would be accepted, regardless if the user has enough shares, etc.\n    /// - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n    /// - MUST NOT revert.\n    ///\n    /// NOTE: any unfavorable discrepancy between convertToShares and previewWithdraw SHOULD be considered slippage in\n    /// share price or some other type of condition, meaning the depositor will lose assets by depositing.\n    function previewWithdraw(uint256 assets) external view returns (uint256 shares);\n\n    /// @notice Burns shares from owner and sends exactly assets of underlying tokens to receiver.\n    /// @dev\n    /// - MUST emit the Withdraw event.\n    /// - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n    ///   withdraw execution, and are accounted for during withdrawal.\n    /// - MUST revert if all of assets cannot be withdrawn (due to withdrawal limit being reached, slippage, the owner\n    ///   not having enough shares, etc).\n    ///\n    /// Note that some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n    /// Those methods should be performed separately.\n    function withdraw(uint256 assets, address receiver, address owner) external returns (uint256 shares);\n\n    /// @notice Returns the maximum amount of Vault shares that can be redeemed from the owner balance in the Vault,\n    /// through a redeem call.\n    /// @dev\n    /// - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n    /// - MUST return balanceOf(owner) if owner is not subject to any withdrawal limit or timelock.\n    /// - MUST NOT revert.\n    function maxRedeem(address owner) external view returns (uint256 maxShares);\n\n    /// @notice Allows an on-chain or off-chain user to simulate the effects of their redeemption at the current block,\n    /// given current on-chain conditions.\n    /// @dev\n    /// - MUST return as close to and no more than the exact amount of assets that would be withdrawn in a redeem call\n    ///   in the same transaction. I.e. redeem should return the same or more assets as previewRedeem if called in the\n    ///   same transaction.\n    /// - MUST NOT account for redemption limits like those returned from maxRedeem and should always act as though the\n    ///   redemption would be accepted, regardless if the user has enough shares, etc.\n    /// - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n    /// - MUST NOT revert.\n    ///\n    /// NOTE: any unfavorable discrepancy between convertToAssets and previewRedeem SHOULD be considered slippage in\n    /// share price or some other type of condition, meaning the depositor will lose assets by redeeming.\n    function previewRedeem(uint256 shares) external view returns (uint256 assets);\n\n    /// @notice Burns exactly shares from owner and sends assets of underlying tokens to receiver.\n    /// @dev\n    /// - MUST emit the Withdraw event.\n    /// - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n    ///   redeem execution, and are accounted for during redeem.\n    /// - MUST revert if all of shares cannot be redeemed (due to withdrawal limit being reached, slippage, the owner\n    ///   not having enough shares, etc).\n    ///\n    /// NOTE: some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n    /// Those methods should be performed separately.\n    function redeem(uint256 shares, address receiver, address owner) external returns (uint256 assets);\n}\n"
    },
    "lib/metamorpho/src/interfaces/IMetaMorpho.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\nimport {IMorpho, Id, MarketParams} from \"../../lib/morpho-blue/src/interfaces/IMorpho.sol\";\nimport {IERC4626} from \"../../lib/openzeppelin-contracts/contracts/interfaces/IERC4626.sol\";\nimport {IERC20Permit} from \"../../lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Permit.sol\";\n\nimport {MarketConfig, PendingUint192, PendingAddress} from \"../libraries/PendingLib.sol\";\n\nstruct MarketAllocation {\n    /// @notice The market to allocate.\n    MarketParams marketParams;\n    /// @notice The amount of assets to allocate.\n    uint256 assets;\n}\n\ninterface IMulticall {\n    function multicall(bytes[] calldata) external returns (bytes[] memory);\n}\n\ninterface IOwnable {\n    function owner() external view returns (address);\n    function transferOwnership(address) external;\n    function renounceOwnership() external;\n    function acceptOwnership() external;\n    function pendingOwner() external view returns (address);\n}\n\n/// @dev This interface is used for factorizing IMetaMorphoStaticTyping and IMetaMorpho.\n/// @dev Consider using the IMetaMorpho interface instead of this one.\ninterface IMetaMorphoBase {\n    /// @notice The address of the Morpho contract.\n    function MORPHO() external view returns (IMorpho);\n    function DECIMALS_OFFSET() external view returns (uint8);\n\n    /// @notice The address of the curator.\n    function curator() external view returns (address);\n\n    /// @notice Stores whether an address is an allocator or not.\n    function isAllocator(address target) external view returns (bool);\n\n    /// @notice The current guardian. Can be set even without the timelock set.\n    function guardian() external view returns (address);\n\n    /// @notice The current fee.\n    function fee() external view returns (uint96);\n\n    /// @notice The fee recipient.\n    function feeRecipient() external view returns (address);\n\n    /// @notice The skim recipient.\n    function skimRecipient() external view returns (address);\n\n    /// @notice The current timelock.\n    function timelock() external view returns (uint256);\n\n    /// @dev Stores the order of markets on which liquidity is supplied upon deposit.\n    /// @dev Can contain any market. A market is skipped as soon as its supply cap is reached.\n    function supplyQueue(uint256) external view returns (Id);\n\n    /// @notice Returns the length of the supply queue.\n    function supplyQueueLength() external view returns (uint256);\n\n    /// @dev Stores the order of markets from which liquidity is withdrawn upon withdrawal.\n    /// @dev Always contain all non-zero cap markets as well as all markets on which the vault supplies liquidity,\n    /// without duplicate.\n    function withdrawQueue(uint256) external view returns (Id);\n\n    /// @notice Returns the length of the withdraw queue.\n    function withdrawQueueLength() external view returns (uint256);\n\n    /// @notice Stores the total assets managed by this vault when the fee was last accrued.\n    /// @dev May be greater than `totalAssets()` due to removal of markets with non-zero supply or socialized bad debt.\n    /// This difference will decrease the fee accrued until one of the functions updating `lastTotalAssets` is\n    /// triggered (deposit/mint/withdraw/redeem/setFee/setFeeRecipient).\n    function lastTotalAssets() external view returns (uint256);\n\n    /// @notice Submits a `newTimelock`.\n    /// @dev Warning: Reverts if a timelock is already pending. Revoke the pending timelock to overwrite it.\n    /// @dev In case the new timelock is higher than the current one, the timelock is set immediately.\n    function submitTimelock(uint256 newTimelock) external;\n\n    /// @notice Accepts the pending timelock.\n    function acceptTimelock() external;\n\n    /// @notice Revokes the pending timelock.\n    /// @dev Does not revert if there is no pending timelock.\n    function revokePendingTimelock() external;\n\n    /// @notice Submits a `newSupplyCap` for the market defined by `marketParams`.\n    /// @dev Warning: Reverts if a cap is already pending. Revoke the pending cap to overwrite it.\n    /// @dev Warning: Reverts if a market removal is pending.\n    /// @dev In case the new cap is lower than the current one, the cap is set immediately.\n    function submitCap(MarketParams memory marketParams, uint256 newSupplyCap) external;\n\n    /// @notice Accepts the pending cap of the market defined by `marketParams`.\n    function acceptCap(MarketParams memory marketParams) external;\n\n    /// @notice Revokes the pending cap of the market defined by `id`.\n    /// @dev Does not revert if there is no pending cap.\n    function revokePendingCap(Id id) external;\n\n    /// @notice Submits a forced market removal from the vault, eventually losing all funds supplied to the market.\n    /// @notice Funds can be recovered by enabling this market again and withdrawing from it (using `reallocate`),\n    /// but funds will be distributed pro-rata to the shares at the time of withdrawal, not at the time of removal.\n    /// @notice This forced removal is expected to be used as an emergency process in case a market constantly reverts.\n    /// To softly remove a sane market, the curator role is expected to bundle a reallocation that empties the market\n    /// first (using `reallocate`), followed by the removal of the market (using `updateWithdrawQueue`).\n    /// @dev Warning: Removing a market with non-zero supply will instantly impact the vault's price per share.\n    /// @dev Warning: Reverts for non-zero cap or if there is a pending cap. Successfully submitting a zero cap will\n    /// prevent such reverts.\n    function submitMarketRemoval(MarketParams memory marketParams) external;\n\n    /// @notice Revokes the pending removal of the market defined by `id`.\n    /// @dev Does not revert if there is no pending market removal.\n    function revokePendingMarketRemoval(Id id) external;\n\n    /// @notice Submits a `newGuardian`.\n    /// @notice Warning: a malicious guardian could disrupt the vault's operation, and would have the power to revoke\n    /// any pending guardian.\n    /// @dev In case there is no guardian, the gardian is set immediately.\n    /// @dev Warning: Submitting a gardian will overwrite the current pending gardian.\n    function submitGuardian(address newGuardian) external;\n\n    /// @notice Accepts the pending guardian.\n    function acceptGuardian() external;\n\n    /// @notice Revokes the pending guardian.\n    function revokePendingGuardian() external;\n\n    /// @notice Skims the vault `token` balance to `skimRecipient`.\n    function skim(address) external;\n\n    /// @notice Sets `newAllocator` as an allocator or not (`newIsAllocator`).\n    function setIsAllocator(address newAllocator, bool newIsAllocator) external;\n\n    /// @notice Sets `curator` to `newCurator`.\n    function setCurator(address newCurator) external;\n\n    /// @notice Sets the `fee` to `newFee`.\n    function setFee(uint256 newFee) external;\n\n    /// @notice Sets `feeRecipient` to `newFeeRecipient`.\n    function setFeeRecipient(address newFeeRecipient) external;\n\n    /// @notice Sets `skimRecipient` to `newSkimRecipient`.\n    function setSkimRecipient(address newSkimRecipient) external;\n\n    /// @notice Sets `supplyQueue` to `newSupplyQueue`.\n    /// @param newSupplyQueue is an array of enabled markets, and can contain duplicate markets, but it would only\n    /// increase the cost of depositing to the vault.\n    function setSupplyQueue(Id[] calldata newSupplyQueue) external;\n\n    /// @notice Updates the withdraw queue. Some markets can be removed, but no market can be added.\n    /// @notice Removing a market requires the vault to have 0 supply on it, or to have previously submitted a removal\n    /// for this market (with the function `submitMarketRemoval`).\n    /// @notice Warning: Anyone can supply on behalf of the vault so the call to `updateWithdrawQueue` that expects a\n    /// market to be empty can be griefed by a front-run. To circumvent this, the allocator can simply bundle a\n    /// reallocation that withdraws max from this market with a call to `updateWithdrawQueue`.\n    /// @dev Warning: Removing a market with supply will decrease the fee accrued until one of the functions updating\n    /// `lastTotalAssets` is triggered (deposit/mint/withdraw/redeem/setFee/setFeeRecipient).\n    /// @dev Warning: `updateWithdrawQueue` is not idempotent. Submitting twice the same tx will change the queue twice.\n    /// @param indexes The indexes of each market in the previous withdraw queue, in the new withdraw queue's order.\n    function updateWithdrawQueue(uint256[] calldata indexes) external;\n\n    /// @notice Reallocates the vault's liquidity so as to reach a given allocation of assets on each given market.\n    /// @notice The allocator can withdraw from any market, even if it's not in the withdraw queue, as long as the loan\n    /// token of the market is the same as the vault's asset.\n    /// @dev The behavior of the reallocation can be altered by state changes, including:\n    /// - Deposits on the vault that supplies to markets that are expected to be supplied to during reallocation.\n    /// - Withdrawals from the vault that withdraws from markets that are expected to be withdrawn from during\n    /// reallocation.\n    /// - Donations to the vault on markets that are expected to be supplied to during reallocation.\n    /// - Withdrawals from markets that are expected to be withdrawn from during reallocation.\n    /// @dev Sender is expected to pass `assets = type(uint256).max` with the last MarketAllocation of `allocations` to\n    /// supply all the remaining withdrawn liquidity, which would ensure that `totalWithdrawn` = `totalSupplied`.\n    function reallocate(MarketAllocation[] calldata allocations) external;\n}\n\n/// @dev This interface is inherited by MetaMorpho so that function signatures are checked by the compiler.\n/// @dev Consider using the IMetaMorpho interface instead of this one.\ninterface IMetaMorphoStaticTyping is IMetaMorphoBase {\n    /// @notice Returns the current configuration of each market.\n    function config(Id) external view returns (uint184 cap, bool enabled, uint64 removableAt);\n\n    /// @notice Returns the pending guardian.\n    function pendingGuardian() external view returns (address guardian, uint64 validAt);\n\n    /// @notice Returns the pending cap for each market.\n    function pendingCap(Id) external view returns (uint192 value, uint64 validAt);\n\n    /// @notice Returns the pending timelock.\n    function pendingTimelock() external view returns (uint192 value, uint64 validAt);\n}\n\n/// @title IMetaMorpho\n/// @author Morpho Labs\n/// @custom:contact security@morpho.org\n/// @dev Use this interface for MetaMorpho to have access to all the functions with the appropriate function signatures.\ninterface IMetaMorpho is IMetaMorphoBase, IERC4626, IERC20Permit, IOwnable, IMulticall {\n    /// @notice Returns the current configuration of each market.\n    function config(Id) external view returns (MarketConfig memory);\n\n    /// @notice Returns the pending guardian.\n    function pendingGuardian() external view returns (PendingAddress memory);\n\n    /// @notice Returns the pending cap for each market.\n    function pendingCap(Id) external view returns (PendingUint192 memory);\n\n    /// @notice Returns the pending timelock.\n    function pendingTimelock() external view returns (PendingUint192 memory);\n}\n"
    },
    "lib/metamorpho/lib/morpho-blue/src/interfaces/IMorpho.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\ntype Id is bytes32;\n\nstruct MarketParams {\n    address loanToken;\n    address collateralToken;\n    address oracle;\n    address irm;\n    uint256 lltv;\n}\n\n/// @dev Warning: For `feeRecipient`, `supplyShares` does not contain the accrued shares since the last interest\n/// accrual.\nstruct Position {\n    uint256 supplyShares;\n    uint128 borrowShares;\n    uint128 collateral;\n}\n\n/// @dev Warning: `totalSupplyAssets` does not contain the accrued interest since the last interest accrual.\n/// @dev Warning: `totalBorrowAssets` does not contain the accrued interest since the last interest accrual.\n/// @dev Warning: `totalSupplyShares` does not contain the additional shares accrued by `feeRecipient` since the last\n/// interest accrual.\nstruct Market {\n    uint128 totalSupplyAssets;\n    uint128 totalSupplyShares;\n    uint128 totalBorrowAssets;\n    uint128 totalBorrowShares;\n    uint128 lastUpdate;\n    uint128 fee;\n}\n\nstruct Authorization {\n    address authorizer;\n    address authorized;\n    bool isAuthorized;\n    uint256 nonce;\n    uint256 deadline;\n}\n\nstruct Signature {\n    uint8 v;\n    bytes32 r;\n    bytes32 s;\n}\n\n/// @dev This interface is used for factorizing IMorphoStaticTyping and IMorpho.\n/// @dev Consider using the IMorpho interface instead of this one.\ninterface IMorphoBase {\n    /// @notice The EIP-712 domain separator.\n    /// @dev Warning: Every EIP-712 signed message based on this domain separator can be reused on another chain sharing\n    /// the same chain id because the domain separator would be the same.\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    /// @notice The owner of the contract.\n    /// @dev It has the power to change the owner.\n    /// @dev It has the power to set fees on markets and set the fee recipient.\n    /// @dev It has the power to enable but not disable IRMs and LLTVs.\n    function owner() external view returns (address);\n\n    /// @notice The fee recipient of all markets.\n    /// @dev The recipient receives the fees of a given market through a supply position on that market.\n    function feeRecipient() external view returns (address);\n\n    /// @notice Whether the `irm` is enabled.\n    function isIrmEnabled(address irm) external view returns (bool);\n\n    /// @notice Whether the `lltv` is enabled.\n    function isLltvEnabled(uint256 lltv) external view returns (bool);\n\n    /// @notice Whether `authorized` is authorized to modify `authorizer`'s position on all markets.\n    /// @dev Anyone is authorized to modify their own positions, regardless of this variable.\n    function isAuthorized(address authorizer, address authorized) external view returns (bool);\n\n    /// @notice The `authorizer`'s current nonce. Used to prevent replay attacks with EIP-712 signatures.\n    function nonce(address authorizer) external view returns (uint256);\n\n    /// @notice Sets `newOwner` as `owner` of the contract.\n    /// @dev Warning: No two-step transfer ownership.\n    /// @dev Warning: The owner can be set to the zero address.\n    function setOwner(address newOwner) external;\n\n    /// @notice Enables `irm` as a possible IRM for market creation.\n    /// @dev Warning: It is not possible to disable an IRM.\n    function enableIrm(address irm) external;\n\n    /// @notice Enables `lltv` as a possible LLTV for market creation.\n    /// @dev Warning: It is not possible to disable a LLTV.\n    function enableLltv(uint256 lltv) external;\n\n    /// @notice Sets the `newFee` for the given market `marketParams`.\n    /// @param newFee The new fee, scaled by WAD.\n    /// @dev Warning: The recipient can be the zero address.\n    function setFee(MarketParams memory marketParams, uint256 newFee) external;\n\n    /// @notice Sets `newFeeRecipient` as `feeRecipient` of the fee.\n    /// @dev Warning: If the fee recipient is set to the zero address, fees will accrue there and will be lost.\n    /// @dev Modifying the fee recipient will allow the new recipient to claim any pending fees not yet accrued. To\n    /// ensure that the current recipient receives all due fees, accrue interest manually prior to making any changes.\n    function setFeeRecipient(address newFeeRecipient) external;\n\n    /// @notice Creates the market `marketParams`.\n    /// @dev Here is the list of assumptions on the market's dependencies (tokens, IRM and oracle) that guarantees\n    /// Morpho behaves as expected:\n    /// - The token should be ERC-20 compliant, except that it can omit return values on `transfer` and `transferFrom`.\n    /// - The token balance of Morpho should only decrease on `transfer` and `transferFrom`. In particular, tokens with\n    /// burn functions are not supported.\n    /// - The token should not re-enter Morpho on `transfer` nor `transferFrom`.\n    /// - The token balance of the sender (resp. receiver) should decrease (resp. increase) by exactly the given amount\n    /// on `transfer` and `transferFrom`. In particular, tokens with fees on transfer are not supported.\n    /// - The IRM should not re-enter Morpho.\n    /// - The oracle should return a price with the correct scaling.\n    /// @dev Here is a list of properties on the market's dependencies that could break Morpho's liveness properties\n    /// (funds could get stuck):\n    /// - The token can revert on `transfer` and `transferFrom` for a reason other than an approval or balance issue.\n    /// - A very high amount of assets (~1e35) supplied or borrowed can make the computation of `toSharesUp` and\n    /// `toSharesDown` overflow.\n    /// - The IRM can revert on `borrowRate`.\n    /// - A very high borrow rate returned by the IRM can make the computation of `interest` in `_accrueInterest`\n    /// overflow.\n    /// - The oracle can revert on `price`. Note that this can be used to prevent `borrow`, `withdrawCollateral` and\n    /// `liquidate` from being used under certain market conditions.\n    /// - A very high price returned by the oracle can make the computation of `maxBorrow` in `_isHealthy` overflow, or\n    /// the computation of `assetsRepaid` in `liquidate` overflow.\n    /// @dev The borrow share price of a market with less than 1e4 assets borrowed can be decreased by manipulations, to\n    /// the point where `totalBorrowShares` is very large and borrowing overflows.\n    function createMarket(MarketParams memory marketParams) external;\n\n    /// @notice Supplies `assets` or `shares` on behalf of `onBehalf`, optionally calling back the caller's\n    /// `onMorphoSupply` function with the given `data`.\n    /// @dev Either `assets` or `shares` should be zero. Most use cases should rely on `assets` as an input so the\n    /// caller is guaranteed to have `assets` tokens pulled from their balance, but the possibility to mint a specific\n    /// amount of shares is given for full compatibility and precision.\n    /// @dev Supplying a large amount can revert for overflow.\n    /// @dev Supplying an amount of shares may lead to supply more or fewer assets than expected due to slippage.\n    /// Consider using the `assets` parameter to avoid this.\n    /// @param marketParams The market to supply assets to.\n    /// @param assets The amount of assets to supply.\n    /// @param shares The amount of shares to mint.\n    /// @param onBehalf The address that will own the increased supply position.\n    /// @param data Arbitrary data to pass to the `onMorphoSupply` callback. Pass empty data if not needed.\n    /// @return assetsSupplied The amount of assets supplied.\n    /// @return sharesSupplied The amount of shares minted.\n    function supply(\n        MarketParams memory marketParams,\n        uint256 assets,\n        uint256 shares,\n        address onBehalf,\n        bytes memory data\n    ) external returns (uint256 assetsSupplied, uint256 sharesSupplied);\n\n    /// @notice Withdraws `assets` or `shares` on behalf of `onBehalf` and sends the assets to `receiver`.\n    /// @dev Either `assets` or `shares` should be zero. To withdraw max, pass the `shares`'s balance of `onBehalf`.\n    /// @dev `msg.sender` must be authorized to manage `onBehalf`'s positions.\n    /// @dev Withdrawing an amount corresponding to more shares than supplied will revert for underflow.\n    /// @dev It is advised to use the `shares` input when withdrawing the full position to avoid reverts due to\n    /// conversion roundings between shares and assets.\n    /// @param marketParams The market to withdraw assets from.\n    /// @param assets The amount of assets to withdraw.\n    /// @param shares The amount of shares to burn.\n    /// @param onBehalf The address of the owner of the supply position.\n    /// @param receiver The address that will receive the withdrawn assets.\n    /// @return assetsWithdrawn The amount of assets withdrawn.\n    /// @return sharesWithdrawn The amount of shares burned.\n    function withdraw(\n        MarketParams memory marketParams,\n        uint256 assets,\n        uint256 shares,\n        address onBehalf,\n        address receiver\n    ) external returns (uint256 assetsWithdrawn, uint256 sharesWithdrawn);\n\n    /// @notice Borrows `assets` or `shares` on behalf of `onBehalf` and sends the assets to `receiver`.\n    /// @dev Either `assets` or `shares` should be zero. Most use cases should rely on `assets` as an input so the\n    /// caller is guaranteed to borrow `assets` of tokens, but the possibility to mint a specific amount of shares is\n    /// given for full compatibility and precision.\n    /// @dev `msg.sender` must be authorized to manage `onBehalf`'s positions.\n    /// @dev Borrowing a large amount can revert for overflow.\n    /// @dev Borrowing an amount of shares may lead to borrow fewer assets than expected due to slippage.\n    /// Consider using the `assets` parameter to avoid this.\n    /// @param marketParams The market to borrow assets from.\n    /// @param assets The amount of assets to borrow.\n    /// @param shares The amount of shares to mint.\n    /// @param onBehalf The address that will own the increased borrow position.\n    /// @param receiver The address that will receive the borrowed assets.\n    /// @return assetsBorrowed The amount of assets borrowed.\n    /// @return sharesBorrowed The amount of shares minted.\n    function borrow(\n        MarketParams memory marketParams,\n        uint256 assets,\n        uint256 shares,\n        address onBehalf,\n        address receiver\n    ) external returns (uint256 assetsBorrowed, uint256 sharesBorrowed);\n\n    /// @notice Repays `assets` or `shares` on behalf of `onBehalf`, optionally calling back the caller's\n    /// `onMorphoReplay` function with the given `data`.\n    /// @dev Either `assets` or `shares` should be zero. To repay max, pass the `shares`'s balance of `onBehalf`.\n    /// @dev Repaying an amount corresponding to more shares than borrowed will revert for underflow.\n    /// @dev It is advised to use the `shares` input when repaying the full position to avoid reverts due to conversion\n    /// roundings between shares and assets.\n    /// @dev An attacker can front-run a repay with a small repay making the transaction revert for underflow.\n    /// @param marketParams The market to repay assets to.\n    /// @param assets The amount of assets to repay.\n    /// @param shares The amount of shares to burn.\n    /// @param onBehalf The address of the owner of the debt position.\n    /// @param data Arbitrary data to pass to the `onMorphoRepay` callback. Pass empty data if not needed.\n    /// @return assetsRepaid The amount of assets repaid.\n    /// @return sharesRepaid The amount of shares burned.\n    function repay(\n        MarketParams memory marketParams,\n        uint256 assets,\n        uint256 shares,\n        address onBehalf,\n        bytes memory data\n    ) external returns (uint256 assetsRepaid, uint256 sharesRepaid);\n\n    /// @notice Supplies `assets` of collateral on behalf of `onBehalf`, optionally calling back the caller's\n    /// `onMorphoSupplyCollateral` function with the given `data`.\n    /// @dev Interest are not accrued since it's not required and it saves gas.\n    /// @dev Supplying a large amount can revert for overflow.\n    /// @param marketParams The market to supply collateral to.\n    /// @param assets The amount of collateral to supply.\n    /// @param onBehalf The address that will own the increased collateral position.\n    /// @param data Arbitrary data to pass to the `onMorphoSupplyCollateral` callback. Pass empty data if not needed.\n    function supplyCollateral(MarketParams memory marketParams, uint256 assets, address onBehalf, bytes memory data)\n        external;\n\n    /// @notice Withdraws `assets` of collateral on behalf of `onBehalf` and sends the assets to `receiver`.\n    /// @dev `msg.sender` must be authorized to manage `onBehalf`'s positions.\n    /// @dev Withdrawing an amount corresponding to more collateral than supplied will revert for underflow.\n    /// @param marketParams The market to withdraw collateral from.\n    /// @param assets The amount of collateral to withdraw.\n    /// @param onBehalf The address of the owner of the collateral position.\n    /// @param receiver The address that will receive the collateral assets.\n    function withdrawCollateral(MarketParams memory marketParams, uint256 assets, address onBehalf, address receiver)\n        external;\n\n    /// @notice Liquidates the given `repaidShares` of debt asset or seize the given `seizedAssets` of collateral on the\n    /// given market `marketParams` of the given `borrower`'s position, optionally calling back the caller's\n    /// `onMorphoLiquidate` function with the given `data`.\n    /// @dev Either `seizedAssets` or `repaidShares` should be zero.\n    /// @dev Seizing more than the collateral balance will underflow and revert without any error message.\n    /// @dev Repaying more than the borrow balance will underflow and revert without any error message.\n    /// @dev An attacker can front-run a liquidation with a small repay making the transaction revert for underflow.\n    /// @param marketParams The market of the position.\n    /// @param borrower The owner of the position.\n    /// @param seizedAssets The amount of collateral to seize.\n    /// @param repaidShares The amount of shares to repay.\n    /// @param data Arbitrary data to pass to the `onMorphoLiquidate` callback. Pass empty data if not needed.\n    /// @return The amount of assets seized.\n    /// @return The amount of assets repaid.\n    function liquidate(\n        MarketParams memory marketParams,\n        address borrower,\n        uint256 seizedAssets,\n        uint256 repaidShares,\n        bytes memory data\n    ) external returns (uint256, uint256);\n\n    /// @notice Executes a flash loan.\n    /// @dev Flash loans have access to the whole balance of the contract (the liquidity and deposited collateral of all\n    /// markets combined, plus donations).\n    /// @dev Warning: Not ERC-3156 compliant but compatibility is easily reached:\n    /// - `flashFee` is zero.\n    /// - `maxFlashLoan` is the token's balance of this contract.\n    /// - The receiver of `assets` is the caller.\n    /// @param token The token to flash loan.\n    /// @param assets The amount of assets to flash loan.\n    /// @param data Arbitrary data to pass to the `onMorphoFlashLoan` callback.\n    function flashLoan(address token, uint256 assets, bytes calldata data) external;\n\n    /// @notice Sets the authorization for `authorized` to manage `msg.sender`'s positions.\n    /// @param authorized The authorized address.\n    /// @param newIsAuthorized The new authorization status.\n    function setAuthorization(address authorized, bool newIsAuthorized) external;\n\n    /// @notice Sets the authorization for `authorization.authorized` to manage `authorization.authorizer`'s positions.\n    /// @dev Warning: Reverts if the signature has already been submitted.\n    /// @dev The signature is malleable, but it has no impact on the security here.\n    /// @dev The nonce is passed as argument to be able to revert with a different error message.\n    /// @param authorization The `Authorization` struct.\n    /// @param signature The signature.\n    function setAuthorizationWithSig(Authorization calldata authorization, Signature calldata signature) external;\n\n    /// @notice Accrues interest for the given market `marketParams`.\n    function accrueInterest(MarketParams memory marketParams) external;\n\n    /// @notice Returns the data stored on the different `slots`.\n    function extSloads(bytes32[] memory slots) external view returns (bytes32[] memory);\n}\n\n/// @dev This interface is inherited by Morpho so that function signatures are checked by the compiler.\n/// @dev Consider using the IMorpho interface instead of this one.\ninterface IMorphoStaticTyping is IMorphoBase {\n    /// @notice The state of the position of `user` on the market corresponding to `id`.\n    /// @dev Warning: For `feeRecipient`, `supplyShares` does not contain the accrued shares since the last interest\n    /// accrual.\n    function position(Id id, address user)\n        external\n        view\n        returns (uint256 supplyShares, uint128 borrowShares, uint128 collateral);\n\n    /// @notice The state of the market corresponding to `id`.\n    /// @dev Warning: `totalSupplyAssets` does not contain the accrued interest since the last interest accrual.\n    /// @dev Warning: `totalBorrowAssets` does not contain the accrued interest since the last interest accrual.\n    /// @dev Warning: `totalSupplyShares` does not contain the accrued shares by `feeRecipient` since the last interest\n    /// accrual.\n    function market(Id id)\n        external\n        view\n        returns (\n            uint128 totalSupplyAssets,\n            uint128 totalSupplyShares,\n            uint128 totalBorrowAssets,\n            uint128 totalBorrowShares,\n            uint128 lastUpdate,\n            uint128 fee\n        );\n\n    /// @notice The market params corresponding to `id`.\n    /// @dev This mapping is not used in Morpho. It is there to enable reducing the cost associated to calldata on layer\n    /// 2s by creating a wrapper contract with functions that take `id` as input instead of `marketParams`.\n    function idToMarketParams(Id id)\n        external\n        view\n        returns (address loanToken, address collateralToken, address oracle, address irm, uint256 lltv);\n}\n\n/// @title IMorpho\n/// @author Morpho Labs\n/// @custom:contact security@morpho.org\n/// @dev Use this interface for Morpho to have access to all the functions with the appropriate function signatures.\ninterface IMorpho is IMorphoBase {\n    /// @notice The state of the position of `user` on the market corresponding to `id`.\n    /// @dev Warning: For `feeRecipient`, `p.supplyShares` does not contain the accrued shares since the last interest\n    /// accrual.\n    function position(Id id, address user) external view returns (Position memory p);\n\n    /// @notice The state of the market corresponding to `id`.\n    /// @dev Warning: `m.totalSupplyAssets` does not contain the accrued interest since the last interest accrual.\n    /// @dev Warning: `m.totalBorrowAssets` does not contain the accrued interest since the last interest accrual.\n    /// @dev Warning: `m.totalSupplyShares` does not contain the accrued shares by `feeRecipient` since the last\n    /// interest accrual.\n    function market(Id id) external view returns (Market memory m);\n\n    /// @notice The market params corresponding to `id`.\n    /// @dev This mapping is not used in Morpho. It is there to enable reducing the cost associated to calldata on layer\n    /// 2s by creating a wrapper contract with functions that take `id` as input instead of `marketParams`.\n    function idToMarketParams(Id id) external view returns (MarketParams memory);\n}\n"
    },
    "lib/metamorpho/lib/morpho-blue/src/libraries/MarketParamsLib.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\nimport {Id, MarketParams} from \"../interfaces/IMorpho.sol\";\n\n/// @title MarketParamsLib\n/// @author Morpho Labs\n/// @custom:contact security@morpho.org\n/// @notice Library to convert a market to its id.\nlibrary MarketParamsLib {\n    /// @notice The length of the data used to compute the id of a market.\n    /// @dev The length is 5 * 32 because `MarketParams` has 5 variables of 32 bytes each.\n    uint256 internal constant MARKET_PARAMS_BYTES_LENGTH = 5 * 32;\n\n    /// @notice Returns the id of the market `marketParams`.\n    function id(MarketParams memory marketParams) internal pure returns (Id marketParamsId) {\n        assembly (\"memory-safe\") {\n            marketParamsId := keccak256(marketParams, MARKET_PARAMS_BYTES_LENGTH)\n        }\n    }\n}\n"
    },
    "lib/spark-alm-controller/deploy/ControllerInstance.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity >=0.8.0;\n\nstruct ControllerInstance {\n    address almProxy;\n    address controller;\n    address rateLimits;\n}\n"
    },
    "lib/spark-alm-controller/deploy/MainnetControllerInit.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity >=0.8.0;\n\nimport { MainnetController } from \"../src/MainnetController.sol\";\n\nimport { IALMProxy }   from \"../src/interfaces/IALMProxy.sol\";\nimport { IRateLimits } from \"../src/interfaces/IRateLimits.sol\";\n\nimport { ControllerInstance } from \"./ControllerInstance.sol\";\n\ninterface IBufferLike {\n    function approve(address, address, uint256) external;\n}\n\ninterface IPSMLike {\n    function kiss(address) external;\n}\n\ninterface IVaultLike {\n    function buffer() external view returns (address);\n    function rely(address) external;\n}\n\nlibrary MainnetControllerInit {\n\n    /**********************************************************************************************/\n    /*** Structs and constants                                                                  ***/\n    /**********************************************************************************************/\n\n    struct CheckAddressParams {\n        address admin;\n        address proxy;\n        address rateLimits;\n        address vault;\n        address psm;\n        address daiUsds;\n        address cctp;\n    }\n\n    struct ConfigAddressParams {\n        address freezer;\n        address relayer;\n        address oldController;\n    }\n\n    struct MintRecipient {\n        uint32  domain;\n        bytes32 mintRecipient;\n    }\n\n    bytes32 constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**********************************************************************************************/\n    /*** Internal library functions                                                             ***/\n    /**********************************************************************************************/\n\n    function initAlmSystem(\n        address vault,\n        address usds,\n        ControllerInstance  memory controllerInst,\n        ConfigAddressParams memory configAddresses,\n        CheckAddressParams  memory checkAddresses,\n        MintRecipient[]     memory mintRecipients\n    )\n        internal\n    {\n        // Step 1: Do sanity checks outside of the controller\n\n        require(IALMProxy(controllerInst.almProxy).hasRole(DEFAULT_ADMIN_ROLE, checkAddresses.admin),     \"MainnetControllerInit/incorrect-admin-almProxy\");\n        require(IRateLimits(controllerInst.rateLimits).hasRole(DEFAULT_ADMIN_ROLE, checkAddresses.admin), \"MainnetControllerInit/incorrect-admin-rateLimits\");\n\n        // Step 2: Initialize the controller\n\n        _initController(controllerInst, configAddresses, checkAddresses, mintRecipients);\n\n        // Step 3: Configure almProxy within the allocation system\n\n        require(vault == checkAddresses.vault, \"MainnetControllerInit/incorrect-vault\");\n\n        IVaultLike(vault).rely(controllerInst.almProxy);\n        IBufferLike(IVaultLike(vault).buffer()).approve(usds, controllerInst.almProxy, type(uint256).max);\n    }\n\n    function upgradeController(\n        ControllerInstance  memory controllerInst,\n        ConfigAddressParams memory configAddresses,\n        CheckAddressParams  memory checkAddresses,\n        MintRecipient[]     memory mintRecipients\n    )\n        internal\n    {\n        _initController(controllerInst, configAddresses, checkAddresses, mintRecipients);\n\n        IALMProxy   almProxy   = IALMProxy(controllerInst.almProxy);\n        IRateLimits rateLimits = IRateLimits(controllerInst.rateLimits);\n\n        require(configAddresses.oldController != address(0), \"MainnetControllerInit/old-controller-zero-address\");\n\n        require(almProxy.hasRole(almProxy.CONTROLLER(), configAddresses.oldController),     \"MainnetControllerInit/old-controller-not-almProxy-controller\");\n        require(rateLimits.hasRole(rateLimits.CONTROLLER(), configAddresses.oldController), \"MainnetControllerInit/old-controller-not-rateLimits-controller\");\n\n        almProxy.revokeRole(almProxy.CONTROLLER(), configAddresses.oldController);\n        rateLimits.revokeRole(rateLimits.CONTROLLER(), configAddresses.oldController);\n    }\n\n    function pauseProxyInitAlmSystem(address psm, address almProxy) internal {\n        IPSMLike(psm).kiss(almProxy);  // To allow using no fee functionality\n    }\n\n    /**********************************************************************************************/\n    /*** Private helper functions                                                               ***/\n    /**********************************************************************************************/\n\n    function _initController(\n        ControllerInstance  memory controllerInst,\n        ConfigAddressParams memory configAddresses,\n        CheckAddressParams  memory checkAddresses,\n        MintRecipient[]     memory mintRecipients\n    )\n        private\n    {\n        // Step 1: Perform controller sanity checks\n\n        MainnetController newController = MainnetController(controllerInst.controller);\n\n        require(newController.hasRole(DEFAULT_ADMIN_ROLE, checkAddresses.admin), \"MainnetControllerInit/incorrect-admin-controller\");\n\n        require(address(newController.proxy())      == controllerInst.almProxy,   \"MainnetControllerInit/incorrect-almProxy\");\n        require(address(newController.rateLimits()) == controllerInst.rateLimits, \"MainnetControllerInit/incorrect-rateLimits\");\n\n        require(address(newController.vault())   == checkAddresses.vault,   \"MainnetControllerInit/incorrect-vault\");\n        require(address(newController.psm())     == checkAddresses.psm,     \"MainnetControllerInit/incorrect-psm\");\n        require(address(newController.daiUsds()) == checkAddresses.daiUsds, \"MainnetControllerInit/incorrect-daiUsds\");\n        require(address(newController.cctp())    == checkAddresses.cctp,    \"MainnetControllerInit/incorrect-cctp\");\n\n        require(newController.psmTo18ConversionFactor() == 1e12, \"MainnetControllerInit/incorrect-psmTo18ConversionFactor\");\n\n        require(configAddresses.oldController != address(newController), \"MainnetControllerInit/old-controller-is-new-controller\");\n\n        // Step 2: Configure ACL permissions controller, almProxy, and rateLimits\n\n        IALMProxy   almProxy   = IALMProxy(controllerInst.almProxy);\n        IRateLimits rateLimits = IRateLimits(controllerInst.rateLimits);\n\n        newController.grantRole(newController.FREEZER(), configAddresses.freezer);\n        newController.grantRole(newController.RELAYER(), configAddresses.relayer);\n\n        almProxy.grantRole(almProxy.CONTROLLER(), address(newController));\n        rateLimits.grantRole(rateLimits.CONTROLLER(), address(newController));\n\n        // Step 3: Configure the mint recipients on other domains\n\n        for (uint256 i = 0; i < mintRecipients.length; i++) {\n            newController.setMintRecipient(mintRecipients[i].domain, mintRecipients[i].mintRecipient);\n        }\n    }\n\n}\n"
    },
    "lib/spark-alm-controller/deploy/ForeignControllerInit.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity >=0.8.0;\n\nimport { ForeignController } from \"../src/ForeignController.sol\";\n\nimport { IALMProxy }   from \"../src/interfaces/IALMProxy.sol\";\nimport { IRateLimits } from \"../src/interfaces/IRateLimits.sol\";\n\nimport { ControllerInstance } from \"./ControllerInstance.sol\";\n\ninterface IPSM3Like {\n    function susds() external view returns (address);\n    function totalAssets() external view returns (uint256);\n    function totalShares() external view returns (uint256);\n    function usdc() external view returns (address);\n    function usds() external view returns (address);\n}\n\nlibrary ForeignControllerInit {\n\n    /**********************************************************************************************/\n    /*** Structs and constants                                                                  ***/\n    /**********************************************************************************************/\n\n    struct CheckAddressParams {\n        address admin;\n        address psm;\n        address cctp;\n        address usdc;\n        address susds;\n        address usds;\n    }\n\n    struct ConfigAddressParams {\n        address freezer;\n        address relayer;\n        address oldController;\n    }\n\n    struct MintRecipient {\n        uint32  domain;\n        bytes32 mintRecipient;\n    }\n\n    bytes32 constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**********************************************************************************************/\n    /*** Internal library functions                                                             ***/\n    /**********************************************************************************************/\n\n    function initAlmSystem(\n        ControllerInstance  memory controllerInst,\n        ConfigAddressParams memory configAddresses,\n        CheckAddressParams  memory checkAddresses,\n        MintRecipient[]     memory mintRecipients\n    )\n        internal\n    {\n        // Step 1: Do sanity checks outside of the controller\n\n        require(IALMProxy(controllerInst.almProxy).hasRole(DEFAULT_ADMIN_ROLE, checkAddresses.admin),     \"ForeignControllerInit/incorrect-admin-almProxy\");\n        require(IRateLimits(controllerInst.rateLimits).hasRole(DEFAULT_ADMIN_ROLE, checkAddresses.admin), \"ForeignControllerInit/incorrect-admin-rateLimits\");\n\n        // Step 2: Initialize the controller\n\n        _initController(controllerInst, configAddresses, checkAddresses, mintRecipients);\n    }\n\n    function upgradeController(\n        ControllerInstance  memory controllerInst,\n        ConfigAddressParams memory configAddresses,\n        CheckAddressParams  memory checkAddresses,\n        MintRecipient[]     memory mintRecipients\n    )\n        internal\n    {\n        _initController(controllerInst, configAddresses, checkAddresses, mintRecipients);\n\n        IALMProxy   almProxy   = IALMProxy(controllerInst.almProxy);\n        IRateLimits rateLimits = IRateLimits(controllerInst.rateLimits);\n\n        require(configAddresses.oldController != address(0), \"ForeignControllerInit/old-controller-zero-address\");\n\n        require(almProxy.hasRole(almProxy.CONTROLLER(), configAddresses.oldController),     \"ForeignControllerInit/old-controller-not-almProxy-controller\");\n        require(rateLimits.hasRole(rateLimits.CONTROLLER(), configAddresses.oldController), \"ForeignControllerInit/old-controller-not-rateLimits-controller\");\n\n        almProxy.revokeRole(almProxy.CONTROLLER(), configAddresses.oldController);\n        rateLimits.revokeRole(rateLimits.CONTROLLER(), configAddresses.oldController);\n    }\n\n    /**********************************************************************************************/\n    /*** Private helper functions                                                               ***/\n    /**********************************************************************************************/\n\n    function _initController(\n        ControllerInstance  memory controllerInst,\n        ConfigAddressParams memory configAddresses,\n        CheckAddressParams  memory checkAddresses,\n        MintRecipient[]     memory mintRecipients\n    )\n        private\n    {\n        // Step 1: Perform controller sanity checks\n\n        ForeignController newController = ForeignController(controllerInst.controller);\n\n        require(newController.hasRole(DEFAULT_ADMIN_ROLE, checkAddresses.admin), \"ForeignControllerInit/incorrect-admin-controller\");\n\n        require(address(newController.proxy())      == controllerInst.almProxy,   \"ForeignControllerInit/incorrect-almProxy\");\n        require(address(newController.rateLimits()) == controllerInst.rateLimits, \"ForeignControllerInit/incorrect-rateLimits\");\n\n        require(address(newController.psm())  == checkAddresses.psm,  \"ForeignControllerInit/incorrect-psm\");\n        require(address(newController.usdc()) == checkAddresses.usdc, \"ForeignControllerInit/incorrect-usdc\");\n        require(address(newController.cctp()) == checkAddresses.cctp, \"ForeignControllerInit/incorrect-cctp\");\n\n        require(configAddresses.oldController != address(newController), \"ForeignControllerInit/old-controller-is-new-controller\");\n\n        // Step 2: Perform PSM sanity checks\n\n        IPSM3Like psm = IPSM3Like(checkAddresses.psm);\n\n        require(psm.totalAssets() >= 1e18, \"ForeignControllerInit/psm-totalAssets-not-seeded\");\n        require(psm.totalShares() >= 1e18, \"ForeignControllerInit/psm-totalShares-not-seeded\");\n\n        require(psm.usdc()  == checkAddresses.usdc,  \"ForeignControllerInit/psm-incorrect-usdc\");\n        require(psm.usds()  == checkAddresses.usds,  \"ForeignControllerInit/psm-incorrect-usds\");\n        require(psm.susds() == checkAddresses.susds, \"ForeignControllerInit/psm-incorrect-susds\");\n\n        // Step 3: Configure ACL permissions controller, almProxy, and rateLimits\n\n        IALMProxy   almProxy   = IALMProxy(controllerInst.almProxy);\n        IRateLimits rateLimits = IRateLimits(controllerInst.rateLimits);\n\n        newController.grantRole(newController.FREEZER(), configAddresses.freezer);\n        newController.grantRole(newController.RELAYER(), configAddresses.relayer);\n\n        almProxy.grantRole(almProxy.CONTROLLER(), address(newController));\n        rateLimits.grantRole(rateLimits.CONTROLLER(), address(newController));\n\n        // Step 4: Configure the mint recipients on other domains\n\n        for (uint256 i = 0; i < mintRecipients.length; i++) {\n            newController.setMintRecipient(mintRecipients[i].domain, mintRecipients[i].mintRecipient);\n        }\n    }\n\n}\n"
    },
    "lib/spark-alm-controller/src/MainnetController.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.21;\n\nimport { IAToken }            from \"aave-v3-origin/src/core/contracts/interfaces/IAToken.sol\";\nimport { IPool as IAavePool } from \"aave-v3-origin/src/core/contracts/interfaces/IPool.sol\";\n\nimport { IERC20 }   from \"forge-std/interfaces/IERC20.sol\";\nimport { IERC4626 } from \"forge-std/interfaces/IERC4626.sol\";\nimport { IERC7540 } from \"forge-std/interfaces/IERC7540.sol\";\n\nimport { IMetaMorpho, Id, MarketAllocation } from \"metamorpho/interfaces/IMetaMorpho.sol\";\n\nimport { AccessControl } from \"openzeppelin-contracts/contracts/access/AccessControl.sol\";\n\nimport { Ethereum } from \"spark-address-registry/Ethereum.sol\";\n\nimport { IALMProxy }   from \"./interfaces/IALMProxy.sol\";\nimport { ICCTPLike }   from \"./interfaces/CCTPInterfaces.sol\";\nimport { IRateLimits } from \"./interfaces/IRateLimits.sol\";\n\nimport { RateLimitHelpers } from \"./RateLimitHelpers.sol\";\n\ninterface IATokenWithPool is IAToken {\n    function POOL() external view returns(address);\n}\n\ninterface IBuidlRedeemLike {\n    function asset() external view returns(address);\n    function redeem(uint256 usdcAmount) external;\n}\n\ninterface ICurvePoolLike is IERC20 {\n    function add_liquidity(\n        uint256[] memory amounts,\n        uint256 minMintAmount,\n        address receiver\n    ) external;\n    function balances(uint256 index) external view returns (uint256);\n    function coins(uint256 index) external returns (address);\n    function exchange(\n        int128  inputIndex,\n        int128  outputIndex,\n        uint256 amountIn,\n        uint256 minAmountOut,\n        address receiver\n    ) external returns (uint256 tokensOut);\n    function get_virtual_price() external view returns (uint256);\n    function N_COINS() external view returns (uint256);\n    function remove_liquidity(\n        uint256 burnAmount,\n        uint256[] memory minAmounts,\n        address receiver\n    ) external;\n    function stored_rates() external view returns (uint256[] memory);\n}\n\ninterface IDaiUsdsLike {\n    function dai() external view returns (address);\n    function daiToUsds(address usr, uint256 wad) external;\n    function usdsToDai(address usr, uint256 wad) external;\n}\n\ninterface IEthenaMinterLike {\n    function setDelegatedSigner(address delegateSigner) external;\n    function removeDelegatedSigner(address delegateSigner) external;\n}\n\ninterface ICentrifugeToken is IERC7540 {\n    function cancelDepositRequest(uint256 requestId, address controller) external;\n    function cancelRedeemRequest(uint256 requestId, address controller) external;\n    function claimCancelDepositRequest(uint256 requestId, address receiver, address controller)\n        external returns (uint256 assets);\n    function claimCancelRedeemRequest(uint256 requestId, address receiver, address controller)\n        external returns (uint256 shares);\n}\n\ninterface IMapleTokenLike is IERC4626 {\n    function requestRedeem(uint256 shares, address receiver) external;\n    function removeShares(uint256 shares, address receiver) external;\n}\n\ninterface IPSMLike {\n    function buyGemNoFee(address usr, uint256 usdcAmount) external returns (uint256 usdsAmount);\n    function fill() external returns (uint256 wad);\n    function gem() external view returns (address);\n    function sellGemNoFee(address usr, uint256 usdcAmount) external returns (uint256 usdsAmount);\n    function to18ConversionFactor() external view returns (uint256);\n}\n\ninterface ISSRedemptionLike is IERC20 {\n    function calculateUsdcOut(uint256 ustbAmount)\n        external view returns (uint256 usdcOutAmount, uint256 usdPerUstbChainlinkRaw);\n    function redeem(uint256 ustbAmout) external;\n}\n\ninterface ISUSDELike is IERC4626 {\n    function cooldownAssets(uint256 usdeAmount) external;\n    function cooldownShares(uint256 susdeAmount) external;\n    function unstake(address receiver) external;\n}\n\ninterface IUSTBLike is IERC20 {\n    function subscribe(uint256 inAmount, address stablecoin) external;\n}\n\ninterface IVaultLike {\n    function buffer() external view returns (address);\n    function draw(uint256 usdsAmount) external;\n    function wipe(uint256 usdsAmount) external;\n}\n\ncontract MainnetController is AccessControl {\n\n    /**********************************************************************************************/\n    /*** Events                                                                                 ***/\n    /**********************************************************************************************/\n\n    // NOTE: This is used to track individual transfers for offchain processing of CCTP transactions\n    event CCTPTransferInitiated(\n        uint64  indexed nonce,\n        uint32  indexed destinationDomain,\n        bytes32 indexed mintRecipient,\n        uint256 usdcAmount\n    );\n\n    event MaxSlippageSet(address indexed pool, uint256 maxSlippage);\n    event MintRecipientSet(uint32 indexed destinationDomain, bytes32 mintRecipient);\n    event RelayerRemoved(address indexed relayer);\n\n    /**********************************************************************************************/\n    /*** State variables                                                                        ***/\n    /**********************************************************************************************/\n\n    bytes32 public constant FREEZER = keccak256(\"FREEZER\");\n    bytes32 public constant RELAYER = keccak256(\"RELAYER\");\n\n    bytes32 public constant LIMIT_4626_DEPOSIT         = keccak256(\"LIMIT_4626_DEPOSIT\");\n    bytes32 public constant LIMIT_4626_WITHDRAW        = keccak256(\"LIMIT_4626_WITHDRAW\");\n    bytes32 public constant LIMIT_7540_DEPOSIT         = keccak256(\"LIMIT_7540_DEPOSIT\");\n    bytes32 public constant LIMIT_7540_REDEEM          = keccak256(\"LIMIT_7540_REDEEM\");\n    bytes32 public constant LIMIT_AAVE_DEPOSIT         = keccak256(\"LIMIT_AAVE_DEPOSIT\");\n    bytes32 public constant LIMIT_AAVE_WITHDRAW        = keccak256(\"LIMIT_AAVE_WITHDRAW\");\n    bytes32 public constant LIMIT_ASSET_TRANSFER       = keccak256(\"LIMIT_ASSET_TRANSFER\");\n    bytes32 public constant LIMIT_BUIDL_REDEEM_CIRCLE  = keccak256(\"LIMIT_BUIDL_REDEEM_CIRCLE\");\n    bytes32 public constant LIMIT_CURVE_DEPOSIT        = keccak256(\"LIMIT_CURVE_DEPOSIT\");\n    bytes32 public constant LIMIT_CURVE_SWAP           = keccak256(\"LIMIT_CURVE_SWAP\");\n    bytes32 public constant LIMIT_CURVE_WITHDRAW       = keccak256(\"LIMIT_CURVE_WITHDRAW\");\n    bytes32 public constant LIMIT_MAPLE_REDEEM         = keccak256(\"LIMIT_MAPLE_REDEEM\");\n    bytes32 public constant LIMIT_SUPERSTATE_REDEEM    = keccak256(\"LIMIT_SUPERSTATE_REDEEM\");\n    bytes32 public constant LIMIT_SUPERSTATE_SUBSCRIBE = keccak256(\"LIMIT_SUPERSTATE_SUBSCRIBE\");\n    bytes32 public constant LIMIT_SUSDE_COOLDOWN       = keccak256(\"LIMIT_SUSDE_COOLDOWN\");\n    bytes32 public constant LIMIT_USDC_TO_CCTP         = keccak256(\"LIMIT_USDC_TO_CCTP\");\n    bytes32 public constant LIMIT_USDC_TO_DOMAIN       = keccak256(\"LIMIT_USDC_TO_DOMAIN\");\n    bytes32 public constant LIMIT_USDE_BURN            = keccak256(\"LIMIT_USDE_BURN\");\n    bytes32 public constant LIMIT_USDE_MINT            = keccak256(\"LIMIT_USDE_MINT\");\n    bytes32 public constant LIMIT_USDS_MINT            = keccak256(\"LIMIT_USDS_MINT\");\n    bytes32 public constant LIMIT_USDS_TO_USDC         = keccak256(\"LIMIT_USDS_TO_USDC\");\n\n    address public immutable buffer;\n\n    IALMProxy         public immutable proxy;\n    IBuidlRedeemLike  public immutable buidlRedeem;\n    ICCTPLike         public immutable cctp;\n    IDaiUsdsLike      public immutable daiUsds;\n    IEthenaMinterLike public immutable ethenaMinter;\n    IPSMLike          public immutable psm;\n    IRateLimits       public immutable rateLimits;\n    ISSRedemptionLike public immutable superstateRedemption;\n    IVaultLike        public immutable vault;\n\n    IERC20     public immutable dai;\n    IERC20     public immutable usds;\n    IERC20     public immutable usde;\n    IERC20     public immutable usdc;\n    IUSTBLike  public immutable ustb;\n    ISUSDELike public immutable susde;\n\n    uint256 public immutable psmTo18ConversionFactor;\n\n    mapping(address pool => uint256 maxSlippage) public maxSlippages;  // 1e18 precision\n\n    mapping(uint32 destinationDomain => bytes32 mintRecipient) public mintRecipients;\n\n    /**********************************************************************************************/\n    /*** Initialization                                                                         ***/\n    /**********************************************************************************************/\n\n    constructor(\n        address admin_,\n        address proxy_,\n        address rateLimits_,\n        address vault_,\n        address psm_,\n        address daiUsds_,\n        address cctp_\n    ) {\n        _grantRole(DEFAULT_ADMIN_ROLE, admin_);\n\n        proxy      = IALMProxy(proxy_);\n        rateLimits = IRateLimits(rateLimits_);\n        vault      = IVaultLike(vault_);\n        buffer     = IVaultLike(vault_).buffer();\n        psm        = IPSMLike(psm_);\n        daiUsds    = IDaiUsdsLike(daiUsds_);\n        cctp       = ICCTPLike(cctp_);\n\n        buidlRedeem          = IBuidlRedeemLike(Ethereum.BUIDL_REDEEM);\n        ethenaMinter         = IEthenaMinterLike(Ethereum.ETHENA_MINTER);\n        superstateRedemption = ISSRedemptionLike(Ethereum.SUPERSTATE_REDEMPTION);\n\n        susde = ISUSDELike(Ethereum.SUSDE);\n        ustb  = IUSTBLike(Ethereum.USTB);\n        dai   = IERC20(daiUsds.dai());\n        usdc  = IERC20(psm.gem());\n        usds  = IERC20(Ethereum.USDS);\n        usde  = IERC20(Ethereum.USDE);\n\n        psmTo18ConversionFactor = psm.to18ConversionFactor();\n    }\n\n    /**********************************************************************************************/\n    /*** Admin functions                                                                        ***/\n    /**********************************************************************************************/\n\n    function setMintRecipient(uint32 destinationDomain, bytes32 mintRecipient) external {\n        _checkRole(DEFAULT_ADMIN_ROLE);\n        mintRecipients[destinationDomain] = mintRecipient;\n        emit MintRecipientSet(destinationDomain, mintRecipient);\n    }\n\n    function setMaxSlippage(address pool, uint256 maxSlippage) external {\n        _checkRole(DEFAULT_ADMIN_ROLE);\n        maxSlippages[pool] = maxSlippage;\n        emit MaxSlippageSet(pool, maxSlippage);\n    }\n\n    /**********************************************************************************************/\n    /*** Freezer functions                                                                      ***/\n    /**********************************************************************************************/\n\n    function removeRelayer(address relayer) external {\n        _checkRole(FREEZER);\n        _revokeRole(RELAYER, relayer);\n        emit RelayerRemoved(relayer);\n    }\n\n    /**********************************************************************************************/\n    /*** Relayer vault functions                                                                ***/\n    /**********************************************************************************************/\n\n    function mintUSDS(uint256 usdsAmount) external {\n        _checkRole(RELAYER);\n        _rateLimited(LIMIT_USDS_MINT, usdsAmount);\n\n        // Mint USDS into the buffer\n        proxy.doCall(\n            address(vault),\n            abi.encodeCall(vault.draw, (usdsAmount))\n        );\n\n        // Transfer USDS from the buffer to the proxy\n        proxy.doCall(\n            address(usds),\n            abi.encodeCall(usds.transferFrom, (buffer, address(proxy), usdsAmount))\n        );\n    }\n\n    function burnUSDS(uint256 usdsAmount) external {\n        _checkRole(RELAYER);\n        _cancelRateLimit(LIMIT_USDS_MINT, usdsAmount);\n\n        // Transfer USDS from the proxy to the buffer\n        proxy.doCall(\n            address(usds),\n            abi.encodeCall(usds.transfer, (buffer, usdsAmount))\n        );\n\n        // Burn USDS from the buffer\n        proxy.doCall(\n            address(vault),\n            abi.encodeCall(vault.wipe, (usdsAmount))\n        );\n    }\n\n    /**********************************************************************************************/\n    /*** Relayer ERC20 functions                                                                ***/\n    /**********************************************************************************************/\n\n    function transferAsset(address asset, address destination, uint256 amount) external {\n        _checkRole(RELAYER);\n        _rateLimited(\n            RateLimitHelpers.makeAssetDestinationKey(LIMIT_ASSET_TRANSFER, asset, destination),\n            amount\n        );\n\n        proxy.doCall(\n            asset,\n            abi.encodeCall(IERC20(asset).transfer, (destination, amount))\n        );\n    }\n\n    /**********************************************************************************************/\n    /*** Relayer ERC4626 functions                                                              ***/\n    /**********************************************************************************************/\n\n    function depositERC4626(address token, uint256 amount) external returns (uint256 shares) {\n        _checkRole(RELAYER);\n        _rateLimitedAsset(LIMIT_4626_DEPOSIT, token, amount);\n\n        // Note that whitelist is done by rate limits\n        IERC20 asset = IERC20(IERC4626(token).asset());\n\n        // Approve asset to token from the proxy (assumes the proxy has enough of the asset).\n        _approve(address(asset), token, amount);\n\n        // Deposit asset into the token, proxy receives token shares, decode the resulting shares\n        shares = abi.decode(\n            proxy.doCall(\n                token,\n                abi.encodeCall(IERC4626(token).deposit, (amount, address(proxy)))\n            ),\n            (uint256)\n        );\n    }\n\n    function withdrawERC4626(address token, uint256 amount) external returns (uint256 shares) {\n        _checkRole(RELAYER);\n        _rateLimitedAsset(LIMIT_4626_WITHDRAW, token, amount);\n\n        // Withdraw asset from a token, decode resulting shares.\n        // Assumes proxy has adequate token shares.\n        shares = abi.decode(\n            proxy.doCall(\n                token,\n                abi.encodeCall(IERC4626(token).withdraw, (amount, address(proxy), address(proxy)))\n            ),\n            (uint256)\n        );\n    }\n\n    // NOTE: !!! Rate limited at end of function !!!\n    function redeemERC4626(address token, uint256 shares) external returns (uint256 assets) {\n        _checkRole(RELAYER);\n\n        // Redeem shares for assets from the token, decode the resulting assets.\n        // Assumes proxy has adequate token shares.\n        assets = abi.decode(\n            proxy.doCall(\n                token,\n                abi.encodeCall(IERC4626(token).redeem, (shares, address(proxy), address(proxy)))\n            ),\n            (uint256)\n        );\n\n        rateLimits.triggerRateLimitDecrease(\n            RateLimitHelpers.makeAssetKey(LIMIT_4626_WITHDRAW, token),\n            assets\n        );\n    }\n\n    /**********************************************************************************************/\n    /*** Relayer ERC7540 functions                                                              ***/\n    /**********************************************************************************************/\n\n    function requestDepositERC7540(address token, uint256 amount) external {\n        _checkRole(RELAYER);\n        _rateLimitedAsset(LIMIT_7540_DEPOSIT, token, amount);\n\n        // Note that whitelist is done by rate limits\n        IERC20 asset = IERC20(IERC7540(token).asset());\n\n        // Approve asset to vault from the proxy (assumes the proxy has enough of the asset).\n        _approve(address(asset), token, amount);\n\n        // Submit deposit request by transferring assets\n        proxy.doCall(\n            token,\n            abi.encodeCall(IERC7540(token).requestDeposit, (amount, address(proxy), address(proxy)))\n        );\n    }\n\n    function claimDepositERC7540(address token) external {\n        _checkRole(RELAYER);\n        _rateLimitExists(RateLimitHelpers.makeAssetKey(LIMIT_7540_DEPOSIT, token));\n\n        uint256 shares = IERC7540(token).maxMint(address(proxy));\n\n        // Claim shares from the vault to the proxy\n        proxy.doCall(\n            token,\n            abi.encodeCall(IERC4626(token).mint, (shares, address(proxy)))\n        );\n    }\n\n    function requestRedeemERC7540(address token, uint256 shares) external {\n        _checkRole(RELAYER);\n        _rateLimitedAsset(\n            LIMIT_7540_REDEEM,\n            token,\n            IERC7540(token).convertToAssets(shares)\n        );\n\n        // Submit redeem request by transferring shares\n        proxy.doCall(\n            token,\n            abi.encodeCall(IERC7540(token).requestRedeem, (shares, address(proxy), address(proxy)))\n        );\n    }\n\n    function claimRedeemERC7540(address token) external {\n        _checkRole(RELAYER);\n        _rateLimitExists(RateLimitHelpers.makeAssetKey(LIMIT_7540_REDEEM, token));\n\n        uint256 assets = IERC7540(token).maxWithdraw(address(proxy));\n\n        // Claim assets from the vault to the proxy\n        proxy.doCall(\n            token,\n            abi.encodeCall(IERC7540(token).withdraw, (assets, address(proxy), address(proxy)))\n        );\n    }\n\n    /**********************************************************************************************/\n    /*** Relayer Centrifuge functions                                                           ***/\n    /**********************************************************************************************/\n\n    // NOTE: These cancelation methods are compatible with ERC-7887\n\n    uint256 CENTRIFUGE_REQUEST_ID = 0;\n\n    function cancelCentrifugeDepositRequest(address token) external {\n        _checkRole(RELAYER);\n        _rateLimitExists(RateLimitHelpers.makeAssetKey(LIMIT_7540_DEPOSIT, token));\n\n        // NOTE: While the cancelation is pending, no new deposit request can be submitted\n        proxy.doCall(\n            token,\n            abi.encodeCall(\n                ICentrifugeToken(token).cancelDepositRequest,\n                (CENTRIFUGE_REQUEST_ID, address(proxy))\n            )\n        );\n    }\n\n    function claimCentrifugeCancelDepositRequest(address token) external {\n        _checkRole(RELAYER);\n        _rateLimitExists(RateLimitHelpers.makeAssetKey(LIMIT_7540_DEPOSIT, token));\n\n        proxy.doCall(\n            token,\n            abi.encodeCall(\n                ICentrifugeToken(token).claimCancelDepositRequest,\n                (CENTRIFUGE_REQUEST_ID, address(proxy), address(proxy))\n            )\n        );\n    }\n\n    function cancelCentrifugeRedeemRequest(address token) external {\n        _checkRole(RELAYER);\n        _rateLimitExists(RateLimitHelpers.makeAssetKey(LIMIT_7540_REDEEM, token));\n\n        // NOTE: While the cancelation is pending, no new redeem request can be submitted\n        proxy.doCall(\n            token,\n            abi.encodeCall(\n                ICentrifugeToken(token).cancelRedeemRequest,\n                (CENTRIFUGE_REQUEST_ID, address(proxy))\n            )\n        );\n    }\n\n    function claimCentrifugeCancelRedeemRequest(address token) external {\n        _checkRole(RELAYER);\n        _rateLimitExists(RateLimitHelpers.makeAssetKey(LIMIT_7540_REDEEM, token));\n\n        proxy.doCall(\n            token,\n            abi.encodeCall(\n                ICentrifugeToken(token).claimCancelRedeemRequest,\n                (CENTRIFUGE_REQUEST_ID, address(proxy), address(proxy))\n            )\n        );\n    }\n\n    /**********************************************************************************************/\n    /*** Relayer Aave functions                                                                 ***/\n    /**********************************************************************************************/\n\n    function depositAave(address aToken, uint256 amount) external {\n        _checkRole(RELAYER);\n        _rateLimitedAsset(LIMIT_AAVE_DEPOSIT, aToken, amount);\n\n        IERC20    underlying = IERC20(IATokenWithPool(aToken).UNDERLYING_ASSET_ADDRESS());\n        IAavePool pool       = IAavePool(IATokenWithPool(aToken).POOL());\n\n        // Approve underlying to Aave pool from the proxy (assumes the proxy has enough underlying).\n        _approve(address(underlying), address(pool), amount);\n\n        // Deposit underlying into Aave pool, proxy receives aTokens\n        proxy.doCall(\n            address(pool),\n            abi.encodeCall(pool.supply, (address(underlying), amount, address(proxy), 0))\n        );\n    }\n\n    // NOTE: !!! Rate limited at end of function !!!\n    function withdrawAave(address aToken, uint256 amount)\n        external\n        returns (uint256 amountWithdrawn)\n    {\n        _checkRole(RELAYER);\n\n        IAavePool pool = IAavePool(IATokenWithPool(aToken).POOL());\n\n        // Withdraw underlying from Aave pool, decode resulting amount withdrawn.\n        // Assumes proxy has adequate aTokens.\n        amountWithdrawn = abi.decode(\n            proxy.doCall(\n                address(pool),\n                abi.encodeCall(\n                    pool.withdraw,\n                    (IATokenWithPool(aToken).UNDERLYING_ASSET_ADDRESS(), amount, address(proxy))\n                )\n            ),\n            (uint256)\n        );\n\n        rateLimits.triggerRateLimitDecrease(\n            RateLimitHelpers.makeAssetKey(LIMIT_AAVE_WITHDRAW, aToken),\n            amountWithdrawn\n        );\n    }\n\n    /**********************************************************************************************/\n    /*** Relayer BlackRock BUIDL functions                                                      ***/\n    /**********************************************************************************************/\n\n    function redeemBUIDLCircleFacility(uint256 usdcAmount) external {\n        _checkRole(RELAYER);\n        _rateLimited(LIMIT_BUIDL_REDEEM_CIRCLE, usdcAmount);\n\n        _approve(address(buidlRedeem.asset()), address(buidlRedeem), usdcAmount);\n\n        proxy.doCall(\n            address(buidlRedeem),\n            abi.encodeCall(buidlRedeem.redeem, (usdcAmount))\n        );\n    }\n\n    /**********************************************************************************************/\n    /*** Relayer Curve StableSwap functions                                                     ***/\n    /**********************************************************************************************/\n\n    function swapCurve(\n        address pool,\n        uint256 inputIndex,\n        uint256 outputIndex,\n        uint256 amountIn,\n        uint256 minAmountOut\n    )\n        external returns (uint256 amountOut)\n    {\n        _checkRole(RELAYER);\n\n        require(inputIndex != outputIndex, \"MainnetController/invalid-indices\");\n\n        uint256 maxSlippage = maxSlippages[pool];\n        require(maxSlippage != 0, \"MainnetController/max-slippage-not-set\");\n\n        ICurvePoolLike curvePool = ICurvePoolLike(pool);\n\n        uint256 numCoins = curvePool.N_COINS();\n        require(\n            inputIndex < numCoins && outputIndex < numCoins,\n            \"MainnetController/index-too-high\"\n        );\n\n        // Normalized to provide 36 decimal precision when multiplied by asset amount\n        uint256[] memory rates = curvePool.stored_rates();\n\n        // Below code is simplified from the following logic.\n        // `maxSlippage` was multipled first to avoid precision loss.\n        //   valueIn   = amountIn * rates[inputIndex] / 1e18  // 18 decimal precision, USD\n        //   tokensOut = valueIn * 1e18 / rates[outputIndex]  // Token precision, token amount\n        //   result    = tokensOut * maxSlippage / 1e18\n        uint256 minimumMinAmountOut = amountIn\n            * rates[inputIndex]\n            * maxSlippage\n            / rates[outputIndex]\n            / 1e18;\n\n        require(\n            minAmountOut >= minimumMinAmountOut,\n            \"MainnetController/min-amount-not-met\"\n        );\n\n        rateLimits.triggerRateLimitDecrease(\n            RateLimitHelpers.makeAssetKey(LIMIT_CURVE_SWAP, pool),\n            amountIn * rates[inputIndex] / 1e18\n        );\n\n        _approve(curvePool.coins(inputIndex), pool, amountIn);\n\n        amountOut = abi.decode(\n            proxy.doCall(\n                pool,\n                abi.encodeCall(\n                    curvePool.exchange,\n                    (\n                        int128(int256(inputIndex)),   // safe cast because of 8 token max\n                        int128(int256(outputIndex)),  // safe cast because of 8 token max\n                        amountIn,\n                        minAmountOut,\n                        address(proxy)\n                    )\n                )\n            ),\n            (uint256)\n        );\n    }\n\n    function addLiquidityCurve(\n        address pool,\n        uint256[] memory depositAmounts,\n        uint256 minLpAmount\n    )\n        external returns (uint256 shares)\n    {\n        _checkRole(RELAYER);\n\n        uint256 maxSlippage = maxSlippages[pool];\n        require(maxSlippage != 0, \"MainnetController/max-slippage-not-set\");\n\n        ICurvePoolLike curvePool = ICurvePoolLike(pool);\n\n        require(\n            depositAmounts.length == curvePool.N_COINS(),\n            \"MainnetController/invalid-deposit-amounts\"\n        );\n\n        // Normalized to provide 36 decimal precision when multiplied by asset amount\n        uint256[] memory rates = curvePool.stored_rates();\n\n        // Aggregate the value of the deposited assets (e.g. USD)\n        uint256 valueDeposited;\n        for (uint256 i = 0; i < depositAmounts.length; i++) {\n            _approve(curvePool.coins(i), pool, depositAmounts[i]);\n            valueDeposited += depositAmounts[i] * rates[i];\n        }\n        valueDeposited /= 1e18;\n\n        // Ensure minimum LP amount expected is greater than max slippage amount.\n        require(\n            minLpAmount >= valueDeposited * maxSlippage / curvePool.get_virtual_price(),\n            \"MainnetController/min-amount-not-met\"\n        );\n\n        // Reduce the rate limit by the aggregated underlying asset value of the deposit (e.g. USD)\n        rateLimits.triggerRateLimitDecrease(\n            RateLimitHelpers.makeAssetKey(LIMIT_CURVE_DEPOSIT, pool),\n            valueDeposited\n        );\n\n        shares = abi.decode(\n            proxy.doCall(\n                pool,\n                abi.encodeCall(\n                    curvePool.add_liquidity,\n                    (depositAmounts, minLpAmount, address(proxy))\n                )\n            ),\n            (uint256)\n        );\n\n        // Compute the swap value by taking the difference of the current underlying\n        // asset values from minted shares vs the deposited funds, converting this into an\n        // aggregated swap \"amount in\" by dividing the total value moved by two and decrease the\n        // swap rate limit by this amount.\n        uint256 totalSwapped;\n        for (uint256 i; i < depositAmounts.length; i++) {\n            totalSwapped += _absSubtraction(\n                curvePool.balances(i) * rates[i] * shares / curvePool.totalSupply(),\n                depositAmounts[i] * rates[i]\n            );\n        }\n        uint256 averageSwap = totalSwapped / 2 / 1e18;\n\n        rateLimits.triggerRateLimitDecrease(\n            RateLimitHelpers.makeAssetKey(LIMIT_CURVE_SWAP, pool),\n            averageSwap\n        );\n    }\n\n    function removeLiquidityCurve(\n        address pool,\n        uint256 lpBurnAmount,\n        uint256[] memory minWithdrawAmounts\n    )\n        external returns (uint256[] memory withdrawnTokens)\n    {\n        _checkRole(RELAYER);\n\n        uint256 maxSlippage = maxSlippages[pool];\n        require(maxSlippage != 0, \"MainnetController/max-slippage-not-set\");\n\n        ICurvePoolLike curvePool = ICurvePoolLike(pool);\n\n        require(\n            minWithdrawAmounts.length == curvePool.N_COINS(),\n            \"MainnetController/invalid-min-withdraw-amounts\"\n        );\n\n        // Normalized to provide 36 decimal precision when multiplied by asset amount\n        uint256[] memory rates = curvePool.stored_rates();\n\n        // Aggregate the minimum values of the withdrawn assets (e.g. USD)\n        uint256 valueMinWithdrawn;\n        for (uint256 i = 0; i < minWithdrawAmounts.length; i++) {\n            valueMinWithdrawn += minWithdrawAmounts[i] * rates[i];\n        }\n        valueMinWithdrawn /= 1e18;\n\n        // Check that the aggregated minimums are greater than the max slippage amount\n        require(\n            valueMinWithdrawn >= lpBurnAmount * curvePool.get_virtual_price() * maxSlippage / 1e36,\n            \"MainnetController/min-amount-not-met\"\n        );\n\n        withdrawnTokens = abi.decode(\n            proxy.doCall(\n                pool,\n                abi.encodeCall(\n                    curvePool.remove_liquidity,\n                    (lpBurnAmount, minWithdrawAmounts, address(proxy))\n                )\n            ),\n            (uint256[])\n        );\n\n        // Aggregate value withdrawn to reduce the rate limit\n        uint256 valueWithdrawn;\n        for (uint256 i = 0; i < withdrawnTokens.length; i++) {\n            valueWithdrawn += withdrawnTokens[i] * rates[i];\n        }\n        valueWithdrawn /= 1e18;\n\n        rateLimits.triggerRateLimitDecrease(\n            RateLimitHelpers.makeAssetKey(LIMIT_CURVE_WITHDRAW, pool),\n            valueWithdrawn\n        );\n    }\n\n    /**********************************************************************************************/\n    /*** Relayer Ethena functions                                                               ***/\n    /**********************************************************************************************/\n\n    function setDelegatedSigner(address delegatedSigner) external {\n        _checkRole(RELAYER);\n\n        proxy.doCall(\n            address(ethenaMinter),\n            abi.encodeCall(ethenaMinter.setDelegatedSigner, (address(delegatedSigner)))\n        );\n    }\n\n    function removeDelegatedSigner(address delegatedSigner) external {\n        _checkRole(RELAYER);\n\n        proxy.doCall(\n            address(ethenaMinter),\n            abi.encodeCall(ethenaMinter.removeDelegatedSigner, (address(delegatedSigner)))\n        );\n    }\n\n    // Note that Ethena's mint/redeem per-block limits include other users\n    function prepareUSDeMint(uint256 usdcAmount) external {\n        _checkRole(RELAYER);\n        _rateLimited(LIMIT_USDE_MINT, usdcAmount);\n        _approve(address(usdc), address(ethenaMinter), usdcAmount);\n    }\n\n    function prepareUSDeBurn(uint256 usdeAmount) external {\n        _checkRole(RELAYER);\n        _rateLimited(LIMIT_USDE_BURN, usdeAmount);\n        _approve(address(usde), address(ethenaMinter), usdeAmount);\n    }\n\n    function cooldownAssetsSUSDe(uint256 usdeAmount) external {\n        _checkRole(RELAYER);\n        _rateLimited(LIMIT_SUSDE_COOLDOWN, usdeAmount);\n\n        proxy.doCall(\n            address(susde),\n            abi.encodeCall(susde.cooldownAssets, (usdeAmount))\n        );\n    }\n\n    // NOTE: !!! Rate limited at end of function !!!\n    function cooldownSharesSUSDe(uint256 susdeAmount)\n        external\n        returns (uint256 cooldownAmount)\n    {\n        _checkRole(RELAYER);\n\n        cooldownAmount = abi.decode(\n            proxy.doCall(\n                address(susde),\n                abi.encodeCall(susde.cooldownShares, (susdeAmount))\n            ),\n            (uint256)\n        );\n\n        rateLimits.triggerRateLimitDecrease(LIMIT_SUSDE_COOLDOWN, cooldownAmount);\n    }\n\n    function unstakeSUSDe() external {\n        _checkRole(RELAYER);\n\n        proxy.doCall(\n            address(susde),\n            abi.encodeCall(susde.unstake, (address(proxy)))\n        );\n    }\n\n    /**********************************************************************************************/\n    /*** Relayer Maple functions                                                                ***/\n    /**********************************************************************************************/\n\n    function requestMapleRedemption(address mapleToken, uint256 shares) external {\n        _checkRole(RELAYER);\n        _rateLimitedAsset(\n            LIMIT_MAPLE_REDEEM,\n            mapleToken,\n            IMapleTokenLike(mapleToken).convertToAssets(shares)\n        );\n\n        proxy.doCall(\n            mapleToken,\n            abi.encodeCall(IMapleTokenLike(mapleToken).requestRedeem, (shares, address(proxy)))\n        );\n    }\n\n    function cancelMapleRedemption(address mapleToken, uint256 shares) external {\n        _checkRole(RELAYER);\n        _rateLimitExists(RateLimitHelpers.makeAssetKey(LIMIT_MAPLE_REDEEM, mapleToken));\n\n        proxy.doCall(\n            mapleToken,\n            abi.encodeCall(IMapleTokenLike(mapleToken).removeShares, (shares, address(proxy)))\n        );\n    }\n\n    /**********************************************************************************************/\n    /*** Relayer Superstate functions                                                           ***/\n    /**********************************************************************************************/\n\n    function subscribeSuperstate(uint256 usdcAmount) external {\n        _checkRole(RELAYER);\n        _rateLimited(LIMIT_SUPERSTATE_SUBSCRIBE, usdcAmount);\n\n        _approve(address(usdc), address(ustb), usdcAmount);\n\n        proxy.doCall(\n            address(ustb),\n            abi.encodeCall(ustb.subscribe, (usdcAmount, address(usdc)))\n        );\n    }\n\n    // NOTE: Rate limited outside of modifier because of tuple return\n    function redeemSuperstate(uint256 ustbAmount) external {\n        _checkRole(RELAYER);\n\n        ( uint256 usdcAmount, ) = superstateRedemption.calculateUsdcOut(ustbAmount);\n\n        rateLimits.triggerRateLimitDecrease(LIMIT_SUPERSTATE_REDEEM, usdcAmount);\n\n        _approve(address(ustb), address(superstateRedemption), ustbAmount);\n\n        proxy.doCall(\n            address(superstateRedemption),\n            abi.encodeCall(superstateRedemption.redeem, (ustbAmount))\n        );\n    }\n\n    /**********************************************************************************************/\n    /*** Relayer DaiUsds functions                                                              ***/\n    /**********************************************************************************************/\n\n    function swapUSDSToDAI(uint256 usdsAmount)\n        external\n        onlyRole(RELAYER)\n    {\n        // Approve USDS to DaiUsds migrator from the proxy (assumes the proxy has enough USDS)\n        _approve(address(usds), address(daiUsds), usdsAmount);\n\n        // Swap USDS to DAI 1:1\n        proxy.doCall(\n            address(daiUsds),\n            abi.encodeCall(daiUsds.usdsToDai, (address(proxy), usdsAmount))\n        );\n    }\n\n    function swapDAIToUSDS(uint256 daiAmount)\n        external\n        onlyRole(RELAYER)\n    {\n        // Approve DAI to DaiUsds migrator from the proxy (assumes the proxy has enough DAI)\n        _approve(address(dai), address(daiUsds), daiAmount);\n\n        // Swap DAI to USDS 1:1\n        proxy.doCall(\n            address(daiUsds),\n            abi.encodeCall(daiUsds.daiToUsds, (address(proxy), daiAmount))\n        );\n    }\n\n    /**********************************************************************************************/\n    /*** Relayer PSM functions                                                                  ***/\n    /**********************************************************************************************/\n\n    // NOTE: The param `usdcAmount` is denominated in 1e6 precision to match how PSM uses\n    //       USDC precision for both `buyGemNoFee` and `sellGemNoFee`\n    function swapUSDSToUSDC(uint256 usdcAmount) external {\n        _checkRole(RELAYER);\n        _rateLimited(LIMIT_USDS_TO_USDC, usdcAmount);\n\n        uint256 usdsAmount = usdcAmount * psmTo18ConversionFactor;\n\n        // Approve USDS to DaiUsds migrator from the proxy (assumes the proxy has enough USDS)\n        _approve(address(usds), address(daiUsds), usdsAmount);\n\n        // Swap USDS to DAI 1:1\n        proxy.doCall(\n            address(daiUsds),\n            abi.encodeCall(daiUsds.usdsToDai, (address(proxy), usdsAmount))\n        );\n\n        // Approve DAI to PSM from the proxy because conversion from USDS to DAI was 1:1\n        _approve(address(dai), address(psm), usdsAmount);\n\n        // Swap DAI to USDC through the PSM\n        proxy.doCall(\n            address(psm),\n            abi.encodeCall(psm.buyGemNoFee, (address(proxy), usdcAmount))\n        );\n    }\n\n    function swapUSDCToUSDS(uint256 usdcAmount) external {\n        _checkRole(RELAYER);\n        _cancelRateLimit(LIMIT_USDS_TO_USDC, usdcAmount);\n\n        // Approve USDC to PSM from the proxy (assumes the proxy has enough USDC)\n        _approve(address(usdc), address(psm), usdcAmount);\n\n        // Max USDC that can be swapped to DAI in one call\n        uint256 limit = dai.balanceOf(address(psm)) / psmTo18ConversionFactor;\n\n        if (usdcAmount <= limit) {\n            _swapUSDCToDAI(usdcAmount);\n        } else {\n            uint256 remainingUsdcToSwap = usdcAmount;\n\n            // Refill the PSM with DAI as many times as needed to get to the full `usdcAmount`.\n            // If the PSM cannot be filled with the full amount, psm.fill() will revert\n            // with `DssLitePsm/nothing-to-fill` since rush() will return 0.\n            // This is desired behavior because this function should only succeed if the full\n            // `usdcAmount` can be swapped.\n            while (remainingUsdcToSwap > 0) {\n                psm.fill();\n\n                limit = dai.balanceOf(address(psm)) / psmTo18ConversionFactor;\n\n                uint256 swapAmount = remainingUsdcToSwap < limit ? remainingUsdcToSwap : limit;\n\n                _swapUSDCToDAI(swapAmount);\n\n                remainingUsdcToSwap -= swapAmount;\n            }\n        }\n\n        uint256 daiAmount = usdcAmount * psmTo18ConversionFactor;\n\n        // Approve DAI to DaiUsds migrator from the proxy (assumes the proxy has enough DAI)\n        _approve(address(dai), address(daiUsds), daiAmount);\n\n        // Swap DAI to USDS 1:1\n        proxy.doCall(\n            address(daiUsds),\n            abi.encodeCall(daiUsds.daiToUsds, (address(proxy), daiAmount))\n        );\n    }\n\n    /**********************************************************************************************/\n    /*** Relayer bridging functions                                                             ***/\n    /**********************************************************************************************/\n\n    function transferUSDCToCCTP(uint256 usdcAmount, uint32 destinationDomain) external {\n        _checkRole(RELAYER);\n        _rateLimited(LIMIT_USDC_TO_CCTP, usdcAmount);\n        _rateLimited(\n            RateLimitHelpers.makeDomainKey(LIMIT_USDC_TO_DOMAIN, destinationDomain),\n            usdcAmount\n        );\n\n        bytes32 mintRecipient = mintRecipients[destinationDomain];\n\n        require(mintRecipient != 0, \"MainnetController/domain-not-configured\");\n\n        // Approve USDC to CCTP from the proxy (assumes the proxy has enough USDC)\n        _approve(address(usdc), address(cctp), usdcAmount);\n\n        // If amount is larger than limit it must be split into multiple calls\n        uint256 burnLimit = cctp.localMinter().burnLimitsPerMessage(address(usdc));\n\n        while (usdcAmount > burnLimit) {\n            _initiateCCTPTransfer(burnLimit, destinationDomain, mintRecipient);\n            usdcAmount -= burnLimit;\n        }\n\n        // Send remaining amount (if any)\n        if (usdcAmount > 0) {\n            _initiateCCTPTransfer(usdcAmount, destinationDomain, mintRecipient);\n        }\n    }\n\n    /**********************************************************************************************/\n    /*** Relayer helper functions                                                               ***/\n    /**********************************************************************************************/\n\n    function _absSubtraction(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a - b : b - a;\n    }\n\n    function _approve(address token, address spender, uint256 amount) internal {\n        proxy.doCall(token, abi.encodeCall(IERC20.approve, (spender, amount)));\n    }\n\n    function _initiateCCTPTransfer(\n        uint256 usdcAmount,\n        uint32  destinationDomain,\n        bytes32 mintRecipient\n    )\n        internal\n    {\n        uint64 nonce = abi.decode(\n            proxy.doCall(\n                address(cctp),\n                abi.encodeCall(\n                    cctp.depositForBurn,\n                    (\n                        usdcAmount,\n                        destinationDomain,\n                        mintRecipient,\n                        address(usdc)\n                    )\n                )\n            ),\n            (uint64)\n        );\n\n        emit CCTPTransferInitiated(nonce, destinationDomain, mintRecipient, usdcAmount);\n    }\n\n    function _swapUSDCToDAI(uint256 usdcAmount) internal {\n        // Swap USDC to DAI through the PSM (1:1 since sellGemNoFee is used)\n        proxy.doCall(\n            address(psm),\n            abi.encodeCall(psm.sellGemNoFee, (address(proxy), usdcAmount))\n        );\n    }\n\n    /**********************************************************************************************/\n    /*** Rate Limit helper functions                                                            ***/\n    /**********************************************************************************************/\n\n    function _rateLimited(bytes32 key, uint256 amount) internal {\n        rateLimits.triggerRateLimitDecrease(key, amount);\n    }\n\n    function _rateLimitedAsset(bytes32 key, address asset, uint256 amount) internal {\n        rateLimits.triggerRateLimitDecrease(RateLimitHelpers.makeAssetKey(key, asset), amount);\n    }\n\n    function _cancelRateLimit(bytes32 key, uint256 amount) internal {\n        rateLimits.triggerRateLimitIncrease(key, amount);\n    }\n\n    function _rateLimitExists(bytes32 key) internal view {\n        require(\n            rateLimits.getRateLimitData(key).maxAmount > 0,\n            \"MainnetController/invalid-action\"\n        );\n    }\n\n}\n\n"
    },
    "lib/spark-alm-controller/src/ForeignController.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.21;\n\nimport { IAToken }            from \"aave-v3-origin/src/core/contracts/interfaces/IAToken.sol\";\nimport { IPool as IAavePool } from \"aave-v3-origin/src/core/contracts/interfaces/IPool.sol\";\n\nimport { IERC20 }   from \"forge-std/interfaces/IERC20.sol\";\nimport { IERC4626 } from \"forge-std/interfaces/IERC4626.sol\";\n\nimport { IMetaMorpho, Id, MarketAllocation } from \"metamorpho/interfaces/IMetaMorpho.sol\";\n\nimport { AccessControl } from \"openzeppelin-contracts/contracts/access/AccessControl.sol\";\n\nimport { IPSM3 } from \"spark-psm/src/interfaces/IPSM3.sol\";\n\nimport { IALMProxy }   from \"./interfaces/IALMProxy.sol\";\nimport { ICCTPLike }   from \"./interfaces/CCTPInterfaces.sol\";\nimport { IRateLimits } from \"./interfaces/IRateLimits.sol\";\n\nimport { RateLimitHelpers } from \"./RateLimitHelpers.sol\";\n\ninterface IATokenWithPool is IAToken {\n    function POOL() external view returns(address);\n}\n\ncontract ForeignController is AccessControl {\n\n    /**********************************************************************************************/\n    /*** Events                                                                                 ***/\n    /**********************************************************************************************/\n\n    // NOTE: This is used to track individual transfers for offchain processing of CCTP transactions\n    event CCTPTransferInitiated(\n        uint64  indexed nonce,\n        uint32  indexed destinationDomain,\n        bytes32 indexed mintRecipient,\n        uint256 usdcAmount\n    );\n\n    event MintRecipientSet(uint32 indexed destinationDomain, bytes32 mintRecipient);\n\n    event RelayerRemoved(address indexed relayer);\n\n    /**********************************************************************************************/\n    /*** State variables                                                                        ***/\n    /**********************************************************************************************/\n\n    bytes32 public constant FREEZER = keccak256(\"FREEZER\");\n    bytes32 public constant RELAYER = keccak256(\"RELAYER\");\n\n    bytes32 public constant LIMIT_4626_DEPOSIT   = keccak256(\"LIMIT_4626_DEPOSIT\");\n    bytes32 public constant LIMIT_4626_WITHDRAW  = keccak256(\"LIMIT_4626_WITHDRAW\");\n    bytes32 public constant LIMIT_AAVE_DEPOSIT   = keccak256(\"LIMIT_AAVE_DEPOSIT\");\n    bytes32 public constant LIMIT_AAVE_WITHDRAW  = keccak256(\"LIMIT_AAVE_WITHDRAW\");\n    bytes32 public constant LIMIT_PSM_DEPOSIT    = keccak256(\"LIMIT_PSM_DEPOSIT\");\n    bytes32 public constant LIMIT_PSM_WITHDRAW   = keccak256(\"LIMIT_PSM_WITHDRAW\");\n    bytes32 public constant LIMIT_USDC_TO_CCTP   = keccak256(\"LIMIT_USDC_TO_CCTP\");\n    bytes32 public constant LIMIT_USDC_TO_DOMAIN = keccak256(\"LIMIT_USDC_TO_DOMAIN\");\n\n    IALMProxy   public immutable proxy;\n    ICCTPLike   public immutable cctp;\n    IPSM3       public immutable psm;\n    IRateLimits public immutable rateLimits;\n\n    IERC20 public immutable usdc;\n\n    mapping(uint32 destinationDomain => bytes32 mintRecipient) public mintRecipients;\n\n    /**********************************************************************************************/\n    /*** Initialization                                                                         ***/\n    /**********************************************************************************************/\n\n    constructor(\n        address admin_,\n        address proxy_,\n        address rateLimits_,\n        address psm_,\n        address usdc_,\n        address cctp_\n    ) {\n        _grantRole(DEFAULT_ADMIN_ROLE, admin_);\n\n        proxy      = IALMProxy(proxy_);\n        rateLimits = IRateLimits(rateLimits_);\n        psm        = IPSM3(psm_);\n        usdc       = IERC20(usdc_);\n        cctp       = ICCTPLike(cctp_);\n    }\n\n    /**********************************************************************************************/\n    /*** Modifiers                                                                              ***/\n    /**********************************************************************************************/\n\n    modifier rateLimited(bytes32 key, uint256 amount) {\n        rateLimits.triggerRateLimitDecrease(key, amount);\n        _;\n    }\n\n    modifier rateLimitedAsset(bytes32 key, address asset, uint256 amount) {\n        rateLimits.triggerRateLimitDecrease(RateLimitHelpers.makeAssetKey(key, asset), amount);\n        _;\n    }\n\n    modifier rateLimitExists(bytes32 key) {\n        require(\n            rateLimits.getRateLimitData(key).maxAmount > 0,\n            \"ForeignController/invalid-action\"\n        );\n        _;\n    }\n\n    /**********************************************************************************************/\n    /*** Admin functions                                                                        ***/\n    /**********************************************************************************************/\n\n    function setMintRecipient(uint32 destinationDomain, bytes32 mintRecipient)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        mintRecipients[destinationDomain] = mintRecipient;\n        emit MintRecipientSet(destinationDomain, mintRecipient);\n    }\n\n    /**********************************************************************************************/\n    /*** Freezer functions                                                                      ***/\n    /**********************************************************************************************/\n\n    function removeRelayer(address relayer) external onlyRole(FREEZER) {\n        _revokeRole(RELAYER, relayer);\n        emit RelayerRemoved(relayer);\n    }\n\n    /**********************************************************************************************/\n    /*** Relayer PSM functions                                                                  ***/\n    /**********************************************************************************************/\n\n    function depositPSM(address asset, uint256 amount)\n        external\n        onlyRole(RELAYER)\n        rateLimitedAsset(LIMIT_PSM_DEPOSIT, asset, amount)\n        returns (uint256 shares)\n    {\n        // Approve `asset` to PSM from the proxy (assumes the proxy has enough `asset`).\n        _approve(asset, address(psm), amount);\n\n        // Deposit `amount` of `asset` in the PSM, decode the result to get `shares`.\n        shares = abi.decode(\n            proxy.doCall(\n                address(psm),\n                abi.encodeCall(\n                    psm.deposit,\n                    (asset, address(proxy), amount)\n                )\n            ),\n            (uint256)\n        );\n    }\n\n    // NOTE: !!! Rate limited at end of function !!!\n    function withdrawPSM(address asset, uint256 maxAmount)\n        external\n        onlyRole(RELAYER)\n        returns (uint256 assetsWithdrawn)\n    {\n        // Withdraw up to `maxAmount` of `asset` in the PSM, decode the result\n        // to get `assetsWithdrawn` (assumes the proxy has enough PSM shares).\n        assetsWithdrawn = abi.decode(\n            proxy.doCall(\n                address(psm),\n                abi.encodeCall(\n                    psm.withdraw,\n                    (asset, address(proxy), maxAmount)\n                )\n            ),\n            (uint256)\n        );\n\n        rateLimits.triggerRateLimitDecrease(\n            RateLimitHelpers.makeAssetKey(LIMIT_PSM_WITHDRAW, asset),\n            assetsWithdrawn\n        );\n    }\n\n    /**********************************************************************************************/\n    /*** Relayer bridging functions                                                             ***/\n    /**********************************************************************************************/\n\n    function transferUSDCToCCTP(uint256 usdcAmount, uint32 destinationDomain)\n        external\n        onlyRole(RELAYER)\n        rateLimited(LIMIT_USDC_TO_CCTP, usdcAmount)\n        rateLimited(\n            RateLimitHelpers.makeDomainKey(LIMIT_USDC_TO_DOMAIN, destinationDomain),\n            usdcAmount\n        )\n    {\n        bytes32 mintRecipient = mintRecipients[destinationDomain];\n\n        require(mintRecipient != 0, \"ForeignController/domain-not-configured\");\n\n        // Approve USDC to CCTP from the proxy (assumes the proxy has enough USDC).\n        _approve(address(usdc), address(cctp), usdcAmount);\n\n        // If amount is larger than limit it must be split into multiple calls.\n        uint256 burnLimit = cctp.localMinter().burnLimitsPerMessage(address(usdc));\n\n        while (usdcAmount > burnLimit) {\n            _initiateCCTPTransfer(burnLimit, destinationDomain, mintRecipient);\n            usdcAmount -= burnLimit;\n        }\n\n        // Send remaining amount (if any)\n        if (usdcAmount > 0) {\n            _initiateCCTPTransfer(usdcAmount, destinationDomain, mintRecipient);\n        }\n    }\n\n    /**********************************************************************************************/\n    /*** Relayer ERC4626 functions                                                              ***/\n    /**********************************************************************************************/\n\n    function depositERC4626(address token, uint256 amount)\n        external\n        onlyRole(RELAYER)\n        rateLimitedAsset(LIMIT_4626_DEPOSIT, token, amount)\n        returns (uint256 shares)\n    {\n        // Note that whitelist is done by rate limits.\n        IERC20 asset = IERC20(IERC4626(token).asset());\n\n        // Approve asset to token from the proxy (assumes the proxy has enough of the asset).\n        _approve(address(asset), token, amount);\n\n        // Deposit asset into the token, proxy receives token shares, decode the resulting shares.\n        shares = abi.decode(\n            proxy.doCall(\n                token,\n                abi.encodeCall(IERC4626(token).deposit, (amount, address(proxy)))\n            ),\n            (uint256)\n        );\n    }\n\n    function withdrawERC4626(address token, uint256 amount)\n        external\n        onlyRole(RELAYER)\n        rateLimitedAsset(LIMIT_4626_WITHDRAW, token, amount)\n        returns (uint256 shares)\n    {\n        // Withdraw asset from a token, decode resulting shares.\n        // Assumes proxy has adequate token shares.\n        shares = abi.decode(\n            proxy.doCall(\n                token,\n                abi.encodeCall(IERC4626(token).withdraw, (amount, address(proxy), address(proxy)))\n            ),\n            (uint256)\n        );\n    }\n\n    // NOTE: !!! Rate limited at end of function !!!\n    function redeemERC4626(address token, uint256 shares)\n        external\n        onlyRole(RELAYER)\n        returns (uint256 assets)\n    {\n        // Redeem shares for assets from the token, decode the resulting assets.\n        // Assumes proxy has adequate token shares.\n        assets = abi.decode(\n            proxy.doCall(\n                token,\n                abi.encodeCall(IERC4626(token).redeem, (shares, address(proxy), address(proxy)))\n            ),\n            (uint256)\n        );\n\n        rateLimits.triggerRateLimitDecrease(\n            RateLimitHelpers.makeAssetKey(LIMIT_4626_WITHDRAW, token),\n            assets\n        );\n    }\n\n    /**********************************************************************************************/\n    /*** Relayer Aave functions                                                                 ***/\n    /**********************************************************************************************/\n\n    function depositAave(address aToken, uint256 amount)\n        external\n        onlyRole(RELAYER)\n        rateLimitedAsset(LIMIT_AAVE_DEPOSIT, aToken, amount)\n    {\n        IERC20    underlying = IERC20(IATokenWithPool(aToken).UNDERLYING_ASSET_ADDRESS());\n        IAavePool pool       = IAavePool(IATokenWithPool(aToken).POOL());\n\n        // Approve underlying to Aave pool from the proxy (assumes the proxy has enough underlying).\n        _approve(address(underlying), address(pool), amount);\n\n        // Deposit underlying into Aave pool, proxy receives aTokens.\n        proxy.doCall(\n            address(pool),\n            abi.encodeCall(pool.supply, (address(underlying), amount, address(proxy), 0))\n        );\n    }\n\n    // NOTE: !!! Rate limited at end of function !!!\n    function withdrawAave(address aToken, uint256 amount)\n        external\n        onlyRole(RELAYER)\n        returns (uint256 amountWithdrawn)\n    {\n        IAavePool pool = IAavePool(IATokenWithPool(aToken).POOL());\n\n        // Withdraw underlying from Aave pool, decode resulting amount withdrawn.\n        // Assumes proxy has adequate aTokens.\n        amountWithdrawn = abi.decode(\n            proxy.doCall(\n                address(pool),\n                abi.encodeCall(\n                    pool.withdraw,\n                    (IATokenWithPool(aToken).UNDERLYING_ASSET_ADDRESS(), amount, address(proxy))\n                )\n            ),\n            (uint256)\n        );\n\n        rateLimits.triggerRateLimitDecrease(\n            RateLimitHelpers.makeAssetKey(LIMIT_AAVE_WITHDRAW, aToken),\n            amountWithdrawn\n        );\n    }\n\n    /**********************************************************************************************/\n    /*** Relayer Morpho functions                                                               ***/\n    /**********************************************************************************************/\n\n    function setSupplyQueueMorpho(address morphoVault, Id[] memory newSupplyQueue)\n        external\n        onlyRole(RELAYER)\n        rateLimitExists(RateLimitHelpers.makeAssetKey(LIMIT_4626_DEPOSIT, morphoVault))\n    {\n        proxy.doCall(\n            morphoVault,\n            abi.encodeCall(IMetaMorpho(morphoVault).setSupplyQueue, (newSupplyQueue))\n        );\n    }\n\n    function updateWithdrawQueueMorpho(address morphoVault, uint256[] calldata indexes)\n        external\n        onlyRole(RELAYER)\n        rateLimitExists(RateLimitHelpers.makeAssetKey(LIMIT_4626_DEPOSIT, morphoVault))\n    {\n        proxy.doCall(\n            morphoVault,\n            abi.encodeCall(IMetaMorpho(morphoVault).updateWithdrawQueue, (indexes))\n        );\n    }\n\n    function reallocateMorpho(address morphoVault, MarketAllocation[] calldata allocations)\n        external\n        onlyRole(RELAYER)\n        rateLimitExists(RateLimitHelpers.makeAssetKey(LIMIT_4626_DEPOSIT, morphoVault))\n    {\n        proxy.doCall(\n            morphoVault,\n            abi.encodeCall(IMetaMorpho(morphoVault).reallocate, (allocations))\n        );\n    }\n\n\n    /**********************************************************************************************/\n    /*** Internal helper functions                                                              ***/\n    /**********************************************************************************************/\n\n    function _approve(address token, address spender, uint256 amount) internal {\n        proxy.doCall(token, abi.encodeCall(IERC20.approve, (spender, amount)));\n    }\n\n    function _initiateCCTPTransfer(\n        uint256 usdcAmount,\n        uint32  destinationDomain,\n        bytes32 mintRecipient\n    )\n        internal\n    {\n        uint64 nonce = abi.decode(\n            proxy.doCall(\n                address(cctp),\n                abi.encodeCall(\n                    cctp.depositForBurn,\n                    (\n                        usdcAmount,\n                        destinationDomain,\n                        mintRecipient,\n                        address(usdc)\n                    )\n                )\n            ),\n            (uint64)\n        );\n\n        emit CCTPTransferInitiated(nonce, destinationDomain, mintRecipient, usdcAmount);\n    }\n\n}\n"
    },
    "lib/spark-alm-controller/src/RateLimitHelpers.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.21;\n\nimport { IRateLimits } from \"../src/interfaces/IRateLimits.sol\";\n\nstruct RateLimitData {\n    uint256 maxAmount;\n    uint256 slope;\n}\n\nlibrary RateLimitHelpers {\n\n    error InvalidUnlimitedRateLimitSlope(string name);\n    error InvalidMaxAmountPrecision(string name);\n    error InvalidSlopePrecision(string name);\n\n    function makeAssetKey(bytes32 key, address asset) internal pure returns (bytes32) {\n        return keccak256(abi.encode(key, asset));\n    }\n\n    function makeAssetDestinationKey(bytes32 key, address asset, address destination) internal pure returns (bytes32) {\n        return keccak256(abi.encode(key, asset, destination));\n    }\n\n    function makeDomainKey(bytes32 key, uint32 domain) internal pure returns (bytes32) {\n        return keccak256(abi.encode(key, domain));\n    }\n\n    function unlimitedRateLimit() internal pure returns (RateLimitData memory) {\n        return RateLimitData({\n            maxAmount : type(uint256).max,\n            slope     : 0\n        });\n    }\n\n    function setRateLimitData(\n        bytes32       key,\n        address       rateLimits,\n        RateLimitData memory data,\n        string        memory name,\n        uint256       decimals\n    )\n        internal\n    {\n        // Handle setting an unlimited rate limit\n        if (data.maxAmount == type(uint256).max) {\n            if (data.slope != 0) {\n                revert InvalidUnlimitedRateLimitSlope(name);\n            }\n        } else {\n            uint256 upperBound = 1e12 * (10 ** decimals);\n            uint256 lowerBound = 10 ** decimals;\n\n            if (data.maxAmount > upperBound || data.maxAmount < lowerBound) {\n                revert InvalidMaxAmountPrecision(name);\n            }\n\n            if (\n                data.slope != 0 &&\n                (data.slope > upperBound / 1 hours || data.slope < lowerBound / 1 hours)\n            ) {\n                revert InvalidSlopePrecision(name);\n            }\n        }\n        IRateLimits(rateLimits).setRateLimitData(key, data.maxAmount, data.slope);\n    }\n\n}\n"
    },
    "lib/xchain-helpers/src/forwarders/CCTPForwarder.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.0;\n\ninterface IMessageTransmitter {\n    function sendMessage(\n        uint32 destinationDomain,\n        bytes32 recipient,\n        bytes calldata messageBody\n    ) external;\n}\n\nlibrary CCTPForwarder {\n\n    address constant internal MESSAGE_TRANSMITTER_CIRCLE_ETHEREUM     = 0x0a992d191DEeC32aFe36203Ad87D7d289a738F81;\n    address constant internal MESSAGE_TRANSMITTER_CIRCLE_AVALANCHE    = 0x8186359aF5F57FbB40c6b14A588d2A59C0C29880;\n    address constant internal MESSAGE_TRANSMITTER_CIRCLE_OPTIMISM     = 0x4D41f22c5a0e5c74090899E5a8Fb597a8842b3e8;\n    address constant internal MESSAGE_TRANSMITTER_CIRCLE_ARBITRUM_ONE = 0xC30362313FBBA5cf9163F0bb16a0e01f01A896ca;\n    address constant internal MESSAGE_TRANSMITTER_CIRCLE_BASE         = 0xAD09780d193884d503182aD4588450C416D6F9D4;\n    address constant internal MESSAGE_TRANSMITTER_CIRCLE_POLYGON_POS  = 0xF3be9355363857F3e001be68856A2f96b4C39Ba9;\n\n    uint32 constant internal DOMAIN_ID_CIRCLE_ETHEREUM     = 0;\n    uint32 constant internal DOMAIN_ID_CIRCLE_AVALANCHE    = 1;\n    uint32 constant internal DOMAIN_ID_CIRCLE_OPTIMISM     = 2;\n    uint32 constant internal DOMAIN_ID_CIRCLE_ARBITRUM_ONE = 3;\n    uint32 constant internal DOMAIN_ID_CIRCLE_NOBLE        = 4;\n    uint32 constant internal DOMAIN_ID_CIRCLE_SOLANA       = 5;\n    uint32 constant internal DOMAIN_ID_CIRCLE_BASE         = 6;\n    uint32 constant internal DOMAIN_ID_CIRCLE_POLYGON_POS  = 7;\n\n    function sendMessage(\n        address messageTransmitter,\n        uint32 destinationDomainId,\n        bytes32 recipient,\n        bytes memory messageBody\n    ) internal {\n        IMessageTransmitter(messageTransmitter).sendMessage(\n            destinationDomainId,\n            recipient,\n            messageBody\n        );\n    }\n\n    function sendMessage(\n        address messageTransmitter,\n        uint32 destinationDomainId,\n        address recipient,\n        bytes memory messageBody\n    ) internal {\n        sendMessage(\n            messageTransmitter,\n            destinationDomainId,\n            bytes32(uint256(uint160(recipient))),\n            messageBody\n        );\n    }\n    \n}\n"
    },
    "lib/sparklend-v1-core/contracts/interfaces/IPool.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\nimport {IPoolAddressesProvider} from './IPoolAddressesProvider.sol';\nimport {DataTypes} from '../protocol/libraries/types/DataTypes.sol';\n\n/**\n * @title IPool\n * @author Aave\n * @notice Defines the basic interface for an Aave Pool.\n */\ninterface IPool {\n  /**\n   * @dev Emitted on mintUnbacked()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address initiating the supply\n   * @param onBehalfOf The beneficiary of the supplied assets, receiving the aTokens\n   * @param amount The amount of supplied assets\n   * @param referralCode The referral code used\n   */\n  event MintUnbacked(\n    address indexed reserve,\n    address user,\n    address indexed onBehalfOf,\n    uint256 amount,\n    uint16 indexed referralCode\n  );\n\n  /**\n   * @dev Emitted on backUnbacked()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param backer The address paying for the backing\n   * @param amount The amount added as backing\n   * @param fee The amount paid in fees\n   */\n  event BackUnbacked(address indexed reserve, address indexed backer, uint256 amount, uint256 fee);\n\n  /**\n   * @dev Emitted on supply()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address initiating the supply\n   * @param onBehalfOf The beneficiary of the supply, receiving the aTokens\n   * @param amount The amount supplied\n   * @param referralCode The referral code used\n   */\n  event Supply(\n    address indexed reserve,\n    address user,\n    address indexed onBehalfOf,\n    uint256 amount,\n    uint16 indexed referralCode\n  );\n\n  /**\n   * @dev Emitted on withdraw()\n   * @param reserve The address of the underlying asset being withdrawn\n   * @param user The address initiating the withdrawal, owner of aTokens\n   * @param to The address that will receive the underlying\n   * @param amount The amount to be withdrawn\n   */\n  event Withdraw(address indexed reserve, address indexed user, address indexed to, uint256 amount);\n\n  /**\n   * @dev Emitted on borrow() and flashLoan() when debt needs to be opened\n   * @param reserve The address of the underlying asset being borrowed\n   * @param user The address of the user initiating the borrow(), receiving the funds on borrow() or just\n   * initiator of the transaction on flashLoan()\n   * @param onBehalfOf The address that will be getting the debt\n   * @param amount The amount borrowed out\n   * @param interestRateMode The rate mode: 1 for Stable, 2 for Variable\n   * @param borrowRate The numeric rate at which the user has borrowed, expressed in ray\n   * @param referralCode The referral code used\n   */\n  event Borrow(\n    address indexed reserve,\n    address user,\n    address indexed onBehalfOf,\n    uint256 amount,\n    DataTypes.InterestRateMode interestRateMode,\n    uint256 borrowRate,\n    uint16 indexed referralCode\n  );\n\n  /**\n   * @dev Emitted on repay()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The beneficiary of the repayment, getting his debt reduced\n   * @param repayer The address of the user initiating the repay(), providing the funds\n   * @param amount The amount repaid\n   * @param useATokens True if the repayment is done using aTokens, `false` if done with underlying asset directly\n   */\n  event Repay(\n    address indexed reserve,\n    address indexed user,\n    address indexed repayer,\n    uint256 amount,\n    bool useATokens\n  );\n\n  /**\n   * @dev Emitted on swapBorrowRateMode()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user swapping his rate mode\n   * @param interestRateMode The current interest rate mode of the position being swapped: 1 for Stable, 2 for Variable\n   */\n  event SwapBorrowRateMode(\n    address indexed reserve,\n    address indexed user,\n    DataTypes.InterestRateMode interestRateMode\n  );\n\n  /**\n   * @dev Emitted on borrow(), repay() and liquidationCall() when using isolated assets\n   * @param asset The address of the underlying asset of the reserve\n   * @param totalDebt The total isolation mode debt for the reserve\n   */\n  event IsolationModeTotalDebtUpdated(address indexed asset, uint256 totalDebt);\n\n  /**\n   * @dev Emitted when the user selects a certain asset category for eMode\n   * @param user The address of the user\n   * @param categoryId The category id\n   */\n  event UserEModeSet(address indexed user, uint8 categoryId);\n\n  /**\n   * @dev Emitted on setUserUseReserveAsCollateral()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user enabling the usage as collateral\n   */\n  event ReserveUsedAsCollateralEnabled(address indexed reserve, address indexed user);\n\n  /**\n   * @dev Emitted on setUserUseReserveAsCollateral()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user enabling the usage as collateral\n   */\n  event ReserveUsedAsCollateralDisabled(address indexed reserve, address indexed user);\n\n  /**\n   * @dev Emitted on rebalanceStableBorrowRate()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user for which the rebalance has been executed\n   */\n  event RebalanceStableBorrowRate(address indexed reserve, address indexed user);\n\n  /**\n   * @dev Emitted on flashLoan()\n   * @param target The address of the flash loan receiver contract\n   * @param initiator The address initiating the flash loan\n   * @param asset The address of the asset being flash borrowed\n   * @param amount The amount flash borrowed\n   * @param interestRateMode The flashloan mode: 0 for regular flashloan, 1 for Stable debt, 2 for Variable debt\n   * @param premium The fee flash borrowed\n   * @param referralCode The referral code used\n   */\n  event FlashLoan(\n    address indexed target,\n    address initiator,\n    address indexed asset,\n    uint256 amount,\n    DataTypes.InterestRateMode interestRateMode,\n    uint256 premium,\n    uint16 indexed referralCode\n  );\n\n  /**\n   * @dev Emitted when a borrower is liquidated.\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n   * @param user The address of the borrower getting liquidated\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n   * @param liquidatedCollateralAmount The amount of collateral received by the liquidator\n   * @param liquidator The address of the liquidator\n   * @param receiveAToken True if the liquidators wants to receive the collateral aTokens, `false` if he wants\n   * to receive the underlying collateral asset directly\n   */\n  event LiquidationCall(\n    address indexed collateralAsset,\n    address indexed debtAsset,\n    address indexed user,\n    uint256 debtToCover,\n    uint256 liquidatedCollateralAmount,\n    address liquidator,\n    bool receiveAToken\n  );\n\n  /**\n   * @dev Emitted when the state of a reserve is updated.\n   * @param reserve The address of the underlying asset of the reserve\n   * @param liquidityRate The next liquidity rate\n   * @param stableBorrowRate The next stable borrow rate\n   * @param variableBorrowRate The next variable borrow rate\n   * @param liquidityIndex The next liquidity index\n   * @param variableBorrowIndex The next variable borrow index\n   */\n  event ReserveDataUpdated(\n    address indexed reserve,\n    uint256 liquidityRate,\n    uint256 stableBorrowRate,\n    uint256 variableBorrowRate,\n    uint256 liquidityIndex,\n    uint256 variableBorrowIndex\n  );\n\n  /**\n   * @dev Emitted when the protocol treasury receives minted aTokens from the accrued interest.\n   * @param reserve The address of the reserve\n   * @param amountMinted The amount minted to the treasury\n   */\n  event MintedToTreasury(address indexed reserve, uint256 amountMinted);\n\n  /**\n   * @notice Mints an `amount` of aTokens to the `onBehalfOf`\n   * @param asset The address of the underlying asset to mint\n   * @param amount The amount to mint\n   * @param onBehalfOf The address that will receive the aTokens\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   */\n  function mintUnbacked(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external;\n\n  /**\n   * @notice Back the current unbacked underlying with `amount` and pay `fee`.\n   * @param asset The address of the underlying asset to back\n   * @param amount The amount to back\n   * @param fee The amount paid in fees\n   * @return The backed amount\n   */\n  function backUnbacked(address asset, uint256 amount, uint256 fee) external returns (uint256);\n\n  /**\n   * @notice Supplies an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\n   * - E.g. User supplies 100 USDC and gets in return 100 aUSDC\n   * @param asset The address of the underlying asset to supply\n   * @param amount The amount to be supplied\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n   *   is a different wallet\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   */\n  function supply(address asset, uint256 amount, address onBehalfOf, uint16 referralCode) external;\n\n  /**\n   * @notice Supply with transfer approval of asset to be supplied done via permit function\n   * see: https://eips.ethereum.org/EIPS/eip-2612 and https://eips.ethereum.org/EIPS/eip-713\n   * @param asset The address of the underlying asset to supply\n   * @param amount The amount to be supplied\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n   *   is a different wallet\n   * @param deadline The deadline timestamp that the permit is valid\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   * @param permitV The V parameter of ERC712 permit sig\n   * @param permitR The R parameter of ERC712 permit sig\n   * @param permitS The S parameter of ERC712 permit sig\n   */\n  function supplyWithPermit(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode,\n    uint256 deadline,\n    uint8 permitV,\n    bytes32 permitR,\n    bytes32 permitS\n  ) external;\n\n  /**\n   * @notice Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\n   * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\n   * @param asset The address of the underlying asset to withdraw\n   * @param amount The underlying amount to be withdrawn\n   *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\n   * @param to The address that will receive the underlying, same as msg.sender if the user\n   *   wants to receive it on his own wallet, or a different address if the beneficiary is a\n   *   different wallet\n   * @return The final amount withdrawn\n   */\n  function withdraw(address asset, uint256 amount, address to) external returns (uint256);\n\n  /**\n   * @notice Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower\n   * already supplied enough collateral, or he was given enough allowance by a credit delegator on the\n   * corresponding debt token (StableDebtToken or VariableDebtToken)\n   * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet\n   *   and 100 stable/variable debt tokens, depending on the `interestRateMode`\n   * @param asset The address of the underlying asset to borrow\n   * @param amount The amount to be borrowed\n   * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable\n   * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   * @param onBehalfOf The address of the user who will receive the debt. Should be the address of the borrower itself\n   * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator\n   * if he has been given credit delegation allowance\n   */\n  function borrow(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode,\n    uint16 referralCode,\n    address onBehalfOf\n  ) external;\n\n  /**\n   * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned\n   * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address\n   * @param asset The address of the borrowed underlying asset previously borrowed\n   * @param amount The amount to repay\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n   * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n   * @param onBehalfOf The address of the user who will get his debt reduced/removed. Should be the address of the\n   * user calling the function if he wants to reduce/remove his own debt, or the address of any other\n   * other borrower whose debt should be removed\n   * @return The final amount repaid\n   */\n  function repay(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode,\n    address onBehalfOf\n  ) external returns (uint256);\n\n  /**\n   * @notice Repay with transfer approval of asset to be repaid done via permit function\n   * see: https://eips.ethereum.org/EIPS/eip-2612 and https://eips.ethereum.org/EIPS/eip-713\n   * @param asset The address of the borrowed underlying asset previously borrowed\n   * @param amount The amount to repay\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n   * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n   * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the\n   * user calling the function if he wants to reduce/remove his own debt, or the address of any other\n   * other borrower whose debt should be removed\n   * @param deadline The deadline timestamp that the permit is valid\n   * @param permitV The V parameter of ERC712 permit sig\n   * @param permitR The R parameter of ERC712 permit sig\n   * @param permitS The S parameter of ERC712 permit sig\n   * @return The final amount repaid\n   */\n  function repayWithPermit(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode,\n    address onBehalfOf,\n    uint256 deadline,\n    uint8 permitV,\n    bytes32 permitR,\n    bytes32 permitS\n  ) external returns (uint256);\n\n  /**\n   * @notice Repays a borrowed `amount` on a specific reserve using the reserve aTokens, burning the\n   * equivalent debt tokens\n   * - E.g. User repays 100 USDC using 100 aUSDC, burning 100 variable/stable debt tokens\n   * @dev  Passing uint256.max as amount will clean up any residual aToken dust balance, if the user aToken\n   * balance is not enough to cover the whole debt\n   * @param asset The address of the borrowed underlying asset previously borrowed\n   * @param amount The amount to repay\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n   * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n   * @return The final amount repaid\n   */\n  function repayWithATokens(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode\n  ) external returns (uint256);\n\n  /**\n   * @notice Allows a borrower to swap his debt between stable and variable mode, or vice versa\n   * @param asset The address of the underlying asset borrowed\n   * @param interestRateMode The current interest rate mode of the position being swapped: 1 for Stable, 2 for Variable\n   */\n  function swapBorrowRateMode(address asset, uint256 interestRateMode) external;\n\n  /**\n   * @notice Rebalances the stable interest rate of a user to the current stable rate defined on the reserve.\n   * - Users can be rebalanced if the following conditions are satisfied:\n   *     1. Usage ratio is above 95%\n   *     2. the current supply APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate, which means that too\n   *        much has been borrowed at a stable rate and suppliers are not earning enough\n   * @param asset The address of the underlying asset borrowed\n   * @param user The address of the user to be rebalanced\n   */\n  function rebalanceStableBorrowRate(address asset, address user) external;\n\n  /**\n   * @notice Allows suppliers to enable/disable a specific supplied asset as collateral\n   * @param asset The address of the underlying asset supplied\n   * @param useAsCollateral True if the user wants to use the supply as collateral, false otherwise\n   */\n  function setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external;\n\n  /**\n   * @notice Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1\n   * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives\n   *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n   * @param user The address of the borrower getting liquidated\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n   * @param receiveAToken True if the liquidators wants to receive the collateral aTokens, `false` if he wants\n   * to receive the underlying collateral asset directly\n   */\n  function liquidationCall(\n    address collateralAsset,\n    address debtAsset,\n    address user,\n    uint256 debtToCover,\n    bool receiveAToken\n  ) external;\n\n  /**\n   * @notice Allows smartcontracts to access the liquidity of the pool within one transaction,\n   * as long as the amount taken plus a fee is returned.\n   * @dev IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept\n   * into consideration. For further details please visit https://docs.aave.com/developers/\n   * @param receiverAddress The address of the contract receiving the funds, implementing IFlashLoanReceiver interface\n   * @param assets The addresses of the assets being flash-borrowed\n   * @param amounts The amounts of the assets being flash-borrowed\n   * @param interestRateModes Types of the debt to open if the flash loan is not returned:\n   *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver\n   *   1 -> Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n   *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n   * @param onBehalfOf The address  that will receive the debt in the case of using on `modes` 1 or 2\n   * @param params Variadic packed params to pass to the receiver as extra information\n   * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   */\n  function flashLoan(\n    address receiverAddress,\n    address[] calldata assets,\n    uint256[] calldata amounts,\n    uint256[] calldata interestRateModes,\n    address onBehalfOf,\n    bytes calldata params,\n    uint16 referralCode\n  ) external;\n\n  /**\n   * @notice Allows smartcontracts to access the liquidity of the pool within one transaction,\n   * as long as the amount taken plus a fee is returned.\n   * @dev IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept\n   * into consideration. For further details please visit https://docs.aave.com/developers/\n   * @param receiverAddress The address of the contract receiving the funds, implementing IFlashLoanSimpleReceiver interface\n   * @param asset The address of the asset being flash-borrowed\n   * @param amount The amount of the asset being flash-borrowed\n   * @param params Variadic packed params to pass to the receiver as extra information\n   * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   */\n  function flashLoanSimple(\n    address receiverAddress,\n    address asset,\n    uint256 amount,\n    bytes calldata params,\n    uint16 referralCode\n  ) external;\n\n  /**\n   * @notice Returns the user account data across all the reserves\n   * @param user The address of the user\n   * @return totalCollateralBase The total collateral of the user in the base currency used by the price feed\n   * @return totalDebtBase The total debt of the user in the base currency used by the price feed\n   * @return availableBorrowsBase The borrowing power left of the user in the base currency used by the price feed\n   * @return currentLiquidationThreshold The liquidation threshold of the user\n   * @return ltv The loan to value of The user\n   * @return healthFactor The current health factor of the user\n   */\n  function getUserAccountData(\n    address user\n  )\n    external\n    view\n    returns (\n      uint256 totalCollateralBase,\n      uint256 totalDebtBase,\n      uint256 availableBorrowsBase,\n      uint256 currentLiquidationThreshold,\n      uint256 ltv,\n      uint256 healthFactor\n    );\n\n  /**\n   * @notice Initializes a reserve, activating it, assigning an aToken and debt tokens and an\n   * interest rate strategy\n   * @dev Only callable by the PoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param aTokenAddress The address of the aToken that will be assigned to the reserve\n   * @param stableDebtAddress The address of the StableDebtToken that will be assigned to the reserve\n   * @param variableDebtAddress The address of the VariableDebtToken that will be assigned to the reserve\n   * @param interestRateStrategyAddress The address of the interest rate strategy contract\n   */\n  function initReserve(\n    address asset,\n    address aTokenAddress,\n    address stableDebtAddress,\n    address variableDebtAddress,\n    address interestRateStrategyAddress\n  ) external;\n\n  /**\n   * @notice Drop a reserve\n   * @dev Only callable by the PoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   */\n  function dropReserve(address asset) external;\n\n  /**\n   * @notice Updates the address of the interest rate strategy contract\n   * @dev Only callable by the PoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param rateStrategyAddress The address of the interest rate strategy contract\n   */\n  function setReserveInterestRateStrategyAddress(\n    address asset,\n    address rateStrategyAddress\n  ) external;\n\n  /**\n   * @notice Sets the configuration bitmap of the reserve as a whole\n   * @dev Only callable by the PoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param configuration The new configuration bitmap\n   */\n  function setConfiguration(\n    address asset,\n    DataTypes.ReserveConfigurationMap calldata configuration\n  ) external;\n\n  /**\n   * @notice Returns the configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The configuration of the reserve\n   */\n  function getConfiguration(\n    address asset\n  ) external view returns (DataTypes.ReserveConfigurationMap memory);\n\n  /**\n   * @notice Returns the configuration of the user across all the reserves\n   * @param user The user address\n   * @return The configuration of the user\n   */\n  function getUserConfiguration(\n    address user\n  ) external view returns (DataTypes.UserConfigurationMap memory);\n\n  /**\n   * @notice Returns the normalized income of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve's normalized income\n   */\n  function getReserveNormalizedIncome(address asset) external view returns (uint256);\n\n  /**\n   * @notice Returns the normalized variable debt per unit of asset\n   * @dev WARNING: This function is intended to be used primarily by the protocol itself to get a\n   * \"dynamic\" variable index based on time, current stored index and virtual rate at the current\n   * moment (approx. a borrower would get if opening a position). This means that is always used in\n   * combination with variable debt supply/balances.\n   * If using this function externally, consider that is possible to have an increasing normalized\n   * variable debt that is not equivalent to how the variable debt index would be updated in storage\n   * (e.g. only updates with non-zero variable debt supply)\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve normalized variable debt\n   */\n  function getReserveNormalizedVariableDebt(address asset) external view returns (uint256);\n\n  /**\n   * @notice Returns the state and configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The state and configuration data of the reserve\n   */\n  function getReserveData(address asset) external view returns (DataTypes.ReserveData memory);\n\n  /**\n   * @notice Validates and finalizes an aToken transfer\n   * @dev Only callable by the overlying aToken of the `asset`\n   * @param asset The address of the underlying asset of the aToken\n   * @param from The user from which the aTokens are transferred\n   * @param to The user receiving the aTokens\n   * @param amount The amount being transferred/withdrawn\n   * @param balanceFromBefore The aToken balance of the `from` user before the transfer\n   * @param balanceToBefore The aToken balance of the `to` user before the transfer\n   */\n  function finalizeTransfer(\n    address asset,\n    address from,\n    address to,\n    uint256 amount,\n    uint256 balanceFromBefore,\n    uint256 balanceToBefore\n  ) external;\n\n  /**\n   * @notice Returns the list of the underlying assets of all the initialized reserves\n   * @dev It does not include dropped reserves\n   * @return The addresses of the underlying assets of the initialized reserves\n   */\n  function getReservesList() external view returns (address[] memory);\n\n  /**\n   * @notice Returns the number of initialized reserves\n   * @dev It includes dropped reserves\n   * @return The count\n   */\n  function getReservesCount() external view returns (uint256);\n\n  /**\n   * @notice Returns the address of the underlying asset of a reserve by the reserve id as stored in the DataTypes.ReserveData struct\n   * @param id The id of the reserve as stored in the DataTypes.ReserveData struct\n   * @return The address of the reserve associated with id\n   */\n  function getReserveAddressById(uint16 id) external view returns (address);\n\n  /**\n   * @notice Returns the PoolAddressesProvider connected to this contract\n   * @return The address of the PoolAddressesProvider\n   */\n  function ADDRESSES_PROVIDER() external view returns (IPoolAddressesProvider);\n\n  /**\n   * @notice Updates the protocol fee on the bridging\n   * @param bridgeProtocolFee The part of the premium sent to the protocol treasury\n   */\n  function updateBridgeProtocolFee(uint256 bridgeProtocolFee) external;\n\n  /**\n   * @notice Updates flash loan premiums. Flash loan premium consists of two parts:\n   * - A part is sent to aToken holders as extra, one time accumulated interest\n   * - A part is collected by the protocol treasury\n   * @dev The total premium is calculated on the total borrowed amount\n   * @dev The premium to protocol is calculated on the total premium, being a percentage of `flashLoanPremiumTotal`\n   * @dev Only callable by the PoolConfigurator contract\n   * @param flashLoanPremiumTotal The total premium, expressed in bps\n   * @param flashLoanPremiumToProtocol The part of the premium sent to the protocol treasury, expressed in bps\n   */\n  function updateFlashloanPremiums(\n    uint128 flashLoanPremiumTotal,\n    uint128 flashLoanPremiumToProtocol\n  ) external;\n\n  /**\n   * @notice Configures a new category for the eMode.\n   * @dev In eMode, the protocol allows very high borrowing power to borrow assets of the same category.\n   * The category 0 is reserved as it's the default for volatile assets\n   * @param id The id of the category\n   * @param config The configuration of the category\n   */\n  function configureEModeCategory(uint8 id, DataTypes.EModeCategory memory config) external;\n\n  /**\n   * @notice Returns the data of an eMode category\n   * @param id The id of the category\n   * @return The configuration data of the category\n   */\n  function getEModeCategoryData(uint8 id) external view returns (DataTypes.EModeCategory memory);\n\n  /**\n   * @notice Allows a user to use the protocol in eMode\n   * @param categoryId The id of the category\n   */\n  function setUserEMode(uint8 categoryId) external;\n\n  /**\n   * @notice Returns the eMode the user is using\n   * @param user The address of the user\n   * @return The eMode id\n   */\n  function getUserEMode(address user) external view returns (uint256);\n\n  /**\n   * @notice Resets the isolation mode total debt of the given asset to zero\n   * @dev It requires the given asset has zero debt ceiling\n   * @param asset The address of the underlying asset to reset the isolationModeTotalDebt\n   */\n  function resetIsolationModeTotalDebt(address asset) external;\n\n  /**\n   * @notice Returns the percentage of available liquidity that can be borrowed at once at stable rate\n   * @return The percentage of available liquidity to borrow, expressed in bps\n   */\n  function MAX_STABLE_RATE_BORROW_SIZE_PERCENT() external view returns (uint256);\n\n  /**\n   * @notice Returns the total fee on flash loans\n   * @return The total fee on flashloans\n   */\n  function FLASHLOAN_PREMIUM_TOTAL() external view returns (uint128);\n\n  /**\n   * @notice Returns the part of the bridge fees sent to protocol\n   * @return The bridge fee sent to the protocol treasury\n   */\n  function BRIDGE_PROTOCOL_FEE() external view returns (uint256);\n\n  /**\n   * @notice Returns the part of the flashloan fees sent to protocol\n   * @return The flashloan fee sent to the protocol treasury\n   */\n  function FLASHLOAN_PREMIUM_TO_PROTOCOL() external view returns (uint128);\n\n  /**\n   * @notice Returns the maximum number of reserves supported to be listed in this Pool\n   * @return The maximum number of reserves supported\n   */\n  function MAX_NUMBER_RESERVES() external view returns (uint16);\n\n  /**\n   * @notice Mints the assets accrued through the reserve factor to the treasury in the form of aTokens\n   * @param assets The list of reserves for which the minting needs to be executed\n   */\n  function mintToTreasury(address[] calldata assets) external;\n\n  /**\n   * @notice Rescue and transfer tokens locked in this contract\n   * @param token The address of the token\n   * @param to The address of the recipient\n   * @param amount The amount of token to transfer\n   */\n  function rescueTokens(address token, address to, uint256 amount) external;\n\n  /**\n   * @notice Supplies an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\n   * - E.g. User supplies 100 USDC and gets in return 100 aUSDC\n   * @dev Deprecated: Use the `supply` function instead\n   * @param asset The address of the underlying asset to supply\n   * @param amount The amount to be supplied\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n   *   is a different wallet\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   */\n  function deposit(address asset, uint256 amount, address onBehalfOf, uint16 referralCode) external;\n}\n"
    },
    "lib/sparklend-v1-core/contracts/interfaces/IPoolConfigurator.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\nimport {ConfiguratorInputTypes} from '../protocol/libraries/types/ConfiguratorInputTypes.sol';\n\n/**\n * @title IPoolConfigurator\n * @author Aave\n * @notice Defines the basic interface for a Pool configurator.\n */\ninterface IPoolConfigurator {\n  /**\n   * @dev Emitted when a reserve is initialized.\n   * @param asset The address of the underlying asset of the reserve\n   * @param aToken The address of the associated aToken contract\n   * @param stableDebtToken The address of the associated stable rate debt token\n   * @param variableDebtToken The address of the associated variable rate debt token\n   * @param interestRateStrategyAddress The address of the interest rate strategy for the reserve\n   */\n  event ReserveInitialized(\n    address indexed asset,\n    address indexed aToken,\n    address stableDebtToken,\n    address variableDebtToken,\n    address interestRateStrategyAddress\n  );\n\n  /**\n   * @dev Emitted when borrowing is enabled or disabled on a reserve.\n   * @param asset The address of the underlying asset of the reserve\n   * @param enabled True if borrowing is enabled, false otherwise\n   */\n  event ReserveBorrowing(address indexed asset, bool enabled);\n\n  /**\n   * @dev Emitted when flashloans are enabled or disabled on a reserve.\n   * @param asset The address of the underlying asset of the reserve\n   * @param enabled True if flashloans are enabled, false otherwise\n   */\n  event ReserveFlashLoaning(address indexed asset, bool enabled);\n\n  /**\n   * @dev Emitted when the collateralization risk parameters for the specified asset are updated.\n   * @param asset The address of the underlying asset of the reserve\n   * @param ltv The loan to value of the asset when used as collateral\n   * @param liquidationThreshold The threshold at which loans using this asset as collateral will be considered undercollateralized\n   * @param liquidationBonus The bonus liquidators receive to liquidate this asset\n   */\n  event CollateralConfigurationChanged(\n    address indexed asset,\n    uint256 ltv,\n    uint256 liquidationThreshold,\n    uint256 liquidationBonus\n  );\n\n  /**\n   * @dev Emitted when stable rate borrowing is enabled or disabled on a reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @param enabled True if stable rate borrowing is enabled, false otherwise\n   */\n  event ReserveStableRateBorrowing(address indexed asset, bool enabled);\n\n  /**\n   * @dev Emitted when a reserve is activated or deactivated\n   * @param asset The address of the underlying asset of the reserve\n   * @param active True if reserve is active, false otherwise\n   */\n  event ReserveActive(address indexed asset, bool active);\n\n  /**\n   * @dev Emitted when a reserve is frozen or unfrozen\n   * @param asset The address of the underlying asset of the reserve\n   * @param frozen True if reserve is frozen, false otherwise\n   */\n  event ReserveFrozen(address indexed asset, bool frozen);\n\n  /**\n   * @dev Emitted when a reserve is paused or unpaused\n   * @param asset The address of the underlying asset of the reserve\n   * @param paused True if reserve is paused, false otherwise\n   */\n  event ReservePaused(address indexed asset, bool paused);\n\n  /**\n   * @dev Emitted when a reserve is dropped.\n   * @param asset The address of the underlying asset of the reserve\n   */\n  event ReserveDropped(address indexed asset);\n\n  /**\n   * @dev Emitted when a reserve factor is updated.\n   * @param asset The address of the underlying asset of the reserve\n   * @param oldReserveFactor The old reserve factor, expressed in bps\n   * @param newReserveFactor The new reserve factor, expressed in bps\n   */\n  event ReserveFactorChanged(\n    address indexed asset,\n    uint256 oldReserveFactor,\n    uint256 newReserveFactor\n  );\n\n  /**\n   * @dev Emitted when the borrow cap of a reserve is updated.\n   * @param asset The address of the underlying asset of the reserve\n   * @param oldBorrowCap The old borrow cap\n   * @param newBorrowCap The new borrow cap\n   */\n  event BorrowCapChanged(address indexed asset, uint256 oldBorrowCap, uint256 newBorrowCap);\n\n  /**\n   * @dev Emitted when the supply cap of a reserve is updated.\n   * @param asset The address of the underlying asset of the reserve\n   * @param oldSupplyCap The old supply cap\n   * @param newSupplyCap The new supply cap\n   */\n  event SupplyCapChanged(address indexed asset, uint256 oldSupplyCap, uint256 newSupplyCap);\n\n  /**\n   * @dev Emitted when the liquidation protocol fee of a reserve is updated.\n   * @param asset The address of the underlying asset of the reserve\n   * @param oldFee The old liquidation protocol fee, expressed in bps\n   * @param newFee The new liquidation protocol fee, expressed in bps\n   */\n  event LiquidationProtocolFeeChanged(address indexed asset, uint256 oldFee, uint256 newFee);\n\n  /**\n   * @dev Emitted when the unbacked mint cap of a reserve is updated.\n   * @param asset The address of the underlying asset of the reserve\n   * @param oldUnbackedMintCap The old unbacked mint cap\n   * @param newUnbackedMintCap The new unbacked mint cap\n   */\n  event UnbackedMintCapChanged(\n    address indexed asset,\n    uint256 oldUnbackedMintCap,\n    uint256 newUnbackedMintCap\n  );\n\n  /**\n   * @dev Emitted when the category of an asset in eMode is changed.\n   * @param asset The address of the underlying asset of the reserve\n   * @param oldCategoryId The old eMode asset category\n   * @param newCategoryId The new eMode asset category\n   */\n  event EModeAssetCategoryChanged(address indexed asset, uint8 oldCategoryId, uint8 newCategoryId);\n\n  /**\n   * @dev Emitted when a new eMode category is added.\n   * @param categoryId The new eMode category id\n   * @param ltv The ltv for the asset category in eMode\n   * @param liquidationThreshold The liquidationThreshold for the asset category in eMode\n   * @param liquidationBonus The liquidationBonus for the asset category in eMode\n   * @param oracle The optional address of the price oracle specific for this category\n   * @param label A human readable identifier for the category\n   */\n  event EModeCategoryAdded(\n    uint8 indexed categoryId,\n    uint256 ltv,\n    uint256 liquidationThreshold,\n    uint256 liquidationBonus,\n    address oracle,\n    string label\n  );\n\n  /**\n   * @dev Emitted when a reserve interest strategy contract is updated.\n   * @param asset The address of the underlying asset of the reserve\n   * @param oldStrategy The address of the old interest strategy contract\n   * @param newStrategy The address of the new interest strategy contract\n   */\n  event ReserveInterestRateStrategyChanged(\n    address indexed asset,\n    address oldStrategy,\n    address newStrategy\n  );\n\n  /**\n   * @dev Emitted when an aToken implementation is upgraded.\n   * @param asset The address of the underlying asset of the reserve\n   * @param proxy The aToken proxy address\n   * @param implementation The new aToken implementation\n   */\n  event ATokenUpgraded(\n    address indexed asset,\n    address indexed proxy,\n    address indexed implementation\n  );\n\n  /**\n   * @dev Emitted when the implementation of a stable debt token is upgraded.\n   * @param asset The address of the underlying asset of the reserve\n   * @param proxy The stable debt token proxy address\n   * @param implementation The new aToken implementation\n   */\n  event StableDebtTokenUpgraded(\n    address indexed asset,\n    address indexed proxy,\n    address indexed implementation\n  );\n\n  /**\n   * @dev Emitted when the implementation of a variable debt token is upgraded.\n   * @param asset The address of the underlying asset of the reserve\n   * @param proxy The variable debt token proxy address\n   * @param implementation The new aToken implementation\n   */\n  event VariableDebtTokenUpgraded(\n    address indexed asset,\n    address indexed proxy,\n    address indexed implementation\n  );\n\n  /**\n   * @dev Emitted when the debt ceiling of an asset is set.\n   * @param asset The address of the underlying asset of the reserve\n   * @param oldDebtCeiling The old debt ceiling\n   * @param newDebtCeiling The new debt ceiling\n   */\n  event DebtCeilingChanged(address indexed asset, uint256 oldDebtCeiling, uint256 newDebtCeiling);\n\n  /**\n   * @dev Emitted when the the siloed borrowing state for an asset is changed.\n   * @param asset The address of the underlying asset of the reserve\n   * @param oldState The old siloed borrowing state\n   * @param newState The new siloed borrowing state\n   */\n  event SiloedBorrowingChanged(address indexed asset, bool oldState, bool newState);\n\n  /**\n   * @dev Emitted when the bridge protocol fee is updated.\n   * @param oldBridgeProtocolFee The old protocol fee, expressed in bps\n   * @param newBridgeProtocolFee The new protocol fee, expressed in bps\n   */\n  event BridgeProtocolFeeUpdated(uint256 oldBridgeProtocolFee, uint256 newBridgeProtocolFee);\n\n  /**\n   * @dev Emitted when the total premium on flashloans is updated.\n   * @param oldFlashloanPremiumTotal The old premium, expressed in bps\n   * @param newFlashloanPremiumTotal The new premium, expressed in bps\n   */\n  event FlashloanPremiumTotalUpdated(\n    uint128 oldFlashloanPremiumTotal,\n    uint128 newFlashloanPremiumTotal\n  );\n\n  /**\n   * @dev Emitted when the part of the premium that goes to protocol is updated.\n   * @param oldFlashloanPremiumToProtocol The old premium, expressed in bps\n   * @param newFlashloanPremiumToProtocol The new premium, expressed in bps\n   */\n  event FlashloanPremiumToProtocolUpdated(\n    uint128 oldFlashloanPremiumToProtocol,\n    uint128 newFlashloanPremiumToProtocol\n  );\n\n  /**\n   * @dev Emitted when the reserve is set as borrowable/non borrowable in isolation mode.\n   * @param asset The address of the underlying asset of the reserve\n   * @param borrowable True if the reserve is borrowable in isolation, false otherwise\n   */\n  event BorrowableInIsolationChanged(address asset, bool borrowable);\n\n  /**\n   * @notice Initializes multiple reserves.\n   * @param input The array of initialization parameters\n   */\n  function initReserves(ConfiguratorInputTypes.InitReserveInput[] calldata input) external;\n\n  /**\n   * @dev Updates the aToken implementation for the reserve.\n   * @param input The aToken update parameters\n   */\n  function updateAToken(ConfiguratorInputTypes.UpdateATokenInput calldata input) external;\n\n  /**\n   * @notice Updates the stable debt token implementation for the reserve.\n   * @param input The stableDebtToken update parameters\n   */\n  function updateStableDebtToken(\n    ConfiguratorInputTypes.UpdateDebtTokenInput calldata input\n  ) external;\n\n  /**\n   * @notice Updates the variable debt token implementation for the asset.\n   * @param input The variableDebtToken update parameters\n   */\n  function updateVariableDebtToken(\n    ConfiguratorInputTypes.UpdateDebtTokenInput calldata input\n  ) external;\n\n  /**\n   * @notice Configures borrowing on a reserve.\n   * @dev Can only be disabled (set to false) if stable borrowing is disabled\n   * @param asset The address of the underlying asset of the reserve\n   * @param enabled True if borrowing needs to be enabled, false otherwise\n   */\n  function setReserveBorrowing(address asset, bool enabled) external;\n\n  /**\n   * @notice Configures the reserve collateralization parameters.\n   * @dev All the values are expressed in bps. A value of 10000, results in 100.00%\n   * @dev The `liquidationBonus` is always above 100%. A value of 105% means the liquidator will receive a 5% bonus\n   * @param asset The address of the underlying asset of the reserve\n   * @param ltv The loan to value of the asset when used as collateral\n   * @param liquidationThreshold The threshold at which loans using this asset as collateral will be considered undercollateralized\n   * @param liquidationBonus The bonus liquidators receive to liquidate this asset\n   */\n  function configureReserveAsCollateral(\n    address asset,\n    uint256 ltv,\n    uint256 liquidationThreshold,\n    uint256 liquidationBonus\n  ) external;\n\n  /**\n   * @notice Enable or disable stable rate borrowing on a reserve.\n   * @dev Can only be enabled (set to true) if borrowing is enabled\n   * @param asset The address of the underlying asset of the reserve\n   * @param enabled True if stable rate borrowing needs to be enabled, false otherwise\n   */\n  function setReserveStableRateBorrowing(address asset, bool enabled) external;\n\n  /**\n   * @notice Enable or disable flashloans on a reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @param enabled True if flashloans need to be enabled, false otherwise\n   */\n  function setReserveFlashLoaning(address asset, bool enabled) external;\n\n  /**\n   * @notice Activate or deactivate a reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @param active True if the reserve needs to be active, false otherwise\n   */\n  function setReserveActive(address asset, bool active) external;\n\n  /**\n   * @notice Freeze or unfreeze a reserve. A frozen reserve doesn't allow any new supply, borrow\n   * or rate swap but allows repayments, liquidations, rate rebalances and withdrawals.\n   * @param asset The address of the underlying asset of the reserve\n   * @param freeze True if the reserve needs to be frozen, false otherwise\n   */\n  function setReserveFreeze(address asset, bool freeze) external;\n\n  /**\n   * @notice Sets the borrowable in isolation flag for the reserve.\n   * @dev When this flag is set to true, the asset will be borrowable against isolated collaterals and the\n   * borrowed amount will be accumulated in the isolated collateral's total debt exposure\n   * @dev Only assets of the same family (e.g. USD stablecoins) should be borrowable in isolation mode to keep\n   * consistency in the debt ceiling calculations\n   * @param asset The address of the underlying asset of the reserve\n   * @param borrowable True if the asset should be borrowable in isolation, false otherwise\n   */\n  function setBorrowableInIsolation(address asset, bool borrowable) external;\n\n  /**\n   * @notice Pauses a reserve. A paused reserve does not allow any interaction (supply, borrow, repay,\n   * swap interest rate, liquidate, atoken transfers).\n   * @param asset The address of the underlying asset of the reserve\n   * @param paused True if pausing the reserve, false if unpausing\n   */\n  function setReservePause(address asset, bool paused) external;\n\n  /**\n   * @notice Updates the reserve factor of a reserve.\n   * @param asset The address of the underlying asset of the reserve\n   * @param newReserveFactor The new reserve factor of the reserve\n   */\n  function setReserveFactor(address asset, uint256 newReserveFactor) external;\n\n  /**\n   * @notice Sets the interest rate strategy of a reserve.\n   * @param asset The address of the underlying asset of the reserve\n   * @param newRateStrategyAddress The address of the new interest strategy contract\n   */\n  function setReserveInterestRateStrategyAddress(\n    address asset,\n    address newRateStrategyAddress\n  ) external;\n\n  /**\n   * @notice Pauses or unpauses all the protocol reserves. In the paused state all the protocol interactions\n   * are suspended.\n   * @param paused True if protocol needs to be paused, false otherwise\n   */\n  function setPoolPause(bool paused) external;\n\n  /**\n   * @notice Updates the borrow cap of a reserve.\n   * @param asset The address of the underlying asset of the reserve\n   * @param newBorrowCap The new borrow cap of the reserve\n   */\n  function setBorrowCap(address asset, uint256 newBorrowCap) external;\n\n  /**\n   * @notice Updates the supply cap of a reserve.\n   * @param asset The address of the underlying asset of the reserve\n   * @param newSupplyCap The new supply cap of the reserve\n   */\n  function setSupplyCap(address asset, uint256 newSupplyCap) external;\n\n  /**\n   * @notice Updates the liquidation protocol fee of reserve.\n   * @param asset The address of the underlying asset of the reserve\n   * @param newFee The new liquidation protocol fee of the reserve, expressed in bps\n   */\n  function setLiquidationProtocolFee(address asset, uint256 newFee) external;\n\n  /**\n   * @notice Updates the unbacked mint cap of reserve.\n   * @param asset The address of the underlying asset of the reserve\n   * @param newUnbackedMintCap The new unbacked mint cap of the reserve\n   */\n  function setUnbackedMintCap(address asset, uint256 newUnbackedMintCap) external;\n\n  /**\n   * @notice Assign an efficiency mode (eMode) category to asset.\n   * @param asset The address of the underlying asset of the reserve\n   * @param newCategoryId The new category id of the asset\n   */\n  function setAssetEModeCategory(address asset, uint8 newCategoryId) external;\n\n  /**\n   * @notice Adds a new efficiency mode (eMode) category.\n   * @dev If zero is provided as oracle address, the default asset oracles will be used to compute the overall debt and\n   * overcollateralization of the users using this category.\n   * @dev The new ltv and liquidation threshold must be greater than the base\n   * ltvs and liquidation thresholds of all assets within the eMode category\n   * @param categoryId The id of the category to be configured\n   * @param ltv The ltv associated with the category\n   * @param liquidationThreshold The liquidation threshold associated with the category\n   * @param liquidationBonus The liquidation bonus associated with the category\n   * @param oracle The oracle associated with the category\n   * @param label A label identifying the category\n   */\n  function setEModeCategory(\n    uint8 categoryId,\n    uint16 ltv,\n    uint16 liquidationThreshold,\n    uint16 liquidationBonus,\n    address oracle,\n    string calldata label\n  ) external;\n\n  /**\n   * @notice Drops a reserve entirely.\n   * @param asset The address of the reserve to drop\n   */\n  function dropReserve(address asset) external;\n\n  /**\n   * @notice Updates the bridge fee collected by the protocol reserves.\n   * @param newBridgeProtocolFee The part of the fee sent to the protocol treasury, expressed in bps\n   */\n  function updateBridgeProtocolFee(uint256 newBridgeProtocolFee) external;\n\n  /**\n   * @notice Updates the total flash loan premium.\n   * Total flash loan premium consists of two parts:\n   * - A part is sent to aToken holders as extra balance\n   * - A part is collected by the protocol reserves\n   * @dev Expressed in bps\n   * @dev The premium is calculated on the total amount borrowed\n   * @param newFlashloanPremiumTotal The total flashloan premium\n   */\n  function updateFlashloanPremiumTotal(uint128 newFlashloanPremiumTotal) external;\n\n  /**\n   * @notice Updates the flash loan premium collected by protocol reserves\n   * @dev Expressed in bps\n   * @dev The premium to protocol is calculated on the total flashloan premium\n   * @param newFlashloanPremiumToProtocol The part of the flashloan premium sent to the protocol treasury\n   */\n  function updateFlashloanPremiumToProtocol(uint128 newFlashloanPremiumToProtocol) external;\n\n  /**\n   * @notice Sets the debt ceiling for an asset.\n   * @param newDebtCeiling The new debt ceiling\n   */\n  function setDebtCeiling(address asset, uint256 newDebtCeiling) external;\n\n  /**\n   * @notice Sets siloed borrowing for an asset\n   * @param siloed The new siloed borrowing state\n   */\n  function setSiloedBorrowing(address asset, bool siloed) external;\n}\n"
    },
    "lib/sparklend-v1-core/contracts/interfaces/IAaveOracle.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\nimport {IPriceOracleGetter} from './IPriceOracleGetter.sol';\nimport {IPoolAddressesProvider} from './IPoolAddressesProvider.sol';\n\n/**\n * @title IAaveOracle\n * @author Aave\n * @notice Defines the basic interface for the Aave Oracle\n */\ninterface IAaveOracle is IPriceOracleGetter {\n  /**\n   * @dev Emitted after the base currency is set\n   * @param baseCurrency The base currency of used for price quotes\n   * @param baseCurrencyUnit The unit of the base currency\n   */\n  event BaseCurrencySet(address indexed baseCurrency, uint256 baseCurrencyUnit);\n\n  /**\n   * @dev Emitted after the price source of an asset is updated\n   * @param asset The address of the asset\n   * @param source The price source of the asset\n   */\n  event AssetSourceUpdated(address indexed asset, address indexed source);\n\n  /**\n   * @dev Emitted after the address of fallback oracle is updated\n   * @param fallbackOracle The address of the fallback oracle\n   */\n  event FallbackOracleUpdated(address indexed fallbackOracle);\n\n  /**\n   * @notice Returns the PoolAddressesProvider\n   * @return The address of the PoolAddressesProvider contract\n   */\n  function ADDRESSES_PROVIDER() external view returns (IPoolAddressesProvider);\n\n  /**\n   * @notice Sets or replaces price sources of assets\n   * @param assets The addresses of the assets\n   * @param sources The addresses of the price sources\n   */\n  function setAssetSources(address[] calldata assets, address[] calldata sources) external;\n\n  /**\n   * @notice Sets the fallback oracle\n   * @param fallbackOracle The address of the fallback oracle\n   */\n  function setFallbackOracle(address fallbackOracle) external;\n\n  /**\n   * @notice Returns a list of prices from a list of assets addresses\n   * @param assets The list of assets addresses\n   * @return The prices of the given assets\n   */\n  function getAssetsPrices(address[] calldata assets) external view returns (uint256[] memory);\n\n  /**\n   * @notice Returns the address of the source for an asset address\n   * @param asset The address of the asset\n   * @return The address of the source\n   */\n  function getSourceOfAsset(address asset) external view returns (address);\n\n  /**\n   * @notice Returns the address of the fallback oracle\n   * @return The address of the fallback oracle\n   */\n  function getFallbackOracle() external view returns (address);\n}\n"
    },
    "lib/sparklend-v1-core/contracts/interfaces/IPoolAddressesProvider.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\n/**\n * @title IPoolAddressesProvider\n * @author Aave\n * @notice Defines the basic interface for a Pool Addresses Provider.\n */\ninterface IPoolAddressesProvider {\n  /**\n   * @dev Emitted when the market identifier is updated.\n   * @param oldMarketId The old id of the market\n   * @param newMarketId The new id of the market\n   */\n  event MarketIdSet(string indexed oldMarketId, string indexed newMarketId);\n\n  /**\n   * @dev Emitted when the pool is updated.\n   * @param oldAddress The old address of the Pool\n   * @param newAddress The new address of the Pool\n   */\n  event PoolUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the pool configurator is updated.\n   * @param oldAddress The old address of the PoolConfigurator\n   * @param newAddress The new address of the PoolConfigurator\n   */\n  event PoolConfiguratorUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the price oracle is updated.\n   * @param oldAddress The old address of the PriceOracle\n   * @param newAddress The new address of the PriceOracle\n   */\n  event PriceOracleUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the ACL manager is updated.\n   * @param oldAddress The old address of the ACLManager\n   * @param newAddress The new address of the ACLManager\n   */\n  event ACLManagerUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the ACL admin is updated.\n   * @param oldAddress The old address of the ACLAdmin\n   * @param newAddress The new address of the ACLAdmin\n   */\n  event ACLAdminUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the price oracle sentinel is updated.\n   * @param oldAddress The old address of the PriceOracleSentinel\n   * @param newAddress The new address of the PriceOracleSentinel\n   */\n  event PriceOracleSentinelUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the pool data provider is updated.\n   * @param oldAddress The old address of the PoolDataProvider\n   * @param newAddress The new address of the PoolDataProvider\n   */\n  event PoolDataProviderUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when a new proxy is created.\n   * @param id The identifier of the proxy\n   * @param proxyAddress The address of the created proxy contract\n   * @param implementationAddress The address of the implementation contract\n   */\n  event ProxyCreated(\n    bytes32 indexed id,\n    address indexed proxyAddress,\n    address indexed implementationAddress\n  );\n\n  /**\n   * @dev Emitted when a new non-proxied contract address is registered.\n   * @param id The identifier of the contract\n   * @param oldAddress The address of the old contract\n   * @param newAddress The address of the new contract\n   */\n  event AddressSet(bytes32 indexed id, address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the implementation of the proxy registered with id is updated\n   * @param id The identifier of the contract\n   * @param proxyAddress The address of the proxy contract\n   * @param oldImplementationAddress The address of the old implementation contract\n   * @param newImplementationAddress The address of the new implementation contract\n   */\n  event AddressSetAsProxy(\n    bytes32 indexed id,\n    address indexed proxyAddress,\n    address oldImplementationAddress,\n    address indexed newImplementationAddress\n  );\n\n  /**\n   * @notice Returns the id of the Aave market to which this contract points to.\n   * @return The market id\n   */\n  function getMarketId() external view returns (string memory);\n\n  /**\n   * @notice Associates an id with a specific PoolAddressesProvider.\n   * @dev This can be used to create an onchain registry of PoolAddressesProviders to\n   * identify and validate multiple Aave markets.\n   * @param newMarketId The market id\n   */\n  function setMarketId(string calldata newMarketId) external;\n\n  /**\n   * @notice Returns an address by its identifier.\n   * @dev The returned address might be an EOA or a contract, potentially proxied\n   * @dev It returns ZERO if there is no registered address with the given id\n   * @param id The id\n   * @return The address of the registered for the specified id\n   */\n  function getAddress(bytes32 id) external view returns (address);\n\n  /**\n   * @notice General function to update the implementation of a proxy registered with\n   * certain `id`. If there is no proxy registered, it will instantiate one and\n   * set as implementation the `newImplementationAddress`.\n   * @dev IMPORTANT Use this function carefully, only for ids that don't have an explicit\n   * setter function, in order to avoid unexpected consequences\n   * @param id The id\n   * @param newImplementationAddress The address of the new implementation\n   */\n  function setAddressAsProxy(bytes32 id, address newImplementationAddress) external;\n\n  /**\n   * @notice Sets an address for an id replacing the address saved in the addresses map.\n   * @dev IMPORTANT Use this function carefully, as it will do a hard replacement\n   * @param id The id\n   * @param newAddress The address to set\n   */\n  function setAddress(bytes32 id, address newAddress) external;\n\n  /**\n   * @notice Returns the address of the Pool proxy.\n   * @return The Pool proxy address\n   */\n  function getPool() external view returns (address);\n\n  /**\n   * @notice Updates the implementation of the Pool, or creates a proxy\n   * setting the new `pool` implementation when the function is called for the first time.\n   * @param newPoolImpl The new Pool implementation\n   */\n  function setPoolImpl(address newPoolImpl) external;\n\n  /**\n   * @notice Returns the address of the PoolConfigurator proxy.\n   * @return The PoolConfigurator proxy address\n   */\n  function getPoolConfigurator() external view returns (address);\n\n  /**\n   * @notice Updates the implementation of the PoolConfigurator, or creates a proxy\n   * setting the new `PoolConfigurator` implementation when the function is called for the first time.\n   * @param newPoolConfiguratorImpl The new PoolConfigurator implementation\n   */\n  function setPoolConfiguratorImpl(address newPoolConfiguratorImpl) external;\n\n  /**\n   * @notice Returns the address of the price oracle.\n   * @return The address of the PriceOracle\n   */\n  function getPriceOracle() external view returns (address);\n\n  /**\n   * @notice Updates the address of the price oracle.\n   * @param newPriceOracle The address of the new PriceOracle\n   */\n  function setPriceOracle(address newPriceOracle) external;\n\n  /**\n   * @notice Returns the address of the ACL manager.\n   * @return The address of the ACLManager\n   */\n  function getACLManager() external view returns (address);\n\n  /**\n   * @notice Updates the address of the ACL manager.\n   * @param newAclManager The address of the new ACLManager\n   */\n  function setACLManager(address newAclManager) external;\n\n  /**\n   * @notice Returns the address of the ACL admin.\n   * @return The address of the ACL admin\n   */\n  function getACLAdmin() external view returns (address);\n\n  /**\n   * @notice Updates the address of the ACL admin.\n   * @param newAclAdmin The address of the new ACL admin\n   */\n  function setACLAdmin(address newAclAdmin) external;\n\n  /**\n   * @notice Returns the address of the price oracle sentinel.\n   * @return The address of the PriceOracleSentinel\n   */\n  function getPriceOracleSentinel() external view returns (address);\n\n  /**\n   * @notice Updates the address of the price oracle sentinel.\n   * @param newPriceOracleSentinel The address of the new PriceOracleSentinel\n   */\n  function setPriceOracleSentinel(address newPriceOracleSentinel) external;\n\n  /**\n   * @notice Returns the address of the data provider.\n   * @return The address of the DataProvider\n   */\n  function getPoolDataProvider() external view returns (address);\n\n  /**\n   * @notice Updates the address of the data provider.\n   * @param newDataProvider The address of the new DataProvider\n   */\n  function setPoolDataProvider(address newDataProvider) external;\n}\n"
    },
    "lib/sparklend-v1-core/contracts/interfaces/IDefaultInterestRateStrategy.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\nimport {IReserveInterestRateStrategy} from './IReserveInterestRateStrategy.sol';\nimport {IPoolAddressesProvider} from './IPoolAddressesProvider.sol';\n\n/**\n * @title IDefaultInterestRateStrategy\n * @author Aave\n * @notice Defines the basic interface of the DefaultReserveInterestRateStrategy\n */\ninterface IDefaultInterestRateStrategy is IReserveInterestRateStrategy {\n  /**\n   * @notice Returns the usage ratio at which the pool aims to obtain most competitive borrow rates.\n   * @return The optimal usage ratio, expressed in ray.\n   */\n  function OPTIMAL_USAGE_RATIO() external view returns (uint256);\n\n  /**\n   * @notice Returns the optimal stable to total debt ratio of the reserve.\n   * @return The optimal stable to total debt ratio, expressed in ray.\n   */\n  function OPTIMAL_STABLE_TO_TOTAL_DEBT_RATIO() external view returns (uint256);\n\n  /**\n   * @notice Returns the excess usage ratio above the optimal.\n   * @dev It's always equal to 1-optimal usage ratio (added as constant for gas optimizations)\n   * @return The max excess usage ratio, expressed in ray.\n   */\n  function MAX_EXCESS_USAGE_RATIO() external view returns (uint256);\n\n  /**\n   * @notice Returns the excess stable debt ratio above the optimal.\n   * @dev It's always equal to 1-optimal stable to total debt ratio (added as constant for gas optimizations)\n   * @return The max excess stable to total debt ratio, expressed in ray.\n   */\n  function MAX_EXCESS_STABLE_TO_TOTAL_DEBT_RATIO() external view returns (uint256);\n\n  /**\n   * @notice Returns the address of the PoolAddressesProvider\n   * @return The address of the PoolAddressesProvider contract\n   */\n  function ADDRESSES_PROVIDER() external view returns (IPoolAddressesProvider);\n\n  /**\n   * @notice Returns the variable rate slope below optimal usage ratio\n   * @dev It's the variable rate when usage ratio > 0 and <= OPTIMAL_USAGE_RATIO\n   * @return The variable rate slope, expressed in ray\n   */\n  function getVariableRateSlope1() external view returns (uint256);\n\n  /**\n   * @notice Returns the variable rate slope above optimal usage ratio\n   * @dev It's the variable rate when usage ratio > OPTIMAL_USAGE_RATIO\n   * @return The variable rate slope, expressed in ray\n   */\n  function getVariableRateSlope2() external view returns (uint256);\n\n  /**\n   * @notice Returns the stable rate slope below optimal usage ratio\n   * @dev It's the stable rate when usage ratio > 0 and <= OPTIMAL_USAGE_RATIO\n   * @return The stable rate slope, expressed in ray\n   */\n  function getStableRateSlope1() external view returns (uint256);\n\n  /**\n   * @notice Returns the stable rate slope above optimal usage ratio\n   * @dev It's the variable rate when usage ratio > OPTIMAL_USAGE_RATIO\n   * @return The stable rate slope, expressed in ray\n   */\n  function getStableRateSlope2() external view returns (uint256);\n\n  /**\n   * @notice Returns the stable rate excess offset\n   * @dev It's an additional premium applied to the stable when stable debt > OPTIMAL_STABLE_TO_TOTAL_DEBT_RATIO\n   * @return The stable rate excess offset, expressed in ray\n   */\n  function getStableRateExcessOffset() external view returns (uint256);\n\n  /**\n   * @notice Returns the base stable borrow rate\n   * @return The base stable borrow rate, expressed in ray\n   */\n  function getBaseStableBorrowRate() external view returns (uint256);\n\n  /**\n   * @notice Returns the base variable borrow rate\n   * @return The base variable borrow rate, expressed in ray\n   */\n  function getBaseVariableBorrowRate() external view returns (uint256);\n\n  /**\n   * @notice Returns the maximum variable borrow rate\n   * @return The maximum variable borrow rate, expressed in ray\n   */\n  function getMaxVariableBorrowRate() external view returns (uint256);\n}\n"
    },
    "lib/spark-alm-controller/lib/aave-v3-origin/src/core/contracts/dependencies/openzeppelin/contracts/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n  /**\n   * @dev Returns the amount of tokens in existence.\n   */\n  function totalSupply() external view returns (uint256);\n\n  /**\n   * @dev Returns the amount of tokens owned by `account`.\n   */\n  function balanceOf(address account) external view returns (uint256);\n\n  /**\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transfer(address recipient, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Returns the remaining number of tokens that `spender` will be\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\n   * zero by default.\n   *\n   * This value changes when {approve} or {transferFrom} are called.\n   */\n  function allowance(address owner, address spender) external view returns (uint256);\n\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\n   * that someone may use both the old and the new allowance by unfortunate\n   * transaction ordering. One possible solution to mitigate this race\n   * condition is to first reduce the spender's allowance to 0 and set the\n   * desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   *\n   * Emits an {Approval} event.\n   */\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\n   * allowance mechanism. `amount` is then deducted from the caller's\n   * allowance.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\n   * another (`to`).\n   *\n   * Note that `value` may be zero.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  /**\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n   * a call to {approve}. `value` is the new allowance.\n   */\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "lib/spark-alm-controller/lib/aave-v3-origin/src/core/contracts/interfaces/IScaledBalanceToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title IScaledBalanceToken\n * @author Aave\n * @notice Defines the basic interface for a scaled-balance token.\n */\ninterface IScaledBalanceToken {\n  /**\n   * @dev Emitted after the mint action\n   * @param caller The address performing the mint\n   * @param onBehalfOf The address of the user that will receive the minted tokens\n   * @param value The scaled-up amount being minted (based on user entered amount and balance increase from interest)\n   * @param balanceIncrease The increase in scaled-up balance since the last action of 'onBehalfOf'\n   * @param index The next liquidity index of the reserve\n   */\n  event Mint(\n    address indexed caller,\n    address indexed onBehalfOf,\n    uint256 value,\n    uint256 balanceIncrease,\n    uint256 index\n  );\n\n  /**\n   * @dev Emitted after the burn action\n   * @dev If the burn function does not involve a transfer of the underlying asset, the target defaults to zero address\n   * @param from The address from which the tokens will be burned\n   * @param target The address that will receive the underlying, if any\n   * @param value The scaled-up amount being burned (user entered amount - balance increase from interest)\n   * @param balanceIncrease The increase in scaled-up balance since the last action of 'from'\n   * @param index The next liquidity index of the reserve\n   */\n  event Burn(\n    address indexed from,\n    address indexed target,\n    uint256 value,\n    uint256 balanceIncrease,\n    uint256 index\n  );\n\n  /**\n   * @notice Returns the scaled balance of the user.\n   * @dev The scaled balance is the sum of all the updated stored balance divided by the reserve's liquidity index\n   * at the moment of the update\n   * @param user The user whose balance is calculated\n   * @return The scaled balance of the user\n   */\n  function scaledBalanceOf(address user) external view returns (uint256);\n\n  /**\n   * @notice Returns the scaled balance of the user and the scaled total supply.\n   * @param user The address of the user\n   * @return The scaled balance of the user\n   * @return The scaled total supply\n   */\n  function getScaledUserBalanceAndSupply(address user) external view returns (uint256, uint256);\n\n  /**\n   * @notice Returns the scaled total supply of the scaled balance token. Represents sum(debt/index)\n   * @return The scaled total supply\n   */\n  function scaledTotalSupply() external view returns (uint256);\n\n  /**\n   * @notice Returns last index interest was accrued to the user's balance\n   * @param user The address of the user\n   * @return The last index interest was accrued to the user's balance, expressed in ray\n   */\n  function getPreviousIndex(address user) external view returns (uint256);\n}\n"
    },
    "lib/spark-alm-controller/lib/aave-v3-origin/src/core/contracts/interfaces/IInitializableAToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IAaveIncentivesController} from './IAaveIncentivesController.sol';\nimport {IPool} from './IPool.sol';\n\n/**\n * @title IInitializableAToken\n * @author Aave\n * @notice Interface for the initialize function on AToken\n */\ninterface IInitializableAToken {\n  /**\n   * @dev Emitted when an aToken is initialized\n   * @param underlyingAsset The address of the underlying asset\n   * @param pool The address of the associated pool\n   * @param treasury The address of the treasury\n   * @param incentivesController The address of the incentives controller for this aToken\n   * @param aTokenDecimals The decimals of the underlying\n   * @param aTokenName The name of the aToken\n   * @param aTokenSymbol The symbol of the aToken\n   * @param params A set of encoded parameters for additional initialization\n   */\n  event Initialized(\n    address indexed underlyingAsset,\n    address indexed pool,\n    address treasury,\n    address incentivesController,\n    uint8 aTokenDecimals,\n    string aTokenName,\n    string aTokenSymbol,\n    bytes params\n  );\n\n  /**\n   * @notice Initializes the aToken\n   * @param pool The pool contract that is initializing this contract\n   * @param treasury The address of the Aave treasury, receiving the fees on this aToken\n   * @param underlyingAsset The address of the underlying asset of this aToken (E.g. WETH for aWETH)\n   * @param incentivesController The smart contract managing potential incentives distribution\n   * @param aTokenDecimals The decimals of the aToken, same as the underlying asset's\n   * @param aTokenName The name of the aToken\n   * @param aTokenSymbol The symbol of the aToken\n   * @param params A set of encoded parameters for additional initialization\n   */\n  function initialize(\n    IPool pool,\n    address treasury,\n    address underlyingAsset,\n    IAaveIncentivesController incentivesController,\n    uint8 aTokenDecimals,\n    string calldata aTokenName,\n    string calldata aTokenSymbol,\n    bytes calldata params\n  ) external;\n}\n"
    },
    "lib/metamorpho/lib/openzeppelin-contracts/contracts/interfaces/IERC4626.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC4626.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../token/ERC20/IERC20.sol\";\nimport {IERC20Metadata} from \"../token/ERC20/extensions/IERC20Metadata.sol\";\n\n/**\n * @dev Interface of the ERC4626 \"Tokenized Vault Standard\", as defined in\n * https://eips.ethereum.org/EIPS/eip-4626[ERC-4626].\n */\ninterface IERC4626 is IERC20, IERC20Metadata {\n    event Deposit(address indexed sender, address indexed owner, uint256 assets, uint256 shares);\n\n    event Withdraw(\n        address indexed sender,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /**\n     * @dev Returns the address of the underlying token used for the Vault for accounting, depositing, and withdrawing.\n     *\n     * - MUST be an ERC-20 token contract.\n     * - MUST NOT revert.\n     */\n    function asset() external view returns (address assetTokenAddress);\n\n    /**\n     * @dev Returns the total amount of the underlying asset that is managed by Vault.\n     *\n     * - SHOULD include any compounding that occurs from yield.\n     * - MUST be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT revert.\n     */\n    function totalAssets() external view returns (uint256 totalManagedAssets);\n\n    /**\n     * @dev Returns the amount of shares that the Vault would exchange for the amount of assets provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert.\n     *\n     * NOTE: This calculation MAY NOT reflect the per-user price-per-share, and instead should reflect the\n     * average-users price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n    function convertToShares(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Returns the amount of assets that the Vault would exchange for the amount of shares provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert.\n     *\n     * NOTE: This calculation MAY NOT reflect the per-user price-per-share, and instead should reflect the\n     * average-users price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n    function convertToAssets(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Returns the maximum amount of the underlying asset that can be deposited into the Vault for the receiver,\n     * through a deposit call.\n     *\n     * - MUST return a limited value if receiver is subject to some deposit limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of assets that may be deposited.\n     * - MUST NOT revert.\n     */\n    function maxDeposit(address receiver) external view returns (uint256 maxAssets);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their deposit at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of Vault shares that would be minted in a deposit\n     *   call in the same transaction. I.e. deposit should return the same or more shares as previewDeposit if called\n     *   in the same transaction.\n     * - MUST NOT account for deposit limits like those returned from maxDeposit and should always act as though the\n     *   deposit would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewDeposit SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n    function previewDeposit(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Mints shares Vault shares to receiver by depositing exactly amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   deposit execution, and are accounted for during deposit.\n     * - MUST revert if all of assets cannot be deposited (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vaults underlying asset token.\n     */\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\n\n    /**\n     * @dev Returns the maximum amount of the Vault shares that can be minted for the receiver, through a mint call.\n     * - MUST return a limited value if receiver is subject to some mint limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of shares that may be minted.\n     * - MUST NOT revert.\n     */\n    function maxMint(address receiver) external view returns (uint256 maxShares);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their mint at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of assets that would be deposited in a mint call\n     *   in the same transaction. I.e. mint should return the same or fewer assets as previewMint if called in the\n     *   same transaction.\n     * - MUST NOT account for mint limits like those returned from maxMint and should always act as though the mint\n     *   would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewMint SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by minting.\n     */\n    function previewMint(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the mint\n     *   execution, and are accounted for during mint.\n     * - MUST revert if all of shares cannot be minted (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vaults underlying asset token.\n     */\n    function mint(uint256 shares, address receiver) external returns (uint256 assets);\n\n    /**\n     * @dev Returns the maximum amount of the underlying asset that can be withdrawn from the owner balance in the\n     * Vault, through a withdraw call.\n     *\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n    function maxWithdraw(address owner) external view returns (uint256 maxAssets);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their withdrawal at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of Vault shares that would be burned in a withdraw\n     *   call in the same transaction. I.e. withdraw should return the same or fewer shares as previewWithdraw if\n     *   called\n     *   in the same transaction.\n     * - MUST NOT account for withdrawal limits like those returned from maxWithdraw and should always act as though\n     *   the withdrawal would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewWithdraw SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n    function previewWithdraw(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Burns shares from owner and sends exactly assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   withdraw execution, and are accounted for during withdraw.\n     * - MUST revert if all of assets cannot be withdrawn (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * Note that some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n    function withdraw(uint256 assets, address receiver, address owner) external returns (uint256 shares);\n\n    /**\n     * @dev Returns the maximum amount of Vault shares that can be redeemed from the owner balance in the Vault,\n     * through a redeem call.\n     *\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST return balanceOf(owner) if owner is not subject to any withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n    function maxRedeem(address owner) external view returns (uint256 maxShares);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their redeemption at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of assets that would be withdrawn in a redeem call\n     *   in the same transaction. I.e. redeem should return the same or more assets as previewRedeem if called in the\n     *   same transaction.\n     * - MUST NOT account for redemption limits like those returned from maxRedeem and should always act as though the\n     *   redemption would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewRedeem SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by redeeming.\n     */\n    function previewRedeem(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Burns exactly shares from owner and sends assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   redeem execution, and are accounted for during redeem.\n     * - MUST revert if all of shares cannot be redeemed (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * NOTE: some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n    function redeem(uint256 shares, address receiver, address owner) external returns (uint256 assets);\n}\n"
    },
    "lib/metamorpho/lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "lib/metamorpho/src/libraries/PendingLib.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\nstruct MarketConfig {\n    /// @notice The maximum amount of assets that can be allocated to the market.\n    uint184 cap;\n    /// @notice Whether the market is in the withdraw queue.\n    bool enabled;\n    /// @notice The timestamp at which the market can be instantly removed from the withdraw queue.\n    uint64 removableAt;\n}\n\nstruct PendingUint192 {\n    /// @notice The pending value to set.\n    uint192 value;\n    /// @notice The timestamp at which the pending value becomes valid.\n    uint64 validAt;\n}\n\nstruct PendingAddress {\n    /// @notice The pending value to set.\n    address value;\n    /// @notice The timestamp at which the pending value becomes valid.\n    uint64 validAt;\n}\n\n/// @title PendingLib\n/// @author Morpho Labs\n/// @custom:contact security@morpho.org\n/// @notice Library to manage pending values and their validity timestamp.\nlibrary PendingLib {\n    /// @dev Updates `pending`'s value to `newValue` and its corresponding `validAt` timestamp.\n    /// @dev Assumes `timelock` <= `MAX_TIMELOCK`.\n    function update(PendingUint192 storage pending, uint184 newValue, uint256 timelock) internal {\n        pending.value = newValue;\n        // Safe \"unchecked\" cast because timelock <= MAX_TIMELOCK.\n        pending.validAt = uint64(block.timestamp + timelock);\n    }\n\n    /// @dev Updates `pending`'s value to `newValue` and its corresponding `validAt` timestamp.\n    /// @dev Assumes `timelock` <= `MAX_TIMELOCK`.\n    function update(PendingAddress storage pending, address newValue, uint256 timelock) internal {\n        pending.value = newValue;\n        // Safe \"unchecked\" cast because timelock <= MAX_TIMELOCK.\n        pending.validAt = uint64(block.timestamp + timelock);\n    }\n}\n"
    },
    "lib/spark-alm-controller/src/interfaces/IALMProxy.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity >=0.8.0;\n\nimport { IAccessControl } from \"openzeppelin-contracts/contracts/access/IAccessControl.sol\";\n\ninterface IALMProxy is IAccessControl {\n\n    /**\n     * @dev    This function retrieves a constant `bytes32` value that represents the controller.\n     * @return The `bytes32` identifier of the controller.\n     */\n    function CONTROLLER() external view returns (bytes32);\n\n    /**\n     * @dev    Performs a standard call to the specified `target` with the given `data`.\n     *         Reverts if the call fails.\n     * @param  target The address of the target contract to call.\n     * @param  data   The calldata that will be sent to the target contract.\n     * @return result The returned data from the call.\n     */\n    function doCall(address target, bytes calldata data)\n        external returns (bytes memory result);\n\n    /**\n     * @dev    This function allows for transferring `value` (ether) along with the call to the target contract.\n     *         Reverts if the call fails.\n     * @param  target The address of the target contract to call.\n     * @param  data   The calldata that will be sent to the target contract.\n     * @param  value  The amount of Ether (in wei) to send with the call.\n     * @return result The returned data from the call.\n     */\n    function doCallWithValue(address target, bytes memory data, uint256 value)\n        external payable returns (bytes memory result);\n\n    /**\n     * @dev    This function performs a delegate call to the specified `target`\n     *         with the given `data`. Reverts if the call fails.\n     * @param  target The address of the target contract to delegate call.\n     * @param  data   The calldata that will be sent to the target contract.\n     * @return result The returned data from the delegate call.\n     */\n    function doDelegateCall(address target, bytes calldata data)\n        external returns (bytes memory result);\n\n}\n"
    },
    "lib/spark-alm-controller/src/interfaces/IRateLimits.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity >=0.8.0;\n\nimport { IAccessControl } from \"openzeppelin-contracts/contracts/access/IAccessControl.sol\";\n\ninterface IRateLimits is IAccessControl {\n\n    /**********************************************************************************************/\n    /*** Structs                                                                                ***/\n    /**********************************************************************************************/\n\n    /**\n     * @dev   Struct representing a rate limit.\n     *        The current rate limit is calculated using the formula:\n     *        `currentRateLimit = min(slope * (block.timestamp - lastUpdated) + lastAmount, maxAmount)`.\n     * @param maxAmount   Maximum allowed amount at any time.\n     * @param slope       The slope of the rate limit, used to calculate the new\n     *                    limit based on time passed. [tokens / second]\n     * @param lastAmount  The amount left available at the last update.\n     * @param lastUpdated The timestamp when the rate limit was last updated.\n     */\n    struct RateLimitData {\n        uint256 maxAmount;\n        uint256 slope;\n        uint256 lastAmount;\n        uint256 lastUpdated;\n    }\n\n    /**********************************************************************************************/\n    /*** Events                                                                                 ***/\n    /**********************************************************************************************/\n\n    /**\n     * @dev   Emitted when the rate limit data is set.\n     * @param key         The identifier for the rate limit.\n     * @param maxAmount   The maximum allowed amount for the rate limit.\n     * @param slope       The slope value used in the rate limit calculation.\n     * @param lastAmount  The amount left available at the last update.\n     * @param lastUpdated The timestamp when the rate limit was last updated.\n     */\n    event RateLimitDataSet(\n        bytes32 indexed key,\n        uint256 maxAmount,\n        uint256 slope,\n        uint256 lastAmount,\n        uint256 lastUpdated\n    );\n\n    /**\n     * @dev   Emitted when a rate limit decrease is triggered.\n     * @param key              The identifier for the rate limit.\n     * @param amountToDecrease The amount to decrease from the current rate limit.\n     * @param oldRateLimit     The previous rate limit value before triggering.\n     * @param newRateLimit     The new rate limit value after triggering.\n     */\n    event RateLimitDecreaseTriggered(\n        bytes32 indexed key,\n        uint256 amountToDecrease,\n        uint256 oldRateLimit,\n        uint256 newRateLimit\n    );\n\n    /**\n     * @dev   Emitted when a rate limit increase is triggered.\n     * @param key              The identifier for the rate limit.\n     * @param amountToIncrease The amount to increase from the current rate limit.\n     * @param oldRateLimit     The previous rate limit value before triggering.\n     * @param newRateLimit     The new rate limit value after triggering.\n     */\n    event RateLimitIncreaseTriggered(\n        bytes32 indexed key,\n        uint256 amountToIncrease,\n        uint256 oldRateLimit,\n        uint256 newRateLimit\n    );\n\n    /**********************************************************************************************/\n    /*** State variables                                                                        ***/\n    /**********************************************************************************************/\n\n    /**\n     * @dev    Returns the controller identifier as a bytes32 value.\n     * @return The controller identifier.\n     */\n    function CONTROLLER() external view returns (bytes32);\n\n    /**********************************************************************************************/\n    /*** Admin functions                                                                        ***/\n    /**********************************************************************************************/\n\n    /**\n     * @dev   Sets rate limit data for a specific key.\n     * @param key         The identifier for the rate limit.\n     * @param maxAmount   The maximum allowed amount for the rate limit.\n     * @param slope       The slope value used in the rate limit calculation.\n     * @param lastAmount  The amount left available at the last update.\n     * @param lastUpdated The timestamp when the rate limit was last updated.\n     */\n    function setRateLimitData(\n        bytes32 key,\n        uint256 maxAmount,\n        uint256 slope,\n        uint256 lastAmount,\n        uint256 lastUpdated\n    ) external;\n\n    /**\n     * @dev   Sets rate limit data for a specific key with\n     *        `lastAmount == maxAmount` and `lastUpdated == block.timestamp`.\n     * @param key       The identifier for the rate limit.\n     * @param maxAmount The maximum allowed amount for the rate limit.\n     * @param slope     The slope value used in the rate limit calculation.\n     */\n    function setRateLimitData(bytes32 key, uint256 maxAmount, uint256 slope) external;\n\n    /**\n     * @dev   Sets an unlimited rate limit.\n     * @param key The identifier for the rate limit.\n     */\n    function setUnlimitedRateLimitData(bytes32 key) external;\n\n    /**********************************************************************************************/\n    /*** Getter Functions                                                                       ***/\n    /**********************************************************************************************/\n\n    /**\n     * @dev    Retrieves the RateLimitData struct associated with a specific key.\n     * @param  key The identifier for the rate limit.\n     * @return The data associated with the rate limit.\n     */\n    function getRateLimitData(bytes32 key) external view returns (RateLimitData memory);\n\n    /**\n     * @dev    Retrieves the current rate limit for a specific key.\n     * @param  key The identifier for the rate limit.\n     * @return The current rate limit value for the given key.\n     */\n    function getCurrentRateLimit(bytes32 key) external view returns (uint256);\n\n    /**********************************************************************************************/\n    /*** Controller functions                                                                   ***/\n    /**********************************************************************************************/\n\n    /**\n     * @dev    Triggers the rate limit for a specific key and reduces the available\n     *         amount by the provided value.\n     * @param  key              The identifier for the rate limit.\n     * @param  amountToDecrease The amount to decrease from the current rate limit.\n     * @return newLimit         The updated rate limit after the deduction.\n     */\n    function triggerRateLimitDecrease(bytes32 key, uint256 amountToDecrease)\n        external returns (uint256 newLimit);\n\n    /**\n     * @dev    Increases the rate limit for a given key up to the maxAmount. Does not revert if\n     *         the new rate limit exceeds the maxAmount.\n     * @param  key              The identifier for the rate limit.\n     * @param  amountToIncrease The amount to increase from the current rate limit.\n     * @return newLimit         The updated rate limit after the addition.\n     */\n    function triggerRateLimitIncrease(bytes32 key, uint256 amountToIncrease)\n        external returns (uint256 newLimit);\n\n}\n"
    },
    "lib/spark-alm-controller/lib/aave-v3-origin/src/core/contracts/interfaces/IPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IPoolAddressesProvider} from './IPoolAddressesProvider.sol';\nimport {DataTypes} from '../protocol/libraries/types/DataTypes.sol';\n\n/**\n * @title IPool\n * @author Aave\n * @notice Defines the basic interface for an Aave Pool.\n */\ninterface IPool {\n  /**\n   * @dev Emitted on mintUnbacked()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address initiating the supply\n   * @param onBehalfOf The beneficiary of the supplied assets, receiving the aTokens\n   * @param amount The amount of supplied assets\n   * @param referralCode The referral code used\n   */\n  event MintUnbacked(\n    address indexed reserve,\n    address user,\n    address indexed onBehalfOf,\n    uint256 amount,\n    uint16 indexed referralCode\n  );\n\n  /**\n   * @dev Emitted on backUnbacked()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param backer The address paying for the backing\n   * @param amount The amount added as backing\n   * @param fee The amount paid in fees\n   */\n  event BackUnbacked(address indexed reserve, address indexed backer, uint256 amount, uint256 fee);\n\n  /**\n   * @dev Emitted on supply()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address initiating the supply\n   * @param onBehalfOf The beneficiary of the supply, receiving the aTokens\n   * @param amount The amount supplied\n   * @param referralCode The referral code used\n   */\n  event Supply(\n    address indexed reserve,\n    address user,\n    address indexed onBehalfOf,\n    uint256 amount,\n    uint16 indexed referralCode\n  );\n\n  /**\n   * @dev Emitted on withdraw()\n   * @param reserve The address of the underlying asset being withdrawn\n   * @param user The address initiating the withdrawal, owner of aTokens\n   * @param to The address that will receive the underlying\n   * @param amount The amount to be withdrawn\n   */\n  event Withdraw(address indexed reserve, address indexed user, address indexed to, uint256 amount);\n\n  /**\n   * @dev Emitted on borrow() and flashLoan() when debt needs to be opened\n   * @param reserve The address of the underlying asset being borrowed\n   * @param user The address of the user initiating the borrow(), receiving the funds on borrow() or just\n   * initiator of the transaction on flashLoan()\n   * @param onBehalfOf The address that will be getting the debt\n   * @param amount The amount borrowed out\n   * @param interestRateMode The rate mode: 1 for Stable, 2 for Variable\n   * @param borrowRate The numeric rate at which the user has borrowed, expressed in ray\n   * @param referralCode The referral code used\n   */\n  event Borrow(\n    address indexed reserve,\n    address user,\n    address indexed onBehalfOf,\n    uint256 amount,\n    DataTypes.InterestRateMode interestRateMode,\n    uint256 borrowRate,\n    uint16 indexed referralCode\n  );\n\n  /**\n   * @dev Emitted on repay()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The beneficiary of the repayment, getting his debt reduced\n   * @param repayer The address of the user initiating the repay(), providing the funds\n   * @param amount The amount repaid\n   * @param useATokens True if the repayment is done using aTokens, `false` if done with underlying asset directly\n   */\n  event Repay(\n    address indexed reserve,\n    address indexed user,\n    address indexed repayer,\n    uint256 amount,\n    bool useATokens\n  );\n\n  /**\n   * @dev Emitted on swapBorrowRateMode()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user swapping his rate mode\n   * @param interestRateMode The current interest rate mode of the position being swapped: 1 for Stable, 2 for Variable\n   */\n  event SwapBorrowRateMode(\n    address indexed reserve,\n    address indexed user,\n    DataTypes.InterestRateMode interestRateMode\n  );\n\n  /**\n   * @dev Emitted on borrow(), repay() and liquidationCall() when using isolated assets\n   * @param asset The address of the underlying asset of the reserve\n   * @param totalDebt The total isolation mode debt for the reserve\n   */\n  event IsolationModeTotalDebtUpdated(address indexed asset, uint256 totalDebt);\n\n  /**\n   * @dev Emitted when the user selects a certain asset category for eMode\n   * @param user The address of the user\n   * @param categoryId The category id\n   */\n  event UserEModeSet(address indexed user, uint8 categoryId);\n\n  /**\n   * @dev Emitted on setUserUseReserveAsCollateral()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user enabling the usage as collateral\n   */\n  event ReserveUsedAsCollateralEnabled(address indexed reserve, address indexed user);\n\n  /**\n   * @dev Emitted on setUserUseReserveAsCollateral()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user enabling the usage as collateral\n   */\n  event ReserveUsedAsCollateralDisabled(address indexed reserve, address indexed user);\n\n  /**\n   * @dev Emitted on rebalanceStableBorrowRate()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user for which the rebalance has been executed\n   */\n  event RebalanceStableBorrowRate(address indexed reserve, address indexed user);\n\n  /**\n   * @dev Emitted on flashLoan()\n   * @param target The address of the flash loan receiver contract\n   * @param initiator The address initiating the flash loan\n   * @param asset The address of the asset being flash borrowed\n   * @param amount The amount flash borrowed\n   * @param interestRateMode The flashloan mode: 0 for regular flashloan, 1 for Stable debt, 2 for Variable debt\n   * @param premium The fee flash borrowed\n   * @param referralCode The referral code used\n   */\n  event FlashLoan(\n    address indexed target,\n    address initiator,\n    address indexed asset,\n    uint256 amount,\n    DataTypes.InterestRateMode interestRateMode,\n    uint256 premium,\n    uint16 indexed referralCode\n  );\n\n  /**\n   * @dev Emitted when a borrower is liquidated.\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n   * @param user The address of the borrower getting liquidated\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n   * @param liquidatedCollateralAmount The amount of collateral received by the liquidator\n   * @param liquidator The address of the liquidator\n   * @param receiveAToken True if the liquidators wants to receive the collateral aTokens, `false` if he wants\n   * to receive the underlying collateral asset directly\n   */\n  event LiquidationCall(\n    address indexed collateralAsset,\n    address indexed debtAsset,\n    address indexed user,\n    uint256 debtToCover,\n    uint256 liquidatedCollateralAmount,\n    address liquidator,\n    bool receiveAToken\n  );\n\n  /**\n   * @dev Emitted when the state of a reserve is updated.\n   * @param reserve The address of the underlying asset of the reserve\n   * @param liquidityRate The next liquidity rate\n   * @param stableBorrowRate The next stable borrow rate\n   * @param variableBorrowRate The next variable borrow rate\n   * @param liquidityIndex The next liquidity index\n   * @param variableBorrowIndex The next variable borrow index\n   */\n  event ReserveDataUpdated(\n    address indexed reserve,\n    uint256 liquidityRate,\n    uint256 stableBorrowRate,\n    uint256 variableBorrowRate,\n    uint256 liquidityIndex,\n    uint256 variableBorrowIndex\n  );\n\n  /**\n   * @dev Emitted when the protocol treasury receives minted aTokens from the accrued interest.\n   * @param reserve The address of the reserve\n   * @param amountMinted The amount minted to the treasury\n   */\n  event MintedToTreasury(address indexed reserve, uint256 amountMinted);\n\n  /**\n   * @notice Mints an `amount` of aTokens to the `onBehalfOf`\n   * @param asset The address of the underlying asset to mint\n   * @param amount The amount to mint\n   * @param onBehalfOf The address that will receive the aTokens\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   */\n  function mintUnbacked(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external;\n\n  /**\n   * @notice Back the current unbacked underlying with `amount` and pay `fee`.\n   * @param asset The address of the underlying asset to back\n   * @param amount The amount to back\n   * @param fee The amount paid in fees\n   * @return The backed amount\n   */\n  function backUnbacked(address asset, uint256 amount, uint256 fee) external returns (uint256);\n\n  /**\n   * @notice Supplies an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\n   * - E.g. User supplies 100 USDC and gets in return 100 aUSDC\n   * @param asset The address of the underlying asset to supply\n   * @param amount The amount to be supplied\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n   *   is a different wallet\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   */\n  function supply(address asset, uint256 amount, address onBehalfOf, uint16 referralCode) external;\n\n  /**\n   * @notice Supply with transfer approval of asset to be supplied done via permit function\n   * see: https://eips.ethereum.org/EIPS/eip-2612 and https://eips.ethereum.org/EIPS/eip-713\n   * @param asset The address of the underlying asset to supply\n   * @param amount The amount to be supplied\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n   *   is a different wallet\n   * @param deadline The deadline timestamp that the permit is valid\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   * @param permitV The V parameter of ERC712 permit sig\n   * @param permitR The R parameter of ERC712 permit sig\n   * @param permitS The S parameter of ERC712 permit sig\n   */\n  function supplyWithPermit(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode,\n    uint256 deadline,\n    uint8 permitV,\n    bytes32 permitR,\n    bytes32 permitS\n  ) external;\n\n  /**\n   * @notice Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\n   * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\n   * @param asset The address of the underlying asset to withdraw\n   * @param amount The underlying amount to be withdrawn\n   *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\n   * @param to The address that will receive the underlying, same as msg.sender if the user\n   *   wants to receive it on his own wallet, or a different address if the beneficiary is a\n   *   different wallet\n   * @return The final amount withdrawn\n   */\n  function withdraw(address asset, uint256 amount, address to) external returns (uint256);\n\n  /**\n   * @notice Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower\n   * already supplied enough collateral, or he was given enough allowance by a credit delegator on the\n   * corresponding debt token (StableDebtToken or VariableDebtToken)\n   * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet\n   *   and 100 stable/variable debt tokens, depending on the `interestRateMode`\n   * @param asset The address of the underlying asset to borrow\n   * @param amount The amount to be borrowed\n   * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable\n   * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   * @param onBehalfOf The address of the user who will receive the debt. Should be the address of the borrower itself\n   * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator\n   * if he has been given credit delegation allowance\n   */\n  function borrow(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode,\n    uint16 referralCode,\n    address onBehalfOf\n  ) external;\n\n  /**\n   * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned\n   * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address\n   * @param asset The address of the borrowed underlying asset previously borrowed\n   * @param amount The amount to repay\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n   * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n   * @param onBehalfOf The address of the user who will get his debt reduced/removed. Should be the address of the\n   * user calling the function if he wants to reduce/remove his own debt, or the address of any other\n   * other borrower whose debt should be removed\n   * @return The final amount repaid\n   */\n  function repay(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode,\n    address onBehalfOf\n  ) external returns (uint256);\n\n  /**\n   * @notice Repay with transfer approval of asset to be repaid done via permit function\n   * see: https://eips.ethereum.org/EIPS/eip-2612 and https://eips.ethereum.org/EIPS/eip-713\n   * @param asset The address of the borrowed underlying asset previously borrowed\n   * @param amount The amount to repay\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n   * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n   * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the\n   * user calling the function if he wants to reduce/remove his own debt, or the address of any other\n   * other borrower whose debt should be removed\n   * @param deadline The deadline timestamp that the permit is valid\n   * @param permitV The V parameter of ERC712 permit sig\n   * @param permitR The R parameter of ERC712 permit sig\n   * @param permitS The S parameter of ERC712 permit sig\n   * @return The final amount repaid\n   */\n  function repayWithPermit(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode,\n    address onBehalfOf,\n    uint256 deadline,\n    uint8 permitV,\n    bytes32 permitR,\n    bytes32 permitS\n  ) external returns (uint256);\n\n  /**\n   * @notice Repays a borrowed `amount` on a specific reserve using the reserve aTokens, burning the\n   * equivalent debt tokens\n   * - E.g. User repays 100 USDC using 100 aUSDC, burning 100 variable/stable debt tokens\n   * @dev  Passing uint256.max as amount will clean up any residual aToken dust balance, if the user aToken\n   * balance is not enough to cover the whole debt\n   * @param asset The address of the borrowed underlying asset previously borrowed\n   * @param amount The amount to repay\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n   * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n   * @return The final amount repaid\n   */\n  function repayWithATokens(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode\n  ) external returns (uint256);\n\n  /**\n   * @notice Allows a borrower to swap his debt between stable and variable mode, or vice versa\n   * @param asset The address of the underlying asset borrowed\n   * @param interestRateMode The current interest rate mode of the position being swapped: 1 for Stable, 2 for Variable\n   */\n  function swapBorrowRateMode(address asset, uint256 interestRateMode) external;\n\n  /**\n   * @notice Permissionless method which allows anyone to swap a users stable debt to variable debt\n   * @dev Introduced in favor of stable rate deprecation\n   * @param asset The address of the underlying asset borrowed\n   * @param user The address of the user whose debt will be swapped from stable to variable\n   */\n  function swapToVariable(address asset, address user) external;\n\n  /**\n   * @notice Rebalances the stable interest rate of a user to the current stable rate defined on the reserve.\n   * - Users can be rebalanced if the following conditions are satisfied:\n   *     1. Usage ratio is above 95%\n   *     2. the current supply APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate, which means that too\n   *        much has been borrowed at a stable rate and suppliers are not earning enough\n   * @param asset The address of the underlying asset borrowed\n   * @param user The address of the user to be rebalanced\n   */\n  function rebalanceStableBorrowRate(address asset, address user) external;\n\n  /**\n   * @notice Allows suppliers to enable/disable a specific supplied asset as collateral\n   * @param asset The address of the underlying asset supplied\n   * @param useAsCollateral True if the user wants to use the supply as collateral, false otherwise\n   */\n  function setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external;\n\n  /**\n   * @notice Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1\n   * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives\n   *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n   * @param user The address of the borrower getting liquidated\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n   * @param receiveAToken True if the liquidators wants to receive the collateral aTokens, `false` if he wants\n   * to receive the underlying collateral asset directly\n   */\n  function liquidationCall(\n    address collateralAsset,\n    address debtAsset,\n    address user,\n    uint256 debtToCover,\n    bool receiveAToken\n  ) external;\n\n  /**\n   * @notice Allows smartcontracts to access the liquidity of the pool within one transaction,\n   * as long as the amount taken plus a fee is returned.\n   * @dev IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept\n   * into consideration. For further details please visit https://docs.aave.com/developers/\n   * @param receiverAddress The address of the contract receiving the funds, implementing IFlashLoanReceiver interface\n   * @param assets The addresses of the assets being flash-borrowed\n   * @param amounts The amounts of the assets being flash-borrowed\n   * @param interestRateModes Types of the debt to open if the flash loan is not returned:\n   *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver\n   *   1 -> Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n   *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n   * @param onBehalfOf The address  that will receive the debt in the case of using on `modes` 1 or 2\n   * @param params Variadic packed params to pass to the receiver as extra information\n   * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   */\n  function flashLoan(\n    address receiverAddress,\n    address[] calldata assets,\n    uint256[] calldata amounts,\n    uint256[] calldata interestRateModes,\n    address onBehalfOf,\n    bytes calldata params,\n    uint16 referralCode\n  ) external;\n\n  /**\n   * @notice Allows smartcontracts to access the liquidity of the pool within one transaction,\n   * as long as the amount taken plus a fee is returned.\n   * @dev IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept\n   * into consideration. For further details please visit https://docs.aave.com/developers/\n   * @param receiverAddress The address of the contract receiving the funds, implementing IFlashLoanSimpleReceiver interface\n   * @param asset The address of the asset being flash-borrowed\n   * @param amount The amount of the asset being flash-borrowed\n   * @param params Variadic packed params to pass to the receiver as extra information\n   * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   */\n  function flashLoanSimple(\n    address receiverAddress,\n    address asset,\n    uint256 amount,\n    bytes calldata params,\n    uint16 referralCode\n  ) external;\n\n  /**\n   * @notice Returns the user account data across all the reserves\n   * @param user The address of the user\n   * @return totalCollateralBase The total collateral of the user in the base currency used by the price feed\n   * @return totalDebtBase The total debt of the user in the base currency used by the price feed\n   * @return availableBorrowsBase The borrowing power left of the user in the base currency used by the price feed\n   * @return currentLiquidationThreshold The liquidation threshold of the user\n   * @return ltv The loan to value of The user\n   * @return healthFactor The current health factor of the user\n   */\n  function getUserAccountData(\n    address user\n  )\n    external\n    view\n    returns (\n      uint256 totalCollateralBase,\n      uint256 totalDebtBase,\n      uint256 availableBorrowsBase,\n      uint256 currentLiquidationThreshold,\n      uint256 ltv,\n      uint256 healthFactor\n    );\n\n  /**\n   * @notice Initializes a reserve, activating it, assigning an aToken and debt tokens and an\n   * interest rate strategy\n   * @dev Only callable by the PoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param aTokenAddress The address of the aToken that will be assigned to the reserve\n   * @param stableDebtAddress The address of the StableDebtToken that will be assigned to the reserve\n   * @param variableDebtAddress The address of the VariableDebtToken that will be assigned to the reserve\n   * @param interestRateStrategyAddress The address of the interest rate strategy contract\n   */\n  function initReserve(\n    address asset,\n    address aTokenAddress,\n    address stableDebtAddress,\n    address variableDebtAddress,\n    address interestRateStrategyAddress\n  ) external;\n\n  /**\n   * @notice Drop a reserve\n   * @dev Only callable by the PoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   */\n  function dropReserve(address asset) external;\n\n  /**\n   * @notice Updates the address of the interest rate strategy contract\n   * @dev Only callable by the PoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param rateStrategyAddress The address of the interest rate strategy contract\n   */\n  function setReserveInterestRateStrategyAddress(\n    address asset,\n    address rateStrategyAddress\n  ) external;\n\n  /**\n   * @notice Accumulates interest to all indexes of the reserve\n   * @dev Only callable by the PoolConfigurator contract\n   * @dev To be used when required by the configurator, for example when updating interest rates strategy data\n   * @param asset The address of the underlying asset of the reserve\n   */\n  function syncIndexesState(address asset) external;\n\n  /**\n   * @notice Updates interest rates on the reserve data\n   * @dev Only callable by the PoolConfigurator contract\n   * @dev To be used when required by the configurator, for example when updating interest rates strategy data\n   * @param asset The address of the underlying asset of the reserve\n   */\n  function syncRatesState(address asset) external;\n\n  /**\n   * @notice Sets the configuration bitmap of the reserve as a whole\n   * @dev Only callable by the PoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param configuration The new configuration bitmap\n   */\n  function setConfiguration(\n    address asset,\n    DataTypes.ReserveConfigurationMap calldata configuration\n  ) external;\n\n  /**\n   * @notice Returns the configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The configuration of the reserve\n   */\n  function getConfiguration(\n    address asset\n  ) external view returns (DataTypes.ReserveConfigurationMap memory);\n\n  /**\n   * @notice Returns the configuration of the user across all the reserves\n   * @param user The user address\n   * @return The configuration of the user\n   */\n  function getUserConfiguration(\n    address user\n  ) external view returns (DataTypes.UserConfigurationMap memory);\n\n  /**\n   * @notice Returns the normalized income of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve's normalized income\n   */\n  function getReserveNormalizedIncome(address asset) external view returns (uint256);\n\n  /**\n   * @notice Returns the normalized variable debt per unit of asset\n   * @dev WARNING: This function is intended to be used primarily by the protocol itself to get a\n   * \"dynamic\" variable index based on time, current stored index and virtual rate at the current\n   * moment (approx. a borrower would get if opening a position). This means that is always used in\n   * combination with variable debt supply/balances.\n   * If using this function externally, consider that is possible to have an increasing normalized\n   * variable debt that is not equivalent to how the variable debt index would be updated in storage\n   * (e.g. only updates with non-zero variable debt supply)\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve normalized variable debt\n   */\n  function getReserveNormalizedVariableDebt(address asset) external view returns (uint256);\n\n  /**\n   * @notice Returns the state and configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The state and configuration data of the reserve\n   */\n  function getReserveData(address asset) external view returns (DataTypes.ReserveDataLegacy memory);\n\n  /**\n   * @notice Returns the state and configuration of the reserve, including extra data included with Aave v3.1\n   * @param asset The address of the underlying asset of the reserve\n   * @return The state and configuration data of the reserve with virtual accounting\n   */\n  function getReserveDataExtended(\n    address asset\n  ) external view returns (DataTypes.ReserveData memory);\n\n  /**\n   * @notice Returns the virtual underlying balance of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve virtual underlying balance\n   */\n  function getVirtualUnderlyingBalance(address asset) external view returns (uint128);\n\n  /**\n   * @notice Validates and finalizes an aToken transfer\n   * @dev Only callable by the overlying aToken of the `asset`\n   * @param asset The address of the underlying asset of the aToken\n   * @param from The user from which the aTokens are transferred\n   * @param to The user receiving the aTokens\n   * @param amount The amount being transferred/withdrawn\n   * @param balanceFromBefore The aToken balance of the `from` user before the transfer\n   * @param balanceToBefore The aToken balance of the `to` user before the transfer\n   */\n  function finalizeTransfer(\n    address asset,\n    address from,\n    address to,\n    uint256 amount,\n    uint256 balanceFromBefore,\n    uint256 balanceToBefore\n  ) external;\n\n  /**\n   * @notice Returns the list of the underlying assets of all the initialized reserves\n   * @dev It does not include dropped reserves\n   * @return The addresses of the underlying assets of the initialized reserves\n   */\n  function getReservesList() external view returns (address[] memory);\n\n  /**\n   * @notice Returns the number of initialized reserves\n   * @dev It includes dropped reserves\n   * @return The count\n   */\n  function getReservesCount() external view returns (uint256);\n\n  /**\n   * @notice Returns the address of the underlying asset of a reserve by the reserve id as stored in the DataTypes.ReserveData struct\n   * @param id The id of the reserve as stored in the DataTypes.ReserveData struct\n   * @return The address of the reserve associated with id\n   */\n  function getReserveAddressById(uint16 id) external view returns (address);\n\n  /**\n   * @notice Returns the PoolAddressesProvider connected to this contract\n   * @return The address of the PoolAddressesProvider\n   */\n  function ADDRESSES_PROVIDER() external view returns (IPoolAddressesProvider);\n\n  /**\n   * @notice Updates the protocol fee on the bridging\n   * @param bridgeProtocolFee The part of the premium sent to the protocol treasury\n   */\n  function updateBridgeProtocolFee(uint256 bridgeProtocolFee) external;\n\n  /**\n   * @notice Updates flash loan premiums. Flash loan premium consists of two parts:\n   * - A part is sent to aToken holders as extra, one time accumulated interest\n   * - A part is collected by the protocol treasury\n   * @dev The total premium is calculated on the total borrowed amount\n   * @dev The premium to protocol is calculated on the total premium, being a percentage of `flashLoanPremiumTotal`\n   * @dev Only callable by the PoolConfigurator contract\n   * @param flashLoanPremiumTotal The total premium, expressed in bps\n   * @param flashLoanPremiumToProtocol The part of the premium sent to the protocol treasury, expressed in bps\n   */\n  function updateFlashloanPremiums(\n    uint128 flashLoanPremiumTotal,\n    uint128 flashLoanPremiumToProtocol\n  ) external;\n\n  /**\n   * @notice Configures a new category for the eMode.\n   * @dev In eMode, the protocol allows very high borrowing power to borrow assets of the same category.\n   * The category 0 is reserved as it's the default for volatile assets\n   * @param id The id of the category\n   * @param config The configuration of the category\n   */\n  function configureEModeCategory(uint8 id, DataTypes.EModeCategory memory config) external;\n\n  /**\n   * @notice Returns the data of an eMode category\n   * @param id The id of the category\n   * @return The configuration data of the category\n   */\n  function getEModeCategoryData(uint8 id) external view returns (DataTypes.EModeCategory memory);\n\n  /**\n   * @notice Allows a user to use the protocol in eMode\n   * @param categoryId The id of the category\n   */\n  function setUserEMode(uint8 categoryId) external;\n\n  /**\n   * @notice Returns the eMode the user is using\n   * @param user The address of the user\n   * @return The eMode id\n   */\n  function getUserEMode(address user) external view returns (uint256);\n\n  /**\n   * @notice Resets the isolation mode total debt of the given asset to zero\n   * @dev It requires the given asset has zero debt ceiling\n   * @param asset The address of the underlying asset to reset the isolationModeTotalDebt\n   */\n  function resetIsolationModeTotalDebt(address asset) external;\n\n  /**\n   * @notice Sets the liquidation grace period of the given asset\n   * @dev To enable a liquidation grace period, a timestamp in the future should be set,\n   *      To disable a liquidation grace period, any timestamp in the past works, like 0\n   * @param asset The address of the underlying asset to set the liquidationGracePeriod\n   * @param until Timestamp when the liquidation grace period will end\n   **/\n  function setLiquidationGracePeriod(address asset, uint40 until) external;\n\n  /**\n   * @notice Returns the liquidation grace period of the given asset\n   * @param asset The address of the underlying asset\n   * @return Timestamp when the liquidation grace period will end\n   **/\n  function getLiquidationGracePeriod(address asset) external returns (uint40);\n\n  /**\n   * @notice Returns the percentage of available liquidity that can be borrowed at once at stable rate\n   * @return The percentage of available liquidity to borrow, expressed in bps\n   */\n  function MAX_STABLE_RATE_BORROW_SIZE_PERCENT() external view returns (uint256);\n\n  /**\n   * @notice Returns the total fee on flash loans\n   * @return The total fee on flashloans\n   */\n  function FLASHLOAN_PREMIUM_TOTAL() external view returns (uint128);\n\n  /**\n   * @notice Returns the part of the bridge fees sent to protocol\n   * @return The bridge fee sent to the protocol treasury\n   */\n  function BRIDGE_PROTOCOL_FEE() external view returns (uint256);\n\n  /**\n   * @notice Returns the part of the flashloan fees sent to protocol\n   * @return The flashloan fee sent to the protocol treasury\n   */\n  function FLASHLOAN_PREMIUM_TO_PROTOCOL() external view returns (uint128);\n\n  /**\n   * @notice Returns the maximum number of reserves supported to be listed in this Pool\n   * @return The maximum number of reserves supported\n   */\n  function MAX_NUMBER_RESERVES() external view returns (uint16);\n\n  /**\n   * @notice Mints the assets accrued through the reserve factor to the treasury in the form of aTokens\n   * @param assets The list of reserves for which the minting needs to be executed\n   */\n  function mintToTreasury(address[] calldata assets) external;\n\n  /**\n   * @notice Rescue and transfer tokens locked in this contract\n   * @param token The address of the token\n   * @param to The address of the recipient\n   * @param amount The amount of token to transfer\n   */\n  function rescueTokens(address token, address to, uint256 amount) external;\n\n  /**\n   * @notice Supplies an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\n   * - E.g. User supplies 100 USDC and gets in return 100 aUSDC\n   * @dev Deprecated: Use the `supply` function instead\n   * @param asset The address of the underlying asset to supply\n   * @param amount The amount to be supplied\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n   *   is a different wallet\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   */\n  function deposit(address asset, uint256 amount, address onBehalfOf, uint16 referralCode) external;\n\n  /**\n   * @notice Gets the address of the external FlashLoanLogic\n   */\n  function getFlashLoanLogic() external returns (address);\n\n  /**\n   * @notice Gets the address of the external BorrowLogic\n   */\n  function getBorrowLogic() external returns (address);\n\n  /**\n   * @notice Gets the address of the external BridgeLogic\n   */\n  function getBridgeLogic() external returns (address);\n\n  /**\n   * @notice Gets the address of the external EModeLogic\n   */\n  function getEModeLogic() external returns (address);\n\n  /**\n   * @notice Gets the address of the external LiquidationLogic\n   */\n  function getLiquidationLogic() external returns (address);\n\n  /**\n   * @notice Gets the address of the external PoolLogic\n   */\n  function getPoolLogic() external returns (address);\n\n  /**\n   * @notice Gets the address of the external SupplyLogic\n   */\n  function getSupplyLogic() external returns (address);\n}\n"
    },
    "lib/forge-std/src/interfaces/IERC7540.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2;\n\nimport {IERC7575} from \"./IERC7575.sol\";\n\n/// @dev Interface of the base operator logic of ERC7540, as defined in\n/// https://eips.ethereum.org/EIPS/eip-7540\ninterface IERC7540Operator {\n    /**\n     * @dev The event emitted when an operator is set.\n     *\n     * @param controller The address of the controller.\n     * @param operator The address of the operator.\n     * @param approved The approval status.\n     */\n    event OperatorSet(address indexed controller, address indexed operator, bool approved);\n\n    /**\n     * @dev Sets or removes an operator for the caller.\n     *\n     * @param operator The address of the operator.\n     * @param approved The approval status.\n     * @return Whether the call was executed successfully or not\n     */\n    function setOperator(address operator, bool approved) external returns (bool);\n\n    /**\n     * @dev Returns `true` if the `operator` is approved as an operator for an `controller`.\n     *\n     * @param controller The address of the controller.\n     * @param operator The address of the operator.\n     * @return status The approval status\n     */\n    function isOperator(address controller, address operator) external view returns (bool status);\n}\n\n/// @dev Interface of the asynchronous deposit Vault interface of ERC7540, as defined in\n/// https://eips.ethereum.org/EIPS/eip-7540\ninterface IERC7540Deposit is IERC7540Operator {\n    event DepositRequest(\n        address indexed controller, address indexed owner, uint256 indexed requestId, address sender, uint256 assets\n    );\n    /**\n     * @dev Transfers assets from sender into the Vault and submits a Request for asynchronous deposit.\n     *\n     * - MUST support ERC-20 approve / transferFrom on asset as a deposit Request flow.\n     * - MUST revert if all of assets cannot be requested for deposit.\n     * - owner MUST be msg.sender unless some unspecified explicit approval is given by the caller,\n     *    approval of ERC-20 tokens from owner to sender is NOT enough.\n     *\n     * @param assets the amount of deposit assets to transfer from owner\n     * @param controller the controller of the request who will be able to operate the request\n     * @param owner the source of the deposit assets\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault's underlying asset token.\n     */\n\n    function requestDeposit(uint256 assets, address controller, address owner) external returns (uint256 requestId);\n\n    /**\n     * @dev Returns the amount of requested assets in Pending state.\n     *\n     * - MUST NOT include any assets in Claimable state for deposit or mint.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT revert unless due to integer overflow caused by an unreasonably large input.\n     */\n    function pendingDepositRequest(uint256 requestId, address controller)\n        external\n        view\n        returns (uint256 pendingAssets);\n\n    /**\n     * @dev Returns the amount of requested assets in Claimable state for the controller to deposit or mint.\n     *\n     * - MUST NOT include any assets in Pending state.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT revert unless due to integer overflow caused by an unreasonably large input.\n     */\n    function claimableDepositRequest(uint256 requestId, address controller)\n        external\n        view\n        returns (uint256 claimableAssets);\n\n    /**\n     * @dev Mints shares Vault shares to receiver by claiming the Request of the controller.\n     *\n     * - MUST emit the Deposit event.\n     * - controller MUST equal msg.sender unless the controller has approved the msg.sender as an operator.\n     */\n    function deposit(uint256 assets, address receiver, address controller) external returns (uint256 shares);\n\n    /**\n     * @dev Mints exactly shares Vault shares to receiver by claiming the Request of the controller.\n     *\n     * - MUST emit the Deposit event.\n     * - controller MUST equal msg.sender unless the controller has approved the msg.sender as an operator.\n     */\n    function mint(uint256 shares, address receiver, address controller) external returns (uint256 assets);\n}\n\n/// @dev Interface of the asynchronous deposit Vault interface of ERC7540, as defined in\n/// https://eips.ethereum.org/EIPS/eip-7540\ninterface IERC7540Redeem is IERC7540Operator {\n    event RedeemRequest(\n        address indexed controller, address indexed owner, uint256 indexed requestId, address sender, uint256 assets\n    );\n\n    /**\n     * @dev Assumes control of shares from sender into the Vault and submits a Request for asynchronous redeem.\n     *\n     * - MUST support a redeem Request flow where the control of shares is taken from sender directly\n     *   where msg.sender has ERC-20 approval over the shares of owner.\n     * - MUST revert if all of shares cannot be requested for redeem.\n     *\n     * @param shares the amount of shares to be redeemed to transfer from owner\n     * @param controller the controller of the request who will be able to operate the request\n     * @param owner the source of the shares to be redeemed\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault's share token.\n     */\n    function requestRedeem(uint256 shares, address controller, address owner) external returns (uint256 requestId);\n\n    /**\n     * @dev Returns the amount of requested shares in Pending state.\n     *\n     * - MUST NOT include any shares in Claimable state for redeem or withdraw.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT revert unless due to integer overflow caused by an unreasonably large input.\n     */\n    function pendingRedeemRequest(uint256 requestId, address controller)\n        external\n        view\n        returns (uint256 pendingShares);\n\n    /**\n     * @dev Returns the amount of requested shares in Claimable state for the controller to redeem or withdraw.\n     *\n     * - MUST NOT include any shares in Pending state for redeem or withdraw.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT revert unless due to integer overflow caused by an unreasonably large input.\n     */\n    function claimableRedeemRequest(uint256 requestId, address controller)\n        external\n        view\n        returns (uint256 claimableShares);\n}\n\n/// @dev Interface of the fully asynchronous Vault interface of ERC7540, as defined in\n/// https://eips.ethereum.org/EIPS/eip-7540\ninterface IERC7540 is IERC7540Deposit, IERC7540Redeem, IERC7575 {}\n"
    },
    "lib/metamorpho/lib/openzeppelin-contracts/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.20;\n\nimport {IAccessControl} from \"./IAccessControl.sol\";\nimport {Context} from \"../utils/Context.sol\";\nimport {ERC165} from \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 role => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        return _roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (!hasRole(role, account)) {\n            _roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (hasRole(role, account)) {\n            _roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n"
    },
    "lib/spark-alm-controller/src/interfaces/CCTPInterfaces.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity >=0.8.0;\n\ninterface ICCTPLike {\n\n    function depositForBurn(\n        uint256 amount,\n        uint32  destinationDomain,\n        bytes32 mintRecipient,\n        address burnToken\n    ) external returns (uint64 nonce);\n\n    function localMinter() external view returns (ICCTPTokenMinterLike);\n\n}\n\ninterface ICCTPTokenMinterLike {\n    function burnLimitsPerMessage(address) external view returns (uint256);\n}\n"
    },
    "lib/spark-alm-controller/lib/spark-psm/src/interfaces/IPSM3.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.13;\n\nimport { IERC20 } from \"erc20-helpers/interfaces/IERC20.sol\";\n\ninterface IPSM3 {\n\n    /**********************************************************************************************/\n    /*** Events                                                                                 ***/\n    /**********************************************************************************************/\n\n    /**\n     *  @dev   Emitted when a new pocket is set in the PSM, transferring the balance of USDC.\n     *         of the old pocket to the new pocket.\n     *  @param oldPocket         Address of the old `pocket`.\n     *  @param newPocket         Address of the new `pocket`.\n     *  @param amountTransferred Amount of USDC transferred from the old pocket to the new pocket.\n     */\n    event PocketSet(\n        address indexed oldPocket,\n        address indexed newPocket,\n        uint256 amountTransferred\n    );\n\n    /**\n     *  @dev   Emitted when an asset is swapped in the PSM.\n     *  @param assetIn       Address of the asset swapped in.\n     *  @param assetOut      Address of the asset swapped out.\n     *  @param sender        Address of the sender of the swap.\n     *  @param receiver      Address of the receiver of the swap.\n     *  @param amountIn      Amount of the asset swapped in.\n     *  @param amountOut     Amount of the asset swapped out.\n     *  @param referralCode  Referral code for the swap.\n     */\n    event Swap(\n        address indexed assetIn,\n        address indexed assetOut,\n        address sender,\n        address indexed receiver,\n        uint256 amountIn,\n        uint256 amountOut,\n        uint256 referralCode\n    );\n\n    /**\n     *  @dev   Emitted when an asset is deposited into the PSM.\n     *  @param asset           Address of the asset deposited.\n     *  @param user            Address of the user that deposited the asset.\n     *  @param receiver        Address of the receiver of the resulting shares from the deposit.\n     *  @param assetsDeposited Amount of the asset deposited.\n     *  @param sharesMinted    Number of shares minted to the user.\n     */\n    event Deposit(\n        address indexed asset,\n        address indexed user,\n        address indexed receiver,\n        uint256 assetsDeposited,\n        uint256 sharesMinted\n    );\n\n    /**\n     *  @dev   Emitted when an asset is withdrawn from the PSM.\n     *  @param asset           Address of the asset withdrawn.\n     *  @param user            Address of the user that withdrew the asset.\n     *  @param receiver        Address of the receiver of the withdrawn assets.\n     *  @param assetsWithdrawn Amount of the asset withdrawn.\n     *  @param sharesBurned    Number of shares burned from the user.\n     */\n    event Withdraw(\n        address indexed asset,\n        address indexed user,\n        address indexed receiver,\n        uint256 assetsWithdrawn,\n        uint256 sharesBurned\n    );\n\n    /**********************************************************************************************/\n    /*** State variables and immutables                                                         ***/\n    /**********************************************************************************************/\n\n    /**\n     *  @dev    Returns the IERC20 interface representing USDC.\n     *  @return The IERC20 interface of USDC.\n     */\n    function usdc() external view returns (IERC20);\n\n    /**\n     *  @dev    Returns the IERC20 interface representing USDS.\n     *  @return The IERC20 interface of USDS.\n     */\n    function usds() external view returns (IERC20);\n\n    /**\n     *  @dev    Returns the IERC20 interface representing sUSDS. This asset is the yield-bearing\n     *          asset in the PSM. The value of this asset is queried from the rate provider.\n     *  @return The IERC20 interface of sUSDS.\n     */\n    function susds() external view returns (IERC20);\n\n    /**\n     *  @dev    Returns the address of the pocket, an address that holds custody of USDC in the\n     *          PSM and can deploy it to yield-bearing strategies. Settable by the owner.\n     *  @return The address of the pocket.\n     */\n    function pocket() external view returns (address);\n\n    /**\n     *  @dev    Returns the address of the rate provider, a contract that provides the conversion\n     *          rate between sUSDS and the other two assets in the PSM (e.g., sUSDS to USD).\n     *  @return The address of the rate provider.\n     */\n    function rateProvider() external view returns (address);\n\n    /**\n     *  @dev    Returns the total number of shares in the PSM. Shares represent ownership of the\n     *          assets in the PSM and can be converted to assets at any time.\n     *  @return The total number of shares.\n     */\n    function totalShares() external view returns (uint256);\n\n    /**\n     *  @dev    Returns the number of shares held by a specific user.\n     *  @param  user The address of the user.\n     *  @return The number of shares held by the user.\n     */\n    function shares(address user) external view returns (uint256);\n\n    /**********************************************************************************************/\n    /*** Owner functions                                                                        ***/\n    /**********************************************************************************************/\n\n    /**\n     *  @dev    Sets the address of the pocket, an address that holds custody of USDC in the PSM\n     *          and can deploy it to yield-bearing strategies. This function will transfer the\n     *          balance of USDC in the PSM to the new pocket. Callable only by the owner.\n     *  @param  newPocket Address of the new pocket.\n     */\n    function setPocket(address newPocket) external;\n\n    /**********************************************************************************************/\n    /*** Swap functions                                                                         ***/\n    /**********************************************************************************************/\n\n    /**\n     *  @dev    Swaps a specified amount of assetIn for assetOut in the PSM. The amount swapped is\n     *          converted based on the current value of the two assets used in the swap. This\n     *          function will revert if there is not enough balance in the PSM to facilitate the\n     *          swap. Both assets must be supported in the PSM in order to succeed.\n     *  @param  assetIn      Address of the ERC-20 asset to swap in.\n     *  @param  assetOut     Address of the ERC-20 asset to swap out.\n     *  @param  amountIn     Amount of the asset to swap in.\n     *  @param  minAmountOut Minimum amount of the asset to receive.\n     *  @param  receiver     Address of the receiver of the swapped assets.\n     *  @param  referralCode Referral code for the swap.\n     *  @return amountOut    Resulting amount of the asset that will be received in the swap.\n     */\n    function swapExactIn(\n        address assetIn,\n        address assetOut,\n        uint256 amountIn,\n        uint256 minAmountOut,\n        address receiver,\n        uint256 referralCode\n    ) external returns (uint256 amountOut);\n\n    /**\n     *  @dev    Swaps a derived amount of assetIn for a specific amount of assetOut in the PSM. The\n     *          amount swapped is converted based on the current value of the two assets used in\n     *          the swap. This function will revert if there is not enough balance in the PSM to\n     *          facilitate the swap. Both assets must be supported in the PSM in order to succeed.\n     *  @param  assetIn      Address of the ERC-20 asset to swap in.\n     *  @param  assetOut     Address of the ERC-20 asset to swap out.\n     *  @param  amountOut    Amount of the asset to receive from the swap.\n     *  @param  maxAmountIn  Max amount of the asset to use for the swap.\n     *  @param  receiver     Address of the receiver of the swapped assets.\n     *  @param  referralCode Referral code for the swap.\n     *  @return amountIn     Resulting amount of the asset swapped in.\n     */\n    function swapExactOut(\n        address assetIn,\n        address assetOut,\n        uint256 amountOut,\n        uint256 maxAmountIn,\n        address receiver,\n        uint256 referralCode\n    ) external returns (uint256 amountIn);\n\n    /**********************************************************************************************/\n    /*** Liquidity provision functions                                                          ***/\n    /**********************************************************************************************/\n\n    /**\n     *  @dev    Deposits an amount of a given asset into the PSM. Must be one of the supported\n     *          assets in order to succeed. The amount deposited is converted to shares based on\n     *          the current exchange rate.\n     *  @param  asset           Address of the ERC-20 asset to deposit.\n     *  @param  receiver        Address of the receiver of the resulting shares from the deposit.\n     *  @param  assetsToDeposit Amount of the asset to deposit into the PSM.\n     *  @return newShares       Number of shares minted to the user.\n     */\n    function deposit(address asset, address receiver, uint256 assetsToDeposit)\n        external returns (uint256 newShares);\n\n    /**\n     *  @dev    Withdraws an amount of a given asset from the PSM up to `maxAssetsToWithdraw`.\n     *          Must be one of the supported assets in order to succeed. The amount withdrawn is\n     *          the minimum of the balance of the PSM, the max amount, and the max amount of assets\n     *          that the user's shares can be converted to.\n     *  @param  asset               Address of the ERC-20 asset to withdraw.\n     *  @param  receiver            Address of the receiver of the withdrawn assets.\n     *  @param  maxAssetsToWithdraw Max amount that the user is willing to withdraw.\n     *  @return assetsWithdrawn     Resulting amount of the asset withdrawn from the PSM.\n     */\n    function withdraw(\n        address asset,\n        address receiver,\n        uint256 maxAssetsToWithdraw\n    ) external returns (uint256 assetsWithdrawn);\n\n    /**********************************************************************************************/\n    /*** Deposit/withdraw preview functions                                                     ***/\n    /**********************************************************************************************/\n\n    /**\n     *  @dev    View function that returns the exact number of shares that would be minted for a\n     *          given asset and amount to deposit.\n     *  @param  asset  Address of the ERC-20 asset to deposit.\n     *  @param  assets Amount of the asset to deposit into the PSM.\n     *  @return shares Number of shares to be minted to the user.\n     */\n    function previewDeposit(address asset, uint256 assets) external view returns (uint256 shares);\n\n    /**\n     *  @dev    View function that returns the exact number of assets that would be withdrawn and\n     *          corresponding shares that would be burned in a withdrawal for a given asset and max\n     *          withdraw amount. The amount returned is the minimum of the balance of the PSM,\n     *          the max amount, and the max amount of assets that the user's shares\n     *          can be converted to.\n     *  @param  asset               Address of the ERC-20 asset to withdraw.\n     *  @param  maxAssetsToWithdraw Max amount that the user is willing to withdraw.\n     *  @return sharesToBurn        Number of shares that would be burned in the withdrawal.\n     *  @return assetsWithdrawn     Resulting amount of the asset withdrawn from the PSM.\n     */\n    function previewWithdraw(address asset, uint256 maxAssetsToWithdraw)\n        external view returns (uint256 sharesToBurn, uint256 assetsWithdrawn);\n\n    /**********************************************************************************************/\n    /*** Swap preview functions                                                                 ***/\n    /**********************************************************************************************/\n\n    /**\n     * @dev    View function that returns the exact amount of assetOut that would be received for a\n     *         given amount of assetIn in a swap. The amount returned is converted based on the\n     *         current value of the two assets used in the swap.\n     * @param  assetIn   Address of the ERC-20 asset to swap in.\n     * @param  assetOut  Address of the ERC-20 asset to swap out.\n     * @param  amountIn  Amount of the asset to swap in.\n     * @return amountOut Amount of the asset that will be received in the swap.\n     */\n    function previewSwapExactIn(address assetIn, address assetOut, uint256 amountIn)\n        external view returns (uint256 amountOut);\n\n    /**\n     * @dev    View function that returns the exact amount of assetIn that would be required to\n     *         receive a given amount of assetOut in a swap. The amount returned is\n     *         converted based on the current value of the two assets used in the swap.\n     * @param  assetIn   Address of the ERC-20 asset to swap in.\n     * @param  assetOut  Address of the ERC-20 asset to swap out.\n     * @param  amountOut Amount of the asset to receive from the swap.\n     * @return amountIn  Amount of the asset that is required to receive amountOut.\n     */\n    function previewSwapExactOut(address assetIn, address assetOut, uint256 amountOut)\n        external view returns (uint256 amountIn);\n\n    /**********************************************************************************************/\n    /*** Conversion functions                                                                   ***/\n    /**********************************************************************************************/\n\n    /**\n     *  @dev    View function that converts an amount of a given shares to the equivalent amount of\n     *          assets for a specified asset.\n     *  @param  asset     Address of the asset to use to convert.\n     *  @param  numShares Number of shares to convert to assets.\n     *  @return assets    Value of assets in asset-native units.\n     */\n    function convertToAssets(address asset, uint256 numShares) external view returns (uint256);\n\n    /**\n     *  @dev    View function that converts an amount of a given shares to the equivalent\n     *          amount of assetValue.\n     *  @param  numShares  Number of shares to convert to assetValue.\n     *  @return assetValue Value of assets in USDC denominated in 18 decimals.\n     */\n    function convertToAssetValue(uint256 numShares) external view returns (uint256);\n\n    /**\n     *  @dev    View function that converts an amount of assetValue (18 decimal value denominated in\n     *          USDC and USDS) to shares in the PSM based on the current exchange rate.\n     *          Note that this rounds down on calculation so is intended to be used for quoting the\n     *          current exchange rate.\n     *  @param  assetValue 18 decimal value denominated in USDC (e.g., 1e6 USDC = 1e18)\n     *  @return shares     Number of shares that the assetValue is equivalent to.\n     */\n    function convertToShares(uint256 assetValue) external view returns (uint256);\n\n    /**\n     *  @dev    View function that converts an amount of a given asset to shares in the PSM based\n     *          on the current exchange rate. Note that this rounds down on calculation so is\n     *          intended to be used for quoting the current exchange rate.\n     *  @param  asset  Address of the ERC-20 asset to convert to shares.\n     *  @param  assets Amount of assets in asset-native units.\n     *  @return shares Number of shares that the assetValue is equivalent to.\n     */\n    function convertToShares(address asset, uint256 assets) external view returns (uint256);\n\n    /**********************************************************************************************/\n    /*** Asset value functions                                                                  ***/\n    /**********************************************************************************************/\n\n    /**\n     *  @dev View function that returns the total value of the balance of all assets in the PSM\n     *       converted to USDC/USDS terms denominated in 18 decimal precision.\n     */\n    function totalAssets() external view returns (uint256);\n\n}\n"
    },
    "lib/sparklend-v1-core/contracts/protocol/libraries/types/DataTypes.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nlibrary DataTypes {\n  struct ReserveData {\n    //stores the reserve configuration\n    ReserveConfigurationMap configuration;\n    //the liquidity index. Expressed in ray\n    uint128 liquidityIndex;\n    //the current supply rate. Expressed in ray\n    uint128 currentLiquidityRate;\n    //variable borrow index. Expressed in ray\n    uint128 variableBorrowIndex;\n    //the current variable borrow rate. Expressed in ray\n    uint128 currentVariableBorrowRate;\n    //the current stable borrow rate. Expressed in ray\n    uint128 currentStableBorrowRate;\n    //timestamp of last update\n    uint40 lastUpdateTimestamp;\n    //the id of the reserve. Represents the position in the list of the active reserves\n    uint16 id;\n    //aToken address\n    address aTokenAddress;\n    //stableDebtToken address\n    address stableDebtTokenAddress;\n    //variableDebtToken address\n    address variableDebtTokenAddress;\n    //address of the interest rate strategy\n    address interestRateStrategyAddress;\n    //the current treasury balance, scaled\n    uint128 accruedToTreasury;\n    //the outstanding unbacked aTokens minted through the bridging feature\n    uint128 unbacked;\n    //the outstanding debt borrowed against this asset in isolation mode\n    uint128 isolationModeTotalDebt;\n  }\n\n  struct ReserveConfigurationMap {\n    //bit 0-15: LTV\n    //bit 16-31: Liq. threshold\n    //bit 32-47: Liq. bonus\n    //bit 48-55: Decimals\n    //bit 56: reserve is active\n    //bit 57: reserve is frozen\n    //bit 58: borrowing is enabled\n    //bit 59: stable rate borrowing enabled\n    //bit 60: asset is paused\n    //bit 61: borrowing in isolation mode is enabled\n    //bit 62: siloed borrowing enabled\n    //bit 63: flashloaning enabled\n    //bit 64-79: reserve factor\n    //bit 80-115 borrow cap in whole tokens, borrowCap == 0 => no cap\n    //bit 116-151 supply cap in whole tokens, supplyCap == 0 => no cap\n    //bit 152-167 liquidation protocol fee\n    //bit 168-175 eMode category\n    //bit 176-211 unbacked mint cap in whole tokens, unbackedMintCap == 0 => minting disabled\n    //bit 212-251 debt ceiling for isolation mode with (ReserveConfiguration::DEBT_CEILING_DECIMALS) decimals\n    //bit 252-255 unused\n\n    uint256 data;\n  }\n\n  struct UserConfigurationMap {\n    /**\n     * @dev Bitmap of the users collaterals and borrows. It is divided in pairs of bits, one pair per asset.\n     * The first bit indicates if an asset is used as collateral by the user, the second whether an\n     * asset is borrowed by the user.\n     */\n    uint256 data;\n  }\n\n  struct EModeCategory {\n    // each eMode category has a custom ltv and liquidation threshold\n    uint16 ltv;\n    uint16 liquidationThreshold;\n    uint16 liquidationBonus;\n    // each eMode category may or may not have a custom oracle to override the individual assets price oracles\n    address priceSource;\n    string label;\n  }\n\n  enum InterestRateMode {NONE, STABLE, VARIABLE}\n\n  struct ReserveCache {\n    uint256 currScaledVariableDebt;\n    uint256 nextScaledVariableDebt;\n    uint256 currPrincipalStableDebt;\n    uint256 currAvgStableBorrowRate;\n    uint256 currTotalStableDebt;\n    uint256 nextAvgStableBorrowRate;\n    uint256 nextTotalStableDebt;\n    uint256 currLiquidityIndex;\n    uint256 nextLiquidityIndex;\n    uint256 currVariableBorrowIndex;\n    uint256 nextVariableBorrowIndex;\n    uint256 currLiquidityRate;\n    uint256 currVariableBorrowRate;\n    uint256 reserveFactor;\n    ReserveConfigurationMap reserveConfiguration;\n    address aTokenAddress;\n    address stableDebtTokenAddress;\n    address variableDebtTokenAddress;\n    uint40 reserveLastUpdateTimestamp;\n    uint40 stableDebtLastUpdateTimestamp;\n  }\n\n  struct ExecuteLiquidationCallParams {\n    uint256 reservesCount;\n    uint256 debtToCover;\n    address collateralAsset;\n    address debtAsset;\n    address user;\n    bool receiveAToken;\n    address priceOracle;\n    uint8 userEModeCategory;\n    address priceOracleSentinel;\n  }\n\n  struct ExecuteSupplyParams {\n    address asset;\n    uint256 amount;\n    address onBehalfOf;\n    uint16 referralCode;\n  }\n\n  struct ExecuteBorrowParams {\n    address asset;\n    address user;\n    address onBehalfOf;\n    uint256 amount;\n    InterestRateMode interestRateMode;\n    uint16 referralCode;\n    bool releaseUnderlying;\n    uint256 maxStableRateBorrowSizePercent;\n    uint256 reservesCount;\n    address oracle;\n    uint8 userEModeCategory;\n    address priceOracleSentinel;\n  }\n\n  struct ExecuteRepayParams {\n    address asset;\n    uint256 amount;\n    InterestRateMode interestRateMode;\n    address onBehalfOf;\n    bool useATokens;\n  }\n\n  struct ExecuteWithdrawParams {\n    address asset;\n    uint256 amount;\n    address to;\n    uint256 reservesCount;\n    address oracle;\n    uint8 userEModeCategory;\n  }\n\n  struct ExecuteSetUserEModeParams {\n    uint256 reservesCount;\n    address oracle;\n    uint8 categoryId;\n  }\n\n  struct FinalizeTransferParams {\n    address asset;\n    address from;\n    address to;\n    uint256 amount;\n    uint256 balanceFromBefore;\n    uint256 balanceToBefore;\n    uint256 reservesCount;\n    address oracle;\n    uint8 fromEModeCategory;\n  }\n\n  struct FlashloanParams {\n    address receiverAddress;\n    address[] assets;\n    uint256[] amounts;\n    uint256[] interestRateModes;\n    address onBehalfOf;\n    bytes params;\n    uint16 referralCode;\n    uint256 flashLoanPremiumToProtocol;\n    uint256 flashLoanPremiumTotal;\n    uint256 maxStableRateBorrowSizePercent;\n    uint256 reservesCount;\n    address addressesProvider;\n    address pool;\n    uint8 userEModeCategory;\n    bool isAuthorizedFlashBorrower;\n  }\n\n  struct FlashloanSimpleParams {\n    address receiverAddress;\n    address asset;\n    uint256 amount;\n    bytes params;\n    uint16 referralCode;\n    uint256 flashLoanPremiumToProtocol;\n    uint256 flashLoanPremiumTotal;\n  }\n\n  struct FlashLoanRepaymentParams {\n    uint256 amount;\n    uint256 totalPremium;\n    uint256 flashLoanPremiumToProtocol;\n    address asset;\n    address receiverAddress;\n    uint16 referralCode;\n  }\n\n  struct CalculateUserAccountDataParams {\n    UserConfigurationMap userConfig;\n    uint256 reservesCount;\n    address user;\n    address oracle;\n    uint8 userEModeCategory;\n  }\n\n  struct ValidateBorrowParams {\n    ReserveCache reserveCache;\n    UserConfigurationMap userConfig;\n    address asset;\n    address userAddress;\n    uint256 amount;\n    InterestRateMode interestRateMode;\n    uint256 maxStableLoanPercent;\n    uint256 reservesCount;\n    address oracle;\n    uint8 userEModeCategory;\n    address priceOracleSentinel;\n    bool isolationModeActive;\n    address isolationModeCollateralAddress;\n    uint256 isolationModeDebtCeiling;\n  }\n\n  struct ValidateLiquidationCallParams {\n    ReserveCache debtReserveCache;\n    uint256 totalDebt;\n    uint256 healthFactor;\n    address priceOracleSentinel;\n  }\n\n  struct CalculateInterestRatesParams {\n    uint256 unbacked;\n    uint256 liquidityAdded;\n    uint256 liquidityTaken;\n    uint256 totalStableDebt;\n    uint256 totalVariableDebt;\n    uint256 averageStableBorrowRate;\n    uint256 reserveFactor;\n    address reserve;\n    address aToken;\n  }\n\n  struct InitReserveParams {\n    address asset;\n    address aTokenAddress;\n    address stableDebtAddress;\n    address variableDebtAddress;\n    address interestRateStrategyAddress;\n    uint16 reservesCount;\n    uint16 maxNumberReserves;\n  }\n}\n"
    },
    "lib/sparklend-v1-core/contracts/protocol/libraries/types/ConfiguratorInputTypes.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nlibrary ConfiguratorInputTypes {\n  struct InitReserveInput {\n    address aTokenImpl;\n    address stableDebtTokenImpl;\n    address variableDebtTokenImpl;\n    uint8 underlyingAssetDecimals;\n    address interestRateStrategyAddress;\n    address underlyingAsset;\n    address treasury;\n    address incentivesController;\n    string aTokenName;\n    string aTokenSymbol;\n    string variableDebtTokenName;\n    string variableDebtTokenSymbol;\n    string stableDebtTokenName;\n    string stableDebtTokenSymbol;\n    bytes params;\n  }\n\n  struct UpdateATokenInput {\n    address asset;\n    address treasury;\n    address incentivesController;\n    string name;\n    string symbol;\n    address implementation;\n    bytes params;\n  }\n\n  struct UpdateDebtTokenInput {\n    address asset;\n    address incentivesController;\n    string name;\n    string symbol;\n    address implementation;\n    bytes params;\n  }\n}\n"
    },
    "lib/sparklend-v1-core/contracts/interfaces/IPriceOracleGetter.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\n/**\n * @title IPriceOracleGetter\n * @author Aave\n * @notice Interface for the Aave price oracle.\n */\ninterface IPriceOracleGetter {\n  /**\n   * @notice Returns the base currency address\n   * @dev Address 0x0 is reserved for USD as base currency.\n   * @return Returns the base currency address.\n   */\n  function BASE_CURRENCY() external view returns (address);\n\n  /**\n   * @notice Returns the base currency unit\n   * @dev 1 ether for ETH, 1e8 for USD.\n   * @return Returns the base currency unit.\n   */\n  function BASE_CURRENCY_UNIT() external view returns (uint256);\n\n  /**\n   * @notice Returns the asset price in the base currency\n   * @param asset The address of the asset\n   * @return The price of the asset\n   */\n  function getAssetPrice(address asset) external view returns (uint256);\n}\n"
    },
    "lib/sparklend-v1-core/contracts/interfaces/IReserveInterestRateStrategy.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\nimport {DataTypes} from '../protocol/libraries/types/DataTypes.sol';\n\n/**\n * @title IReserveInterestRateStrategy\n * @author Aave\n * @notice Interface for the calculation of the interest rates\n */\ninterface IReserveInterestRateStrategy {\n  /**\n   * @notice Calculates the interest rates depending on the reserve's state and configurations\n   * @param params The parameters needed to calculate interest rates\n   * @return liquidityRate The liquidity rate expressed in rays\n   * @return stableBorrowRate The stable borrow rate expressed in rays\n   * @return variableBorrowRate The variable borrow rate expressed in rays\n   */\n  function calculateInterestRates(\n    DataTypes.CalculateInterestRatesParams memory params\n  ) external view returns (uint256, uint256, uint256);\n}\n"
    },
    "lib/spark-alm-controller/lib/aave-v3-origin/src/core/contracts/interfaces/IAaveIncentivesController.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title IAaveIncentivesController\n * @author Aave\n * @notice Defines the basic interface for an Aave Incentives Controller.\n * @dev It only contains one single function, needed as a hook on aToken and debtToken transfers.\n */\ninterface IAaveIncentivesController {\n  /**\n   * @dev Called by the corresponding asset on transfer hook in order to update the rewards distribution.\n   * @dev The units of `totalSupply` and `userBalance` should be the same.\n   * @param user The address of the user whose asset balance has changed\n   * @param totalSupply The total supply of the asset prior to user balance change\n   * @param userBalance The previous user balance prior to balance change\n   */\n  function handleAction(address user, uint256 totalSupply, uint256 userBalance) external;\n}\n"
    },
    "lib/metamorpho/lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "lib/metamorpho/lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "lib/spark-alm-controller/lib/aave-v3-origin/src/core/contracts/interfaces/IPoolAddressesProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title IPoolAddressesProvider\n * @author Aave\n * @notice Defines the basic interface for a Pool Addresses Provider.\n */\ninterface IPoolAddressesProvider {\n  /**\n   * @dev Emitted when the market identifier is updated.\n   * @param oldMarketId The old id of the market\n   * @param newMarketId The new id of the market\n   */\n  event MarketIdSet(string indexed oldMarketId, string indexed newMarketId);\n\n  /**\n   * @dev Emitted when the pool is updated.\n   * @param oldAddress The old address of the Pool\n   * @param newAddress The new address of the Pool\n   */\n  event PoolUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the pool configurator is updated.\n   * @param oldAddress The old address of the PoolConfigurator\n   * @param newAddress The new address of the PoolConfigurator\n   */\n  event PoolConfiguratorUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the price oracle is updated.\n   * @param oldAddress The old address of the PriceOracle\n   * @param newAddress The new address of the PriceOracle\n   */\n  event PriceOracleUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the ACL manager is updated.\n   * @param oldAddress The old address of the ACLManager\n   * @param newAddress The new address of the ACLManager\n   */\n  event ACLManagerUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the ACL admin is updated.\n   * @param oldAddress The old address of the ACLAdmin\n   * @param newAddress The new address of the ACLAdmin\n   */\n  event ACLAdminUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the price oracle sentinel is updated.\n   * @param oldAddress The old address of the PriceOracleSentinel\n   * @param newAddress The new address of the PriceOracleSentinel\n   */\n  event PriceOracleSentinelUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the pool data provider is updated.\n   * @param oldAddress The old address of the PoolDataProvider\n   * @param newAddress The new address of the PoolDataProvider\n   */\n  event PoolDataProviderUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when a new proxy is created.\n   * @param id The identifier of the proxy\n   * @param proxyAddress The address of the created proxy contract\n   * @param implementationAddress The address of the implementation contract\n   */\n  event ProxyCreated(\n    bytes32 indexed id,\n    address indexed proxyAddress,\n    address indexed implementationAddress\n  );\n\n  /**\n   * @dev Emitted when a new non-proxied contract address is registered.\n   * @param id The identifier of the contract\n   * @param oldAddress The address of the old contract\n   * @param newAddress The address of the new contract\n   */\n  event AddressSet(bytes32 indexed id, address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the implementation of the proxy registered with id is updated\n   * @param id The identifier of the contract\n   * @param proxyAddress The address of the proxy contract\n   * @param oldImplementationAddress The address of the old implementation contract\n   * @param newImplementationAddress The address of the new implementation contract\n   */\n  event AddressSetAsProxy(\n    bytes32 indexed id,\n    address indexed proxyAddress,\n    address oldImplementationAddress,\n    address indexed newImplementationAddress\n  );\n\n  /**\n   * @notice Returns the id of the Aave market to which this contract points to.\n   * @return The market id\n   */\n  function getMarketId() external view returns (string memory);\n\n  /**\n   * @notice Associates an id with a specific PoolAddressesProvider.\n   * @dev This can be used to create an onchain registry of PoolAddressesProviders to\n   * identify and validate multiple Aave markets.\n   * @param newMarketId The market id\n   */\n  function setMarketId(string calldata newMarketId) external;\n\n  /**\n   * @notice Returns an address by its identifier.\n   * @dev The returned address might be an EOA or a contract, potentially proxied\n   * @dev It returns ZERO if there is no registered address with the given id\n   * @param id The id\n   * @return The address of the registered for the specified id\n   */\n  function getAddress(bytes32 id) external view returns (address);\n\n  /**\n   * @notice General function to update the implementation of a proxy registered with\n   * certain `id`. If there is no proxy registered, it will instantiate one and\n   * set as implementation the `newImplementationAddress`.\n   * @dev IMPORTANT Use this function carefully, only for ids that don't have an explicit\n   * setter function, in order to avoid unexpected consequences\n   * @param id The id\n   * @param newImplementationAddress The address of the new implementation\n   */\n  function setAddressAsProxy(bytes32 id, address newImplementationAddress) external;\n\n  /**\n   * @notice Sets an address for an id replacing the address saved in the addresses map.\n   * @dev IMPORTANT Use this function carefully, as it will do a hard replacement\n   * @param id The id\n   * @param newAddress The address to set\n   */\n  function setAddress(bytes32 id, address newAddress) external;\n\n  /**\n   * @notice Returns the address of the Pool proxy.\n   * @return The Pool proxy address\n   */\n  function getPool() external view returns (address);\n\n  /**\n   * @notice Updates the implementation of the Pool, or creates a proxy\n   * setting the new `pool` implementation when the function is called for the first time.\n   * @param newPoolImpl The new Pool implementation\n   */\n  function setPoolImpl(address newPoolImpl) external;\n\n  /**\n   * @notice Returns the address of the PoolConfigurator proxy.\n   * @return The PoolConfigurator proxy address\n   */\n  function getPoolConfigurator() external view returns (address);\n\n  /**\n   * @notice Updates the implementation of the PoolConfigurator, or creates a proxy\n   * setting the new `PoolConfigurator` implementation when the function is called for the first time.\n   * @param newPoolConfiguratorImpl The new PoolConfigurator implementation\n   */\n  function setPoolConfiguratorImpl(address newPoolConfiguratorImpl) external;\n\n  /**\n   * @notice Returns the address of the price oracle.\n   * @return The address of the PriceOracle\n   */\n  function getPriceOracle() external view returns (address);\n\n  /**\n   * @notice Updates the address of the price oracle.\n   * @param newPriceOracle The address of the new PriceOracle\n   */\n  function setPriceOracle(address newPriceOracle) external;\n\n  /**\n   * @notice Returns the address of the ACL manager.\n   * @return The address of the ACLManager\n   */\n  function getACLManager() external view returns (address);\n\n  /**\n   * @notice Updates the address of the ACL manager.\n   * @param newAclManager The address of the new ACLManager\n   */\n  function setACLManager(address newAclManager) external;\n\n  /**\n   * @notice Returns the address of the ACL admin.\n   * @return The address of the ACL admin\n   */\n  function getACLAdmin() external view returns (address);\n\n  /**\n   * @notice Updates the address of the ACL admin.\n   * @param newAclAdmin The address of the new ACL admin\n   */\n  function setACLAdmin(address newAclAdmin) external;\n\n  /**\n   * @notice Returns the address of the price oracle sentinel.\n   * @return The address of the PriceOracleSentinel\n   */\n  function getPriceOracleSentinel() external view returns (address);\n\n  /**\n   * @notice Updates the address of the price oracle sentinel.\n   * @param newPriceOracleSentinel The address of the new PriceOracleSentinel\n   */\n  function setPriceOracleSentinel(address newPriceOracleSentinel) external;\n\n  /**\n   * @notice Returns the address of the data provider.\n   * @return The address of the DataProvider\n   */\n  function getPoolDataProvider() external view returns (address);\n\n  /**\n   * @notice Updates the address of the data provider.\n   * @param newDataProvider The address of the new DataProvider\n   */\n  function setPoolDataProvider(address newDataProvider) external;\n}\n"
    },
    "lib/spark-alm-controller/lib/aave-v3-origin/src/core/contracts/protocol/libraries/types/DataTypes.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nlibrary DataTypes {\n  /**\n   * This exists specifically to maintain the `getReserveData()` interface, since the new, internal\n   * `ReserveData` struct includes the reserve's `virtualUnderlyingBalance`.\n   */\n  struct ReserveDataLegacy {\n    //stores the reserve configuration\n    ReserveConfigurationMap configuration;\n    //the liquidity index. Expressed in ray\n    uint128 liquidityIndex;\n    //the current supply rate. Expressed in ray\n    uint128 currentLiquidityRate;\n    //variable borrow index. Expressed in ray\n    uint128 variableBorrowIndex;\n    //the current variable borrow rate. Expressed in ray\n    uint128 currentVariableBorrowRate;\n    //the current stable borrow rate. Expressed in ray\n    uint128 currentStableBorrowRate;\n    //timestamp of last update\n    uint40 lastUpdateTimestamp;\n    //the id of the reserve. Represents the position in the list of the active reserves\n    uint16 id;\n    //aToken address\n    address aTokenAddress;\n    //stableDebtToken address\n    address stableDebtTokenAddress;\n    //variableDebtToken address\n    address variableDebtTokenAddress;\n    //address of the interest rate strategy\n    address interestRateStrategyAddress;\n    //the current treasury balance, scaled\n    uint128 accruedToTreasury;\n    //the outstanding unbacked aTokens minted through the bridging feature\n    uint128 unbacked;\n    //the outstanding debt borrowed against this asset in isolation mode\n    uint128 isolationModeTotalDebt;\n  }\n\n  struct ReserveData {\n    //stores the reserve configuration\n    ReserveConfigurationMap configuration;\n    //the liquidity index. Expressed in ray\n    uint128 liquidityIndex;\n    //the current supply rate. Expressed in ray\n    uint128 currentLiquidityRate;\n    //variable borrow index. Expressed in ray\n    uint128 variableBorrowIndex;\n    //the current variable borrow rate. Expressed in ray\n    uint128 currentVariableBorrowRate;\n    //the current stable borrow rate. Expressed in ray\n    uint128 currentStableBorrowRate;\n    //timestamp of last update\n    uint40 lastUpdateTimestamp;\n    //the id of the reserve. Represents the position in the list of the active reserves\n    uint16 id;\n    //timestamp until when liquidations are not allowed on the reserve, if set to past liquidations will be allowed\n    uint40 liquidationGracePeriodUntil;\n    //aToken address\n    address aTokenAddress;\n    //stableDebtToken address\n    address stableDebtTokenAddress;\n    //variableDebtToken address\n    address variableDebtTokenAddress;\n    //address of the interest rate strategy\n    address interestRateStrategyAddress;\n    //the current treasury balance, scaled\n    uint128 accruedToTreasury;\n    //the outstanding unbacked aTokens minted through the bridging feature\n    uint128 unbacked;\n    //the outstanding debt borrowed against this asset in isolation mode\n    uint128 isolationModeTotalDebt;\n    //the amount of underlying accounted for by the protocol\n    uint128 virtualUnderlyingBalance;\n  }\n\n  struct ReserveConfigurationMap {\n    //bit 0-15: LTV\n    //bit 16-31: Liq. threshold\n    //bit 32-47: Liq. bonus\n    //bit 48-55: Decimals\n    //bit 56: reserve is active\n    //bit 57: reserve is frozen\n    //bit 58: borrowing is enabled\n    //bit 59: stable rate borrowing enabled\n    //bit 60: asset is paused\n    //bit 61: borrowing in isolation mode is enabled\n    //bit 62: siloed borrowing enabled\n    //bit 63: flashloaning enabled\n    //bit 64-79: reserve factor\n    //bit 80-115: borrow cap in whole tokens, borrowCap == 0 => no cap\n    //bit 116-151: supply cap in whole tokens, supplyCap == 0 => no cap\n    //bit 152-167: liquidation protocol fee\n    //bit 168-175: eMode category\n    //bit 176-211: unbacked mint cap in whole tokens, unbackedMintCap == 0 => minting disabled\n    //bit 212-251: debt ceiling for isolation mode with (ReserveConfiguration::DEBT_CEILING_DECIMALS) decimals\n    //bit 252: virtual accounting is enabled for the reserve\n    //bit 253-255 unused\n\n    uint256 data;\n  }\n\n  struct UserConfigurationMap {\n    /**\n     * @dev Bitmap of the users collaterals and borrows. It is divided in pairs of bits, one pair per asset.\n     * The first bit indicates if an asset is used as collateral by the user, the second whether an\n     * asset is borrowed by the user.\n     */\n    uint256 data;\n  }\n\n  struct EModeCategory {\n    // each eMode category has a custom ltv and liquidation threshold\n    uint16 ltv;\n    uint16 liquidationThreshold;\n    uint16 liquidationBonus;\n    // each eMode category may or may not have a custom oracle to override the individual assets price oracles\n    address priceSource;\n    string label;\n  }\n\n  enum InterestRateMode {\n    NONE,\n    STABLE,\n    VARIABLE\n  }\n\n  struct ReserveCache {\n    uint256 currScaledVariableDebt;\n    uint256 nextScaledVariableDebt;\n    uint256 currPrincipalStableDebt;\n    uint256 currAvgStableBorrowRate;\n    uint256 currTotalStableDebt;\n    uint256 nextAvgStableBorrowRate;\n    uint256 nextTotalStableDebt;\n    uint256 currLiquidityIndex;\n    uint256 nextLiquidityIndex;\n    uint256 currVariableBorrowIndex;\n    uint256 nextVariableBorrowIndex;\n    uint256 currLiquidityRate;\n    uint256 currVariableBorrowRate;\n    uint256 reserveFactor;\n    ReserveConfigurationMap reserveConfiguration;\n    address aTokenAddress;\n    address stableDebtTokenAddress;\n    address variableDebtTokenAddress;\n    uint40 reserveLastUpdateTimestamp;\n    uint40 stableDebtLastUpdateTimestamp;\n  }\n\n  struct ExecuteLiquidationCallParams {\n    uint256 reservesCount;\n    uint256 debtToCover;\n    address collateralAsset;\n    address debtAsset;\n    address user;\n    bool receiveAToken;\n    address priceOracle;\n    uint8 userEModeCategory;\n    address priceOracleSentinel;\n  }\n\n  struct ExecuteSupplyParams {\n    address asset;\n    uint256 amount;\n    address onBehalfOf;\n    uint16 referralCode;\n  }\n\n  struct ExecuteBorrowParams {\n    address asset;\n    address user;\n    address onBehalfOf;\n    uint256 amount;\n    InterestRateMode interestRateMode;\n    uint16 referralCode;\n    bool releaseUnderlying;\n    uint256 maxStableRateBorrowSizePercent;\n    uint256 reservesCount;\n    address oracle;\n    uint8 userEModeCategory;\n    address priceOracleSentinel;\n  }\n\n  struct ExecuteRepayParams {\n    address asset;\n    uint256 amount;\n    InterestRateMode interestRateMode;\n    address onBehalfOf;\n    bool useATokens;\n  }\n\n  struct ExecuteWithdrawParams {\n    address asset;\n    uint256 amount;\n    address to;\n    uint256 reservesCount;\n    address oracle;\n    uint8 userEModeCategory;\n  }\n\n  struct ExecuteSetUserEModeParams {\n    uint256 reservesCount;\n    address oracle;\n    uint8 categoryId;\n  }\n\n  struct FinalizeTransferParams {\n    address asset;\n    address from;\n    address to;\n    uint256 amount;\n    uint256 balanceFromBefore;\n    uint256 balanceToBefore;\n    uint256 reservesCount;\n    address oracle;\n    uint8 fromEModeCategory;\n  }\n\n  struct FlashloanParams {\n    address receiverAddress;\n    address[] assets;\n    uint256[] amounts;\n    uint256[] interestRateModes;\n    address onBehalfOf;\n    bytes params;\n    uint16 referralCode;\n    uint256 flashLoanPremiumToProtocol;\n    uint256 flashLoanPremiumTotal;\n    uint256 maxStableRateBorrowSizePercent;\n    uint256 reservesCount;\n    address addressesProvider;\n    address pool;\n    uint8 userEModeCategory;\n    bool isAuthorizedFlashBorrower;\n  }\n\n  struct FlashloanSimpleParams {\n    address receiverAddress;\n    address asset;\n    uint256 amount;\n    bytes params;\n    uint16 referralCode;\n    uint256 flashLoanPremiumToProtocol;\n    uint256 flashLoanPremiumTotal;\n  }\n\n  struct FlashLoanRepaymentParams {\n    uint256 amount;\n    uint256 totalPremium;\n    uint256 flashLoanPremiumToProtocol;\n    address asset;\n    address receiverAddress;\n    uint16 referralCode;\n  }\n\n  struct CalculateUserAccountDataParams {\n    UserConfigurationMap userConfig;\n    uint256 reservesCount;\n    address user;\n    address oracle;\n    uint8 userEModeCategory;\n  }\n\n  struct ValidateBorrowParams {\n    ReserveCache reserveCache;\n    UserConfigurationMap userConfig;\n    address asset;\n    address userAddress;\n    uint256 amount;\n    InterestRateMode interestRateMode;\n    uint256 maxStableLoanPercent;\n    uint256 reservesCount;\n    address oracle;\n    uint8 userEModeCategory;\n    address priceOracleSentinel;\n    bool isolationModeActive;\n    address isolationModeCollateralAddress;\n    uint256 isolationModeDebtCeiling;\n  }\n\n  struct ValidateLiquidationCallParams {\n    ReserveCache debtReserveCache;\n    uint256 totalDebt;\n    uint256 healthFactor;\n    address priceOracleSentinel;\n  }\n\n  struct CalculateInterestRatesParams {\n    uint256 unbacked;\n    uint256 liquidityAdded;\n    uint256 liquidityTaken;\n    uint256 totalStableDebt;\n    uint256 totalVariableDebt;\n    uint256 averageStableBorrowRate;\n    uint256 reserveFactor;\n    address reserve;\n    bool usingVirtualBalance;\n    uint256 virtualUnderlyingBalance;\n  }\n\n  struct InitReserveParams {\n    address asset;\n    address aTokenAddress;\n    address stableDebtAddress;\n    address variableDebtAddress;\n    address interestRateStrategyAddress;\n    uint16 reservesCount;\n    uint16 maxNumberReserves;\n  }\n}\n"
    },
    "lib/forge-std/src/interfaces/IERC7575.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2;\n\nimport {IERC165} from \"./IERC165.sol\";\n\n/// @dev Interface of the ERC7575 \"Multi-Asset ERC-4626 Vaults\", as defined in\n/// https://eips.ethereum.org/EIPS/eip-7575\ninterface IERC7575 is IERC165 {\n    event Deposit(address indexed sender, address indexed owner, uint256 assets, uint256 shares);\n    event Withdraw(\n        address indexed sender, address indexed receiver, address indexed owner, uint256 assets, uint256 shares\n    );\n\n    /**\n     * @dev Returns the address of the underlying token used for the Vault for accounting, depositing, and withdrawing.\n     *\n     * - MUST be an ERC-20 token contract.\n     * - MUST NOT revert.\n     */\n    function asset() external view returns (address assetTokenAddress);\n\n    /**\n     * @dev Returns the address of the share token\n     *\n     * - MUST be an ERC-20 token contract.\n     * - MUST NOT revert.\n     */\n    function share() external view returns (address shareTokenAddress);\n\n    /**\n     * @dev Returns the amount of shares that the Vault would exchange for the amount of assets provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert.\n     *\n     * NOTE: This calculation MAY NOT reflect the per-user price-per-share, and instead should reflect the\n     * average-users price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n    function convertToShares(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Returns the amount of assets that the Vault would exchange for the amount of shares provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert.\n     *\n     * NOTE: This calculation MAY NOT reflect the per-user price-per-share, and instead should reflect the\n     * average-users price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n    function convertToAssets(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Returns the total amount of the underlying asset that is managed by Vault.\n     *\n     * - SHOULD include any compounding that occurs from yield.\n     * - MUST be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT revert.\n     */\n    function totalAssets() external view returns (uint256 totalManagedAssets);\n\n    /**\n     * @dev Returns the maximum amount of the underlying asset that can be deposited into the Vault for the receiver,\n     * through a deposit call.\n     *\n     * - MUST return a limited value if receiver is subject to some deposit limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of assets that may be deposited.\n     * - MUST NOT revert.\n     */\n    function maxDeposit(address receiver) external view returns (uint256 maxAssets);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their deposit at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of Vault shares that would be minted in a deposit\n     *   call in the same transaction. I.e. deposit should return the same or more shares as previewDeposit if called\n     *   in the same transaction.\n     * - MUST NOT account for deposit limits like those returned from maxDeposit and should always act as though the\n     *   deposit would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewDeposit SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n    function previewDeposit(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Mints shares Vault shares to receiver by depositing exactly amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   deposit execution, and are accounted for during deposit.\n     * - MUST revert if all of assets cannot be deposited (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vaults underlying asset token.\n     */\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\n\n    /**\n     * @dev Returns the maximum amount of the Vault shares that can be minted for the receiver, through a mint call.\n     * - MUST return a limited value if receiver is subject to some mint limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of shares that may be minted.\n     * - MUST NOT revert.\n     */\n    function maxMint(address receiver) external view returns (uint256 maxShares);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their mint at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of assets that would be deposited in a mint call\n     *   in the same transaction. I.e. mint should return the same or fewer assets as previewMint if called in the\n     *   same transaction.\n     * - MUST NOT account for mint limits like those returned from maxMint and should always act as though the mint\n     *   would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewMint SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by minting.\n     */\n    function previewMint(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the mint\n     *   execution, and are accounted for during mint.\n     * - MUST revert if all of shares cannot be minted (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vaults underlying asset token.\n     */\n    function mint(uint256 shares, address receiver) external returns (uint256 assets);\n\n    /**\n     * @dev Returns the maximum amount of the underlying asset that can be withdrawn from the owner balance in the\n     * Vault, through a withdraw call.\n     *\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n    function maxWithdraw(address owner) external view returns (uint256 maxAssets);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their withdrawal at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of Vault shares that would be burned in a withdraw\n     *   call in the same transaction. I.e. withdraw should return the same or fewer shares as previewWithdraw if\n     *   called\n     *   in the same transaction.\n     * - MUST NOT account for withdrawal limits like those returned from maxWithdraw and should always act as though\n     *   the withdrawal would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewWithdraw SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n    function previewWithdraw(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Burns shares from owner and sends exactly assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   withdraw execution, and are accounted for during withdraw.\n     * - MUST revert if all of assets cannot be withdrawn (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * Note that some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n    function withdraw(uint256 assets, address receiver, address owner) external returns (uint256 shares);\n\n    /**\n     * @dev Returns the maximum amount of Vault shares that can be redeemed from the owner balance in the Vault,\n     * through a redeem call.\n     *\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST return balanceOf(owner) if owner is not subject to any withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n    function maxRedeem(address owner) external view returns (uint256 maxShares);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their redeemption at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of assets that would be withdrawn in a redeem call\n     *   in the same transaction. I.e. redeem should return the same or more assets as previewRedeem if called in the\n     *   same transaction.\n     * - MUST NOT account for redemption limits like those returned from maxRedeem and should always act as though the\n     *   redemption would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewRedeem SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by redeeming.\n     */\n    function previewRedeem(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Burns exactly shares from owner and sends assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   redeem execution, and are accounted for during redeem.\n     * - MUST revert if all of shares cannot be redeemed (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * NOTE: some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n    function redeem(uint256 shares, address receiver, address owner) external returns (uint256 assets);\n}\n\n/// @dev Interface of the ERC20 share token, as defined in\n/// https://eips.ethereum.org/EIPS/eip-7575\ninterface IERC7575Share is IERC165 {\n    event VaultUpdate(address indexed asset, address vault);\n\n    /**\n     * @dev Returns the address of the Vault for the given asset.\n     *\n     * @param asset the ERC-20 token to deposit with into the Vault\n     */\n    function vault(address asset) external view returns (address);\n}\n"
    },
    "lib/metamorpho/lib/openzeppelin-contracts/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "lib/metamorpho/lib/openzeppelin-contracts/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "lib/erc20-helpers/src/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/*\n *  @title Interface of the ERC20 standard as defined in the EIP,\n *         including EIP-2612 permit functionality.\n */\ninterface IERC20 {\n\n    /**********************************************************************************************/\n    /*** Events                                                                                 ***/\n    /**********************************************************************************************/\n\n    /**\n     *  @dev   Emitted when one account has set the allowance of another account over their tokens.\n     *  @param owner   Account that tokens are approved from.\n     *  @param spender Account that tokens are approved for.\n     *  @param amount  Amount of tokens that have been approved.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /**\n     *  @dev   Emitted when tokens have moved from one account to another.\n     *  @param owner     Account that tokens have moved from.\n     *  @param recipient Account that tokens have moved to.\n     *  @param amount    Amount of tokens that have been transferred.\n     */\n    event Transfer(address indexed owner, address indexed recipient, uint256 amount);\n\n    /**********************************************************************************************/\n    /*** External Functions                                                                     ***/\n    /**********************************************************************************************/\n\n    /**\n     *  @dev    Function that allows one account to set the allowance of another account\n     *          over their tokens.\n     *          Emits an {Approval} event.\n     *  @param  spender Account that tokens are approved for.\n     *  @param  amount  Amount of tokens that have been approved.\n     *  @return success Boolean indicating whether the operation succeeded.\n     */\n    function approve(address spender, uint256 amount) external returns (bool success);\n\n    /**\n     *  @dev    Function that allows one account to decrease the allowance of another\n     *          account over their tokens.\n     *          Emits an {Approval} event.\n     *  @param  spender          Account that tokens are approved for.\n     *  @param  subtractedAmount Amount to decrease approval by.\n     *  @return success          Boolean indicating whether the operation succeeded.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedAmount)\n        external returns (bool success);\n\n    /**\n     *  @dev    Function that allows one account to increase the allowance of another\n     *          account over their tokens.\n     *          Emits an {Approval} event.\n     *  @param  spender     Account that tokens are approved for.\n     *  @param  addedAmount Amount to increase approval by.\n     *  @return success     Boolean indicating whether the operation succeeded.\n     */\n    function increaseAllowance(address spender, uint256 addedAmount)\n        external returns (bool success);\n\n    /**\n     *  @dev   Approve by signature.\n     *  @param owner    Owner address that signed the permit.\n     *  @param spender  Spender of the permit.\n     *  @param amount   Permit approval spend limit.\n     *  @param deadline Deadline after which the permit is invalid.\n     *  @param v        ECDSA signature v component.\n     *  @param r        ECDSA signature r component.\n     *  @param s        ECDSA signature s component.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 amount,\n        uint256 deadline,\n        uint8   v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     *  @dev    Moves an amount of tokens from `msg.sender` to a specified account.\n     *          Emits a {Transfer} event.\n     *  @param  recipient Account that receives tokens.\n     *  @param  amount    Amount of tokens that are transferred.\n     *  @return success   Boolean indicating whether the operation succeeded.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool success);\n\n    /**\n     *  @dev    Moves a pre-approved amount of tokens from a sender to a specified account.\n     *          Emits a {Transfer} event.\n     *          Emits an {Approval} event.\n     *  @param  owner     Account that tokens are moving from.\n     *  @param  recipient Account that receives tokens.\n     *  @param  amount    Amount of tokens that are transferred.\n     *  @return success   Boolean indicating whether the operation succeeded.\n     */\n    function transferFrom(address owner, address recipient, uint256 amount)\n        external returns (bool success);\n\n    /**********************************************************************************************/\n    /*** View Functions                                                                         ***/\n    /**********************************************************************************************/\n\n    /**\n     *  @dev    Returns the allowance that one account has given another over their tokens.\n     *  @param  owner     Account that tokens are approved from.\n     *  @param  spender   Account that tokens are approved for.\n     *  @return allowance Allowance that one account has given another over their tokens.\n     */\n    function allowance(address owner, address spender) external view returns (uint256 allowance);\n\n    /**\n     *  @dev    Returns the amount of tokens owned by a given account.\n     *  @param  account Account that owns the tokens.\n     *  @return balance Amount of tokens owned by a given account.\n     */\n    function balanceOf(address account) external view returns (uint256 balance);\n\n    /**\n     *  @dev    Returns the decimal precision used by the token.\n     *  @return decimals The decimal precision used by the token.\n     */\n    function decimals() external view returns (uint8 decimals);\n\n    /**\n     *  @dev    Returns the signature domain separator.\n     *  @return domainSeparator The signature domain separator.\n     */\n    function DOMAIN_SEPARATOR() external view returns (bytes32 domainSeparator);\n\n    /**\n     *  @dev    Returns the name of the token.\n     *  @return name The name of the token.\n     */\n    function name() external view returns (string memory name);\n\n    /**\n      *  @dev    Returns the nonce for the given owner.\n      *  @param  owner  The address of the owner account.\n      *  @return nonce The nonce for the given owner.\n     */\n    function nonces(address owner) external view returns (uint256 nonce);\n\n    /**\n     *  @dev    Returns the permit type hash.\n     *  @return permitTypehash The permit type hash.\n     */\n    function PERMIT_TYPEHASH() external view returns (bytes32 permitTypehash);\n\n    /**\n     *  @dev    Returns the symbol of the token.\n     *  @return symbol The symbol of the token.\n     */\n    function symbol() external view returns (string memory symbol);\n\n    /**\n     *  @dev    Returns the total amount of tokens in existence.\n     *  @return totalSupply The total amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256 totalSupply);\n\n}\n"
    },
    "lib/forge-std/src/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2;\n\ninterface IERC165 {\n    /// @notice Query if a contract implements an interface\n    /// @param interfaceID The interface identifier, as specified in ERC-165\n    /// @dev Interface identification is specified in ERC-165. This function\n    /// uses less than 30,000 gas.\n    /// @return `true` if the contract implements `interfaceID` and\n    /// `interfaceID` is not 0xffffffff, `false` otherwise\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\n}\n"
    },
    "lib/metamorpho/lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    }
  },
  "settings": {
    "remappings": [
      "morpho-blue/=lib/metamorpho/lib/morpho-blue/",
      "@openzeppelin/contracts-upgradeable/=lib/spark-alm-controller/lib/sdai/lib/openzeppelin-contracts-upgradeable/contracts/",
      "@openzeppelin/contracts/=lib/metamorpho/lib/openzeppelin-contracts/contracts/",
      "aave-v3-core/=lib/sparklend-kill-switch/lib/aave-v3-core/",
      "aave-v3-origin/=lib/spark-alm-controller/lib/aave-v3-origin/",
      "aave-v3-periphery/=lib/aave-v3-periphery/contracts/",
      "ds-test/=lib/metamorpho/lib/forge-std/lib/ds-test/src/",
      "dss-allocator/=lib/spark-alm-controller/lib/dss-allocator/",
      "dss-interfaces/=lib/spark-alm-controller/lib/dss-test/lib/dss-interfaces/src/",
      "dss-test/=lib/spark-alm-controller/lib/dss-test/src/",
      "erc20-helpers/=lib/erc20-helpers/src/",
      "erc4626-tests/=lib/metamorpho/lib/erc4626-tests/",
      "forge-std/=lib/forge-std/src/",
      "metamorpho/=lib/metamorpho/src/",
      "morpho-blue-oracles/=lib/morpho-blue-oracles/src/",
      "murky/=lib/metamorpho/lib/universal-rewards-distributor/lib/murky/src/",
      "openzeppelin-contracts-upgradeable/=lib/spark-alm-controller/lib/sdai/lib/openzeppelin-contracts-upgradeable/",
      "openzeppelin-contracts/=lib/metamorpho/lib/openzeppelin-contracts/",
      "openzeppelin-foundry-upgrades/=lib/spark-alm-controller/lib/sdai/lib/openzeppelin-foundry-upgrades/src/",
      "openzeppelin/=lib/metamorpho/lib/universal-rewards-distributor/lib/openzeppelin-contracts/contracts/",
      "sdai/=lib/spark-alm-controller/lib/sdai/",
      "solidity-stringutils/=lib/spark-alm-controller/lib/sdai/lib/openzeppelin-foundry-upgrades/lib/solidity-stringutils/",
      "solidity-utils/=lib/spark-alm-controller/lib/aave-v3-origin/lib/solidity-utils/",
      "spark-address-registry/=lib/spark-address-registry/src/",
      "spark-alm-controller/=lib/spark-alm-controller/",
      "spark-gov-relay/=lib/spark-gov-relay/",
      "spark-psm/=lib/spark-alm-controller/lib/spark-psm/",
      "sparklend-address-registry/=lib/spark-alm-controller/lib/spark-psm/lib/xchain-ssr-oracle/lib/sparklend-address-registry/",
      "sparklend-cap-automator/=lib/sparklend-cap-automator/src/",
      "sparklend-freezer/=lib/sparklend-freezer/src/",
      "sparklend-kill-switch/=lib/sparklend-kill-switch/src/",
      "sparklend-v1-core/=lib/sparklend-v1-core/",
      "token-tests/=lib/spark-alm-controller/lib/sdai/lib/token-tests/src/",
      "universal-rewards-distributor/=lib/metamorpho/lib/universal-rewards-distributor/src/",
      "usds/=lib/spark-alm-controller/lib/usds/",
      "xchain-helpers/=lib/xchain-helpers/src/",
      "xchain-ssr-oracle/=lib/spark-alm-controller/lib/spark-psm/lib/xchain-ssr-oracle/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "metadata": {
      "useLiteralContent": false,
      "bytecodeHash": "ipfs",
      "appendCBOR": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "evmVersion": "cancun",
    "viaIR": false,
    "libraries": {}
  }
}}