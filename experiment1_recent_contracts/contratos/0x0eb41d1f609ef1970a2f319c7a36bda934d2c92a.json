{{
  "language": "Solidity",
  "sources": {
    "lib/aave-umbrella/src/contracts/payloads/configEngine/UmbrellaConfigEngine.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.27;\n\nimport {IERC20} from 'openzeppelin-contracts/contracts/token/ERC20/IERC20.sol';\nimport {SafeERC20} from 'openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol';\n\nimport {Ownable} from 'openzeppelin-contracts/contracts/access/Ownable.sol';\n\nimport {IRescuableBase, RescuableBase} from 'solidity-utils/contracts/utils/RescuableBase.sol';\nimport {Rescuable} from 'solidity-utils/contracts/utils/Rescuable.sol';\n\nimport {IUmbrellaStkManager as ISMStructs, IUmbrellaConfiguration as ICStructs} from '../IUmbrellaEngineStructs.sol';\nimport {IUmbrellaEngineStructs as IStructs, IRewardsStructs as IRStructs} from '../IUmbrellaEngineStructs.sol';\n\nimport {IUmbrellaConfigEngine} from './IUmbrellaConfigEngine.sol';\n\nimport {EngineUtils} from '../utils/EngineUtils.sol';\n\nimport {IUmbrella} from '../../umbrella/interfaces/IUmbrella.sol';\n\nimport {IRewardsController} from '../../rewards/interfaces/IRewardsController.sol';\n\n/**\n * @dev Helper smart contract performing actions using internal libraries.\n *\n * ***IMPORTANT*** This engine MUST BE STATELESS always.\n *\n * Assumptions:\n *   - Only one `RewardsController` per network\n *   - Only one `Umbrella` per `Pool`\n *   - For each `Umbrella` separate `UmbrellaConfigEngine` will be deployed\n *\n * @author BGD Labs\n */\ncontract UmbrellaConfigEngine is Ownable, Rescuable, IUmbrellaConfigEngine {\n  using SafeERC20 for IERC20;\n\n  address public immutable REWARDS_CONTROLLER;\n  address public immutable UMBRELLA;\n\n  constructor(address rewardsController_, address umbrella_, address owner_) Ownable(owner_) {\n    require(rewardsController_ != address(0) && umbrella_ != address(0), ZeroAddress());\n\n    REWARDS_CONTROLLER = rewardsController_;\n    UMBRELLA = umbrella_;\n  }\n\n  /// Functions for basic and extended payloads\n  /////////////////////////////////////////////////////////////////////////////////////////\n\n  /// Umbrella\n  /////////////////////////////////////////////////////////////////////////////////////////\n\n  function executeCreateTokens(\n    ISMStructs.StakeTokenSetup[] memory configs\n  ) public returns (address[] memory) {\n    return IUmbrella(UMBRELLA).createStakeTokens(configs);\n  }\n\n  function executeUpdateUnstakeConfigs(IStructs.UnstakeConfig[] memory configs) public {\n    (\n      ISMStructs.UnstakeWindowConfig[] memory unstakeWindowConfigs,\n      ISMStructs.CooldownConfig[] memory cooldownConfigs\n    ) = EngineUtils.repackUnstakeStructs(configs);\n\n    executeChangeUnstakeWindows(unstakeWindowConfigs);\n    executeChangeCooldowns(cooldownConfigs);\n  }\n\n  function executeChangeCooldowns(ISMStructs.CooldownConfig[] memory configs) public {\n    IUmbrella(UMBRELLA).setCooldownStk(configs);\n  }\n\n  function executeChangeUnstakeWindows(ISMStructs.UnstakeWindowConfig[] memory configs) public {\n    IUmbrella(UMBRELLA).setUnstakeWindowStk(configs);\n  }\n\n  function executeRemoveSlashingConfigs(ICStructs.SlashingConfigRemoval[] memory configs) public {\n    IUmbrella(UMBRELLA).removeSlashingConfigs(configs);\n  }\n\n  function executeUpdateSlashingConfigs(ICStructs.SlashingConfigUpdate[] memory configs) public {\n    IUmbrella(UMBRELLA).updateSlashingConfigs(configs);\n  }\n\n  function executeSetDeficitOffsets(IStructs.SetDeficitOffset[] memory configs) public {\n    for (uint256 i; i < configs.length; ++i) {\n      IUmbrella(UMBRELLA).setDeficitOffset(configs[i].reserve, configs[i].newDeficitOffset);\n    }\n  }\n\n  function executeCoverPendingDeficits(IStructs.CoverDeficit[] memory configs) public {\n    for (uint256 i; i < configs.length; ++i) {\n      if (configs[i].approve) {\n        _approveBeforeCoverage(configs[i].reserve, configs[i].amount);\n      }\n\n      IUmbrella(UMBRELLA).coverPendingDeficit(configs[i].reserve, configs[i].amount);\n    }\n  }\n\n  function executeCoverDeficitOffsets(IStructs.CoverDeficit[] memory configs) public {\n    for (uint256 i; i < configs.length; ++i) {\n      if (configs[i].approve) {\n        _approveBeforeCoverage(configs[i].reserve, configs[i].amount);\n      }\n\n      IUmbrella(UMBRELLA).coverDeficitOffset(configs[i].reserve, configs[i].amount);\n    }\n  }\n\n  function executeCoverReserveDeficits(IStructs.CoverDeficit[] memory configs) public {\n    for (uint256 i; i < configs.length; ++i) {\n      if (configs[i].approve) {\n        _approveBeforeCoverage(configs[i].reserve, configs[i].amount);\n      }\n\n      IUmbrella(UMBRELLA).coverReserveDeficit(configs[i].reserve, configs[i].amount);\n    }\n  }\n\n  /// RewardsController\n  /////////////////////////////////////////////////////////////////////////////////////////\n\n  function executeConfigureStakesAndRewards(\n    IStructs.ConfigureStakeAndRewardsConfig[] memory configs\n  ) public {\n    for (uint256 i; i < configs.length; ++i) {\n      configs[i].targetLiquidity = EngineUtils.getTargetLiquidity(\n        configs[i].umbrellaStake,\n        configs[i].targetLiquidity,\n        REWARDS_CONTROLLER\n      );\n\n      EngineUtils.repackRewardConfigs(\n        configs[i].rewardConfigs,\n        configs[i].umbrellaStake,\n        REWARDS_CONTROLLER\n      );\n\n      IRewardsController(REWARDS_CONTROLLER).configureAssetWithRewards(\n        configs[i].umbrellaStake,\n        configs[i].targetLiquidity,\n        configs[i].rewardConfigs\n      );\n    }\n  }\n\n  function executeConfigureRewards(IStructs.ConfigureRewardsConfig[] memory configs) public {\n    for (uint256 i; i < configs.length; ++i) {\n      EngineUtils.repackRewardConfigs(\n        configs[i].rewardConfigs,\n        configs[i].umbrellaStake,\n        REWARDS_CONTROLLER\n      );\n\n      IRewardsController(REWARDS_CONTROLLER).configureRewards(\n        configs[i].umbrellaStake,\n        configs[i].rewardConfigs\n      );\n    }\n  }\n\n  /// Functions for extended payloads\n  /////////////////////////////////////////////////////////////////////////////////////////\n\n  function executeComplexRemovals(IStructs.TokenRemoval[] memory configs) public {\n    (\n      ICStructs.SlashingConfigRemoval[] memory slashingConfigs,\n      IStructs.ConfigureRewardsConfig[] memory rewardsConfigs\n    ) = EngineUtils.repackRemovalStructs(configs, REWARDS_CONTROLLER, UMBRELLA);\n\n    executeRemoveSlashingConfigs(slashingConfigs);\n    executeConfigureRewards(rewardsConfigs);\n\n    (\n      ISMStructs.UnstakeWindowConfig[] memory unstakeWindowConfigs,\n      ISMStructs.CooldownConfig[] memory cooldownConfigs\n    ) = EngineUtils.repackInstantUnstakeStructs(configs);\n\n    executeChangeUnstakeWindows(unstakeWindowConfigs);\n    executeChangeCooldowns(cooldownConfigs);\n  }\n\n  function executeComplexCreations(IStructs.TokenSetup[] memory configs) public {\n    address[] memory createdTokens = executeCreateTokens(EngineUtils.repackCreateStructs(configs));\n\n    (\n      ICStructs.SlashingConfigUpdate[] memory slashingConfigs,\n      IStructs.ConfigureStakeAndRewardsConfig[] memory rewardConfigs\n    ) = EngineUtils.repackInitStructs(configs, createdTokens);\n\n    executeUpdateSlashingConfigs(slashingConfigs);\n    executeConfigureStakesAndRewards(rewardConfigs);\n\n    executeSetDeficitOffsets(EngineUtils.repackDeficitIncreaseStructs(configs, UMBRELLA));\n  }\n\n  /////////////////////////////////////////////////////////////////////////////////////////\n\n  function whoCanRescue() public view override returns (address) {\n    return owner();\n  }\n\n  function maxRescue(\n    address\n  ) public pure override(IRescuableBase, RescuableBase) returns (uint256) {\n    return type(uint256).max;\n  }\n\n  /////////////////////////////////////////////////////////////////////////////////////////\n\n  function _approveBeforeCoverage(address reserve, uint256 amount) internal {\n    address tokenForCoverage = IUmbrella(UMBRELLA).tokenForDeficitCoverage(reserve);\n\n    IERC20(tokenForCoverage).forceApprove(UMBRELLA, amount);\n  }\n}\n"
    },
    "lib/aave-umbrella/lib/aave-v3-origin/lib/solidity-utils/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "lib/aave-umbrella/lib/aave-v3-origin/lib/solidity-utils/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC1363} from \"../../../interfaces/IERC1363.sol\";\nimport {Address} from \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC-20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    /**\n     * @dev An operation with an ERC-20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     *\n     * NOTE: If the token implements ERC-7674, this function will not modify any temporary allowance. This function\n     * only sets the \"standard\" allowance. Any temporary allowance will remain active, in addition to the value being\n     * set here.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferAndCall, with a fallback to the simple {ERC20} transfer if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            safeTransfer(token, to, value);\n        } else if (!token.transferAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferFromAndCall, with a fallback to the simple {ERC20} transferFrom if the target\n     * has no code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferFromAndCallRelaxed(\n        IERC1363 token,\n        address from,\n        address to,\n        uint256 value,\n        bytes memory data\n    ) internal {\n        if (to.code.length == 0) {\n            safeTransferFrom(token, from, to, value);\n        } else if (!token.transferFromAndCall(from, to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} approveAndCall, with a fallback to the simple {ERC20} approve if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * NOTE: When the recipient address (`to`) has no code (i.e. is an EOA), this function behaves as {forceApprove}.\n     * Opposedly, when the recipient address (`to`) has code, this function only attempts to call {ERC1363-approveAndCall}\n     * once without retrying, and relies on the returned value to be true.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function approveAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            forceApprove(token, to, value);\n        } else if (!token.approveAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturnBool} that reverts if call fails to meet the requirements.\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            let success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            // bubble errors\n            if iszero(success) {\n                let ptr := mload(0x40)\n                returndatacopy(ptr, 0, returndatasize())\n                revert(ptr, returndatasize())\n            }\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n\n        if (returnSize == 0 ? address(token).code.length == 0 : returnValue != 1) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silently catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n        return success && (returnSize == 0 ? address(token).code.length > 0 : returnValue == 1);\n    }\n}\n"
    },
    "lib/aave-umbrella/lib/aave-v3-origin/lib/solidity-utils/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "lib/aave-umbrella/lib/aave-v3-origin/lib/solidity-utils/src/contracts/utils/RescuableBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.8;\n\nimport {IERC20} from 'openzeppelin-contracts/contracts/token/ERC20/IERC20.sol';\nimport {SafeERC20} from 'openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol';\nimport {IRescuableBase} from './interfaces/IRescuableBase.sol';\n\nabstract contract RescuableBase is IRescuableBase {\n  using SafeERC20 for IERC20;\n\n  /// @inheritdoc IRescuableBase\n  function maxRescue(address erc20Token) public view virtual returns (uint256);\n\n  function _emergencyTokenTransfer(address erc20Token, address to, uint256 amount) internal {\n    uint256 max = maxRescue(erc20Token);\n    amount = max > amount ? amount : max;\n    IERC20(erc20Token).safeTransfer(to, amount);\n\n    emit ERC20Rescued(msg.sender, erc20Token, to, amount);\n  }\n\n  function _emergencyEtherTransfer(address to, uint256 amount) internal {\n    (bool success, ) = to.call{value: amount}(new bytes(0));\n    if (!success) {\n      revert EthTransferFailed();\n    }\n\n    emit NativeTokensRescued(msg.sender, to, amount);\n  }\n}\n"
    },
    "lib/aave-umbrella/lib/aave-v3-origin/lib/solidity-utils/src/contracts/utils/Rescuable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.8;\n\nimport {IERC20} from 'openzeppelin-contracts/contracts/token/ERC20/IERC20.sol';\nimport {RescuableBase} from './RescuableBase.sol';\nimport {IRescuable} from './interfaces/IRescuable.sol';\n\n/**\n * @title Rescuable\n * @author BGD Labs\n * @notice abstract contract with the methods to rescue tokens (ERC20 and native)  from a contract\n */\nabstract contract Rescuable is RescuableBase, IRescuable {\n  /// @notice modifier that checks that caller is allowed address\n  modifier onlyRescueGuardian() {\n    if (msg.sender != whoCanRescue()) {\n      revert OnlyRescueGuardian();\n    }\n    _;\n  }\n\n  /// @inheritdoc IRescuable\n  function emergencyTokenTransfer(\n    address erc20Token,\n    address to,\n    uint256 amount\n  ) external virtual onlyRescueGuardian {\n    _emergencyTokenTransfer(erc20Token, to, amount);\n  }\n\n  /// @inheritdoc IRescuable\n  function emergencyEtherTransfer(address to, uint256 amount) external virtual onlyRescueGuardian {\n    _emergencyEtherTransfer(to, amount);\n  }\n\n  function whoCanRescue() public view virtual returns (address);\n}\n"
    },
    "lib/aave-umbrella/src/contracts/payloads/IUmbrellaEngineStructs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.27;\n\nimport {IUmbrellaStkManager} from '../umbrella/interfaces/IUmbrellaStkManager.sol';\nimport {IUmbrellaConfiguration} from '../umbrella/interfaces/IUmbrellaConfiguration.sol';\n\nimport {IRewardsStructs} from '../rewards/interfaces/IRewardsStructs.sol';\n\n/**\n * @title IUmbrellaEngineStructs interface\n * @notice An interface containing structures that can be used externally.\n * @author BGD labs\n */\ninterface IUmbrellaEngineStructs {\n  /// Umbrella\n  /////////////////////////////////////////////////////////////////////////////////////////\n\n  struct UnstakeConfig {\n    /// @notice Address of the `UmbrellaStakeToken` to be configured\n    address umbrellaStake;\n    /// @notice New duration of `cooldown` to be set (could be set as `KEEP_CURRENT`)\n    uint256 newCooldown;\n    /// @notice New duration of `unstakeWindow` to be set (could be set as `KEEP_CURRENT`)\n    uint256 newUnstakeWindow;\n  }\n\n  struct SetDeficitOffset {\n    /// @notice Reserve address\n    address reserve;\n    /// @notice New amount of `deficitOffset` to set for this reserve\n    uint256 newDeficitOffset;\n  }\n\n  struct CoverDeficit {\n    /// @notice Reserve address\n    address reserve;\n    /// @notice Amount of `aToken`s (or reserve) to be eliminated\n    uint256 amount;\n    /// @notice True - make `forceApprove` for required amount of tokens, false - skip\n    bool approve;\n  }\n\n  /// RewardsController\n  /////////////////////////////////////////////////////////////////////////////////////////\n\n  struct ConfigureStakeAndRewardsConfig {\n    /// @notice Address of the `asset` to be configured/initialized\n    address umbrellaStake;\n    /// @notice Amount of liquidity where will be the maximum emission of rewards per second applied (could be set as KEEP_CURRENT)\n    uint256 targetLiquidity;\n    /// @notice Optional array of reward configs, can be empty\n    IRewardsStructs.RewardSetupConfig[] rewardConfigs;\n  }\n\n  struct ConfigureRewardsConfig {\n    /// @notice Address of the `asset` whose reward should be configured\n    address umbrellaStake;\n    /// @notice Array of structs with params to set\n    IRewardsStructs.RewardSetupConfig[] rewardConfigs;\n  }\n\n  /// Structs for extended payloads\n  /////////////////////////////////////////////////////////////////////////////////////////\n\n  struct TokenRemoval {\n    /// @notice Address of the `UmbrellaStakeToken` which should be removed from the system\n    address umbrellaStake;\n    /// @notice Address that must transfer all rewards that have not been received by users\n    address residualRewardPayer;\n  }\n\n  struct TokenSetup {\n    /// @notice `UmbrellaStakeToken`s setup config\n    IUmbrellaStkManager.StakeTokenSetup stakeSetup;\n    /// @notice Amount of liquidity where will be the maximum emission of rewards per second applied\n    uint256 targetLiquidity;\n    /// @notice Optional array of reward configs, can be empty\n    IRewardsStructs.RewardSetupConfig[] rewardConfigs;\n    /// @notice Reserve address\n    address reserve;\n    /// @notice Percentage of funds slashed on top of the new deficit\n    uint256 liquidationFee;\n    /// @notice Oracle of `UmbrellaStakeToken`s underlying\n    address umbrellaStakeUnderlyingOracle;\n    /// @notice The value by which `deficitOffset` will be increased\n    uint256 deficitOffsetIncrease;\n  }\n\n  /////////////////////////////////////////////////////////////////////////////////////////\n}\n"
    },
    "lib/aave-umbrella/src/contracts/payloads/configEngine/IUmbrellaConfigEngine.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.27;\n\nimport {IUmbrellaEngineStructs as IStructs} from '../IUmbrellaEngineStructs.sol';\nimport {IUmbrellaStkManager as ISMStructs, IUmbrellaConfiguration as ICStructs} from '../IUmbrellaEngineStructs.sol';\n\n/**\n * @title IUmbrellaConfigEngine interface\n * @notice Interface to define functions that can be called from `UmbrellaBasePayload` and `UmbrellaExtendedPayload`.\n * @author BGD labs\n */\ninterface IUmbrellaConfigEngine {\n  /// @dev Attempted to set zero address as parameter.\n  error ZeroAddress();\n\n  /// Umbrella\n  /////////////////////////////////////////////////////////////////////////////////////////\n\n  function executeCreateTokens(\n    ISMStructs.StakeTokenSetup[] memory configs\n  ) external returns (address[] memory);\n\n  function executeUpdateUnstakeConfigs(IStructs.UnstakeConfig[] memory configs) external;\n\n  function executeChangeCooldowns(ISMStructs.CooldownConfig[] memory configs) external;\n\n  function executeChangeUnstakeWindows(ISMStructs.UnstakeWindowConfig[] memory configs) external;\n\n  function executeRemoveSlashingConfigs(ICStructs.SlashingConfigRemoval[] memory configs) external;\n\n  function executeUpdateSlashingConfigs(ICStructs.SlashingConfigUpdate[] memory configs) external;\n\n  function executeSetDeficitOffsets(IStructs.SetDeficitOffset[] memory configs) external;\n\n  function executeCoverPendingDeficits(IStructs.CoverDeficit[] memory configs) external;\n\n  function executeCoverDeficitOffsets(IStructs.CoverDeficit[] memory configs) external;\n\n  function executeCoverReserveDeficits(IStructs.CoverDeficit[] memory configs) external;\n\n  /// RewardsController\n  /////////////////////////////////////////////////////////////////////////////////////////\n\n  function executeConfigureStakesAndRewards(\n    IStructs.ConfigureStakeAndRewardsConfig[] memory configs\n  ) external;\n\n  function executeConfigureRewards(IStructs.ConfigureRewardsConfig[] memory configs) external;\n\n  /// Functions for extended payloads\n  /////////////////////////////////////////////////////////////////////////////////////////\n\n  function executeComplexRemovals(IStructs.TokenRemoval[] memory configs) external;\n\n  function executeComplexCreations(IStructs.TokenSetup[] memory configs) external;\n\n  /////////////////////////////////////////////////////////////////////////////////////////\n}\n"
    },
    "lib/aave-umbrella/src/contracts/payloads/utils/EngineUtils.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.27;\n\nimport {IUmbrellaStkManager as ISMStructs, IUmbrellaConfiguration as ICStructs} from '../IUmbrellaEngineStructs.sol';\nimport {IUmbrellaEngineStructs as IStructs, IRewardsStructs as IRStructs} from '../IUmbrellaEngineStructs.sol';\n\nimport {EngineFlags} from '../EngineFlags.sol';\n\nimport {IUmbrella} from '../../umbrella/interfaces/IUmbrella.sol';\nimport {IRewardsController} from '../../rewards/interfaces/IRewardsController.sol';\n\nlibrary EngineUtils {\n  function getTargetLiquidity(\n    address umbrellaStake,\n    uint256 targetLiquidity,\n    address rewardsController\n  ) internal view returns (uint256) {\n    if (targetLiquidity == EngineFlags.KEEP_CURRENT) {\n      targetLiquidity = IRewardsController(rewardsController)\n        .getAssetData(umbrellaStake)\n        .targetLiquidity;\n    }\n\n    return targetLiquidity;\n  }\n\n  function repackRewardConfigs(\n    IRStructs.RewardSetupConfig[] memory configs,\n    address umbrellaStake,\n    address rewardsController\n  ) internal view {\n    for (uint256 i; i < configs.length; ++i) {\n      bool getEmission = configs[i].maxEmissionPerSecond == EngineFlags.KEEP_CURRENT;\n      bool getDistribution = configs[i].distributionEnd == EngineFlags.KEEP_CURRENT;\n\n      if (getEmission || getDistribution) {\n        IRStructs.RewardDataExternal memory rewardData = IRewardsController(rewardsController)\n          .getRewardData(umbrellaStake, configs[i].reward);\n\n        if (getEmission) {\n          configs[i].maxEmissionPerSecond = rewardData.maxEmissionPerSecond;\n        }\n\n        if (getDistribution) {\n          configs[i].distributionEnd = rewardData.distributionEnd;\n        }\n      }\n    }\n  }\n\n  function repackRemovalStructs(\n    IStructs.TokenRemoval[] memory configs,\n    address rewardsController,\n    address umbrella\n  )\n    internal\n    view\n    returns (ICStructs.SlashingConfigRemoval[] memory, IStructs.ConfigureRewardsConfig[] memory)\n  {\n    IStructs.ConfigureRewardsConfig[]\n      memory removeRewardsConfigs = new IStructs.ConfigureRewardsConfig[](configs.length);\n\n    ICStructs.SlashingConfigRemoval[]\n      memory removeSlashingConfigs = new ICStructs.SlashingConfigRemoval[](configs.length);\n\n    for (uint256 i; i < configs.length; ++i) {\n      removeRewardsConfigs[i] = repackRewardsRemovalStructs(configs[i], rewardsController);\n      removeSlashingConfigs[i] = repackSlashingConfigRemovalStructs(\n        configs[i].umbrellaStake,\n        umbrella\n      );\n    }\n\n    deleteStakesWithEmptyRewards(removeRewardsConfigs);\n\n    return (removeSlashingConfigs, removeRewardsConfigs);\n  }\n\n  function repackDeficitIncreaseStructs(\n    IStructs.TokenSetup[] memory configs,\n    address umbrella\n  ) internal view returns (IStructs.SetDeficitOffset[] memory) {\n    IStructs.SetDeficitOffset[]\n      memory deficitOffsetIncreaseConfigs = new IStructs.SetDeficitOffset[](configs.length);\n\n    uint256 deficitOffsetIncreaseArrayLength;\n\n    for (uint256 i; i < configs.length; ++i) {\n      if (configs[i].deficitOffsetIncrease != 0) {\n        uint256 currentDeficitOffset = IUmbrella(umbrella).getDeficitOffset(configs[i].reserve);\n\n        deficitOffsetIncreaseConfigs[deficitOffsetIncreaseArrayLength++] = IStructs\n          .SetDeficitOffset({\n            reserve: configs[i].reserve,\n            newDeficitOffset: configs[i].deficitOffsetIncrease + currentDeficitOffset\n          });\n      }\n    }\n\n    assembly {\n      mstore(deficitOffsetIncreaseConfigs, deficitOffsetIncreaseArrayLength)\n    }\n\n    return deficitOffsetIncreaseConfigs;\n  }\n\n  function repackRewardsRemovalStructs(\n    IStructs.TokenRemoval memory tokenRemoval,\n    address rewardsController\n  ) internal view returns (IStructs.ConfigureRewardsConfig memory) {\n    (, IRStructs.RewardDataExternal[] memory rewardsData) = IRewardsController(rewardsController)\n      .getAssetAndRewardsData(tokenRemoval.umbrellaStake);\n\n    IRStructs.RewardSetupConfig[] memory rewardsRemoval = new IRStructs.RewardSetupConfig[](\n      rewardsData.length\n    );\n\n    uint256 numberOfActiveRewards;\n\n    for (uint256 i; i < rewardsData.length; ++i) {\n      if (\n        rewardsData[i].maxEmissionPerSecond == 0 ||\n        rewardsData[i].distributionEnd <= block.timestamp\n      ) {\n        continue;\n      }\n\n      rewardsRemoval[numberOfActiveRewards++] = IRStructs.RewardSetupConfig({\n        reward: rewardsData[i].addr,\n        rewardPayer: tokenRemoval.residualRewardPayer,\n        maxEmissionPerSecond: 0,\n        distributionEnd: block.timestamp\n      });\n    }\n\n    assembly {\n      mstore(rewardsRemoval, numberOfActiveRewards)\n    }\n\n    return\n      IStructs.ConfigureRewardsConfig({\n        umbrellaStake: tokenRemoval.umbrellaStake,\n        rewardConfigs: rewardsRemoval\n      });\n  }\n\n  function repackSlashingConfigRemovalStructs(\n    address umbrellaStake,\n    address umbrella\n  ) internal view returns (ICStructs.SlashingConfigRemoval memory) {\n    ICStructs.StakeTokenData memory data = IUmbrella(umbrella).getStakeTokenData(umbrellaStake);\n\n    return ICStructs.SlashingConfigRemoval({reserve: data.reserve, umbrellaStake: umbrellaStake});\n  }\n\n  function repackUnstakeStructs(\n    IStructs.UnstakeConfig[] memory configs\n  )\n    internal\n    pure\n    returns (ISMStructs.UnstakeWindowConfig[] memory, ISMStructs.CooldownConfig[] memory)\n  {\n    ISMStructs.UnstakeWindowConfig[] memory unstakeConfigs = new ISMStructs.UnstakeWindowConfig[](\n      configs.length\n    );\n    ISMStructs.CooldownConfig[] memory cooldownConfigs = new ISMStructs.CooldownConfig[](\n      configs.length\n    );\n\n    uint256 unstakeConfigsToChange;\n    uint256 cooldownConfigsToChange;\n\n    for (uint256 i; i < configs.length; ++i) {\n      if (configs[i].newUnstakeWindow != EngineFlags.KEEP_CURRENT) {\n        unstakeConfigs[unstakeConfigsToChange++] = ISMStructs.UnstakeWindowConfig({\n          umbrellaStake: configs[i].umbrellaStake,\n          newUnstakeWindow: configs[i].newUnstakeWindow\n        });\n      }\n\n      if (configs[i].newCooldown != EngineFlags.KEEP_CURRENT) {\n        cooldownConfigs[cooldownConfigsToChange++] = ISMStructs.CooldownConfig({\n          umbrellaStake: configs[i].umbrellaStake,\n          newCooldown: configs[i].newCooldown\n        });\n      }\n    }\n\n    assembly {\n      mstore(unstakeConfigs, unstakeConfigsToChange)\n      mstore(cooldownConfigs, cooldownConfigsToChange)\n    }\n\n    return (unstakeConfigs, cooldownConfigs);\n  }\n\n  function repackInstantUnstakeStructs(\n    IStructs.TokenRemoval[] memory configs\n  )\n    internal\n    pure\n    returns (ISMStructs.UnstakeWindowConfig[] memory, ISMStructs.CooldownConfig[] memory)\n  {\n    ISMStructs.UnstakeWindowConfig[] memory unstakeConfigs = new ISMStructs.UnstakeWindowConfig[](\n      configs.length\n    );\n    ISMStructs.CooldownConfig[] memory cooldownConfigs = new ISMStructs.CooldownConfig[](\n      configs.length\n    );\n\n    for (uint256 i; i < configs.length; ++i) {\n      unstakeConfigs[i] = ISMStructs.UnstakeWindowConfig({\n        umbrellaStake: configs[i].umbrellaStake,\n        newUnstakeWindow: type(uint32).max\n      });\n\n      cooldownConfigs[i] = ISMStructs.CooldownConfig({\n        umbrellaStake: configs[i].umbrellaStake,\n        newCooldown: 0\n      });\n    }\n\n    return (unstakeConfigs, cooldownConfigs);\n  }\n\n  function repackCreateStructs(\n    IStructs.TokenSetup[] memory configs\n  ) internal pure returns (ISMStructs.StakeTokenSetup[] memory) {\n    ISMStructs.StakeTokenSetup[] memory createStkConfigs = new ISMStructs.StakeTokenSetup[](\n      configs.length\n    );\n\n    for (uint256 i; i < configs.length; ++i) {\n      createStkConfigs[i] = configs[i].stakeSetup;\n    }\n\n    return createStkConfigs;\n  }\n\n  function repackInitStructs(\n    IStructs.TokenSetup[] memory configs,\n    address[] memory createdTokens\n  )\n    internal\n    pure\n    returns (\n      ICStructs.SlashingConfigUpdate[] memory,\n      IStructs.ConfigureStakeAndRewardsConfig[] memory\n    )\n  {\n    ICStructs.SlashingConfigUpdate[]\n      memory initSlashingConfigs = new ICStructs.SlashingConfigUpdate[](configs.length);\n\n    IStructs.ConfigureStakeAndRewardsConfig[]\n      memory configsForStakesAndRewards = new IStructs.ConfigureStakeAndRewardsConfig[](\n        configs.length\n      );\n\n    for (uint256 i; i < configs.length; ++i) {\n      initSlashingConfigs[i] = ICStructs.SlashingConfigUpdate({\n        reserve: configs[i].reserve,\n        umbrellaStake: createdTokens[i],\n        liquidationFee: configs[i].liquidationFee,\n        umbrellaStakeUnderlyingOracle: configs[i].umbrellaStakeUnderlyingOracle\n      });\n\n      configsForStakesAndRewards[i] = IStructs.ConfigureStakeAndRewardsConfig({\n        umbrellaStake: createdTokens[i],\n        targetLiquidity: configs[i].targetLiquidity,\n        rewardConfigs: configs[i].rewardConfigs\n      });\n    }\n\n    return (initSlashingConfigs, configsForStakesAndRewards);\n  }\n\n  function deleteStakesWithEmptyRewards(\n    IStructs.ConfigureRewardsConfig[] memory configs\n  ) internal pure {\n    uint256 numberOfConfigs;\n\n    for (uint256 i; i < configs.length; ++i) {\n      if (configs[i].rewardConfigs.length == 0) {\n        continue;\n      }\n\n      configs[numberOfConfigs++] = configs[i];\n    }\n\n    assembly {\n      mstore(configs, numberOfConfigs)\n    }\n  }\n}\n"
    },
    "lib/aave-umbrella/src/contracts/umbrella/interfaces/IUmbrella.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.27;\n\nimport {IUmbrellaStkManager} from './IUmbrellaStkManager.sol';\n\ninterface IUmbrella is IUmbrellaStkManager {\n  /**\n   * @notice Event is emitted whenever the `deficitOffset` is covered on some amount.\n   * @param reserve Reserve which `deficitOffset` is covered\n   * @param amount Amount of covered `deficitOffset`\n   */\n  event DeficitOffsetCovered(address indexed reserve, uint256 amount);\n\n  /**\n   * @notice Event is emitted whenever the `pendingDeficit` is covered on some amount.\n   * @param reserve Reserve which `pendingDeficit` is covered\n   * @param amount Amount of covered `pendingDeficit`\n   */\n  event PendingDeficitCovered(address indexed reserve, uint256 amount);\n\n  /**\n   * @notice Event is emitted whenever the deficit for untuned inside `Umbrella` reserve is covered on some amount.\n   * @param reserve Reserve which `reserve.deficit` is covered\n   * @param amount Amount of covered `reserve.deficit`\n   */\n  event ReserveDeficitCovered(address indexed reserve, uint256 amount);\n\n  /**\n   * @notice Event is emitted when funds are slashed from a `umbrellaStake` to cover a reserve deficit.\n   * @param reserve Reserve address for which funds are slashed\n   * @param umbrellaStake Address of the `UmbrellaStakeToken` from which funds are transferred\n   * @param amount Amount of funds slashed for future deficit elimination\n   * @param fee Additional fee amount slashed on top of the amount\n   */\n  event StakeTokenSlashed(\n    address indexed reserve,\n    address indexed umbrellaStake,\n    uint256 amount,\n    uint256 fee\n  );\n\n  /**\n   * @dev Attempted to change `deficitOffset` for a reserve that does not have a slashing configuration.\n   */\n  error ReserveCoverageNotSetup();\n\n  /**\n   * @dev Attempted to set `deficitOffset` less than possible to avoid immediate slashing.\n   */\n  error TooMuchDeficitOffsetReduction();\n\n  /**\n   * @dev Attempted to cover zero deficit.\n   */\n  error ZeroDeficitToCover();\n\n  /**\n   * @dev Attempted to slash for reserve with zero new deficit or without `SlashingConfig` setup.\n   */\n  error CannotSlash();\n\n  /**\n   * @dev Attempted to slash a basket of `StakeToken`s. Unreachable error in the current version.\n   */\n  error NotImplemented();\n\n  /**\n   * @dev Attempted to call `coverReserveDeficit()` of reserve, which has some configuration.\n   * In this case functions `coverPendingDeficit` or `coverDeficitOffset` should be used instead.\n   */\n  error ReserveIsConfigured();\n\n  // DEFAULT_ADMIN_ROLE\n  /////////////////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @notice Sets a new `deficitOffset` value for this `reserve`.\n   * @dev `deficitOffset` can be increased arbitrarily by a value exceeding `poolDeficit - pendingDeficit`.\n   * It can also be decreased, but not less than the same value `poolDeficit - pendingDeficit`.\n   * `deficitOffset` can only be changed for reserves that have at least 1 `SlashingConfig` setup.\n   * @param reserve Reserve address\n   * @param newDeficitOffset New amount of `deficitOffset` to set for this reserve\n   */\n  function setDeficitOffset(address reserve, uint256 newDeficitOffset) external;\n\n  // COVERAGE_MANAGER_ROLE\n  /////////////////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @notice Pulls funds to resolve `pendingDeficit` **up to** specified amount.\n   * @dev If the amount exceeds the existing `pendingDeficit`, only the `pendingDeficit` will be eliminated.\n   * @param reserve Reserve address\n   * @param amount Amount of `aToken`s (or reserve) to be eliminated\n   * @return The amount of `pendingDeficit` eliminated\n   */\n  function coverPendingDeficit(address reserve, uint256 amount) external returns (uint256);\n\n  /**\n   * @notice Pulls funds to resolve `deficitOffset` **up to** specified amount.\n   * @dev If the amount exceeds the existing `deficitOffset`, only the `deficitOffset` will be eliminated.\n   * @param reserve Reserve address\n   * @param amount Amount of `aToken`s (or reserve) to be eliminated\n   * @return The amount of `deficitOffset` eliminated\n   */\n  function coverDeficitOffset(address reserve, uint256 amount) external returns (uint256);\n\n  /**\n   * @notice Pulls funds to resolve `reserve.deficit` **up to** specified amount.\n   * @dev If the amount exceeds the existing `reserve.deficit`, only the `reserve.deficit` will be eliminated.\n   * Can only be called if this reserve is not configured within `Umbrella`.\n   * (If the reserve has uncovered `deficitOffset`, `pendingDeficit` or at least one `SlashingConfig` is set, then the function will revert.\n   * In this case, to call this function you must first cover `pendingDeficit` and `deficitOffset`, along with removing all `SlashingConfig`s\n   * or use `coverPendingDeficit/coverDeficitOffset` instead.)\n   * @param reserve Reserve address\n   * @param amount Amount of `aToken`s (or reserve) to be eliminated\n   * @return The amount of `reserve.deficit` eliminated\n   */\n  function coverReserveDeficit(address reserve, uint256 amount) external returns (uint256);\n\n  /////////////////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @notice Performs a slashing to cover **up to** the `Pool.getReserveDeficit(reserve) - (pendingDeficit + deficitOffset)`.\n   * @param reserve Reserve address\n   * @return New added and covered deficit\n   */\n  function slash(address reserve) external returns (uint256);\n\n  /**\n   * @notice Returns an address of token, which should be used to cover reserve deficit.\n   * @param reserve Reserve address\n   * @return Address of token to use for deficit coverage\n   */\n  function tokenForDeficitCoverage(address reserve) external view returns (address);\n}\n"
    },
    "lib/aave-umbrella/src/contracts/rewards/interfaces/IRewardsController.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {IRewardsDistributor} from './IRewardsDistributor.sol';\n\ninterface IRewardsController is IRewardsDistributor {\n  /**\n   * @notice Event is emitted when an asset is initialized.\n   * @param asset Address of the new `asset` added\n   */\n  event AssetInitialized(address indexed asset);\n\n  /**\n   * @notice Event is emitted when a `targetLiquidity` of the `asset` is changed.\n   * @param asset Address of the `asset`\n   * @param newTargetLiquidity New amount of `targetLiquidity` set for the `asset`\n   */\n  event TargetLiquidityUpdated(address indexed asset, uint256 newTargetLiquidity);\n\n  /**\n   * @notice Event is emitted when a `lastUpdatedTimestamp` of the `asset` is updated.\n   * @param asset Address of the `asset`\n   * @param newTimestamp New value of `lastUpdatedTimestamp` updated for the `asset`\n   */\n  event LastTimestampUpdated(address indexed asset, uint256 newTimestamp);\n\n  /**\n   * @notice Event is emitted when a reward is initialized for concrete `asset`.\n   * @param asset Address of the `asset`\n   * @param reward Address of the `reward`\n   */\n  event RewardInitialized(address indexed asset, address indexed reward);\n\n  /**\n   * @notice Event is emitted when a reward config is updated.\n   * @param asset Address of the `asset`\n   * @param reward Address of the `reward`\n   * @param maxEmissionPerSecond Amount of maximum possible rewards emission per second\n   * @param distributionEnd Timestamp after which distribution ends\n   * @param rewardPayer Address from where rewards will be transferred\n   */\n  event RewardConfigUpdated(\n    address indexed asset,\n    address indexed reward,\n    uint256 maxEmissionPerSecond,\n    uint256 distributionEnd,\n    address rewardPayer\n  );\n\n  /**\n   * @notice Event is emitted when a `reward` index is updated.\n   * @param asset Address of the `asset`\n   * @param reward Address of the `reward`\n   * @param newIndex New `reward` index updated for certain `asset`\n   */\n  event RewardIndexUpdated(address indexed asset, address indexed reward, uint256 newIndex);\n\n  /**\n   * @notice Event is emitted when a user interacts with the asset (transfer, mint, burn)  or manually updates the rewards data or claims them\n   * @param asset Address of the `asset`\n   * @param reward Address of the `reward`, which `user` data is updated\n   * @param user Address of the `user` whose `reward` data is updated\n   * @param newIndex Reward index set after update\n   * @param accruedFromLastUpdate Amount of accrued rewards from last update\n   */\n  event UserDataUpdated(\n    address indexed asset,\n    address indexed reward,\n    address indexed user,\n    uint256 newIndex,\n    uint256 accruedFromLastUpdate\n  );\n\n  /**\n   * @notice Event is emitted when a `user` `reward` is claimed.\n   * @param asset Address of the `asset`, whose `reward` was claimed\n   * @param reward Address of the `reward`, which is claimed\n   * @param user Address of the `user` whose `reward` is claimed\n   * @param receiver Address of the funds receiver\n   * @param amount Amount of the received funds\n   */\n  event RewardClaimed(\n    address indexed asset,\n    address indexed reward,\n    address indexed user,\n    address receiver,\n    uint256 amount\n  );\n\n  /**\n   * @dev Attempted to update data on the `asset` before it was initialized.\n   */\n  error AssetNotInitialized(address asset);\n\n  /**\n   * @dev Attempted to change the configuration of the `reward` before it was initialized.\n   */\n  error RewardNotInitialized(address reward);\n\n  /**\n   * @dev Attempted to set `distributionEnd` less than `block.timestamp` during `reward` initialization.\n   */\n  error InvalidDistributionEnd();\n\n  /**\n   * @dev Attempted to initialize more rewards than limit.\n   */\n  error MaxRewardsLengthReached();\n\n  // DEFAULT_ADMIN_ROLE\n  /////////////////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @notice Configures asset: sets `targetLiquidity` and updates `lastUpdatedTimestamp`.\n   * If the asset has already been initialized, then updates the rewards indexes and `lastUpdatedTimestamp`,\n   * also changes `targetLiquidity`, otherwise initializes asset and rewards.\n   * @dev `targetLiquidity` should be greater than 1 whole token.\n   * `maxEmissionPerSecond` inside `rewardConfig` should be less than 1000 tokens and greater than 2 wei.\n   * It must also be greater than `targetLiquidity * 1000 / 1e18`. Check EmissionMath.sol for more info.\n   * if `maxEmissionPerSecond` is zero or `distributionEnd` is less than current `block.timestamp`,\n   * then disable distribution for this `reward` if it was previously initialized.\n   * It can't initialize already disabled reward.\n   * @param asset Address of the `asset` to be configured/initialized\n   * @param targetLiquidity Amount of liquidity where will be the maximum emission of rewards per second applied\n   * @param rewardConfigs Optional array of reward configs, can be empty\n   */\n  function configureAssetWithRewards(\n    address asset,\n    uint256 targetLiquidity,\n    RewardSetupConfig[] calldata rewardConfigs\n  ) external;\n\n  // REWARDS_ADMIN_ROLE\n  /////////////////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @notice Configures already initialized rewards for certain `asset`: sets `distributionEnd` and `maxEmissionPerSecond`.\n   * If any reward hasn't initialized before then it reverts.\n   * Before setting new configuration updates all rewards indexes for `asset`.\n   * @dev `maxEmissionPerSecond` inside `rewardConfig` should be less than 1000 tokens and greater than 2 wei.\n   * It must also be greater than `targetLiquidity * 1000 / 1e18`. Check EmissionMath.sol for more info.\n   * If `maxEmissionPerSecond` is zero or `distributionEnd` is less than the current `block.timestamp`,\n   * then distribution for this `reward` will be disabled.\n   * @param asset Address of the `asset` whose reward should be configured\n   * @param rewardConfigs Array of structs with params to set\n   */\n  function configureRewards(address asset, RewardSetupConfig[] calldata rewardConfigs) external;\n\n  /////////////////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @notice Special hook, which is called every time `StakeToken` makes `_update` or `slash`.\n   * Makes an update and calculates new `index` and `accrued`. Also updates `lastUpdateTimestamp`.\n   * @dev All variables are passed here before the actual update.\n   * @param totalSupply Total supply of `StakeToken`\n   * @param totalAssets Total assets of `StakeToken`\n   * @param user User, whose `index` and rewards accrued will be updated, if address is zero then skips user update\n   * @param userBalance Amount of `StakeToken` shares owned by user\n   */\n  function handleAction(\n    uint256 totalSupply,\n    uint256 totalAssets,\n    address user,\n    uint256 userBalance\n  ) external;\n\n  /**\n   * @notice Updates all `reward` indexes and `lastUpdateTimestamp` for the `asset`.\n   * @param asset Address of the `asset` whose rewards will be updated\n   */\n  function updateAsset(address asset) external;\n\n  /**\n   * @notice Returns an array of all initialized assets (all `StakeTokens`, which are initialized here).\n   * @dev Return zero data if assets aren't set.\n   * @return assets Array of asset addresses\n   */\n  function getAllAssets() external view returns (address[] memory assets);\n\n  /**\n   * @notice Returns an array of all initialized rewards for a certain `asset`.\n   * @dev Return zero data if asset or rewards aren't set.\n   * @param asset Address of the `asset` whose rewards should be returned\n   * @return rewards Array of reward addresses\n   */\n  function getAllRewards(address asset) external view returns (address[] memory rewards);\n\n  /**\n   * @notice Returns all data about the asset and its rewards.\n   * @dev Return zero data if asset or rewards aren't set.\n   * Function made without some gas optimizations, so it's recommended to avoid calling it often from non-view method or inside batch.\n   * If the emission for a specific reward has ended at the time of the call (i.e., block.timestamp >= distributionEnd),\n   * the function will return a zero emission, even though there may still be remaining rewards.\n   * Note that the actual reward data will be updated the next time someone manually refreshes the data or interacts with the `StakeToken`.\n   * @param asset Address of the `asset` whose params should be returned\n   * @return assetData `targetLiquidity` and `lastUpdatedTimestamp` inside struct\n   * @return rewardsData All data about rewards including addresses and `RewardData`\n   */\n  function getAssetAndRewardsData(\n    address asset\n  )\n    external\n    view\n    returns (AssetDataExternal memory assetData, RewardDataExternal[] memory rewardsData);\n\n  /**\n   * @notice Returns data about the asset.\n   * @dev Return zero data if asset isn't set.\n   * @param asset Address of the `asset` whose params should be returned\n   * @return assetData `targetLiquidity` and `lastUpdatedTimestamp` inside struct\n   */\n  function getAssetData(address asset) external view returns (AssetDataExternal memory assetData);\n\n  /**\n   * @notice Returns data about the reward.\n   * @dev Return zero data if asset or rewards aren't set.\n   * If the emission has ended at the time of the call (i.e., block.timestamp >= distributionEnd), the function will return a zero emission,\n   * even though there may still be remaining rewards.\n   * Note that the actual reward data will be updated the next time someone manually refreshes the data or interacts with the `StakeToken`.\n   * @param asset Address of the `asset` whose `reward` params should be returned\n   * @param reward Address of the `reward` whose params should be returned\n   * @return rewardData `index`, `maxEmissionPerSecond` and `distributionEnd` and address inside struct, address is duplicated from external one\n   */\n  function getRewardData(\n    address asset,\n    address reward\n  ) external view returns (RewardDataExternal memory rewardData);\n\n  /**\n   * @notice Returns data about the reward emission.\n   * @dev Return zero data if asset or rewards aren't set.\n   * If `maxEmissionPerSecond` is equal to 1 wei, then `flatEmission` will be 0, although in fact it is not 0 and emission is taken into account correctly inside the code.\n   * Here this calculation is made specifically to simplify the function behaviour.\n   * If the emission has ended at the time of the call (i.e., block.timestamp >= distributionEnd), the function will return a zero max and flat emissions,\n   * even though there may still be remaining rewards.\n   * Note that the actual reward data will be updated the next time someone manually refreshes the data or interacts with the `StakeToken`.\n   * @param asset Address of the `asset` whose `reward` emission params should be returned\n   * @param reward Address of the `reward` whose emission params should be returned\n   * @return emissionData `targetLiquidity`, `targetLiquidityExcess`, `maxEmission` and `flatEmission` inside struct\n   */\n  function getEmissionData(\n    address asset,\n    address reward\n  ) external view returns (EmissionData memory emissionData);\n\n  /**\n   * @notice Returns `user` `index` and `accrued` for all rewards for certain `asset` at the time of the last user update.\n   * If you want to get current `accrued` of all rewards, see `calculateCurrentUserRewards`.\n   * @dev Return zero data if asset or rewards aren't set.\n   * @param asset Address of the `asset` for which the rewards are accumulated\n   * @param user Address of `user` accumulating rewards\n   * @return rewards Array of `reward` addresses\n   * @return userData `index` and `accrued` inside structs\n   */\n  function getUserDataByAsset(\n    address asset,\n    address user\n  ) external view returns (address[] memory rewards, UserDataExternal[] memory userData);\n\n  /**\n   * @notice Returns `user` `index` and `accrued` for certain `asset` and `reward` at the time of the last user update.\n   * If you want to calculate current `accrued` of the `reward`, see `calculateCurrentUserReward`.\n   * @dev Return zero data if asset or rewards aren't set.\n   * @param asset Address of the `asset` for which the `reward` is accumulated\n   * @param reward Address of the accumulating `reward`\n   * @param user Address of `user` accumulating rewards\n   * @return data `index` and `accrued` inside struct\n   */\n  function getUserDataByReward(\n    address asset,\n    address reward,\n    address user\n  ) external view returns (UserDataExternal memory data);\n\n  /**\n   * @notice Returns current `reward` indexes for `asset`.\n   * @dev Return zero if asset or rewards aren't set.\n   * Function made without some gas optimizations, so it's recommended to avoid calling it often from non-view method or inside batch.\n   * @param asset Address of the `asset` whose indexes of rewards should be calculated\n   * @return rewards Array of `reward` addresses\n   * @return indexes Current indexes\n   */\n  function calculateRewardIndexes(\n    address asset\n  ) external view returns (address[] memory rewards, uint256[] memory indexes);\n\n  /**\n   * @notice Returns current `index` for certain `asset` and `reward`.\n   * @dev Return zero if asset or rewards aren't set.\n   * @param asset Address of the `asset` whose `index` of `reward` should be calculated\n   * @param reward Address of the accumulating `reward`\n   * @return index Current `index`\n   */\n  function calculateRewardIndex(\n    address asset,\n    address reward\n  ) external view returns (uint256 index);\n\n  /**\n   * @notice Returns `emissionPerSecondScaled` for certain `asset` and `reward`. Returned value scaled to 18 decimals.\n   * @dev Return zero if asset or rewards aren't set.\n   * @param asset Address of the `asset` which current emission of `reward` should be returned\n   * @param reward Address of the `reward` which `emissionPerSecond` should be returned\n   * @return emissionPerSecondScaled Current amount of rewards distributed every second (scaled to 18 decimals)\n   */\n  function calculateCurrentEmissionScaled(\n    address asset,\n    address reward\n  ) external view returns (uint256 emissionPerSecondScaled);\n\n  /**\n   * @notice  Returns `emissionPerSecond` for certain `asset` and `reward`.\n   * @dev Return zero if asset or rewards aren't set.\n   * An integer quantity is returned, although the accuracy of the calculations in reality is higher.\n   * @param asset Address of the `asset` which current emission of `reward` should be returned\n   * @param reward Address of the `reward` which `emissionPerSecond` should be returned\n   * @return emissionPerSecond Current amount of rewards distributed every second\n   */\n  function calculateCurrentEmission(\n    address asset,\n    address reward\n  ) external view returns (uint256 emissionPerSecond);\n\n  /**\n   * @notice Calculates and returns `user` `accrued` amounts for all rewards for certain `asset`.\n   * @dev Return zero data if asset or rewards aren't set.\n   * Function made without some gas optimizations, so it's recommended to avoid calling it often from non-view method or inside batch.\n   * @param asset Address of the `asset` whose rewards are accumulated\n   * @param user Address of `user` accumulating rewards\n   * @return rewards Array of `reward` addresses\n   * @return rewardsAccrued Array of current calculated `accrued` amounts\n   */\n  function calculateCurrentUserRewards(\n    address asset,\n    address user\n  ) external view returns (address[] memory rewards, uint256[] memory rewardsAccrued);\n\n  /**\n   * @notice Calculates and returns `user` `accrued` amount for certain `reward` and `asset`.\n   * @dev Return zero if asset or rewards aren't set.\n   * @param asset Address of the `asset` whose reward is accumulated\n   * @param reward Address of the `reward` that accumulates for the user\n   * @param user Address of `user` accumulating rewards\n   * @return rewardAccrued Amount of current calculated `accrued` amount\n   */\n  function calculateCurrentUserReward(\n    address asset,\n    address reward,\n    address user\n  ) external view returns (uint256 rewardAccrued);\n}\n"
    },
    "lib/aave-umbrella/lib/aave-v3-origin/lib/solidity-utils/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/interfaces/IERC1363.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (interfaces/IERC1363.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @title IERC1363\n * @dev Interface of the ERC-1363 standard as defined in the https://eips.ethereum.org/EIPS/eip-1363[ERC-1363].\n *\n * Defines an extension interface for ERC-20 tokens that supports executing code on a recipient contract\n * after `transfer` or `transferFrom`, or code on a spender contract after `approve`, in a single transaction.\n */\ninterface IERC1363 is IERC20, IERC165 {\n    /*\n     * Note: the ERC-165 identifier for this interface is 0xb0202a11.\n     * 0xb0202a11 ===\n     *   bytes4(keccak256('transferAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))\n     */\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @param data Additional data with no specified format, sent in call to `spender`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value, bytes calldata data) external returns (bool);\n}\n"
    },
    "lib/aave-umbrella/lib/aave-v3-origin/lib/solidity-utils/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Address.sol)\n\npragma solidity ^0.8.20;\n\nimport {Errors} from \"./Errors.sol\";\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert Errors.InsufficientBalance(address(this).balance, amount);\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert Errors.FailedCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {Errors.FailedCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert Errors.InsufficientBalance(address(this).balance, value);\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {Errors.FailedCall}) in case\n     * of an unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {Errors.FailedCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {Errors.FailedCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            assembly (\"memory-safe\") {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert Errors.FailedCall();\n        }\n    }\n}\n"
    },
    "lib/aave-umbrella/lib/aave-v3-origin/lib/solidity-utils/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "lib/aave-umbrella/lib/aave-v3-origin/lib/solidity-utils/src/contracts/utils/interfaces/IRescuableBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.8;\n\n/**\n * @title IRescuableBase\n * @author BGD Labs\n * @notice interface containing the objects, events and methods definitions of the RescuableBase contract\n */\ninterface IRescuableBase {\n  error EthTransferFailed();\n  /**\n   * @notice emitted when erc20 tokens get rescued\n   * @param caller address that triggers the rescue\n   * @param token address of the rescued token\n   * @param to address that will receive the rescued tokens\n   * @param amount quantity of tokens rescued\n   */\n  event ERC20Rescued(\n    address indexed caller,\n    address indexed token,\n    address indexed to,\n    uint256 amount\n  );\n\n  /**\n   * @notice emitted when native tokens get rescued\n   * @param caller address that triggers the rescue\n   * @param to address that will receive the rescued tokens\n   * @param amount quantity of tokens rescued\n   */\n  event NativeTokensRescued(address indexed caller, address indexed to, uint256 amount);\n\n  /**\n   * @notice method that defined the maximum amount rescuable for any given asset.\n   * @dev there's currently no way to limit the rescuable \"native asset\", as we assume erc20s as intended underlying.\n   * @return the maximum amount of\n   */\n  function maxRescue(address erc20Token) external view returns (uint256);\n}\n"
    },
    "lib/aave-umbrella/lib/aave-v3-origin/lib/solidity-utils/src/contracts/utils/interfaces/IRescuable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.8;\n\nimport {IRescuableBase} from './IRescuableBase.sol';\n\n/**\n * @title IRescuable\n * @author BGD Labs\n * @notice interface containing the objects, events and methods definitions of the Rescuable contract\n */\ninterface IRescuable is IRescuableBase {\n  error OnlyRescueGuardian();\n\n  /**\n   * @notice method called to rescue tokens sent erroneously to the contract. Only callable by owner\n   * @param erc20Token address of the token to rescue\n   * @param to address to send the tokens\n   * @param amount of tokens to rescue\n   */\n  function emergencyTokenTransfer(address erc20Token, address to, uint256 amount) external;\n\n  /**\n   * @notice method called to rescue ether sent erroneously to the contract. Only callable by owner\n   * @param to address to send the eth\n   * @param amount of eth to rescue\n   */\n  function emergencyEtherTransfer(address to, uint256 amount) external;\n}\n"
    },
    "lib/aave-umbrella/src/contracts/umbrella/interfaces/IUmbrellaStkManager.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.27;\n\nimport {ITransparentProxyFactory} from 'solidity-utils/contracts/transparent-proxy/interfaces/ITransparentProxyFactory.sol';\n\nimport {IUmbrellaConfiguration} from './IUmbrellaConfiguration.sol';\n\ninterface IUmbrellaStkManager is IUmbrellaConfiguration {\n  struct StakeTokenSetup {\n    /// @notice Address of the underlying token for which the `UmbrellaStakeToken` will be created\n    address underlying;\n    /// @notice Cooldown duration of the `UmbrellaStakeToken`\n    uint256 cooldown;\n    /// @notice Time period during which funds can be withdrawn from the `UmbrellaStakeToken`\n    uint256 unstakeWindow;\n    /// @notice Suffix to be added in the end to name and symbol (optional, can be empty)\n    string suffix;\n  }\n\n  struct CooldownConfig {\n    /// @notice `UmbrellaStakeToken` address\n    address umbrellaStake;\n    /// @notice Amount of seconds users have to wait between triggering the `cooldown()` and being able to withdraw funds\n    uint256 newCooldown;\n  }\n\n  struct UnstakeWindowConfig {\n    /// @notice `UmbrellaStakeToken` address\n    address umbrellaStake;\n    /// @notice Amount of seconds users have to withdraw after `cooldown`\n    uint256 newUnstakeWindow;\n  }\n\n  /**\n   * @notice Event is emitted when a new `UmbrellaStakeToken` is created.\n   * @param umbrellaStake Address of the new `UmbrellaStakeToken`\n   * @param underlying Address of the underlying token it is created for\n   * @param name Name of the new `UmbrellaStakeToken`\n   * @param symbol Symbol of the new `UmbrellaStakeToken`\n   */\n  event UmbrellaStakeTokenCreated(\n    address indexed umbrellaStake,\n    address indexed underlying,\n    string name,\n    string symbol\n  );\n\n  // DEFAULT_ADMIN_ROLE\n  /////////////////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @notice Creates new `UmbrellaStakeToken`s.\n   * @param stakeTokenSetups Array of `UmbrellaStakeToken`s setup configs\n   * @return stakeTokens Array of new `UmbrellaStakeToken`s addresses\n   */\n  function createStakeTokens(\n    StakeTokenSetup[] calldata stakeTokenSetups\n  ) external returns (address[] memory stakeTokens);\n\n  /**\n   * @notice Sets a new `cooldown`s (in seconds) for the specified `UmbrellaStakeToken`s.\n   * @param cooldownConfigs Array of new `cooldown` configs\n   */\n  function setCooldownStk(CooldownConfig[] calldata cooldownConfigs) external;\n\n  /**\n   * @notice Sets a new `unstakeWindow`s (in seconds) for the specified `UmbrellaStakeToken`s.\n   * @param unstakeWindowConfigs Array of new `unstakeWindow` configs\n   */\n  function setUnstakeWindowStk(UnstakeWindowConfig[] calldata unstakeWindowConfigs) external;\n\n  // RESCUE_GUARDIAN_ROLE\n  /////////////////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @notice Rescue tokens sent erroneously to the contract.\n   * @param stk Address of the `UmbrellaStakeToken` to rescue from\n   * @param erc20Token Address of the token to rescue\n   * @param to Address of the tokens receiver\n   * @param amount Amount of tokens to rescue\n   */\n  function emergencyTokenTransferStk(\n    address stk,\n    address erc20Token,\n    address to,\n    uint256 amount\n  ) external;\n\n  /**\n   * @notice Rescue native currency (e.g. Ethereum) sent erroneously to the contract.\n   * @param stk Address of the `UmbrellaStakeToken` to rescue from\n   * @param to Address of the tokens receiver\n   * @param amount Amount of tokens to rescue\n   */\n  function emergencyEtherTransferStk(address stk, address to, uint256 amount) external;\n\n  // PAUSE_GUARDIAN_ROLE\n  /////////////////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @notice Pauses `UmbrellaStakeToken`.\n   * @param stk Address of the `UmbrellaStakeToken` to turn pause on\n   */\n  function pauseStk(address stk) external;\n\n  /**\n   * @notice Unpauses `UmbrellaStakeToken`.\n   * @param stk Address of the `UmbrellaStakeToken` to turn pause off\n   */\n  function unpauseStk(address stk) external;\n\n  /////////////////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @notice Predicts new `UmbrellaStakeToken`s addresses.\n   * @dev Should be used only to predict new `UmbrellaStakeToken` addresses and not to calculate already deployed ones.\n   * @param stakeSetups Array of `UmbrellaStakeToken`s setup configs\n   * @return stakeTokens Array of new `UmbrellaStakeToken`s predicted addresses\n   */\n  function predictStakeTokensAddresses(\n    StakeTokenSetup[] calldata stakeSetups\n  ) external view returns (address[] memory);\n\n  /**\n   * @notice Returns a list of all the `UmbrellaStakeToken`s created via this `Umbrella` instance.\n   * @return Array of addresses containing all the `UmbrellaStakeToken`s\n   */\n  function getStkTokens() external view returns (address[] memory);\n\n  /**\n   * @notice Returns true if the provided address is a `UmbrellaStakeToken` belonging to this `Umbrella` instance.\n   * @return True if the token is part of this `Umbrella`, false otherwise\n   */\n  function isUmbrellaStkToken(address stakeToken) external view returns (bool);\n\n  /**\n   * @notice Returns the `TransparentProxyFactory` contract used to create `UmbrellaStakeToken`s.\n   * @return `TransparentProxyFactory` address\n   */\n  function TRANSPARENT_PROXY_FACTORY() external view returns (ITransparentProxyFactory);\n\n  /**\n   * @notice Returns the `UmbrellaStakeToken` implementation used to instantiate new umbrella stake tokens.\n   * @return `UmbrellaStakeToken` implementation address\n   */\n  function UMBRELLA_STAKE_TOKEN_IMPL() external view returns (address);\n\n  /**\n   * @notice Returns the `SUPER_ADMIN` address, which has `DEFAULT_ADMIN_ROLE` and is used to manage `UmbrellaStakeToken`s upgradability.\n   * @return `SUPER_ADMIN` address\n   */\n  function SUPER_ADMIN() external view returns (address);\n}\n"
    },
    "lib/aave-umbrella/src/contracts/umbrella/interfaces/IUmbrellaConfiguration.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.27;\n\nimport {IPool} from 'aave-v3-origin/contracts/interfaces/IPool.sol';\nimport {IPoolAddressesProvider} from 'aave-v3-origin/contracts/interfaces/IPoolAddressesProvider.sol';\n\ninterface IUmbrellaConfiguration {\n  struct SlashingConfigUpdate {\n    /// @notice Reserve which configuration should be updated\n    address reserve;\n    /// @notice Address of `UmbrellaStakeToken` that should be set for this reserve\n    address umbrellaStake;\n    /// @notice Percentage of funds slashed on top of the new deficit\n    uint256 liquidationFee;\n    /// @notice Oracle of `UmbrellaStakeToken`s underlying\n    address umbrellaStakeUnderlyingOracle;\n  }\n\n  struct SlashingConfigRemoval {\n    /// @notice Reserve which configuration is being removed\n    address reserve;\n    /// @notice Address of `UmbrellaStakeToken` that will be removed from this reserve\n    address umbrellaStake;\n  }\n\n  struct SlashingConfig {\n    /// @notice Address of `UmbrellaStakeToken`\n    address umbrellaStake;\n    /// @notice `UmbrellaStakeToken` underlying oracle address\n    address umbrellaStakeUnderlyingOracle;\n    /// @notice Percentage of funds slashed on top of the new deficit\n    uint256 liquidationFee;\n  }\n\n  struct StakeTokenData {\n    /// @notice Oracle for pricing an underlying assets of `UmbrellaStakeToken`\n    /// @dev Remains after removal of `SlashingConfig`\n    address underlyingOracle;\n    /// @notice Reserve address for which this `UmbrellaStakeToken` is configured\n    /// @dev Will be deleted after removal of `SlashingConfig`\n    address reserve;\n  }\n\n  /**\n   * @notice Event is emitted whenever a configuration is added or updated.\n   * @param reserve Reserve which configuration is changed\n   * @param umbrellaStake Address of `UmbrellaStakeToken`\n   * @param liquidationFee Percentage of funds slashed on top of the deficit\n   * @param umbrellaStakeUnderlyingOracle `UmbrellaStakeToken` underlying oracle address\n   */\n  event SlashingConfigurationChanged(\n    address indexed reserve,\n    address indexed umbrellaStake,\n    uint256 liquidationFee,\n    address umbrellaStakeUnderlyingOracle\n  );\n\n  /**\n   * @notice Event is emitted whenever a configuration is removed.\n   * @param reserve Reserve which configuration is removed\n   * @param umbrellaStake Address of `UmbrellaStakeToken`\n   */\n  event SlashingConfigurationRemoved(address indexed reserve, address indexed umbrellaStake);\n\n  /**\n   * @notice Event is emitted whenever the `deficitOffset` is changed.\n   * @param reserve Reserve which `deficitOffset` is changed\n   * @param newDeficitOffset New amount of `deficitOffset`\n   */\n  event DeficitOffsetChanged(address indexed reserve, uint256 newDeficitOffset);\n\n  /**\n   * @notice Event is emitted whenever the `pendingDeficit` is changed.\n   * @param reserve Reserve which `pendingDeficit` is changed\n   * @param newPendingDeficit New amount of `pendingDeficit`\n   */\n  event PendingDeficitChanged(address indexed reserve, uint256 newPendingDeficit);\n\n  /**\n   * @dev Attempted to set zero address.\n   */\n  error ZeroAddress();\n\n  /**\n   * @dev Attempted to interact with a `UmbrellaStakeToken` that should be deployed by this `Umbrella` instance, but is not.\n   */\n  error InvalidStakeToken();\n\n  /**\n   * @dev Attempted to set a `UmbrellaStakeToken` that has a different number of decimals than `reserve`.\n   */\n  error InvalidNumberOfDecimals();\n\n  /**\n   * @dev Attempted to set `liquidationFee` greater than 100%.\n   */\n  error InvalidLiquidationFee();\n\n  /**\n   * @dev Attempted to get `SlashingConfig` for this `reserve` and `StakeToken`, however config doesn't exist for this pair.\n   */\n  error ConfigurationNotExist();\n\n  /**\n   * @dev Attempted to get price of `StakeToken` underlying, however the oracle has never been set.\n   */\n  error ConfigurationHasNotBeenSet();\n  /**\n   * @dev Attempted to set `UmbrellaStakeToken`, which is already set for another reserve.\n   */\n  error UmbrellaStakeAlreadySetForAnotherReserve();\n\n  /**\n   * @dev Attempted to add `reserve` to configuration, which isn't exist in the `Pool`.\n   */\n  error InvalidReserve();\n\n  /**\n   * @dev Attempted to set `umbrellaStakeUnderlyingOracle` that returns invalid price.\n   */\n  error InvalidOraclePrice();\n\n  // DEFAULT_ADMIN_ROLE\n  /////////////////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @notice Updates a set of slashing configurations.\n   * @dev If the configs contain an already existing configuration, the configuration will be overwritten.\n   * If install more than 1 configuration, then `slash` will not work in the current version.\n   * @param slashingConfigs An array of configurations\n   */\n  function updateSlashingConfigs(SlashingConfigUpdate[] calldata slashingConfigs) external;\n\n  /**\n   * @notice Removes a set of slashing configurations.\n   * @dev If such a config did not exist, the function does not revert.\n   * @param removalPairs An array of coverage pairs (reserve:stk) to remove\n   */\n  function removeSlashingConfigs(SlashingConfigRemoval[] calldata removalPairs) external;\n\n  /////////////////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @notice Returns all the slashing configurations, configured for a given `reserve`.\n   * @param reserve Address of the `reserve`\n   * @return An array of `SlashingConfig` structs\n   */\n  function getReserveSlashingConfigs(\n    address reserve\n  ) external view returns (SlashingConfig[] memory);\n\n  /**\n   * @notice Returns the slashing configuration for a given `UmbrellaStakeToken` in regards to a specific `reserve`.\n   * @dev Reverts if `SlashingConfig` doesn't exist.\n   * @param reserve Address of the `reserve`\n   * @param umbrellaStake Address of the `UmbrellaStakeToken`\n   * @return A `SlashingConfig` struct\n   */\n  function getReserveSlashingConfig(\n    address reserve,\n    address umbrellaStake\n  ) external view returns (SlashingConfig memory);\n\n  /**\n   * @notice Returns if a reserve is currently slashable or not.\n   * A reserve is slashable if:\n   * - there's only one stk configured for slashing\n   * - if there is a non zero new deficit\n   * @param reserve Address of the `reserve`\n   * @return flag If `Umbrella` could slash for a given `reserve`\n   * @return amount Amount of the new deficit, by which `UmbrellaStakeToken` potentially could be slashed\n   */\n  function isReserveSlashable(address reserve) external view returns (bool flag, uint256 amount);\n\n  /**\n   * @notice Returns the amount of deficit that can't be slashed using `UmbrellaStakeToken` funds.\n   * @param reserve Address of the `reserve`\n   * @return The amount of the `deficitOffset`\n   */\n  function getDeficitOffset(address reserve) external view returns (uint256);\n\n  /**\n   * @notice Returns the amount of already slashed funds that have not yet been used for the deficit elimination.\n   * @param reserve Address of the `reserve`\n   * @return The amount of funds pending for deficit elimination\n   */\n  function getPendingDeficit(address reserve) external view returns (uint256);\n\n  /**\n   * @notice Returns the `StakeTokenData` of the `umbrellaStake`.\n   * @param umbrellaStake Address of the `UmbrellaStakeToken`\n   * @return stakeTokenData A `StakeTokenData` struct\n   */\n  function getStakeTokenData(\n    address umbrellaStake\n  ) external view returns (StakeTokenData memory stakeTokenData);\n\n  /**\n   * @notice Returns the price of the `UmbrellaStakeToken` underlying.\n   * @dev This price is used for calculations inside `Umbrella` and should not be used outside of this system.\n   *\n   * The underlying price is determined based on the current oracle, if the oracle has never been set, the function will revert.\n   * The system retains information about the last oracle installed for a given `StakeToken`.\n   *\n   * If the `SlashingConfig` associated with the `StakeToken` is removed, this function will still be operational.\n   * However, the results of its work are not guaranteed.\n   *\n   * @param umbrellaStake Address of the `UmbrellaStakeToken`\n   * @return latestAnswer Price of the underlying\n   */\n  function latestUnderlyingAnswer(\n    address umbrellaStake\n  ) external view returns (int256 latestAnswer);\n\n  /**\n   * @notice Returns the Pool addresses provider.\n   * @return Pool addresses provider address\n   */\n  function POOL_ADDRESSES_PROVIDER() external view returns (IPoolAddressesProvider);\n\n  /**\n   * @notice Returns the address that is receiving the slashed funds.\n   * @return Slashed funds recipient\n   */\n  function SLASHED_FUNDS_RECIPIENT() external view returns (address);\n\n  /**\n   * @notice Returns the Aave Pool for which this `Umbrella` instance is configured.\n   * @return Pool address\n   */\n  function POOL() external view returns (IPool);\n}\n"
    },
    "lib/aave-umbrella/src/contracts/rewards/interfaces/IRewardsStructs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title IRewardsStructs interface\n * @notice An interface containing structures that can be used externally.\n * @author BGD labs\n */\ninterface IRewardsStructs {\n  struct RewardSetupConfig {\n    /// @notice Reward address\n    address reward;\n    /// @notice Address, from which this reward will be transferred (should give approval to this address)\n    address rewardPayer;\n    /// @notice Maximum possible emission rate of rewards per second\n    uint256 maxEmissionPerSecond;\n    /// @notice End of the rewards distribution\n    uint256 distributionEnd;\n  }\n\n  struct AssetDataExternal {\n    /// @notice Liquidity value at which there will be maximum emission per second (expected amount of asset to be deposited into `StakeToken`)\n    uint256 targetLiquidity;\n    /// @notice Timestamp of the last update\n    uint256 lastUpdateTimestamp;\n  }\n\n  struct RewardDataExternal {\n    /// @notice Reward address\n    address addr;\n    /// @notice Liquidity index of the reward set during the last update\n    uint256 index;\n    /// @notice Maximum possible emission rate of rewards per second\n    uint256 maxEmissionPerSecond;\n    /// @notice End of the reward distribution\n    uint256 distributionEnd;\n  }\n\n  struct EmissionData {\n    /// @notice Liquidity value at which there will be maximum emission per second applied\n    uint256 targetLiquidity;\n    /// @notice Liquidity value after which emission per second will be flat\n    uint256 targetLiquidityExcess;\n    /// @notice Maximum possible emission rate of rewards per second (can be with or without scaling to 18 decimals, depending on usage in code)\n    uint256 maxEmission;\n    /// @notice Flat emission value per second (can be with or without scaling, depending on usage in code)\n    uint256 flatEmission;\n  }\n\n  struct UserDataExternal {\n    /// @notice Liquidity index of the user reward set during the last update\n    uint256 index;\n    /// @notice Amount of accrued rewards that the user earned at the time of his last index update (pending to claim)\n    uint256 accrued;\n  }\n\n  struct SignatureParams {\n    uint8 v;\n    bytes32 r;\n    bytes32 s;\n  }\n}\n"
    },
    "lib/aave-umbrella/src/contracts/payloads/EngineFlags.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.27;\n\nlibrary EngineFlags {\n  /**\n   * @dev Magic value to be used as flag to keep unchanged any current configuration.\n   * Strongly assumes that the value `type(uint256).max - 42` will never be used, which seems reasonable\n   *\n   * For now could be used for:\n   *   - `unstakeWindow (inside `UnstakeConfig`)\n   *   - `cooldown` (inside `UnstakeConfig`)\n   *   - `targetLiquidity` (inside `ConfigureStakeAndRewardsConfig`)\n   *   - `rewardConfigs[i].maxEmissionPerSecond` (inside `ConfigureStakeAndRewardsConfig` and `ConfigureRewardsConfig`)\n   *   - `rewardConfigs[i].distributionEnd` (inside `ConfigureStakeAndRewardsConfig` and `ConfigureRewardsConfig`)\n   */\n  uint256 internal constant KEEP_CURRENT = type(uint256).max - 42;\n}\n"
    },
    "lib/aave-umbrella/src/contracts/rewards/interfaces/IRewardsDistributor.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {IRewardsStructs} from './IRewardsStructs.sol';\n\ninterface IRewardsDistributor is IRewardsStructs {\n  /**\n   * @notice Event is emitted when a `user` or admin installs/disables `claimer` for claiming user rewards.\n   * @param user Address of the `user`\n   * @param claimer Address of the `claimer` to install/disable\n   * @param caller Address of the `msg.sender` who changes claimer\n   * @param flag Flag responsible for setting/disabling `claimer`\n   */\n  event ClaimerSet(\n    address indexed user,\n    address indexed claimer,\n    address indexed caller,\n    bool flag\n  );\n\n  /**\n   * @dev Attempted to use signature with expired deadline.\n   */\n  error ExpiredSignature(uint256 deadline);\n\n  /**\n   * @dev Mismatched signature.\n   */\n  error InvalidSigner(address signer, address owner);\n\n  /**\n   * @dev Attempted to claim `reward` without authorization.\n   */\n  error ClaimerNotAuthorized(address claimer, address user);\n\n  /**\n   * @dev Attempted to claim rewards for assets while arrays lengths don't match.\n   */\n  error LengthsDontMatch();\n\n  /**\n   * @dev Attempted to set zero address.\n   */\n  error ZeroAddress();\n\n  // DEFAULT_ADMIN_ROLE\n  /////////////////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @notice Installs/disables `claimer` for claiming `user` rewards.\n   * @param user Address of the `user`\n   * @param claimer Address of the `claimer` to install/disable\n   * @param flag Flag responsible for setting/disabling `claimer`\n   */\n  function setClaimer(address user, address claimer, bool flag) external;\n\n  /////////////////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @notice Installs/disables `claimer` for claiming `msg.sender` rewards.\n   * @param claimer Address of the `claimer` to install/disable\n   * @param flag Flag responsible for setting/disabling `claimer`\n   */\n  function setClaimer(address claimer, bool flag) external;\n\n  /**\n   * @notice Claims all existing `rewards` for a certain `asset` on behalf of `msg.sender`.\n   * Makes an update and calculates new `index` and `accrued` `rewards` before claim.\n   * @dev Always claims all `rewards`.\n   * @param asset Address of the `asset` whose `rewards` should be claimed\n   * @param receiver Address of the funds receiver\n   * @return rewards Array containing the addresses of all `reward` tokens claimed\n   * @return amounts Array containing the corresponding `amounts` of each `reward` claimed\n   */\n  function claimAllRewards(\n    address asset,\n    address receiver\n  ) external returns (address[] memory rewards, uint256[] memory amounts);\n\n  /**\n   * @notice Claims all existing `rewards` on behalf of `user` for a certain `asset` by `msg.sender`.\n   * Makes an update and calculates new `index` and `accrued` `rewards` before claim.\n   * @dev Always claims all `rewards`.\n   * @param asset Address of the `asset` whose `rewards` should be claimed\n   * @param user Address of user, which accrued `rewards` should be claimed\n   * @param receiver Address of the funds receiver\n   * @return rewards Array containing the addresses of all `reward` tokens claimed\n   * @return amounts Array containing the corresponding `amounts` of each `reward` claimed\n   */\n  function claimAllRewardsOnBehalf(\n    address asset,\n    address user,\n    address receiver\n  ) external returns (address[] memory rewards, uint256[] memory amounts);\n\n  /**\n   * @notice Claims all existing `rewards` on behalf of `user` for a certain `asset` using signature.\n   * Makes an update and calculates new `index` and `accrued` `rewards` before claim.\n   * @dev Always claims all `rewards`.\n   * @param asset Address of the `asset` whose `rewards` should be claimed\n   * @param user Address of user, which accrued `rewards` should be claimed\n   * @param receiver Address of the funds receiver\n   * @param deadline Signature deadline for claiming\n   * @param sig Signature parameters\n   * @return rewards Array containing the addresses of all `reward` tokens claimed\n   * @return amounts Array containing the corresponding `amounts` of each `reward` claimed\n   */\n  function claimAllRewardsPermit(\n    address asset,\n    address user,\n    address receiver,\n    uint256 deadline,\n    SignatureParams calldata sig\n  ) external returns (address[] memory rewards, uint256[] memory amounts);\n\n  /**\n   * @notice Claims selected `rewards` of `msg.sender` for a certain `asset`.\n   * Makes an update and calculates new `index` and `accrued` `rewards` before claim.\n   * @param asset Address of the `asset` whose `rewards` should be claimed\n   * @param rewards Array of `reward` addresses, which should be claimed\n   * @param receiver Address of the funds receiver\n   * @return amounts Array containing the corresponding `amounts` of each `reward` claimed\n   */\n  function claimSelectedRewards(\n    address asset,\n    address[] calldata rewards,\n    address receiver\n  ) external returns (uint256[] memory amounts);\n\n  /**\n   * @notice Claims selected `rewards` on behalf of `user` for a certain `asset` by `msg.sender`.\n   * Makes an update and calculates new `index` and `accrued` `rewards` before claim.\n   * @param asset Address of the `asset` whose `rewards` should be claimed\n   * @param rewards Array of `reward` addresses, which should be claimed\n   * @param user Address of user, which accrued `rewards` should be claimed\n   * @param receiver Address of the funds receiver\n   * @return amounts Array containing the corresponding `amounts` of each `reward` claimed\n   */\n  function claimSelectedRewardsOnBehalf(\n    address asset,\n    address[] calldata rewards,\n    address user,\n    address receiver\n  ) external returns (uint256[] memory amounts);\n\n  /**\n   * @notice Claims selected `rewards` on behalf of `user` for a certain `asset` using signature.\n   * Makes an update and calculates new `index` and `accrued` `rewards` before claim.\n   * @param asset Address of the `asset` whose `rewards` should be claimed\n   * @param rewards Array of `reward` addresses, which should be claimed\n   * @param user Address of user, which accrued `rewards` should be claimed\n   * @param receiver Address of the funds receiver\n   * @param deadline Signature deadline for claiming\n   * @param sig Signature parameters\n   * @return amounts Array containing the corresponding `amounts` of each `reward` claimed\n   */\n  function claimSelectedRewardsPermit(\n    address asset,\n    address[] calldata rewards,\n    address user,\n    address receiver,\n    uint256 deadline,\n    SignatureParams calldata sig\n  ) external returns (uint256[] memory amounts);\n\n  /**\n   * @notice Claims all existing `rewards` of `msg.sender` across multiple `assets`.\n   * Makes an update and calculates new `index` and `accrued` `rewards` before claim.\n   * @dev Always claims all `rewards`.\n   * @param assets Array of addresses representing the `assets`, whose `rewards` should be claimed\n   * @param receiver Address of the funds receiver\n   * @return rewards Two-dimensional array where each inner array contains the addresses of `reward` tokens for a specific `asset`\n   * @return amounts Two-dimensional array where each inner array contains the amounts of each `reward` claimed for a specific `asset`\n   */\n  function claimAllRewards(\n    address[] calldata assets,\n    address receiver\n  ) external returns (address[][] memory rewards, uint256[][] memory amounts);\n\n  /**\n   * @notice Claims all existing `rewards` on behalf of `user` across multiple `assets` by `msg.sender`.\n   * Makes an update and calculates new `index` and `accrued` `rewards` before claim.\n   * @dev Always claims all `rewards`.\n   * @param assets Array of addresses representing the `assets`, whose `rewards` should be claimed\n   * @param user Address of user, which accrued `rewards` should be claimed\n   * @param receiver Address of the funds receiver\n   * @return rewards Two-dimensional array where each inner array contains the addresses of `reward` tokens for a specific `asset`\n   * @return amounts Two-dimensional array where each inner array contains the amounts of each `reward` claimed for a specific `asset`\n   */\n  function claimAllRewardsOnBehalf(\n    address[] calldata assets,\n    address user,\n    address receiver\n  ) external returns (address[][] memory rewards, uint256[][] memory amounts);\n\n  /**\n   * @notice Claims selected `rewards` of `msg.sender` across multiple `assets`.\n   * Makes an update and calculates new `index` and `accrued` `rewards` before claim.\n   * @param assets Array of addresses representing the `assets`, whose `rewards` should be claimed\n   * @param rewards Two-dimensional array where each inner array contains the addresses of `rewards` for a specific `asset`\n   * @param receiver Address of the funds receiver\n   * @return amounts Two-dimensional array where each inner array contains the amounts of each `reward` claimed for a specific `asset`\n   */\n  function claimSelectedRewards(\n    address[] calldata assets,\n    address[][] calldata rewards,\n    address receiver\n  ) external returns (uint256[][] memory);\n\n  /**\n   * @notice Claims selected `rewards` on behalf of `user` across multiple `assets` by `msg.sender`.\n   * Makes an update and calculates new `index` and `accrued` `rewards` before claim.\n   * @param assets Array of addresses representing the `assets`, whose `rewards` should be claimed\n   * @param rewards Two-dimensional array where each inner array contains the addresses of `rewards` for a specific `asset`\n   * @param user Address of user, which accrued `rewards` should be claimed\n   * @param receiver Address of the funds receiver\n   * @return amounts Two-dimensional array where each inner array contains the amounts of each `reward` claimed for a specific `asset`\n   */\n  function claimSelectedRewardsOnBehalf(\n    address[] calldata assets,\n    address[][] calldata rewards,\n    address user,\n    address receiver\n  ) external returns (uint256[][] memory);\n}\n"
    },
    "lib/aave-umbrella/lib/aave-v3-origin/lib/solidity-utils/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../token/ERC20/IERC20.sol\";\n"
    },
    "lib/aave-umbrella/lib/aave-v3-origin/lib/solidity-utils/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../utils/introspection/IERC165.sol\";\n"
    },
    "lib/aave-umbrella/lib/aave-v3-origin/lib/solidity-utils/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/utils/Errors.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Errors.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of common custom errors used in multiple contracts\n *\n * IMPORTANT: Backwards compatibility is not guaranteed in future versions of the library.\n * It is recommended to avoid relying on the error API for critical functionality.\n *\n * _Available since v5.1._\n */\nlibrary Errors {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error InsufficientBalance(uint256 balance, uint256 needed);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedCall();\n\n    /**\n     * @dev The deployment failed.\n     */\n    error FailedDeployment();\n\n    /**\n     * @dev A necessary precompile is missing.\n     */\n    error MissingPrecompile(address);\n}\n"
    },
    "lib/aave-umbrella/lib/aave-v3-origin/lib/solidity-utils/src/contracts/transparent-proxy/interfaces/ITransparentProxyFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\ninterface ITransparentProxyFactory {\n  event ProxyCreated(address proxy, address indexed logic, address indexed initialOwner);\n  event ProxyAdminCreated(address proxyAdmin, address indexed initialOwner);\n  event ProxyDeterministicCreated(\n    address proxy,\n    address indexed logic,\n    address indexed initialOwner,\n    bytes32 indexed salt\n  );\n  event ProxyAdminDeterministicCreated(\n    address proxyAdmin,\n    address indexed initialOwner,\n    bytes32 indexed salt\n  );\n\n  /**\n   * @notice Creates a transparent proxy instance, doing the first initialization in construction\n   * @dev Version using CREATE\n   * @param logic The address of the implementation contract\n   * @param initialOwner The initial owner of the admin of the proxy.\n   * @param data abi encoded call to the function with `initializer` (or `reinitializer`) modifier.\n   *             E.g. `abi.encodeWithSelector(mockImpl.initialize.selector, 2)`\n   *             for an `initialize` function being `function initialize(uint256 foo) external initializer;`\n   * @return address The address of the proxy deployed\n   **/\n  function create(\n    address logic,\n    address initialOwner,\n    bytes memory data\n  ) external returns (address);\n\n  /**\n   * @notice Creates a proxyAdmin instance, and transfers ownership to provided owner\n   * @dev Version using CREATE\n   * @param initialOwner The initial owner of the proxyAdmin deployed.\n   * @return address The address of the proxyAdmin deployed\n   **/\n  function createProxyAdmin(address initialOwner) external returns (address);\n\n  /**\n   * @notice Creates a transparent proxy instance, doing the first initialization in construction\n   * @dev Version using CREATE2, so deterministic\n   * @param logic The address of the implementation contract\n   * @param initialOwner The initial owner of the admin of the proxy.\n   * @param data abi encoded call to the function with `initializer` (or `reinitializer`) modifier.\n   *             E.g. `abi.encodeWithSelector(mockImpl.initialize.selector, 2)`\n   *             for an `initialize` function being `function initialize(uint256 foo) external initializer;`\n   * @param salt Value to be used in the address calculation, to be chosen by the account calling this function\n   * @return address The address of the proxy deployed\n   **/\n  function createDeterministic(\n    address logic,\n    address initialOwner,\n    bytes memory data,\n    bytes32 salt\n  ) external returns (address);\n\n  /**\n   * @notice Deterministically create a proxy admin instance and transfers ownership to provided owner.\n   * @dev Version using CREATE2, so deterministic\n   * @param adminOwner The owner of the ProxyAdmin deployed.\n   * @param salt Value to be used in the address calculation, to be chosen by the account calling this function\n   * @return address The address of the proxy admin deployed\n   **/\n  function createDeterministicProxyAdmin(\n    address adminOwner,\n    bytes32 salt\n  ) external returns (address);\n\n  /**\n   * @notice Pre-calculates and return the address on which `createDeterministic` will deploy a proxy\n   * @param logic The address of the implementation contract\n   * @param initialOwner The initial owner of the admin of the proxy.\n   * @param data abi encoded call to the function with `initializer` (or `reinitializer`) modifier.\n   *             E.g. `abi.encodeWithSelector(mockImpl.initialize.selector, 2)`\n   *             for an `initialize` function being `function initialize(uint256 foo) external initializer;`\n   * @param salt Value to be used in the address calculation, to be chosen by the account calling this function\n   * @return address The pre-calculated address\n   **/\n  function predictCreateDeterministic(\n    address logic,\n    address initialOwner,\n    bytes calldata data,\n    bytes32 salt\n  ) external view returns (address);\n\n  /**\n   * @notice Pre-calculates and return the address on which `createDeterministic` will deploy the proxyAdmin\n   * @param salt Value to be used in the address calculation, to be chosen by the account calling this function\n   * @return address The pre-calculated address\n   **/\n  function predictCreateDeterministicProxyAdmin(\n    bytes32 salt,\n    address initialOwner\n  ) external view returns (address);\n\n  /**\n   * @notice Returns the address of the `ProxyAdmin` associated with a given transparent proxy.\n   * @param proxy Address of the transparent proxy\n   * @return address Address of the `ProxyAdmin` that was deployed when the proxy was created\n   */\n  function getProxyAdmin(address proxy) external view returns (address);\n}\n"
    },
    "lib/aave-umbrella/lib/aave-v3-origin/src/contracts/interfaces/IPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IPoolAddressesProvider} from './IPoolAddressesProvider.sol';\nimport {DataTypes} from '../protocol/libraries/types/DataTypes.sol';\n\n/**\n * @title IPool\n * @author Aave\n * @notice Defines the basic interface for an Aave Pool.\n */\ninterface IPool {\n  /**\n   * @dev Emitted on mintUnbacked()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address initiating the supply\n   * @param onBehalfOf The beneficiary of the supplied assets, receiving the aTokens\n   * @param amount The amount of supplied assets\n   * @param referralCode The referral code used\n   */\n  event MintUnbacked(\n    address indexed reserve,\n    address user,\n    address indexed onBehalfOf,\n    uint256 amount,\n    uint16 indexed referralCode\n  );\n\n  /**\n   * @dev Emitted on backUnbacked()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param backer The address paying for the backing\n   * @param amount The amount added as backing\n   * @param fee The amount paid in fees\n   */\n  event BackUnbacked(address indexed reserve, address indexed backer, uint256 amount, uint256 fee);\n\n  /**\n   * @dev Emitted on supply()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address initiating the supply\n   * @param onBehalfOf The beneficiary of the supply, receiving the aTokens\n   * @param amount The amount supplied\n   * @param referralCode The referral code used\n   */\n  event Supply(\n    address indexed reserve,\n    address user,\n    address indexed onBehalfOf,\n    uint256 amount,\n    uint16 indexed referralCode\n  );\n\n  /**\n   * @dev Emitted on withdraw()\n   * @param reserve The address of the underlying asset being withdrawn\n   * @param user The address initiating the withdrawal, owner of aTokens\n   * @param to The address that will receive the underlying\n   * @param amount The amount to be withdrawn\n   */\n  event Withdraw(address indexed reserve, address indexed user, address indexed to, uint256 amount);\n\n  /**\n   * @dev Emitted on borrow() and flashLoan() when debt needs to be opened\n   * @param reserve The address of the underlying asset being borrowed\n   * @param user The address of the user initiating the borrow(), receiving the funds on borrow() or just\n   * initiator of the transaction on flashLoan()\n   * @param onBehalfOf The address that will be getting the debt\n   * @param amount The amount borrowed out\n   * @param interestRateMode The rate mode: 2 for Variable, 1 is deprecated (changed on v3.2.0)\n   * @param borrowRate The numeric rate at which the user has borrowed, expressed in ray\n   * @param referralCode The referral code used\n   */\n  event Borrow(\n    address indexed reserve,\n    address user,\n    address indexed onBehalfOf,\n    uint256 amount,\n    DataTypes.InterestRateMode interestRateMode,\n    uint256 borrowRate,\n    uint16 indexed referralCode\n  );\n\n  /**\n   * @dev Emitted on repay()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The beneficiary of the repayment, getting his debt reduced\n   * @param repayer The address of the user initiating the repay(), providing the funds\n   * @param amount The amount repaid\n   * @param useATokens True if the repayment is done using aTokens, `false` if done with underlying asset directly\n   */\n  event Repay(\n    address indexed reserve,\n    address indexed user,\n    address indexed repayer,\n    uint256 amount,\n    bool useATokens\n  );\n\n  /**\n   * @dev Emitted on borrow(), repay() and liquidationCall() when using isolated assets\n   * @param asset The address of the underlying asset of the reserve\n   * @param totalDebt The total isolation mode debt for the reserve\n   */\n  event IsolationModeTotalDebtUpdated(address indexed asset, uint256 totalDebt);\n\n  /**\n   * @dev Emitted when the user selects a certain asset category for eMode\n   * @param user The address of the user\n   * @param categoryId The category id\n   */\n  event UserEModeSet(address indexed user, uint8 categoryId);\n\n  /**\n   * @dev Emitted on setUserUseReserveAsCollateral()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user enabling the usage as collateral\n   */\n  event ReserveUsedAsCollateralEnabled(address indexed reserve, address indexed user);\n\n  /**\n   * @dev Emitted on setUserUseReserveAsCollateral()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user enabling the usage as collateral\n   */\n  event ReserveUsedAsCollateralDisabled(address indexed reserve, address indexed user);\n\n  /**\n   * @dev Emitted on flashLoan()\n   * @param target The address of the flash loan receiver contract\n   * @param initiator The address initiating the flash loan\n   * @param asset The address of the asset being flash borrowed\n   * @param amount The amount flash borrowed\n   * @param interestRateMode The flashloan mode: 0 for regular flashloan,\n   *        1 for Stable (Deprecated on v3.2.0), 2 for Variable\n   * @param premium The fee flash borrowed\n   * @param referralCode The referral code used\n   */\n  event FlashLoan(\n    address indexed target,\n    address initiator,\n    address indexed asset,\n    uint256 amount,\n    DataTypes.InterestRateMode interestRateMode,\n    uint256 premium,\n    uint16 indexed referralCode\n  );\n\n  /**\n   * @dev Emitted when a borrower is liquidated.\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n   * @param user The address of the borrower getting liquidated\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n   * @param liquidatedCollateralAmount The amount of collateral received by the liquidator\n   * @param liquidator The address of the liquidator\n   * @param receiveAToken True if the liquidators wants to receive the collateral aTokens, `false` if he wants\n   * to receive the underlying collateral asset directly\n   */\n  event LiquidationCall(\n    address indexed collateralAsset,\n    address indexed debtAsset,\n    address indexed user,\n    uint256 debtToCover,\n    uint256 liquidatedCollateralAmount,\n    address liquidator,\n    bool receiveAToken\n  );\n\n  /**\n   * @dev Emitted when the state of a reserve is updated.\n   * @param reserve The address of the underlying asset of the reserve\n   * @param liquidityRate The next liquidity rate\n   * @param stableBorrowRate The next stable borrow rate @note deprecated on v3.2.0\n   * @param variableBorrowRate The next variable borrow rate\n   * @param liquidityIndex The next liquidity index\n   * @param variableBorrowIndex The next variable borrow index\n   */\n  event ReserveDataUpdated(\n    address indexed reserve,\n    uint256 liquidityRate,\n    uint256 stableBorrowRate,\n    uint256 variableBorrowRate,\n    uint256 liquidityIndex,\n    uint256 variableBorrowIndex\n  );\n\n  /**\n   * @dev Emitted when the deficit of a reserve is covered.\n   * @param reserve The address of the underlying asset of the reserve\n   * @param caller The caller that triggered the DeficitCovered event\n   * @param amountCovered The amount of deficit covered\n   */\n  event DeficitCovered(address indexed reserve, address caller, uint256 amountCovered);\n\n  /**\n   * @dev Emitted when the protocol treasury receives minted aTokens from the accrued interest.\n   * @param reserve The address of the reserve\n   * @param amountMinted The amount minted to the treasury\n   */\n  event MintedToTreasury(address indexed reserve, uint256 amountMinted);\n\n  /**\n   * @dev Emitted when deficit is realized on a liquidation.\n   * @param user The user address where the bad debt will be burned\n   * @param debtAsset The address of the underlying borrowed asset to be burned\n   * @param amountCreated The amount of deficit created\n   */\n  event DeficitCreated(address indexed user, address indexed debtAsset, uint256 amountCreated);\n\n  /**\n   * @notice Mints an `amount` of aTokens to the `onBehalfOf`\n   * @param asset The address of the underlying asset to mint\n   * @param amount The amount to mint\n   * @param onBehalfOf The address that will receive the aTokens\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   */\n  function mintUnbacked(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external;\n\n  /**\n   * @notice Back the current unbacked underlying with `amount` and pay `fee`.\n   * @param asset The address of the underlying asset to back\n   * @param amount The amount to back\n   * @param fee The amount paid in fees\n   * @return The backed amount\n   */\n  function backUnbacked(address asset, uint256 amount, uint256 fee) external returns (uint256);\n\n  /**\n   * @notice Supplies an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\n   * - E.g. User supplies 100 USDC and gets in return 100 aUSDC\n   * @param asset The address of the underlying asset to supply\n   * @param amount The amount to be supplied\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n   *   is a different wallet\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   */\n  function supply(address asset, uint256 amount, address onBehalfOf, uint16 referralCode) external;\n\n  /**\n   * @notice Supply with transfer approval of asset to be supplied done via permit function\n   * see: https://eips.ethereum.org/EIPS/eip-2612 and https://eips.ethereum.org/EIPS/eip-713\n   * @param asset The address of the underlying asset to supply\n   * @param amount The amount to be supplied\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n   *   is a different wallet\n   * @param deadline The deadline timestamp that the permit is valid\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   * @param permitV The V parameter of ERC712 permit sig\n   * @param permitR The R parameter of ERC712 permit sig\n   * @param permitS The S parameter of ERC712 permit sig\n   */\n  function supplyWithPermit(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode,\n    uint256 deadline,\n    uint8 permitV,\n    bytes32 permitR,\n    bytes32 permitS\n  ) external;\n\n  /**\n   * @notice Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\n   * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\n   * @param asset The address of the underlying asset to withdraw\n   * @param amount The underlying amount to be withdrawn\n   *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\n   * @param to The address that will receive the underlying, same as msg.sender if the user\n   *   wants to receive it on his own wallet, or a different address if the beneficiary is a\n   *   different wallet\n   * @return The final amount withdrawn\n   */\n  function withdraw(address asset, uint256 amount, address to) external returns (uint256);\n\n  /**\n   * @notice Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower\n   * already supplied enough collateral, or he was given enough allowance by a credit delegator on the VariableDebtToken\n   * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet\n   *   and 100 variable debt tokens\n   * @param asset The address of the underlying asset to borrow\n   * @param amount The amount to be borrowed\n   * @param interestRateMode 2 for Variable, 1 is deprecated on v3.2.0\n   * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   * @param onBehalfOf The address of the user who will receive the debt. Should be the address of the borrower itself\n   * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator\n   * if he has been given credit delegation allowance\n   */\n  function borrow(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode,\n    uint16 referralCode,\n    address onBehalfOf\n  ) external;\n\n  /**\n   * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned\n   * - E.g. User repays 100 USDC, burning 100 variable debt tokens of the `onBehalfOf` address\n   * @param asset The address of the borrowed underlying asset previously borrowed\n   * @param amount The amount to repay\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n   * @param interestRateMode 2 for Variable, 1 is deprecated on v3.2.0\n   * @param onBehalfOf The address of the user who will get his debt reduced/removed. Should be the address of the\n   * user calling the function if he wants to reduce/remove his own debt, or the address of any other\n   * other borrower whose debt should be removed\n   * @return The final amount repaid\n   */\n  function repay(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode,\n    address onBehalfOf\n  ) external returns (uint256);\n\n  /**\n   * @notice Repay with transfer approval of asset to be repaid done via permit function\n   * see: https://eips.ethereum.org/EIPS/eip-2612 and https://eips.ethereum.org/EIPS/eip-713\n   * @param asset The address of the borrowed underlying asset previously borrowed\n   * @param amount The amount to repay\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n   * @param interestRateMode 2 for Variable, 1 is deprecated on v3.2.0\n   * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the\n   * user calling the function if he wants to reduce/remove his own debt, or the address of any other\n   * other borrower whose debt should be removed\n   * @param deadline The deadline timestamp that the permit is valid\n   * @param permitV The V parameter of ERC712 permit sig\n   * @param permitR The R parameter of ERC712 permit sig\n   * @param permitS The S parameter of ERC712 permit sig\n   * @return The final amount repaid\n   */\n  function repayWithPermit(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode,\n    address onBehalfOf,\n    uint256 deadline,\n    uint8 permitV,\n    bytes32 permitR,\n    bytes32 permitS\n  ) external returns (uint256);\n\n  /**\n   * @notice Repays a borrowed `amount` on a specific reserve using the reserve aTokens, burning the\n   * equivalent debt tokens\n   * - E.g. User repays 100 USDC using 100 aUSDC, burning 100 variable debt tokens\n   * @dev  Passing uint256.max as amount will clean up any residual aToken dust balance, if the user aToken\n   * balance is not enough to cover the whole debt\n   * @param asset The address of the borrowed underlying asset previously borrowed\n   * @param amount The amount to repay\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n   * @param interestRateMode DEPRECATED in v3.2.0\n   * @return The final amount repaid\n   */\n  function repayWithATokens(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode\n  ) external returns (uint256);\n\n  /**\n   * @notice Allows suppliers to enable/disable a specific supplied asset as collateral\n   * @param asset The address of the underlying asset supplied\n   * @param useAsCollateral True if the user wants to use the supply as collateral, false otherwise\n   */\n  function setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external;\n\n  /**\n   * @notice Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1\n   * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives\n   *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n   * @param user The address of the borrower getting liquidated\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n   * @param receiveAToken True if the liquidators wants to receive the collateral aTokens, `false` if he wants\n   * to receive the underlying collateral asset directly\n   */\n  function liquidationCall(\n    address collateralAsset,\n    address debtAsset,\n    address user,\n    uint256 debtToCover,\n    bool receiveAToken\n  ) external;\n\n  /**\n   * @notice Allows smartcontracts to access the liquidity of the pool within one transaction,\n   * as long as the amount taken plus a fee is returned.\n   * @dev IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept\n   * into consideration. For further details please visit https://docs.aave.com/developers/\n   * @param receiverAddress The address of the contract receiving the funds, implementing IFlashLoanReceiver interface\n   * @param assets The addresses of the assets being flash-borrowed\n   * @param amounts The amounts of the assets being flash-borrowed\n   * @param interestRateModes Types of the debt to open if the flash loan is not returned:\n   *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver\n   *   1 -> Deprecated on v3.2.0\n   *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n   * @param onBehalfOf The address  that will receive the debt in the case of using 2 on `modes`\n   * @param params Variadic packed params to pass to the receiver as extra information\n   * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   */\n  function flashLoan(\n    address receiverAddress,\n    address[] calldata assets,\n    uint256[] calldata amounts,\n    uint256[] calldata interestRateModes,\n    address onBehalfOf,\n    bytes calldata params,\n    uint16 referralCode\n  ) external;\n\n  /**\n   * @notice Allows smartcontracts to access the liquidity of the pool within one transaction,\n   * as long as the amount taken plus a fee is returned.\n   * @dev IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept\n   * into consideration. For further details please visit https://docs.aave.com/developers/\n   * @param receiverAddress The address of the contract receiving the funds, implementing IFlashLoanSimpleReceiver interface\n   * @param asset The address of the asset being flash-borrowed\n   * @param amount The amount of the asset being flash-borrowed\n   * @param params Variadic packed params to pass to the receiver as extra information\n   * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   */\n  function flashLoanSimple(\n    address receiverAddress,\n    address asset,\n    uint256 amount,\n    bytes calldata params,\n    uint16 referralCode\n  ) external;\n\n  /**\n   * @notice Returns the user account data across all the reserves\n   * @param user The address of the user\n   * @return totalCollateralBase The total collateral of the user in the base currency used by the price feed\n   * @return totalDebtBase The total debt of the user in the base currency used by the price feed\n   * @return availableBorrowsBase The borrowing power left of the user in the base currency used by the price feed\n   * @return currentLiquidationThreshold The liquidation threshold of the user\n   * @return ltv The loan to value of The user\n   * @return healthFactor The current health factor of the user\n   */\n  function getUserAccountData(\n    address user\n  )\n    external\n    view\n    returns (\n      uint256 totalCollateralBase,\n      uint256 totalDebtBase,\n      uint256 availableBorrowsBase,\n      uint256 currentLiquidationThreshold,\n      uint256 ltv,\n      uint256 healthFactor\n    );\n\n  /**\n   * @notice Initializes a reserve, activating it, assigning an aToken and debt tokens and an\n   * interest rate strategy\n   * @dev Only callable by the PoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param aTokenAddress The address of the aToken that will be assigned to the reserve\n   * @param variableDebtAddress The address of the VariableDebtToken that will be assigned to the reserve\n   * @param interestRateStrategyAddress The address of the interest rate strategy contract\n   */\n  function initReserve(\n    address asset,\n    address aTokenAddress,\n    address variableDebtAddress,\n    address interestRateStrategyAddress\n  ) external;\n\n  /**\n   * @notice Drop a reserve\n   * @dev Only callable by the PoolConfigurator contract\n   * @dev Does not reset eMode flags, which must be considered when reusing the same reserve id for a different reserve.\n   * @param asset The address of the underlying asset of the reserve\n   */\n  function dropReserve(address asset) external;\n\n  /**\n   * @notice Updates the address of the interest rate strategy contract\n   * @dev Only callable by the PoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param rateStrategyAddress The address of the interest rate strategy contract\n   */\n  function setReserveInterestRateStrategyAddress(\n    address asset,\n    address rateStrategyAddress\n  ) external;\n\n  /**\n   * @notice Accumulates interest to all indexes of the reserve\n   * @dev Only callable by the PoolConfigurator contract\n   * @dev To be used when required by the configurator, for example when updating interest rates strategy data\n   * @param asset The address of the underlying asset of the reserve\n   */\n  function syncIndexesState(address asset) external;\n\n  /**\n   * @notice Updates interest rates on the reserve data\n   * @dev Only callable by the PoolConfigurator contract\n   * @dev To be used when required by the configurator, for example when updating interest rates strategy data\n   * @param asset The address of the underlying asset of the reserve\n   */\n  function syncRatesState(address asset) external;\n\n  /**\n   * @notice Sets the configuration bitmap of the reserve as a whole\n   * @dev Only callable by the PoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param configuration The new configuration bitmap\n   */\n  function setConfiguration(\n    address asset,\n    DataTypes.ReserveConfigurationMap calldata configuration\n  ) external;\n\n  /**\n   * @notice Returns the configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The configuration of the reserve\n   */\n  function getConfiguration(\n    address asset\n  ) external view returns (DataTypes.ReserveConfigurationMap memory);\n\n  /**\n   * @notice Returns the configuration of the user across all the reserves\n   * @param user The user address\n   * @return The configuration of the user\n   */\n  function getUserConfiguration(\n    address user\n  ) external view returns (DataTypes.UserConfigurationMap memory);\n\n  /**\n   * @notice Returns the normalized income of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve's normalized income\n   */\n  function getReserveNormalizedIncome(address asset) external view returns (uint256);\n\n  /**\n   * @notice Returns the normalized variable debt per unit of asset\n   * @dev WARNING: This function is intended to be used primarily by the protocol itself to get a\n   * \"dynamic\" variable index based on time, current stored index and virtual rate at the current\n   * moment (approx. a borrower would get if opening a position). This means that is always used in\n   * combination with variable debt supply/balances.\n   * If using this function externally, consider that is possible to have an increasing normalized\n   * variable debt that is not equivalent to how the variable debt index would be updated in storage\n   * (e.g. only updates with non-zero variable debt supply)\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve normalized variable debt\n   */\n  function getReserveNormalizedVariableDebt(address asset) external view returns (uint256);\n\n  /**\n   * @notice Returns the state and configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The state and configuration data of the reserve\n   */\n  function getReserveData(address asset) external view returns (DataTypes.ReserveDataLegacy memory);\n\n  /**\n   * @notice Returns the virtual underlying balance of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve virtual underlying balance\n   */\n  function getVirtualUnderlyingBalance(address asset) external view returns (uint128);\n\n  /**\n   * @notice Validates and finalizes an aToken transfer\n   * @dev Only callable by the overlying aToken of the `asset`\n   * @param asset The address of the underlying asset of the aToken\n   * @param from The user from which the aTokens are transferred\n   * @param to The user receiving the aTokens\n   * @param amount The amount being transferred/withdrawn\n   * @param balanceFromBefore The aToken balance of the `from` user before the transfer\n   * @param balanceToBefore The aToken balance of the `to` user before the transfer\n   */\n  function finalizeTransfer(\n    address asset,\n    address from,\n    address to,\n    uint256 amount,\n    uint256 balanceFromBefore,\n    uint256 balanceToBefore\n  ) external;\n\n  /**\n   * @notice Returns the list of the underlying assets of all the initialized reserves\n   * @dev It does not include dropped reserves\n   * @return The addresses of the underlying assets of the initialized reserves\n   */\n  function getReservesList() external view returns (address[] memory);\n\n  /**\n   * @notice Returns the number of initialized reserves\n   * @dev It includes dropped reserves\n   * @return The count\n   */\n  function getReservesCount() external view returns (uint256);\n\n  /**\n   * @notice Returns the address of the underlying asset of a reserve by the reserve id as stored in the DataTypes.ReserveData struct\n   * @param id The id of the reserve as stored in the DataTypes.ReserveData struct\n   * @return The address of the reserve associated with id\n   */\n  function getReserveAddressById(uint16 id) external view returns (address);\n\n  /**\n   * @notice Returns the PoolAddressesProvider connected to this contract\n   * @return The address of the PoolAddressesProvider\n   */\n  function ADDRESSES_PROVIDER() external view returns (IPoolAddressesProvider);\n\n  /**\n   * @notice Updates the protocol fee on the bridging\n   * @param bridgeProtocolFee The part of the premium sent to the protocol treasury\n   */\n  function updateBridgeProtocolFee(uint256 bridgeProtocolFee) external;\n\n  /**\n   * @notice Updates flash loan premiums. Flash loan premium consists of two parts:\n   * - A part is sent to aToken holders as extra, one time accumulated interest\n   * - A part is collected by the protocol treasury\n   * @dev The total premium is calculated on the total borrowed amount\n   * @dev The premium to protocol is calculated on the total premium, being a percentage of `flashLoanPremiumTotal`\n   * @dev Only callable by the PoolConfigurator contract\n   * @param flashLoanPremiumTotal The total premium, expressed in bps\n   * @param flashLoanPremiumToProtocol The part of the premium sent to the protocol treasury, expressed in bps\n   */\n  function updateFlashloanPremiums(\n    uint128 flashLoanPremiumTotal,\n    uint128 flashLoanPremiumToProtocol\n  ) external;\n\n  /**\n   * @notice Configures a new or alters an existing collateral configuration of an eMode.\n   * @dev In eMode, the protocol allows very high borrowing power to borrow assets of the same category.\n   * The category 0 is reserved as it's the default for volatile assets\n   * @param id The id of the category\n   * @param config The configuration of the category\n   */\n  function configureEModeCategory(\n    uint8 id,\n    DataTypes.EModeCategoryBaseConfiguration memory config\n  ) external;\n\n  /**\n   * @notice Replaces the current eMode collateralBitmap.\n   * @param id The id of the category\n   * @param collateralBitmap The collateralBitmap of the category\n   */\n  function configureEModeCategoryCollateralBitmap(uint8 id, uint128 collateralBitmap) external;\n\n  /**\n   * @notice Replaces the current eMode borrowableBitmap.\n   * @param id The id of the category\n   * @param borrowableBitmap The borrowableBitmap of the category\n   */\n  function configureEModeCategoryBorrowableBitmap(uint8 id, uint128 borrowableBitmap) external;\n\n  /**\n   * @notice Returns the data of an eMode category\n   * @dev DEPRECATED use independent getters instead\n   * @param id The id of the category\n   * @return The configuration data of the category\n   */\n  function getEModeCategoryData(\n    uint8 id\n  ) external view returns (DataTypes.EModeCategoryLegacy memory);\n\n  /**\n   * @notice Returns the label of an eMode category\n   * @param id The id of the category\n   * @return The label of the category\n   */\n  function getEModeCategoryLabel(uint8 id) external view returns (string memory);\n\n  /**\n   * @notice Returns the collateral config of an eMode category\n   * @param id The id of the category\n   * @return The ltv,lt,lb of the category\n   */\n  function getEModeCategoryCollateralConfig(\n    uint8 id\n  ) external view returns (DataTypes.CollateralConfig memory);\n\n  /**\n   * @notice Returns the collateralBitmap of an eMode category\n   * @param id The id of the category\n   * @return The collateralBitmap of the category\n   */\n  function getEModeCategoryCollateralBitmap(uint8 id) external view returns (uint128);\n\n  /**\n   * @notice Returns the borrowableBitmap of an eMode category\n   * @param id The id of the category\n   * @return The borrowableBitmap of the category\n   */\n  function getEModeCategoryBorrowableBitmap(uint8 id) external view returns (uint128);\n\n  /**\n   * @notice Allows a user to use the protocol in eMode\n   * @param categoryId The id of the category\n   */\n  function setUserEMode(uint8 categoryId) external;\n\n  /**\n   * @notice Returns the eMode the user is using\n   * @param user The address of the user\n   * @return The eMode id\n   */\n  function getUserEMode(address user) external view returns (uint256);\n\n  /**\n   * @notice Resets the isolation mode total debt of the given asset to zero\n   * @dev It requires the given asset has zero debt ceiling\n   * @param asset The address of the underlying asset to reset the isolationModeTotalDebt\n   */\n  function resetIsolationModeTotalDebt(address asset) external;\n\n  /**\n   * @notice Sets the liquidation grace period of the given asset\n   * @dev To enable a liquidation grace period, a timestamp in the future should be set,\n   *      To disable a liquidation grace period, any timestamp in the past works, like 0\n   * @param asset The address of the underlying asset to set the liquidationGracePeriod\n   * @param until Timestamp when the liquidation grace period will end\n   **/\n  function setLiquidationGracePeriod(address asset, uint40 until) external;\n\n  /**\n   * @notice Returns the liquidation grace period of the given asset\n   * @param asset The address of the underlying asset\n   * @return Timestamp when the liquidation grace period will end\n   **/\n  function getLiquidationGracePeriod(address asset) external view returns (uint40);\n\n  /**\n   * @notice Returns the total fee on flash loans\n   * @return The total fee on flashloans\n   */\n  function FLASHLOAN_PREMIUM_TOTAL() external view returns (uint128);\n\n  /**\n   * @notice Returns the part of the bridge fees sent to protocol\n   * @return The bridge fee sent to the protocol treasury\n   */\n  function BRIDGE_PROTOCOL_FEE() external view returns (uint256);\n\n  /**\n   * @notice Returns the part of the flashloan fees sent to protocol\n   * @return The flashloan fee sent to the protocol treasury\n   */\n  function FLASHLOAN_PREMIUM_TO_PROTOCOL() external view returns (uint128);\n\n  /**\n   * @notice Returns the maximum number of reserves supported to be listed in this Pool\n   * @return The maximum number of reserves supported\n   */\n  function MAX_NUMBER_RESERVES() external view returns (uint16);\n\n  /**\n   * @notice Mints the assets accrued through the reserve factor to the treasury in the form of aTokens\n   * @param assets The list of reserves for which the minting needs to be executed\n   */\n  function mintToTreasury(address[] calldata assets) external;\n\n  /**\n   * @notice Rescue and transfer tokens locked in this contract\n   * @param token The address of the token\n   * @param to The address of the recipient\n   * @param amount The amount of token to transfer\n   */\n  function rescueTokens(address token, address to, uint256 amount) external;\n\n  /**\n   * @notice Supplies an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\n   * - E.g. User supplies 100 USDC and gets in return 100 aUSDC\n   * @dev Deprecated: Use the `supply` function instead\n   * @param asset The address of the underlying asset to supply\n   * @param amount The amount to be supplied\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n   *   is a different wallet\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   */\n  function deposit(address asset, uint256 amount, address onBehalfOf, uint16 referralCode) external;\n\n  /**\n   * @notice It covers the deficit of a specified reserve by burning:\n   * - the equivalent aToken `amount` for assets with virtual accounting enabled\n   * - the equivalent `amount` of underlying for assets with virtual accounting disabled (e.g. GHO)\n   * @dev The deficit of a reserve can occur due to situations where borrowed assets are not repaid, leading to bad debt.\n   * @param asset The address of the underlying asset to cover the deficit.\n   * @param amount The amount to be covered, in aToken or underlying on non-virtual accounted assets\n   */\n  function eliminateReserveDeficit(address asset, uint256 amount) external;\n\n  /**\n   * @notice Returns the current deficit of a reserve.\n   * @param asset The address of the underlying asset of the reserve\n   * @return The current deficit of the reserve\n   */\n  function getReserveDeficit(address asset) external view returns (uint256);\n\n  /**\n   * @notice Returns the aToken address of a reserve.\n   * @param asset The address of the underlying asset of the reserve\n   * @return The address of the aToken\n   */\n  function getReserveAToken(address asset) external view returns (address);\n\n  /**\n   * @notice Returns the variableDebtToken address of a reserve.\n   * @param asset The address of the underlying asset of the reserve\n   * @return The address of the variableDebtToken\n   */\n  function getReserveVariableDebtToken(address asset) external view returns (address);\n\n  /**\n   * @notice Gets the address of the external FlashLoanLogic\n   */\n  function getFlashLoanLogic() external view returns (address);\n\n  /**\n   * @notice Gets the address of the external BorrowLogic\n   */\n  function getBorrowLogic() external view returns (address);\n\n  /**\n   * @notice Gets the address of the external BridgeLogic\n   */\n  function getBridgeLogic() external view returns (address);\n\n  /**\n   * @notice Gets the address of the external EModeLogic\n   */\n  function getEModeLogic() external view returns (address);\n\n  /**\n   * @notice Gets the address of the external LiquidationLogic\n   */\n  function getLiquidationLogic() external view returns (address);\n\n  /**\n   * @notice Gets the address of the external PoolLogic\n   */\n  function getPoolLogic() external view returns (address);\n\n  /**\n   * @notice Gets the address of the external SupplyLogic\n   */\n  function getSupplyLogic() external view returns (address);\n}\n"
    },
    "lib/aave-umbrella/lib/aave-v3-origin/src/contracts/interfaces/IPoolAddressesProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title IPoolAddressesProvider\n * @author Aave\n * @notice Defines the basic interface for a Pool Addresses Provider.\n */\ninterface IPoolAddressesProvider {\n  /**\n   * @dev Emitted when the market identifier is updated.\n   * @param oldMarketId The old id of the market\n   * @param newMarketId The new id of the market\n   */\n  event MarketIdSet(string indexed oldMarketId, string indexed newMarketId);\n\n  /**\n   * @dev Emitted when the pool is updated.\n   * @param oldAddress The old address of the Pool\n   * @param newAddress The new address of the Pool\n   */\n  event PoolUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the pool configurator is updated.\n   * @param oldAddress The old address of the PoolConfigurator\n   * @param newAddress The new address of the PoolConfigurator\n   */\n  event PoolConfiguratorUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the price oracle is updated.\n   * @param oldAddress The old address of the PriceOracle\n   * @param newAddress The new address of the PriceOracle\n   */\n  event PriceOracleUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the ACL manager is updated.\n   * @param oldAddress The old address of the ACLManager\n   * @param newAddress The new address of the ACLManager\n   */\n  event ACLManagerUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the ACL admin is updated.\n   * @param oldAddress The old address of the ACLAdmin\n   * @param newAddress The new address of the ACLAdmin\n   */\n  event ACLAdminUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the price oracle sentinel is updated.\n   * @param oldAddress The old address of the PriceOracleSentinel\n   * @param newAddress The new address of the PriceOracleSentinel\n   */\n  event PriceOracleSentinelUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the pool data provider is updated.\n   * @param oldAddress The old address of the PoolDataProvider\n   * @param newAddress The new address of the PoolDataProvider\n   */\n  event PoolDataProviderUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when a new proxy is created.\n   * @param id The identifier of the proxy\n   * @param proxyAddress The address of the created proxy contract\n   * @param implementationAddress The address of the implementation contract\n   */\n  event ProxyCreated(\n    bytes32 indexed id,\n    address indexed proxyAddress,\n    address indexed implementationAddress\n  );\n\n  /**\n   * @dev Emitted when a new non-proxied contract address is registered.\n   * @param id The identifier of the contract\n   * @param oldAddress The address of the old contract\n   * @param newAddress The address of the new contract\n   */\n  event AddressSet(bytes32 indexed id, address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the implementation of the proxy registered with id is updated\n   * @param id The identifier of the contract\n   * @param proxyAddress The address of the proxy contract\n   * @param oldImplementationAddress The address of the old implementation contract\n   * @param newImplementationAddress The address of the new implementation contract\n   */\n  event AddressSetAsProxy(\n    bytes32 indexed id,\n    address indexed proxyAddress,\n    address oldImplementationAddress,\n    address indexed newImplementationAddress\n  );\n\n  /**\n   * @notice Returns the id of the Aave market to which this contract points to.\n   * @return The market id\n   */\n  function getMarketId() external view returns (string memory);\n\n  /**\n   * @notice Associates an id with a specific PoolAddressesProvider.\n   * @dev This can be used to create an onchain registry of PoolAddressesProviders to\n   * identify and validate multiple Aave markets.\n   * @param newMarketId The market id\n   */\n  function setMarketId(string calldata newMarketId) external;\n\n  /**\n   * @notice Returns an address by its identifier.\n   * @dev The returned address might be an EOA or a contract, potentially proxied\n   * @dev It returns ZERO if there is no registered address with the given id\n   * @param id The id\n   * @return The address of the registered for the specified id\n   */\n  function getAddress(bytes32 id) external view returns (address);\n\n  /**\n   * @notice General function to update the implementation of a proxy registered with\n   * certain `id`. If there is no proxy registered, it will instantiate one and\n   * set as implementation the `newImplementationAddress`.\n   * @dev IMPORTANT Use this function carefully, only for ids that don't have an explicit\n   * setter function, in order to avoid unexpected consequences\n   * @param id The id\n   * @param newImplementationAddress The address of the new implementation\n   */\n  function setAddressAsProxy(bytes32 id, address newImplementationAddress) external;\n\n  /**\n   * @notice Sets an address for an id replacing the address saved in the addresses map.\n   * @dev IMPORTANT Use this function carefully, as it will do a hard replacement\n   * @param id The id\n   * @param newAddress The address to set\n   */\n  function setAddress(bytes32 id, address newAddress) external;\n\n  /**\n   * @notice Returns the address of the Pool proxy.\n   * @return The Pool proxy address\n   */\n  function getPool() external view returns (address);\n\n  /**\n   * @notice Updates the implementation of the Pool, or creates a proxy\n   * setting the new `pool` implementation when the function is called for the first time.\n   * @param newPoolImpl The new Pool implementation\n   */\n  function setPoolImpl(address newPoolImpl) external;\n\n  /**\n   * @notice Returns the address of the PoolConfigurator proxy.\n   * @return The PoolConfigurator proxy address\n   */\n  function getPoolConfigurator() external view returns (address);\n\n  /**\n   * @notice Updates the implementation of the PoolConfigurator, or creates a proxy\n   * setting the new `PoolConfigurator` implementation when the function is called for the first time.\n   * @param newPoolConfiguratorImpl The new PoolConfigurator implementation\n   */\n  function setPoolConfiguratorImpl(address newPoolConfiguratorImpl) external;\n\n  /**\n   * @notice Returns the address of the price oracle.\n   * @return The address of the PriceOracle\n   */\n  function getPriceOracle() external view returns (address);\n\n  /**\n   * @notice Updates the address of the price oracle.\n   * @param newPriceOracle The address of the new PriceOracle\n   */\n  function setPriceOracle(address newPriceOracle) external;\n\n  /**\n   * @notice Returns the address of the ACL manager.\n   * @return The address of the ACLManager\n   */\n  function getACLManager() external view returns (address);\n\n  /**\n   * @notice Updates the address of the ACL manager.\n   * @param newAclManager The address of the new ACLManager\n   */\n  function setACLManager(address newAclManager) external;\n\n  /**\n   * @notice Returns the address of the ACL admin.\n   * @return The address of the ACL admin\n   */\n  function getACLAdmin() external view returns (address);\n\n  /**\n   * @notice Updates the address of the ACL admin.\n   * @param newAclAdmin The address of the new ACL admin\n   */\n  function setACLAdmin(address newAclAdmin) external;\n\n  /**\n   * @notice Returns the address of the price oracle sentinel.\n   * @return The address of the PriceOracleSentinel\n   */\n  function getPriceOracleSentinel() external view returns (address);\n\n  /**\n   * @notice Updates the address of the price oracle sentinel.\n   * @param newPriceOracleSentinel The address of the new PriceOracleSentinel\n   */\n  function setPriceOracleSentinel(address newPriceOracleSentinel) external;\n\n  /**\n   * @notice Returns the address of the data provider.\n   * @return The address of the DataProvider\n   */\n  function getPoolDataProvider() external view returns (address);\n\n  /**\n   * @notice Updates the address of the data provider.\n   * @param newDataProvider The address of the new DataProvider\n   */\n  function setPoolDataProvider(address newDataProvider) external;\n}\n"
    },
    "lib/aave-umbrella/lib/aave-v3-origin/lib/solidity-utils/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "lib/aave-umbrella/lib/aave-v3-origin/src/contracts/protocol/libraries/types/DataTypes.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nlibrary DataTypes {\n  /**\n   * This exists specifically to maintain the `getReserveData()` interface, since the new, internal\n   * `ReserveData` struct includes the reserve's `virtualUnderlyingBalance`.\n   */\n  struct ReserveDataLegacy {\n    //stores the reserve configuration\n    ReserveConfigurationMap configuration;\n    //the liquidity index. Expressed in ray\n    uint128 liquidityIndex;\n    //the current supply rate. Expressed in ray\n    uint128 currentLiquidityRate;\n    //variable borrow index. Expressed in ray\n    uint128 variableBorrowIndex;\n    //the current variable borrow rate. Expressed in ray\n    uint128 currentVariableBorrowRate;\n    // DEPRECATED on v3.2.0\n    uint128 currentStableBorrowRate;\n    //timestamp of last update\n    uint40 lastUpdateTimestamp;\n    //the id of the reserve. Represents the position in the list of the active reserves\n    uint16 id;\n    //aToken address\n    address aTokenAddress;\n    // DEPRECATED on v3.2.0\n    address stableDebtTokenAddress;\n    //variableDebtToken address\n    address variableDebtTokenAddress;\n    //address of the interest rate strategy\n    address interestRateStrategyAddress;\n    //the current treasury balance, scaled\n    uint128 accruedToTreasury;\n    //the outstanding unbacked aTokens minted through the bridging feature\n    uint128 unbacked;\n    //the outstanding debt borrowed against this asset in isolation mode\n    uint128 isolationModeTotalDebt;\n  }\n\n  struct ReserveData {\n    //stores the reserve configuration\n    ReserveConfigurationMap configuration;\n    //the liquidity index. Expressed in ray\n    uint128 liquidityIndex;\n    //the current supply rate. Expressed in ray\n    uint128 currentLiquidityRate;\n    //variable borrow index. Expressed in ray\n    uint128 variableBorrowIndex;\n    //the current variable borrow rate. Expressed in ray\n    uint128 currentVariableBorrowRate;\n    /// @notice reused `__deprecatedStableBorrowRate` storage from pre 3.2\n    // the current accumulate deficit in underlying tokens\n    uint128 deficit;\n    //timestamp of last update\n    uint40 lastUpdateTimestamp;\n    //the id of the reserve. Represents the position in the list of the active reserves\n    uint16 id;\n    //timestamp until when liquidations are not allowed on the reserve, if set to past liquidations will be allowed\n    uint40 liquidationGracePeriodUntil;\n    //aToken address\n    address aTokenAddress;\n    // DEPRECATED on v3.2.0\n    address __deprecatedStableDebtTokenAddress;\n    //variableDebtToken address\n    address variableDebtTokenAddress;\n    //address of the interest rate strategy\n    address interestRateStrategyAddress;\n    //the current treasury balance, scaled\n    uint128 accruedToTreasury;\n    //the outstanding unbacked aTokens minted through the bridging feature\n    uint128 unbacked;\n    //the outstanding debt borrowed against this asset in isolation mode\n    uint128 isolationModeTotalDebt;\n    //the amount of underlying accounted for by the protocol\n    uint128 virtualUnderlyingBalance;\n  }\n\n  struct ReserveConfigurationMap {\n    //bit 0-15: LTV\n    //bit 16-31: Liq. threshold\n    //bit 32-47: Liq. bonus\n    //bit 48-55: Decimals\n    //bit 56: reserve is active\n    //bit 57: reserve is frozen\n    //bit 58: borrowing is enabled\n    //bit 59: DEPRECATED: stable rate borrowing enabled\n    //bit 60: asset is paused\n    //bit 61: borrowing in isolation mode is enabled\n    //bit 62: siloed borrowing enabled\n    //bit 63: flashloaning enabled\n    //bit 64-79: reserve factor\n    //bit 80-115: borrow cap in whole tokens, borrowCap == 0 => no cap\n    //bit 116-151: supply cap in whole tokens, supplyCap == 0 => no cap\n    //bit 152-167: liquidation protocol fee\n    //bit 168-175: DEPRECATED: eMode category\n    //bit 176-211: unbacked mint cap in whole tokens, unbackedMintCap == 0 => minting disabled\n    //bit 212-251: debt ceiling for isolation mode with (ReserveConfiguration::DEBT_CEILING_DECIMALS) decimals\n    //bit 252: virtual accounting is enabled for the reserve\n    //bit 253-255 unused\n\n    uint256 data;\n  }\n\n  struct UserConfigurationMap {\n    /**\n     * @dev Bitmap of the users collaterals and borrows. It is divided in pairs of bits, one pair per asset.\n     * The first bit indicates if an asset is used as collateral by the user, the second whether an\n     * asset is borrowed by the user.\n     */\n    uint256 data;\n  }\n\n  // DEPRECATED: kept for backwards compatibility, might be removed in a future version\n  struct EModeCategoryLegacy {\n    // each eMode category has a custom ltv and liquidation threshold\n    uint16 ltv;\n    uint16 liquidationThreshold;\n    uint16 liquidationBonus;\n    // DEPRECATED\n    address priceSource;\n    string label;\n  }\n\n  struct CollateralConfig {\n    uint16 ltv;\n    uint16 liquidationThreshold;\n    uint16 liquidationBonus;\n  }\n\n  struct EModeCategoryBaseConfiguration {\n    uint16 ltv;\n    uint16 liquidationThreshold;\n    uint16 liquidationBonus;\n    string label;\n  }\n\n  struct EModeCategory {\n    // each eMode category has a custom ltv and liquidation threshold\n    uint16 ltv;\n    uint16 liquidationThreshold;\n    uint16 liquidationBonus;\n    uint128 collateralBitmap;\n    string label;\n    uint128 borrowableBitmap;\n  }\n\n  enum InterestRateMode {\n    NONE,\n    __DEPRECATED,\n    VARIABLE\n  }\n\n  struct ReserveCache {\n    uint256 currScaledVariableDebt;\n    uint256 nextScaledVariableDebt;\n    uint256 currLiquidityIndex;\n    uint256 nextLiquidityIndex;\n    uint256 currVariableBorrowIndex;\n    uint256 nextVariableBorrowIndex;\n    uint256 currLiquidityRate;\n    uint256 currVariableBorrowRate;\n    uint256 reserveFactor;\n    ReserveConfigurationMap reserveConfiguration;\n    address aTokenAddress;\n    address variableDebtTokenAddress;\n    uint40 reserveLastUpdateTimestamp;\n  }\n\n  struct ExecuteLiquidationCallParams {\n    uint256 reservesCount;\n    uint256 debtToCover;\n    address collateralAsset;\n    address debtAsset;\n    address user;\n    bool receiveAToken;\n    address priceOracle;\n    uint8 userEModeCategory;\n    address priceOracleSentinel;\n  }\n\n  struct ExecuteSupplyParams {\n    address asset;\n    uint256 amount;\n    address onBehalfOf;\n    uint16 referralCode;\n  }\n\n  struct ExecuteBorrowParams {\n    address asset;\n    address user;\n    address onBehalfOf;\n    uint256 amount;\n    InterestRateMode interestRateMode;\n    uint16 referralCode;\n    bool releaseUnderlying;\n    uint256 reservesCount;\n    address oracle;\n    uint8 userEModeCategory;\n    address priceOracleSentinel;\n  }\n\n  struct ExecuteRepayParams {\n    address asset;\n    uint256 amount;\n    InterestRateMode interestRateMode;\n    address onBehalfOf;\n    bool useATokens;\n  }\n\n  struct ExecuteWithdrawParams {\n    address asset;\n    uint256 amount;\n    address to;\n    uint256 reservesCount;\n    address oracle;\n    uint8 userEModeCategory;\n  }\n\n  struct ExecuteEliminateDeficitParams {\n    address asset;\n    uint256 amount;\n  }\n\n  struct ExecuteSetUserEModeParams {\n    uint256 reservesCount;\n    address oracle;\n    uint8 categoryId;\n  }\n\n  struct FinalizeTransferParams {\n    address asset;\n    address from;\n    address to;\n    uint256 amount;\n    uint256 balanceFromBefore;\n    uint256 balanceToBefore;\n    uint256 reservesCount;\n    address oracle;\n    uint8 fromEModeCategory;\n  }\n\n  struct FlashloanParams {\n    address receiverAddress;\n    address[] assets;\n    uint256[] amounts;\n    uint256[] interestRateModes;\n    address onBehalfOf;\n    bytes params;\n    uint16 referralCode;\n    uint256 flashLoanPremiumToProtocol;\n    uint256 flashLoanPremiumTotal;\n    uint256 reservesCount;\n    address addressesProvider;\n    address pool;\n    uint8 userEModeCategory;\n    bool isAuthorizedFlashBorrower;\n  }\n\n  struct FlashloanSimpleParams {\n    address receiverAddress;\n    address asset;\n    uint256 amount;\n    bytes params;\n    uint16 referralCode;\n    uint256 flashLoanPremiumToProtocol;\n    uint256 flashLoanPremiumTotal;\n  }\n\n  struct FlashLoanRepaymentParams {\n    uint256 amount;\n    uint256 totalPremium;\n    uint256 flashLoanPremiumToProtocol;\n    address asset;\n    address receiverAddress;\n    uint16 referralCode;\n  }\n\n  struct CalculateUserAccountDataParams {\n    UserConfigurationMap userConfig;\n    uint256 reservesCount;\n    address user;\n    address oracle;\n    uint8 userEModeCategory;\n  }\n\n  struct ValidateBorrowParams {\n    ReserveCache reserveCache;\n    UserConfigurationMap userConfig;\n    address asset;\n    address userAddress;\n    uint256 amount;\n    InterestRateMode interestRateMode;\n    uint256 reservesCount;\n    address oracle;\n    uint8 userEModeCategory;\n    address priceOracleSentinel;\n    bool isolationModeActive;\n    address isolationModeCollateralAddress;\n    uint256 isolationModeDebtCeiling;\n  }\n\n  struct ValidateLiquidationCallParams {\n    ReserveCache debtReserveCache;\n    uint256 totalDebt;\n    uint256 healthFactor;\n    address priceOracleSentinel;\n  }\n\n  struct CalculateInterestRatesParams {\n    uint256 unbacked;\n    uint256 liquidityAdded;\n    uint256 liquidityTaken;\n    uint256 totalDebt;\n    uint256 reserveFactor;\n    address reserve;\n    bool usingVirtualBalance;\n    uint256 virtualUnderlyingBalance;\n  }\n\n  struct InitReserveParams {\n    address asset;\n    address aTokenAddress;\n    address variableDebtAddress;\n    address interestRateStrategyAddress;\n    uint16 reservesCount;\n    uint16 maxNumberReserves;\n  }\n}\n"
    }
  },
  "settings": {
    "remappings": [
      "forge-std/=lib/aave-umbrella/lib/forge-std/src/",
      "@openzeppelin/contracts-upgradeable/=lib/aave-umbrella/lib/aave-v3-origin/lib/solidity-utils/lib/openzeppelin-contracts-upgradeable/contracts/",
      "@openzeppelin/contracts/=lib/aave-umbrella/lib/aave-v3-origin/lib/solidity-utils/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/",
      "openzeppelin-contracts-upgradeable/=lib/aave-umbrella/lib/aave-v3-origin/lib/solidity-utils/lib/openzeppelin-contracts-upgradeable/",
      "openzeppelin-contracts/=lib/aave-umbrella/lib/aave-v3-origin/lib/solidity-utils/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/",
      "aave-v3-core/=lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/core/",
      "aave-v3-origin-tests/=lib/aave-umbrella/lib/aave-v3-origin/tests/",
      "aave-v3-origin/=lib/aave-umbrella/lib/aave-v3-origin/src/",
      "aave-v3-periphery/=lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/periphery/",
      "solidity-utils/=lib/aave-umbrella/lib/aave-v3-origin/lib/solidity-utils/src/",
      "aave-address-book/=lib/aave-helpers/lib/aave-address-book/src/",
      "aave-helpers/=lib/aave-helpers/src/",
      "aave-umbrella/=lib/aave-umbrella/",
      "ds-test/=lib/aave-umbrella/lib/aave-v3-origin/lib/forge-std/lib/ds-test/src/",
      "erc4626-tests/=lib/aave-umbrella/lib/erc4626-tests/",
      "halmos-cheatcodes/=lib/aave-umbrella/lib/aave-v3-origin/lib/solidity-utils/lib/openzeppelin-contracts-upgradeable/lib/halmos-cheatcodes/src/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "metadata": {
      "useLiteralContent": false,
      "bytecodeHash": "ipfs",
      "appendCBOR": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "evmVersion": "shanghai",
    "viaIR": false,
    "libraries": {}
  }
}}