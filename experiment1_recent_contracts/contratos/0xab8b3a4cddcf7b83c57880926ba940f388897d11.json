{{
  "language": "Solidity",
  "sources": {
    "src/utils/GatewayUtils.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.28;\n\nimport {IGatewayManager} from \"src/interfaces/IGatewayManager.sol\";\n\n/**\n * @title GatewayUtils\n * @author Libre\n * @notice Utility functions for gateway contracts\n * @dev Shared utilities used by LibreCoreGateway and GatewayManager\n */\nlibrary GatewayUtils {\n    /**\n     * @notice Error thrown when input data is invalid\n     */\n    error GatewayUtils_InvalidInput();\n\n    /**\n     * @notice Bridges wallet address changes to other chains\n     * @param _gatewayManager The gateway manager contract\n     * @param _userId The ID of the user\n     * @param _wallet The wallet address being added or removed\n     * @param _isAdd True if adding a wallet, false if removing\n     * @param _nativeChainSelector The chain selector for the native chain\n     * @param _gatewayManagerRole The role required for cross-chain operations\n     */\n    function bridgeAddressChange(\n        IGatewayManager _gatewayManager,\n        bytes32 _userId,\n        address _wallet,\n        bool _isAdd,\n        uint16 _nativeChainSelector,\n        bytes32 _gatewayManagerRole\n    ) public {\n        if (address(_gatewayManager) == address(0)) {\n            return;\n        }\n\n        bytes memory addressChange = encodeAddressChange(_wallet, _isAdd, _nativeChainSelector);\n\n        bytes[] memory addressChanges = new bytes[](1);\n        addressChanges[0] = addressChange;\n\n        // Bridge the address change to other chains\n        _gatewayManager.manageCrossChainAddresses(_gatewayManagerRole, _userId, addressChanges);\n    }\n\n    /**\n     * @notice Decodes an address change byte array\n     * @param addressChange The encoded address change\n     * @return isAdd True if adding an address, false if removing\n     * @return chainId The chain ID for the address\n     * @return walletAddress The wallet address being added or removed\n     */\n    function decodeAddressChange(bytes calldata addressChange)\n        public\n        pure\n        returns (bool isAdd, uint16 chainId, bytes memory walletAddress)\n    {\n        // excluding the action and chainId, the address has to be of at least one byte\n        if (addressChange.length < 4) {\n            revert GatewayUtils_InvalidInput();\n        }\n\n        // Extract isAdd, first byte (0 -> Add, 1 -> Remove)\n        isAdd = addressChange[0] == 0x00;\n\n        // Extract chainId (bytes 1-2)\n        chainId = uint16(uint8(addressChange[1])) << 8 | uint16(uint8(addressChange[2]));\n\n        // Remaining bytes are the wallet address\n        uint256 walletLength = addressChange.length - 3;\n        walletAddress = new bytes(walletLength);\n        for (uint256 i; i < walletLength; ++i) {\n            walletAddress[i] = addressChange[i + 3];\n        }\n    }\n\n    /**\n     * @notice Creates an encoded address change\n     * @param _wallet The wallet address being added or removed\n     * @param _isAdd True if adding a wallet, false if removing\n     * @param _chainSelector The chain selector for the chain\n     * @return The encoded address change\n     */\n    function encodeAddressChange(address _wallet, bool _isAdd, uint16 _chainSelector)\n        public\n        pure\n        returns (bytes memory)\n    {\n        // Create the address change encoding: [action byte][2 bytes chainSelector][n bytes address]\n        bytes memory addressChange = new bytes(23); // 1 byte action + 2 bytes chainSelector + 20 bytes address\n        addressChange[0] = _isAdd ? bytes1(0x00) : bytes1(0x01); // 0x00 for add, 0x01 for remove\n\n        // Set the chainSelector\n        addressChange[1] = bytes1(uint8(_chainSelector >> 8));\n        addressChange[2] = bytes1(uint8(_chainSelector));\n\n        // Copy the wallet address bytes\n        bytes memory walletBytes = abi.encodePacked(_wallet);\n        for (uint256 i = 0; i < 20; i++) {\n            addressChange[i + 3] = walletBytes[i];\n        }\n\n        return addressChange;\n    }\n}\n"
    },
    "src/interfaces/IGatewayManager.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {IInvestorRegistry} from \"src/interfaces/IInvestorRegistry.sol\";\nimport {IRoleRegistry} from \"src/interfaces/IRoleRegistry.sol\";\nimport {ILibreCoreGateway} from \"src/interfaces/ILibreCoreGateway.sol\";\nimport {IEAS} from \"eas-contracts/IEAS.sol\";\n\n/**\n * @title IGatewayManager Interface\n * @notice Interface for managing cross-chain addresses and investor chain preferences\n * @dev Coordinates with LibreCoreGateway for cross-chain operations\n */\ninterface IGatewayManager {\n    /**\n     * @notice Emitted when an investor's preferred chains are updated or set\n     * @param investorId The unique identifier of the investor\n     * @param chains Array of custom chain IDs that the investor prefers\n     * @param oldChains Previous array of chain IDs for the investor\n     */\n    event InvestorChainsUpdated(bytes32 investorId, uint16[] chains, uint16[] oldChains);\n\n    /**\n     * @notice Emitted when cross-chain addresses are updated for an investor\n     * @dev Each address change is encoded as: [1 byte action][2 bytes chainSelector][n bytes address]\n     * @param investorId The unique identifier of the investor\n     * @param addressChanges A list of concatenated bytes describing a change in multi-chain address\n     */\n    event InvestorAddressesUpdated(bytes32 investorId, bytes[] addressChanges);\n\n    /// @notice Thrown when an unsupported or invalid chain ID is provided\n    error GatewayManager_InvalidChain();\n\n    /// @notice Thrown when the investor ID doesn't exist or is invalid\n    error GatewayManager_InvalidInvestor();\n\n    /// @notice Thrown when input parameters are invalid or missing\n    error GatewayManager_InvalidInput();\n\n    /// @notice Thrown when a cross-chain address is already associated with another investor\n    error GatewayManager_AddressAlreadyUsed();\n\n    /**\n     * @notice Initializes the gateway manager\n     * @param _coreGateway Address of the LibreCoreGateway contract\n     * @param _eas Address of the Ethereum Attestation Service\n     * @param _investorRegistry Address of the InvestorRegistry contract\n     * @param _roleRegistry Address of the RoleRegistry contract\n     */\n    function initialize(\n        ILibreCoreGateway _coreGateway,\n        IEAS _eas,\n        IInvestorRegistry _investorRegistry,\n        IRoleRegistry _roleRegistry\n    ) external;\n\n    /**\n     * @notice Sets the preferred chains for an investor\n     * @param _senderRole Role of the transaction sender\n     * @param _investorId Unique identifier of the investor\n     * @param _chains Array of chain IDs to set as preferred\n     */\n    function setInvestorChains(bytes32 _senderRole, bytes32 _investorId, uint16[] calldata _chains) external;\n\n    /**\n     * @notice Updates investor's cross-chain addresses and propagates changes to other chains\n     * @dev Adds or removes addresses and bridges the updates to other chains\n     * @param _senderRole Role of the transaction sender\n     * @param _investorId Unique identifier of the investor\n     * @param _addressChanges A list of concatenated bytes describing a change in multi-chain address\n     */\n    function manageCrossChainAddresses(bytes32 _senderRole, bytes32 _investorId, bytes[] calldata _addressChanges)\n        external;\n\n    /**\n     * @notice Bridges a credential to all investor's preferred chains via core gateway.\n     * @param _attestationId The unique ID of the attestation to be bridged.\n     * @param _senderRole Role of the transaction sender.\n     * @param _chains Chains to bridge credential to (all investor chains if empty)\n     */\n    function bridgeCredential(bytes32 _attestationId, bytes32 _senderRole, uint16[] memory _chains) external;\n\n    /**\n     * @notice Validates if an address is a valid cross-chain address for an investor\n     * @param _investorId The investor ID to check\n     * @param _chainSelector The chain ID to check\n     * @param _address The address to validate\n     * @return bool True if the address is valid for the investor on the chain\n     */\n    function isValidCrossChainAddress(bytes32 _investorId, uint16 _chainSelector, bytes calldata _address)\n        external\n        view\n        returns (bool);\n\n    /**\n     * @notice Gets an investor's preferred chains\n     * @param _investorId The investor's unique identifier\n     * @return uint16[] Array of preferred chain IDs\n     */\n    function getInvestorChains(bytes32 _investorId) external view returns (uint16[] memory);\n\n    /**\n     * @notice Gets the owner of a cross-chain address\n     * @param _chainSelector The chain ID of the address\n     * @param _address The address to get the owner of\n     * @return bytes32 The owner of the address\n     */\n    function getAddressOwner(uint16 _chainSelector, bytes calldata _address) external view returns (bytes32);\n}\n"
    },
    "src/interfaces/IInvestorRegistry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {IERC20MetadataUpgradeable} from\n    \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\n\nimport {IEAS, AttestationRequestData} from \"eas-contracts/IEAS.sol\";\nimport {IRiscZeroVerifier} from \"risc0/IRiscZeroVerifier.sol\";\n\nimport {IBaseRegistry} from \"src/interfaces/IBaseRegistry.sol\";\nimport {IRoleRegistry} from \"src/interfaces/IRoleRegistry.sol\";\nimport {IInstrumentRegistry} from \"src/interfaces/IInstrumentRegistry.sol\";\nimport {IDealerRegistry} from \"src/interfaces/IDealerRegistry.sol\";\nimport {IOperationsEngine} from \"src/interfaces/IOperationsEngine.sol\";\nimport {IUserRegistry} from \"src/interfaces/IUserRegistry.sol\";\nimport {IGatewayManager} from \"src/interfaces/IGatewayManager.sol\";\nimport {IEternalRegistryStorage} from \"src/interfaces/IEternalRegistryStorage.sol\";\nimport {OrderProofData, SteelProofData, CredentialProofData} from \"src/utils/Types.sol\";\nimport {IRiscZeroVerifier} from \"risc0/IRiscZeroVerifier.sol\";\n\n/**\n * @title IInvestorRegistry\n * @author Libre\n * @notice Interface for managing investors, including adding new investors, managing credentials, and verifying subscriptions.\n * It integrates with Ethereum Attestation Service (EAS) and zk-verifiers to ensure security and compliance.\n */\ninterface IInvestorRegistry is IBaseRegistry, IUserRegistry {\n    /// @notice Thrown when an operation is not permitted due to insufficient privileges.\n    error IInvestorRegistry_OperationNotPermitted();\n\n    /// @notice Thrown when the sender is not the dealer associated with the specified investor.\n    error IInvestorRegistry_NotInvestorsDealer();\n\n    /// @notice Thrown when the caller is not the Operations Engine.\n    error IInvestorRegistry_NotOperationsEngine();\n\n    /// @notice Thrown when the caller is not the Jurisdiction Registry.\n    error IInvestorRegistry_NotJurisdictionRegistry();\n\n    /// @notice Thrown when attempting to add an investor who is already registered.\n    error IInvestorRegistry_AlreadyAnInvestor();\n\n    /// @notice Thrown when the sender does not have the Contract Manager role.\n    error IInvestorRegistry_NoContractManagerRole();\n\n    /// @notice Thrown when the Resolver Verifier address is empty or invalid.\n    error IInvestorRegistry_EmptyResolverVerifier();\n\n    /// @notice Thrown when the provided zk program image IDs are empty.\n    error IInvestorRegistry_EmptyImageIDs();\n\n    /// @notice Thrown when the sender does not have the Attester role.\n    error IInvestorRegistry_NoAttesterRole();\n\n    /// @notice Thrown when attempting to access a schema that has not been set.\n    error IInvestorRegistry_SchemaNotSet();\n\n    /// @notice Thrown when attempting to access a credential that does not exist.\n    error IInvestorRegistry_NonExistingCredential();\n\n    /// @notice Thrown when the credential is found to be invalid or revoked.\n    error IInvestorRegistry_CredentialInvalid();\n\n    /// @notice Thrown when the Investor Id doesn't match with the attestation's investor Id.\n    error IInvestorRegistry_MismatchInvestorId();\n\n    /// @notice Thrown when a credential does not grant access to the specified instrument.\n    error IInvestorRegistry_InstrumentCredentialInvalid();\n\n    /// @notice Thrown when attempting to revoke access to instruments that are not part of the credential.\n    error IInvestorRegistry_InstrumentsToRevokeNotInCredential();\n\n    /// @notice Thrown when there is a mismatch in the policy viewer proof.\n    error IInvestorRegistry_PolicyViewerProofMismatch();\n\n    /// @notice Thrown when an invalid dealer ID is provided.\n    error IInvestorRegistry_InvalidDealerId();\n\n    // Events\n    /**\n     * @notice Emitted when a new investor is added to the registry.\n     * @param investorId The unique identifier of the new investor.\n     * @param wallet The initial wallet address associated with the investor.\n     */\n    event NewInvestorAdded(bytes32 investorId, address wallet);\n\n    /**\n     * @notice Emitted when a credential is set for an investor.\n     * @param investorId The unique identifier of the investor.\n     * @param instrumentIds The list of instrument IDs included in the credential.\n     */\n    event InvestorRegistryCredentialSet(bytes32 investorId, bytes32[] instrumentIds);\n\n    /**\n     * @notice Emitted when a credential is revoked for an investor.\n     * @param investorId The unique identifier of the investor.\n     * @param instrumentIds The list of instrument IDs that have been revoked.\n     */\n    event InvestorRegistryCredentialRevoked(bytes32 investorId, bytes32[] instrumentIds);\n\n    /**\n     * @notice Emitted when the Resolver Verifier is updated.\n     * @param resolverVerifierAddress The address of the new Resolver Verifier.\n     */\n    event InvestorRegistryResolverVerifierChanged(address resolverVerifierAddress);\n\n    /**\n     * @notice Emitted when the zk program image IDs are updated.\n     * @param credentialImageID The new image ID for the credential zk program.\n     * @param subscriptionImageID The new image ID for the subscription zk program.\n     */\n    event InvestorRegistryImageIDsChanged(bytes32 credentialImageID, bytes32 subscriptionImageID);\n\n    /**\n     * @notice Initialize the registry\n     * @param _roleRegistry Address of the Role Registry\n     * @param _instrumentRegistry Address of the Instrument Registry\n     * @param _dealerRegistry Address of the Dealer Registry\n     * @param _jurisdictionRegistry Address of the Jurisdiction Registry\n     * @param _operationsEngine Address of the Operations Engine\n     * @param _eas Address of the Ethereum Attestation Service contract\n     * @param _gatewayManager Address of the gateway manager contract\n     * @param _resolverVerifier Address of the Resolver Verifier\n     * @param _policyViewer Address of the Policy Viewer\n     */\n    function initialize(\n        IRoleRegistry _roleRegistry,\n        IInstrumentRegistry _instrumentRegistry,\n        IDealerRegistry _dealerRegistry,\n        IEternalRegistryStorage _jurisdictionRegistry,\n        IOperationsEngine _operationsEngine,\n        IEAS _eas,\n        IGatewayManager _gatewayManager,\n        address _resolverVerifier,\n        address _policyViewer\n    ) external;\n\n    /**\n     * @notice Adds a new investor to the registry\n     * @param _senderRole Role the sender claims to have\n     * @param _investorId ID of the investor\n     * @param _wallet Default address of the investor\n     * @param _dealerId ID of the dealer\n     */\n    function addInvestor(bytes32 _senderRole, bytes32 _investorId, address _wallet, bytes32 _dealerId) external;\n\n    /**\n     * @notice Checks a subscription is allowed into the instrument\n     * @param _proof proof data for zk verifier\n     */\n    function checkSubscription(OrderProofData calldata _proof) external view;\n\n    /**\n     * @notice Replaces the ResolverVerifier contract with a new version, renewing the schema in the process\n     * @param _resolverVerifier address of new resolverVerifier\n     */\n    function configureResolverVerifier(address _resolverVerifier) external;\n\n    /**\n     * @notice Changes the zk program image IDs to use with the verifier\n     * @param _credentialImageID new image ID for the credential zk program\n     * @param _subscriptionImageID new image ID for the subscription zk program\n     */\n    function configureImageIDs(bytes32 _credentialImageID, bytes32 _subscriptionImageID) external;\n\n    /**\n     * @notice Creates a new investor credential or updates an existing/revoked one\n     * @param _proof contains data for setting the credential, including the zk-proof to verify\n     * @dev When updating credential, seal should contain the proof for new instruments, while\n     * the journal should include existing ones to be kept, bridge new credential via gateway manager\n     */\n    function setCredential(CredentialProofData calldata _proof) external;\n\n    /**\n     * @notice Revokes an investor credential, or access to certain instruments, bridge revoked credential via gateway manager\n     * @param _investorId Id of the investor\n     * @param _instrumentIds Instruments to revoke access from (entire credential revoked if left empty)\n     */\n    function revokeCredential(bytes32 _investorId, bytes32[] calldata _instrumentIds) external;\n\n    /**\n     * @notice Checks if the investor has a valid credential\n     * @param _investorId Id of the investor\n     */\n    function checkCredential(bytes32 _investorId) external view;\n\n    /**\n     * @notice Checks if the investor has a valid credential granting access to the instrument\n     * @param _investorId Id of the investor\n     * @param _instrumentId Id of the instrument\n     */\n    function checkCredentialInstrument(bytes32 _investorId, bytes32 _instrumentId) external view;\n\n    /**\n     * @notice Get dealer id of an investor\n     * @param _investorId The ID of the investor\n     * @return dealerId_ Id of the dealer associated to the investor\n     */\n    function getDealer(bytes32 _investorId) external view returns (bytes32 dealerId_);\n\n    /**\n     * Used by the ResolverVerifier to fetch the proof data for the current attestation\n     * @return Proof Data\n     */\n    function getTempSteelProofData() external view returns (SteelProofData memory);\n}\n"
    },
    "src/interfaces/IRoleRegistry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {IAccessControlUpgradeable} from\n    \"openzeppelin-contracts-upgradeable/contracts/access/IAccessControlUpgradeable.sol\";\n\n/**\n * @title Roles Registry\n * @author Libre\n * @notice Store all the roles of the system as well as the permissions a user get by having each role.\n * @dev It is meant to be used for roles access validation in all the components of the system.\n */\ninterface IRoleRegistry is IAccessControlUpgradeable {\n    /**\n     * @notice Thrown when attempting to create a role that already exists.\n     */\n    error IRoleRegistry_RoleAlreadyExists();\n\n    /**\n     * @notice Thrown when attempting to grant a role that does not exist.\n     */\n    error IRoleRegistry_RoleDoesNotExist();\n\n    /**\n     * @notice Thrown when attempting to use a blacklisted wallet.\n     */\n    error IRoleRegistry_WalletBlacklisted();\n\n    /**\n     * @notice Used when a new role is created\n     * @param _role Parent role\n     * @param _subRole Newly created Role\n     */\n    event RoleCreated(bytes32 _role, bytes32 _subRole);\n\n    /**\n     * @notice Used when a contract manager is set\n     * @param _contract Contract managed\n     * @param _roleManager New contract manager role\n     */\n    event ContractManagerAdded(address _contract, bytes32 _roleManager);\n\n    /**\n     * @notice Used when a wallet is blacklisted\n     * @param _wallet Wallet blacklisted\n     */\n    event WalletBlacklisted(address _wallet);\n\n    /**\n     * @notice Used when a contract function access is granted\n     * @param _contract Contract managed\n     * @param _selector Selector of the funtion which access is modified\n     * @param _role Role getting access gratend\n     */\n    event AccessGranted(address _contract, bytes4 _selector, bytes32 _role);\n\n    /**\n     * @notice Used when a contract function access is revoked\n     * @param _contract Contract managed\n     * @param _selector Selector of the funtion which access is modified\n     * @param _role Role which access is revoked\n     */\n    event RevokedAccess(address _contract, bytes4 _selector, bytes32 _role);\n\n    /**\n     * @notice Used when a contract access is reset\n     * @param _contract Contract managed\n     * @param _timestamp Time when the reset is executed\n     */\n    event ResetedAccess(address _contract, uint256 _timestamp);\n\n    /**\n     * @notice Function to create subroles\n     * @param _role New role to create\n     * @param _adminRole Parent role of the newly created role\n     * @dev Caller needs to has role _adminRole\n     */\n    function createRole(bytes32 _role, bytes32 _adminRole) external;\n\n    /**\n     * @notice Set the role going to manage permissions in a specific contract\n     * @param _contract Address of the contract to where permissions are needed to be managed\n     * @param _roleManager Role in charge of managing the permissions\n     */\n    function setContractManager(address _contract, bytes32 _roleManager) external;\n\n    /**\n     * @notice Get the role that manages permissions in a specific contract\n     * @param _contract Address of the contract\n     */\n    function getContractManager(address _contract) external view returns (bytes32);\n\n    /**\n     * @notice Grant a role the right access a functionality of a contract\n     * @param _contract Contract where the access is granted\n     * @param _selector Functionality granted access for\n     * @param _role Role getting the access\n     */\n    function grantAccess(address _contract, bytes4 _selector, bytes32 _role) external;\n\n    /**\n     * @notice Prevent a role for having access to a functionality of a contract\n     * @param _contract Contract where the access is revoked\n     * @param _selector Functionality revoked access for\n     * @param _role Role losing the access\n     */\n    function revokeAccess(address _contract, bytes4 _selector, bytes32 _role) external;\n\n    /**\n     * @notice Revoke access to a functionality of a contract for all roles\n     * @param _contract Contract where the access is reset\n     * @param _selector Functionality reset access for\n     * @dev Cleans all the previously granted roles\n     */\n    function resetAccess(address _contract, bytes4 _selector) external;\n\n    /**\n     * @notice Blacklists a wallet.\n     * @param _wallet The wallet to blacklist.\n     */\n    function blacklistWallet(address _wallet) external;\n\n    /**\n     * @notice Check access of a role to a contract functionality\n     * @param _contract Contract where accessed\n     * @param _selector Functionality accessed\n     * @param _requestor Address attempting to access\n     * @param _role Role of the address attempting to access\n     */\n    function hasAccess(address _contract, bytes4 _selector, address _requestor, bytes32 _role)\n        external\n        view\n        returns (bool);\n\n    /**\n     * @notice Checks if a wallet is blacklisted.\n     * @param _wallet The wallet to check.\n     * @return Boolean indicating whether the wallet is blacklisted.\n     */\n    function isBlacklisted(address _wallet) external view returns (bool);\n}\n"
    },
    "src/interfaces/ILibreCoreGateway.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {IInvestorRegistry} from \"src/interfaces/IInvestorRegistry.sol\";\nimport {IInstrumentRegistry} from \"src/interfaces/IInstrumentRegistry.sol\";\nimport {IRoleRegistry} from \"src/interfaces/IRoleRegistry.sol\";\nimport {IGatewayManager} from \"src/interfaces/IGatewayManager.sol\";\nimport {Attestation} from \"eas-contracts/IEAS.sol\";\n\n/**\n * @notice Structure representing token transfer details across chains\n * @dev Used for both locking and unlocking operations\n */\nstruct TokenTransfer {\n    uint16 chainSelector; // Unique 16-bit Custom Chain ID where the Token is transfered\n    bytes32 instrumentId; // Instrument ID associated with the security token\n    bytes32 investorId; // Investor ID associated with the sender\n    bytes receiver; // Recipient's address for minting/unlocking\n    uint256 amount; // Amount of the asset to transfer\n}\n\n/**\n * @notice Structure for managing investor addresses across specific chain\n * @dev Each address change is encoded as: [1 byte action][n bytes address]\n */\nstruct ChainInvestorAddresses {\n    // Unique investor ID\n    bytes32 investorId;\n    // Unique chain ID\n    uint16 chainSelector;\n    // Address size for that chain\n    uint8 addressSize;\n    // A list of concatenated bytes describing a change in addresses\n    // Format `addressChanges`` := bytes1 action ++ bytes accountAddress\n    // where `action`: 0b0 -> Add, 0b1 -> Remove\n    bytes[] addressChanges;\n}\n\n/// @notice Interface for the Libre Core Gateway.\ninterface ILibreCoreGateway {\n    // Events\n    /**\n     * @notice Emitted when tokens are locked on source chain\n     * @param encodedTransferDetails ABI-encoded TokenTransfer struct\n     */\n    event TokenLockedAndBridged(bytes encodedTransferDetails);\n\n    /**\n     * @notice Emitted when tokens are unlocked on destination chain\n     * @param encodedTransferDetails ABI-encoded TokenTransfer struct\n     */\n    event TokenUnlocked(bytes encodedTransferDetails);\n\n    /**\n     * @notice Emitted when a credential is bridged to other chains\n     * @param investorId Investor ID of the investor\n     * @param chainSelectors Array of investor preffered chains on which credential to be bridged\n     * @param credentialId Unique identifier of the bridged credential\n     */\n    event CredentialBridged(bytes32 investorId, uint16[] chainSelectors, bytes32 credentialId);\n\n    /**\n     * @notice Emitted when investor chain-specific addresses are bridged\n     * @param investorId Investor ID of the investor\n     * @param chainSelectors Array of investor preferred chains on which addresses updates to be bridged\n     * @param encodedChainInvestorAddresses ABI-encoded ChainInvestorAddresses struct\n     */\n    event ChainInvestorAddressesBridged(\n        bytes32 investorId, uint16[] chainSelectors, bytes encodedChainInvestorAddresses\n    );\n\n    /**\n     * @notice Emitted when chain support status is updated\n     * @param chainSelector Chain ID whose support status changed\n     * @param isSupported New support status\n     */\n    event ChainSupportUpdated(uint16 chainSelector, bool isSupported);\n\n    /**\n     * @notice Emitted when chain variable length address support status is updated\n     * @param _chainSelector Chain ID whose support status changed\n     * @param _isVariableLengthAddress New support status\n     */\n    event ChainVariableLengthAddressSupportUpdated(uint16 _chainSelector, bool _isVariableLengthAddress);\n\n    // Custom Errors\n    /// @notice Thrown when operation is attempted on an unsupported chain\n    /// @param chainSelector The unsupported chain ID\n    error CoreGateway_ChainNotSupported(uint16 chainSelector);\n\n    /// @notice Thrown when the chain selector (chain ID) not matches with Native chain ID for unlock requests\n    error CoreGateway_InvalidNativeChainSelector();\n\n    /// @notice Thrown when token address is not found or invalid\n    /// @param token The invalid token address\n    error CoreGateway_TokenAddressNotFound(address token);\n\n    /// @notice Thrown when attempting transfer with zero amount\n    error CoreGateway_ZeroAmount();\n\n    /// @notice Thrown when transfer validation fails\n    error CoreGateway_InvalidTransfer();\n\n    /// @notice Thrown when provided investor id is not found\n    error CoreGateway_InvalidInvestor();\n\n    /// @notice Thrown when wrong inputs are provided\n    error CoreGateway_InvalidInput();\n\n    /// @notice Thrown when credential to be bridged are not stored or mismatches with registry\n    error CoreGateway_InvalidCredential();\n\n    /// @notice Thrown when an attempted status update results in no actual change.\n    error CoreGateway_NoStatusChanged();\n\n    /**\n     * @notice Initializes the gateway contract\n     * @param _instrumentRegistry Address of the Instrument Registry\n     * @param _investorRegistry Address of the Investor Registry\n     * @param _gatewayManager Address of the Gateway Manager\n     * @param _roleRegistry Address of the Role Registry\n     * @param _nativeChainSelector Native Custom Chain ID\n     * @param _supportedChains Array of supported custom chain Ids\n     */\n    function initialize(\n        IInstrumentRegistry _instrumentRegistry,\n        IInvestorRegistry _investorRegistry,\n        IGatewayManager _gatewayManager,\n        IRoleRegistry _roleRegistry,\n        uint16 _nativeChainSelector,\n        uint16[] memory _supportedChains\n    ) external;\n\n    /**\n     * @notice Locks tokens for cross-chain transfer and emits event for minting\n     * @dev Validates investor credentials and cross-chain addresses before locking\n     * @param transferDetails The details of the token transfer.\n     */\n    function lockAndBridge(TokenTransfer calldata transferDetails) external;\n\n    /**\n     * @notice Unlocks tokens on the source chain\n     * @dev Called by bridge operators to release tokens to the recipient\n     * @param _senderRole The role of the caller\n     * @param encodedTransferDetails ABI-encoded transfer details.\n     */\n    function unlock(bytes32 _senderRole, bytes calldata encodedTransferDetails) external;\n\n    /**\n     * @notice Bridges a credential to one or more destination chains.\n     * @dev Perform below steps:\n     *      1. Verifies all destination chains are supported\n     *      2. Validates the attestation matches the stored credential for the investor\n     *      3. Emits CredentialBridged event for cross-chain communication\n     * @param _senderRole The role of the caller\n     * @param attestation The attestation details to bridge.\n     * @param destinationChainSelectors Array of destination chain IDs.\n     */\n    function bridgeCredential(\n        bytes32 _senderRole,\n        Attestation calldata attestation,\n        uint16[] calldata destinationChainSelectors\n    ) external;\n\n    /**\n     * @notice Bridges investor addresses updates.\n     * @dev Processes and broadcasts chain specific address changes across investor preferred chains\n     *         Emits `ChainInvestorAddressesBridged` event for each chain's address updates.\n     *\n     * @param _senderRole The role of the caller.\n     * @param _investorId The unique identifier of the investor whose addresses are being updated.\n     * @param _addressChanges ABI-encoded updates representing address changes per chain or context.\n     * @param chainSelectors Array of investor preferred chains on which addresses updates to be bridged\n     */\n    function bridgeInvestorAddresses(\n        bytes32 _senderRole,\n        bytes32 _investorId,\n        bytes[] calldata _addressChanges,\n        uint16[] calldata chainSelectors\n    ) external;\n\n    /**\n     * @notice Pauses all gateway operations\n     * @param _senderRole The role of the caller\n     */\n    function pause(bytes32 _senderRole) external;\n\n    /**\n     * @notice Unpauses gateway operations\n     * @param _senderRole The role of the caller\n     */\n    function unpause(bytes32 _senderRole) external;\n\n    /**\n     * @notice Enables or disables support for a specific chain.\n     * @param _senderRole The role of the caller\n     * @param chainSelector The Custom chain ID.\n     * @param isSupported Whether the chain is supported.\n     */\n    function setChainSupport(bytes32 _senderRole, uint16 chainSelector, bool isSupported) external;\n\n    /**\n     * @notice Enables or disables support for variable length addresses for a specific chain.\n     * @param _senderRole The role of the caller\n     * @param _chainSelector The Custom chain ID.\n     * @param _isVariableLengthAddress Whether variable length addresses for the chain are supported.\n     */\n    function setChainVariableLengthAddressSupport(\n        bytes32 _senderRole,\n        uint16 _chainSelector,\n        bool _isVariableLengthAddress\n    ) external;\n\n    /**\n     * @notice Retrieves the total amount of a specific instrument/token locked in the gateway.\n     * @param instrumentId The Instrument ID associated with the security token\n     * @return The total amount of the token locked in the gateway\n     */\n    function getLockedBalance(bytes32 instrumentId) external view returns (uint256);\n\n    /**\n     * @notice Checks if a chain is supported.\n     * @param chainSelector The ID of the chain to check.\n     * @return True if the chain is supported, false otherwise.\n     */\n    function isSupportedChain(uint16 chainSelector) external view returns (bool);\n\n    /**\n     * @notice Gets the list of supported chains\n     * @return uint16[] Array of supported chain IDs\n     */\n    function getSupportedChains() external view returns (uint16[] memory);\n}\n"
    },
    "lib/eas-contracts/contracts/IEAS.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { ISchemaRegistry } from \"./ISchemaRegistry.sol\";\nimport { ISemver } from \"./ISemver.sol\";\nimport { Attestation, Signature } from \"./Common.sol\";\n\n/// @notice A struct representing the arguments of the attestation request.\nstruct AttestationRequestData {\n    address recipient; // The recipient of the attestation.\n    uint64 expirationTime; // The time when the attestation expires (Unix timestamp).\n    bool revocable; // Whether the attestation is revocable.\n    bytes32 refUID; // The UID of the related attestation.\n    bytes data; // Custom attestation data.\n    uint256 value; // An explicit ETH amount to send to the resolver. This is important to prevent accidental user errors.\n}\n\n/// @notice A struct representing the full arguments of the attestation request.\nstruct AttestationRequest {\n    bytes32 schema; // The unique identifier of the schema.\n    AttestationRequestData data; // The arguments of the attestation request.\n}\n\n/// @notice A struct representing the full arguments of the full delegated attestation request.\nstruct DelegatedAttestationRequest {\n    bytes32 schema; // The unique identifier of the schema.\n    AttestationRequestData data; // The arguments of the attestation request.\n    Signature signature; // The ECDSA signature data.\n    address attester; // The attesting account.\n    uint64 deadline; // The deadline of the signature/request.\n}\n\n/// @notice A struct representing the full arguments of the multi attestation request.\nstruct MultiAttestationRequest {\n    bytes32 schema; // The unique identifier of the schema.\n    AttestationRequestData[] data; // The arguments of the attestation request.\n}\n\n/// @notice A struct representing the full arguments of the delegated multi attestation request.\nstruct MultiDelegatedAttestationRequest {\n    bytes32 schema; // The unique identifier of the schema.\n    AttestationRequestData[] data; // The arguments of the attestation requests.\n    Signature[] signatures; // The ECDSA signatures data. Please note that the signatures are assumed to be signed with increasing nonces.\n    address attester; // The attesting account.\n    uint64 deadline; // The deadline of the signature/request.\n}\n\n/// @notice A struct representing the arguments of the revocation request.\nstruct RevocationRequestData {\n    bytes32 uid; // The UID of the attestation to revoke.\n    uint256 value; // An explicit ETH amount to send to the resolver. This is important to prevent accidental user errors.\n}\n\n/// @notice A struct representing the full arguments of the revocation request.\nstruct RevocationRequest {\n    bytes32 schema; // The unique identifier of the schema.\n    RevocationRequestData data; // The arguments of the revocation request.\n}\n\n/// @notice A struct representing the arguments of the full delegated revocation request.\nstruct DelegatedRevocationRequest {\n    bytes32 schema; // The unique identifier of the schema.\n    RevocationRequestData data; // The arguments of the revocation request.\n    Signature signature; // The ECDSA signature data.\n    address revoker; // The revoking account.\n    uint64 deadline; // The deadline of the signature/request.\n}\n\n/// @notice A struct representing the full arguments of the multi revocation request.\nstruct MultiRevocationRequest {\n    bytes32 schema; // The unique identifier of the schema.\n    RevocationRequestData[] data; // The arguments of the revocation request.\n}\n\n/// @notice A struct representing the full arguments of the delegated multi revocation request.\nstruct MultiDelegatedRevocationRequest {\n    bytes32 schema; // The unique identifier of the schema.\n    RevocationRequestData[] data; // The arguments of the revocation requests.\n    Signature[] signatures; // The ECDSA signatures data. Please note that the signatures are assumed to be signed with increasing nonces.\n    address revoker; // The revoking account.\n    uint64 deadline; // The deadline of the signature/request.\n}\n\n/// @title IEAS\n/// @notice EAS - Ethereum Attestation Service interface.\ninterface IEAS is ISemver {\n    /// @notice Emitted when an attestation has been made.\n    /// @param recipient The recipient of the attestation.\n    /// @param attester The attesting account.\n    /// @param uid The UID of the new attestation.\n    /// @param schemaUID The UID of the schema.\n    event Attested(address indexed recipient, address indexed attester, bytes32 uid, bytes32 indexed schemaUID);\n\n    /// @notice Emitted when an attestation has been revoked.\n    /// @param recipient The recipient of the attestation.\n    /// @param attester The attesting account.\n    /// @param schemaUID The UID of the schema.\n    /// @param uid The UID the revoked attestation.\n    event Revoked(address indexed recipient, address indexed attester, bytes32 uid, bytes32 indexed schemaUID);\n\n    /// @notice Emitted when a data has been timestamped.\n    /// @param data The data.\n    /// @param timestamp The timestamp.\n    event Timestamped(bytes32 indexed data, uint64 indexed timestamp);\n\n    /// @notice Emitted when a data has been revoked.\n    /// @param revoker The address of the revoker.\n    /// @param data The data.\n    /// @param timestamp The timestamp.\n    event RevokedOffchain(address indexed revoker, bytes32 indexed data, uint64 indexed timestamp);\n\n    /// @notice Returns the address of the global schema registry.\n    /// @return The address of the global schema registry.\n    function getSchemaRegistry() external view returns (ISchemaRegistry);\n\n    /// @notice Attests to a specific schema.\n    /// @param request The arguments of the attestation request.\n    /// @return The UID of the new attestation.\n    ///\n    /// Example:\n    ///     attest({\n    ///         schema: \"0facc36681cbe2456019c1b0d1e7bedd6d1d40f6f324bf3dd3a4cef2999200a0\",\n    ///         data: {\n    ///             recipient: \"0xdEADBeAFdeAdbEafdeadbeafDeAdbEAFdeadbeaf\",\n    ///             expirationTime: 0,\n    ///             revocable: true,\n    ///             refUID: \"0x0000000000000000000000000000000000000000000000000000000000000000\",\n    ///             data: \"0xF00D\",\n    ///             value: 0\n    ///         }\n    ///     })\n    function attest(AttestationRequest calldata request) external payable returns (bytes32);\n\n    /// @notice Attests to a specific schema via the provided ECDSA signature.\n    /// @param delegatedRequest The arguments of the delegated attestation request.\n    /// @return The UID of the new attestation.\n    ///\n    /// Example:\n    ///     attestByDelegation({\n    ///         schema: '0x8e72f5bc0a8d4be6aa98360baa889040c50a0e51f32dbf0baa5199bd93472ebc',\n    ///         data: {\n    ///             recipient: '0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266',\n    ///             expirationTime: 1673891048,\n    ///             revocable: true,\n    ///             refUID: '0x0000000000000000000000000000000000000000000000000000000000000000',\n    ///             data: '0x1234',\n    ///             value: 0\n    ///         },\n    ///         signature: {\n    ///             v: 28,\n    ///             r: '0x148c...b25b',\n    ///             s: '0x5a72...be22'\n    ///         },\n    ///         attester: '0xc5E8740aD971409492b1A63Db8d83025e0Fc427e',\n    ///         deadline: 1673891048\n    ///     })\n    function attestByDelegation(\n        DelegatedAttestationRequest calldata delegatedRequest\n    ) external payable returns (bytes32);\n\n    /// @notice Attests to multiple schemas.\n    /// @param multiRequests The arguments of the multi attestation requests. The requests should be grouped by distinct\n    ///     schema ids to benefit from the best batching optimization.\n    /// @return The UIDs of the new attestations.\n    ///\n    /// Example:\n    ///     multiAttest([{\n    ///         schema: '0x33e9094830a5cba5554d1954310e4fbed2ef5f859ec1404619adea4207f391fd',\n    ///         data: [{\n    ///             recipient: '0xdEADBeAFdeAdbEafdeadbeafDeAdbEAFdeadbeaf',\n    ///             expirationTime: 1673891048,\n    ///             revocable: true,\n    ///             refUID: '0x0000000000000000000000000000000000000000000000000000000000000000',\n    ///             data: '0x1234',\n    ///             value: 1000\n    ///         },\n    ///         {\n    ///             recipient: '0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266',\n    ///             expirationTime: 0,\n    ///             revocable: false,\n    ///             refUID: '0x480df4a039efc31b11bfdf491b383ca138b6bde160988222a2a3509c02cee174',\n    ///             data: '0x00',\n    ///             value: 0\n    ///         }],\n    ///     },\n    ///     {\n    ///         schema: '0x5ac273ce41e3c8bfa383efe7c03e54c5f0bff29c9f11ef6ffa930fc84ca32425',\n    ///         data: [{\n    ///             recipient: '0xdEADBeAFdeAdbEafdeadbeafDeAdbEAFdeadbeaf',\n    ///             expirationTime: 0,\n    ///             revocable: true,\n    ///             refUID: '0x75bf2ed8dca25a8190c50c52db136664de25b2449535839008ccfdab469b214f',\n    ///             data: '0x12345678',\n    ///             value: 0\n    ///         },\n    ///     }])\n    function multiAttest(MultiAttestationRequest[] calldata multiRequests) external payable returns (bytes32[] memory);\n\n    /// @notice Attests to multiple schemas using via provided ECDSA signatures.\n    /// @param multiDelegatedRequests The arguments of the delegated multi attestation requests. The requests should be\n    ///     grouped by distinct schema ids to benefit from the best batching optimization.\n    /// @return The UIDs of the new attestations.\n    ///\n    /// Example:\n    ///     multiAttestByDelegation([{\n    ///         schema: '0x8e72f5bc0a8d4be6aa98360baa889040c50a0e51f32dbf0baa5199bd93472ebc',\n    ///         data: [{\n    ///             recipient: '0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266',\n    ///             expirationTime: 1673891048,\n    ///             revocable: true,\n    ///             refUID: '0x0000000000000000000000000000000000000000000000000000000000000000',\n    ///             data: '0x1234',\n    ///             value: 0\n    ///         },\n    ///         {\n    ///             recipient: '0xdEADBeAFdeAdbEafdeadbeafDeAdbEAFdeadbeaf',\n    ///             expirationTime: 0,\n    ///             revocable: false,\n    ///             refUID: '0x0000000000000000000000000000000000000000000000000000000000000000',\n    ///             data: '0x00',\n    ///             value: 0\n    ///         }],\n    ///         signatures: [{\n    ///             v: 28,\n    ///             r: '0x148c...b25b',\n    ///             s: '0x5a72...be22'\n    ///         },\n    ///         {\n    ///             v: 28,\n    ///             r: '0x487s...67bb',\n    ///             s: '0x12ad...2366'\n    ///         }],\n    ///         attester: '0x1D86495b2A7B524D747d2839b3C645Bed32e8CF4',\n    ///         deadline: 1673891048\n    ///     }])\n    function multiAttestByDelegation(\n        MultiDelegatedAttestationRequest[] calldata multiDelegatedRequests\n    ) external payable returns (bytes32[] memory);\n\n    /// @notice Revokes an existing attestation to a specific schema.\n    /// @param request The arguments of the revocation request.\n    ///\n    /// Example:\n    ///     revoke({\n    ///         schema: '0x8e72f5bc0a8d4be6aa98360baa889040c50a0e51f32dbf0baa5199bd93472ebc',\n    ///         data: {\n    ///             uid: '0x101032e487642ee04ee17049f99a70590c735b8614079fc9275f9dd57c00966d',\n    ///             value: 0\n    ///         }\n    ///     })\n    function revoke(RevocationRequest calldata request) external payable;\n\n    /// @notice Revokes an existing attestation to a specific schema via the provided ECDSA signature.\n    /// @param delegatedRequest The arguments of the delegated revocation request.\n    ///\n    /// Example:\n    ///     revokeByDelegation({\n    ///         schema: '0x8e72f5bc0a8d4be6aa98360baa889040c50a0e51f32dbf0baa5199bd93472ebc',\n    ///         data: {\n    ///             uid: '0xcbbc12102578c642a0f7b34fe7111e41afa25683b6cd7b5a14caf90fa14d24ba',\n    ///             value: 0\n    ///         },\n    ///         signature: {\n    ///             v: 27,\n    ///             r: '0xb593...7142',\n    ///             s: '0x0f5b...2cce'\n    ///         },\n    ///         revoker: '0x244934dd3e31bE2c81f84ECf0b3E6329F5381992',\n    ///         deadline: 1673891048\n    ///     })\n    function revokeByDelegation(DelegatedRevocationRequest calldata delegatedRequest) external payable;\n\n    /// @notice Revokes existing attestations to multiple schemas.\n    /// @param multiRequests The arguments of the multi revocation requests. The requests should be grouped by distinct\n    ///     schema ids to benefit from the best batching optimization.\n    ///\n    /// Example:\n    ///     multiRevoke([{\n    ///         schema: '0x8e72f5bc0a8d4be6aa98360baa889040c50a0e51f32dbf0baa5199bd93472ebc',\n    ///         data: [{\n    ///             uid: '0x211296a1ca0d7f9f2cfebf0daaa575bea9b20e968d81aef4e743d699c6ac4b25',\n    ///             value: 1000\n    ///         },\n    ///         {\n    ///             uid: '0xe160ac1bd3606a287b4d53d5d1d6da5895f65b4b4bab6d93aaf5046e48167ade',\n    ///             value: 0\n    ///         }],\n    ///     },\n    ///     {\n    ///         schema: '0x5ac273ce41e3c8bfa383efe7c03e54c5f0bff29c9f11ef6ffa930fc84ca32425',\n    ///         data: [{\n    ///             uid: '0x053d42abce1fd7c8fcddfae21845ad34dae287b2c326220b03ba241bc5a8f019',\n    ///             value: 0\n    ///         },\n    ///     }])\n    function multiRevoke(MultiRevocationRequest[] calldata multiRequests) external payable;\n\n    /// @notice Revokes existing attestations to multiple schemas via provided ECDSA signatures.\n    /// @param multiDelegatedRequests The arguments of the delegated multi revocation attestation requests. The requests\n    ///     should be grouped by distinct schema ids to benefit from the best batching optimization.\n    ///\n    /// Example:\n    ///     multiRevokeByDelegation([{\n    ///         schema: '0x8e72f5bc0a8d4be6aa98360baa889040c50a0e51f32dbf0baa5199bd93472ebc',\n    ///         data: [{\n    ///             uid: '0x211296a1ca0d7f9f2cfebf0daaa575bea9b20e968d81aef4e743d699c6ac4b25',\n    ///             value: 1000\n    ///         },\n    ///         {\n    ///             uid: '0xe160ac1bd3606a287b4d53d5d1d6da5895f65b4b4bab6d93aaf5046e48167ade',\n    ///             value: 0\n    ///         }],\n    ///         signatures: [{\n    ///             v: 28,\n    ///             r: '0x148c...b25b',\n    ///             s: '0x5a72...be22'\n    ///         },\n    ///         {\n    ///             v: 28,\n    ///             r: '0x487s...67bb',\n    ///             s: '0x12ad...2366'\n    ///         }],\n    ///         revoker: '0x244934dd3e31bE2c81f84ECf0b3E6329F5381992',\n    ///         deadline: 1673891048\n    ///     }])\n    function multiRevokeByDelegation(\n        MultiDelegatedRevocationRequest[] calldata multiDelegatedRequests\n    ) external payable;\n\n    /// @notice Timestamps the specified bytes32 data.\n    /// @param data The data to timestamp.\n    /// @return The timestamp the data was timestamped with.\n    function timestamp(bytes32 data) external returns (uint64);\n\n    /// @notice Timestamps the specified multiple bytes32 data.\n    /// @param data The data to timestamp.\n    /// @return The timestamp the data was timestamped with.\n    function multiTimestamp(bytes32[] calldata data) external returns (uint64);\n\n    /// @notice Revokes the specified bytes32 data.\n    /// @param data The data to timestamp.\n    /// @return The timestamp the data was revoked with.\n    function revokeOffchain(bytes32 data) external returns (uint64);\n\n    /// @notice Revokes the specified multiple bytes32 data.\n    /// @param data The data to timestamp.\n    /// @return The timestamp the data was revoked with.\n    function multiRevokeOffchain(bytes32[] calldata data) external returns (uint64);\n\n    /// @notice Returns an existing attestation by UID.\n    /// @param uid The UID of the attestation to retrieve.\n    /// @return The attestation data members.\n    function getAttestation(bytes32 uid) external view returns (Attestation memory);\n\n    /// @notice Checks whether an attestation exists.\n    /// @param uid The UID of the attestation to retrieve.\n    /// @return Whether an attestation exists.\n    function isAttestationValid(bytes32 uid) external view returns (bool);\n\n    /// @notice Returns the timestamp that the specified data was timestamped with.\n    /// @param data The data to query.\n    /// @return The timestamp the data was timestamped with.\n    function getTimestamp(bytes32 data) external view returns (uint64);\n\n    /// @notice Returns the timestamp that the specified data was timestamped with.\n    /// @param data The data to query.\n    /// @return The timestamp the data was timestamped with.\n    function getRevokeOffchain(address revoker, bytes32 data) external view returns (uint64);\n}\n"
    },
    "lib/openzeppelin-contracts-upgradeable/contracts/token/ERC20/extensions/IERC20MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.19;\n\nimport \"../IERC20Upgradeable.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "lib/risc0-ethereum/contracts/src/IRiscZeroVerifier.sol": {
      "content": "// Copyright 2024 RISC Zero, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n\npragma solidity ^0.8.9;\n\nimport {reverseByteOrderUint32} from \"./Util.sol\";\n\n/// @notice A receipt attesting to the execution of a guest program.\n/// @dev A receipt contains two parts: a seal and a claim. The seal is a zero-knowledge proof\n/// attesting to knowledge of a zkVM execution resulting in the claim. The claim is a set of public\n/// outputs for the execution. Crucially, the claim includes the journal and the image ID. The\n/// image ID identifies the program that was executed, and the journal is the public data written\n/// by the program. Note that this struct only contains the claim digest, as can be obtained with\n/// the `digest()` function on `ReceiptClaimLib`.\nstruct Receipt {\n    bytes seal;\n    bytes32 claimDigest;\n}\n\n/// @notice Public claims about a zkVM guest execution, such as the journal committed to by the guest.\n/// @dev Also includes important information such as the exit code and the starting and ending system\n/// state (i.e. the state of memory). `ReceiptClaim` is a \"Merkle-ized struct\" supporting\n/// partial openings of the underlying fields from a hash commitment to the full structure.\nstruct ReceiptClaim {\n    /// @notice Digest of the SystemState just before execution has begun.\n    bytes32 preStateDigest;\n    /// @notice Digest of the SystemState just after execution has completed.\n    bytes32 postStateDigest;\n    /// @notice The exit code for the execution.\n    ExitCode exitCode;\n    /// @notice A digest of the input to the guest.\n    /// @dev This field is currently unused and must be set to the zero digest.\n    bytes32 input;\n    /// @notice Digest of the Output of the guest, including the journal\n    /// and assumptions set during execution.\n    bytes32 output;\n}\n\nlibrary ReceiptClaimLib {\n    using OutputLib for Output;\n    using SystemStateLib for SystemState;\n\n    bytes32 constant TAG_DIGEST = sha256(\"risc0.ReceiptClaim\");\n\n    // Define a constant to ensure hashing is done at compile time. Can't use the\n    // SystemStateLib.digest method here because the Solidity compiler complains.\n    bytes32 constant SYSTEM_STATE_ZERO_DIGEST = 0xa3acc27117418996340b84e5a90f3ef4c49d22c79e44aad822ec9c313e1eb8e2;\n\n    /// @notice Construct a ReceiptClaim from the given imageId and journalDigest.\n    ///         Returned ReceiptClaim will represent a successful execution of the zkVM, running\n    ///         the program committed by imageId and resulting in the journal specified by\n    ///         journalDigest.\n    /// @param imageId The identifier for the guest program.\n    /// @param journalDigest The SHA-256 digest of the journal bytes.\n    /// @dev Input hash and postStateDigest are set to all-zeros (i.e. no committed input, or\n    ///      final memory state), the exit code is (Halted, 0), and there are no assumptions\n    ///      (i.e. the receipt is unconditional).\n    function ok(bytes32 imageId, bytes32 journalDigest) internal pure returns (ReceiptClaim memory) {\n        return ReceiptClaim(\n            imageId,\n            SYSTEM_STATE_ZERO_DIGEST,\n            ExitCode(SystemExitCode.Halted, 0),\n            bytes32(0),\n            Output(journalDigest, bytes32(0)).digest()\n        );\n    }\n\n    function digest(ReceiptClaim memory claim) internal pure returns (bytes32) {\n        return sha256(\n            abi.encodePacked(\n                TAG_DIGEST,\n                // down\n                claim.input,\n                claim.preStateDigest,\n                claim.postStateDigest,\n                claim.output,\n                // data\n                uint32(claim.exitCode.system) << 24,\n                uint32(claim.exitCode.user) << 24,\n                // down.length\n                uint16(4) << 8\n            )\n        );\n    }\n}\n\n/// @notice Commitment to the memory state and program counter (pc) of the zkVM.\n/// @dev The \"pre\" and \"post\" fields of the ReceiptClaim are digests of the system state at the\n///      start are stop of execution. Programs are loaded into the zkVM by creating a memory image\n///      of the loaded program, and creating a system state for initializing the zkVM. This is\n///      known as the \"image ID\".\nstruct SystemState {\n    /// @notice Program counter.\n    uint32 pc;\n    /// @notice Root hash of a merkle tree which confirms the integrity of the memory image.\n    bytes32 merkle_root;\n}\n\nlibrary SystemStateLib {\n    bytes32 constant TAG_DIGEST = sha256(\"risc0.SystemState\");\n\n    function digest(SystemState memory state) internal pure returns (bytes32) {\n        return sha256(\n            abi.encodePacked(\n                TAG_DIGEST,\n                // down\n                state.merkle_root,\n                // data\n                reverseByteOrderUint32(state.pc),\n                // down.length\n                uint16(1) << 8\n            )\n        );\n    }\n}\n\n/// @notice Exit condition indicated by the zkVM at the end of the guest execution.\n/// @dev Exit codes have a \"system\" part and a \"user\" part. Semantically, the system part is set to\n/// indicate the type of exit (e.g. halt, pause, or system split) and is directly controlled by the\n/// zkVM. The user part is an exit code, similar to exit codes used in Linux, chosen by the guest\n/// program to indicate additional information (e.g. 0 to indicate success or 1 to indicate an\n/// error).\nstruct ExitCode {\n    SystemExitCode system;\n    uint8 user;\n}\n\n/// @notice Exit condition indicated by the zkVM at the end of the execution covered by this proof.\n/// @dev\n/// `Halted` indicates normal termination of a program with an interior exit code returned from the\n/// guest program. A halted program cannot be resumed.\n///\n/// `Paused` indicates the execution ended in a paused state with an interior exit code set by the\n/// guest program. A paused program can be resumed such that execution picks up where it left\n/// of, with the same memory state.\n///\n/// `SystemSplit` indicates the execution ended on a host-initiated system split. System split is\n/// mechanism by which the host can temporarily stop execution of the execution ended in a system\n/// split has no output and no conclusions can be drawn about whether the program will eventually\n/// halt. System split is used in continuations to split execution into individually provable segments.\nenum SystemExitCode {\n    Halted,\n    Paused,\n    SystemSplit\n}\n\n/// @notice Output field in the `ReceiptClaim`, committing to a claimed journal and assumptions list.\nstruct Output {\n    /// @notice Digest of the journal committed to by the guest execution.\n    bytes32 journalDigest;\n    /// @notice Digest of the ordered list of `ReceiptClaim` digests corresponding to the\n    /// calls to `env::verify` and `env::verify_integrity`.\n    /// @dev Verifying the integrity of a `Receipt` corresponding to a `ReceiptClaim` with a\n    /// non-empty assumptions list does not guarantee unconditionally any of the claims over the\n    /// guest execution (i.e. if the assumptions list is non-empty, then the journal digest cannot\n    /// be trusted to correspond to a genuine execution). The claims can be checked by additional\n    /// verifying a `Receipt` for every digest in the assumptions list.\n    bytes32 assumptionsDigest;\n}\n\nlibrary OutputLib {\n    bytes32 constant TAG_DIGEST = sha256(\"risc0.Output\");\n\n    function digest(Output memory output) internal pure returns (bytes32) {\n        return sha256(\n            abi.encodePacked(\n                TAG_DIGEST,\n                // down\n                output.journalDigest,\n                output.assumptionsDigest,\n                // down.length\n                uint16(2) << 8\n            )\n        );\n    }\n}\n\n/// @notice Error raised when cryptographic verification of the zero-knowledge proof fails.\nerror VerificationFailed();\n\n/// @notice Verifier interface for RISC Zero receipts of execution.\ninterface IRiscZeroVerifier {\n    /// @notice Verify that the given seal is a valid RISC Zero proof of execution with the\n    ///     given image ID and journal digest. Reverts on failure.\n    /// @dev This method additionally ensures that the input hash is all-zeros (i.e. no\n    /// committed input), the exit code is (Halted, 0), and there are no assumptions (i.e. the\n    /// receipt is unconditional).\n    /// @param seal The encoded cryptographic proof (i.e. SNARK).\n    /// @param imageId The identifier for the guest program.\n    /// @param journalDigest The SHA-256 digest of the journal bytes.\n    function verify(bytes calldata seal, bytes32 imageId, bytes32 journalDigest) external view;\n\n    /// @notice Verify that the given receipt is a valid RISC Zero receipt, ensuring the `seal` is\n    /// valid a cryptographic proof of the execution with the given `claim`. Reverts on failure.\n    /// @param receipt The receipt to be verified.\n    function verifyIntegrity(Receipt calldata receipt) external view;\n}\n"
    },
    "src/interfaces/IBaseRegistry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {IEternalRegistryStorage} from \"src/interfaces/IEternalRegistryStorage.sol\";\n\n/**\n * @title IBaseRegistry\n * @notice Interface for the base registry, which provides functionality for tracking and retrieving data\n * specific to modules that interact with the registry.\n * @dev The tracked data can be queried via a delegatecall callback to the relevant module,\n * which implements the query logic.\n */\ninterface IBaseRegistry is IEternalRegistryStorage {\n    /**\n     * @notice Thrown when an unauthorized caller tries to access a restricted function or resource.\n     */\n    error IBaseRegistry_AccessDenied();\n\n    /**\n     * @notice Thrown when an action is attempted on a module that is not registered in the registry.\n     */\n    error IBaseRegistry_NotRegisteredModule();\n\n    /**\n     * @notice Thrown when an invalid or non-existent ID is provided for an operation.\n     */\n    error IBaseRegistry_NotAValidId();\n\n    /**\n     * @notice Thrown when the system fails to retrieve the tracked data for a specific operation or ID.\n     */\n    error IBaseRegistry_FailedToGetTrackedData();\n\n    /**\n     * @notice Get the tracked data of the registry\n     * @param _data Data to be used by the module to get the tracked data\n     * @return bytes memory of the tracked data\n     * @dev This function is used to get the tracked data from the registry\n     * by doing a delegatecall callback to the module requesting the data\n     * which can implement the query logic\n     */\n    function getTrackedData(bytes memory _data) external returns (bytes memory);\n}\n"
    },
    "src/interfaces/IInstrumentRegistry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {IERC20Metadata} from \"openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport {IBaseRegistry} from \"src/interfaces/IBaseRegistry.sol\";\nimport {IDealerRegistry} from \"src/interfaces/IDealerRegistry.sol\";\nimport {IFundRegistry} from \"src/interfaces/IFundRegistry.sol\";\nimport {IRoleRegistry} from \"src/interfaces/IRoleRegistry.sol\";\nimport {IInvestorRegistry} from \"src/interfaces/IInvestorRegistry.sol\";\nimport {IOperationsEngine} from \"src/interfaces/IOperationsEngine.sol\";\nimport {IEternalRegistryStorage} from \"src/interfaces/IEternalRegistryStorage.sol\";\n\n/**\n * @title IInstrumentRegistry\n * @author Libre\n * @notice Interface for managing instruments within a fund registry system.\n * Provides functionalities to initialize, add, and manage instruments, track their subscription and redemption periods,\n * update Net Asset Value (NAV) per share, and manage investor access.\n */\ninterface IInstrumentRegistry is IBaseRegistry {\n    /**\n     * @notice Thrown when attempting to add an instrument that already exists in the registry.\n     */\n    error IInstrumentRegistry_InstrumentAlreadyExists();\n\n    /**\n     * @notice Thrown when the specified instrument does not exist in the registry.\n     */\n    error IInstrumentRegistry_InstrumentDoesNotExist();\n\n    /**\n     * @notice Thrown when attempting to initialize an instrument that has already been initialized.\n     */\n    error IInstrumentRegistry_InstrumentAlreadyInitialized();\n\n    /**\n     * @notice Emited when a new instrument is added\n     * @param fundId Id of the fund where the instrument is added\n     * @param instrumentId Id of the new instrument\n     */\n    event NewFundInstrumentAdded(bytes32 indexed fundId, bytes32 indexed instrumentId);\n\n    /**\n     * @notice Emited when an instrument is initialized\n     * @param instrumentId Id of the new instrument\n     * @param settlementToken Address of the settlement token of the instrument\n     * @param securityToken Address of the deployed security token\n     * @param subscriptionBook Address of the deployed subscription book\n     * @param redemptionBook Address of the deployed redemption book\n     */\n    event FundInstrumentInitialized(\n        bytes32 indexed instrumentId,\n        address settlementToken,\n        address securityToken,\n        address subscriptionBook,\n        address redemptionBook\n    );\n\n    /**\n     * @notice Emited when an instrument is closed\n     * @param instrumentId Id of the instrument\n     */\n    event InstrumentClosed(bytes32 indexed instrumentId);\n\n    /**\n     * @notice Emited when an instrument is paused\n     * @param instrumentId Id of the instrument\n     * @param paused Y/N value indicating if the instrument is paused or not\n     */\n    event InstrumentPaused(bytes32 indexed instrumentId, bool paused);\n\n    /**\n     * @notice Emited when an investor's allowlist status is updated for an instrument\n     * @param instrumentId Id of the instrument\n     * @param investorId Id of the investor\n     * @param allowed Y/N value indicating if the investor is allowed or not\n     */\n    event InvestorAllowedUpdated(bytes32 indexed instrumentId, bytes32 indexed investorId, bool allowed);\n\n    /**\n     * @notice Initialize the registry\n     * @param _roleRegistry Address of the Role Registry\n     * @param _investorRegistry Address of the Investor Registry\n     * @param _dealerRegistry Address of the Dealer Registry\n     * @param _fundRegistry Address of the Fund Registry\n     * @param _jurisdictionRegistry Address of the Jurisdiction Registry\n     * @param _operationsEngine Address of the Rules Engine\n     */\n    function initialize(\n        IRoleRegistry _roleRegistry,\n        IInvestorRegistry _investorRegistry,\n        IDealerRegistry _dealerRegistry,\n        IFundRegistry _fundRegistry,\n        IEternalRegistryStorage _jurisdictionRegistry,\n        IOperationsEngine _operationsEngine\n    ) external;\n\n    /**\n     * @notice Adds a new fund instrument to the registry\n     * @dev _senderRole is ignored if the caller if the Fund Admin of the instrument\n     * @param _senderRole Role of the sender which allow the operation execution\n     * @param _instrumentId the instrument ID\n     * @param _fundId the fund ID\n     */\n    function addFundInstrument(bytes32 _senderRole, bytes32 _instrumentId, bytes32 _fundId) external;\n\n    /**\n     * @notice Adds a new instrument to the registry\n     * @dev _senderRole is ignored if the caller if the Fund Admin of the instrument\n     * @param _senderRole Role of the sender which allow the operation execution\n     * @param _instrumentId the instrument ID\n     * @param _settlementToken settlement token address\n     * @param _name the instrument token name\n     * @param _symbol the instrument token symbol\n     * @param _subscriptionBookImp The implementation of subscription book to be cloned\n     * @param _redemptionBookImp The implementation of redemption book to be cloned\n     * @param _stTokenImpl The implementation of security token implementation to be cloned\n     * @param _treasury The address of instrument treasury\n     * @param _policyViewerAddress The address of instrument policy viewer\n     */\n    function initializeFundInstrument(\n        bytes32 _senderRole,\n        bytes32 _fundId,\n        bytes32 _instrumentId,\n        address _settlementToken,\n        string memory _name,\n        string memory _symbol,\n        address _subscriptionBookImp,\n        address _redemptionBookImp,\n        address _stTokenImpl,\n        address _treasury,\n        address _policyViewerAddress\n    ) external;\n\n    /**\n     * @notice Close a fund instrument\n     * @param _senderRole Role of the sender which allow the operation execution\n     * @param _instrumentId The ID of the instrument\n     */\n    function closeFundInstrument(bytes32 _senderRole, bytes32 _instrumentId) external;\n\n    /**\n     * @notice Return the number of the current subscription period or\n     * 0 in case subscription is not started or infinite if subscriptions are done\n     * @dev Infinite is represented by type(uint256).max;\n     * @param _instrumentId Id of the instrument\n     * @return The current period of the subscription, the start & the end of it\n     */\n    function currentSubscriptionPeriod(bytes32 _instrumentId) external view returns (uint256, uint256, uint256);\n\n    /**\n     * @notice Return the number of the current redemption period or\n     * 0 in case redemption is not started or infinite if redemptions are done\n     * @param _instrumentId Id of the instrument\n     * @return The current period of the redemption, the start & the end of it\n     */\n    function currentRedemptionPeriod(bytes32 _instrumentId) external view returns (uint256, uint256, uint256);\n\n    /**\n     * @notice Sets a new value for the audited NAV per share of a fund\n     * @param _senderRole Role of the sender which allow the operation execution\n     * @param _instrumentId ID of the fund\n     * @param _newNavPerShare new value of the nav\n     * @dev Expressed with 6 decimals as it is in settlement tokens units\n     */\n    function updateAuditedNavPerShare(bytes32 _senderRole, bytes32 _instrumentId, uint256 _newNavPerShare) external;\n\n    /**\n     * @notice Allow investor for a specific instrument\n     * @param _instrumentId The ID of the instrument\n     * @param _investorId Id of the investor\n     * @param _allowed Y/N value indicating if the investor is allowed or not\n     * @param _senderRole Role of the sender\n     */\n    function allowInvestor(bytes32 _instrumentId, bytes32 _investorId, bool _allowed, bytes32 _senderRole) external;\n}\n"
    },
    "src/interfaces/IDealerRegistry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {IBaseRegistry} from \"src/interfaces/IBaseRegistry.sol\";\nimport {IRoleRegistry} from \"src/interfaces/IRoleRegistry.sol\";\nimport {IInvestorRegistry} from \"src/interfaces/IInvestorRegistry.sol\";\nimport {IUserRegistry} from \"src/interfaces/IUserRegistry.sol\";\nimport {IOperationsEngine} from \"src/interfaces/IOperationsEngine.sol\";\nimport {IInstrumentRegistry} from \"src/interfaces/IInstrumentRegistry.sol\";\n\n/**\n * @title IDealerRegistry\n * @notice Interface for managing dealers within the registry, including adding new dealers,\n * allowing dealers for specific instruments, and checking dealer permissions.\n * @dev Extends both `IBaseRegistry` and `IUserRegistry` for core registry and user management functionality.\n */\ninterface IDealerRegistry is IBaseRegistry, IUserRegistry {\n    /**\n     * @notice Thrown when attempting to add a dealer who is already registered.\n     */\n    error IDealerRegistry_AlreadyADealer();\n\n    /**\n     * @notice Thrown when invalid input parameters are provided.\n     */\n    error IDealerRegistry_InvalidInput();\n\n    /**\n     * @notice Thrown when the specified instrument does not exist in the registry.\n     */\n    error IDealerRegistry_NonExistingInstrument();\n\n    /**\n     * @notice Thrown when the dealer is not allowed for the specified instrument.\n     */\n    error IDealerRegistry_DealerNotAllowed();\n\n    /**\n     * @notice Emited when a new dealer is added\n     * @param dealerId Id of the new dealer\n     * @param wallet Initial wallet of the dealer\n     */\n    event NewDealerAdded(bytes32 dealerId, address wallet);\n\n    /**\n     * @notice Emited when an dealer's allowed status is updated\n     * @param dealerId Id of the dealer updated\n     * @param allowed Y/N if dealer is allowed for the instrument\n     */\n    event dealerAllowedUpdated(bytes32 dealerId, bytes32 instrumentId, bool allowed);\n\n    /**\n     * @notice Initialize the registry\n     * @param _roleRegistry Address of the role registry\n     */\n    function initialize(\n        IRoleRegistry _roleRegistry,\n        IOperationsEngine _operationsEngine,\n        IInvestorRegistry _investorRegistry,\n        IInstrumentRegistry _instrumentRegistry\n    ) external;\n\n    /**\n     * @notice Adds a new dealer to the registry\n     * @param _senderRole Role of the sender which allows the operation execution\n     * @param _dealerId ID of the dealer\n     * @param _wallet Wallet of the dealer\n     */\n    function addDealer(bytes32 _senderRole, bytes32 _dealerId, address _wallet) external;\n\n    /**\n     * @notice Allows a dealer for a specific instrument\n     * @param _senderRole Role of the sender which allows the operation execution\n     * @param _dealerId ID of the dealer\n     * @param _instrumentId ID of the instrument\n     * @param _allowed Y/N if dealer is allowed for the instrument\n     */\n    function allowDealer(bytes32 _senderRole, bytes32 _dealerId, bytes32 _instrumentId, bool _allowed) external;\n\n    /**\n     * @notice Returns if the dealer is allowed for a specific instrument\n     * @param _dealerId ID of the dealer\n     * @param _instrumentId ID of the instrument\n     * @return Bool indicating if dealer if allowed\n     */\n    function isDealerAllowed(bytes32 _dealerId, bytes32 _instrumentId) external view returns (bool);\n\n    /**\n     * @notice Reverts if the dealer is not allowed for a specific instrument\n     * @param _dealerId ID of the dealer\n     * @param _instrumentId ID of the instrument\n     */\n    function checkDealerAllowed(bytes32 _dealerId, bytes32 _instrumentId) external view;\n}\n"
    },
    "src/interfaces/IOperationsEngine.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {IInvestorRegistry} from \"src/interfaces/IInvestorRegistry.sol\";\nimport {IFundRegistry} from \"src/interfaces/IFundRegistry.sol\";\nimport {IDealerRegistry} from \"src/interfaces/IDealerRegistry.sol\";\nimport {IInstrumentRegistry} from \"src/interfaces/IInstrumentRegistry.sol\";\nimport {IRoleRegistry} from \"src/interfaces/IRoleRegistry.sol\";\nimport {IEternalRegistryStorage} from \"src/interfaces/IEternalRegistryStorage.sol\";\nimport {OPERATIONS} from \"./operations/IOperationModule.sol\";\n\n/**\n * @title Operations Engine Interface\n * @author Libre\n * @notice Defines the interface for managing modules, operations, and dependencies in the system.\n * @dev Includes error definitions, events, and function signatures for interacting with the operations engine.\n */\ninterface IOperationsEngine {\n    // Enums\n    /**\n     * @notice Defines the type of ID for the module check, modules are either tracking ones or check ones.\n     */\n    enum IdType {\n        NULL,\n        INSTRUMENT_CHECK,\n        FEE,\n        TRACKING\n    }\n\n    /**\n     * @notice Defines the type of check a module performs.\n     */\n    enum CHECK_TYPE {\n        BOOLEAN,\n        NUMERIC_MIN,\n        NUMERIC_MAX\n    }\n\n    // Errors\n    /**\n     * @dev Revert when the tracking module reverts for any reason\n     */\n    error IOperationsEngine_TrackingModuleFailure();\n\n    /**\n     * @dev Revert when the fee module reverts for any reason\n     */\n    error IOperationsEngine_FeeModuleFailure();\n\n    /**\n     * @dev Revert when the module address provided is invalid.\n     */\n    error IOperationsEngine_InvalidModuleAddress();\n\n    /**\n     * @dev Revert when the module is not of the Libre type.\n     */\n    error IOperationsEngine_ModuleIsNotLibreType();\n\n    /**\n     * @dev Revert when a lending module cannot be disabled.\n     */\n    error IOperationsEngine_LendingModuleDisable();\n\n    /**\n     * @dev Revert when dependencies required for an operation are missing.\n     */\n    error IOperationsEngine_MissingDependencies();\n\n    /**\n     * @dev Revert when an invalid check type is used.\n     */\n    error IOperationsEngine_InvalidCheckType();\n\n    /**\n     * @dev Revert when the caller is not authorized to perform the action.\n     */\n    error IOperationsEngine_CallerNotAuthorized();\n\n    /**\n     * @dev Revert when adding a module that is already been added.\n     */\n    error IOperationsEngine_ModuleAlreadyAdded();\n\n    /**\n     * @dev Revert when module already enabled for the same instrument.\n     */\n    error IOperationsEngine_ModuleAlreadyEnabled();\n\n    /**\n     * @dev Revert when a module to be disabled for an instrument is not enabled\n     */\n    error IOperationsEngine_ModuleNotEnabled();\n\n    // Events\n    /**\n     * @notice Emitted when a module is added to the available modules library.\n     * @param moduleAddress Address of the module that was added.\n     */\n    event ModuleAdded(address indexed moduleAddress);\n\n    /**\n     * @notice Emitted when a module is removed from the available modules library.\n     * @param moduleAddress Address of the module that was removed.\n     */\n    event ModuleRemoved(address indexed moduleAddress);\n\n    /**\n     * @notice Emitted when a module is enabled for a specific instrument.\n     * @param moduleAddress Address of the module that was enabled.\n     * @param instrumentId Id of the instrument for which the module was enabled.\n     */\n    event ModuleEnabled(address indexed moduleAddress, bytes32 instrumentId);\n\n    /**\n     * @notice Emitted when a module is disabled for a specific instrument.\n     * @param moduleAddress Address of the module that was disabled.\n     * @param instrumentId Id of the instrument for which the module was disabled.\n     */\n    event ModuleDisabled(address indexed moduleAddress, bytes32 instrumentId);\n\n    /**\n     * @dev Event emitted when a fee is applied.\n     * @param instrumentId The ID of the instrument.\n     * @param orderId The ID of the order.\n     * @param feeModule The address of the fee module.\n     * @param feeAmount The amount of the fee applied.\n     */\n    event FeeApplied(bytes32 indexed instrumentId, uint256 orderId, address feeModule, uint256 feeAmount);\n\n    //functions\n\n    /**\n     * @notice Initializes the Rules Engine with necessary registries.\n     * @param _investorRegistry Address of the Investor Registry.\n     * @param _dealerRegistry Address of the Dealer Registry.\n     * @param _fundRegistry Address of the Fund Registry.\n     * @param _instrumentRegistry Address of the Instrument Registry.\n     * @param _roleRegistry Address of the Role Registry.\n     * @param _jurisdictionRegistry Address of the Jurisdiction Registry.\n     */\n    function initialize(\n        IInvestorRegistry _investorRegistry,\n        IDealerRegistry _dealerRegistry,\n        IFundRegistry _fundRegistry,\n        IInstrumentRegistry _instrumentRegistry,\n        IRoleRegistry _roleRegistry,\n        IEternalRegistryStorage _jurisdictionRegistry\n    ) external;\n\n    /**\n     * @notice Gets the addresses for registered check modules implementing the given operation.\n     * @param _id Id of the dealer or instrument the modules belong to.\n     * @param _operation Operation implemented in modules.\n     * @return An array of addresses of modules implementing the given operation.\n     */\n    function getCheckModules(bytes32 _id, OPERATIONS _operation) external view returns (address[] memory);\n\n    /**\n     * @notice Gets the addresses for registered fee modules implementing the given operation.\n     * @param _id Id of the dealer or instrument the modules belong to.\n     * @param _operation Operation implemented in modules.\n     * @return An array of addresses of modules implementing the given operation.\n     */\n    function getFeeModules(bytes32 _id, OPERATIONS _operation) external view returns (address[] memory);\n\n    /**\n     * @notice Gets the addresses for registered tracking modules implementing the given operation.\n     * @param _id Id of the dealer or instrument the modules belong to.\n     * @param _operation Operation implemented in modules.\n     * @return An array of addresses of modules implementing the given operation.\n     */\n    function getTrackingModules(bytes32 _id, OPERATIONS _operation) external view returns (address[] memory);\n\n    /**\n     * @notice Adds a module to the available modules library.\n     * @param _moduleAddress Address of the module to add.\n     * @param _role Role required to add the module.\n     * @param _idType Type of the module.\n     */\n    function addModule(address _moduleAddress, bytes32 _role, IdType _idType) external;\n\n    /**\n     * @notice Removes a module from the available modules library.\n     * @param _moduleAddress Address of the module to remove.\n     * @param _role Role required to remove the module.\n     */\n    function removeModule(address _moduleAddress, bytes32 _role) external;\n\n    /**\n     * @notice Enables a module for a specific instrument.\n     * @param _moduleAddress Address of the module to enable.\n     * @param _instrumentId Id of the instrument.\n     * @param _role Role required to enable the module.\n     */\n    function enableModule(address _moduleAddress, bytes32 _instrumentId, bytes32 _role) external;\n\n    /**\n     * @notice Disables a module for a specific instrument.\n     * @param _moduleAddress Address of the module to disable.\n     * @param _instrumentId Id of the instrument.\n     * @param _role Role required to disable the module.\n     * @dev Lending modules cannot be disabled, because at least one module must be enabled at all times.\n     * Instead, the lending module can be replaced with another lending module by enabling the new module.\n     */\n    function disableModule(address _moduleAddress, bytes32 _instrumentId, bytes32 _role) external;\n\n    /**\n     * @notice Checks if a module is available in the available modules library.\n     * @param _moduleAddress Address of the module to check.\n     * @return True if the module is available, false otherwise.\n     */\n    function isAvailableModule(address _moduleAddress) external view returns (bool);\n\n    /**\n     * @notice Checks if a module is enabled for a specific instrument.\n     * @param _id Id of the instrument.\n     * @param _moduleName Hash of the abi.encodePacked of the module name\n     * @return True if the module is enabled, false otherwise.\n     */\n    function hasModuleEnabled(bytes32 _id, bytes32 _moduleName) external view returns (bool);\n\n    /**\n     * @notice Function to be delegatecalled by the registry to perform the check\n     * @param _operation The operation to be checked\n     * @param _id The id of the operation\n     * @param _data Arbitrary data that can be used by the module to perform the check\n     * @return result memory Result of the check\n     */\n    function check(OPERATIONS _operation, bytes32 _id, bytes calldata _data) external returns (bytes memory result);\n\n    /**\n     * @notice Tracks the operation\n     * @param _operation The operation to track\n     * @param _id The id of the instrument or investor\n     * @param _data The data to track\n     * @return True if the tracking was successful, false otherwise\n     */\n    function track(OPERATIONS _operation, bytes32 _id, bytes memory _data) external returns (bool);\n\n    /**\n     * @notice Calculates the total fee amount to be deducted for a given operation and instrument.\n     * @dev Loops through all enabled fee modules for the given operation and instrument, calls them with the input data,\n     *      and sums up the returned fee amounts. Also emits `FeeApplied` events for each individual module fee.\n     *\n     * @param _operation The operation type (e.g., SETTLE_SUBSCRIPTION_PER_ORDER).\n     * @param _id The instrument ID for which the fees are being calculated.\n     * @param _data ABI-encoded parameters required for fee calculation. Must encode the following values in order:\n     *        - `uint256 _orderId`: Unique identifier of the order\n     *        - `bytes32 _investorId`: The ID of the investor associated with the order\n     *        - `uint256 _amountToSettle`: The current amount to be settled\n     *\n     * @return totalFee The total fee amount to be deducted across all enabled fee modules.\n     */\n    function calculateFees(OPERATIONS _operation, bytes32 _id, bytes memory _data)\n        external\n        returns (uint256 totalFee);\n}\n"
    },
    "src/interfaces/IUserRegistry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title IUserRegistry\n * @author Libre\n * @notice Interface for managing user wallets and their association with investor/dealer IDs.\n * @dev Provides functions for adding wallets, retrieving wallets, and mapping wallets to user IDs.\n */\ninterface IUserRegistry {\n    /**\n     * @notice Thrown when the wallet address being added is already associated with another user ID.\n     */\n    error IUserRegistry_WalletAlreadyClaimed();\n\n    /**\n     * @notice Thrown when the provided signature fails to verify ownership of the wallet address.\n     */\n    error IUserRegistry_WalletOwnershipVerificationFailure();\n\n    /**\n     * @notice Thrown when the provided wallet signature has expired.\n     */\n    error IUserRegistry_WalletSignatureExpired();\n\n    /**\n     * @notice Thrown when the provided wallet address to add is blacklisted.\n     */\n    error IUserRegistry_WalletBlacklisted();\n\n    /**\n     * @notice Emited when secondary wallet is removed\n     * @param wallet User wallet address\n     */\n    event WalletAdded(address indexed wallet);\n\n    /**\n     * @notice Emited when secondary wallet is removed\n     * @param wallet User wallet address\n     */\n    event WalletRemoved(address indexed wallet);\n\n    /**\n     * @notice Adds a new investor to the registry\n     * @param _userId The ID of the user.\n     * @param _wallet The wallet address to associate with the user ID.\n     * @param _role The role used by the caller.\n     */\n    function addWallet(bytes32 _userId, address _wallet, bytes32 _role) external;\n\n    /**\n     * @notice Removes a wallet from the registry\n     * @param _wallet The wallet address to remove.\n     * @param _role The role used by the caller.\n     * @return The user ID that the wallet was removed from\n     */\n    function removeWallet(address _wallet, bytes32 _role) external returns (bytes32);\n\n    /**\n     * @notice Get Investor/Dealer array of wallets\n     * @param _userId Investor/Dealer ID\n     */\n    function getWallets(bytes32 _userId) external view returns (address[] memory);\n\n    /**\n     * @notice Get Investor/Dealer ID\n     * @param _wallet Investor/Dealer address\n     */\n    function getIdFromWallet(address _wallet) external view returns (bytes32);\n}\n"
    },
    "src/interfaces/IEternalRegistryStorage.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title IEternalRegistryStorage\n * @notice Interface for managing a flexible and extensible storage system, allowing various types of values to be\n * stored and retrieved for specific registry entries. Provides a robust and modular way to interact with registry data.\n * @dev Enables storage and retrieval of multiple data types (e.g., uint256, address, string, bool, bytes32) and\n * supports operations like batch updates, array manipulations, and role-based access control for data modifications.\n */\ninterface IEternalRegistryStorage {\n    /**\n     * @notice Thrown when attempting to modify a key that has been restricted.\n     */\n    error IEternalRegistryStorage_AttemptToSetARestrictedKey();\n\n    /**\n     * @notice Thrown when the length of the provided input arrays does not match.\n     */\n    error IEternalRegistryStorage_BatchLengthMismatch();\n\n    /**\n     * @notice Thrown when attempting to access an array index that is out of bounds.\n     */\n    error IEternalRegistryStorage_IndexShouldBeLessThanLengthOfTheArray();\n\n    /**\n     * @notice Emitted when a boolean value is added to the registry.\n     * @param id The identifier of the registry entry.\n     * @param key The key associated with the boolean value.\n     * @param value The boolean value added to the registry.\n     */\n    event AddedBool(bytes32 indexed id, bytes32 indexed key, bool value);\n\n    /**\n     * @notice Emitted when a uint256 value is added to the registry.\n     * @param id The identifier of the registry entry.\n     * @param key The key associated with the uint256 value.\n     * @param value The uint256 value added to the registry.\n     */\n    event AddedUint(bytes32 indexed id, bytes32 indexed key, uint256 value);\n\n    /**\n     * @notice Emitted when an address value is added to the registry.\n     * @param id The identifier of the registry entry.\n     * @param key The key associated with the address value.\n     * @param value The address value added to the registry.\n     */\n    event AddedAddress(bytes32 indexed id, bytes32 indexed key, address value);\n\n    /**\n     * @notice Emitted when a string value is added to the registry.\n     * @param id The identifier of the registry entry.\n     * @param key The key associated with the string value.\n     * @param value The string value added to the registry.\n     */\n    event AddedString(bytes32 indexed id, bytes32 indexed key, string value);\n\n    /**\n     * @notice Emitted when a bytes32 value is added to the registry.\n     * @param id The identifier of the registry entry.\n     * @param key The key associated with the bytes32 value.\n     * @param value The bytes32 value added to the registry.\n     */\n    event AddedBytes(bytes32 indexed id, bytes32 indexed key, bytes32 value);\n\n    /**\n     * @notice Emitted every time a key is restricted from being set\n     * for an specific entry\n     * @param _id Id of the entry where the key is restricted\n     * @param _key Key being restricted\n     */\n    event KeyRestricted(bytes32 indexed _id, bytes32 indexed _key);\n\n    /**\n     * @notice Get a boolean value from the storage\n     * @param _id Id of the registry entry to get the value from\n     * @param _key Key identifying the value to get\n     * @return bool value of the element associated to the key\n     * in the requested registry entry\n     */\n    function getBool(bytes32 _id, bytes32 _key) external view returns (bool);\n\n    /**\n     * @notice Get a uint256 value from the storage\n     * @param _id Id of the registry entry to get the value from\n     * @param _key Key identifying the value to get\n     * @return uint256 value of the element associated to the key\n     * in the requested registry entry\n     */\n    function getUint(bytes32 _id, bytes32 _key) external view returns (uint256);\n\n    /**\n     * @notice Get an address value from the storage\n     * @param _id Id of the registry entry to get the value from\n     * @param _key Key identifying the value to get\n     * @return address value of the element associated to the key\n     * in the requested registry entry\n     */\n    function getAddress(bytes32 _id, bytes32 _key) external view returns (address);\n\n    /**\n     * @notice Get a string value from the storage\n     * @param _id Id of the registry entry to get the value from\n     * @param _key Key identifying the value to get\n     * @return string value of the element associated to the key\n     * in the requested registry entry\n     */\n    function getString(bytes32 _id, bytes32 _key) external view returns (string memory);\n\n    /**\n     * @notice Get a bytes value from the storage\n     * @param _id Id of the registry entry to get the value from\n     * @param _key Key identifying the value to get\n     * @return bytes value of the element associated to the key\n     * in the requested registry entry\n     */\n    function getBytes(bytes32 _id, bytes32 _key) external view returns (bytes32);\n\n    /**\n     * @notice Set a boolean value on the storage\n     * @param _id Id of the registry entry to set the value on\n     * @param _key Key identifying the value to set\n     * @param _value Value to set\n     * @param _senderRole Role of the sender allowing the operation\n     */\n    function setBool(bytes32 _id, bytes32 _key, bool _value, bytes32 _senderRole) external;\n\n    /**\n     * @notice Set a uint256 value on the storage\n     * @param _id Id of the registry entry to set the value on\n     * @param _key Key identifying the value to set\n     * @param _value Value to set\n     * @param _senderRole Role of the sender allowing the operation\n     */\n    function setUint(bytes32 _id, bytes32 _key, uint256 _value, bytes32 _senderRole) external;\n\n    /**\n     * @notice Set an address value on the storage\n     * @param _id Id of the registry entry to set the value on\n     * @param _key Key identifying the value to set\n     * @param _value Value to set\n     * @param _senderRole Role of the sender allowing the operation\n     */\n    function setAddress(bytes32 _id, bytes32 _key, address _value, bytes32 _senderRole) external;\n\n    /**\n     * @notice Set a string value on the storage\n     * @param _id Id of the registry entry to set the value on\n     * @param _key Key identifying the value to set\n     * @param _value Value to set\n     * @param _senderRole Role of the sender allowing the operation\n     */\n    function setString(bytes32 _id, bytes32 _key, string calldata _value, bytes32 _senderRole) external;\n\n    /**\n     * @notice Set a bytes value on the storage\n     * @param _id Id of the registry entry to set the value on\n     * @param _key Key identifying the value to set\n     * @param _value Value to set\n     * @param _senderRole Role of the sender allowing the operation\n     */\n    function setBytes(bytes32 _id, bytes32 _key, bytes32 _value, bytes32 _senderRole) external;\n\n    /**\n     * @notice Set multiple values in one transaction\n     * @param _ids Ids associated to the values to set\n     * @param _keys Key associated to the values to set\n     * @param _boolValues Bool values to set\n     * @param _uintValues Uint256 values to set\n     * @param _addressValues Address values to set\n     * @param _stringValues String values to set\n     * @param _bytesValues Bytes32 values to set\n     * @param _senderRole Role of the sender allowing the operation\n     */\n    function setBatch(\n        bytes32[] memory _ids,\n        bytes32[] memory _keys,\n        bool[] memory _boolValues,\n        uint256[] memory _uintValues,\n        address[] memory _addressValues,\n        string[] memory _stringValues,\n        bytes32[] memory _bytesValues,\n        bytes32 _senderRole\n    ) external;\n\n    /**\n     * @notice Get multiple values in one transaction\n     * @param _ids Ids associated to the values to get\n     * @param _keys Keys associated to the values to get\n     * @param _boolCount Number of bool values to get\n     * @param _uintCount Number of uint256 values to get\n     * @param _addressCount Number of address values to get\n     * @param _stringCount Number of string values to get\n     * @param _bytesCount Number of bytes32 values to get\n     * @return _boolValues Bool values return array\n     * @return _uintValues Uint256 values return array\n     * @return _addressValues Address values return array\n     * @return _stringValues String values return array\n     * @return _bytesValues Bytes32 values return array\n     */\n    function getBatch(\n        bytes32[] memory _ids,\n        bytes32[] memory _keys,\n        uint256 _boolCount,\n        uint256 _uintCount,\n        uint256 _addressCount,\n        uint256 _stringCount,\n        uint256 _bytesCount\n    )\n        external\n        view\n        returns (\n            bool[] memory _boolValues,\n            uint256[] memory _uintValues,\n            address[] memory _addressValues,\n            string[] memory _stringValues,\n            bytes32[] memory _bytesValues\n        );\n}\n"
    },
    "src/utils/Types.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {Steel} from \"risc0/steel/Steel.sol\";\n\nstruct SteelProofData {\n    //Block hash commitment for Steel\n    Steel.Commitment commitment;\n    //Seal for Steel\n    bytes seal;\n}\n\nstruct CredentialProofData {\n    //Journal Data for Steel\n    CredentialJournal journal;\n    //Seal for Steel\n    bytes seal;\n}\n\n// @notice Journal that is committed to for Credentials\nstruct CredentialJournal {\n    //Block hash commitment for Steel\n    Steel.Commitment commitment;\n    //Id of the investor\n    bytes32 investorId;\n    //Credential expiry timestamp\n    uint64 expiryTimestamp;\n    //Ids of instruments the investor is registered for\n    bytes32[] instrumentIds;\n    //Access expiry timestamps for instruments the investor is registered for\n    uint64[] instrumentExpiryTimestamps;\n    address policyViewer;\n}\n\nstruct OrderProofData {\n    //Journal Data for Steel\n    OrderJournal journal;\n    //Seal for Steel\n    bytes seal;\n}\n\n// @notice Journal that is committed to for Orders\nstruct OrderJournal {\n    //Block hash commitment for Steel\n    Steel.Commitment commitment;\n    //Id of the investor\n    bytes32 investorId;\n    //Id of the instrument the investor is subscribing or redeeming to\n    bytes32 instrumentId;\n    //Amount the investor is subscribing or redeeming with\n    uint256 amount;\n    address policyViewer;\n}\n"
    },
    "lib/openzeppelin-contracts-upgradeable/contracts/access/IAccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.19;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControlUpgradeable {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n"
    },
    "lib/eas-contracts/contracts/ISchemaRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { ISemver } from \"./ISemver.sol\";\n\nimport { ISchemaResolver } from \"./resolver/ISchemaResolver.sol\";\n\n/// @notice A struct representing a record for a submitted schema.\nstruct SchemaRecord {\n    bytes32 uid; // The unique identifier of the schema.\n    ISchemaResolver resolver; // Optional schema resolver.\n    bool revocable; // Whether the schema allows revocations explicitly.\n    string schema; // Custom specification of the schema (e.g., an ABI).\n}\n\n/// @title ISchemaRegistry\n/// @notice The interface of global attestation schemas for the Ethereum Attestation Service protocol.\ninterface ISchemaRegistry is ISemver {\n    /// @notice Emitted when a new schema has been registered\n    /// @param uid The schema UID.\n    /// @param registerer The address of the account used to register the schema.\n    /// @param schema The schema data.\n    event Registered(bytes32 indexed uid, address indexed registerer, SchemaRecord schema);\n\n    /// @notice Submits and reserves a new schema\n    /// @param schema The schema data schema.\n    /// @param resolver An optional schema resolver.\n    /// @param revocable Whether the schema allows revocations explicitly.\n    /// @return The UID of the new schema.\n    function register(string calldata schema, ISchemaResolver resolver, bool revocable) external returns (bytes32);\n\n    /// @notice Returns an existing schema by UID\n    /// @param uid The UID of the schema to retrieve.\n    /// @return The schema data members.\n    function getSchema(bytes32 uid) external view returns (SchemaRecord memory);\n}\n"
    },
    "lib/eas-contracts/contracts/ISemver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/// @title ISemver\n/// @notice A semver interface.\ninterface ISemver {\n    /// @notice Returns the full semver contract version.\n    /// @return Semver contract version as a string.\n    function version() external view returns (string memory);\n}\n"
    },
    "lib/eas-contracts/contracts/Common.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n// A representation of an empty/uninitialized UID.\nbytes32 constant EMPTY_UID = 0;\n\n// A zero expiration represents an non-expiring attestation.\nuint64 constant NO_EXPIRATION_TIME = 0;\n\nerror AccessDenied();\nerror DeadlineExpired();\nerror InvalidEAS();\nerror InvalidLength();\nerror InvalidSignature();\nerror NotFound();\n\n/// @notice A struct representing ECDSA signature data.\nstruct Signature {\n    uint8 v; // The recovery ID.\n    bytes32 r; // The x-coordinate of the nonce R.\n    bytes32 s; // The signature data.\n}\n\n/// @notice A struct representing a single attestation.\nstruct Attestation {\n    bytes32 uid; // A unique identifier of the attestation.\n    bytes32 schema; // The unique identifier of the schema.\n    uint64 time; // The time when the attestation was created (Unix timestamp).\n    uint64 expirationTime; // The time when the attestation expires (Unix timestamp).\n    uint64 revocationTime; // The time when the attestation was revoked (Unix timestamp).\n    bytes32 refUID; // The UID of the related attestation.\n    address recipient; // The recipient of the attestation.\n    address attester; // The attester/sender of the attestation.\n    bool revocable; // Whether the attestation is revocable.\n    bytes data; // Custom attestation data.\n}\n\n/// @notice A helper function to work with unchecked iterators in loops.\nfunction uncheckedInc(uint256 i) pure returns (uint256 j) {\n    unchecked {\n        j = i + 1;\n    }\n}\n"
    },
    "lib/openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.19;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "lib/risc0-ethereum/contracts/src/Util.sol": {
      "content": "// Copyright 2024 RISC Zero, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n\npragma solidity ^0.8.9;\n\n/// @notice reverse the byte order of the uint256 value.\n/// @dev Solidity uses a big-endian ABI encoding. Reversing the byte order before encoding\n/// ensure that the encoded value will be little-endian.\n/// Written by k06a. https://ethereum.stackexchange.com/a/83627\nfunction reverseByteOrderUint256(uint256 input) pure returns (uint256 v) {\n    v = input;\n\n    // swap bytes\n    v = ((v & 0xFF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00) >> 8)\n        | ((v & 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) << 8);\n\n    // swap 2-byte long pairs\n    v = ((v & 0xFFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000) >> 16)\n        | ((v & 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) << 16);\n\n    // swap 4-byte long pairs\n    v = ((v & 0xFFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000) >> 32)\n        | ((v & 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) << 32);\n\n    // swap 8-byte long pairs\n    v = ((v & 0xFFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF0000000000000000) >> 64)\n        | ((v & 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) << 64);\n\n    // swap 16-byte long pairs\n    v = (v >> 128) | (v << 128);\n}\n\n/// @notice reverse the byte order of the uint32 value.\n/// @dev Solidity uses a big-endian ABI encoding. Reversing the byte order before encoding\n/// ensure that the encoded value will be little-endian.\n/// Written by k06a. https://ethereum.stackexchange.com/a/83627\nfunction reverseByteOrderUint32(uint32 input) pure returns (uint32 v) {\n    v = input;\n\n    // swap bytes\n    v = ((v & 0xFF00FF00) >> 8) | ((v & 0x00FF00FF) << 8);\n\n    // swap 2-byte long pairs\n    v = (v >> 16) | (v << 16);\n}\n\n/// @notice reverse the byte order of the uint16 value.\n/// @dev Solidity uses a big-endian ABI encoding. Reversing the byte order before encoding\n/// ensure that the encoded value will be little-endian.\n/// Written by k06a. https://ethereum.stackexchange.com/a/83627\nfunction reverseByteOrderUint16(uint16 input) pure returns (uint16 v) {\n    v = input;\n\n    // swap bytes\n    v = (v >> 8) | ((v & 0x00FF) << 8);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.19;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "src/interfaces/IFundRegistry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {IBaseRegistry} from \"src/interfaces/IBaseRegistry.sol\";\nimport {IRoleRegistry} from \"src/interfaces/IRoleRegistry.sol\";\nimport {IOperationsEngine} from \"src/interfaces/IOperationsEngine.sol\";\n\n/**\n * @title IFundRegistry\n * @author Libre\n * @notice Interface for managing and storing information related to funds within a registry.\n * Provides functionality to initialize the registry, add new funds, and emit events for key actions.\n */\ninterface IFundRegistry is IBaseRegistry {\n    /// @notice Error raised when attempting to register a fund that is already registered.\n    error IFundRegistry_AlreadyRegistered();\n\n    /**\n     * @notice Emited when a new Fund is added\n     * @param fundId Id of the new fund\n     */\n    event NewFundAdded(bytes32 indexed fundId);\n\n    /**\n     * @notice Initialize the registry\n     * @param _roleRegistry Address of the role registry\n     */\n    function initialize(IRoleRegistry _roleRegistry, IOperationsEngine _operationsEngine) external;\n\n    /**\n     * @notice Adds a new fund to the registry\n     * @param _senderRole Role of the sender which allow the operation execution\n     * @param _fundId The ID of the fund\n     */\n    function addNewFund(bytes32 _senderRole, bytes32 _fundId) external;\n}\n"
    },
    "src/interfaces/operations/IOperationModule.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {IInvestorRegistry} from \"src/interfaces/IInvestorRegistry.sol\";\nimport {IFundRegistry} from \"src/interfaces/IFundRegistry.sol\";\nimport {IDealerRegistry} from \"src/interfaces/IDealerRegistry.sol\";\nimport {IInstrumentRegistry} from \"src/interfaces/IInstrumentRegistry.sol\";\nimport {IEternalRegistryStorage} from \"src/interfaces/IEternalRegistryStorage.sol\";\nimport {IRoleRegistry} from \"src/interfaces/IRoleRegistry.sol\";\n\nenum OPERATIONS {\n    // Transfer specific operations:\n    TRANSFER,\n    FORCED_TRANSFER,\n    RECEIVE,\n    SEND,\n    CLAWBACK,\n    // Subscription specific operations:\n    ADVISED_CREATE_SUBSCRIPTION,\n    CREATE_SUBSCRIPTION,\n    SUBSCRIPTION_EXECUTION_DATE_CALCULATION,\n    SETTLE_SUBSCRIPTIONS,\n    SETTLE_SUBSCRIPTION_PER_ORDER,\n    SUBSCRIPTION_CANCELLATION,\n    // Redemption specific operations:\n    ADVISED_CREATE_REDEMPTION,\n    CREATE_REDEMPTION,\n    REDEMPTION_EXECUTION_DATE_CALCULATION,\n    REDEMPTION_CANCELLATION,\n    SETTLE_REDEMPTIONS,\n    SETTLE_REDEMPTION_PER_ORDER,\n    FORCED_REDEMPTION,\n    REDEMPTION_FEE,\n    // Secondary Market specific operations:\n    FILL,\n    ORDER,\n    TRADE,\n    // NAV operations:\n    UPDATE_AUDITED_NAV_PER_SHARE\n}\n\ninterface IOperationModule {\n    /**\n     * @return The list of operations associated with a module\n     * @dev It should contains all the Operation ids of all\n     * the IOperations it implements\n     */\n    function getOperations() external pure returns (OPERATIONS[] memory);\n\n    /**\n     * @return Returns the name of the module\n     */\n    function name() external pure returns (string memory);\n\n    /**\n     * @return Returns the hash of the module name\n     */\n    function nameHash() external pure returns (bytes32);\n}\n"
    },
    "lib/risc0-ethereum/contracts/src/steel/Steel.sol": {
      "content": "// Copyright 2024 RISC Zero, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n\npragma solidity ^0.8.9;\n\n/// @title Steel Library\n/// @notice This library provides a collection of utilities to work with Steel commitments in Solidity.\nlibrary Steel {\n    /// @notice Represents a commitment to a specific block in the blockchain.\n    /// @dev The `id` combines the version and the actual identifier of the claim, such as the block number.\n    /// @dev The `digest` represents the data being committed to, e.g. the hash of the execution block.\n    /// @dev The `configID` is the cryptographic digest of the network configuration.\n    struct Commitment {\n        uint256 id;\n        bytes32 digest;\n        bytes32 configID;\n    }\n\n    /// @notice The version of the Commitment is incorrect.\n    error InvalidCommitmentVersion();\n\n    /// @notice The Commitment is too old and can no longer be validated.\n    error CommitmentTooOld();\n\n    /// @notice Validates if the provided Commitment matches the block hash of the given block number.\n    /// @param commitment The Commitment struct to validate.\n    /// @return True if the commitment's block hash matches the block hash of the block number, false otherwise.\n    function validateCommitment(Commitment memory commitment) internal view returns (bool) {\n        (uint240 claimID, uint16 version) = Encoding.decodeVersionedID(commitment.id);\n        if (version == 0) {\n            return validateBlockCommitment(claimID, commitment.digest);\n        } else if (version == 1) {\n            return validateBeaconCommitment(claimID, commitment.digest);\n        } else {\n            revert InvalidCommitmentVersion();\n        }\n    }\n\n    /// @notice Validates if the provided block commitment matches the block hash of the given block number.\n    /// @param blockNumber The block number to compare against.\n    /// @param blockHash The block hash to validate.\n    /// @return True if the block's block hash matches the block hash, false otherwise.\n    function validateBlockCommitment(uint256 blockNumber, bytes32 blockHash) internal view returns (bool) {\n        if (block.number - blockNumber > 256) {\n            revert CommitmentTooOld();\n        }\n        return blockHash == blockhash(blockNumber);\n    }\n\n    /// @notice Validates if the provided beacon commitment matches the block root of the given timestamp.\n    /// @param timestamp The timestamp to compare against.\n    /// @param blockRoot The block root to validate.\n    /// @return True if the block's block root matches the block root, false otherwise.\n    function validateBeaconCommitment(uint256 timestamp, bytes32 blockRoot) internal view returns (bool) {\n        if (block.timestamp - timestamp > 12 * 8191) {\n            revert CommitmentTooOld();\n        }\n        return blockRoot == Beacon.parentBlockRoot(timestamp);\n    }\n}\n\n/// @title Beacon Library\nlibrary Beacon {\n    /// @notice The address of the Beacon roots contract.\n    /// @dev https://eips.ethereum.org/EIPS/eip-4788\n    address internal constant BEACON_ROOTS_ADDRESS = 0x000F3df6D732807Ef1319fB7B8bB8522d0Beac02;\n\n    /// @notice Find the root of the Beacon block corresponding to the parent of the execution block with the given timestamp.\n    /// @return root Returns the corresponding Beacon block root or null, if no such block exists.\n    function parentBlockRoot(uint256 timestamp) internal view returns (bytes32 root) {\n        (bool success, bytes memory result) = BEACON_ROOTS_ADDRESS.staticcall(abi.encode(timestamp));\n        if (success) {\n            return abi.decode(result, (bytes32));\n        }\n    }\n}\n\n/// @title Encoding Library\nlibrary Encoding {\n    /// @notice Encodes a version and ID into a single uint256 value.\n    /// @param id The base ID to be encoded, limited by 240 bits (or the maximum value of a uint240).\n    /// @param version The version number to be encoded, limited by 16 bits (or the maximum value of a uint16).\n    /// @return Returns a single uint256 value that contains both the `id` and the `version` encoded into it.\n    function encodeVersionedID(uint240 id, uint16 version) internal pure returns (uint256) {\n        uint256 encoded;\n        assembly {\n            encoded := or(shl(240, version), id)\n        }\n        return encoded;\n    }\n\n    /// @notice Decodes a version and ID from a single uint256 value.\n    /// @param id The single uint256 value to be decoded.\n    /// @return Returns two values: a uint240 for the original base ID and a uint16 for the version number encoded into it.\n    function decodeVersionedID(uint256 id) internal pure returns (uint240, uint16) {\n        uint240 decoded;\n        uint16 version;\n        assembly {\n            decoded := and(id, 0x0000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n            version := shr(240, id)\n        }\n        return (decoded, version);\n    }\n}\n"
    },
    "lib/eas-contracts/contracts/resolver/ISchemaResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { Attestation } from \"./../Common.sol\";\nimport { ISemver } from \"./../ISemver.sol\";\n\n/// @title ISchemaResolver\n/// @notice The interface of an optional schema resolver.\ninterface ISchemaResolver is ISemver {\n    /// @notice Checks if the resolver can be sent ETH.\n    /// @return Whether the resolver supports ETH transfers.\n    function isPayable() external pure returns (bool);\n\n    /// @notice Processes an attestation and verifies whether it's valid.\n    /// @param attestation The new attestation.\n    /// @return Whether the attestation is valid.\n    function attest(Attestation calldata attestation) external payable returns (bool);\n\n    /// @notice Processes multiple attestations and verifies whether they are valid.\n    /// @param attestations The new attestations.\n    /// @param values Explicit ETH amounts which were sent with each attestation.\n    /// @return Whether all the attestations are valid.\n    function multiAttest(\n        Attestation[] calldata attestations,\n        uint256[] calldata values\n    ) external payable returns (bool);\n\n    /// @notice Processes an attestation revocation and verifies if it can be revoked.\n    /// @param attestation The existing attestation to be revoked.\n    /// @return Whether the attestation can be revoked.\n    function revoke(Attestation calldata attestation) external payable returns (bool);\n\n    /// @notice Processes revocation of multiple attestation and verifies they can be revoked.\n    /// @param attestations The existing attestations to be revoked.\n    /// @param values Explicit ETH amounts which were sent with each revocation.\n    /// @return Whether the attestations can be revoked.\n    function multiRevoke(\n        Attestation[] calldata attestations,\n        uint256[] calldata values\n    ) external payable returns (bool);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.19;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    }
  },
  "settings": {
    "remappings": [
      "BokkyPooBahsDateTimeLibrary/=lib/BokkyPooBahsDateTimeLibrary/",
      "ds-test/=lib/forge-std/lib/ds-test/src/",
      "forge-std/=lib/forge-std/src/",
      "openzeppelin-contracts/=lib/openzeppelin-contracts/",
      "openzeppelin/=lib/openzeppelin-contracts/",
      "@openzeppelin/=lib/openzeppelin-contracts/",
      "openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/",
      "risc0/=lib/risc0-ethereum/contracts/src/",
      "eas-contracts/=lib/eas-contracts/contracts/",
      "safe-contracts/=lib/safe-contracts/contracts/",
      "erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/",
      "risc0-ethereum/=lib/risc0-ethereum/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "metadata": {
      "useLiteralContent": false,
      "bytecodeHash": "ipfs",
      "appendCBOR": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "evmVersion": "cancun",
    "viaIR": false,
    "libraries": {
      "src/lib/SortedLinkedList.sol": {
        "SortedLinkedList": "0x07B879C1bAaeeDe4dbC7383f6342556Ef144b27F"
      },
      "src/lib/TimeOperations.sol": {
        "TimeOperations": "0x852BE1E091189E68cD8721163286172d1e162a5a"
      },
      "src/utils/GatewayUtils.sol": {
        "GatewayUtils": "0xaB8b3a4CDdcf7B83C57880926Ba940F388897D11"
      }
    }
  }
}}