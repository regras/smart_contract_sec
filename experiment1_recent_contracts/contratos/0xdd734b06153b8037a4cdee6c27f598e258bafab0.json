{{
  "language": "Solidity",
  "sources": {
    "contracts/zegseggs.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.24;\r\n\r\n/*\r\n:..........:.....................................................................................::.\r\n:...............................................................................................:...\r\n:..................................................................................................:\r\n:...................................................................................................\r\n:...............................................................................................::.:\r\n:..................................................................................................:\r\n:...................................................................................................\r\n:.................................................................................................:.\r\n:..................................................................................................:\r\n:.................................................................................................::\r\n:.................................................................................................::\r\n:...........................................::....................................................::\r\n:.......................................=:=#%%%##%#++=:..........................................:..\r\n:.....................................-*+:.-%#+=:.=#%%#*-.........................................::\r\n:.....................................+=+::+#=:#%=.:#%%%%+:........................................:\r\n:.................................:-==##+#%%#=:=+...=%%%##=........................................:\r\n:..............................-+*%%%%%%%%%%%#-.....=%%%%%#+....................................::::\r\n...........................-*%#+++===-=--+%%%%%*===#%%%%%%%#.....................................:::\r\n........................................:*%%%%%%%%%%%%%%#%%%......................................::\r\n:.......................................=#%%%%%%%%%%%%%%%%%%...................................:::::\r\n:.......................................#%%%#%%#%%%%%%%%%%%#.....................................:::\r\n:................................:-....=*%%%%%%%%%%%%%%%%%%%+..................................:::::\r\n:................................:.....=+%%%%%%%%%%%%%%#%%%%#.....................................::\r\n:.....................................::*%%%%%%%%%%%%%%%%%%%%-...................................:::\r\n:.....................................:.##%%%%%%%%%%%%%%%%%%%#-.................................:.::\r\n:........::.............................##%%%%%%%%%%%%%%##%%%#-..................................:::\r\n:......................................:+%%%%%%%%%%%%%%%#%%%%#-...............................::::::\r\n:.......................................-%%%%%%%%%%%%%%%%##%%%*-.................................:::\r\n:.......................................=%%%%%%%%%%%%%%%%%%%%%#=:...............................:.::\r\n:.......................................=#%%%%%%%%%%%%%%%%%%%%%#-.................................::\r\n.........................................-%%%%%%%%%%%%%%%%%%%%%#-..................................:\r\n.........................................-#%%%%%%%%%%%%%%%%%%%%#=..................................:\r\n..........................................-#%%%%%%%%%%%%%%%%%%%*:.................................::\r\n:..........................................=##%%%%%%%%%%%%%%#%%#=..................................:\r\n:............................................:*#%%###########%%%#=:..............................:..\r\n:..............................................-=+%#%%%#####%##%%%*-.............................:.:\r\n:...........................................::...:%#==+*%**=::+#*##%*-............................::\r\n:................................................-%*.::+%-.....-++**#*#+:.........................::\r\n.................................................=#-...+%=......-+++:+==*+:........................:\r\n.................................................+%:...+%-.......-::+::=.:::........................\r\n.................................................*%....=#-...........=..............................\r\n.................................................##....=#-.......................................:::\r\n................................................:#*....-#-......................................:..:\r\n................................................:%=....-*-.......................................:::\r\n................................................-#:....-*-....................................::.:::\r\n................................................=#.....-*:.........................................:\r\n...............................................:*=.....-+:..........................................\r\n............................................:-*#%#+::-+**+:.........................................\r\n.........................................:-+*+***%+#****#*#==----::.:..............................:\r\n..........................................-:.-=::-.::=::-:.:........................................\r\n....................................................................................................\r\n....................................................................................................\r\n....................................................................................................\r\n....................................................................................................\r\n....................................................................................................\r\n*/\r\n\r\nimport \"https://raw.githubusercontent.com/Vectorized/solady/main/src/auth/Ownable.sol\";\r\nimport \"https://raw.githubusercontent.com/Vectorized/solady/main/src/tokens/ERC721.sol\";\r\n\r\n//special thanks to @bantg for his ridiculous Legible Math library which inspired this whole thing\r\n\r\nabstract contract ERCSevenTwentyOne is ERC721 {}\r\n\r\n/*──────────── 16‑bit signed numerator | 16‑bit unsigned denominator ──────────*/\r\ntype LM is uint32;\r\n\r\nuint32 constant _DEN_MASK = 0xFFFF;\r\nint256 constant _LIM = 32_767;\r\n\r\n/*─────────── custom errors ───────────*/\r\nerror NotInteger(int256 num, int256 den);\r\nerror OutOfRange(int256 value);\r\nerror Overflow();\r\n\r\n/*─────────── helpers ───────────*/\r\nfunction _split(LM _f) pure returns (int256 num, int256 den) {\r\n    uint32 raw = LM.unwrap(_f);\r\n    // high 16 bits → signed numerator\r\n    num = int256(int16(uint16(raw >> 16)));\r\n    // low 16 bits  → unsigned denominator, then widen safely\r\n    den = int256(uint256(uint16(raw & _DEN_MASK)));\r\n}\r\n\r\nfunction _gcd(int256 _x, int256 _y) pure returns (int256) {\r\n    while (_y != 0) (_x, _y) = (_y, _x % _y);\r\n    return _x >= 0 ? _x : -_x;\r\n}\r\n\r\nfunction _encode(int256 _n, int256 _d) pure returns (LM) {\r\n    if (_d <= 0 || _d > _LIM || _n < -_LIM || _n > _LIM) revert Overflow();\r\n    // pack a 16-bit signed numerator and 16-bit unsigned denominator into 32 bits\r\n    // ensure shift occurs on a 32-bit value so bits are not truncated\r\n    uint32 numBits = uint32(uint16(int16(_n)));\r\n    uint32 denBits = uint32(uint16(uint256(_d)));\r\n    uint32 packed = (numBits << 16) | denBits;\r\n    return LM.wrap(packed);\r\n}\r\n\r\nfunction _reduce(int256 _n, int256 _d) pure returns (LM) {\r\n    int256 _g = _gcd(_n, _d);\r\n    return _encode(_n / _g, _d / _g);\r\n}\r\n\r\n/*─────────── operator overloads ───────────*/\r\nfunction _plus(LM _x, LM _y) pure returns (LM) {\r\n    (int256 nx, int256 dx) = _split(_x);\r\n    (int256 ny, int256 dy) = _split(_y);\r\n    return _reduce(nx * dy + ny * dx, dx * dy);\r\n}\r\n\r\nfunction _minus(LM _x, LM _y) pure returns (LM) {\r\n    (int256 nx, int256 dx) = _split(_x);\r\n    (int256 ny, int256 dy) = _split(_y);\r\n    return _reduce(nx * dy - ny * dx, dx * dy);\r\n}\r\n\r\nfunction _times(LM _x, LM _y) pure returns (LM) {\r\n    (int256 nx, int256 dx) = _split(_x);\r\n    (int256 ny, int256 dy) = _split(_y);\r\n    return _reduce(nx * ny, dx * dy);\r\n}\r\n\r\nfunction _over(LM _x, LM _y) pure returns (LM) {\r\n    (int256 nx, int256 dx) = _split(_x);\r\n    (int256 ny, int256 dy) = _split(_y);\r\n    if (ny == 0) revert();\r\n    return _reduce(nx * dy, dx * ny);\r\n}\r\n\r\n/* Make the symbols work everywhere */\r\nusing {_plus as +, _minus as -, _times as *, _over as / } for LM global;\r\n\r\n/*─────────── public helpers ───────────*/\r\nlibrary LegibleMath {\r\n    struct Fraction {\r\n        int256 num;\r\n        int256 den;\r\n    }\r\n\r\n    function literally(LM _f) internal pure returns (int256) {\r\n        (int256 _n, int256 _d) = _split(_f);\r\n        if (_n % _d != 0) revert NotInteger(_n, _d);\r\n        int256 val = _n / _d;\r\n        if (val < -11 || val > 11) revert OutOfRange(val);\r\n        return val;\r\n    }\r\n\r\n    function toFraction(LM _f) internal pure returns (int256 num, int256 den) {\r\n        (num, den) = _split(_f);\r\n    }\r\n}\r\n\r\nusing LegibleMath for LM global;\r\n\r\n/*─────────── compile‑time packed constants ──────────*/\r\n/* (num << 16) | den */\r\nLM constant a = LM.wrap(0xfffd0050); // -3 / 80\r\nLM constant e = LM.wrap(0x00010001); //  1 / 1\r\nLM constant f = LM.wrap(0x00050009); //  5 / 9\r\nLM constant g = LM.wrap(0x0008001b); //  8 / 27\r\nLM constant h = LM.wrap(0x0003000a); //  3 / 10\r\nLM constant i = LM.wrap(0x00090001); //  9 / 1\r\nLM constant l = LM.wrap(0x000b0001); // 11 / 1\r\nLM constant n = LM.wrap(0x00010001); //  1 / 1\r\nLM constant o = LM.wrap(0x00010001); //  1 / 1\r\nLM constant r = LM.wrap(0x00010001); //  1 / 1\r\nLM constant s = LM.wrap(0x00070001); //  7 / 1\r\nLM constant t = LM.wrap(0x000a0001); // 10 / 1\r\nLM constant u = LM.wrap(0x00240005); // 36 / 5\r\nLM constant v = LM.wrap(0x00010001); //  1 / 1\r\nLM constant w = LM.wrap(0x00010005); //  1 / 5\r\nLM constant x = LM.wrap(0x00020015); //  2 / 21\r\nLM constant z = LM.wrap(0x00000001); //  0 / 1\r\n\r\nabstract contract LegibleKeccak {\r\n    function keccak(bytes memory input) internal pure returns (uint256) {\r\n        return uint256(keccak256(input));\r\n    }\r\n}\r\n\r\ncontract ZegsEggs is ERCSevenTwentyOne, LegibleKeccak, Ownable {\r\n\r\n    constructor(string memory tokenZeroMetadata) {\r\n        _initializeOwner(msg.sender);\r\n        _mint(msg.sender, zero);\r\n        tokenMetadata[zero] = tokenZeroMetadata;\r\n    }\r\n\r\n    function name() public pure override returns (string memory) { return \"Zeg's Eggs\"; }\r\n    function symbol() public pure override returns (string memory) { return \"ZEGG\"; }\r\n\r\n    uint zero = uint((z * e * r * o).literally());\r\n    uint one = uint((o * n * e).literally());\r\n    uint two = uint((t * w * o).literally());\r\n    uint three = uint((t * h * r * e * e).literally());\r\n    uint four = uint((f * o * u * r).literally());\r\n    uint five = uint((f * i * v * e).literally());\r\n    uint six = uint((s * i * x).literally());\r\n    uint seven = uint((s * e * v * e * n).literally());\r\n    uint eight = uint((e * i * g * h * t).literally());\r\n    uint nine = uint((n * i * n * e).literally());\r\n    uint ten = uint((t * e * n).literally());\r\n    uint eleven = uint((e * l * e * v * e * n).literally());\r\n\r\n    uint nineteen = two + eight + nine;\r\n    uint public sixtynine = eleven * six + three;\r\n    uint public fourtwenty = three * four * five * seven;\r\n    uint twofiftysix = eight * eight * four;\r\n    uint thousand = ten * ten * ten;\r\n    uint million = thousand * thousand;\r\n    uint public MAP_SIZE = eleven * ten * ten + eleven;\r\n    uint public ENTRY_FEE = eleven * million * million * thousand;\r\n    uint public HUNT_DURATION_BLOCKS = eleven * ten * ten + eleven;\r\n    uint public EGG_COUNT = eleven;\r\n    address ZERO_ADDRESS;\r\n\r\n    enum GamePhase {\r\n        PreHunt, // zero\r\n        HuntActive, // one\r\n        HuntEnded // two \r\n    }\r\n\r\n    struct Player {\r\n        address addr;\r\n        uint x;\r\n        uint y;\r\n    }\r\n\r\n    struct Egg {\r\n        uint x;\r\n        uint y;\r\n        bool claimed;\r\n        bool revealed;\r\n        address winner;\r\n    }\r\n\r\n    Player[] public players;\r\n    mapping(address => uint) public entriesByAddress;\r\n    mapping(uint => Egg) public eggs;\r\n    mapping(uint => string) internal tokenMetadata;\r\n    mapping(uint => mapping(uint => bool)) coordsTaken;\r\n\r\n    uint public gameStartBlock;\r\n    bool public gameStarted;\r\n    bool public gameFinalized;\r\n    GamePhase public gamePhase = GamePhase.PreHunt;\r\n\r\n    event PlayerGuessed(address indexed player, uint x, uint y);\r\n    event EggRevealed(uint eggIndex, uint eggX, uint eggY);\r\n\r\n    modifier onlyDuringGame() {\r\n        require(gameStarted, \"Game not started\");\r\n        require(block.number <= gameStartBlock + HUNT_DURATION_BLOCKS, \"Game ended\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyAfterGame() {\r\n        require(gameStarted, \"Game not started\");\r\n        require(block.number > gameStartBlock + HUNT_DURATION_BLOCKS, \"Game still active\");\r\n        _;\r\n    }\r\n\r\n    function startGame() external onlyOwner {\r\n        require(!gameStarted, \"Game already started\");\r\n        gameStartBlock = block.number;\r\n        gameStarted = true;\r\n        gamePhase = GamePhase.HuntActive;\r\n    }\r\n\r\n    function setZeroAddress(address _zeroAddress) external onlyOwner {\r\n        ZERO_ADDRESS = _zeroAddress;\r\n    }\r\n\r\n    function getBlocksUntilGameOver() external view returns (uint) {\r\n        if (block.number >= gameStartBlock + HUNT_DURATION_BLOCKS) return zero;\r\n        return (gameStartBlock + HUNT_DURATION_BLOCKS) - block.number;\r\n    }\r\n\r\n    function whereIsTheEgg(uint xCoord, uint yCoord) external payable onlyDuringGame {\r\n        require(entriesByAddress[msg.sender] < three, \"Maximum guesses reached\");\r\n        require((msg.value == ENTRY_FEE), \"Incorrect entry fee\");\r\n        require(players.length < eleven * ten * ten + eleven, \"Max players reached\");\r\n        require((xCoord <= MAP_SIZE && yCoord <= MAP_SIZE), \"Invalid coordinates\");\r\n        require(!coordsTaken[xCoord][yCoord], \"That spot has already been claimed.\");\r\n\r\n        coordsTaken[xCoord][yCoord] = true;\r\n\r\n        players.push(Player(msg.sender, xCoord, yCoord));\r\n        entriesByAddress[msg.sender]++;\r\n        emit PlayerGuessed(msg.sender, xCoord, yCoord);\r\n    }\r\n\r\n    function getAllPlayerGuesses()\r\n        external\r\n        view\r\n        returns (address[] memory addrs, uint[] memory xs, uint[] memory ys)\r\n    {\r\n        uint len = players.length;\r\n        addrs = new address[](len);\r\n        xs = new uint[](len);\r\n        ys = new uint[](len);\r\n\r\n        for (uint index = zero; index < len; index++) {\r\n            Player memory player = players[index];\r\n            addrs[index] = player.addr;\r\n            xs[index] = player.x;\r\n            ys[index] = player.y;\r\n        }\r\n    }\r\n\r\n    function revealEgg(uint eggId) external {\r\n        require(gameStarted, \"Game not started\");\r\n        require(eggId >= one && eggId <= eleven, \"Invalid egg ID\");\r\n        require(!eggs[eggId].revealed, \"Already revealed\");\r\n\r\n        uint revealBase = gameStartBlock + HUNT_DURATION_BLOCKS;\r\n        uint xBlock = revealBase + eggId + one; // offset for X\r\n        uint yBlock = revealBase + eggId + two; // offset for Y\r\n\r\n        require(block.number > yBlock, \"Too early to reveal\");\r\n        require(block.number <= yBlock + twofiftysix, \"Reveal window expired\");\r\n\r\n        uint eggX = uint(keccak(abi.encodePacked(blockhash(xBlock), \"EGG\", eggId, address(this)))) % MAP_SIZE;\r\n        uint eggY = uint(keccak(abi.encodePacked(blockhash(yBlock), \"EGG\", eggId, address(this)))) % MAP_SIZE;\r\n\r\n        eggs[eggId] = Egg({x: eggX, y: eggY, revealed: true, claimed: false, winner: address(ZERO_ADDRESS)});\r\n\r\n        emit EggRevealed(eggId, eggX, eggY);\r\n\r\n        if (gamePhase == GamePhase.HuntActive) {\r\n            gamePhase = GamePhase.HuntEnded;\r\n        }\r\n\r\n        if (!gameFinalized) {\r\n            gameFinalized = true;\r\n        }\r\n    }\r\n\r\n    function getEggCoords(uint eggId) external view returns (uint xCoord, uint yCoord) {\r\n        Egg memory egg = eggs[eggId];\r\n        require(gameFinalized, \"Game not finalized\");\r\n        require(egg.revealed, \"Egg not revealed yet\");\r\n        require(eggId >= one && eggId <= eleven, \"Invalid egg ID\");\r\n        return (egg.x, egg.y);\r\n    }\r\n\r\n    function getWinner(uint eggId) public view returns (address) {\r\n        Egg memory egg = eggs[eggId];\r\n        require(gameFinalized, \"Game not finalized\");\r\n        require(egg.revealed, \"Egg mot revealed yet\");\r\n        require(eggId >= one && eggId <= eleven, \"Invalid egg ID\");\r\n\r\n        uint closestIndex = zero;\r\n        uint minDistance = type(uint).max;\r\n        for (uint index = zero; index < players.length; index++) {\r\n            Player memory player = players[index];\r\n            uint dx = player.x > egg.x ? player.x - egg.x : egg.x - player.x;\r\n            uint dy = player.y > egg.y ? player.y - egg.y : egg.y - player.y;\r\n            uint dist = dx * dx + dy * dy;\r\n\r\n            if (dist < minDistance) {\r\n                minDistance = dist;\r\n                closestIndex = index;\r\n            }\r\n        }\r\n\r\n        return players[closestIndex].addr;\r\n    }\r\n\r\n    function ownerClaimEgg(uint eggId) public onlyOwner {\r\n        Egg memory egg = eggs[eggId];\r\n        require(gameFinalized, \"Game not finalized\");\r\n        require(!egg.claimed, \"Egg already claimed\");\r\n        require(egg.revealed, \"Egg not yet revealed\");\r\n\r\n        address winner = getWinner(eggId);\r\n        egg.winner = winner;\r\n        egg.claimed = true;\r\n        eggs[eggId] = egg;\r\n        _mint(winner, eggId);\r\n    }\r\n\r\n    function ownerClaimAll() external onlyOwner {\r\n        for (uint eggId = one; eggId <= eleven; eggId++) {\r\n            if (!eggs[eggId].claimed) {\r\n                ownerClaimEgg(eggId);\r\n            }\r\n        }\r\n    }\r\n\r\n    function getGuessCount() external view returns (uint) {\r\n        return players.length;\r\n    }\r\n\r\n    function isGameActive() external view returns (bool) {\r\n        return gameStarted && block.number <= gameStartBlock + HUNT_DURATION_BLOCKS && !gameFinalized;\r\n    }\r\n\r\n    mapping(address => bool) public canRead;\r\n    address[] public readers;\r\n\r\n    function iCanRead() external {\r\n        require(entriesByAddress[msg.sender] > zero, \"Only hunters can sign.\");\r\n        require(!canRead[msg.sender], \"Already signed.\");\r\n\r\n        canRead[msg.sender] = true;\r\n        readers.push(msg.sender);\r\n    }\r\n\r\n    function getReaders() external view returns (address[] memory) {\r\n        return readers;\r\n    }\r\n\r\n    function updateMetadata(uint tokenId, string memory metadata) external onlyOwner {\r\n        require(tokenId <= eleven, \"Nonexistent token\");\r\n        tokenMetadata[tokenId] = metadata;\r\n    }\r\n\r\n    function tokenURI(uint tokenId) public view override returns (string memory) {\r\n        require(_exists(tokenId), \"Nonexistent token\");\r\n        require(tokenId <= eleven, \"Nonexistent token\");\r\n        return tokenMetadata[tokenId];\r\n    }\r\n\r\n    function withdraw() external onlyOwner {\r\n        require(address(this).balance > zero, \"No ETH to withdraw\");\r\n        (bool success,) = payable(owner()).call{value: address(this).balance}(\"\");\r\n        require(success, \"Withdraw failed\");\r\n    }\r\n\r\n    receive() external payable {}\r\n}\r\n"
    },
    "https://raw.githubusercontent.com/Vectorized/solady/main/src/tokens/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Simple ERC721 implementation with storage hitchhiking.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/tokens/ERC721.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/tree/master/contracts/token/ERC721/ERC721.sol)\n///\n/// @dev Note:\n/// - The ERC721 standard allows for self-approvals.\n///   For performance, this implementation WILL NOT revert for such actions.\n///   Please add any checks with overrides if desired.\n/// - For performance, methods are made payable where permitted by the ERC721 standard.\n/// - The `safeTransfer` functions use the identity precompile (0x4)\n///   to copy memory internally.\n///\n/// If you are overriding:\n/// - NEVER violate the ERC721 invariant:\n///   the balance of an owner MUST always be equal to their number of ownership slots.\n///   The transfer functions do not have an underflow guard for user token balances.\n/// - Make sure all variables written to storage are properly cleaned\n///   (e.g. the bool value for `isApprovedForAll` MUST be either 1 or 0 under the hood).\n/// - Check that the overridden function is actually used in the function you want to\n///   change the behavior of. Much of the code has been manually inlined for performance.\nabstract contract ERC721 {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         CONSTANTS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev An account can hold up to 4294967295 tokens.\n    uint256 internal constant _MAX_ACCOUNT_BALANCE = 0xffffffff;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Only the token owner or an approved account can manage the token.\n    error NotOwnerNorApproved();\n\n    /// @dev The token does not exist.\n    error TokenDoesNotExist();\n\n    /// @dev The token already exists.\n    error TokenAlreadyExists();\n\n    /// @dev Cannot query the balance for the zero address.\n    error BalanceQueryForZeroAddress();\n\n    /// @dev Cannot mint or transfer to the zero address.\n    error TransferToZeroAddress();\n\n    /// @dev The token must be owned by `from`.\n    error TransferFromIncorrectOwner();\n\n    /// @dev The recipient's balance has overflowed.\n    error AccountBalanceOverflow();\n\n    /// @dev Cannot safely transfer to a contract that does not implement\n    /// the ERC721Receiver interface.\n    error TransferToNonERC721ReceiverImplementer();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                           EVENTS                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Emitted when token `id` is transferred from `from` to `to`.\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n\n    /// @dev Emitted when `owner` enables `account` to manage the `id` token.\n    event Approval(address indexed owner, address indexed account, uint256 indexed id);\n\n    /// @dev Emitted when `owner` enables or disables `operator` to manage all of their tokens.\n    event ApprovalForAll(address indexed owner, address indexed operator, bool isApproved);\n\n    /// @dev `keccak256(bytes(\"Transfer(address,address,uint256)\"))`.\n    uint256 private constant _TRANSFER_EVENT_SIGNATURE =\n        0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;\n\n    /// @dev `keccak256(bytes(\"Approval(address,address,uint256)\"))`.\n    uint256 private constant _APPROVAL_EVENT_SIGNATURE =\n        0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925;\n\n    /// @dev `keccak256(bytes(\"ApprovalForAll(address,address,bool)\"))`.\n    uint256 private constant _APPROVAL_FOR_ALL_EVENT_SIGNATURE =\n        0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                          STORAGE                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The ownership data slot of `id` is given by:\n    /// ```\n    ///     mstore(0x00, id)\n    ///     mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\n    ///     let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))\n    /// ```\n    /// Bits Layout:\n    /// - [0..159]   `addr`\n    /// - [160..255] `extraData`\n    ///\n    /// The approved address slot is given by: `add(1, ownershipSlot)`.\n    ///\n    /// See: https://notes.ethereum.org/%40vbuterin/verkle_tree_eip\n    ///\n    /// The balance slot of `owner` is given by:\n    /// ```\n    ///     mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\n    ///     mstore(0x00, owner)\n    ///     let balanceSlot := keccak256(0x0c, 0x1c)\n    /// ```\n    /// Bits Layout:\n    /// - [0..31]   `balance`\n    /// - [32..255] `aux`\n    ///\n    /// The `operator` approval slot of `owner` is given by:\n    /// ```\n    ///     mstore(0x1c, or(_ERC721_MASTER_SLOT_SEED, operator))\n    ///     mstore(0x00, owner)\n    ///     let operatorApprovalSlot := keccak256(0x0c, 0x30)\n    /// ```\n    uint256 private constant _ERC721_MASTER_SLOT_SEED = 0x7d8825530a5a2e7a << 192;\n\n    /// @dev Pre-shifted and pre-masked constant.\n    uint256 private constant _ERC721_MASTER_SLOT_SEED_MASKED = 0x0a5a2e7a00000000;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      ERC721 METADATA                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the token collection name.\n    function name() public view virtual returns (string memory);\n\n    /// @dev Returns the token collection symbol.\n    function symbol() public view virtual returns (string memory);\n\n    /// @dev Returns the Uniform Resource Identifier (URI) for token `id`.\n    function tokenURI(uint256 id) public view virtual returns (string memory);\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                           ERC721                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the owner of token `id`.\n    ///\n    /// Requirements:\n    /// - Token `id` must exist.\n    function ownerOf(uint256 id) public view virtual returns (address result) {\n        result = _ownerOf(id);\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(result) {\n                mstore(0x00, 0xceea21b6) // `TokenDoesNotExist()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Returns the number of tokens owned by `owner`.\n    ///\n    /// Requirements:\n    /// - `owner` must not be the zero address.\n    function balanceOf(address owner) public view virtual returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Revert if the `owner` is the zero address.\n            if iszero(owner) {\n                mstore(0x00, 0x8f4eb604) // `BalanceQueryForZeroAddress()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\n            mstore(0x00, owner)\n            result := and(sload(keccak256(0x0c, 0x1c)), _MAX_ACCOUNT_BALANCE)\n        }\n    }\n\n    /// @dev Returns the account approved to manage token `id`.\n    ///\n    /// Requirements:\n    /// - Token `id` must exist.\n    function getApproved(uint256 id) public view virtual returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, id)\n            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\n            let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))\n            if iszero(shl(96, sload(ownershipSlot))) {\n                mstore(0x00, 0xceea21b6) // `TokenDoesNotExist()`.\n                revert(0x1c, 0x04)\n            }\n            result := sload(add(1, ownershipSlot))\n        }\n    }\n\n    /// @dev Sets `account` as the approved account to manage token `id`.\n    ///\n    /// Requirements:\n    /// - Token `id` must exist.\n    /// - The caller must be the owner of the token,\n    ///   or an approved operator for the token owner.\n    ///\n    /// Emits an {Approval} event.\n    function approve(address account, uint256 id) public payable virtual {\n        _approve(msg.sender, account, id);\n    }\n\n    /// @dev Returns whether `operator` is approved to manage the tokens of `owner`.\n    function isApprovedForAll(address owner, address operator)\n        public\n        view\n        virtual\n        returns (bool result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x1c, operator)\n            mstore(0x08, _ERC721_MASTER_SLOT_SEED_MASKED)\n            mstore(0x00, owner)\n            result := sload(keccak256(0x0c, 0x30))\n        }\n    }\n\n    /// @dev Sets whether `operator` is approved to manage the tokens of the caller.\n    ///\n    /// Emits an {ApprovalForAll} event.\n    function setApprovalForAll(address operator, bool isApproved) public virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Convert to 0 or 1.\n            isApproved := iszero(iszero(isApproved))\n            // Update the `isApproved` for (`msg.sender`, `operator`).\n            mstore(0x1c, operator)\n            mstore(0x08, _ERC721_MASTER_SLOT_SEED_MASKED)\n            mstore(0x00, caller())\n            sstore(keccak256(0x0c, 0x30), isApproved)\n            // Emit the {ApprovalForAll} event.\n            mstore(0x00, isApproved)\n            // forgefmt: disable-next-item\n            log3(0x00, 0x20, _APPROVAL_FOR_ALL_EVENT_SIGNATURE, caller(), shr(96, shl(96, operator)))\n        }\n    }\n\n    /// @dev Transfers token `id` from `from` to `to`.\n    ///\n    /// Requirements:\n    ///\n    /// - Token `id` must exist.\n    /// - `from` must be the owner of the token.\n    /// - `to` cannot be the zero address.\n    /// - The caller must be the owner of the token, or be approved to manage the token.\n    ///\n    /// Emits a {Transfer} event.\n    function transferFrom(address from, address to, uint256 id) public payable virtual {\n        _beforeTokenTransfer(from, to, id);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Clear the upper 96 bits.\n            let bitmaskAddress := shr(96, not(0))\n            from := and(bitmaskAddress, from)\n            to := and(bitmaskAddress, to)\n            // Load the ownership data.\n            mstore(0x00, id)\n            mstore(0x1c, or(_ERC721_MASTER_SLOT_SEED, caller()))\n            let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))\n            let ownershipPacked := sload(ownershipSlot)\n            let owner := and(bitmaskAddress, ownershipPacked)\n            // Revert if the token does not exist, or if `from` is not the owner.\n            if iszero(mul(owner, eq(owner, from))) {\n                // `TokenDoesNotExist()`, `TransferFromIncorrectOwner()`.\n                mstore(shl(2, iszero(owner)), 0xceea21b6a1148100)\n                revert(0x1c, 0x04)\n            }\n            // Load, check, and update the token approval.\n            {\n                mstore(0x00, from)\n                let approvedAddress := sload(add(1, ownershipSlot))\n                // Revert if the caller is not the owner, nor approved.\n                if iszero(or(eq(caller(), from), eq(caller(), approvedAddress))) {\n                    if iszero(sload(keccak256(0x0c, 0x30))) {\n                        mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.\n                        revert(0x1c, 0x04)\n                    }\n                }\n                // Delete the approved address if any.\n                if approvedAddress { sstore(add(1, ownershipSlot), 0) }\n            }\n            // Update with the new owner.\n            sstore(ownershipSlot, xor(ownershipPacked, xor(from, to)))\n            // Decrement the balance of `from`.\n            {\n                let fromBalanceSlot := keccak256(0x0c, 0x1c)\n                sstore(fromBalanceSlot, sub(sload(fromBalanceSlot), 1))\n            }\n            // Increment the balance of `to`.\n            {\n                mstore(0x00, to)\n                let toBalanceSlot := keccak256(0x0c, 0x1c)\n                let toBalanceSlotPacked := add(sload(toBalanceSlot), 1)\n                // Revert if `to` is the zero address, or if the account balance overflows.\n                if iszero(mul(to, and(toBalanceSlotPacked, _MAX_ACCOUNT_BALANCE))) {\n                    // `TransferToZeroAddress()`, `AccountBalanceOverflow()`.\n                    mstore(shl(2, iszero(to)), 0xea553b3401336cea)\n                    revert(0x1c, 0x04)\n                }\n                sstore(toBalanceSlot, toBalanceSlotPacked)\n            }\n            // Emit the {Transfer} event.\n            log4(codesize(), 0x00, _TRANSFER_EVENT_SIGNATURE, from, to, id)\n        }\n        _afterTokenTransfer(from, to, id);\n    }\n\n    /// @dev Equivalent to `safeTransferFrom(from, to, id, \"\")`.\n    function safeTransferFrom(address from, address to, uint256 id) public payable virtual {\n        transferFrom(from, to, id);\n        if (_hasCode(to)) _checkOnERC721Received(from, to, id, \"\");\n    }\n\n    /// @dev Transfers token `id` from `from` to `to`.\n    ///\n    /// Requirements:\n    ///\n    /// - Token `id` must exist.\n    /// - `from` must be the owner of the token.\n    /// - `to` cannot be the zero address.\n    /// - The caller must be the owner of the token, or be approved to manage the token.\n    /// - If `to` refers to a smart contract, it must implement\n    ///   {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n    ///\n    /// Emits a {Transfer} event.\n    function safeTransferFrom(address from, address to, uint256 id, bytes calldata data)\n        public\n        payable\n        virtual\n    {\n        transferFrom(from, to, id);\n        if (_hasCode(to)) _checkOnERC721Received(from, to, id, data);\n    }\n\n    /// @dev Returns true if this contract implements the interface defined by `interfaceId`.\n    /// See: https://eips.ethereum.org/EIPS/eip-165\n    /// This function call must use less than 30000 gas.\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let s := shr(224, interfaceId)\n            // ERC165: 0x01ffc9a7, ERC721: 0x80ac58cd, ERC721Metadata: 0x5b5e139f.\n            result := or(or(eq(s, 0x01ffc9a7), eq(s, 0x80ac58cd)), eq(s, 0x5b5e139f))\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                  INTERNAL QUERY FUNCTIONS                  */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns if token `id` exists.\n    function _exists(uint256 id) internal view virtual returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, id)\n            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\n            result := iszero(iszero(shl(96, sload(add(id, add(id, keccak256(0x00, 0x20)))))))\n        }\n    }\n\n    /// @dev Returns the owner of token `id`.\n    /// Returns the zero address instead of reverting if the token does not exist.\n    function _ownerOf(uint256 id) internal view virtual returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, id)\n            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\n            result := shr(96, shl(96, sload(add(id, add(id, keccak256(0x00, 0x20))))))\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*            INTERNAL DATA HITCHHIKING FUNCTIONS             */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // For performance, no events are emitted for the hitchhiking setters.\n    // Please emit your own events if required.\n\n    /// @dev Returns the auxiliary data for `owner`.\n    /// Minting, transferring, burning the tokens of `owner` will not change the auxiliary data.\n    /// Auxiliary data can be set for any address, even if it does not have any tokens.\n    function _getAux(address owner) internal view virtual returns (uint224 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\n            mstore(0x00, owner)\n            result := shr(32, sload(keccak256(0x0c, 0x1c)))\n        }\n    }\n\n    /// @dev Set the auxiliary data for `owner` to `value`.\n    /// Minting, transferring, burning the tokens of `owner` will not change the auxiliary data.\n    /// Auxiliary data can be set for any address, even if it does not have any tokens.\n    function _setAux(address owner, uint224 value) internal virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\n            mstore(0x00, owner)\n            let balanceSlot := keccak256(0x0c, 0x1c)\n            let packed := sload(balanceSlot)\n            sstore(balanceSlot, xor(packed, shl(32, xor(value, shr(32, packed)))))\n        }\n    }\n\n    /// @dev Returns the extra data for token `id`.\n    /// Minting, transferring, burning a token will not change the extra data.\n    /// The extra data can be set on a non-existent token.\n    function _getExtraData(uint256 id) internal view virtual returns (uint96 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, id)\n            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\n            result := shr(160, sload(add(id, add(id, keccak256(0x00, 0x20)))))\n        }\n    }\n\n    /// @dev Sets the extra data for token `id` to `value`.\n    /// Minting, transferring, burning a token will not change the extra data.\n    /// The extra data can be set on a non-existent token.\n    function _setExtraData(uint256 id, uint96 value) internal virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, id)\n            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\n            let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))\n            let packed := sload(ownershipSlot)\n            sstore(ownershipSlot, xor(packed, shl(160, xor(value, shr(160, packed)))))\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                  INTERNAL MINT FUNCTIONS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Mints token `id` to `to`.\n    ///\n    /// Requirements:\n    ///\n    /// - Token `id` must not exist.\n    /// - `to` cannot be the zero address.\n    ///\n    /// Emits a {Transfer} event.\n    function _mint(address to, uint256 id) internal virtual {\n        _beforeTokenTransfer(address(0), to, id);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Clear the upper 96 bits.\n            to := shr(96, shl(96, to))\n            // Load the ownership data.\n            mstore(0x00, id)\n            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\n            let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))\n            let ownershipPacked := sload(ownershipSlot)\n            // Revert if the token already exists.\n            if shl(96, ownershipPacked) {\n                mstore(0x00, 0xc991cbb1) // `TokenAlreadyExists()`.\n                revert(0x1c, 0x04)\n            }\n            // Update with the owner.\n            sstore(ownershipSlot, or(ownershipPacked, to))\n            // Increment the balance of the owner.\n            {\n                mstore(0x00, to)\n                let balanceSlot := keccak256(0x0c, 0x1c)\n                let balanceSlotPacked := add(sload(balanceSlot), 1)\n                // Revert if `to` is the zero address, or if the account balance overflows.\n                if iszero(mul(to, and(balanceSlotPacked, _MAX_ACCOUNT_BALANCE))) {\n                    // `TransferToZeroAddress()`, `AccountBalanceOverflow()`.\n                    mstore(shl(2, iszero(to)), 0xea553b3401336cea)\n                    revert(0x1c, 0x04)\n                }\n                sstore(balanceSlot, balanceSlotPacked)\n            }\n            // Emit the {Transfer} event.\n            log4(codesize(), 0x00, _TRANSFER_EVENT_SIGNATURE, 0, to, id)\n        }\n        _afterTokenTransfer(address(0), to, id);\n    }\n\n    /// @dev Mints token `id` to `to`, and updates the extra data for token `id` to `value`.\n    /// Does NOT check if token `id` already exists (assumes `id` is auto-incrementing).\n    ///\n    /// Requirements:\n    ///\n    /// - `to` cannot be the zero address.\n    ///\n    /// Emits a {Transfer} event.\n    function _mintAndSetExtraDataUnchecked(address to, uint256 id, uint96 value) internal virtual {\n        _beforeTokenTransfer(address(0), to, id);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Clear the upper 96 bits.\n            to := shr(96, shl(96, to))\n            // Update with the owner and extra data.\n            mstore(0x00, id)\n            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\n            sstore(add(id, add(id, keccak256(0x00, 0x20))), or(shl(160, value), to))\n            // Increment the balance of the owner.\n            {\n                mstore(0x00, to)\n                let balanceSlot := keccak256(0x0c, 0x1c)\n                let balanceSlotPacked := add(sload(balanceSlot), 1)\n                // Revert if `to` is the zero address, or if the account balance overflows.\n                if iszero(mul(to, and(balanceSlotPacked, _MAX_ACCOUNT_BALANCE))) {\n                    // `TransferToZeroAddress()`, `AccountBalanceOverflow()`.\n                    mstore(shl(2, iszero(to)), 0xea553b3401336cea)\n                    revert(0x1c, 0x04)\n                }\n                sstore(balanceSlot, balanceSlotPacked)\n            }\n            // Emit the {Transfer} event.\n            log4(codesize(), 0x00, _TRANSFER_EVENT_SIGNATURE, 0, to, id)\n        }\n        _afterTokenTransfer(address(0), to, id);\n    }\n\n    /// @dev Equivalent to `_safeMint(to, id, \"\")`.\n    function _safeMint(address to, uint256 id) internal virtual {\n        _safeMint(to, id, \"\");\n    }\n\n    /// @dev Mints token `id` to `to`.\n    ///\n    /// Requirements:\n    ///\n    /// - Token `id` must not exist.\n    /// - `to` cannot be the zero address.\n    /// - If `to` refers to a smart contract, it must implement\n    ///   {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n    ///\n    /// Emits a {Transfer} event.\n    function _safeMint(address to, uint256 id, bytes memory data) internal virtual {\n        _mint(to, id);\n        if (_hasCode(to)) _checkOnERC721Received(address(0), to, id, data);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                  INTERNAL BURN FUNCTIONS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Equivalent to `_burn(address(0), id)`.\n    function _burn(uint256 id) internal virtual {\n        _burn(address(0), id);\n    }\n\n    /// @dev Destroys token `id`, using `by`.\n    ///\n    /// Requirements:\n    ///\n    /// - Token `id` must exist.\n    /// - If `by` is not the zero address,\n    ///   it must be the owner of the token, or be approved to manage the token.\n    ///\n    /// Emits a {Transfer} event.\n    function _burn(address by, uint256 id) internal virtual {\n        address owner = ownerOf(id);\n        _beforeTokenTransfer(owner, address(0), id);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Clear the upper 96 bits.\n            by := shr(96, shl(96, by))\n            // Load the ownership data.\n            mstore(0x00, id)\n            mstore(0x1c, or(_ERC721_MASTER_SLOT_SEED, by))\n            let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))\n            let ownershipPacked := sload(ownershipSlot)\n            // Reload the owner in case it is changed in `_beforeTokenTransfer`.\n            owner := shr(96, shl(96, ownershipPacked))\n            // Revert if the token does not exist.\n            if iszero(owner) {\n                mstore(0x00, 0xceea21b6) // `TokenDoesNotExist()`.\n                revert(0x1c, 0x04)\n            }\n            // Load and check the token approval.\n            {\n                mstore(0x00, owner)\n                let approvedAddress := sload(add(1, ownershipSlot))\n                // If `by` is not the zero address, do the authorization check.\n                // Revert if the `by` is not the owner, nor approved.\n                if iszero(or(iszero(by), or(eq(by, owner), eq(by, approvedAddress)))) {\n                    if iszero(sload(keccak256(0x0c, 0x30))) {\n                        mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.\n                        revert(0x1c, 0x04)\n                    }\n                }\n                // Delete the approved address if any.\n                if approvedAddress { sstore(add(1, ownershipSlot), 0) }\n            }\n            // Clear the owner.\n            sstore(ownershipSlot, xor(ownershipPacked, owner))\n            // Decrement the balance of `owner`.\n            {\n                let balanceSlot := keccak256(0x0c, 0x1c)\n                sstore(balanceSlot, sub(sload(balanceSlot), 1))\n            }\n            // Emit the {Transfer} event.\n            log4(codesize(), 0x00, _TRANSFER_EVENT_SIGNATURE, owner, 0, id)\n        }\n        _afterTokenTransfer(owner, address(0), id);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                INTERNAL APPROVAL FUNCTIONS                 */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns whether `account` is the owner of token `id`, or is approved to manage it.\n    ///\n    /// Requirements:\n    /// - Token `id` must exist.\n    function _isApprovedOrOwner(address account, uint256 id)\n        internal\n        view\n        virtual\n        returns (bool result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := 1\n            // Clear the upper 96 bits.\n            account := shr(96, shl(96, account))\n            // Load the ownership data.\n            mstore(0x00, id)\n            mstore(0x1c, or(_ERC721_MASTER_SLOT_SEED, account))\n            let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))\n            let owner := shr(96, shl(96, sload(ownershipSlot)))\n            // Revert if the token does not exist.\n            if iszero(owner) {\n                mstore(0x00, 0xceea21b6) // `TokenDoesNotExist()`.\n                revert(0x1c, 0x04)\n            }\n            // Check if `account` is the `owner`.\n            if iszero(eq(account, owner)) {\n                mstore(0x00, owner)\n                // Check if `account` is approved to manage the token.\n                if iszero(sload(keccak256(0x0c, 0x30))) {\n                    result := eq(account, sload(add(1, ownershipSlot)))\n                }\n            }\n        }\n    }\n\n    /// @dev Returns the account approved to manage token `id`.\n    /// Returns the zero address instead of reverting if the token does not exist.\n    function _getApproved(uint256 id) internal view virtual returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, id)\n            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\n            result := sload(add(1, add(id, add(id, keccak256(0x00, 0x20)))))\n        }\n    }\n\n    /// @dev Equivalent to `_approve(address(0), account, id)`.\n    function _approve(address account, uint256 id) internal virtual {\n        _approve(address(0), account, id);\n    }\n\n    /// @dev Sets `account` as the approved account to manage token `id`, using `by`.\n    ///\n    /// Requirements:\n    /// - Token `id` must exist.\n    /// - If `by` is not the zero address, `by` must be the owner\n    ///   or an approved operator for the token owner.\n    ///\n    /// Emits a {Approval} event.\n    function _approve(address by, address account, uint256 id) internal virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Clear the upper 96 bits.\n            let bitmaskAddress := shr(96, not(0))\n            account := and(bitmaskAddress, account)\n            by := and(bitmaskAddress, by)\n            // Load the owner of the token.\n            mstore(0x00, id)\n            mstore(0x1c, or(_ERC721_MASTER_SLOT_SEED, by))\n            let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))\n            let owner := and(bitmaskAddress, sload(ownershipSlot))\n            // Revert if the token does not exist.\n            if iszero(owner) {\n                mstore(0x00, 0xceea21b6) // `TokenDoesNotExist()`.\n                revert(0x1c, 0x04)\n            }\n            // If `by` is not the zero address, do the authorization check.\n            // Revert if `by` is not the owner, nor approved.\n            if iszero(or(iszero(by), eq(by, owner))) {\n                mstore(0x00, owner)\n                if iszero(sload(keccak256(0x0c, 0x30))) {\n                    mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            // Sets `account` as the approved account to manage `id`.\n            sstore(add(1, ownershipSlot), account)\n            // Emit the {Approval} event.\n            log4(codesize(), 0x00, _APPROVAL_EVENT_SIGNATURE, owner, account, id)\n        }\n    }\n\n    /// @dev Approve or remove the `operator` as an operator for `by`,\n    /// without authorization checks.\n    ///\n    /// Emits an {ApprovalForAll} event.\n    function _setApprovalForAll(address by, address operator, bool isApproved) internal virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Clear the upper 96 bits.\n            by := shr(96, shl(96, by))\n            operator := shr(96, shl(96, operator))\n            // Convert to 0 or 1.\n            isApproved := iszero(iszero(isApproved))\n            // Update the `isApproved` for (`by`, `operator`).\n            mstore(0x1c, or(_ERC721_MASTER_SLOT_SEED, operator))\n            mstore(0x00, by)\n            sstore(keccak256(0x0c, 0x30), isApproved)\n            // Emit the {ApprovalForAll} event.\n            mstore(0x00, isApproved)\n            log3(0x00, 0x20, _APPROVAL_FOR_ALL_EVENT_SIGNATURE, by, operator)\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                INTERNAL TRANSFER FUNCTIONS                 */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Equivalent to `_transfer(address(0), from, to, id)`.\n    function _transfer(address from, address to, uint256 id) internal virtual {\n        _transfer(address(0), from, to, id);\n    }\n\n    /// @dev Transfers token `id` from `from` to `to`.\n    ///\n    /// Requirements:\n    ///\n    /// - Token `id` must exist.\n    /// - `from` must be the owner of the token.\n    /// - `to` cannot be the zero address.\n    /// - If `by` is not the zero address,\n    ///   it must be the owner of the token, or be approved to manage the token.\n    ///\n    /// Emits a {Transfer} event.\n    function _transfer(address by, address from, address to, uint256 id) internal virtual {\n        _beforeTokenTransfer(from, to, id);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Clear the upper 96 bits.\n            let bitmaskAddress := shr(96, not(0))\n            from := and(bitmaskAddress, from)\n            to := and(bitmaskAddress, to)\n            by := and(bitmaskAddress, by)\n            // Load the ownership data.\n            mstore(0x00, id)\n            mstore(0x1c, or(_ERC721_MASTER_SLOT_SEED, by))\n            let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))\n            let ownershipPacked := sload(ownershipSlot)\n            let owner := and(bitmaskAddress, ownershipPacked)\n            // Revert if the token does not exist, or if `from` is not the owner.\n            if iszero(mul(owner, eq(owner, from))) {\n                // `TokenDoesNotExist()`, `TransferFromIncorrectOwner()`.\n                mstore(shl(2, iszero(owner)), 0xceea21b6a1148100)\n                revert(0x1c, 0x04)\n            }\n            // Load, check, and update the token approval.\n            {\n                mstore(0x00, from)\n                let approvedAddress := sload(add(1, ownershipSlot))\n                // If `by` is not the zero address, do the authorization check.\n                // Revert if the `by` is not the owner, nor approved.\n                if iszero(or(iszero(by), or(eq(by, from), eq(by, approvedAddress)))) {\n                    if iszero(sload(keccak256(0x0c, 0x30))) {\n                        mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.\n                        revert(0x1c, 0x04)\n                    }\n                }\n                // Delete the approved address if any.\n                if approvedAddress { sstore(add(1, ownershipSlot), 0) }\n            }\n            // Update with the new owner.\n            sstore(ownershipSlot, xor(ownershipPacked, xor(from, to)))\n            // Decrement the balance of `from`.\n            {\n                let fromBalanceSlot := keccak256(0x0c, 0x1c)\n                sstore(fromBalanceSlot, sub(sload(fromBalanceSlot), 1))\n            }\n            // Increment the balance of `to`.\n            {\n                mstore(0x00, to)\n                let toBalanceSlot := keccak256(0x0c, 0x1c)\n                let toBalanceSlotPacked := add(sload(toBalanceSlot), 1)\n                // Revert if `to` is the zero address, or if the account balance overflows.\n                if iszero(mul(to, and(toBalanceSlotPacked, _MAX_ACCOUNT_BALANCE))) {\n                    // `TransferToZeroAddress()`, `AccountBalanceOverflow()`.\n                    mstore(shl(2, iszero(to)), 0xea553b3401336cea)\n                    revert(0x1c, 0x04)\n                }\n                sstore(toBalanceSlot, toBalanceSlotPacked)\n            }\n            // Emit the {Transfer} event.\n            log4(codesize(), 0x00, _TRANSFER_EVENT_SIGNATURE, from, to, id)\n        }\n        _afterTokenTransfer(from, to, id);\n    }\n\n    /// @dev Equivalent to `_safeTransfer(from, to, id, \"\")`.\n    function _safeTransfer(address from, address to, uint256 id) internal virtual {\n        _safeTransfer(from, to, id, \"\");\n    }\n\n    /// @dev Transfers token `id` from `from` to `to`.\n    ///\n    /// Requirements:\n    ///\n    /// - Token `id` must exist.\n    /// - `from` must be the owner of the token.\n    /// - `to` cannot be the zero address.\n    /// - The caller must be the owner of the token, or be approved to manage the token.\n    /// - If `to` refers to a smart contract, it must implement\n    ///   {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n    ///\n    /// Emits a {Transfer} event.\n    function _safeTransfer(address from, address to, uint256 id, bytes memory data)\n        internal\n        virtual\n    {\n        _transfer(address(0), from, to, id);\n        if (_hasCode(to)) _checkOnERC721Received(from, to, id, data);\n    }\n\n    /// @dev Equivalent to `_safeTransfer(by, from, to, id, \"\")`.\n    function _safeTransfer(address by, address from, address to, uint256 id) internal virtual {\n        _safeTransfer(by, from, to, id, \"\");\n    }\n\n    /// @dev Transfers token `id` from `from` to `to`.\n    ///\n    /// Requirements:\n    ///\n    /// - Token `id` must exist.\n    /// - `from` must be the owner of the token.\n    /// - `to` cannot be the zero address.\n    /// - If `by` is not the zero address,\n    ///   it must be the owner of the token, or be approved to manage the token.\n    /// - If `to` refers to a smart contract, it must implement\n    ///   {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n    ///\n    /// Emits a {Transfer} event.\n    function _safeTransfer(address by, address from, address to, uint256 id, bytes memory data)\n        internal\n        virtual\n    {\n        _transfer(by, from, to, id);\n        if (_hasCode(to)) _checkOnERC721Received(from, to, id, data);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                    HOOKS FOR OVERRIDING                    */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Hook that is called before any token transfers, including minting and burning.\n    function _beforeTokenTransfer(address from, address to, uint256 id) internal virtual {}\n\n    /// @dev Hook that is called after any token transfers, including minting and burning.\n    function _afterTokenTransfer(address from, address to, uint256 id) internal virtual {}\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      PRIVATE HELPERS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns if `a` has bytecode of non-zero length.\n    function _hasCode(address a) private view returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := extcodesize(a) // Can handle dirty upper bits.\n        }\n    }\n\n    /// @dev Perform a call to invoke {IERC721Receiver-onERC721Received} on `to`.\n    /// Reverts if the target does not support the function correctly.\n    function _checkOnERC721Received(address from, address to, uint256 id, bytes memory data)\n        private\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Prepare the calldata.\n            let m := mload(0x40)\n            let onERC721ReceivedSelector := 0x150b7a02\n            mstore(m, onERC721ReceivedSelector)\n            mstore(add(m, 0x20), caller()) // The `operator`, which is always `msg.sender`.\n            mstore(add(m, 0x40), shr(96, shl(96, from)))\n            mstore(add(m, 0x60), id)\n            mstore(add(m, 0x80), 0x80)\n            let n := mload(data)\n            mstore(add(m, 0xa0), n)\n            if n { pop(staticcall(gas(), 4, add(data, 0x20), n, add(m, 0xc0), n)) }\n            // Revert if the call reverts.\n            if iszero(call(gas(), to, 0, add(m, 0x1c), add(n, 0xa4), m, 0x20)) {\n                if returndatasize() {\n                    // Bubble up the revert if the call reverts.\n                    returndatacopy(m, 0x00, returndatasize())\n                    revert(m, returndatasize())\n                }\n            }\n            // Load the returndata and compare it.\n            if iszero(eq(mload(m), shl(224, onERC721ReceivedSelector))) {\n                mstore(0x00, 0xd1a57ed6) // `TransferToNonERC721ReceiverImplementer()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n}\n"
    },
    "https://raw.githubusercontent.com/Vectorized/solady/main/src/auth/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Simple single owner authorization mixin.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/auth/Ownable.sol)\n///\n/// @dev Note:\n/// This implementation does NOT auto-initialize the owner to `msg.sender`.\n/// You MUST call the `_initializeOwner` in the constructor / initializer.\n///\n/// While the ownable portion follows\n/// [EIP-173](https://eips.ethereum.org/EIPS/eip-173) for compatibility,\n/// the nomenclature for the 2-step ownership handover may be unique to this codebase.\nabstract contract Ownable {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The caller is not authorized to call the function.\n    error Unauthorized();\n\n    /// @dev The `newOwner` cannot be the zero address.\n    error NewOwnerIsZeroAddress();\n\n    /// @dev The `pendingOwner` does not have a valid handover request.\n    error NoHandoverRequest();\n\n    /// @dev Cannot double-initialize.\n    error AlreadyInitialized();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                           EVENTS                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The ownership is transferred from `oldOwner` to `newOwner`.\n    /// This event is intentionally kept the same as OpenZeppelin's Ownable to be\n    /// compatible with indexers and [EIP-173](https://eips.ethereum.org/EIPS/eip-173),\n    /// despite it not being as lightweight as a single argument event.\n    event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);\n\n    /// @dev An ownership handover to `pendingOwner` has been requested.\n    event OwnershipHandoverRequested(address indexed pendingOwner);\n\n    /// @dev The ownership handover to `pendingOwner` has been canceled.\n    event OwnershipHandoverCanceled(address indexed pendingOwner);\n\n    /// @dev `keccak256(bytes(\"OwnershipTransferred(address,address)\"))`.\n    uint256 private constant _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE =\n        0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0;\n\n    /// @dev `keccak256(bytes(\"OwnershipHandoverRequested(address)\"))`.\n    uint256 private constant _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE =\n        0xdbf36a107da19e49527a7176a1babf963b4b0ff8cde35ee35d6cd8f1f9ac7e1d;\n\n    /// @dev `keccak256(bytes(\"OwnershipHandoverCanceled(address)\"))`.\n    uint256 private constant _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE =\n        0xfa7b8eab7da67f412cc9575ed43464468f9bfbae89d1675917346ca6d8fe3c92;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                          STORAGE                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The owner slot is given by:\n    /// `bytes32(~uint256(uint32(bytes4(keccak256(\"_OWNER_SLOT_NOT\")))))`.\n    /// It is intentionally chosen to be a high value\n    /// to avoid collision with lower slots.\n    /// The choice of manual storage layout is to enable compatibility\n    /// with both regular and upgradeable contracts.\n    bytes32 internal constant _OWNER_SLOT =\n        0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff74873927;\n\n    /// The ownership handover slot of `newOwner` is given by:\n    /// ```\n    ///     mstore(0x00, or(shl(96, user), _HANDOVER_SLOT_SEED))\n    ///     let handoverSlot := keccak256(0x00, 0x20)\n    /// ```\n    /// It stores the expiry timestamp of the two-step ownership handover.\n    uint256 private constant _HANDOVER_SLOT_SEED = 0x389a75e1;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                     INTERNAL FUNCTIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Override to return true to make `_initializeOwner` prevent double-initialization.\n    function _guardInitializeOwner() internal pure virtual returns (bool guard) {}\n\n    /// @dev Initializes the owner directly without authorization guard.\n    /// This function must be called upon initialization,\n    /// regardless of whether the contract is upgradeable or not.\n    /// This is to enable generalization to both regular and upgradeable contracts,\n    /// and to save gas in case the initial owner is not the caller.\n    /// For performance reasons, this function will not check if there\n    /// is an existing owner.\n    function _initializeOwner(address newOwner) internal virtual {\n        if (_guardInitializeOwner()) {\n            /// @solidity memory-safe-assembly\n            assembly {\n                let ownerSlot := _OWNER_SLOT\n                if sload(ownerSlot) {\n                    mstore(0x00, 0x0dc149f0) // `AlreadyInitialized()`.\n                    revert(0x1c, 0x04)\n                }\n                // Clean the upper 96 bits.\n                newOwner := shr(96, shl(96, newOwner))\n                // Store the new value.\n                sstore(ownerSlot, or(newOwner, shl(255, iszero(newOwner))))\n                // Emit the {OwnershipTransferred} event.\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, 0, newOwner)\n            }\n        } else {\n            /// @solidity memory-safe-assembly\n            assembly {\n                // Clean the upper 96 bits.\n                newOwner := shr(96, shl(96, newOwner))\n                // Store the new value.\n                sstore(_OWNER_SLOT, newOwner)\n                // Emit the {OwnershipTransferred} event.\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, 0, newOwner)\n            }\n        }\n    }\n\n    /// @dev Sets the owner directly without authorization guard.\n    function _setOwner(address newOwner) internal virtual {\n        if (_guardInitializeOwner()) {\n            /// @solidity memory-safe-assembly\n            assembly {\n                let ownerSlot := _OWNER_SLOT\n                // Clean the upper 96 bits.\n                newOwner := shr(96, shl(96, newOwner))\n                // Emit the {OwnershipTransferred} event.\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, sload(ownerSlot), newOwner)\n                // Store the new value.\n                sstore(ownerSlot, or(newOwner, shl(255, iszero(newOwner))))\n            }\n        } else {\n            /// @solidity memory-safe-assembly\n            assembly {\n                let ownerSlot := _OWNER_SLOT\n                // Clean the upper 96 bits.\n                newOwner := shr(96, shl(96, newOwner))\n                // Emit the {OwnershipTransferred} event.\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, sload(ownerSlot), newOwner)\n                // Store the new value.\n                sstore(ownerSlot, newOwner)\n            }\n        }\n    }\n\n    /// @dev Throws if the sender is not the owner.\n    function _checkOwner() internal view virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // If the caller is not the stored owner, revert.\n            if iszero(eq(caller(), sload(_OWNER_SLOT))) {\n                mstore(0x00, 0x82b42900) // `Unauthorized()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Returns how long a two-step ownership handover is valid for in seconds.\n    /// Override to return a different value if needed.\n    /// Made internal to conserve bytecode. Wrap it in a public function if needed.\n    function _ownershipHandoverValidFor() internal view virtual returns (uint64) {\n        return 48 * 3600;\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                  PUBLIC UPDATE FUNCTIONS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Allows the owner to transfer the ownership to `newOwner`.\n    function transferOwnership(address newOwner) public payable virtual onlyOwner {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(shl(96, newOwner)) {\n                mstore(0x00, 0x7448fbae) // `NewOwnerIsZeroAddress()`.\n                revert(0x1c, 0x04)\n            }\n        }\n        _setOwner(newOwner);\n    }\n\n    /// @dev Allows the owner to renounce their ownership.\n    function renounceOwnership() public payable virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /// @dev Request a two-step ownership handover to the caller.\n    /// The request will automatically expire in 48 hours (172800 seconds) by default.\n    function requestOwnershipHandover() public payable virtual {\n        unchecked {\n            uint256 expires = block.timestamp + _ownershipHandoverValidFor();\n            /// @solidity memory-safe-assembly\n            assembly {\n                // Compute and set the handover slot to `expires`.\n                mstore(0x0c, _HANDOVER_SLOT_SEED)\n                mstore(0x00, caller())\n                sstore(keccak256(0x0c, 0x20), expires)\n                // Emit the {OwnershipHandoverRequested} event.\n                log2(0, 0, _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE, caller())\n            }\n        }\n    }\n\n    /// @dev Cancels the two-step ownership handover to the caller, if any.\n    function cancelOwnershipHandover() public payable virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute and set the handover slot to 0.\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\n            mstore(0x00, caller())\n            sstore(keccak256(0x0c, 0x20), 0)\n            // Emit the {OwnershipHandoverCanceled} event.\n            log2(0, 0, _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE, caller())\n        }\n    }\n\n    /// @dev Allows the owner to complete the two-step ownership handover to `pendingOwner`.\n    /// Reverts if there is no existing ownership handover requested by `pendingOwner`.\n    function completeOwnershipHandover(address pendingOwner) public payable virtual onlyOwner {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute and set the handover slot to 0.\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\n            mstore(0x00, pendingOwner)\n            let handoverSlot := keccak256(0x0c, 0x20)\n            // If the handover does not exist, or has expired.\n            if gt(timestamp(), sload(handoverSlot)) {\n                mstore(0x00, 0x6f5e8818) // `NoHandoverRequest()`.\n                revert(0x1c, 0x04)\n            }\n            // Set the handover slot to 0.\n            sstore(handoverSlot, 0)\n        }\n        _setOwner(pendingOwner);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   PUBLIC READ FUNCTIONS                    */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the owner of the contract.\n    function owner() public view virtual returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := sload(_OWNER_SLOT)\n        }\n    }\n\n    /// @dev Returns the expiry timestamp for the two-step ownership handover to `pendingOwner`.\n    function ownershipHandoverExpiresAt(address pendingOwner)\n        public\n        view\n        virtual\n        returns (uint256 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the handover slot.\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\n            mstore(0x00, pendingOwner)\n            // Load the handover slot.\n            result := sload(keccak256(0x0c, 0x20))\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         MODIFIERS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Marks a function as only callable by the owner.\n    modifier onlyOwner() virtual {\n        _checkOwner();\n        _;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    },
    "remappings": []
  }
}}