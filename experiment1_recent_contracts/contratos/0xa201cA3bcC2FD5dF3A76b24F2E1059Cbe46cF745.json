{{
  "language": "Solidity",
  "sources": {
    "@automata-network/dcap-attestation/contracts/bases/EnclaveIdBase.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {\n    IdentityObj,\n    EnclaveId,\n    Tcb,\n    EnclaveIdTcbStatus\n} from \"@automata-network/on-chain-pccs/helpers/EnclaveIdentityHelper.sol\";\n\nabstract contract EnclaveIdBase {\n    /// @dev https://github.com/intel/SGX-TDX-DCAP-QuoteVerificationLibrary/blob/16b7291a7a86e486fdfcf1dfb4be885c0cc00b4e/Src/AttestationLibrary/src/Verifiers/EnclaveReportVerifier.cpp#L47-L113\n    function verifyQEReportWithIdentity(\n        IdentityObj memory identity,\n        bytes4 enclaveReportMiscselect,\n        bytes16 enclaveReportAttributes,\n        bytes32 enclaveReportMrsigner,\n        uint16 enclaveReportIsvprodid,\n        uint16 enclaveReportIsvSvn\n    ) internal pure returns (bool, EnclaveIdTcbStatus status) {\n        bool miscselectMatched = enclaveReportMiscselect & identity.miscselectMask == identity.miscselect;\n        bool attributesMatched = enclaveReportAttributes & identity.attributesMask == identity.attributes;\n        bool mrsignerMatched = enclaveReportMrsigner == identity.mrsigner;\n        bool isvprodidMatched = enclaveReportIsvprodid == identity.isvprodid;\n\n        bool tcbFound;\n        for (uint256 i = 0; i < identity.tcb.length; i++) {\n            if (identity.tcb[i].isvsvn <= enclaveReportIsvSvn) {\n                tcbFound = true;\n                status = identity.tcb[i].status;\n                break;\n            }\n        }\n        return (miscselectMatched && attributesMatched && mrsignerMatched && isvprodidMatched && tcbFound, status);\n    }\n}\n"
    },
    "@automata-network/dcap-attestation/contracts/bases/QuoteVerifierBase.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {TCBStatus} from \"@automata-network/on-chain-pccs/helpers/FmspcTcbHelper.sol\";\n\nimport {IQuoteVerifier, IPCCSRouter} from \"../interfaces/IQuoteVerifier.sol\";\nimport {BytesUtils} from \"../utils/BytesUtils.sol\";\nimport {BELE} from \"../utils/BELE.sol\";\nimport {P256Verifier} from \"../utils/P256Verifier.sol\";\n\nimport {Header, EnclaveReport, Output} from \"../types/CommonStruct.sol\";\nimport \"../types/Constants.sol\";\n\nimport \"./EnclaveIdBase.sol\";\nimport \"./X509ChainBase.sol\";\n\nabstract contract QuoteVerifierBase is IQuoteVerifier, EnclaveIdBase, X509ChainBase {\n    using BytesUtils for bytes;\n\n    IPCCSRouter public immutable override pccsRouter;\n    uint16 public immutable override quoteVersion;\n\n    constructor(address _router, uint16 _version) {\n        pccsRouter = IPCCSRouter(_router);\n        quoteVersion = _version;\n    }\n\n    function validateHeader(Header calldata header, uint256 quoteLength, bool teeIsValid)\n        internal\n        view\n        returns (bool valid, string memory reason)\n    {\n        if (quoteLength < MINIMUM_QUOTE_LENGTH) {\n            return (false, \"Quote length is less than minimum\");\n        }\n\n        if (header.version != quoteVersion) {\n            return (false, \"Version mismatch\");\n        }\n\n        if (header.attestationKeyType != SUPPORTED_ATTESTATION_KEY_TYPE) {\n            return (false, \"Unsupported attestation key type\");\n        }\n\n        if (!teeIsValid) {\n            return (false, \"Unknown TEE type\");\n        }\n\n        if (header.qeVendorId != VALID_QE_VENDOR_ID) {\n            return (false, \"Not a valid Intel SGX QE Vendor ID\");\n        }\n\n        valid = true;\n    }\n\n    function parseEnclaveReport(bytes memory rawEnclaveReport)\n        internal\n        pure\n        returns (bool success, EnclaveReport memory enclaveReport)\n    {\n        if (rawEnclaveReport.length != ENCLAVE_REPORT_LENGTH) {\n            return (false, enclaveReport);\n        }\n        enclaveReport.cpuSvn = bytes16(rawEnclaveReport.substring(0, 16));\n        enclaveReport.miscSelect = bytes4(rawEnclaveReport.substring(16, 4));\n        enclaveReport.reserved1 = bytes28(rawEnclaveReport.substring(20, 28));\n        enclaveReport.attributes = bytes16(rawEnclaveReport.substring(48, 16));\n        enclaveReport.mrEnclave = bytes32(rawEnclaveReport.substring(64, 32));\n        enclaveReport.reserved2 = bytes32(rawEnclaveReport.substring(96, 32));\n        enclaveReport.mrSigner = bytes32(rawEnclaveReport.substring(128, 32));\n        enclaveReport.reserved3 = rawEnclaveReport.substring(160, 96);\n        enclaveReport.isvProdId = uint16(BELE.leBytesToBeUint(rawEnclaveReport.substring(256, 2)));\n        enclaveReport.isvSvn = uint16(BELE.leBytesToBeUint(rawEnclaveReport.substring(258, 2)));\n        enclaveReport.reserved4 = rawEnclaveReport.substring(260, 60);\n        enclaveReport.reportData = rawEnclaveReport.substring(320, 64);\n        success = true;\n    }\n\n    function fetchQeIdentityAndCheckQeReport(EnclaveId id, EnclaveReport memory qeReport)\n        internal\n        view\n        returns (bool success, EnclaveIdTcbStatus qeTcbStatus)\n    {\n        IdentityObj memory qeIdentity;\n        (success, qeIdentity) = pccsRouter.getQeIdentity(id, quoteVersion);\n        if (!success) {\n            return (success, EnclaveIdTcbStatus.SGX_ENCLAVE_REPORT_ISVSVN_NOT_SUPPORTED);\n        }\n        (success, qeTcbStatus) = verifyQEReportWithIdentity(\n            qeIdentity, qeReport.miscSelect, qeReport.attributes, qeReport.mrSigner, qeReport.isvProdId, qeReport.isvSvn\n        );\n    }\n\n    function verifyQeReportData(bytes memory qeReportData, bytes memory attestationKey, bytes memory qeAuthData)\n        internal\n        pure\n        returns (bool)\n    {\n        bytes32 expectedHash = bytes32(qeReportData);\n        bytes memory preimage = abi.encodePacked(attestationKey, qeAuthData);\n        bytes32 computedHash = sha256(preimage);\n        return expectedHash == computedHash;\n    }\n\n    function attestationVerification(\n        bytes memory rawQeReport,\n        bytes memory qeSignature,\n        bytes memory pckPubkey,\n        bytes memory signedAttestationData,\n        bytes memory attestationSignature,\n        bytes memory attestationKey\n    ) internal view returns (bool) {\n        bool qeReportVerified = P256Verifier.ecdsaVerify(sha256(rawQeReport), qeSignature, pckPubkey);\n        if (!qeReportVerified) {\n            return false;\n        }\n        bool attestationVerified =\n            P256Verifier.ecdsaVerify(sha256(signedAttestationData), attestationSignature, attestationKey);\n        return attestationVerified;\n    }\n\n    function convergeTcbStatusWithQeTcbStatus(EnclaveIdTcbStatus qeTcbStatus, TCBStatus tcbStatus)\n        internal\n        pure\n        returns (TCBStatus convergedStatus)\n    {\n        // https://github.com/intel/SGX-TDX-DCAP-QuoteVerificationLibrary/blob/16b7291a7a86e486fdfcf1dfb4be885c0cc00b4e/Src/AttestationLibrary/src/Verifiers/QuoteVerifier.cpp#L271-L312\n        if (qeTcbStatus == EnclaveIdTcbStatus.SGX_ENCLAVE_REPORT_ISVSVN_OUT_OF_DATE) {\n            if (tcbStatus == TCBStatus.OK || tcbStatus == TCBStatus.TCB_SW_HARDENING_NEEDED) {\n                convergedStatus = TCBStatus.TCB_OUT_OF_DATE;\n            }\n            if (\n                tcbStatus == TCBStatus.TCB_CONFIGURATION_NEEDED\n                    || tcbStatus == TCBStatus.TCB_CONFIGURATION_AND_SW_HARDENING_NEEDED\n            ) {\n                convergedStatus = TCBStatus.TCB_OUT_OF_DATE_CONFIGURATION_NEEDED;\n            }\n        } else {\n            convergedStatus = tcbStatus;\n        }\n    }\n\n    function serializeOutput(Output memory output) internal pure returns (bytes memory) {\n        return abi.encodePacked(output.quoteVersion, output.tee, output.tcbStatus, output.fmspcBytes, output.quoteBody, abi.encode(output.advisoryIDs));\n    }\n\n    function checkCollateralHashes(uint256 offset, bytes calldata journal) internal view returns (bool) {\n        bytes32 rootCaHash = bytes32(journal[offset:offset + 32]);\n        bytes32 tcbSigningHash = bytes32(journal[offset + 32:offset + 64]);\n        bytes32 rootCaCrlHash = bytes32(journal[offset + 64:offset + 96]);\n        bytes32 pckCrlHash = bytes32(journal[offset + 96:offset + 128]);\n\n        (bool tcbSigningFound, bytes32 expectedTcbSigningHash) = pccsRouter.getCertHash(CA.SIGNING);\n        if (!tcbSigningFound || tcbSigningHash != expectedTcbSigningHash) {\n            return false;\n        }\n        (bool rootCaFound, bytes32 expectedRootCaHash) = pccsRouter.getCertHash(CA.ROOT);\n        if (!rootCaFound || rootCaHash != expectedRootCaHash) {\n            return false;\n        }\n        (bool rootCrlFound, bytes32 expectedRootCrlHash) = pccsRouter.getCrlHash(CA.ROOT);\n        if (!rootCrlFound || rootCaCrlHash != expectedRootCrlHash) {\n            return false;\n        }\n\n        // use low level calls for PCK CRLs, because we don't know which one of the CAs is used\n        // to verify the quote\n        // we can catch reverts here, and consider it a valid quote as long as:\n        // - one of the PCK CAs has a CRL stored on-chain\n        // - the hash of the on-chain CRL matches with the CRL hash in the journal\n\n        (bool platformSuccess, bytes memory platformRet) =\n            address(pccsRouter).staticcall(abi.encodeWithSelector(IPCCSRouter.getCrlHash.selector, CA.PLATFORM));\n\n        (bool processorSuccess, bytes memory processorRet) =\n            address(pccsRouter).staticcall(abi.encodeWithSelector(IPCCSRouter.getCrlHash.selector, CA.PROCESSOR));\n\n        bytes32 expectedPlatformCrlHash;\n        bytes32 expectedProcessorCrlHash;\n        if (platformSuccess) {\n            (, expectedPlatformCrlHash) = abi.decode(platformRet, (bool, bytes32));\n        } else if (processorSuccess) {\n            (, expectedProcessorCrlHash) = abi.decode(processorRet, (bool, bytes32));\n        } else {\n            // Both Processor and Platform PCKs not found\n            return false;\n        }\n\n        return pckCrlHash == expectedPlatformCrlHash || pckCrlHash == expectedProcessorCrlHash;\n    }\n}\n"
    },
    "@automata-network/dcap-attestation/contracts/bases/tcb/TCBInfoV2Base.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {TCBLevelsObj, TCBStatus} from \"@automata-network/on-chain-pccs/helpers/FmspcTcbHelper.sol\";\nimport {EnclaveIdTcbStatus} from \"@automata-network/on-chain-pccs/helpers/EnclaveIdentityHelper.sol\";\nimport {LibString} from \"solady/utils/LibString.sol\";\nimport {PCKCertTCB} from \"../../types/CommonStruct.sol\";\n\nabstract contract TCBInfoV2Base {\n    using LibString for string;\n\n    // https://github.com/intel/SGXDataCenterAttestationPrimitives/blob/e7604e02331b3377f3766ed3653250e03af72d45/QuoteVerification/QVL/Src/AttestationLibrary/src/CertVerification/X509Constants.h#L64\n    uint256 internal constant CPUSVN_LENGTH = 16;\n\n    function getSGXTcbStatus(PCKCertTCB memory pckTcb, TCBLevelsObj memory current)\n        internal\n        pure\n        returns (bool, TCBStatus status)\n    {\n        bool pceSvnIsHigherOrGreater;\n        bool cpuSvnsAreHigherOrGreater;\n        (pceSvnIsHigherOrGreater, cpuSvnsAreHigherOrGreater) = _checkSgxCpuSvns(pckTcb, current);\n        status = current.status;\n        bool statusFound = pceSvnIsHigherOrGreater && cpuSvnsAreHigherOrGreater;\n        return (statusFound, statusFound ? status : TCBStatus.TCB_UNRECOGNIZED);\n    }\n\n    function _checkSgxCpuSvns(PCKCertTCB memory pckTcb, TCBLevelsObj memory tcbLevel)\n        internal\n        pure\n        returns (bool, bool)\n    {\n        bool pceSvnIsHigherOrGreater = pckTcb.pcesvn >= tcbLevel.pcesvn;\n        bool cpuSvnsAreHigherOrGreater = _isCpuSvnHigherOrGreater(pckTcb.cpusvns, tcbLevel.sgxComponentCpuSvns);\n        return (pceSvnIsHigherOrGreater, cpuSvnsAreHigherOrGreater);\n    }\n\n    function _isCpuSvnHigherOrGreater(uint8[] memory pckCpuSvns, uint8[] memory tcbCpuSvns)\n        internal\n        pure\n        returns (bool)\n    {\n        if (pckCpuSvns.length != CPUSVN_LENGTH || tcbCpuSvns.length != CPUSVN_LENGTH) {\n            return false;\n        }\n        for (uint256 i = 0; i < CPUSVN_LENGTH; i++) {\n            if (uint256(pckCpuSvns[i]) < tcbCpuSvns[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n"
    },
    "@automata-network/dcap-attestation/contracts/bases/X509ChainBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {BytesUtils, P256Verifier} from \"../utils/P256Verifier.sol\";\nimport {PCKCollateral, PCKCertTCB} from \"../types/CommonStruct.sol\";\nimport {IPCCSRouter} from \"../interfaces/IPCCSRouter.sol\";\n\nimport {LibString} from \"solady/utils/LibString.sol\";\nimport {Base64} from \"solady/utils/Base64.sol\";\nimport {PCKHelper, X509CertObj} from \"@automata-network/on-chain-pccs/helpers/PCKHelper.sol\";\nimport {X509CRLHelper} from \"@automata-network/on-chain-pccs/helpers/X509CRLHelper.sol\";\nimport {CA} from \"@automata-network/on-chain-pccs/Common.sol\";\n\nabstract contract X509ChainBase is P256Verifier {\n    using BytesUtils for bytes;\n    using LibString for bytes;\n\n    string constant PLATFORM_ISSUER_NAME = \"Intel SGX PCK Platform CA\";\n    string constant PROCESSOR_ISSUER_NAME = \"Intel SGX PCK Processor CA\";\n\n    // keccak256(hex\"0ba9c4c0c0c86193a3fe23d6b02cda10a8bbd4e88e48b4458561a36e705525f567918e2edc88e40d860bd0cc4ee26aacc988e505a953558c453f6b0904ae7394\")\n    // the uncompressed (0x04) prefix is not included in the pubkey pre-image\n    bytes32 constant ROOTCA_PUBKEY_HASH = 0x89f72d7c488e5b53a77c23ebcb36970ef7eb5bcf6658e9b8292cfbe4703a8473;\n\n    // === PEM PARSER CONSTANTS ===\n    string constant X509_HEADER = \"-----BEGIN CERTIFICATE-----\";\n    string constant X509_FOOTER = \"-----END CERTIFICATE-----\";\n    uint256 constant X509_HEADER_LENGTH = 27;\n    uint256 constant X509_FOOTER_LENGTH = 25;\n\n    function getPckCollateral(address pckHelperAddr, uint16 certType, bytes memory rawCertData)\n        internal\n        pure\n        returns (bool success, PCKCollateral memory pck)\n    {\n        pck.pckChain = new X509CertObj[](3);\n\n        if (certType == 5) {\n            bytes[] memory certArray;\n            (success, certArray) = _splitCertificateChain(rawCertData, 3);\n            if (!success) {\n                return (false, pck);\n            }\n            (pck.pckChain[0], pck.pckExtension) = _parsePck(pckHelperAddr, certArray[0]);\n\n            bytes[] memory issuerChain = new bytes[](certArray.length - 1);\n            for (uint256 a = 0; a < issuerChain.length; a++) {\n                issuerChain[a] = certArray[a + 1];\n            }\n\n            X509CertObj[] memory parsedIssuerChain = _parsePckIssuer(pckHelperAddr, issuerChain);\n            for (uint256 i = 0; i < parsedIssuerChain.length; i++) {\n                pck.pckChain[i + 1] = parsedIssuerChain[i];\n            }\n        } else {\n            return (false, pck);\n        }\n    }\n\n    function verifyCertChain(IPCCSRouter pccsRouter, address crlHelperAddr, X509CertObj[] memory certs)\n        internal\n        view\n        returns (bool)\n    {\n        X509CRLHelper crlHelper = X509CRLHelper(crlHelperAddr);\n        uint256 n = certs.length;\n        bool certRevoked;\n        bool certNotExpired;\n        bool verified;\n        bool certChainCanBeTrusted;\n        for (uint256 i = 0; i < n; i++) {\n            X509CertObj memory issuer;\n            if (i == n - 1) {\n                // rootCA\n                issuer = certs[i];\n            } else {\n                issuer = certs[i + 1];\n                bytes memory crl;\n                if (i == n - 2) {\n                    (, crl) = pccsRouter.getCrl(CA.ROOT);\n                } else if (i == 0) {\n                    string memory issuerName = certs[i].issuerCommonName;\n                    if (LibString.eq(issuerName, PLATFORM_ISSUER_NAME)) {\n                        (, crl) = pccsRouter.getCrl(CA.PLATFORM);\n                    } else if (LibString.eq(issuerName, PROCESSOR_ISSUER_NAME)) {\n                        (, crl) = pccsRouter.getCrl(CA.PROCESSOR);\n                    } else {\n                        return false;\n                    }\n                }\n                if (crl.length > 0) {\n                    certRevoked = crlHelper.serialNumberIsRevoked(certs[i].serialNumber, crl);\n                }\n                if (certRevoked) {\n                    break;\n                }\n            }\n\n            certNotExpired = block.timestamp > certs[i].validityNotBefore && block.timestamp < certs[i].validityNotAfter;\n            if (!certNotExpired) {\n                break;\n            }\n\n            {\n                verified = ecdsaVerify(sha256(certs[i].tbs), certs[i].signature, issuer.subjectPublicKey);\n                if (!verified) {\n                    break;\n                }\n            }\n\n            bytes32 issuerPubKeyHash = keccak256(issuer.subjectPublicKey);\n\n            if (issuerPubKeyHash == ROOTCA_PUBKEY_HASH) {\n                certChainCanBeTrusted = true;\n                break;\n            }\n        }\n        return !certRevoked && certNotExpired && verified && certChainCanBeTrusted;\n    }\n\n    function _parsePck(address pckHelperAddr, bytes memory pckDer)\n        private\n        pure\n        returns (X509CertObj memory pck, PCKCertTCB memory extension)\n    {\n        PCKHelper pckHelper = PCKHelper(pckHelperAddr);\n        pck = pckHelper.parseX509DER(pckDer);\n        (extension.pcesvn, extension.cpusvns, extension.fmspcBytes, extension.pceidBytes) =\n            pckHelper.parsePckExtension(pckDer, pck.extensionPtr);\n    }\n\n    function _parsePckIssuer(address pckHelperAddr, bytes[] memory issuerChain)\n        private\n        pure\n        returns (X509CertObj[] memory chain)\n    {\n        PCKHelper pckHelper = PCKHelper(pckHelperAddr);\n        uint256 n = issuerChain.length;\n        chain = new X509CertObj[](n);\n        for (uint256 i = 0; i < n; i++) {\n            chain[i] = pckHelper.parseX509DER(issuerChain[i]);\n        }\n    }\n\n    function _splitCertificateChain(bytes memory pemChain, uint256 size)\n        private\n        pure\n        returns (bool success, bytes[] memory certs)\n    {\n        certs = new bytes[](size);\n        string memory pemChainStr = string(pemChain);\n\n        uint256 index = 0;\n        uint256 len = pemChain.length;\n\n        for (uint256 i = 0; i < size; i++) {\n            string memory input;\n            if (i > 0) {\n                input = LibString.slice(pemChainStr, index, index + len);\n            } else {\n                input = pemChainStr;\n            }\n            uint256 increment;\n            (success, certs[i], increment) = _removeHeadersAndFooters(input);\n            certs[i] = Base64.decode(string(certs[i]));\n\n            if (!success) {\n                return (false, certs);\n            }\n\n            index += increment;\n        }\n\n        success = true;\n    }\n\n    function _removeHeadersAndFooters(string memory pemData)\n        private\n        pure\n        returns (bool success, bytes memory extracted, uint256 endIndex)\n    {\n        // Check if the input contains the \"BEGIN\" and \"END\" headers\n        uint256 beginPos = LibString.indexOf(pemData, X509_HEADER);\n        uint256 endPos = LibString.indexOf(pemData, X509_FOOTER);\n\n        bool headerFound = beginPos != LibString.NOT_FOUND;\n        bool footerFound = endPos != LibString.NOT_FOUND;\n\n        if (!headerFound || !footerFound) {\n            return (false, extracted, endIndex);\n        }\n\n        // Extract the content between the headers\n        uint256 contentStart = beginPos + X509_HEADER_LENGTH;\n\n        // Extract and return the content\n        bytes memory contentBytes;\n\n        // do not include newline\n        bytes memory delimiter = hex\"0a\";\n        string memory contentSlice = LibString.slice(pemData, contentStart, endPos);\n        string[] memory split = LibString.split(contentSlice, string(delimiter));\n        string memory contentStr;\n\n        for (uint256 i = 0; i < split.length; i++) {\n            contentStr = LibString.concat(contentStr, split[i]);\n        }\n\n        contentBytes = bytes(contentStr);\n        return (true, contentBytes, endPos + X509_FOOTER_LENGTH);\n    }\n}\n"
    },
    "@automata-network/dcap-attestation/contracts/interfaces/IPCCSRouter.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {IdentityObj, EnclaveId} from \"@automata-network/on-chain-pccs/helpers/EnclaveIdentityHelper.sol\";\nimport {\n    TCBLevelsObj,\n    TcbInfoBasic,\n    TcbId,\n    TDXModule,\n    TDXModuleIdentity\n} from \"@automata-network/on-chain-pccs/helpers/FmspcTcbHelper.sol\";\nimport {CA} from \"@automata-network/on-chain-pccs/bases/PcsDao.sol\";\n\n/**\n * @title PCCS Router Interface\n * @notice The PCCS Router is a central contract that serves all other contracts in the network\n * to fetch collaterals from the On Chain PCCS\n */\n\ninterface IPCCSRouter {\n    function qeIdDaoAddr() external view returns (address);\n\n    function fmspcTcbDaoAddr() external view returns (address);\n\n    function pckDaoAddr() external view returns (address);\n\n    function pcsDaoAddr() external view returns (address);\n\n    function pckHelperAddr() external view returns (address);\n\n    function crlHelperAddr() external view returns (address);\n\n    function getQeIdentity(EnclaveId id, uint256 quoteVersion) external view returns (bool, IdentityObj memory);\n\n    function getFmspcTcbV2(bytes6 fmspc) external view returns (bool, TCBLevelsObj[] memory);\n\n    function getFmspcTcbV3(TcbId id, bytes6 fmspc)\n        external\n        view\n        returns (bool, TCBLevelsObj[] memory, TDXModule memory, TDXModuleIdentity[] memory);\n\n    function getPckCert(\n        string calldata qeid,\n        string calldata platformCpuSvn,\n        string calldata platformPceSvn,\n        string calldata pceid\n    ) external view returns (bool, bytes memory);\n\n    function getCert(CA ca) external view returns (bool, bytes memory);\n\n    function getCrl(CA ca) external view returns (bool, bytes memory);\n\n    function getCertHash(CA ca) external view returns (bool, bytes32);\n\n    function getCrlHash(CA ca) external view returns (bool, bytes32);\n}\n"
    },
    "@automata-network/dcap-attestation/contracts/interfaces/IQuoteVerifier.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {IPCCSRouter} from \"./IPCCSRouter.sol\";\nimport {Header} from \"../types/CommonStruct.sol\";\n\n/**\n * @title Automata DCAP Quote Verifier\n * @notice Provides the interface to implement version-specific verifiers\n */\ninterface IQuoteVerifier {\n    /**\n     * @dev this method must be immutable\n     * @return an instance of the PCCSRouter interface\n     */\n    function pccsRouter() external view returns (IPCCSRouter);\n\n    /**\n     * @notice the quote version supported by this verifier\n     */\n    function quoteVersion() external view returns (uint16);\n\n    function verifyQuote(Header calldata, bytes calldata) external view returns (bool, bytes memory);\n\n    /**\n     * @notice additional check on the public output obtained from the ZK Program execution\n     */\n    function verifyZkOutput(bytes calldata) external view returns (bool, bytes memory);\n}\n"
    },
    "@automata-network/dcap-attestation/contracts/types/CommonStruct.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {TCBStatus} from \"@automata-network/on-chain-pccs/helpers/FmspcTcbHelper.sol\";\nimport {X509CertObj} from \"@automata-network/on-chain-pccs/helpers/X509Helper.sol\";\n\n/// @dev https://github.com/intel/SGX-TDX-DCAP-QuoteVerificationLibrary/blob/16b7291a7a86e486fdfcf1dfb4be885c0cc00b4e/Src/AttestationLibrary/src/QuoteVerification/QuoteStructures.h#L42-L53\nstruct Header {\n    uint16 version;\n    bytes2 attestationKeyType;\n    bytes4 teeType;\n    bytes2 qeSvn;\n    bytes2 pceSvn;\n    bytes16 qeVendorId;\n    bytes20 userData;\n}\n\n/// @dev https://github.com/intel/SGX-TDX-DCAP-QuoteVerificationLibrary/blob/16b7291a7a86e486fdfcf1dfb4be885c0cc00b4e/Src/AttestationLibrary/src/QuoteVerification/QuoteStructures.h#L63-L80\nstruct EnclaveReport {\n    bytes16 cpuSvn;\n    bytes4 miscSelect;\n    bytes28 reserved1;\n    bytes16 attributes;\n    bytes32 mrEnclave;\n    bytes32 reserved2;\n    bytes32 mrSigner;\n    bytes reserved3; // 96 bytes\n    uint16 isvProdId;\n    uint16 isvSvn;\n    bytes reserved4; // 60 bytes\n    bytes reportData; // 64 bytes - For QEReports, this contains the hash of the concatenation of attestation key and QEAuthData\n}\n\n/// @dev https://github.com/intel/SGX-TDX-DCAP-QuoteVerificationLibrary/blob/16b7291a7a86e486fdfcf1dfb4be885c0cc00b4e/Src/AttestationLibrary/src/QuoteVerification/QuoteStructures.h#L128-L133\nstruct QEAuthData {\n    uint16 parsedDataSize;\n    bytes data;\n}\n\n/// @dev Modified from https://github.com/intel/SGX-TDX-DCAP-QuoteVerificationLibrary/blob/16b7291a7a86e486fdfcf1dfb4be885c0cc00b4e/Src/AttestationLibrary/src/QuoteVerification/QuoteStructures.h#L135-L141\nstruct CertificationData {\n    uint16 certType;\n    uint32 certDataSize;\n    PCKCollateral pck;\n}\n\n/// ========== CUSTOM TYPES ==========\n\nstruct PCKCollateral {\n    X509CertObj[] pckChain; // base64 decoded array containing the PCK chain\n    PCKCertTCB pckExtension;\n}\n\nstruct PCKCertTCB {\n    uint16 pcesvn;\n    uint8[] cpusvns;\n    bytes fmspcBytes;\n    bytes pceidBytes;\n}\n\nstruct Output {\n    uint16 quoteVersion; // BE\n    bytes4 tee; // BE\n    TCBStatus tcbStatus;\n    bytes6 fmspcBytes;\n    bytes quoteBody;\n    string[] advisoryIDs;\n}\n"
    },
    "@automata-network/dcap-attestation/contracts/types/Constants.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @dev https://github.com/intel/SGX-TDX-DCAP-QuoteVerificationLibrary/blob/16b7291a7a86e486fdfcf1dfb4be885c0cc00b4e/Src/AttestationLibrary/src/QuoteVerification/QuoteConstants.h\nuint16 constant HEADER_LENGTH = 48;\nbytes2 constant SUPPORTED_ATTESTATION_KEY_TYPE = 0x0200; // ECDSA_256_WITH_P256_CURVE (LE)\nbytes4 constant SGX_TEE = 0x00000000;\nbytes4 constant TDX_TEE = 0x00000081;\nbytes16 constant VALID_QE_VENDOR_ID = 0x939a7233f79c4ca9940a0db3957f0607;\nuint16 constant ENCLAVE_REPORT_LENGTH = 384;\nuint16 constant TD_REPORT10_LENGTH = 584;\nuint16 constant TD_REPORT15_LENGTH = 648;\n\n// Header (48 bytes) + Body (minimum 384 bytes) + AuthDataSize (4 bytes) + AuthData:\n// ECDSA_SIGNATURE (64 bytes) + ECDSA_KEY (64 bytes) + QE_REPORT_BYTES (384 bytes)\n// + QE_REPORT_SIGNATURE (64 bytes) + QE_AUTH_DATA_SIZE (2 bytes) + QE_CERT_DATA_TYPE (2 bytes)\n// + QE_CERT_DATA_SIZE (4 bytes)\nuint16 constant MINIMUM_QUOTE_LENGTH = 1020;\n\n// QUOTE_VERSION (2 bytes) + TEE_TYPE (4 bytes) + TCB_STATUS (1 byte) + FMSPC (6 bytes)\nuint16 constant MINIMUM_OUTPUT_LENGTH = 13;\n"
    },
    "@automata-network/dcap-attestation/contracts/types/V3Structs.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./CommonStruct.sol\";\n\n/// @dev https://github.com/intel/SGX-TDX-DCAP-QuoteVerificationLibrary/blob/16b7291a7a86e486fdfcf1dfb4be885c0cc00b4e/Src/AttestationLibrary/src/QuoteVerification/QuoteStructures.h#L153-L164\nstruct ECDSAQuoteV3AuthData {\n    bytes ecdsa256BitSignature; // 64 bytes\n    bytes ecdsaAttestationKey; // 64 bytes\n    EnclaveReport qeReport; // 384 bytes\n    bytes qeReportSignature; // 64 bytes\n    QEAuthData qeAuthData;\n    CertificationData certification;\n}\n\nstruct V3Quote {\n    Header header;\n    EnclaveReport localEnclaveReport;\n    ECDSAQuoteV3AuthData authData;\n}\n"
    },
    "@automata-network/dcap-attestation/contracts/utils/BELE.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @notice Converts a little-endian encoded bytes to a big-endian uint256 integer\n */\n\nlibrary BELE {\n    function leBytesToBeUint(bytes memory encoded) internal pure returns (uint256 decoded) {\n        for (uint256 i = 0; i < encoded.length; i++) {\n            uint256 digits = uint256(uint8(bytes1(encoded[i])));\n            uint256 upperDigit = digits / 16;\n            uint256 lowerDigit = digits % 16;\n\n            uint256 acc = lowerDigit * (16 ** (2 * i));\n            acc += upperDigit * (16 ** ((2 * i) + 1));\n\n            decoded += acc;\n        }\n    }\n}\n"
    },
    "@automata-network/dcap-attestation/contracts/utils/BytesUtils.sol": {
      "content": "// SPDX-License-Identifier: BSD 2-Clause License\npragma solidity ^0.8.0;\n\n// Inspired by ensdomains/dnssec-oracle - BSD-2-Clause license\n// https://github.com/ensdomains/dnssec-oracle/blob/master/contracts/BytesUtils.sol\n\nlibrary BytesUtils {\n    /*\n    * @dev Returns the keccak-256 hash of a byte range.\n    * @param self The byte string to hash.\n    * @param offset The position to start hashing at.\n    * @param len The number of bytes to hash.\n    * @return The hash of the byte range.\n    */\n    function keccak(bytes memory self, uint256 offset, uint256 len) internal pure returns (bytes32 ret) {\n        require(offset + len <= self.length);\n        assembly {\n            ret := keccak256(add(add(self, 32), offset), len)\n        }\n    }\n\n    /*\n    * @dev Returns a positive number if `other` comes lexicographically after\n    *      `self`, a negative number if it comes before, or zero if the\n    *      contents of the two bytes are equal.\n    * @param self The first bytes to compare.\n    * @param other The second bytes to compare.\n    * @return The result of the comparison.\n    */\n    function compare(bytes memory self, bytes memory other) internal pure returns (int256) {\n        return compare(self, 0, self.length, other, 0, other.length);\n    }\n\n    /*\n    * @dev Returns a positive number if `other` comes lexicographically after\n    *      `self`, a negative number if it comes before, or zero if the\n    *      contents of the two bytes are equal. Comparison is done per-rune,\n    *      on unicode codepoints.\n    * @param self The first bytes to compare.\n    * @param offset The offset of self.\n    * @param len    The length of self.\n    * @param other The second bytes to compare.\n    * @param otheroffset The offset of the other string.\n    * @param otherlen    The length of the other string.\n    * @return The result of the comparison.\n    */\n    function compare(\n        bytes memory self,\n        uint256 offset,\n        uint256 len,\n        bytes memory other,\n        uint256 otheroffset,\n        uint256 otherlen\n    ) internal pure returns (int256) {\n        uint256 shortest = len;\n        if (otherlen < len) {\n            shortest = otherlen;\n        }\n\n        uint256 selfptr;\n        uint256 otherptr;\n\n        assembly {\n            selfptr := add(self, add(offset, 32))\n            otherptr := add(other, add(otheroffset, 32))\n        }\n        for (uint256 idx = 0; idx < shortest; idx += 32) {\n            uint256 a;\n            uint256 b;\n            assembly {\n                a := mload(selfptr)\n                b := mload(otherptr)\n            }\n            if (a != b) {\n                // Mask out irrelevant bytes and check again\n                uint256 mask;\n                if (shortest > 32) {\n                    mask = type(uint256).max; // aka 0xffffff....\n                } else {\n                    mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);\n                }\n                uint256 diff = (a & mask) - (b & mask);\n                if (diff != 0) {\n                    return int256(diff);\n                }\n            }\n            selfptr += 32;\n            otherptr += 32;\n        }\n\n        return int256(len) - int256(otherlen);\n    }\n\n    /*\n    * @dev Returns true if the two byte ranges are equal.\n    * @param self The first byte range to compare.\n    * @param offset The offset into the first byte range.\n    * @param other The second byte range to compare.\n    * @param otherOffset The offset into the second byte range.\n    * @param len The number of bytes to compare\n    * @return True if the byte ranges are equal, false otherwise.\n    */\n    function equals(bytes memory self, uint256 offset, bytes memory other, uint256 otherOffset, uint256 len)\n        internal\n        pure\n        returns (bool)\n    {\n        return keccak(self, offset, len) == keccak(other, otherOffset, len);\n    }\n\n    /*\n    * @dev Returns true if the two byte ranges are equal with offsets.\n    * @param self The first byte range to compare.\n    * @param offset The offset into the first byte range.\n    * @param other The second byte range to compare.\n    * @param otherOffset The offset into the second byte range.\n    * @return True if the byte ranges are equal, false otherwise.\n    */\n    function equals(bytes memory self, uint256 offset, bytes memory other, uint256 otherOffset)\n        internal\n        pure\n        returns (bool)\n    {\n        return keccak(self, offset, self.length - offset) == keccak(other, otherOffset, other.length - otherOffset);\n    }\n\n    /*\n    * @dev Compares a range of 'self' to all of 'other' and returns True iff\n    *      they are equal.\n    * @param self The first byte range to compare.\n    * @param offset The offset into the first byte range.\n    * @param other The second byte range to compare.\n    * @return True if the byte ranges are equal, false otherwise.\n    */\n    function equals(bytes memory self, uint256 offset, bytes memory other) internal pure returns (bool) {\n        return self.length >= offset + other.length && equals(self, offset, other, 0, other.length);\n    }\n\n    /*\n    * @dev Returns true if the two byte ranges are equal.\n    * @param self The first byte range to compare.\n    * @param other The second byte range to compare.\n    * @return True if the byte ranges are equal, false otherwise.\n    */\n    function equals(bytes memory self, bytes memory other) internal pure returns (bool) {\n        return self.length == other.length && equals(self, 0, other, 0, self.length);\n    }\n\n    /*\n    * @dev Returns the 8-bit number at the specified index of self.\n    * @param self The byte string.\n    * @param idx The index into the bytes\n    * @return The specified 8 bits of the string, interpreted as an integer.\n    */\n    function readUint8(bytes memory self, uint256 idx) internal pure returns (uint8 ret) {\n        return uint8(self[idx]);\n    }\n\n    /*\n    * @dev Returns the 16-bit number at the specified index of self.\n    * @param self The byte string.\n    * @param idx The index into the bytes\n    * @return The specified 16 bits of the string, interpreted as an integer.\n    */\n    function readUint16(bytes memory self, uint256 idx) internal pure returns (uint16 ret) {\n        require(idx + 2 <= self.length);\n        assembly {\n            ret := and(mload(add(add(self, 2), idx)), 0xFFFF)\n        }\n    }\n\n    /*\n    * @dev Returns the 32-bit number at the specified index of self.\n    * @param self The byte string.\n    * @param idx The index into the bytes\n    * @return The specified 32 bits of the string, interpreted as an integer.\n    */\n    function readUint32(bytes memory self, uint256 idx) internal pure returns (uint32 ret) {\n        require(idx + 4 <= self.length);\n        assembly {\n            ret := and(mload(add(add(self, 4), idx)), 0xFFFFFFFF)\n        }\n    }\n\n    /*\n    * @dev Returns the 32 byte value at the specified index of self.\n    * @param self The byte string.\n    * @param idx The index into the bytes\n    * @return The specified 32 bytes of the string.\n    */\n    function readBytes32(bytes memory self, uint256 idx) internal pure returns (bytes32 ret) {\n        require(idx + 32 <= self.length);\n        assembly {\n            ret := mload(add(add(self, 32), idx))\n        }\n    }\n\n    /*\n    * @dev Returns the 32 byte value at the specified index of self.\n    * @param self The byte string.\n    * @param idx The index into the bytes\n    * @return The specified 32 bytes of the string.\n    */\n    function readBytes20(bytes memory self, uint256 idx) internal pure returns (bytes20 ret) {\n        require(idx + 20 <= self.length);\n        assembly {\n            ret :=\n                and(mload(add(add(self, 32), idx)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000000)\n        }\n    }\n\n    /*\n    * @dev Returns the n byte value at the specified index of self.\n    * @param self The byte string.\n    * @param idx The index into the bytes.\n    * @param len The number of bytes.\n    * @return The specified 32 bytes of the string.\n    */\n    function readBytesN(bytes memory self, uint256 idx, uint256 len) internal pure returns (bytes32 ret) {\n        require(len <= 32);\n        require(idx + len <= self.length);\n        assembly {\n            let mask := not(sub(exp(256, sub(32, len)), 1))\n            ret := and(mload(add(add(self, 32), idx)), mask)\n        }\n    }\n\n    function memcpy(uint256 dest, uint256 src, uint256 len) private pure {\n        // Copy word-length chunks while possible\n        for (; len >= 32; len -= 32) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }\n\n        // Copy remaining bytes\n        uint256 mask;\n        if (len == 0) {\n            mask = type(uint256).max; // Set to maximum value of uint256\n        } else {\n            mask = 256 ** (32 - len) - 1;\n        }\n\n        assembly {\n            let srcpart := and(mload(src), not(mask))\n            let destpart := and(mload(dest), mask)\n            mstore(dest, or(destpart, srcpart))\n        }\n    }\n\n    /*\n    * @dev Copies a substring into a new byte string.\n    * @param self The byte string to copy from.\n    * @param offset The offset to start copying at.\n    * @param len The number of bytes to copy.\n    */\n    function substring(bytes memory self, uint256 offset, uint256 len) internal pure returns (bytes memory) {\n        require(offset + len <= self.length);\n\n        bytes memory ret = new bytes(len);\n        uint256 dest;\n        uint256 src;\n\n        assembly {\n            dest := add(ret, 32)\n            src := add(add(self, 32), offset)\n        }\n        memcpy(dest, src, len);\n\n        return ret;\n    }\n\n    // Maps characters from 0x30 to 0x7A to their base32 values.\n    // 0xFF represents invalid characters in that range.\n    bytes constant base32HexTable =\n        hex\"00010203040506070809FFFFFFFFFFFFFF0A0B0C0D0E0F101112131415161718191A1B1C1D1E1FFFFFFFFFFFFFFFFFFFFF0A0B0C0D0E0F101112131415161718191A1B1C1D1E1F\";\n\n    /**\n     * @dev Decodes unpadded base32 data of up to one word in length.\n     * @param self The data to decode.\n     * @param off Offset into the string to start at.\n     * @param len Number of characters to decode.\n     * @return The decoded data, left aligned.\n     */\n    function base32HexDecodeWord(bytes memory self, uint256 off, uint256 len) internal pure returns (bytes32) {\n        require(len <= 52);\n\n        uint256 ret = 0;\n        uint8 decoded;\n        for (uint256 i = 0; i < len; i++) {\n            bytes1 char = self[off + i];\n            require(char >= 0x30 && char <= 0x7A);\n            decoded = uint8(base32HexTable[uint256(uint8(char)) - 0x30]);\n            require(decoded <= 0x20);\n            if (i == len - 1) {\n                break;\n            }\n            ret = (ret << 5) | decoded;\n        }\n\n        uint256 bitlen = len * 5;\n        if (len % 8 == 0) {\n            // Multiple of 8 characters, no padding\n            ret = (ret << 5) | decoded;\n        } else if (len % 8 == 2) {\n            // Two extra characters - 1 byte\n            ret = (ret << 3) | (decoded >> 2);\n            bitlen -= 2;\n        } else if (len % 8 == 4) {\n            // Four extra characters - 2 bytes\n            ret = (ret << 1) | (decoded >> 4);\n            bitlen -= 4;\n        } else if (len % 8 == 5) {\n            // Five extra characters - 3 bytes\n            ret = (ret << 4) | (decoded >> 1);\n            bitlen -= 1;\n        } else if (len % 8 == 7) {\n            // Seven extra characters - 4 bytes\n            ret = (ret << 2) | (decoded >> 3);\n            bitlen -= 3;\n        } else {\n            revert();\n        }\n\n        return bytes32(ret << (256 - bitlen));\n    }\n\n    function compareBytes(bytes memory a, bytes memory b) internal pure returns (bool) {\n        if (a.length != b.length) {\n            return false;\n        }\n        for (uint256 i = 0; i < a.length; i++) {\n            if (a[i] != b[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n"
    },
    "@automata-network/dcap-attestation/contracts/utils/P256Verifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./BytesUtils.sol\";\n\n/**\n * @title P256Verifier Wrapper\n */\nabstract contract P256Verifier {\n    using BytesUtils for bytes;\n\n    /// @dev this address can either be:\n    /// - 0x100 (as defined in RIP-7212)\n    /// - 0xc2b78104907F722DABAc4C69f826a522B2754De4 (daimo-eth P256 implementation, ref: https://github.com/daimo-eth/p256-verifier/)\n    /// @dev may contain other P256 Verifier address depending on the target network\n    address public immutable P256_VERIFIER;\n\n    constructor(address _verifier) {\n        P256_VERIFIER = _verifier;\n    }\n\n    function ecdsaVerify(bytes32 messageHash, bytes memory signature, bytes memory key)\n        internal\n        view\n        returns (bool verified)\n    {\n        bytes memory args = abi.encode(\n            messageHash,\n            uint256(bytes32(signature.substring(0, 32))),\n            uint256(bytes32(signature.substring(32, 32))),\n            uint256(bytes32(key.substring(0, 32))),\n            uint256(bytes32(key.substring(32, 32)))\n        );\n        (bool success, bytes memory ret) = P256_VERIFIER.staticcall(args);\n        assert(success); // never reverts, always returns 0 or 1\n\n        verified = abi.decode(ret, (uint256)) == 1;\n    }\n}"
    },
    "@automata-network/dcap-attestation/contracts/verifiers/V3QuoteVerifier.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../bases/QuoteVerifierBase.sol\";\nimport \"../types/V3Structs.sol\";\nimport \"../bases/tcb/TCBInfoV2Base.sol\";\n\n/**\n * @title Automata DCAP QuoteV3 Verifier\n */\n\ncontract V3QuoteVerifier is QuoteVerifierBase, TCBInfoV2Base {\n    constructor(address _ecdsaVerifier, address _router) QuoteVerifierBase(_router, 3) P256Verifier(_ecdsaVerifier) {}\n\n    function verifyZkOutput(bytes calldata outputBytes)\n        external\n        view\n        override\n        returns (bool success, bytes memory output)\n    {\n        uint256 offset = 2 + uint16(bytes2(outputBytes[0:2]));\n        success = checkCollateralHashes(offset + 72, outputBytes);\n        if (success) {\n            output = outputBytes[2:offset];\n        } else {\n            output = bytes(\"Found one or more collaterals mismatch\");\n        }\n    }\n\n    function verifyQuote(Header calldata header, bytes calldata rawQuote)\n        external\n        view\n        override\n        returns (bool success, bytes memory output)\n    {\n        string memory reason;\n        V3Quote memory quote;\n        bytes memory rawQeReport;\n        (success, reason, quote, rawQeReport) = _parseV3Quote(header, rawQuote);\n        if (!success) {\n            return (false, bytes(reason));\n        }\n\n        (success, output) = _verifyQuote(\n            quote, rawQuote[0:HEADER_LENGTH], rawQuote[HEADER_LENGTH:HEADER_LENGTH + ENCLAVE_REPORT_LENGTH], rawQeReport\n        );\n    }\n\n    function _parseV3Quote(Header calldata header, bytes calldata quote)\n        private\n        view\n        returns (bool success, string memory reason, V3Quote memory parsed, bytes memory rawQeReport)\n    {\n        (success, reason) = validateHeader(header, quote.length, header.teeType == SGX_TEE);\n        if (!success) {\n            return (success, reason, parsed, rawQeReport);\n        }\n\n        // now that we are able to confirm that the provided quote is a valid V3 SGX quote\n        // based on information found in the header\n        // we continue parsing the remainder of the quote\n\n        // parse the local isv report\n        EnclaveReport memory localReport;\n        uint256 offset = HEADER_LENGTH + ENCLAVE_REPORT_LENGTH;\n        (success, localReport) = parseEnclaveReport(quote[HEADER_LENGTH:offset]);\n        if (!success) {\n            return (false, \"failed to parse local isv report\", parsed, rawQeReport);\n        }\n\n        // check authData length\n        uint256 localAuthDataSize = BELE.leBytesToBeUint(quote[offset:offset + 4]);\n        offset += 4;\n        if (quote.length - offset < localAuthDataSize) {\n            return (false, \"quote length is incorrect\", parsed, rawQeReport);\n        }\n\n        // at this point, we have verified the length of the entire quote to be correct\n        // parse authData\n        ECDSAQuoteV3AuthData memory authData;\n        (success, authData, rawQeReport) = _parseAuthData(quote[offset:offset + localAuthDataSize]);\n        if (!success) {\n            return (false, \"failed to parse authdata\", parsed, rawQeReport);\n        }\n\n        success = true;\n        parsed = V3Quote({header: header, localEnclaveReport: localReport, authData: authData});\n    }\n\n    function _verifyQuote(V3Quote memory quote, bytes memory rawHeader, bytes memory rawBody, bytes memory rawQeReport)\n        private\n        view\n        returns (bool success, bytes memory serialized)\n    {\n        // Step 0: Check QE Report Data\n        success = verifyQeReportData(\n            quote.authData.qeReport.reportData, quote.authData.ecdsaAttestationKey, quote.authData.qeAuthData.data\n        );\n        if (!success) {\n            return (success, bytes(\"Invalid QEReport data\"));\n        }\n\n        // Step 1: Fetch QEIdentity to validate TCB of the QE\n        EnclaveIdTcbStatus qeTcbStatus;\n        EnclaveReport memory qeReport = quote.authData.qeReport;\n        (success, qeTcbStatus) = fetchQeIdentityAndCheckQeReport(EnclaveId.QE, qeReport);\n\n        if (!success || qeTcbStatus == EnclaveIdTcbStatus.SGX_ENCLAVE_REPORT_ISVSVN_REVOKED) {\n            return (success, bytes(\"Verification failed by QEIdentity check\"));\n        }\n\n        // Step 2: Fetch FMSPC TCB then get TCBStatus\n        X509CertObj[] memory parsedCerts = quote.authData.certification.pck.pckChain;\n        PCKCertTCB memory pckTcb = quote.authData.certification.pck.pckExtension;\n        (bool tcbValid, TCBLevelsObj[] memory tcbLevels) = pccsRouter.getFmspcTcbV2(bytes6(pckTcb.fmspcBytes));\n        if (!tcbValid) {\n            return (false, bytes(\"TCB not found or expired\"));\n        }\n        TCBStatus tcbStatus;\n        bool statusFound;\n        for (uint256 i = 0; i < tcbLevels.length; i++) {\n            (statusFound, tcbStatus) = getSGXTcbStatus(pckTcb, tcbLevels[i]);\n            if (statusFound) {\n                break;\n            }\n        }\n        if (!statusFound || tcbStatus == TCBStatus.TCB_REVOKED) {\n            return (statusFound, bytes(\"Verificaton failed by TCBInfo check\"));\n        }\n\n        // Step 3: Converge QEIdentity and FMSPC TCB Status\n        tcbStatus = convergeTcbStatusWithQeTcbStatus(qeTcbStatus, tcbStatus);\n\n        // Step 4: verify cert chain\n        success = verifyCertChain(pccsRouter, pccsRouter.crlHelperAddr(), parsedCerts);\n        if (!success) {\n            return (success, bytes(\"Failed to verify X509 Chain\"));\n        }\n\n        // Step 5: Signature Verification on local isv report and qereport by PCK\n        bytes memory localAttestationData = abi.encodePacked(rawHeader, rawBody);\n        success = attestationVerification(\n            rawQeReport,\n            quote.authData.qeReportSignature,\n            parsedCerts[0].subjectPublicKey,\n            localAttestationData,\n            quote.authData.ecdsa256BitSignature,\n            quote.authData.ecdsaAttestationKey\n        );\n        if (!success) {\n            return (success, bytes(\"Failed to verify attestation and/or qe report signatures\"));\n        }\n\n        Output memory output = Output({\n            quoteVersion: quoteVersion,\n            tee: SGX_TEE,\n            tcbStatus: tcbStatus,\n            fmspcBytes: bytes6(pckTcb.fmspcBytes),\n            quoteBody: rawBody,\n            advisoryIDs: new string[](0)\n        });\n        serialized = serializeOutput(output);\n    }\n\n    /**\n     * [0:64] bytes: ecdsa256BitSignature\n     * [64:128] bytes: ecdsaAttestationKey\n     * [128:512] bytes: qeReport\n     * [512:576] bytes: qeReportSignature\n     * [576:578] bytes: qeAuthDataSize (Y)\n     * [578:578+Y] bytes: qeAuthData\n     * [578+Y:580+Y] bytes: pckCertType\n     * NOTE: the calculations below assume pckCertType == 5\n     * [580+Y:584+Y] bytes: certSize (Z)\n     * [584+Y:584+Y+Z] bytes: certData\n     */\n    function _parseAuthData(bytes calldata rawAuthData)\n        private\n        view\n        returns (bool success, ECDSAQuoteV3AuthData memory authDataV3, bytes memory rawQeReport)\n    {\n        authDataV3.ecdsa256BitSignature = rawAuthData[0:64];\n        authDataV3.ecdsaAttestationKey = rawAuthData[64:128];\n        rawQeReport = rawAuthData[128:512];\n        authDataV3.qeReportSignature = rawAuthData[512:576];\n        uint16 qeAuthDataSize = uint16(BELE.leBytesToBeUint(rawAuthData[576:578]));\n        authDataV3.qeAuthData.parsedDataSize = qeAuthDataSize;\n        uint256 offset = 578;\n        authDataV3.qeAuthData.data = rawAuthData[offset:offset + qeAuthDataSize];\n        offset += qeAuthDataSize;\n\n        uint16 certType = uint16(BELE.leBytesToBeUint(rawAuthData[offset:offset + 2]));\n\n        authDataV3.certification.certType = certType;\n        offset += 2;\n        uint32 certDataSize = uint32(BELE.leBytesToBeUint(rawAuthData[offset:offset + 4]));\n        offset += 4;\n        authDataV3.certification.certDataSize = certDataSize;\n        bytes memory rawCertData = rawAuthData[offset:offset + certDataSize];\n\n        // parsing complete, now we need to decode some raw data\n\n        (success, authDataV3.qeReport) = parseEnclaveReport(rawQeReport);\n        if (!success) {\n            return (false, authDataV3, rawQeReport);\n        }\n\n        (success, authDataV3.certification.pck) = getPckCollateral(pccsRouter.pckHelperAddr(), certType, rawCertData);\n        if (!success) {\n            return (false, authDataV3, rawQeReport);\n        }\n    }\n}\n"
    },
    "@automata-network/on-chain-pccs/bases/DaoBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport \"../interfaces/IDaoAttestationResolver.sol\";\n\n/**\n * @title Common Data Access Object base contract\n * @notice This contract provides the generic API methods to fetch collateral data\n * and its hashes from the Resolver\n */\n\nabstract contract DaoBase {\n    IDaoAttestationResolver public immutable resolver;\n\n    constructor(address _resolver) {\n        resolver = IDaoAttestationResolver(_resolver);\n    }\n\n    /**\n     * @notice getter logic to retrieve attested data from the Resolver\n     * @param key - mapped to a collateral as defined by individual data access objects (DAOs)\n     */\n    function getAttestedData(bytes32 key) external view returns (bytes memory attestationData) {\n        attestationData = _fetchDataFromResolver(key, false);\n    }\n\n    /**\n     * @dev SHOULD store the hash of a collateral (e.g. X509 Cert, TCBInfo JSON etc) in the attestation registry\n     * as a separate attestation from the collateral data itself\n     */\n    function getCollateralHash(bytes32 key) external view returns (bytes32 collateralHash) {\n        bytes memory attestationData = _fetchDataFromResolver(key, true);\n        collateralHash = abi.decode(attestationData, (bytes32));\n    }\n\n    /**\n     * @notice the default internal method to be called directly by the DAO\n     * @notice ideally this is called to fetch a \"signer\" collateral such as a Signing\n     * Certificate to validate a new collateral that is being upserted\n     * @notice there should NOT be additional logic in place other than reading collaterals\n     */\n    function _fetchDataFromResolver(bytes32 key, bool hash) internal view returns (bytes memory) {\n        bytes32 attestationId;\n        if (hash) {\n            attestationId = resolver.collateralHashPointer(key);\n        } else {\n            attestationId = resolver.collateralPointer(key);\n        }\n        return resolver.readAttestation(attestationId);\n    }\n\n    /**\n     * @notice similar with \"_fetchDataFromResolver()\" but this is called ONLY\n     * for collateral reads\n     * @dev may overwrite this method to implement additional custom business logic\n     */\n    function _onFetchDataFromResolver(bytes32 key, bool hash) internal view virtual returns (bytes memory) {\n        return _fetchDataFromResolver(key, hash);\n    }\n\n    /// @dev https://github.com/Vectorized/solady/blob/4964e3e2da1bc86b0394f63a90821f51d60a260b/src/utils/JSONParserLib.sol#L339-L364\n    /// @dev Parses an unsigned integer from a string (in hexadecimal, i.e. base 16).\n    /// Reverts if `s` is not a valid uint256 hex string matching the RegEx\n    /// `^(0[xX])?[0-9a-fA-F]+$`, or if the parsed number is too big for a uint256.\n    function _parseUintFromHex(string memory s) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(s)\n            // Skip two if starts with '0x' or '0X'.\n            let i := shl(1, and(eq(0x3078, or(shr(240, mload(add(s, 0x20))), 0x20)), gt(n, 1)))\n            for {} 1 {} {\n                i := add(i, 1)\n                let c :=\n                    byte(\n                        and(0x1f, shr(and(mload(add(s, i)), 0xff), 0x3e4088843e41bac000000000000)),\n                        0x3010a071000000b0104040208000c05090d060e0f\n                    )\n                n := mul(n, iszero(or(iszero(c), shr(252, result))))\n                result := add(shl(4, result), sub(c, 1))\n                if iszero(lt(i, n)) { break }\n            }\n            if iszero(n) {\n                mstore(0x00, 0x10182796) // `ParsingFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n}\n"
    },
    "@automata-network/on-chain-pccs/bases/PcsDao.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {CA} from \"../Common.sol\";\nimport {X509Helper, X509CertObj} from \"../helpers/X509Helper.sol\";\nimport {X509CRLHelper, X509CRLObj} from \"../helpers/X509CRLHelper.sol\";\n\nimport {DaoBase} from \"./DaoBase.sol\";\nimport {SigVerifyBase} from \"./SigVerifyBase.sol\";\n\nimport {LibString} from \"solady/utils/LibString.sol\";\n\n/// @notice the schema of the attested data for PCS Certs is simply DER-encoded form of the X509\n/// @notice Certificate stored in bytes\n\n/**\n * @title Intel PCS Data Access Object\n * @notice This is the core contract of our on-chain PCCS implementation as it provides methods\n * @notice to read/write essential collaterals such as the RootCA, Intermediate CAs and CRLs.\n * @notice All other DAOs are expected to make external calls to this contract to fetch those collaterals.\n * @notice This contract is heavily inspired by Sections 4.2.5 and 4.2.6 in the Intel SGX PCCS Design Guideline\n * https://download.01.org/intel-sgx/sgx-dcap/1.19/linux/docs/SGX_DCAP_Caching_Service_Design_Guide.pdf\n */\nabstract contract PcsDao is DaoBase, SigVerifyBase {\n    using LibString for string;\n\n    X509CRLHelper public crlLib;\n\n    string constant PCK_PLATFORM_CA_COMMON_NAME = \"Intel SGX PCK Platform CA\";\n    string constant PCK_PROCESSOR_CA_COMMON_NAME = \"Intel SGX PCK Processor CA\";\n    string constant SIGNING_COMMON_NAME = \"Intel SGX TCB Signing\";\n    string constant ROOT_CA_COMMON_NAME = \"Intel SGX Root CA\";\n\n    // first 4 bytes of keccak256('PCS_MAGIC')\n    bytes4 constant PCS_MAGIC = 0xe90e3dc7;\n\n    /// keccak256(hex\"0ba9c4c0c0c86193a3fe23d6b02cda10a8bbd4e88e48b4458561a36e705525f567918e2edc88e40d860bd0cc4ee26aacc988e505a953558c453f6b0904ae7394\")\n    /// the uncompressed (0x04) prefix is not included in the pubkey pre-image\n    /// @dev Must ensure that the public key for the configured Intel Root CA matches with\n    /// @dev the Intel source code at: https://github.com/intel/SGXDataCenterAttestationPrimitives/blob/39989a42bbbb0c968153a47254b6de79a27eb603/QuoteVerification/QvE/Enclave/qve.cpp#L92-L100\n    bytes32 constant ROOT_CA_PUBKEY_HASH = 0x89f72d7c488e5b53a77c23ebcb36970ef7eb5bcf6658e9b8292cfbe4703a8473;\n\n    // 33247a8a\n    error Missing_Certificate(CA ca);\n    // 9849e774\n    error Invalid_PCK_CA(CA ca);\n    // e1406f79\n    error Root_Key_Mismatch();\n    // 291990cd\n    error Certificate_Revoked(CA ca, uint256 serialNum);\n    // dba942a2\n    error Certificate_Expired();\n    // 1e7ab599\n    error Invalid_Issuer_Name();\n    // 92ec707e\n    error Invalid_Subject_Name();\n    // e6612a12\n    error Expired_Certificates();\n    // 4a629e24\n    error TCB_Mismatch();\n    // cd69d374\n    error Missing_Issuer();\n    // e7ef341f\n    error Invalid_Signature();\n\n    constructor(address _resolver, address _p256, address _x509, address _crl)\n        SigVerifyBase(_p256, _x509)\n        DaoBase(_resolver)\n    {\n        crlLib = X509CRLHelper(_crl);\n    }\n\n    function PCS_KEY(CA ca, bool isCrl) public pure returns (bytes32 key) {\n        key = keccak256(abi.encodePacked(PCS_MAGIC, uint8(ca), isCrl));\n    }\n\n    modifier pckCACheck(CA ca) {\n        if (ca == CA.ROOT || ca == CA.SIGNING) {\n            revert Invalid_PCK_CA(ca);\n        }\n        _;\n    }\n\n    /**\n     * @param ca see {Common.sol} for definition\n     * @return cert - DER encoded certificate\n     * @return crl - DER-encoded CRLs that is signed by the provided cert\n     */\n    function getCertificateById(CA ca) external view returns (bytes memory cert, bytes memory crl) {\n        cert = _onFetchDataFromResolver(PCS_KEY(ca, false), false);\n\n        if (cert.length == 0) {\n            revert Missing_Certificate(ca);\n        }\n\n        crl = _onFetchDataFromResolver(PCS_KEY(ca, true), false);\n    }\n\n    /**\n     * Section 4.2.6 (upsertPcsCertificates)\n     * @param ca replaces the \"id\" value with the ca_id\n     * @param cert the DER-encoded certificate\n     */\n    function upsertPcsCertificates(CA ca, bytes calldata cert) external returns (bytes32 attestationId) {\n        bytes32 hash = _validatePcsCert(ca, cert);\n        bytes32 key = PCS_KEY(ca, false);\n        attestationId = _attestPcs(cert, hash, key);\n    }\n\n    /**\n     * Section 4.2.5 (upsertPckCrl)\n     * @param ca either CA.PROCESSOR or CA.PLATFORM\n     * @param crl the DER-encoded CRL\n     */\n    function upsertPckCrl(CA ca, bytes calldata crl) external pckCACheck(ca) returns (bytes32 attestationId) {\n        attestationId = _upsertPcsCrl(ca, crl);\n    }\n\n    /**\n     * Section 4.2.6 (upsertRootCACrl)\n     */\n    function upsertRootCACrl(bytes calldata rootcacrl) external returns (bytes32 attestationId) {\n        attestationId = _upsertPcsCrl(CA.ROOT, rootcacrl);\n    }\n\n    /**\n     * @notice attests collateral via the Resolver\n     * @return attestationId\n     */\n    function _attestPcs(bytes memory reqData, bytes32 hash, bytes32 key)\n        internal\n        virtual\n        returns (bytes32 attestationId)\n    {\n        (attestationId,) = resolver.attest(key, reqData, hash);\n    }\n\n    function _upsertPcsCrl(CA ca, bytes calldata crl) private returns (bytes32 attestationId) {\n        bytes32 hash = _validatePcsCrl(ca, crl);\n        bytes32 key = PCS_KEY(ca, true);\n        attestationId = _attestPcs(crl, hash, key);\n    }\n\n    function _validatePcsCert(CA ca, bytes calldata cert) private view returns (bytes32 hash) {\n        X509Helper x509Lib = X509Helper(x509);\n\n        // Step 1: Check whether cert has expired\n        bool notExpired = x509Lib.certIsNotExpired(cert);\n        if (!notExpired) {\n            revert Certificate_Expired();\n        }\n\n        // Step 2: Check issuer and subject common names are valid\n        string memory issuerName = x509Lib.getIssuerCommonName(cert);\n        string memory subjectName = x509Lib.getSubjectCommonName(cert);\n        string memory expectedIssuer = ROOT_CA_COMMON_NAME;\n        string memory expectedSubject;\n        if (ca == CA.PLATFORM) {\n            expectedSubject = PCK_PLATFORM_CA_COMMON_NAME;\n        } else if (ca == CA.PROCESSOR) {\n            expectedSubject = PCK_PROCESSOR_CA_COMMON_NAME;\n        } else if (ca == CA.SIGNING) {\n            expectedSubject = SIGNING_COMMON_NAME;\n        } else if (ca == CA.ROOT) {\n            expectedSubject = ROOT_CA_COMMON_NAME;\n        }\n\n        if (!LibString.eq(issuerName, expectedIssuer)) {\n            revert Invalid_Issuer_Name();\n        }\n        if (!LibString.eq(subjectName, expectedSubject)) {\n            revert Invalid_Subject_Name();\n        }\n\n        // Step 3: Check Revocation Status\n        bytes memory rootCrlData = _fetchDataFromResolver(PCS_KEY(CA.ROOT, true), false);\n        if (ca == CA.ROOT) {\n            bytes memory pubKey = x509Lib.getSubjectPublicKey(cert);\n            if (keccak256(pubKey) != ROOT_CA_PUBKEY_HASH) {\n                revert Root_Key_Mismatch();\n            }\n        } else if (rootCrlData.length > 0) {\n            uint256 serialNum = x509Lib.getSerialNumber(cert);\n            bool revoked = crlLib.serialNumberIsRevoked(serialNum, rootCrlData);\n            if (revoked) {\n                revert Certificate_Revoked(ca, serialNum);\n            }\n        }\n\n        // Step 4: Check signature\n        bytes memory rootCert = _getIssuer(CA.ROOT);\n        (bytes memory tbs, bytes memory signature) = x509Lib.getTbsAndSig(cert);\n        bytes32 digest = sha256(tbs);\n        bool sigVerified;\n        if (ca == CA.ROOT) {\n            // the root certificate is issued by its own key\n            sigVerified = verifySignature(digest, signature, cert);\n        } else if (rootCert.length > 0) {\n            sigVerified = verifySignature(digest, signature, rootCert);\n        } else {\n            // all other certificates should already have an iusuer configured\n            revert Missing_Issuer();\n        }\n\n        if (!sigVerified) {\n            revert Invalid_Signature();\n        }\n\n        hash = keccak256(tbs);\n    }\n\n    function _validatePcsCrl(CA ca, bytes calldata crl) private view returns (bytes32 hash) {\n        // Step 1: Check whether CRL has expired\n        bool notExpired = crlLib.crlIsNotExpired(crl);\n        if (!notExpired) {\n            revert Certificate_Expired();\n        }\n\n        // Step 2: Check CRL issuer\n        string memory issuerCommonName = crlLib.getIssuerCommonName(crl);\n        string memory expectedIssuer;\n        if (ca == CA.PLATFORM || ca == CA.PROCESSOR) {\n            expectedIssuer = ca == CA.PLATFORM ? PCK_PLATFORM_CA_COMMON_NAME : PCK_PROCESSOR_CA_COMMON_NAME;\n        } else {\n            expectedIssuer = ROOT_CA_COMMON_NAME;\n        }\n        if (!LibString.eq(issuerCommonName, expectedIssuer)) {\n            revert Invalid_Issuer_Name();\n        }\n\n        // Step 3: Verify signature\n        (bytes memory tbs, bytes memory signature) = crlLib.getTbsAndSig(crl);\n        bytes32 digest = sha256(tbs);\n        bool sigVerified = verifySignature(digest, signature, _getIssuer(ca));\n        if (!sigVerified) {\n            revert Invalid_Signature();\n        }\n\n        hash = keccak256(tbs);\n    }\n\n    function _getIssuer(CA ca) private view returns (bytes memory issuerCert) {\n        if (ca == CA.PLATFORM || ca == CA.PROCESSOR) {\n            // this is applicable to crls only\n            // since all certs in the pcsdao are issued by the root\n            issuerCert = _fetchDataFromResolver(PCS_KEY(ca, false), false);\n        } else {\n            issuerCert = _fetchDataFromResolver(PCS_KEY(CA.ROOT, false), false);\n        }\n    }\n}\n"
    },
    "@automata-network/on-chain-pccs/bases/SigVerifyBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {BytesUtils} from \"../utils/BytesUtils.sol\";\nimport {P256Verifier} from \"../utils/P256Verifier.sol\";\n\ninterface IX509 {\n    function getSubjectPublicKey(bytes memory der) external pure returns (bytes memory pubKey);\n}\n\n/**\n * @title Signature verification base contract\n * @notice It can be extended by any contracts that required ECDSA verification\n */\n\nabstract contract SigVerifyBase is P256Verifier {\n    address public x509;\n\n    using BytesUtils for bytes;\n\n    constructor(address _p256Verifier, address _x509helper) P256Verifier(_p256Verifier) {\n        x509 = _x509helper;\n    }\n\n    function verifySignature(bytes32 digest, bytes memory signature, bytes memory signingCertBlob)\n        internal\n        view\n        returns (bool verified)\n    {\n        if (signature.length != 64) {\n            return false;\n        }\n\n        bytes memory pubKey = IX509(x509).getSubjectPublicKey(signingCertBlob);\n        if (pubKey.length != 64) {\n            return false;\n        }\n\n        verified = ecdsaVerify(digest, signature, pubKey);\n    }\n}\n"
    },
    "@automata-network/on-chain-pccs/Common.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nenum CA {\n    ROOT,\n    PROCESSOR,\n    PLATFORM,\n    SIGNING\n}\n"
    },
    "@automata-network/on-chain-pccs/helpers/EnclaveIdentityHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JSONParserLib} from \"solady/utils/JSONParserLib.sol\";\nimport {LibString} from \"solady/utils/LibString.sol\";\nimport {DateTimeUtils} from \"../utils/DateTimeUtils.sol\";\n\nenum EnclaveId {\n    QE,\n    QVE,\n    TD_QE\n}\n\n/**\n * @dev This is a simple representation of the Identity.json in string as a Solidity object.\n * @param identityStr Identity string object body. Needs to be parsed\n * and converted as IdentityObj.\n * @param signature The signature to be passed as bytes array\n */\nstruct EnclaveIdentityJsonObj {\n    string identityStr;\n    bytes signature;\n}\n\n/// @dev Full Solidity Object representation of Identity.json\nstruct IdentityObj {\n    EnclaveId id;\n    uint32 version;\n    uint64 issueDateTimestamp; // UNIX Epoch Timestamp in seconds\n    uint64 nextUpdateTimestamp; // UNIX Epoch Timestamp in seconds\n    uint32 tcbEvaluationDataNumber;\n    bytes4 miscselect;\n    bytes4 miscselectMask;\n    bytes16 attributes;\n    bytes16 attributesMask;\n    bytes32 mrsigner;\n    uint16 isvprodid;\n    Tcb[] tcb;\n}\n\nenum EnclaveIdTcbStatus {\n    SGX_ENCLAVE_REPORT_ISVSVN_NOT_SUPPORTED,\n    OK,\n    SGX_ENCLAVE_REPORT_ISVSVN_REVOKED,\n    SGX_ENCLAVE_REPORT_ISVSVN_OUT_OF_DATE\n}\n\nstruct Tcb {\n    uint16 isvsvn;\n    uint256 dateTimestamp;\n    EnclaveIdTcbStatus status;\n}\n\n/**\n * @title Enclave Identity Helper Contract\n * @notice This is a standalone contract that can be used by off-chain applications and smart contracts\n * to parse Identity.json, and convert as a Solidity object.\n */\ncontract EnclaveIdentityHelper {\n    using JSONParserLib for JSONParserLib.Item;\n    using LibString for string;\n\n    error Invalid_ID();\n\n    function parseIdentityString(string calldata identityStr) external pure returns (IdentityObj memory identity) {\n        identity = _parseIdentity(identityStr);\n    }\n\n    function _parseIdentity(string calldata identityStr) private pure returns (IdentityObj memory identity) {\n        JSONParserLib.Item memory root = JSONParserLib.parse(identityStr);\n        JSONParserLib.Item[] memory identityObj = root.children();\n\n        for (uint256 i = 0; i < root.size(); i++) {\n            JSONParserLib.Item memory current = identityObj[i];\n            string memory decodedKey = JSONParserLib.decodeString(current.key());\n\n            if (decodedKey.eq(\"issueDate\")) {\n                identity.issueDateTimestamp =\n                    uint64(DateTimeUtils.fromISOToTimestamp(JSONParserLib.decodeString(current.value())));\n            } else if (decodedKey.eq(\"nextUpdate\")) {\n                identity.nextUpdateTimestamp =\n                    uint64(DateTimeUtils.fromISOToTimestamp(JSONParserLib.decodeString(current.value())));\n            } else if (decodedKey.eq(\"id\")) {\n                string memory idStr = JSONParserLib.decodeString(current.value());\n                if (LibString.eq(idStr, \"QE\")) {\n                    identity.id = EnclaveId.QE;\n                } else if (LibString.eq(idStr, \"QVE\")) {\n                    identity.id = EnclaveId.QVE;\n                } else if (LibString.eq(idStr, \"TD_QE\")) {\n                    identity.id = EnclaveId.TD_QE;\n                } else {\n                    revert Invalid_ID();\n                }\n            } else if (decodedKey.eq(\"version\")) {\n                identity.version = uint32(JSONParserLib.parseUint(current.value()));\n            } else if (decodedKey.eq(\"tcbEvaluationDataNumber\")) {\n                identity.tcbEvaluationDataNumber = uint32(JSONParserLib.parseUint(current.value()));\n            } else if (decodedKey.eq(\"miscselect\")) {\n                uint256 val = JSONParserLib.parseUintFromHex(JSONParserLib.decodeString(current.value()));\n                identity.miscselect = bytes4(uint32(val));\n            } else if (decodedKey.eq(\"miscselectMask\")) {\n                uint256 val = JSONParserLib.parseUintFromHex(JSONParserLib.decodeString(current.value()));\n                identity.miscselectMask = bytes4(uint32(val));\n            } else if (decodedKey.eq(\"attributes\")) {\n                uint256 val = JSONParserLib.parseUintFromHex(JSONParserLib.decodeString(current.value()));\n                identity.attributes = bytes16(uint128(val));\n            } else if (decodedKey.eq(\"attributesMask\")) {\n                uint256 val = JSONParserLib.parseUintFromHex(JSONParserLib.decodeString(current.value()));\n                identity.attributesMask = bytes16(uint128(val));\n            } else if (decodedKey.eq(\"mrsigner\")) {\n                uint256 val = JSONParserLib.parseUintFromHex(JSONParserLib.decodeString(current.value()));\n                identity.mrsigner = bytes32(val);\n            } else if (decodedKey.eq(\"isvprodid\")) {\n                identity.isvprodid = uint16(JSONParserLib.parseUint(current.value()));\n            } else if (decodedKey.eq(\"tcbLevels\")) {\n                identity.tcb = _parseTcb(current.value());\n            }\n        }\n    }\n\n    function _parseTcb(string memory tcbLevelsStr) internal pure returns (Tcb[] memory tcb) {\n        JSONParserLib.Item memory tcbLevelsParent = JSONParserLib.parse(tcbLevelsStr);\n        JSONParserLib.Item[] memory tcbLevels = tcbLevelsParent.children();\n        uint256 tcbLevelsSize = tcbLevelsParent.size();\n        tcb = new Tcb[](tcbLevelsSize);\n        for (uint256 i = 0; i < tcbLevelsSize; i++) {\n            uint256 tcbLevelsChildSize = tcbLevels[i].size();\n            JSONParserLib.Item[] memory tcbObj = tcbLevels[i].children();\n            for (uint256 j = 0; j < tcbLevelsChildSize; j++) {\n                string memory tcbKey = JSONParserLib.decodeString(tcbObj[j].key());\n                if (tcbKey.eq(\"tcb\")) {\n                    JSONParserLib.Item[] memory tcbChild = tcbObj[j].children();\n                    string memory childKey = JSONParserLib.decodeString(tcbChild[0].key());\n                    if (childKey.eq(\"isvsvn\")) {\n                        tcb[i].isvsvn = uint16(JSONParserLib.parseUint(tcbChild[0].value()));\n                    }\n                } else if (tcbKey.eq(\"tcbDate\")) {\n                    tcb[i].dateTimestamp =\n                        DateTimeUtils.fromISOToTimestamp(JSONParserLib.decodeString(tcbObj[j].value()));\n                } else if (tcbKey.eq(\"tcbStatus\")) {\n                    string memory decodedValue = JSONParserLib.decodeString(tcbObj[j].value());\n                    if (decodedValue.eq(\"UpToDate\")) {\n                        tcb[i].status = EnclaveIdTcbStatus.OK;\n                    } else if (decodedValue.eq(\"Revoked\")) {\n                        tcb[i].status = EnclaveIdTcbStatus.SGX_ENCLAVE_REPORT_ISVSVN_REVOKED;\n                    } else if (decodedValue.eq(\"OutOfDate\")) {\n                        tcb[i].status = EnclaveIdTcbStatus.SGX_ENCLAVE_REPORT_ISVSVN_OUT_OF_DATE;\n                    }\n                }\n            }\n        }\n    }\n}\n"
    },
    "@automata-network/on-chain-pccs/helpers/FmspcTcbHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JSONParserLib} from \"solady/utils/JSONParserLib.sol\";\nimport {LibString} from \"solady/utils/LibString.sol\";\nimport {DateTimeUtils} from \"../utils/DateTimeUtils.sol\";\n\n// https://github.com/intel/SGXDataCenterAttestationPrimitives/blob/e7604e02331b3377f3766ed3653250e03af72d45/QuoteVerification/QVL/Src/AttestationLibrary/src/CertVerification/X509Constants.h#L64\nuint256 constant TCB_CPUSVN_SIZE = 16;\n\nenum TcbId {\n    /// the \"id\" field is absent from TCBInfo V2\n    /// which defaults TcbId to SGX\n    /// since TDX TCBInfos are only included in V3 or above\n    SGX,\n    TDX\n}\n\n/**\n * @dev This is a simple representation of the TCBInfo.json in string as a Solidity object.\n * @param tcbInfo: tcbInfoJson.tcbInfo string object body\n * @param signature The signature to be passed as bytes array\n */\nstruct TcbInfoJsonObj {\n    string tcbInfoStr;\n    bytes signature;\n}\n\n/// @dev Solidity object representing TCBInfo.json excluding TCBLevels\nstruct TcbInfoBasic {\n    /// the name \"tcbType\" can be confusing/misleading\n    /// as the tcbType referred here in this struct is the type\n    /// of TCB level composition that determines TCB level comparison logic\n    /// It is not the same as the \"type\" parameter passed as an argument to the\n    /// getTcbInfo() API method described in Section 4.2.3 of the Intel PCCS Design Document\n    /// Instead, getTcbInfo() \"type\" argument should be checked against the \"id\" value of this struct\n    /// which represents the TEE type for the given TCBInfo\n    uint8 tcbType;\n    TcbId id;\n    uint32 version;\n    uint64 issueDate;\n    uint64 nextUpdate;\n    uint32 evaluationDataNumber;\n    bytes6 fmspc;\n    bytes2 pceid;\n}\n\nstruct TCBLevelsObj {\n    uint16 pcesvn;\n    uint8[] sgxComponentCpuSvns;\n    uint8[] tdxSvns;\n    uint64 tcbDateTimestamp;\n    TCBStatus status;\n    string[] advisoryIDs;\n}\n\nstruct TDXModule {\n    bytes mrsigner; // 48 bytes\n    bytes8 attributes;\n    bytes8 attributesMask;\n}\n\nstruct TDXModuleIdentity {\n    string id;\n    bytes8 attributes;\n    bytes8 attributesMask;\n    bytes mrsigner; // 48 bytes\n    TDXModuleTCBLevelsObj[] tcbLevels;\n}\n\nstruct TDXModuleTCBLevelsObj {\n    uint8 isvsvn;\n    uint64 tcbDateTimestamp;\n    TCBStatus status;\n}\n\nenum TCBStatus {\n    OK,\n    TCB_SW_HARDENING_NEEDED,\n    TCB_CONFIGURATION_AND_SW_HARDENING_NEEDED,\n    TCB_CONFIGURATION_NEEDED,\n    TCB_OUT_OF_DATE,\n    TCB_OUT_OF_DATE_CONFIGURATION_NEEDED,\n    TCB_REVOKED,\n    TCB_UNRECOGNIZED\n}\n\n/**\n * @title FMSPC TCB Helper Contract\n * @notice This is a standalone contract that can be used by off-chain applications and smart contracts\n * to parse TCBInfo data\n */\ncontract FmspcTcbHelper {\n    using JSONParserLib for JSONParserLib.Item;\n    using LibString for string;\n\n    error TCBInfo_Invalid();\n    error TCB_TDX_Version_Invalid();\n    error TCB_TDX_ID_Invalid();\n\n    function parseTcbString(string calldata tcbInfoStr) external pure returns (TcbInfoBasic memory tcbInfo) {\n        JSONParserLib.Item memory root = JSONParserLib.parse(tcbInfoStr);\n        JSONParserLib.Item[] memory tcbInfoObj = root.children();\n\n        bool tcbTypeFound;\n        bool fmspcFound;\n        bool versionFound;\n        bool issueDateFound;\n        bool nextUpdateFound;\n        bool pceidFound;\n        bool evaluationFound;\n        bool idFound;\n        bool allFound;\n\n        for (uint256 y = 0; y < root.size(); y++) {\n            JSONParserLib.Item memory current = tcbInfoObj[y];\n            string memory decodedKey = JSONParserLib.decodeString(current.key());\n            string memory val = current.value();\n            if (decodedKey.eq(\"tcbType\")) {\n                tcbInfo.tcbType = uint8(JSONParserLib.parseUint(val));\n                tcbTypeFound = true;\n            } else if (decodedKey.eq(\"id\")) {\n                string memory idStr = JSONParserLib.decodeString(val);\n                if (idStr.eq(\"SGX\")) {\n                    tcbInfo.id = TcbId.SGX;\n                } else if (idStr.eq(\"TDX\")) {\n                    tcbInfo.id = TcbId.TDX;\n                } else {\n                    revert TCBInfo_Invalid();\n                }\n                idFound = true;\n            } else if (decodedKey.eq(\"fmspc\")) {\n                tcbInfo.fmspc = bytes6(uint48(JSONParserLib.parseUintFromHex(JSONParserLib.decodeString(val))));\n                fmspcFound = true;\n            } else if (decodedKey.eq(\"version\")) {\n                tcbInfo.version = uint32(JSONParserLib.parseUint(val));\n                versionFound = true;\n            } else if (decodedKey.eq(\"issueDate\")) {\n                tcbInfo.issueDate = uint64(DateTimeUtils.fromISOToTimestamp(JSONParserLib.decodeString(val)));\n                issueDateFound = true;\n            } else if (decodedKey.eq(\"nextUpdate\")) {\n                tcbInfo.nextUpdate = uint64(DateTimeUtils.fromISOToTimestamp(JSONParserLib.decodeString(val)));\n                nextUpdateFound = true;\n            } else if (decodedKey.eq(\"pceId\")) {\n                tcbInfo.pceid = bytes2(uint16(JSONParserLib.parseUintFromHex(JSONParserLib.decodeString(val))));\n                pceidFound = true;\n            } else if (decodedKey.eq(\"tcbEvaluationDataNumber\")) {\n                tcbInfo.evaluationDataNumber = uint32(JSONParserLib.parseUint(val));\n                evaluationFound = true;\n            }\n            if (versionFound) {\n                allFound =\n                    (tcbTypeFound && fmspcFound && issueDateFound && nextUpdateFound && pceidFound && evaluationFound);\n                if (tcbInfo.version >= 3) {\n                    allFound = allFound && idFound;\n                }\n                if (allFound) {\n                    break;\n                }\n            }\n        }\n\n        if (!allFound) {\n            revert TCBInfo_Invalid();\n        }\n    }\n\n    function parseTcbLevels(string calldata tcbInfoStr)\n        external\n        pure\n        returns (uint256 version, TCBLevelsObj[] memory tcbLevels)\n    {\n        JSONParserLib.Item memory root = JSONParserLib.parse(tcbInfoStr);\n        JSONParserLib.Item[] memory tcbInfoObj = root.children();\n\n        bool versionFound;\n        bool tcbLevelsFound;\n        JSONParserLib.Item[] memory tcbLevelsObj;\n\n        for (uint256 i = 0; i < root.size(); i++) {\n            JSONParserLib.Item memory current = tcbInfoObj[i];\n            string memory decodedKey = JSONParserLib.decodeString(current.key());\n            if (decodedKey.eq(\"version\")) {\n                version = JSONParserLib.parseUint(current.value());\n                versionFound = true;\n            }\n            if (decodedKey.eq(\"tcbLevels\")) {\n                tcbLevelsObj = current.children();\n                tcbLevelsFound = true;\n            }\n            if (versionFound && tcbLevelsFound) {\n                break;\n            }\n        }\n\n        if (versionFound && tcbLevelsFound) {\n            tcbLevels = _parseTCBLevels(version, tcbLevelsObj);\n        } else {\n            revert TCBInfo_Invalid();\n        }\n    }\n\n    function parseTcbTdxModules(string calldata tcbInfoStr)\n        external\n        pure\n        returns (TDXModule memory module, TDXModuleIdentity[] memory moduleIdentities)\n    {\n        JSONParserLib.Item memory root = JSONParserLib.parse(tcbInfoStr);\n        JSONParserLib.Item[] memory tcbInfoObj = root.children();\n\n        bool versionFound;\n        bool idFound;\n        bool tdxModuleFound;\n        bool tdxModuleIdentitiesFound;\n        bool allFound;\n\n        for (uint256 i = 0; i < root.size(); i++) {\n            JSONParserLib.Item memory current = tcbInfoObj[i];\n            string memory decodedKey = JSONParserLib.decodeString(current.key());\n            if (decodedKey.eq(\"version\")) {\n                uint256 version = JSONParserLib.parseUint(current.value());\n                if (version < 3) {\n                    revert TCB_TDX_Version_Invalid();\n                }\n                versionFound = true;\n            }\n            if (decodedKey.eq(\"id\")) {\n                string memory id = JSONParserLib.decodeString(current.value());\n                if (!id.eq(\"TDX\")) {\n                    revert TCB_TDX_ID_Invalid();\n                }\n                idFound = true;\n            }\n            if (decodedKey.eq(\"tdxModule\")) {\n                module = _parseTdxModule(current.children());\n                tdxModuleFound = true;\n            }\n            if (decodedKey.eq(\"tdxModuleIdentities\")) {\n                moduleIdentities = _parseTdxModuleIdentities(current.children());\n                tdxModuleIdentitiesFound = true;\n            }\n            allFound = versionFound && idFound && tdxModuleFound && tdxModuleIdentitiesFound;\n            if (allFound) {\n                break;\n            }\n        }\n\n        if (!allFound) {\n            revert TCBInfo_Invalid();\n        }\n    }\n\n    /// ====== INTERNAL METHODS BELOW ======\n\n    function _parseTCBLevels(uint256 version, JSONParserLib.Item[] memory tcbLevelsObj)\n        private\n        pure\n        returns (TCBLevelsObj[] memory tcbLevels)\n    {\n        uint256 tcbLevelsSize = tcbLevelsObj.length;\n        tcbLevels = new TCBLevelsObj[](tcbLevelsSize);\n\n        // iterating through the array\n        for (uint256 i = 0; i < tcbLevelsSize; i++) {\n            JSONParserLib.Item[] memory tcbObj = tcbLevelsObj[i].children();\n            // iterating through individual tcb objects\n            for (uint256 j = 0; j < tcbLevelsObj[i].size(); j++) {\n                string memory tcbKey = JSONParserLib.decodeString(tcbObj[j].key());\n                if (tcbKey.eq(\"tcb\")) {\n                    string memory tcbStr = tcbObj[j].value();\n                    JSONParserLib.Item memory tcbParent = JSONParserLib.parse(tcbStr);\n                    JSONParserLib.Item[] memory tcbComponents = tcbParent.children();\n                    if (version == 2) {\n                        (tcbLevels[i].sgxComponentCpuSvns, tcbLevels[i].pcesvn) = _parseV2Tcb(tcbComponents);\n                    } else if (version == 3) {\n                        (tcbLevels[i].sgxComponentCpuSvns, tcbLevels[i].tdxSvns, tcbLevels[i].pcesvn) =\n                            _parseV3Tcb(tcbComponents);\n                    } else {\n                        revert TCBInfo_Invalid();\n                    }\n                } else if (tcbKey.eq(\"tcbDate\")) {\n                    tcbLevels[i].tcbDateTimestamp =\n                        uint64(DateTimeUtils.fromISOToTimestamp(JSONParserLib.decodeString(tcbObj[j].value())));\n                } else if (tcbKey.eq(\"tcbStatus\")) {\n                    tcbLevels[i].status = _getTcbStatus(JSONParserLib.decodeString(tcbObj[j].value()));\n                } else if (tcbKey.eq(\"advisoryIDs\")) {\n                    JSONParserLib.Item[] memory advisoryArr = tcbObj[j].children();\n                    uint256 n = tcbObj[j].size();\n                    tcbLevels[i].advisoryIDs = new string[](n);\n                    for (uint256 k = 0; k < n; k++) {\n                        tcbLevels[i].advisoryIDs[k] = JSONParserLib.decodeString(advisoryArr[k].value());\n                    }\n                }\n            }\n        }\n    }\n\n    function _getTcbStatus(string memory statusStr) private pure returns (TCBStatus status) {\n        if (statusStr.eq(\"UpToDate\")) {\n            status = TCBStatus.OK;\n        } else if (statusStr.eq(\"OutOfDate\")) {\n            status = TCBStatus.TCB_OUT_OF_DATE;\n        } else if (statusStr.eq(\"OutOfDateConfigurationNeeded\")) {\n            status = TCBStatus.TCB_OUT_OF_DATE_CONFIGURATION_NEEDED;\n        } else if (statusStr.eq(\"ConfigurationNeeded\")) {\n            status = TCBStatus.TCB_CONFIGURATION_NEEDED;\n        } else if (statusStr.eq(\"ConfigurationAndSWHardeningNeeded\")) {\n            status = TCBStatus.TCB_CONFIGURATION_AND_SW_HARDENING_NEEDED;\n        } else if (statusStr.eq(\"SWHardeningNeeded\")) {\n            status = TCBStatus.TCB_SW_HARDENING_NEEDED;\n        } else if (statusStr.eq(\"Revoked\")) {\n            status = TCBStatus.TCB_REVOKED;\n        } else {\n            status = TCBStatus.TCB_UNRECOGNIZED;\n        }\n    }\n\n    function _parseV2Tcb(JSONParserLib.Item[] memory tcbComponents)\n        private\n        pure\n        returns (uint8[] memory sgxComponentCpuSvns, uint16 pcesvn)\n    {\n        sgxComponentCpuSvns = new uint8[](TCB_CPUSVN_SIZE);\n        uint256 cpusvnCounter = 0;\n        for (uint256 i = 0; i < tcbComponents.length; i++) {\n            string memory key = JSONParserLib.decodeString(tcbComponents[i].key());\n            uint256 value = JSONParserLib.parseUint(tcbComponents[i].value());\n            if (key.eq(\"pcesvn\")) {\n                pcesvn = uint16(value);\n            } else {\n                sgxComponentCpuSvns[cpusvnCounter++] = uint8(value);\n            }\n        }\n        if (cpusvnCounter != TCB_CPUSVN_SIZE) {\n            revert TCBInfo_Invalid();\n        }\n    }\n\n    function _parseV3Tcb(JSONParserLib.Item[] memory tcbComponents)\n        private\n        pure\n        returns (uint8[] memory sgxComponentCpuSvns, uint8[] memory tdxSvns, uint16 pcesvn)\n    {\n        sgxComponentCpuSvns = new uint8[](TCB_CPUSVN_SIZE);\n        tdxSvns = new uint8[](TCB_CPUSVN_SIZE);\n        for (uint256 i = 0; i < tcbComponents.length; i++) {\n            string memory key = JSONParserLib.decodeString(tcbComponents[i].key());\n            if (key.eq(\"pcesvn\")) {\n                pcesvn = uint16(JSONParserLib.parseUint(tcbComponents[i].value()));\n            } else {\n                string memory componentKey = key;\n                JSONParserLib.Item[] memory componentArr = tcbComponents[i].children();\n                uint256 cpusvnCounter = 0;\n                for (uint256 j = 0; j < tcbComponents[i].size(); j++) {\n                    JSONParserLib.Item[] memory component = componentArr[j].children();\n                    for (uint256 k = 0; k < componentArr[j].size(); k++) {\n                        key = JSONParserLib.decodeString(component[k].key());\n                        if (key.eq(\"svn\")) {\n                            if (componentKey.eq(\"tdxtcbcomponents\")) {\n                                tdxSvns[cpusvnCounter++] = uint8(JSONParserLib.parseUint(component[k].value()));\n                            } else {\n                                sgxComponentCpuSvns[cpusvnCounter++] =\n                                    uint8(JSONParserLib.parseUint(component[k].value()));\n                            }\n                        }\n                    }\n                }\n                if (cpusvnCounter != TCB_CPUSVN_SIZE) {\n                    revert TCBInfo_Invalid();\n                }\n            }\n        }\n    }\n\n    function _parseTdxModule(JSONParserLib.Item[] memory tdxModuleObj) private pure returns (TDXModule memory module) {\n        for (uint256 i = 0; i < tdxModuleObj.length; i++) {\n            string memory key = JSONParserLib.decodeString(tdxModuleObj[i].key());\n            string memory val = JSONParserLib.decodeString(tdxModuleObj[i].value());\n            if (key.eq(\"attributes\")) {\n                module.attributes = bytes8(uint64(JSONParserLib.parseUintFromHex(val)));\n            }\n            if (key.eq(\"attributesMask\")) {\n                module.attributesMask = bytes8(uint64(JSONParserLib.parseUintFromHex(val)));\n            }\n            if (key.eq(\"mrsigner\")) {\n                module.mrsigner = _getMrSignerHex(val);\n            }\n        }\n    }\n\n    function _parseTdxModuleIdentities(JSONParserLib.Item[] memory tdxModuleIdentitiesArr)\n        private\n        pure\n        returns (TDXModuleIdentity[] memory identities)\n    {\n        uint256 n = tdxModuleIdentitiesArr.length;\n        identities = new TDXModuleIdentity[](n);\n        for (uint256 i = 0; i < n; i++) {\n            JSONParserLib.Item[] memory currIdentity = tdxModuleIdentitiesArr[i].children();\n            for (uint256 j = 0; j < tdxModuleIdentitiesArr[i].size(); j++) {\n                string memory key = JSONParserLib.decodeString(currIdentity[j].key());\n                if (key.eq(\"id\")) {\n                    string memory val = JSONParserLib.decodeString(currIdentity[j].value());\n                    identities[i].id = val;\n                }\n                if (key.eq(\"mrsigner\")) {\n                    string memory val = JSONParserLib.decodeString(currIdentity[j].value());\n                    identities[i].mrsigner = _getMrSignerHex(val);\n                }\n                if (key.eq(\"attributes\")) {\n                    string memory val = JSONParserLib.decodeString(currIdentity[j].value());\n                    identities[i].attributes = bytes8(uint64(JSONParserLib.parseUintFromHex(val)));\n                }\n                if (key.eq(\"attributesMask\")) {\n                    string memory val = JSONParserLib.decodeString(currIdentity[j].value());\n                    identities[i].attributesMask = bytes8(uint64(JSONParserLib.parseUintFromHex(val)));\n                }\n                if (key.eq(\"tcbLevels\")) {\n                    JSONParserLib.Item[] memory tcbLevelsArr = currIdentity[j].children();\n                    uint256 x = tcbLevelsArr.length;\n                    identities[i].tcbLevels = new TDXModuleTCBLevelsObj[](x);\n                    for (uint256 k = 0; k < x; k++) {\n                        JSONParserLib.Item[] memory tcb = tcbLevelsArr[k].children();\n                        for (uint256 l = 0; l < tcb.length; l++) {\n                            key = JSONParserLib.decodeString(tcb[l].key());\n                            if (key.eq(\"tcb\")) {\n                                JSONParserLib.Item[] memory isvsvnObj = tcb[l].children();\n                                key = JSONParserLib.decodeString(isvsvnObj[0].key());\n                                if (key.eq(\"isvsvn\")) {\n                                    identities[i].tcbLevels[k].isvsvn =\n                                        uint8(JSONParserLib.parseUint(isvsvnObj[0].value()));\n                                } else {\n                                    revert TCBInfo_Invalid();\n                                }\n                            }\n                            if (key.eq(\"tcbDate\")) {\n                                identities[i].tcbLevels[k].tcbDateTimestamp =\n                                    uint64(DateTimeUtils.fromISOToTimestamp(JSONParserLib.decodeString(tcb[l].value())));\n                            }\n                            if (key.eq(\"tcbStatus\")) {\n                                identities[i].tcbLevels[k].status =\n                                    _getTcbStatus(JSONParserLib.decodeString(tcb[l].value()));\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    function _getMrSignerHex(string memory mrSignerStr) private pure returns (bytes memory mrSignerBytes) {\n        string memory mrSignerUpper16BytesStr = mrSignerStr.slice(0, 16);\n        string memory mrSignerLower32BytesStr = mrSignerStr.slice(16, 48);\n        uint256 mrSignerUpperBytes = JSONParserLib.parseUintFromHex(mrSignerUpper16BytesStr);\n        uint256 mrSignerLowerBytes = JSONParserLib.parseUintFromHex(mrSignerLower32BytesStr);\n        mrSignerBytes = abi.encodePacked(uint128(mrSignerUpperBytes), mrSignerLowerBytes);\n    }\n}\n"
    },
    "@automata-network/on-chain-pccs/helpers/PCKHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {X509Helper, X509CertObj, Asn1Decode, NodePtr, BytesUtils} from \"./X509Helper.sol\";\n\n/**\n * @title PCK X509 Certificate Parser\n * @notice This is an extension of the X509Helper library, \n * that parses the SGX Extension ASN.1 sequence as an add-on.\n * @dev This is the default library to be used as a X509 Certificate parser, \n * for all Intel DCAP-related contracts.\n */\n\ncontract PCKHelper is X509Helper {\n    using Asn1Decode for bytes;\n    using NodePtr for uint256;\n    using BytesUtils for bytes;\n\n    // 1.2.840.113741.1.13.1\n    bytes constant SGX_EXTENSION_OID = hex\"2A864886F84D010D01\";\n    // 1.2.840.113741.1.13.1.2\n    bytes constant TCB_OID = hex\"2A864886F84D010D0102\";\n    // 1.2.840.113741.1.13.1.2.17\n    bytes constant PCESVN_OID = hex\"2A864886F84D010D010211\";\n    // 1.2.840.113741.1.13.1.3\n    bytes constant PCEID_OID = hex\"2A864886F84D010D0103\";\n    // 1.2.840.113741.1.13.1.4\n    bytes constant FMSPC_OID = hex\"2A864886F84D010D0104\";\n\n    // https://github.com/intel/SGXDataCenterAttestationPrimitives/blob/e7604e02331b3377f3766ed3653250e03af72d45/QuoteVerification/QVL/Src/AttestationLibrary/src/CertVerification/X509Constants.h#L64\n    uint256 constant SGX_TCB_CPUSVN_SIZE = 16;\n\n    struct PCKTCBFlags {\n        bool fmspcFound;\n        bool pceidFound;\n        bool tcbFound;\n    }\n\n    function parsePckExtension(bytes memory der, uint256 extensionPtr)\n        external\n        pure\n        returns (uint16 pcesvn, uint8[] memory cpusvns, bytes memory fmspcBytes, bytes memory pceidBytes)\n    {\n        if (der[extensionPtr.ixs()] != 0xA3) {\n            revert(\"Not an extension\");\n        }\n        uint256 parentPtr = der.firstChildOf(extensionPtr);\n        uint256 childPtr = der.firstChildOf(parentPtr);\n        bool success;\n        (success, pcesvn, cpusvns, fmspcBytes, pceidBytes) = _findPckTcbInfo(der, childPtr, parentPtr);\n        require(success, \"invalid SGX extension\");\n    }\n\n    function _findPckTcbInfo(bytes memory der, uint256 ptr, uint256 parentPtr)\n        private\n        pure\n        returns (bool success, uint16 pcesvn, uint8[] memory cpusvns, bytes memory fmspcBytes, bytes memory pceidBytes)\n    {\n        // iterate through the elements in the Extension sequence\n        // until we locate the SGX Extension OID\n        while (ptr != 0) {\n            uint256 internalPtr = der.firstChildOf(ptr);\n            if (der[internalPtr.ixs()] != 0x06) {\n                return (false, pcesvn, cpusvns, fmspcBytes, pceidBytes);\n            }\n\n            if (BytesUtils.compareBytes(der.bytesAt(internalPtr), SGX_EXTENSION_OID)) {\n                // 1.2.840.113741.1.13.1\n                internalPtr = der.nextSiblingOf(internalPtr);\n                uint256 extnValueParentPtr = der.rootOfOctetStringAt(internalPtr);\n                uint256 extnValuePtr = der.firstChildOf(extnValueParentPtr);\n\n                // Copy flags to memory to avoid stack too deep\n                PCKTCBFlags memory flags;\n\n                while (!(flags.fmspcFound && flags.pceidFound && flags.tcbFound)) {\n                    uint256 extnValueOidPtr = der.firstChildOf(extnValuePtr);\n                    if (der[extnValueOidPtr.ixs()] != 0x06) {\n                        return (false, pcesvn, cpusvns, fmspcBytes, pceidBytes);\n                    }\n                    if (BytesUtils.compareBytes(der.bytesAt(extnValueOidPtr), TCB_OID)) {\n                        // 1.2.840.113741.1.13.1.2\n                        (flags.tcbFound, pcesvn, cpusvns) = _findTcb(der, extnValueOidPtr);\n                    }\n                    if (BytesUtils.compareBytes(der.bytesAt(extnValueOidPtr), PCEID_OID)) {\n                        // 1.2.840.113741.1.13.1.3\n                        uint256 pceidPtr = der.nextSiblingOf(extnValueOidPtr);\n                        pceidBytes = der.bytesAt(pceidPtr);\n                        flags.pceidFound = true;\n                    }\n                    if (BytesUtils.compareBytes(der.bytesAt(extnValueOidPtr), FMSPC_OID)) {\n                        // 1.2.840.113741.1.13.1.4\n                        uint256 fmspcPtr = der.nextSiblingOf(extnValueOidPtr);\n                        fmspcBytes = der.bytesAt(fmspcPtr);\n                        flags.fmspcFound = true;\n                    }\n\n                    if (extnValuePtr.ixl() < extnValueParentPtr.ixl()) {\n                        extnValuePtr = der.nextSiblingOf(extnValuePtr);\n                    } else {\n                        break;\n                    }\n                }\n                success = flags.fmspcFound && flags.pceidFound && flags.tcbFound;\n                break;\n            }\n\n            if (ptr.ixl() < parentPtr.ixl()) {\n                ptr = der.nextSiblingOf(ptr);\n            } else {\n                ptr = 0; // exit\n            }\n        }\n    }\n\n    function _findTcb(bytes memory der, uint256 oidPtr)\n        private\n        pure\n        returns (bool success, uint16 pcesvn, uint8[] memory cpusvns)\n    {\n        // sibling of tcbOid\n        uint256 tcbPtr = der.nextSiblingOf(oidPtr);\n        // get the first svn object in the sequence\n        uint256 svnParentPtr = der.firstChildOf(tcbPtr);\n        cpusvns = new uint8[](SGX_TCB_CPUSVN_SIZE);\n        for (uint256 i = 0; i < SGX_TCB_CPUSVN_SIZE + 1; i++) {\n            uint256 svnPtr = der.firstChildOf(svnParentPtr); // OID\n            uint256 svnValuePtr = der.nextSiblingOf(svnPtr); // value\n            bytes memory svnValueBytes = der.bytesAt(svnValuePtr);\n            uint16 svnValue =\n                svnValueBytes.length < 2 ? uint16(bytes2(svnValueBytes)) / 256 : uint16(bytes2(svnValueBytes));\n            if (BytesUtils.compareBytes(der.bytesAt(svnPtr), PCESVN_OID)) {\n                // pcesvn is 2 bytes in size\n                pcesvn = uint16(svnValue);\n            } else {\n                uint8 cpusvn = uint8(svnValue);\n                cpusvns[i] = cpusvn;\n            }\n\n            // iterate to the next svn object in the sequence\n            svnParentPtr = der.nextSiblingOf(svnParentPtr);\n        }\n        success = true;\n    }\n}\n"
    },
    "@automata-network/on-chain-pccs/helpers/X509CRLHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Asn1Decode, NodePtr} from \"../utils/Asn1Decode.sol\";\nimport {BytesUtils} from \"../utils/BytesUtils.sol\";\nimport {DateTimeUtils} from \"../utils/DateTimeUtils.sol\";\n\n/**\n * @title Solidity Structure representing X509 CRL\n * @notice This is a simplified structure of a DER-decoded X509 CRL\n */\nstruct X509CRLObj {\n    uint256 serialNumber;\n    string issuerCommonName;\n    uint256 validityNotBefore;\n    uint256 validityNotAfter;\n    uint256[] serialNumbersRevoked;\n    // for signature verification in the cert chain\n    bytes signature;\n    bytes tbs;\n}\n\n/**\n * @title X509 CRL Helper Contract\n * @notice This is a standalone contract that can be used by off-chain applications and smart contracts\n * to parse DER-encoded CRLs.\n * @dev This parser is only valid for ECDSA signature algorithm and p256 key algorithm.\n */\ncontract X509CRLHelper {\n    using Asn1Decode for bytes;\n    using NodePtr for uint256;\n    using BytesUtils for bytes;\n\n    // 2.5.29.20\n    bytes constant CRL_NUMBER_OID = hex\"551d14\";\n\n    /// =================================================================================\n    /// USE THE GETTERS BELOW IF YOU DON'T WANT TO PARSE THE ENTIRE X509 CRL\n    /// =================================================================================\n\n    function getTbsAndSig(bytes calldata der) external pure returns (bytes memory tbs, bytes memory sig) {\n        uint256 root = der.root();\n        uint256 tbsParentPtr = der.firstChildOf(root);\n        uint256 sigPtr = der.nextSiblingOf(tbsParentPtr);\n        sigPtr = der.nextSiblingOf(sigPtr);\n\n        tbs = der.allBytesAt(tbsParentPtr);\n        sig = _getSignature(der, sigPtr);\n    }\n\n    function getSerialNumber(bytes calldata der) external pure returns (uint256 serialNum) {\n        uint256 root = der.root();\n        uint256 tbsParentPtr = der.firstChildOf(root);\n        uint256 tbsPtr = der.firstChildOf(tbsParentPtr);\n        serialNum = _parseSerialNumber(der.bytesAt(tbsPtr));\n    }\n\n    function getIssuerCommonName(bytes calldata der) external pure returns (string memory issuerCommonName) {\n        uint256 root = der.root();\n        uint256 tbsParentPtr = der.firstChildOf(root);\n        uint256 tbsPtr = der.firstChildOf(tbsParentPtr);\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        issuerCommonName = _getCommonName(der, der.firstChildOf(tbsPtr));\n    }\n\n    function crlIsNotExpired(bytes calldata der) external view returns (bool isValid) {\n        uint256 root = der.root();\n        uint256 tbsParentPtr = der.firstChildOf(root);\n        uint256 tbsPtr = der.firstChildOf(tbsParentPtr);\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        (uint256 validityNotBefore, uint256 validityNotAfter) = _getValidity(der, tbsPtr);\n        isValid = block.timestamp > validityNotBefore && block.timestamp < validityNotAfter;\n    }\n\n    function serialNumberIsRevoked(uint256 serialNumber, bytes calldata der) external pure returns (bool revoked) {\n        uint256 root = der.root();\n        uint256 tbsParentPtr = der.firstChildOf(root);\n        uint256 tbsPtr = der.firstChildOf(tbsParentPtr);\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        uint256[] memory ret = _getRevokedSerialNumbers(der, tbsPtr, true, serialNumber);\n        revoked = ret[0] == serialNumber;\n    }\n\n    /// x509 CRL generally contain a sequence of elements in the following order:\n    /// 1. tbs\n    /// - 1a. serial number\n    /// - 1b. signature algorithm\n    /// - 1c. issuer\n    /// - - 1c(a). common name\n    /// - - 1c(b). organization name\n    /// - - 1c(c). locality name\n    /// - - 1c(d). state or province name\n    /// - - 1c(e). country name\n    /// - 1d. not before\n    /// - 1e. not after\n    /// - 1f. revoked certificates\n    /// - - A list consists of revoked serial numbers and reasons.\n    /// - 1g. CRL extensions\n    /// - - 1g(a) CRL number\n    /// - - 1g(b) Authority Key Identifier\n    /// 2. Signature Algorithm\n    /// 3. Signature\n    function parseCRLDER(bytes calldata der) external pure returns (X509CRLObj memory crl) {\n        uint256 root = der.root();\n\n        uint256 tbsParentPtr = der.firstChildOf(root);\n\n        uint256 tbsPtr = der.firstChildOf(tbsParentPtr);\n\n        crl.serialNumber = uint256(bytes32(der.bytesAt(tbsPtr)));\n\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n\n        crl.issuerCommonName = _getCommonName(der, der.firstChildOf(tbsPtr));\n\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        (crl.validityNotBefore, crl.validityNotAfter) = _getValidity(der, tbsPtr);\n\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n\n        crl.serialNumbersRevoked = _getRevokedSerialNumbers(der, tbsPtr, false, 0);\n\n        // tbs iteration completed\n        // now we just need to look for the signature\n\n        uint256 sigPtr = der.nextSiblingOf(tbsParentPtr);\n        sigPtr = der.nextSiblingOf(sigPtr);\n        crl.signature = _getSignature(der, sigPtr);\n    }\n\n    function _getCommonName(bytes calldata der, uint256 commonNameParentPtr)\n        private\n        pure\n        returns (string memory commonName)\n    {\n        commonNameParentPtr = der.firstChildOf(commonNameParentPtr);\n        commonNameParentPtr = der.firstChildOf(commonNameParentPtr);\n        commonNameParentPtr = der.nextSiblingOf(commonNameParentPtr);\n        commonName = string(der.bytesAt(commonNameParentPtr));\n    }\n\n    function _getValidity(bytes calldata der, uint256 validityPtr)\n        private\n        pure\n        returns (uint256 notBefore, uint256 notAfter)\n    {\n        uint256 notBeforePtr = validityPtr;\n        uint256 notAfterPtr = der.nextSiblingOf(notBeforePtr);\n        notBefore = DateTimeUtils.fromDERToTimestamp(der.bytesAt(notBeforePtr));\n        notAfter = DateTimeUtils.fromDERToTimestamp(der.bytesAt(notAfterPtr));\n    }\n\n    function _getRevokedSerialNumbers(bytes calldata der, uint256 revokedParentPtr, bool breakIfFound, uint256 filter)\n        private\n        pure\n        returns (uint256[] memory serialNumbers)\n    {\n        uint256 revokedPtr = der.firstChildOf(revokedParentPtr);\n\n        if (der[revokedPtr.ixs()] == 0xA0) {\n            uint256 crlExtensionPtr = der.firstChildOf(revokedPtr);\n            require(BytesUtils.compareBytes(der.bytesAt(crlExtensionPtr), CRL_NUMBER_OID), \"invalid CRL\");\n        } else {\n            bytes memory serials;\n            while (revokedPtr.ixl() <= revokedParentPtr.ixl()) {\n                uint256 serialPtr = der.firstChildOf(revokedPtr);\n                bytes memory serialBytes = der.bytesAt(serialPtr);\n                uint256 serialNumber = _parseSerialNumber(serialBytes);\n                serials = abi.encodePacked(serials, serialNumber);\n                if (breakIfFound && filter == serialNumber) {\n                    serialNumbers = new uint256[](1);\n                    serialNumbers[0] = filter;\n                    return serialNumbers;\n                }\n                revokedPtr = der.nextSiblingOf(revokedPtr);\n            }\n            uint256 count = serials.length / 32;\n            // ABI encoding format for a dynamic uint256[] value\n            serials = abi.encodePacked(abi.encode(0x20), abi.encode(count), serials);\n            serialNumbers = new uint256[](count);\n            serialNumbers = abi.decode(serials, (uint256[]));\n        }\n    }\n\n    function _parseSerialNumber(bytes memory serialBytes) private pure returns (uint256 serial) {\n        uint256 shift = 8 * (32 - serialBytes.length);\n        serial = uint256(bytes32(serialBytes) >> shift);\n    }\n\n    function _getSignature(bytes calldata der, uint256 sigPtr) private pure returns (bytes memory sig) {\n        sigPtr = der.rootOfBitStringAt(sigPtr);\n\n        sigPtr = der.firstChildOf(sigPtr);\n        bytes memory r = _trimBytes(der.bytesAt(sigPtr), 32);\n\n        sigPtr = der.nextSiblingOf(sigPtr);\n        bytes memory s = _trimBytes(der.bytesAt(sigPtr), 32);\n\n        sig = abi.encodePacked(r, s);\n    }\n\n    /// @dev remove unnecessary prefix from the input\n    function _trimBytes(bytes memory input, uint256 expectedLength) private pure returns (bytes memory output) {\n        uint256 n = input.length;\n        if (n == expectedLength) {\n            output = input;\n        } else if (n < expectedLength) {\n            output = new bytes(expectedLength);\n            uint256 padLength = expectedLength - n;\n            for (uint256 i = 0; i < n; i++) {\n                output[padLength + i] = input[i];\n            }\n        } else {\n            uint256 lengthDiff = n - expectedLength;\n            output = input.substring(lengthDiff, expectedLength);\n        }\n    }\n}\n"
    },
    "@automata-network/on-chain-pccs/helpers/X509Helper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Asn1Decode, NodePtr} from \"../utils/Asn1Decode.sol\";\nimport {BytesUtils} from \"../utils/BytesUtils.sol\";\nimport {DateTimeUtils} from \"../utils/DateTimeUtils.sol\";\n\n/**\n * @title Solidity Structure representing X509 Certificates\n * @notice This is a simplified structure of a DER-decoded X509 Certificate\n */\nstruct X509CertObj {\n    uint256 serialNumber;\n    string issuerCommonName;\n    uint256 validityNotBefore;\n    uint256 validityNotAfter;\n    string subjectCommonName;\n    bytes subjectPublicKey;\n    // the extension needs to be parsed further for PCK Certificates\n    uint256 extensionPtr;\n    // for signature verification in the cert chain\n    bytes signature;\n    bytes tbs;\n}\n\n/**\n * @title X509 Certificates Helper Contract\n * @notice This is a standalone contract that can be used by off-chain applications and smart contracts\n * to parse DER-encoded X509 certificates.\n * @dev This parser is only valid for ECDSA signature algorithm and p256 key algorithm.\n */\ncontract X509Helper {\n    using Asn1Decode for bytes;\n    using NodePtr for uint256;\n    using BytesUtils for bytes;\n\n    /// =================================================================================\n    /// USE THE GETTERS BELOW IF YOU DON'T WANT TO PARSE THE ENTIRE X509 CERTIFICATE\n    /// =================================================================================\n\n    function getTbsAndSig(bytes calldata der) external pure returns (bytes memory tbs, bytes memory sig) {\n        uint256 root = der.root();\n        uint256 tbsParentPtr = der.firstChildOf(root);\n        uint256 sigPtr = der.nextSiblingOf(tbsParentPtr);\n        sigPtr = der.nextSiblingOf(sigPtr);\n\n        tbs = der.allBytesAt(tbsParentPtr);\n        sig = _getSignature(der, sigPtr);\n    }\n\n    function getSerialNumber(bytes calldata der) external pure returns (uint256 serialNum) {\n        uint256 root = der.root();\n        uint256 tbsParentPtr = der.firstChildOf(root);\n        uint256 tbsPtr = der.firstChildOf(tbsParentPtr);\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        serialNum = _parseSerialNumber(der.bytesAt(tbsPtr));\n    }\n\n    function getIssuerCommonName(bytes calldata der) external pure returns (string memory issuerCommonName) {\n        uint256 root = der.root();\n        uint256 tbsParentPtr = der.firstChildOf(root);\n        uint256 tbsPtr = der.firstChildOf(tbsParentPtr);\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        issuerCommonName = _getCommonName(der, der.firstChildOf(tbsPtr));\n    }\n\n    function certIsNotExpired(bytes calldata der) external view returns (bool isValid) {\n        uint256 root = der.root();\n        uint256 tbsParentPtr = der.firstChildOf(root);\n        uint256 tbsPtr = der.firstChildOf(tbsParentPtr);\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        (uint256 validityNotBefore, uint256 validityNotAfter) = _getValidity(der, tbsPtr);\n        isValid = block.timestamp > validityNotBefore && block.timestamp < validityNotAfter;\n    }\n\n    function getSubjectCommonName(bytes calldata der) external pure returns (string memory subjectCommonName) {\n        uint256 root = der.root();\n        uint256 tbsParentPtr = der.firstChildOf(root);\n        uint256 tbsPtr = der.firstChildOf(tbsParentPtr);\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        subjectCommonName = _getCommonName(der, der.firstChildOf(tbsPtr));\n    }\n\n    function getSubjectPublicKey(bytes calldata der) external pure returns (bytes memory pubKey) {\n        uint256 root = der.root();\n        uint256 tbsParentPtr = der.firstChildOf(root);\n        uint256 tbsPtr = der.firstChildOf(tbsParentPtr);\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        pubKey = _getSubjectPublicKey(der, der.firstChildOf(tbsPtr));\n    }\n\n    /// x509 Certificates generally contain a sequence of elements in the following order:\n    /// 1. tbs\n    /// - 1a. version\n    /// - 1b. serial number\n    /// - 1c. siganture algorithm\n    /// - 1d. issuer\n    /// - - 1d(a). common name\n    /// - - 1d(b). organization name\n    /// - - 1d(c). locality name\n    /// - - 1d(d). state or province name\n    /// - - 1d(e). country name\n    /// - 1e. validity\n    /// - - 1e(a) notBefore\n    /// - - 1e(b) notAfter\n    /// - 1f. subject\n    /// - - contains the same set of elements as 1d\n    /// - 1g. subject public key info\n    /// - - 1g(a). algorithm\n    /// - - 1g(b). subject public key\n    /// - 1h. Extensions\n    /// 2. Signature Algorithm\n    /// 3. Signature\n    function parseX509DER(bytes calldata der) external pure returns (X509CertObj memory cert) {\n        uint256 root = der.root();\n\n        uint256 tbsParentPtr = der.firstChildOf(root);\n        cert.tbs = der.allBytesAt(tbsParentPtr);\n\n        uint256 tbsPtr = der.firstChildOf(tbsParentPtr);\n\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n\n        cert.serialNumber = _parseSerialNumber(der.bytesAt(tbsPtr));\n\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n\n        cert.issuerCommonName = _getCommonName(der, der.firstChildOf(tbsPtr));\n\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        (cert.validityNotBefore, cert.validityNotAfter) = _getValidity(der, tbsPtr);\n\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n\n        cert.subjectCommonName = _getCommonName(der, der.firstChildOf(tbsPtr));\n\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        cert.subjectPublicKey = _getSubjectPublicKey(der, der.firstChildOf(tbsPtr));\n\n        cert.extensionPtr = der.nextSiblingOf(tbsPtr);\n\n        // tbs iteration completed\n        // now we just need to look for the signature\n\n        uint256 sigPtr = der.nextSiblingOf(tbsParentPtr);\n        sigPtr = der.nextSiblingOf(sigPtr);\n        cert.signature = _getSignature(der, sigPtr);\n    }\n\n    function _getCommonName(bytes calldata der, uint256 commonNameParentPtr)\n        private\n        pure\n        returns (string memory commonName)\n    {\n        commonNameParentPtr = der.firstChildOf(commonNameParentPtr);\n        commonNameParentPtr = der.firstChildOf(commonNameParentPtr);\n        commonNameParentPtr = der.nextSiblingOf(commonNameParentPtr);\n        commonName = string(der.bytesAt(commonNameParentPtr));\n    }\n\n    function _getValidity(bytes calldata der, uint256 validityPtr)\n        private\n        pure\n        returns (uint256 notBefore, uint256 notAfter)\n    {\n        uint256 notBeforePtr = der.firstChildOf(validityPtr);\n        uint256 notAfterPtr = der.nextSiblingOf(notBeforePtr);\n        notBefore = DateTimeUtils.fromDERToTimestamp(der.bytesAt(notBeforePtr));\n        notAfter = DateTimeUtils.fromDERToTimestamp(der.bytesAt(notAfterPtr));\n    }\n\n    function _getSubjectPublicKey(bytes calldata der, uint256 subjectPublicKeyInfoPtr)\n        private\n        pure\n        returns (bytes memory pubKey)\n    {\n        subjectPublicKeyInfoPtr = der.nextSiblingOf(subjectPublicKeyInfoPtr);\n        pubKey = der.bitstringAt(subjectPublicKeyInfoPtr);\n        if (pubKey.length != 65) {\n            // TODO: we need to figure out how to handle key with prefix byte 0x02 or 0x03\n            revert(\"compressed public key not supported\");\n        }\n        pubKey = _trimBytes(pubKey, 64);\n    }\n\n    function _parseSerialNumber(bytes memory serialBytes) private pure returns (uint256 serial) {\n        uint256 shift = 8 * (32 - serialBytes.length);\n        serial = uint256(bytes32(serialBytes) >> shift);\n    }\n\n    function _getSignature(bytes calldata der, uint256 sigPtr) private pure returns (bytes memory sig) {\n        sigPtr = der.rootOfBitStringAt(sigPtr);\n\n        sigPtr = der.firstChildOf(sigPtr);\n        bytes memory r = _trimBytes(der.bytesAt(sigPtr), 32);\n\n        sigPtr = der.nextSiblingOf(sigPtr);\n        bytes memory s = _trimBytes(der.bytesAt(sigPtr), 32);\n\n        sig = abi.encodePacked(r, s);\n    }\n\n    /// @dev remove unnecessary prefix from the input\n    function _trimBytes(bytes memory input, uint256 expectedLength) private pure returns (bytes memory output) {\n        uint256 n = input.length;\n        if (n == expectedLength) {\n            output = input;\n        } else if (n < expectedLength) {\n            output = new bytes(expectedLength);\n            uint256 padLength = expectedLength - n;\n            for (uint256 i = 0; i < n; i++) {\n                output[padLength + i] = input[i];\n            }\n        } else {\n            uint256 lengthDiff = n - expectedLength;\n            output = input.substring(lengthDiff, expectedLength);\n        }\n    }\n}\n"
    },
    "@automata-network/on-chain-pccs/interfaces/IDaoAttestationResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n/**\n * @title PCCS Data Access Object (DAO) Resolver\n * @notice The resolver associates a collateral key with an attestation ID,\n * which points to the collateral data that can either be stored interanlly in the\n * Resolver contract or to an attestation registry, such as EAS.\n * @notice The Resolver is intended to be deployed only ONCE and must be permanently immutable\n * @notice Future upgrades/re-deployments of all other PCCS contracts can simply point to this Resolver\n * to retain collateral data.\n */\n\ninterface IDaoAttestationResolver {\n    /**\n     * @param key - identifies a specific collateral. Definition varies by DAO\n     * @return collateralAttId - the attestation ID of the collateral\n     */\n    function collateralPointer(bytes32 key) external view returns (bytes32 collateralAttId);\n\n    /**\n     * @notice the hash of the collateral is RECOMMENDED to be stored as a separate attestation\n     * @dev optimizes SLOAD read cost for checking collateral correctness. (Reading the entire collateral vs 32-byte hash)\n     * @param key - identifies a specific collateral. Definition varies by DAO\n     */\n    function collateralHashPointer(bytes32 key) external view returns (bytes32 collateralHashAttId);\n\n    /**\n     * @notice writes collateral data on-chain\n     * @param key - identifies a specific collateral. Definition varies by DAO\n     * @param attData - serialized collateral data\n     * @param attDataHash - hash of attData\n     * @return attestationId - the ID to retrieve attData\n     * @return hashAttestationid - the ID to retrieve the hash of attData\n     */\n    function attest(bytes32 key, bytes calldata attData, bytes32 attDataHash)\n        external\n        returns (bytes32 attestationId, bytes32 hashAttestationid);\n\n    /**\n     * @param attestationId - identifier that is assigned to the data upon attestation\n     */\n    function readAttestation(bytes32 attestationId) external view returns (bytes memory attData);\n}\n"
    },
    "@automata-network/on-chain-pccs/utils/Asn1Decode.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Original source: https://github.com/JonahGroendal/asn1-decode\npragma solidity ^0.8.0;\n\n// Inspired by PufferFinance/rave\n// https://github.com/JonahGroendal/asn1-decode/blob/5c2d1469fc678513753786acb441e597969192ec/contracts/Asn1Decode.sol\n\nimport \"./BytesUtils.sol\";\n\nlibrary NodePtr {\n    // Unpack first byte index\n    function ixs(uint256 self) internal pure returns (uint256) {\n        return uint80(self);\n    }\n    // Unpack first content byte index\n\n    function ixf(uint256 self) internal pure returns (uint256) {\n        return uint80(self >> 80);\n    }\n    // Unpack last content byte index\n\n    function ixl(uint256 self) internal pure returns (uint256) {\n        return uint80(self >> 160);\n    }\n    // Pack 3 uint80s into a uint256\n\n    function getPtr(uint256 _ixs, uint256 _ixf, uint256 _ixl) internal pure returns (uint256) {\n        _ixs |= _ixf << 80;\n        _ixs |= _ixl << 160;\n        return _ixs;\n    }\n}\n\nlibrary Asn1Decode {\n    using NodePtr for uint256;\n    using BytesUtils for bytes;\n\n    /*\n    * @dev Get the root node. First step in traversing an ASN1 structure\n    * @param der The DER-encoded ASN1 structure\n    * @return A pointer to the outermost node\n    */\n    function root(bytes memory der) internal pure returns (uint256) {\n        return readNodeLength(der, 0);\n    }\n\n    /*\n    * @dev Get the root node of an ASN1 structure that's within a bit string value\n    * @param der The DER-encoded ASN1 structure\n    * @return A pointer to the outermost node\n    */\n    function rootOfBitStringAt(bytes memory der, uint256 ptr) internal pure returns (uint256) {\n        require(der[ptr.ixs()] == 0x03, \"Not type BIT STRING\");\n        return readNodeLength(der, ptr.ixf() + 1);\n    }\n\n    /*\n    * @dev Get the root node of an ASN1 structure that's within an octet string value\n    * @param der The DER-encoded ASN1 structure\n    * @return A pointer to the outermost node\n    */\n    function rootOfOctetStringAt(bytes memory der, uint256 ptr) internal pure returns (uint256) {\n        require(der[ptr.ixs()] == 0x04, \"Not type OCTET STRING\");\n        return readNodeLength(der, ptr.ixf());\n    }\n\n    /*\n    * @dev Get the next sibling node\n    * @param der The DER-encoded ASN1 structure\n    * @param ptr Points to the indices of the current node\n    * @return A pointer to the next sibling node\n    */\n    function nextSiblingOf(bytes memory der, uint256 ptr) internal pure returns (uint256) {\n        return readNodeLength(der, ptr.ixl() + 1);\n    }\n\n    /*\n    * @dev Get the first child node of the current node\n    * @param der The DER-encoded ASN1 structure\n    * @param ptr Points to the indices of the current node\n    * @return A pointer to the first child node\n    */\n    function firstChildOf(bytes memory der, uint256 ptr) internal pure returns (uint256) {\n        require(der[ptr.ixs()] & 0x20 == 0x20, \"Not a constructed type\");\n        return readNodeLength(der, ptr.ixf());\n    }\n\n    /*\n    * @dev Use for looping through children of a node (either i or j).\n    * @param i Pointer to an ASN1 node\n    * @param j Pointer to another ASN1 node of the same ASN1 structure\n    * @return True iff j is child of i or i is child of j.\n    */\n    function isChildOf(uint256 i, uint256 j) internal pure returns (bool) {\n        return (((i.ixf() <= j.ixs()) && (j.ixl() <= i.ixl())) || ((j.ixf() <= i.ixs()) && (i.ixl() <= j.ixl())));\n    }\n\n    /*\n    * @dev Extract value of node from DER-encoded structure\n    * @param der The der-encoded ASN1 structure\n    * @param ptr Points to the indices of the current node\n    * @return Value bytes of node\n    */\n    function bytesAt(bytes memory der, uint256 ptr) internal pure returns (bytes memory) {\n        return der.substring(ptr.ixf(), ptr.ixl() + 1 - ptr.ixf());\n    }\n\n    /*\n    * @dev Extract entire node from DER-encoded structure\n    * @param der The DER-encoded ASN1 structure\n    * @param ptr Points to the indices of the current node\n    * @return All bytes of node\n    */\n    function allBytesAt(bytes memory der, uint256 ptr) internal pure returns (bytes memory) {\n        return der.substring(ptr.ixs(), ptr.ixl() + 1 - ptr.ixs());\n    }\n\n    /*\n    * @dev Extract value of node from DER-encoded structure\n    * @param der The DER-encoded ASN1 structure\n    * @param ptr Points to the indices of the current node\n    * @return Value bytes of node as bytes32\n    */\n    function bytes32At(bytes memory der, uint256 ptr) internal pure returns (bytes32) {\n        return der.readBytesN(ptr.ixf(), ptr.ixl() + 1 - ptr.ixf());\n    }\n\n    /*\n    * @dev Extract value of node from DER-encoded structure\n    * @param der The der-encoded ASN1 structure\n    * @param ptr Points to the indices of the current node\n    * @return Uint value of node\n    */\n    function uintAt(bytes memory der, uint256 ptr) internal pure returns (uint256) {\n        require(der[ptr.ixs()] == 0x02, \"Not type INTEGER\");\n        require(der[ptr.ixf()] & 0x80 == 0, \"Not positive\");\n        uint256 len = ptr.ixl() + 1 - ptr.ixf();\n        return uint256(der.readBytesN(ptr.ixf(), len) >> (32 - len) * 8);\n    }\n\n    /*\n    * @dev Extract value of a positive integer node from DER-encoded structure\n    * @param der The DER-encoded ASN1 structure\n    * @param ptr Points to the indices of the current node\n    * @return Value bytes of a positive integer node\n    */\n    function uintBytesAt(bytes memory der, uint256 ptr) internal pure returns (bytes memory) {\n        require(der[ptr.ixs()] == 0x02, \"Not type INTEGER\");\n        require(der[ptr.ixf()] & 0x80 == 0, \"Not positive\");\n        uint256 valueLength = ptr.ixl() + 1 - ptr.ixf();\n        if (der[ptr.ixf()] == 0) {\n            return der.substring(ptr.ixf() + 1, valueLength - 1);\n        } else {\n            return der.substring(ptr.ixf(), valueLength);\n        }\n    }\n\n    function keccakOfBytesAt(bytes memory der, uint256 ptr) internal pure returns (bytes32) {\n        return der.keccak(ptr.ixf(), ptr.ixl() + 1 - ptr.ixf());\n    }\n\n    function keccakOfAllBytesAt(bytes memory der, uint256 ptr) internal pure returns (bytes32) {\n        return der.keccak(ptr.ixs(), ptr.ixl() + 1 - ptr.ixs());\n    }\n\n    /*\n    * @dev Extract value of bitstring node from DER-encoded structure\n    * @param der The DER-encoded ASN1 structure\n    * @param ptr Points to the indices of the current node\n    * @return Value of bitstring converted to bytes\n    */\n    function bitstringAt(bytes memory der, uint256 ptr) internal pure returns (bytes memory) {\n        require(der[ptr.ixs()] == 0x03, \"Not type BIT STRING\");\n        // Only 00 padded bitstr can be converted to bytestr!\n        require(der[ptr.ixf()] == 0x00);\n        uint256 valueLength = ptr.ixl() + 1 - ptr.ixf();\n        return der.substring(ptr.ixf() + 1, valueLength - 1);\n    }\n\n    function readNodeLength(bytes memory der, uint256 ix) private pure returns (uint256) {\n        uint256 length;\n        uint80 ixFirstContentByte;\n        uint80 ixLastContentByte;\n        if ((der[ix + 1] & 0x80) == 0) {\n            length = uint8(der[ix + 1]);\n            ixFirstContentByte = uint80(ix + 2);\n            ixLastContentByte = uint80(ixFirstContentByte + length - 1);\n        } else {\n            uint8 lengthbytesLength = uint8(der[ix + 1] & 0x7F);\n            if (lengthbytesLength == 1) {\n                length = der.readUint8(ix + 2);\n            } else if (lengthbytesLength == 2) {\n                length = der.readUint16(ix + 2);\n            } else {\n                length = uint256(der.readBytesN(ix + 2, lengthbytesLength) >> (32 - lengthbytesLength) * 8);\n            }\n            ixFirstContentByte = uint80(ix + 2 + lengthbytesLength);\n            ixLastContentByte = uint80(ixFirstContentByte + length - 1);\n        }\n        return NodePtr.getPtr(ix, ixFirstContentByte, ixLastContentByte);\n    }\n}\n"
    },
    "@automata-network/on-chain-pccs/utils/BytesUtils.sol": {
      "content": "// SPDX-License-Identifier: BSD 2-Clause License\npragma solidity ^0.8.0;\n\n// Inspired by ensdomains/dnssec-oracle - BSD-2-Clause license\n// https://github.com/ensdomains/dnssec-oracle/blob/master/contracts/BytesUtils.sol\n\nlibrary BytesUtils {\n    /*\n    * @dev Returns the keccak-256 hash of a byte range.\n    * @param self The byte string to hash.\n    * @param offset The position to start hashing at.\n    * @param len The number of bytes to hash.\n    * @return The hash of the byte range.\n    */\n    function keccak(bytes memory self, uint256 offset, uint256 len) internal pure returns (bytes32 ret) {\n        require(offset + len <= self.length);\n        assembly {\n            ret := keccak256(add(add(self, 32), offset), len)\n        }\n    }\n\n    /*\n    * @dev Returns a positive number if `other` comes lexicographically after\n    *      `self`, a negative number if it comes before, or zero if the\n    *      contents of the two bytes are equal.\n    * @param self The first bytes to compare.\n    * @param other The second bytes to compare.\n    * @return The result of the comparison.\n    */\n    function compare(bytes memory self, bytes memory other) internal pure returns (int256) {\n        return compare(self, 0, self.length, other, 0, other.length);\n    }\n\n    /*\n    * @dev Returns a positive number if `other` comes lexicographically after\n    *      `self`, a negative number if it comes before, or zero if the\n    *      contents of the two bytes are equal. Comparison is done per-rune,\n    *      on unicode codepoints.\n    * @param self The first bytes to compare.\n    * @param offset The offset of self.\n    * @param len    The length of self.\n    * @param other The second bytes to compare.\n    * @param otheroffset The offset of the other string.\n    * @param otherlen    The length of the other string.\n    * @return The result of the comparison.\n    */\n    function compare(\n        bytes memory self,\n        uint256 offset,\n        uint256 len,\n        bytes memory other,\n        uint256 otheroffset,\n        uint256 otherlen\n    ) internal pure returns (int256) {\n        uint256 shortest = len;\n        if (otherlen < len) {\n            shortest = otherlen;\n        }\n\n        uint256 selfptr;\n        uint256 otherptr;\n\n        assembly {\n            selfptr := add(self, add(offset, 32))\n            otherptr := add(other, add(otheroffset, 32))\n        }\n        for (uint256 idx = 0; idx < shortest; idx += 32) {\n            uint256 a;\n            uint256 b;\n            assembly {\n                a := mload(selfptr)\n                b := mload(otherptr)\n            }\n            if (a != b) {\n                // Mask out irrelevant bytes and check again\n                uint256 mask;\n                if (shortest > 32) {\n                    mask = type(uint256).max; // aka 0xffffff....\n                } else {\n                    mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);\n                }\n                uint256 diff = (a & mask) - (b & mask);\n                if (diff != 0) {\n                    return int256(diff);\n                }\n            }\n            selfptr += 32;\n            otherptr += 32;\n        }\n\n        return int256(len) - int256(otherlen);\n    }\n\n    /*\n    * @dev Returns true if the two byte ranges are equal.\n    * @param self The first byte range to compare.\n    * @param offset The offset into the first byte range.\n    * @param other The second byte range to compare.\n    * @param otherOffset The offset into the second byte range.\n    * @param len The number of bytes to compare\n    * @return True if the byte ranges are equal, false otherwise.\n    */\n    function equals(bytes memory self, uint256 offset, bytes memory other, uint256 otherOffset, uint256 len)\n        internal\n        pure\n        returns (bool)\n    {\n        return keccak(self, offset, len) == keccak(other, otherOffset, len);\n    }\n\n    /*\n    * @dev Returns true if the two byte ranges are equal with offsets.\n    * @param self The first byte range to compare.\n    * @param offset The offset into the first byte range.\n    * @param other The second byte range to compare.\n    * @param otherOffset The offset into the second byte range.\n    * @return True if the byte ranges are equal, false otherwise.\n    */\n    function equals(bytes memory self, uint256 offset, bytes memory other, uint256 otherOffset)\n        internal\n        pure\n        returns (bool)\n    {\n        return keccak(self, offset, self.length - offset) == keccak(other, otherOffset, other.length - otherOffset);\n    }\n\n    /*\n    * @dev Compares a range of 'self' to all of 'other' and returns True iff\n    *      they are equal.\n    * @param self The first byte range to compare.\n    * @param offset The offset into the first byte range.\n    * @param other The second byte range to compare.\n    * @return True if the byte ranges are equal, false otherwise.\n    */\n    function equals(bytes memory self, uint256 offset, bytes memory other) internal pure returns (bool) {\n        return self.length >= offset + other.length && equals(self, offset, other, 0, other.length);\n    }\n\n    /*\n    * @dev Returns true if the two byte ranges are equal.\n    * @param self The first byte range to compare.\n    * @param other The second byte range to compare.\n    * @return True if the byte ranges are equal, false otherwise.\n    */\n    function equals(bytes memory self, bytes memory other) internal pure returns (bool) {\n        return self.length == other.length && equals(self, 0, other, 0, self.length);\n    }\n\n    /*\n    * @dev Returns the 8-bit number at the specified index of self.\n    * @param self The byte string.\n    * @param idx The index into the bytes\n    * @return The specified 8 bits of the string, interpreted as an integer.\n    */\n    function readUint8(bytes memory self, uint256 idx) internal pure returns (uint8 ret) {\n        return uint8(self[idx]);\n    }\n\n    /*\n    * @dev Returns the 16-bit number at the specified index of self.\n    * @param self The byte string.\n    * @param idx The index into the bytes\n    * @return The specified 16 bits of the string, interpreted as an integer.\n    */\n    function readUint16(bytes memory self, uint256 idx) internal pure returns (uint16 ret) {\n        require(idx + 2 <= self.length);\n        assembly {\n            ret := and(mload(add(add(self, 2), idx)), 0xFFFF)\n        }\n    }\n\n    /*\n    * @dev Returns the 32-bit number at the specified index of self.\n    * @param self The byte string.\n    * @param idx The index into the bytes\n    * @return The specified 32 bits of the string, interpreted as an integer.\n    */\n    function readUint32(bytes memory self, uint256 idx) internal pure returns (uint32 ret) {\n        require(idx + 4 <= self.length);\n        assembly {\n            ret := and(mload(add(add(self, 4), idx)), 0xFFFFFFFF)\n        }\n    }\n\n    /*\n    * @dev Returns the 32 byte value at the specified index of self.\n    * @param self The byte string.\n    * @param idx The index into the bytes\n    * @return The specified 32 bytes of the string.\n    */\n    function readBytes32(bytes memory self, uint256 idx) internal pure returns (bytes32 ret) {\n        require(idx + 32 <= self.length);\n        assembly {\n            ret := mload(add(add(self, 32), idx))\n        }\n    }\n\n    /*\n    * @dev Returns the 32 byte value at the specified index of self.\n    * @param self The byte string.\n    * @param idx The index into the bytes\n    * @return The specified 32 bytes of the string.\n    */\n    function readBytes20(bytes memory self, uint256 idx) internal pure returns (bytes20 ret) {\n        require(idx + 20 <= self.length);\n        assembly {\n            ret :=\n                and(mload(add(add(self, 32), idx)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000000)\n        }\n    }\n\n    /*\n    * @dev Returns the n byte value at the specified index of self.\n    * @param self The byte string.\n    * @param idx The index into the bytes.\n    * @param len The number of bytes.\n    * @return The specified 32 bytes of the string.\n    */\n    function readBytesN(bytes memory self, uint256 idx, uint256 len) internal pure returns (bytes32 ret) {\n        require(len <= 32);\n        require(idx + len <= self.length);\n        assembly {\n            let mask := not(sub(exp(256, sub(32, len)), 1))\n            ret := and(mload(add(add(self, 32), idx)), mask)\n        }\n    }\n\n    function memcpy(uint256 dest, uint256 src, uint256 len) private pure {\n        // Copy word-length chunks while possible\n        for (; len >= 32; len -= 32) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }\n\n        // Copy remaining bytes\n        uint256 mask;\n        if (len == 0) {\n            mask = type(uint256).max; // Set to maximum value of uint256\n        } else {\n            mask = 256 ** (32 - len) - 1;\n        }\n\n        assembly {\n            let srcpart := and(mload(src), not(mask))\n            let destpart := and(mload(dest), mask)\n            mstore(dest, or(destpart, srcpart))\n        }\n    }\n\n    /*\n    * @dev Copies a substring into a new byte string.\n    * @param self The byte string to copy from.\n    * @param offset The offset to start copying at.\n    * @param len The number of bytes to copy.\n    */\n    function substring(bytes memory self, uint256 offset, uint256 len) internal pure returns (bytes memory) {\n        require(offset + len <= self.length);\n\n        bytes memory ret = new bytes(len);\n        uint256 dest;\n        uint256 src;\n\n        assembly {\n            dest := add(ret, 32)\n            src := add(add(self, 32), offset)\n        }\n        memcpy(dest, src, len);\n\n        return ret;\n    }\n\n    // Maps characters from 0x30 to 0x7A to their base32 values.\n    // 0xFF represents invalid characters in that range.\n    bytes constant base32HexTable =\n        hex\"00010203040506070809FFFFFFFFFFFFFF0A0B0C0D0E0F101112131415161718191A1B1C1D1E1FFFFFFFFFFFFFFFFFFFFF0A0B0C0D0E0F101112131415161718191A1B1C1D1E1F\";\n\n    /**\n     * @dev Decodes unpadded base32 data of up to one word in length.\n     * @param self The data to decode.\n     * @param off Offset into the string to start at.\n     * @param len Number of characters to decode.\n     * @return The decoded data, left aligned.\n     */\n    function base32HexDecodeWord(bytes memory self, uint256 off, uint256 len) internal pure returns (bytes32) {\n        require(len <= 52);\n\n        uint256 ret = 0;\n        uint8 decoded;\n        for (uint256 i = 0; i < len; i++) {\n            bytes1 char = self[off + i];\n            require(char >= 0x30 && char <= 0x7A);\n            decoded = uint8(base32HexTable[uint256(uint8(char)) - 0x30]);\n            require(decoded <= 0x20);\n            if (i == len - 1) {\n                break;\n            }\n            ret = (ret << 5) | decoded;\n        }\n\n        uint256 bitlen = len * 5;\n        if (len % 8 == 0) {\n            // Multiple of 8 characters, no padding\n            ret = (ret << 5) | decoded;\n        } else if (len % 8 == 2) {\n            // Two extra characters - 1 byte\n            ret = (ret << 3) | (decoded >> 2);\n            bitlen -= 2;\n        } else if (len % 8 == 4) {\n            // Four extra characters - 2 bytes\n            ret = (ret << 1) | (decoded >> 4);\n            bitlen -= 4;\n        } else if (len % 8 == 5) {\n            // Five extra characters - 3 bytes\n            ret = (ret << 4) | (decoded >> 1);\n            bitlen -= 1;\n        } else if (len % 8 == 7) {\n            // Seven extra characters - 4 bytes\n            ret = (ret << 2) | (decoded >> 3);\n            bitlen -= 3;\n        } else {\n            revert();\n        }\n\n        return bytes32(ret << (256 - bitlen));\n    }\n\n    function compareBytes(bytes memory a, bytes memory b) internal pure returns (bool) {\n        if (a.length != b.length) {\n            return false;\n        }\n        for (uint256 i = 0; i < a.length; i++) {\n            if (a[i] != b[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n"
    },
    "@automata-network/on-chain-pccs/utils/DateTimeUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {DateTimeLib} from \"solady/utils/DateTimeLib.sol\";\nimport {LibString} from \"solady/utils/LibString.sol\";\n\nlibrary DateTimeUtils {\n    using LibString for string;\n\n    /*\n     * @dev Convert a DER-encoded time to a unix timestamp\n     * @param x509Time The DER-encoded time\n     * @return The unix timestamp\n     */\n    function fromDERToTimestamp(bytes memory x509Time) internal pure returns (uint256) {\n        uint16 yrs;\n        uint8 mnths;\n        uint8 dys;\n        uint8 hrs;\n        uint8 mins;\n        uint8 secs;\n        uint8 offset;\n\n        if (x509Time.length == 13) {\n            if (uint8(x509Time[0]) - 48 < 5) yrs += 2000;\n            else yrs += 1900;\n        } else {\n            yrs += (uint8(x509Time[0]) - 48) * 1000 + (uint8(x509Time[1]) - 48) * 100;\n            offset = 2;\n        }\n        yrs += (uint8(x509Time[offset + 0]) - 48) * 10 + uint8(x509Time[offset + 1]) - 48;\n        mnths = (uint8(x509Time[offset + 2]) - 48) * 10 + uint8(x509Time[offset + 3]) - 48;\n        dys += (uint8(x509Time[offset + 4]) - 48) * 10 + uint8(x509Time[offset + 5]) - 48;\n        hrs += (uint8(x509Time[offset + 6]) - 48) * 10 + uint8(x509Time[offset + 7]) - 48;\n        mins += (uint8(x509Time[offset + 8]) - 48) * 10 + uint8(x509Time[offset + 9]) - 48;\n        secs += (uint8(x509Time[offset + 10]) - 48) * 10 + uint8(x509Time[offset + 11]) - 48;\n\n        return DateTimeLib.dateTimeToTimestamp(yrs, mnths, dys, hrs, mins, secs);\n    }\n\n    /// @dev iso follows pattern: \"YYYY-MM-DDTHH:mm:ssZ\"\n    function fromISOToTimestamp(string memory iso) internal pure returns (uint256) {\n        require(bytes(iso).length == 20, \"invalid iso string length\");\n        uint256 y = stringToUint(iso.slice(0, 4));\n        uint256 m = stringToUint(iso.slice(5, 7));\n        uint256 d = stringToUint(iso.slice(8, 10));\n        uint256 h = stringToUint(iso.slice(11, 13));\n        uint256 min = stringToUint(iso.slice(14, 16));\n        uint256 s = stringToUint(iso.slice(17, 19));\n\n        return DateTimeLib.dateTimeToTimestamp(y, m, d, h, min, s);\n    }\n\n    // https://ethereum.stackexchange.com/questions/10932/how-to-convert-string-to-int\n    function stringToUint(string memory s) private pure returns (uint256 result) {\n        bytes memory b = bytes(s);\n        result = 0;\n        for (uint256 i = 0; i < b.length; i++) {\n            uint256 c = uint256(uint8(b[i]));\n            if (c >= 48 && c <= 57) {\n                result = result * 10 + (c - 48);\n            }\n        }\n    }\n}\n"
    },
    "@automata-network/on-chain-pccs/utils/P256Verifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./BytesUtils.sol\";\n\n/**\n * @title P256Verifier Wrapper\n */\nabstract contract P256Verifier {\n    using BytesUtils for bytes;\n\n    /// @dev this address can either be:\n    /// - 0x100 (as defined in RIP-7212)\n    /// - 0xc2b78104907F722DABAc4C69f826a522B2754De4 (daimo-eth P256 implementation, ref: https://github.com/daimo-eth/p256-verifier/)\n    /// @dev may contain other P256 Verifier address depending on the target network\n    address public immutable P256_VERIFIER;\n\n    constructor(address _verifier) {\n        P256_VERIFIER = _verifier;\n    }\n\n    function ecdsaVerify(bytes32 messageHash, bytes memory signature, bytes memory key)\n        internal\n        view\n        returns (bool verified)\n    {\n        bytes memory args = abi.encode(\n            messageHash,\n            uint256(bytes32(signature.substring(0, 32))),\n            uint256(bytes32(signature.substring(32, 32))),\n            uint256(bytes32(key.substring(0, 32))),\n            uint256(bytes32(key.substring(32, 32)))\n        );\n        (bool success, bytes memory ret) = P256_VERIFIER.staticcall(args);\n        assert(success); // never reverts, always returns 0 or 1\n\n        verified = abi.decode(ret, (uint256)) == 1;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable2Step.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (access/Ownable2Step.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./Ownable.sol\";\n\n/**\n * @dev Contract module which provides access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership} and {acceptOwnership}.\n *\n * This module is used through inheritance. It will make available all functions\n * from parent (Ownable).\n */\nabstract contract Ownable2Step is Ownable {\n    address private _pendingOwner;\n\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Returns the address of the pending owner.\n     */\n    function pendingOwner() public view virtual returns (address) {\n        return _pendingOwner;\n    }\n\n    /**\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\n        _pendingOwner = newOwner;\n        emit OwnershipTransferStarted(owner(), newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual override {\n        delete _pendingOwner;\n        super._transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev The new owner accepts the ownership transfer.\n     */\n    function acceptOwnership() external {\n        address sender = _msgSender();\n        require(pendingOwner() == sender, \"Ownable2Step: caller is not the new owner\");\n        _transferOwnership(sender);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "solady/utils/Base64.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Library to encode strings in Base64.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/Base64.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/Base64.sol)\n/// @author Modified from (https://github.com/Brechtpd/base64/blob/main/base64.sol) by Brecht Devos - <brecht@loopring.org>.\nlibrary Base64 {\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\n    /// See: https://datatracker.ietf.org/doc/html/rfc4648\n    /// @param fileSafe  Whether to replace '+' with '-' and '/' with '_'.\n    /// @param noPadding Whether to strip away the padding.\n    function encode(bytes memory data, bool fileSafe, bool noPadding)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let dataLength := mload(data)\n\n            if dataLength {\n                // Multiply by 4/3 rounded up.\n                // The `shl(2, ...)` is equivalent to multiplying by 4.\n                let encodedLength := shl(2, div(add(dataLength, 2), 3))\n\n                // Set `result` to point to the start of the free memory.\n                result := mload(0x40)\n\n                // Store the table into the scratch space.\n                // Offsetted by -1 byte so that the `mload` will load the character.\n                // We will rewrite the free memory pointer at `0x40` later with\n                // the allocated size.\n                // The magic constant 0x0670 will turn \"-_\" into \"+/\".\n                mstore(0x1f, \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdef\")\n                mstore(0x3f, xor(\"ghijklmnopqrstuvwxyz0123456789-_\", mul(iszero(fileSafe), 0x0670)))\n\n                // Skip the first slot, which stores the length.\n                let ptr := add(result, 0x20)\n                let end := add(ptr, encodedLength)\n\n                let dataEnd := add(add(0x20, data), dataLength)\n                let dataEndValue := mload(dataEnd) // Cache the value at the `dataEnd` slot.\n                mstore(dataEnd, 0x00) // Zeroize the `dataEnd` slot to clear dirty bits.\n\n                // Run over the input, 3 bytes at a time.\n                for {} 1 {} {\n                    data := add(data, 3) // Advance 3 bytes.\n                    let input := mload(data)\n\n                    // Write 4 bytes. Optimized for fewer stack operations.\n                    mstore8(0, mload(and(shr(18, input), 0x3F)))\n                    mstore8(1, mload(and(shr(12, input), 0x3F)))\n                    mstore8(2, mload(and(shr(6, input), 0x3F)))\n                    mstore8(3, mload(and(input, 0x3F)))\n                    mstore(ptr, mload(0x00))\n\n                    ptr := add(ptr, 4) // Advance 4 bytes.\n                    if iszero(lt(ptr, end)) { break }\n                }\n                mstore(dataEnd, dataEndValue) // Restore the cached value at `dataEnd`.\n                mstore(0x40, add(end, 0x20)) // Allocate the memory.\n                // Equivalent to `o = [0, 2, 1][dataLength % 3]`.\n                let o := div(2, mod(dataLength, 3))\n                // Offset `ptr` and pad with '='. We can simply write over the end.\n                mstore(sub(ptr, o), shl(240, 0x3d3d))\n                // Set `o` to zero if there is padding.\n                o := mul(iszero(iszero(noPadding)), o)\n                mstore(sub(ptr, o), 0) // Zeroize the slot after the string.\n                mstore(result, sub(encodedLength, o)) // Store the length.\n            }\n        }\n    }\n\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\n    /// Equivalent to `encode(data, false, false)`.\n    function encode(bytes memory data) internal pure returns (string memory result) {\n        result = encode(data, false, false);\n    }\n\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\n    /// Equivalent to `encode(data, fileSafe, false)`.\n    function encode(bytes memory data, bool fileSafe)\n        internal\n        pure\n        returns (string memory result)\n    {\n        result = encode(data, fileSafe, false);\n    }\n\n    /// @dev Decodes base64 encoded `data`.\n    ///\n    /// Supports:\n    /// - RFC 4648 (both standard and file-safe mode).\n    /// - RFC 3501 (63: ',').\n    ///\n    /// Does not support:\n    /// - Line breaks.\n    ///\n    /// Note: For performance reasons,\n    /// this function will NOT revert on invalid `data` inputs.\n    /// Outputs for invalid inputs will simply be undefined behaviour.\n    /// It is the user's responsibility to ensure that the `data`\n    /// is a valid base64 encoded string.\n    function decode(string memory data) internal pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let dataLength := mload(data)\n\n            if dataLength {\n                let decodedLength := mul(shr(2, dataLength), 3)\n\n                for {} 1 {} {\n                    // If padded.\n                    if iszero(and(dataLength, 3)) {\n                        let t := xor(mload(add(data, dataLength)), 0x3d3d)\n                        // forgefmt: disable-next-item\n                        decodedLength := sub(\n                            decodedLength,\n                            add(iszero(byte(30, t)), iszero(byte(31, t)))\n                        )\n                        break\n                    }\n                    // If non-padded.\n                    decodedLength := add(decodedLength, sub(and(dataLength, 3), 1))\n                    break\n                }\n                result := mload(0x40)\n\n                // Write the length of the bytes.\n                mstore(result, decodedLength)\n\n                // Skip the first slot, which stores the length.\n                let ptr := add(result, 0x20)\n                let end := add(ptr, decodedLength)\n\n                // Load the table into the scratch space.\n                // Constants are optimized for smaller bytecode with zero gas overhead.\n                // `m` also doubles as the mask of the upper 6 bits.\n                let m := 0xfc000000fc00686c7074787c8084888c9094989ca0a4a8acb0b4b8bcc0c4c8cc\n                mstore(0x5b, m)\n                mstore(0x3b, 0x04080c1014181c2024282c3034383c4044484c5054585c6064)\n                mstore(0x1a, 0xf8fcf800fcd0d4d8dce0e4e8ecf0f4)\n\n                for {} 1 {} {\n                    // Read 4 bytes.\n                    data := add(data, 4)\n                    let input := mload(data)\n\n                    // Write 3 bytes.\n                    // forgefmt: disable-next-item\n                    mstore(ptr, or(\n                        and(m, mload(byte(28, input))),\n                        shr(6, or(\n                            and(m, mload(byte(29, input))),\n                            shr(6, or(\n                                and(m, mload(byte(30, input))),\n                                shr(6, mload(byte(31, input)))\n                            ))\n                        ))\n                    ))\n                    ptr := add(ptr, 3)\n                    if iszero(lt(ptr, end)) { break }\n                }\n                mstore(0x40, add(end, 0x20)) // Allocate the memory.\n                mstore(end, 0) // Zeroize the slot after the bytes.\n                mstore(0x60, 0) // Restore the zero slot.\n            }\n        }\n    }\n}\n"
    },
    "solady/utils/DateTimeLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Library for date time operations.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/DateTimeLib.sol)\n/// @author Modified from BokkyPooBahsDateTimeLibrary (https://github.com/bokkypoobah/BokkyPooBahsDateTimeLibrary)\n/// @dev\n/// Conventions:\n/// --------------------------------------------------------------------+\n/// Unit      | Range                | Notes                            |\n/// --------------------------------------------------------------------|\n/// timestamp | 0..0x1e18549868c76ff | Unix timestamp.                  |\n/// epochDay  | 0..0x16d3e098039     | Days since 1970-01-01.           |\n/// year      | 1970..0xffffffff     | Gregorian calendar year.         |\n/// month     | 1..12                | Gregorian calendar month.        |\n/// day       | 1..31                | Gregorian calendar day of month. |\n/// weekday   | 1..7                 | The day of the week (1-indexed). |\n/// --------------------------------------------------------------------+\n/// All timestamps of days are rounded down to 00:00:00 UTC.\nlibrary DateTimeLib {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         CONSTANTS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // Weekdays are 1-indexed, adhering to ISO 8601.\n\n    uint256 internal constant MON = 1;\n    uint256 internal constant TUE = 2;\n    uint256 internal constant WED = 3;\n    uint256 internal constant THU = 4;\n    uint256 internal constant FRI = 5;\n    uint256 internal constant SAT = 6;\n    uint256 internal constant SUN = 7;\n\n    // Months and days of months are 1-indexed, adhering to ISO 8601.\n\n    uint256 internal constant JAN = 1;\n    uint256 internal constant FEB = 2;\n    uint256 internal constant MAR = 3;\n    uint256 internal constant APR = 4;\n    uint256 internal constant MAY = 5;\n    uint256 internal constant JUN = 6;\n    uint256 internal constant JUL = 7;\n    uint256 internal constant AUG = 8;\n    uint256 internal constant SEP = 9;\n    uint256 internal constant OCT = 10;\n    uint256 internal constant NOV = 11;\n    uint256 internal constant DEC = 12;\n\n    // These limits are large enough for most practical purposes.\n    // Inputs that exceed these limits result in undefined behavior.\n\n    uint256 internal constant MAX_SUPPORTED_YEAR = 0xffffffff;\n    uint256 internal constant MAX_SUPPORTED_EPOCH_DAY = 0x16d3e098039;\n    uint256 internal constant MAX_SUPPORTED_TIMESTAMP = 0x1e18549868c76ff;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                    DATE TIME OPERATIONS                    */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the number of days since 1970-01-01 from (`year`,`month`,`day`).\n    /// See: https://howardhinnant.github.io/date_algorithms.html\n    /// Note: Inputs outside the supported ranges result in undefined behavior.\n    /// Use {isSupportedDate} to check if the inputs are supported.\n    function dateToEpochDay(uint256 year, uint256 month, uint256 day)\n        internal\n        pure\n        returns (uint256 epochDay)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            year := sub(year, lt(month, 3))\n            let doy := add(shr(11, add(mul(62719, mod(add(month, 9), 12)), 769)), day)\n            let yoe := mod(year, 400)\n            let doe := sub(add(add(mul(yoe, 365), shr(2, yoe)), doy), div(yoe, 100))\n            epochDay := sub(add(mul(div(year, 400), 146097), doe), 719469)\n        }\n    }\n\n    /// @dev Returns (`year`,`month`,`day`) from the number of days since 1970-01-01.\n    /// Note: Inputs outside the supported ranges result in undefined behavior.\n    /// Use {isSupportedDays} to check if the inputs is supported.\n    function epochDayToDate(uint256 epochDay)\n        internal\n        pure\n        returns (uint256 year, uint256 month, uint256 day)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            epochDay := add(epochDay, 719468)\n            let doe := mod(epochDay, 146097)\n            let yoe :=\n                div(sub(sub(add(doe, div(doe, 36524)), div(doe, 1460)), eq(doe, 146096)), 365)\n            let doy := sub(doe, sub(add(mul(365, yoe), shr(2, yoe)), div(yoe, 100)))\n            let mp := div(add(mul(5, doy), 2), 153)\n            day := add(sub(doy, shr(11, add(mul(mp, 62719), 769))), 1)\n            month := byte(mp, shl(160, 0x030405060708090a0b0c0102))\n            year := add(add(yoe, mul(div(epochDay, 146097), 400)), lt(month, 3))\n        }\n    }\n\n    /// @dev Returns the unix timestamp from (`year`,`month`,`day`).\n    /// Note: Inputs outside the supported ranges result in undefined behavior.\n    /// Use {isSupportedDate} to check if the inputs are supported.\n    function dateToTimestamp(uint256 year, uint256 month, uint256 day)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        unchecked {\n            result = dateToEpochDay(year, month, day) * 86400;\n        }\n    }\n\n    /// @dev Returns (`year`,`month`,`day`) from the given unix timestamp.\n    /// Note: Inputs outside the supported ranges result in undefined behavior.\n    /// Use {isSupportedTimestamp} to check if the inputs are supported.\n    function timestampToDate(uint256 timestamp)\n        internal\n        pure\n        returns (uint256 year, uint256 month, uint256 day)\n    {\n        (year, month, day) = epochDayToDate(timestamp / 86400);\n    }\n\n    /// @dev Returns the unix timestamp from\n    /// (`year`,`month`,`day`,`hour`,`minute`,`second`).\n    /// Note: Inputs outside the supported ranges result in undefined behavior.\n    /// Use {isSupportedDateTime} to check if the inputs are supported.\n    function dateTimeToTimestamp(\n        uint256 year,\n        uint256 month,\n        uint256 day,\n        uint256 hour,\n        uint256 minute,\n        uint256 second\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            result = dateToEpochDay(year, month, day) * 86400 + hour * 3600 + minute * 60 + second;\n        }\n    }\n\n    /// @dev Returns (`year`,`month`,`day`,`hour`,`minute`,`second`)\n    /// from the given unix timestamp.\n    /// Note: Inputs outside the supported ranges result in undefined behavior.\n    /// Use {isSupportedTimestamp} to check if the inputs are supported.\n    function timestampToDateTime(uint256 timestamp)\n        internal\n        pure\n        returns (\n            uint256 year,\n            uint256 month,\n            uint256 day,\n            uint256 hour,\n            uint256 minute,\n            uint256 second\n        )\n    {\n        unchecked {\n            (year, month, day) = epochDayToDate(timestamp / 86400);\n            uint256 secs = timestamp % 86400;\n            hour = secs / 3600;\n            secs = secs % 3600;\n            minute = secs / 60;\n            second = secs % 60;\n        }\n    }\n\n    /// @dev Returns if the `year` is leap.\n    function isLeapYear(uint256 year) internal pure returns (bool leap) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            leap := iszero(and(add(mul(iszero(mod(year, 25)), 12), 3), year))\n        }\n    }\n\n    /// @dev Returns number of days in given `month` of `year`.\n    function daysInMonth(uint256 year, uint256 month) internal pure returns (uint256 result) {\n        bool flag = isLeapYear(year);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // `daysInMonths = [31,28,31,30,31,30,31,31,30,31,30,31]`.\n            // `result = daysInMonths[month - 1] + isLeapYear(year)`.\n            result :=\n                add(byte(month, shl(152, 0x1f1c1f1e1f1e1f1f1e1f1e1f)), and(eq(month, 2), flag))\n        }\n    }\n\n    /// @dev Returns the weekday from the unix timestamp.\n    /// Monday: 1, Tuesday: 2, ....., Sunday: 7.\n    function weekday(uint256 timestamp) internal pure returns (uint256 result) {\n        unchecked {\n            result = ((timestamp / 86400 + 3) % 7) + 1;\n        }\n    }\n\n    /// @dev Returns if (`year`,`month`,`day`) is a supported date.\n    /// - `1970 <= year <= MAX_SUPPORTED_YEAR`.\n    /// - `1 <= month <= 12`.\n    /// - `1 <= day <= daysInMonth(year, month)`.\n    function isSupportedDate(uint256 year, uint256 month, uint256 day)\n        internal\n        pure\n        returns (bool result)\n    {\n        uint256 md = daysInMonth(year, month);\n        /// @solidity memory-safe-assembly\n        assembly {\n            result :=\n                and(\n                    lt(sub(year, 1970), sub(MAX_SUPPORTED_YEAR, 1969)),\n                    and(lt(sub(month, 1), 12), lt(sub(day, 1), md))\n                )\n        }\n    }\n\n    /// @dev Returns if (`year`,`month`,`day`,`hour`,`minute`,`second`) is a supported date time.\n    /// - `1970 <= year <= MAX_SUPPORTED_YEAR`.\n    /// - `1 <= month <= 12`.\n    /// - `1 <= day <= daysInMonth(year, month)`.\n    /// - `hour < 24`.\n    /// - `minute < 60`.\n    /// - `second < 60`.\n    function isSupportedDateTime(\n        uint256 year,\n        uint256 month,\n        uint256 day,\n        uint256 hour,\n        uint256 minute,\n        uint256 second\n    ) internal pure returns (bool result) {\n        if (isSupportedDate(year, month, day)) {\n            /// @solidity memory-safe-assembly\n            assembly {\n                result := and(lt(hour, 24), and(lt(minute, 60), lt(second, 60)))\n            }\n        }\n    }\n\n    /// @dev Returns if `epochDay` is a supported unix epoch day.\n    function isSupportedEpochDay(uint256 epochDay) internal pure returns (bool result) {\n        unchecked {\n            result = epochDay < MAX_SUPPORTED_EPOCH_DAY + 1;\n        }\n    }\n\n    /// @dev Returns if `timestamp` is a supported unix timestamp.\n    function isSupportedTimestamp(uint256 timestamp) internal pure returns (bool result) {\n        unchecked {\n            result = timestamp < MAX_SUPPORTED_TIMESTAMP + 1;\n        }\n    }\n\n    /// @dev Returns the unix timestamp of the given `n`th weekday `wd`, in `month` of `year`.\n    /// Example: 3rd Friday of Feb 2022 is `nthWeekdayInMonthOfYearTimestamp(2022, 2, 3, 5)`\n    /// Note: `n` is 1-indexed for traditional consistency.\n    /// Invalid weekdays (i.e. `wd == 0 || wd > 7`) result in undefined behavior.\n    function nthWeekdayInMonthOfYearTimestamp(uint256 year, uint256 month, uint256 n, uint256 wd)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        uint256 d = dateToEpochDay(year, month, 1);\n        uint256 md = daysInMonth(year, month);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let diff := sub(wd, add(mod(add(d, 3), 7), 1))\n            let date := add(mul(sub(n, 1), 7), add(mul(gt(diff, 6), 7), diff))\n            result := mul(mul(86400, add(date, d)), and(lt(date, md), iszero(iszero(n))))\n        }\n    }\n\n    /// @dev Returns the unix timestamp of the most recent Monday.\n    function mondayTimestamp(uint256 timestamp) internal pure returns (uint256 result) {\n        uint256 t = timestamp;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let day := div(t, 86400)\n            result := mul(mul(sub(day, mod(add(day, 3), 7)), 86400), gt(t, 345599))\n        }\n    }\n\n    /// @dev Returns whether the unix timestamp falls on a Saturday or Sunday.\n    /// To check whether it is a week day, just take the negation of the result.\n    function isWeekEnd(uint256 timestamp) internal pure returns (bool result) {\n        result = weekday(timestamp) > FRI;\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*              DATE TIME ARITHMETIC OPERATIONS               */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Adds `numYears` to the unix timestamp, and returns the result.\n    /// Note: The result will share the same Gregorian calendar month,\n    /// but different Gregorian calendar years for non-zero `numYears`.\n    /// If the Gregorian calendar month of the result has less days\n    /// than the Gregorian calendar month day of the `timestamp`,\n    /// the result's month day will be the maximum possible value for the month.\n    /// (e.g. from 29th Feb to 28th Feb)\n    function addYears(uint256 timestamp, uint256 numYears) internal pure returns (uint256 result) {\n        (uint256 year, uint256 month, uint256 day) = epochDayToDate(timestamp / 86400);\n        result = _offsetted(year + numYears, month, day, timestamp);\n    }\n\n    /// @dev Adds `numMonths` to the unix timestamp, and returns the result.\n    /// Note: If the Gregorian calendar month of the result has less days\n    /// than the Gregorian calendar month day of the `timestamp`,\n    /// the result's month day will be the maximum possible value for the month.\n    /// (e.g. from 29th Feb to 28th Feb)\n    function addMonths(uint256 timestamp, uint256 numMonths)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        (uint256 year, uint256 month, uint256 day) = epochDayToDate(timestamp / 86400);\n        month = _sub(month + numMonths, 1);\n        result = _offsetted(year + month / 12, _add(month % 12, 1), day, timestamp);\n    }\n\n    /// @dev Adds `numDays` to the unix timestamp, and returns the result.\n    function addDays(uint256 timestamp, uint256 numDays) internal pure returns (uint256 result) {\n        result = timestamp + numDays * 86400;\n    }\n\n    /// @dev Adds `numHours` to the unix timestamp, and returns the result.\n    function addHours(uint256 timestamp, uint256 numHours) internal pure returns (uint256 result) {\n        result = timestamp + numHours * 3600;\n    }\n\n    /// @dev Adds `numMinutes` to the unix timestamp, and returns the result.\n    function addMinutes(uint256 timestamp, uint256 numMinutes)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        result = timestamp + numMinutes * 60;\n    }\n\n    /// @dev Adds `numSeconds` to the unix timestamp, and returns the result.\n    function addSeconds(uint256 timestamp, uint256 numSeconds)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        result = timestamp + numSeconds;\n    }\n\n    /// @dev Subtracts `numYears` from the unix timestamp, and returns the result.\n    /// Note: The result will share the same Gregorian calendar month,\n    /// but different Gregorian calendar years for non-zero `numYears`.\n    /// If the Gregorian calendar month of the result has less days\n    /// than the Gregorian calendar month day of the `timestamp`,\n    /// the result's month day will be the maximum possible value for the month.\n    /// (e.g. from 29th Feb to 28th Feb)\n    function subYears(uint256 timestamp, uint256 numYears) internal pure returns (uint256 result) {\n        (uint256 year, uint256 month, uint256 day) = epochDayToDate(timestamp / 86400);\n        result = _offsetted(year - numYears, month, day, timestamp);\n    }\n\n    /// @dev Subtracts `numYears` from the unix timestamp, and returns the result.\n    /// Note: If the Gregorian calendar month of the result has less days\n    /// than the Gregorian calendar month day of the `timestamp`,\n    /// the result's month day will be the maximum possible value for the month.\n    /// (e.g. from 29th Feb to 28th Feb)\n    function subMonths(uint256 timestamp, uint256 numMonths)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        (uint256 year, uint256 month, uint256 day) = epochDayToDate(timestamp / 86400);\n        uint256 yearMonth = _totalMonths(year, month) - _add(numMonths, 1);\n        result = _offsetted(yearMonth / 12, _add(yearMonth % 12, 1), day, timestamp);\n    }\n\n    /// @dev Subtracts `numDays` from the unix timestamp, and returns the result.\n    function subDays(uint256 timestamp, uint256 numDays) internal pure returns (uint256 result) {\n        result = timestamp - numDays * 86400;\n    }\n\n    /// @dev Subtracts `numHours` from the unix timestamp, and returns the result.\n    function subHours(uint256 timestamp, uint256 numHours) internal pure returns (uint256 result) {\n        result = timestamp - numHours * 3600;\n    }\n\n    /// @dev Subtracts `numMinutes` from the unix timestamp, and returns the result.\n    function subMinutes(uint256 timestamp, uint256 numMinutes)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        result = timestamp - numMinutes * 60;\n    }\n\n    /// @dev Subtracts `numSeconds` from the unix timestamp, and returns the result.\n    function subSeconds(uint256 timestamp, uint256 numSeconds)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        result = timestamp - numSeconds;\n    }\n\n    /// @dev Returns the difference in Gregorian calendar years\n    /// between `fromTimestamp` and `toTimestamp`.\n    /// Note: Even if the true time difference is less than a year,\n    /// the difference can be non-zero is the timestamps are\n    /// from different Gregorian calendar years\n    function diffYears(uint256 fromTimestamp, uint256 toTimestamp)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        toTimestamp - fromTimestamp;\n        (uint256 fromYear,,) = epochDayToDate(fromTimestamp / 86400);\n        (uint256 toYear,,) = epochDayToDate(toTimestamp / 86400);\n        result = _sub(toYear, fromYear);\n    }\n\n    /// @dev Returns the difference in Gregorian calendar months\n    /// between `fromTimestamp` and `toTimestamp`.\n    /// Note: Even if the true time difference is less than a month,\n    /// the difference can be non-zero is the timestamps are\n    /// from different Gregorian calendar months.\n    function diffMonths(uint256 fromTimestamp, uint256 toTimestamp)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        toTimestamp - fromTimestamp;\n        (uint256 fromYear, uint256 fromMonth,) = epochDayToDate(fromTimestamp / 86400);\n        (uint256 toYear, uint256 toMonth,) = epochDayToDate(toTimestamp / 86400);\n        result = _sub(_totalMonths(toYear, toMonth), _totalMonths(fromYear, fromMonth));\n    }\n\n    /// @dev Returns the difference in days between `fromTimestamp` and `toTimestamp`.\n    function diffDays(uint256 fromTimestamp, uint256 toTimestamp)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        result = (toTimestamp - fromTimestamp) / 86400;\n    }\n\n    /// @dev Returns the difference in hours between `fromTimestamp` and `toTimestamp`.\n    function diffHours(uint256 fromTimestamp, uint256 toTimestamp)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        result = (toTimestamp - fromTimestamp) / 3600;\n    }\n\n    /// @dev Returns the difference in minutes between `fromTimestamp` and `toTimestamp`.\n    function diffMinutes(uint256 fromTimestamp, uint256 toTimestamp)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        result = (toTimestamp - fromTimestamp) / 60;\n    }\n\n    /// @dev Returns the difference in seconds between `fromTimestamp` and `toTimestamp`.\n    function diffSeconds(uint256 fromTimestamp, uint256 toTimestamp)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        result = toTimestamp - fromTimestamp;\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      PRIVATE HELPERS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Unchecked arithmetic for computing the total number of months.\n    function _totalMonths(uint256 numYears, uint256 numMonths)\n        private\n        pure\n        returns (uint256 total)\n    {\n        unchecked {\n            total = numYears * 12 + numMonths;\n        }\n    }\n\n    /// @dev Unchecked arithmetic for adding two numbers.\n    function _add(uint256 a, uint256 b) private pure returns (uint256 c) {\n        unchecked {\n            c = a + b;\n        }\n    }\n\n    /// @dev Unchecked arithmetic for subtracting two numbers.\n    function _sub(uint256 a, uint256 b) private pure returns (uint256 c) {\n        unchecked {\n            c = a - b;\n        }\n    }\n\n    /// @dev Returns the offsetted timestamp.\n    function _offsetted(uint256 year, uint256 month, uint256 day, uint256 timestamp)\n        private\n        pure\n        returns (uint256 result)\n    {\n        uint256 dm = daysInMonth(year, month);\n        if (day >= dm) {\n            day = dm;\n        }\n        result = dateToEpochDay(year, month, day) * 86400 + (timestamp % 86400);\n    }\n}\n"
    },
    "solady/utils/JSONParserLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Library for parsing JSONs.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/JSONParserLib.sol)\nlibrary JSONParserLib {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The input is invalid.\n    error ParsingFailed();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         CONSTANTS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // There are 6 types of variables in JSON (excluding undefined).\n\n    /// @dev For denoting that an item has not been initialized.\n    /// A item returned from `parse` will never be of an undefined type.\n    /// Parsing a invalid JSON string will simply revert.\n    uint8 internal constant TYPE_UNDEFINED = 0;\n\n    /// @dev Type representing an array (e.g. `[1,2,3]`).\n    uint8 internal constant TYPE_ARRAY = 1;\n\n    /// @dev Type representing an object (e.g. `{\"a\":\"A\",\"b\":\"B\"}`).\n    uint8 internal constant TYPE_OBJECT = 2;\n\n    /// @dev Type representing a number (e.g. `-1.23e+21`).\n    uint8 internal constant TYPE_NUMBER = 3;\n\n    /// @dev Type representing a string (e.g. `\"hello\"`).\n    uint8 internal constant TYPE_STRING = 4;\n\n    /// @dev Type representing a boolean (i.e. `true` or `false`).\n    uint8 internal constant TYPE_BOOLEAN = 5;\n\n    /// @dev Type representing null (i.e. `null`).\n    uint8 internal constant TYPE_NULL = 6;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                          STRUCTS                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev A pointer to a parsed JSON node.\n    struct Item {\n        // Do NOT modify the `_data` directly.\n        uint256 _data;\n    }\n\n    // Private constants for packing `_data`.\n\n    uint256 private constant _BITPOS_STRING = 32 * 7 - 8;\n    uint256 private constant _BITPOS_KEY_LENGTH = 32 * 6 - 8;\n    uint256 private constant _BITPOS_KEY = 32 * 5 - 8;\n    uint256 private constant _BITPOS_VALUE_LENGTH = 32 * 4 - 8;\n    uint256 private constant _BITPOS_VALUE = 32 * 3 - 8;\n    uint256 private constant _BITPOS_CHILD = 32 * 2 - 8;\n    uint256 private constant _BITPOS_SIBLING_OR_PARENT = 32 * 1 - 8;\n    uint256 private constant _BITMASK_POINTER = 0xffffffff;\n    uint256 private constant _BITMASK_TYPE = 7;\n    uint256 private constant _KEY_INITED = 1 << 3;\n    uint256 private constant _VALUE_INITED = 1 << 4;\n    uint256 private constant _CHILDREN_INITED = 1 << 5;\n    uint256 private constant _PARENT_IS_ARRAY = 1 << 6;\n    uint256 private constant _PARENT_IS_OBJECT = 1 << 7;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   JSON PARSING OPERATION                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Parses the JSON string `s`, and returns the root.\n    /// Reverts if `s` is not a valid JSON as specified in RFC 8259.\n    /// Object items WILL simply contain all their children, inclusive of repeated keys,\n    /// in the same order which they appear in the JSON string.\n    ///\n    /// Note: For efficiency, this function WILL NOT make a copy of `s`.\n    /// The parsed tree WILL contain offsets to `s`.\n    /// Do NOT pass in a string that WILL be modified later on.\n    function parse(string memory s) internal pure returns (Item memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x40, result) // We will use our own allocation instead.\n        }\n        bytes32 r = _query(_toInput(s), 255);\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := r\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                    JSON ITEM OPERATIONS                    */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // Note:\n    // - An item is a node in the JSON tree.\n    // - The value of a string item WILL be double-quoted, JSON encoded.\n    // - We make a distinction between `index` and `key`.\n    //   - Items in arrays are located by `index` (uint256).\n    //   - Items in objects are located by `key` (string).\n    // - Keys are always strings, double-quoted, JSON encoded.\n    //\n    // These design choices are made to balance between efficiency and ease-of-use.\n\n    /// @dev Returns the string value of the item.\n    /// This is its exact string representation in the original JSON string.\n    /// The returned string WILL have leading and trailing whitespace trimmed.\n    /// All inner whitespace WILL be preserved, exactly as it is in the original JSON string.\n    /// If the item's type is string, the returned string WILL be double-quoted, JSON encoded.\n    ///\n    /// Note: This function lazily instantiates and caches the returned string.\n    /// Do NOT modify the returned string.\n    function value(Item memory item) internal pure returns (string memory result) {\n        bytes32 r = _query(_toInput(item), 0);\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := r\n        }\n    }\n\n    /// @dev Returns the index of the item in the array.\n    /// It the item's parent is not an array, returns 0.\n    function index(Item memory item) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if and(mload(item), _PARENT_IS_ARRAY) {\n                result := and(_BITMASK_POINTER, shr(_BITPOS_KEY, mload(item)))\n            }\n        }\n    }\n\n    /// @dev Returns the key of the item in the object.\n    /// It the item's parent is not an object, returns an empty string.\n    /// The returned string WILL be double-quoted, JSON encoded.\n    ///\n    /// Note: This function lazily instantiates and caches the returned string.\n    /// Do NOT modify the returned string.\n    function key(Item memory item) internal pure returns (string memory result) {\n        if (item._data & _PARENT_IS_OBJECT != 0) {\n            bytes32 r = _query(_toInput(item), 1);\n            /// @solidity memory-safe-assembly\n            assembly {\n                result := r\n            }\n        }\n    }\n\n    /// @dev Returns the key of the item in the object.\n    /// It the item is neither an array nor object, returns an empty array.\n    ///\n    /// Note: This function lazily instantiates and caches the returned array.\n    /// Do NOT modify the returned array.\n    function children(Item memory item) internal pure returns (Item[] memory result) {\n        bytes32 r = _query(_toInput(item), 3);\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := r\n        }\n    }\n\n    /// @dev Returns the number of children.\n    /// It the item is neither an array nor object, returns zero.\n    function size(Item memory item) internal pure returns (uint256 result) {\n        bytes32 r = _query(_toInput(item), 3);\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(r)\n        }\n    }\n\n    /// @dev Returns the item at index `i` for (array).\n    /// If `item` is not an array, the result's type WILL be undefined.\n    /// If there is no item with the index, the result's type WILL be undefined.\n    function at(Item memory item, uint256 i) internal pure returns (Item memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x40, result) // Free the default allocation. We'll allocate manually.\n        }\n        bytes32 r = _query(_toInput(item), 3);\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(add(add(r, 0x20), shl(5, i)))\n            if iszero(and(lt(i, mload(r)), eq(and(mload(item), _BITMASK_TYPE), TYPE_ARRAY))) {\n                result := 0x60 // Reset to the zero pointer.\n            }\n        }\n    }\n\n    /// @dev Returns the item at key `k` for (object).\n    /// If `item` is not an object, the result's type WILL be undefined.\n    /// The key MUST be double-quoted, JSON encoded. This is for efficiency reasons.\n    /// - Correct : `item.at('\"k\"')`.\n    /// - Wrong   : `item.at(\"k\")`.\n    /// For duplicated keys, the last item with the key WILL be returned.\n    /// If there is no item with the key, the result's type WILL be undefined.\n    function at(Item memory item, string memory k) internal pure returns (Item memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x40, result) // Free the default allocation. We'll allocate manually.\n            result := 0x60 // Initialize to the zero pointer.\n        }\n        if (isObject(item)) {\n            bytes32 kHash = keccak256(bytes(k));\n            Item[] memory r = children(item);\n            // We'll just do a linear search. The alternatives are very bloated.\n            for (uint256 i = r.length << 5; i != 0;) {\n                /// @solidity memory-safe-assembly\n                assembly {\n                    item := mload(add(r, i))\n                    i := sub(i, 0x20)\n                }\n                if (keccak256(bytes(key(item))) != kHash) continue;\n                result = item;\n                break;\n            }\n        }\n    }\n\n    /// @dev Returns the item's type.\n    function getType(Item memory item) internal pure returns (uint8 result) {\n        result = uint8(item._data & _BITMASK_TYPE);\n    }\n\n    /// Note: All types are mutually exclusive.\n\n    /// @dev Returns whether the item is of type undefined.\n    function isUndefined(Item memory item) internal pure returns (bool result) {\n        result = item._data & _BITMASK_TYPE == TYPE_UNDEFINED;\n    }\n\n    /// @dev Returns whether the item is of type array.\n    function isArray(Item memory item) internal pure returns (bool result) {\n        result = item._data & _BITMASK_TYPE == TYPE_ARRAY;\n    }\n\n    /// @dev Returns whether the item is of type object.\n    function isObject(Item memory item) internal pure returns (bool result) {\n        result = item._data & _BITMASK_TYPE == TYPE_OBJECT;\n    }\n\n    /// @dev Returns whether the item is of type number.\n    function isNumber(Item memory item) internal pure returns (bool result) {\n        result = item._data & _BITMASK_TYPE == TYPE_NUMBER;\n    }\n\n    /// @dev Returns whether the item is of type string.\n    function isString(Item memory item) internal pure returns (bool result) {\n        result = item._data & _BITMASK_TYPE == TYPE_STRING;\n    }\n\n    /// @dev Returns whether the item is of type boolean.\n    function isBoolean(Item memory item) internal pure returns (bool result) {\n        result = item._data & _BITMASK_TYPE == TYPE_BOOLEAN;\n    }\n\n    /// @dev Returns whether the item is of type null.\n    function isNull(Item memory item) internal pure returns (bool result) {\n        result = item._data & _BITMASK_TYPE == TYPE_NULL;\n    }\n\n    /// @dev Returns the item's parent.\n    /// If the item does not have a parent, the result's type will be undefined.\n    function parent(Item memory item) internal pure returns (Item memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x40, result) // Free the default allocation. We've already allocated.\n            result := and(shr(_BITPOS_SIBLING_OR_PARENT, mload(item)), _BITMASK_POINTER)\n            if iszero(result) { result := 0x60 } // Reset to the zero pointer.\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                     UTILITY FUNCTIONS                      */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Parses an unsigned integer from a string (in decimal, i.e. base 10).\n    /// Reverts if `s` is not a valid uint256 string matching the RegEx `^[0-9]+$`,\n    /// or if the parsed number is too big for a uint256.\n    function parseUint(string memory s) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(s)\n            let preMulOverflowThres := div(not(0), 10)\n            for { let i := 0 } 1 {} {\n                i := add(i, 1)\n                let digit := sub(and(mload(add(s, i)), 0xff), 48)\n                let mulOverflowed := gt(result, preMulOverflowThres)\n                let product := mul(10, result)\n                result := add(product, digit)\n                n := mul(n, iszero(or(or(mulOverflowed, lt(result, product)), gt(digit, 9))))\n                if iszero(lt(i, n)) { break }\n            }\n            if iszero(n) {\n                mstore(0x00, 0x10182796) // `ParsingFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Parses a signed integer from a string (in decimal, i.e. base 10).\n    /// Reverts if `s` is not a valid int256 string matching the RegEx `^[+-]?[0-9]+$`,\n    /// or if the parsed number cannot fit within `[-2**255 .. 2**255 - 1]`.\n    function parseInt(string memory s) internal pure returns (int256 result) {\n        uint256 n = bytes(s).length;\n        uint256 sign;\n        uint256 isNegative;\n        /// @solidity memory-safe-assembly\n        assembly {\n            if n {\n                let c := and(mload(add(s, 1)), 0xff)\n                isNegative := eq(c, 45)\n                if or(eq(c, 43), isNegative) {\n                    sign := c\n                    s := add(s, 1)\n                    mstore(s, sub(n, 1))\n                }\n                if iszero(or(sign, lt(sub(c, 48), 10))) { s := 0x60 }\n            }\n        }\n        uint256 x = parseUint(s);\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(lt(x, add(shl(255, 1), isNegative))) {\n                mstore(0x00, 0x10182796) // `ParsingFailed()`.\n                revert(0x1c, 0x04)\n            }\n            if sign {\n                mstore(s, sign)\n                s := sub(s, 1)\n                mstore(s, n)\n            }\n            result := xor(x, mul(xor(x, add(not(x), 1)), isNegative))\n        }\n    }\n\n    /// @dev Parses an unsigned integer from a string (in hexadecimal, i.e. base 16).\n    /// Reverts if `s` is not a valid uint256 hex string matching the RegEx\n    /// `^(0[xX])?[0-9a-fA-F]+$`, or if the parsed number cannot fit within `[0 .. 2**256 - 1]`.\n    function parseUintFromHex(string memory s) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(s)\n            // Skip two if starts with '0x' or '0X'.\n            let i := shl(1, and(eq(0x3078, or(shr(240, mload(add(s, 0x20))), 0x20)), gt(n, 1)))\n            for {} 1 {} {\n                i := add(i, 1)\n                let c :=\n                    byte(\n                        and(0x1f, shr(and(mload(add(s, i)), 0xff), 0x3e4088843e41bac000000000000)),\n                        0x3010a071000000b0104040208000c05090d060e0f\n                    )\n                n := mul(n, iszero(or(iszero(c), shr(252, result))))\n                result := add(shl(4, result), sub(c, 1))\n                if iszero(lt(i, n)) { break }\n            }\n            if iszero(n) {\n                mstore(0x00, 0x10182796) // `ParsingFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Decodes a JSON encoded string.\n    /// The string MUST be double-quoted, JSON encoded.\n    /// Reverts if the string is invalid.\n    /// As you can see, it's pretty complex for a deceptively simple looking task.\n    function decodeString(string memory s) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function fail() {\n                mstore(0x00, 0x10182796) // `ParsingFailed()`.\n                revert(0x1c, 0x04)\n            }\n\n            function decodeUnicodeEscapeSequence(pIn_, end_) -> _unicode, _pOut {\n                _pOut := add(pIn_, 4)\n                let b_ := iszero(gt(_pOut, end_))\n                let t_ := mload(pIn_) // Load the whole word.\n                for { let i_ := 0 } iszero(eq(i_, 4)) { i_ := add(i_, 1) } {\n                    let c_ := sub(byte(i_, t_), 48)\n                    if iszero(and(shr(c_, 0x7e0000007e03ff), b_)) { fail() } // Not hexadecimal.\n                    c_ := sub(c_, add(mul(gt(c_, 16), 7), shl(5, gt(c_, 48))))\n                    _unicode := add(shl(4, _unicode), c_)\n                }\n            }\n\n            function decodeUnicodeCodePoint(pIn_, end_) -> _unicode, _pOut {\n                _unicode, _pOut := decodeUnicodeEscapeSequence(pIn_, end_)\n                if iszero(or(lt(_unicode, 0xd800), gt(_unicode, 0xdbff))) {\n                    let t_ := mload(_pOut) // Load the whole word.\n                    end_ := mul(end_, eq(shr(240, t_), 0x5c75)) // Fail if not starting with '\\\\u'.\n                    t_, _pOut := decodeUnicodeEscapeSequence(add(_pOut, 2), end_)\n                    _unicode := add(0x10000, add(shl(10, and(0x3ff, _unicode)), and(0x3ff, t_)))\n                }\n            }\n\n            function appendCodePointAsUTF8(pIn_, c_) -> _pOut {\n                if iszero(gt(c_, 0x7f)) {\n                    mstore8(pIn_, c_)\n                    _pOut := add(pIn_, 1)\n                    leave\n                }\n                mstore8(0x1f, c_)\n                mstore8(0x1e, shr(6, c_))\n                if iszero(gt(c_, 0x7ff)) {\n                    mstore(pIn_, shl(240, or(0xc080, and(0x1f3f, mload(0x00)))))\n                    _pOut := add(pIn_, 2)\n                    leave\n                }\n                mstore8(0x1d, shr(12, c_))\n                if iszero(gt(c_, 0xffff)) {\n                    mstore(pIn_, shl(232, or(0xe08080, and(0x0f3f3f, mload(0x00)))))\n                    _pOut := add(pIn_, 3)\n                    leave\n                }\n                mstore8(0x1c, shr(18, c_))\n                mstore(pIn_, shl(224, or(0xf0808080, and(0x073f3f3f, mload(0x00)))))\n                _pOut := add(pIn_, shl(2, lt(c_, 0x110000)))\n            }\n\n            function chr(p_) -> _c {\n                _c := byte(0, mload(p_))\n            }\n\n            let n := mload(s)\n            let end := add(add(s, n), 0x1f)\n            if iszero(and(gt(n, 1), eq(0x2222, or(and(0xff00, mload(add(s, 2))), chr(end))))) {\n                fail() // Fail if not double-quoted.\n            }\n            let out := add(mload(0x40), 0x20)\n            for { let curr := add(s, 0x21) } iszero(eq(curr, end)) {} {\n                let c := chr(curr)\n                curr := add(curr, 1)\n                // Not '\\\\'.\n                if iszero(eq(c, 92)) {\n                    // Not '\"'.\n                    if iszero(eq(c, 34)) {\n                        mstore8(out, c)\n                        out := add(out, 1)\n                        continue\n                    }\n                    curr := end\n                }\n                if iszero(eq(curr, end)) {\n                    let escape := chr(curr)\n                    curr := add(curr, 1)\n                    // '\"', '/', '\\\\'.\n                    if and(shr(escape, 0x100000000000800400000000), 1) {\n                        mstore8(out, escape)\n                        out := add(out, 1)\n                        continue\n                    }\n                    // 'u'.\n                    if eq(escape, 117) {\n                        escape, curr := decodeUnicodeCodePoint(curr, end)\n                        out := appendCodePointAsUTF8(out, escape)\n                        continue\n                    }\n                    // `{'b':'\\b', 'f':'\\f', 'n':'\\n', 'r':'\\r', 't':'\\t'}`.\n                    escape := byte(sub(escape, 85), 0x080000000c000000000000000a0000000d0009)\n                    if escape {\n                        mstore8(out, escape)\n                        out := add(out, 1)\n                        continue\n                    }\n                }\n                fail()\n                break\n            }\n            mstore(out, 0) // Zeroize the last slot.\n            result := mload(0x40)\n            mstore(result, sub(out, add(result, 0x20))) // Store the length.\n            mstore(0x40, add(out, 0x20)) // Allocate the memory.\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      PRIVATE HELPERS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Performs a query on the input with the given mode.\n    function _query(bytes32 input, uint256 mode) private pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function fail() {\n                mstore(0x00, 0x10182796) // `ParsingFailed()`.\n                revert(0x1c, 0x04)\n            }\n\n            function chr(p_) -> _c {\n                _c := byte(0, mload(p_))\n            }\n\n            function skipWhitespace(pIn_, end_) -> _pOut {\n                for { _pOut := pIn_ } 1 { _pOut := add(_pOut, 1) } {\n                    if iszero(and(shr(chr(_pOut), 0x100002600), 1)) { leave } // Not in ' \\n\\r\\t'.\n                }\n            }\n\n            function setP(packed_, bitpos_, p_) -> _packed {\n                // Perform an out-of-gas revert if `p_` exceeds `_BITMASK_POINTER`.\n                returndatacopy(returndatasize(), returndatasize(), gt(p_, _BITMASK_POINTER))\n                _packed := or(and(not(shl(bitpos_, _BITMASK_POINTER)), packed_), shl(bitpos_, p_))\n            }\n\n            function getP(packed_, bitpos_) -> _p {\n                _p := and(_BITMASK_POINTER, shr(bitpos_, packed_))\n            }\n\n            function mallocItem(s_, packed_, pStart_, pCurr_, type_) -> _item {\n                _item := mload(0x40)\n                // forgefmt: disable-next-item\n                packed_ := setP(setP(packed_, _BITPOS_VALUE, sub(pStart_, add(s_, 0x20))),\n                    _BITPOS_VALUE_LENGTH, sub(pCurr_, pStart_))\n                mstore(_item, or(packed_, type_))\n                mstore(0x40, add(_item, 0x20)) // Allocate memory.\n            }\n\n            function parseValue(s_, sibling_, pIn_, end_) -> _item, _pOut {\n                let packed_ := setP(mload(0x00), _BITPOS_SIBLING_OR_PARENT, sibling_)\n                _pOut := skipWhitespace(pIn_, end_)\n                if iszero(lt(_pOut, end_)) { leave }\n                for { let c_ := chr(_pOut) } 1 {} {\n                    // If starts with '\"'.\n                    if eq(c_, 34) {\n                        let pStart_ := _pOut\n                        _pOut := parseStringSub(s_, packed_, _pOut, end_)\n                        _item := mallocItem(s_, packed_, pStart_, _pOut, TYPE_STRING)\n                        break\n                    }\n                    // If starts with '['.\n                    if eq(c_, 91) {\n                        _item, _pOut := parseArray(s_, packed_, _pOut, end_)\n                        break\n                    }\n                    // If starts with '{'.\n                    if eq(c_, 123) {\n                        _item, _pOut := parseObject(s_, packed_, _pOut, end_)\n                        break\n                    }\n                    // If starts with any in '0123456789-'.\n                    if and(shr(c_, shl(45, 0x1ff9)), 1) {\n                        _item, _pOut := parseNumber(s_, packed_, _pOut, end_)\n                        break\n                    }\n                    if iszero(gt(add(_pOut, 4), end_)) {\n                        let pStart_ := _pOut\n                        let w_ := shr(224, mload(_pOut))\n                        // 'true' in hex format.\n                        if eq(w_, 0x74727565) {\n                            _pOut := add(_pOut, 4)\n                            _item := mallocItem(s_, packed_, pStart_, _pOut, TYPE_BOOLEAN)\n                            break\n                        }\n                        // 'null' in hex format.\n                        if eq(w_, 0x6e756c6c) {\n                            _pOut := add(_pOut, 4)\n                            _item := mallocItem(s_, packed_, pStart_, _pOut, TYPE_NULL)\n                            break\n                        }\n                    }\n                    if iszero(gt(add(_pOut, 5), end_)) {\n                        let pStart_ := _pOut\n                        let w_ := shr(216, mload(_pOut))\n                        // 'false' in hex format.\n                        if eq(w_, 0x66616c7365) {\n                            _pOut := add(_pOut, 5)\n                            _item := mallocItem(s_, packed_, pStart_, _pOut, TYPE_BOOLEAN)\n                            break\n                        }\n                    }\n                    fail()\n                    break\n                }\n                _pOut := skipWhitespace(_pOut, end_)\n            }\n\n            function parseArray(s_, packed_, pIn_, end_) -> _item, _pOut {\n                let j_ := 0\n                for { _pOut := add(pIn_, 1) } 1 { _pOut := add(_pOut, 1) } {\n                    if iszero(lt(_pOut, end_)) { fail() }\n                    if iszero(_item) {\n                        _pOut := skipWhitespace(_pOut, end_)\n                        if eq(chr(_pOut), 93) { break } // ']'.\n                    }\n                    _item, _pOut := parseValue(s_, _item, _pOut, end_)\n                    if _item {\n                        // forgefmt: disable-next-item\n                        mstore(_item, setP(or(_PARENT_IS_ARRAY, mload(_item)),\n                            _BITPOS_KEY, j_))\n                        j_ := add(j_, 1)\n                        let c_ := chr(_pOut)\n                        if eq(c_, 93) { break } // ']'.\n                        if eq(c_, 44) { continue } // ','.\n                    }\n                    _pOut := end_\n                }\n                _pOut := add(_pOut, 1)\n                packed_ := setP(packed_, _BITPOS_CHILD, _item)\n                _item := mallocItem(s_, packed_, pIn_, _pOut, TYPE_ARRAY)\n            }\n\n            function parseObject(s_, packed_, pIn_, end_) -> _item, _pOut {\n                for { _pOut := add(pIn_, 1) } 1 { _pOut := add(_pOut, 1) } {\n                    if iszero(lt(_pOut, end_)) { fail() }\n                    if iszero(_item) {\n                        _pOut := skipWhitespace(_pOut, end_)\n                        if eq(chr(_pOut), 125) { break } // '}'.\n                    }\n                    _pOut := skipWhitespace(_pOut, end_)\n                    let pKeyStart_ := _pOut\n                    let pKeyEnd_ := parseStringSub(s_, _item, _pOut, end_)\n                    _pOut := skipWhitespace(pKeyEnd_, end_)\n                    // If ':'.\n                    if eq(chr(_pOut), 58) {\n                        _item, _pOut := parseValue(s_, _item, add(_pOut, 1), end_)\n                        if _item {\n                            // forgefmt: disable-next-item\n                            mstore(_item, setP(setP(or(_PARENT_IS_OBJECT, mload(_item)),\n                                _BITPOS_KEY_LENGTH, sub(pKeyEnd_, pKeyStart_)),\n                                    _BITPOS_KEY, sub(pKeyStart_, add(s_, 0x20))))\n                            let c_ := chr(_pOut)\n                            if eq(c_, 125) { break } // '}'.\n                            if eq(c_, 44) { continue } // ','.\n                        }\n                    }\n                    _pOut := end_\n                }\n                _pOut := add(_pOut, 1)\n                packed_ := setP(packed_, _BITPOS_CHILD, _item)\n                _item := mallocItem(s_, packed_, pIn_, _pOut, TYPE_OBJECT)\n            }\n\n            function checkStringU(p_, o_) {\n                // If not in '0123456789abcdefABCDEF', revert.\n                if iszero(and(shr(sub(chr(add(p_, o_)), 48), 0x7e0000007e03ff), 1)) { fail() }\n                if iszero(eq(o_, 5)) { checkStringU(p_, add(o_, 1)) }\n            }\n\n            function parseStringSub(s_, packed_, pIn_, end_) -> _pOut {\n                if iszero(lt(pIn_, end_)) { fail() }\n                for { _pOut := add(pIn_, 1) } 1 {} {\n                    let c_ := chr(_pOut)\n                    if eq(c_, 34) { break } // '\"'.\n                    // Not '\\'.\n                    if iszero(eq(c_, 92)) {\n                        _pOut := add(_pOut, 1)\n                        continue\n                    }\n                    c_ := chr(add(_pOut, 1))\n                    // '\"', '\\', '//', 'b', 'f', 'n', 'r', 't'.\n                    if and(shr(sub(c_, 34), 0x510110400000000002001), 1) {\n                        _pOut := add(_pOut, 2)\n                        continue\n                    }\n                    // 'u'.\n                    if eq(c_, 117) {\n                        checkStringU(_pOut, 2)\n                        _pOut := add(_pOut, 6)\n                        continue\n                    }\n                    _pOut := end_\n                    break\n                }\n                if iszero(lt(_pOut, end_)) { fail() }\n                _pOut := add(_pOut, 1)\n            }\n\n            function skip0To9s(pIn_, end_, atLeastOne_) -> _pOut {\n                for { _pOut := pIn_ } 1 { _pOut := add(_pOut, 1) } {\n                    if iszero(lt(sub(chr(_pOut), 48), 10)) { break } // Not '0'..'9'.\n                }\n                if and(atLeastOne_, eq(pIn_, _pOut)) { fail() }\n            }\n\n            function parseNumber(s_, packed_, pIn_, end_) -> _item, _pOut {\n                _pOut := pIn_\n                if eq(chr(_pOut), 45) { _pOut := add(_pOut, 1) } // '-'.\n                if iszero(lt(sub(chr(_pOut), 48), 10)) { fail() } // Not '0'..'9'.\n                let c_ := chr(_pOut)\n                _pOut := add(_pOut, 1)\n                if iszero(eq(c_, 48)) { _pOut := skip0To9s(_pOut, end_, 0) } // Not '0'.\n                if eq(chr(_pOut), 46) { _pOut := skip0To9s(add(_pOut, 1), end_, 1) } // '.'.\n                let t_ := mload(_pOut)\n                // 'E', 'e'.\n                if eq(or(0x20, byte(0, t_)), 101) {\n                    // forgefmt: disable-next-item\n                    _pOut := skip0To9s(add(byte(sub(byte(1, t_), 14), 0x010001), // '+', '-'.\n                        add(_pOut, 1)), end_, 1)\n                }\n                _item := mallocItem(s_, packed_, pIn_, _pOut, TYPE_NUMBER)\n            }\n\n            function copyStr(s_, offset_, len_) -> _sCopy {\n                _sCopy := mload(0x40)\n                s_ := add(s_, offset_)\n                let w_ := not(0x1f)\n                for { let i_ := and(add(len_, 0x1f), w_) } 1 {} {\n                    mstore(add(_sCopy, i_), mload(add(s_, i_)))\n                    i_ := add(i_, w_) // `sub(i_, 0x20)`.\n                    if iszero(i_) { break }\n                }\n                mstore(_sCopy, len_) // Copy the length.\n                mstore(add(add(_sCopy, 0x20), len_), 0) // Zeroize the last slot.\n                mstore(0x40, add(add(_sCopy, 0x40), len_)) // Allocate memory.\n            }\n\n            function value(item_) -> _value {\n                let packed_ := mload(item_)\n                _value := getP(packed_, _BITPOS_VALUE) // The offset in the string.\n                if iszero(and(_VALUE_INITED, packed_)) {\n                    let s_ := getP(packed_, _BITPOS_STRING)\n                    _value := copyStr(s_, _value, getP(packed_, _BITPOS_VALUE_LENGTH))\n                    packed_ := setP(packed_, _BITPOS_VALUE, _value)\n                    mstore(s_, or(_VALUE_INITED, packed_))\n                }\n            }\n\n            function children(item_) -> _arr {\n                _arr := 0x60 // Initialize to the zero pointer.\n                let packed_ := mload(item_)\n                for {} iszero(gt(and(_BITMASK_TYPE, packed_), TYPE_OBJECT)) {} {\n                    if or(iszero(packed_), iszero(item_)) { break }\n                    if and(packed_, _CHILDREN_INITED) {\n                        _arr := getP(packed_, _BITPOS_CHILD)\n                        break\n                    }\n                    _arr := mload(0x40)\n                    let o_ := add(_arr, 0x20)\n                    for { let h_ := getP(packed_, _BITPOS_CHILD) } h_ {} {\n                        mstore(o_, h_)\n                        let q_ := mload(h_)\n                        let y_ := getP(q_, _BITPOS_SIBLING_OR_PARENT)\n                        mstore(h_, setP(q_, _BITPOS_SIBLING_OR_PARENT, item_))\n                        h_ := y_\n                        o_ := add(o_, 0x20)\n                    }\n                    let w_ := not(0x1f)\n                    let n_ := add(w_, sub(o_, _arr))\n                    mstore(_arr, shr(5, n_))\n                    mstore(0x40, o_) // Allocate memory.\n                    packed_ := setP(packed_, _BITPOS_CHILD, _arr)\n                    mstore(item_, or(_CHILDREN_INITED, packed_))\n                    // Reverse the array.\n                    if iszero(lt(n_, 0x40)) {\n                        let lo_ := add(_arr, 0x20)\n                        let hi_ := add(_arr, n_)\n                        for {} 1 {} {\n                            let temp_ := mload(lo_)\n                            mstore(lo_, mload(hi_))\n                            mstore(hi_, temp_)\n                            hi_ := add(hi_, w_)\n                            lo_ := add(lo_, 0x20)\n                            if iszero(lt(lo_, hi_)) { break }\n                        }\n                    }\n                    break\n                }\n            }\n\n            function getStr(item_, bitpos_, bitposLength_, bitmaskInited_) -> _result {\n                _result := 0x60 // Initialize to the zero pointer.\n                let packed_ := mload(item_)\n                if or(iszero(item_), iszero(packed_)) { leave }\n                _result := getP(packed_, bitpos_)\n                if iszero(and(bitmaskInited_, packed_)) {\n                    let s_ := getP(packed_, _BITPOS_STRING)\n                    _result := copyStr(s_, _result, getP(packed_, bitposLength_))\n                    mstore(item_, or(bitmaskInited_, setP(packed_, bitpos_, _result)))\n                }\n            }\n\n            switch mode\n            // Get value.\n            case 0 { result := getStr(input, _BITPOS_VALUE, _BITPOS_VALUE_LENGTH, _VALUE_INITED) }\n            // Get key.\n            case 1 { result := getStr(input, _BITPOS_KEY, _BITPOS_KEY_LENGTH, _KEY_INITED) }\n            // Get children.\n            case 3 { result := children(input) }\n            // Parse.\n            default {\n                let p := add(input, 0x20)\n                let e := add(p, mload(input))\n                if iszero(eq(p, e)) {\n                    let c := chr(e)\n                    mstore8(e, 34) // Place a '\"' at the end to speed up parsing.\n                    // The `34 << 248` makes `mallocItem` preserve '\"' at the end.\n                    mstore(0x00, setP(shl(248, 34), _BITPOS_STRING, input))\n                    result, p := parseValue(input, 0, p, e)\n                    mstore8(e, c) // Restore the original char at the end.\n                }\n                if or(lt(p, e), iszero(result)) { fail() }\n            }\n        }\n    }\n\n    /// @dev Casts the input to a bytes32.\n    function _toInput(string memory input) private pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := input\n        }\n    }\n\n    /// @dev Casts the input to a bytes32.\n    function _toInput(Item memory input) private pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := input\n        }\n    }\n}\n"
    },
    "solady/utils/LibString.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Library for converting numbers into strings and other string operations.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibString.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/LibString.sol)\n///\n/// @dev Note:\n/// For performance and bytecode compactness, most of the string operations are restricted to\n/// byte strings (7-bit ASCII), except where otherwise specified.\n/// Usage of byte string operations on charsets with runes spanning two or more bytes\n/// can lead to undefined behavior.\nlibrary LibString {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                        CUSTOM ERRORS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The length of the output is too small to contain all the hex digits.\n    error HexLengthInsufficient();\n\n    /// @dev The length of the string is more than 32 bytes.\n    error TooBigForSmallString();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         CONSTANTS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The constant returned when the `search` is not found in the string.\n    uint256 internal constant NOT_FOUND = type(uint256).max;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                     DECIMAL OPERATIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the base 10 decimal representation of `value`.\n    function toString(uint256 value) internal pure returns (string memory str) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but\n            // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.\n            // We will need 1 word for the trailing zeros padding, 1 word for the length,\n            // and 3 words for a maximum of 78 digits.\n            str := add(mload(0x40), 0x80)\n            // Update the free memory pointer to allocate.\n            mstore(0x40, add(str, 0x20))\n            // Zeroize the slot after the string.\n            mstore(str, 0)\n\n            // Cache the end of the memory to calculate the length later.\n            let end := str\n\n            let w := not(0) // Tsk.\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            for { let temp := value } 1 {} {\n                str := add(str, w) // `sub(str, 1)`.\n                // Write the character to the pointer.\n                // The ASCII index of the '0' character is 48.\n                mstore8(str, add(48, mod(temp, 10)))\n                // Keep dividing `temp` until zero.\n                temp := div(temp, 10)\n                if iszero(temp) { break }\n            }\n\n            let length := sub(end, str)\n            // Move the pointer 32 bytes leftwards to make room for the length.\n            str := sub(str, 0x20)\n            // Store the length.\n            mstore(str, length)\n        }\n    }\n\n    /// @dev Returns the base 10 decimal representation of `value`.\n    function toString(int256 value) internal pure returns (string memory str) {\n        if (value >= 0) {\n            return toString(uint256(value));\n        }\n        unchecked {\n            str = toString(~uint256(value) + 1);\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We still have some spare memory space on the left,\n            // as we have allocated 3 words (96 bytes) for up to 78 digits.\n            let length := mload(str) // Load the string length.\n            mstore(str, 0x2d) // Store the '-' character.\n            str := sub(str, 1) // Move back the string pointer by a byte.\n            mstore(str, add(length, 1)) // Update the string length.\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   HEXADECIMAL OPERATIONS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the hexadecimal representation of `value`,\n    /// left-padded to an input length of `length` bytes.\n    /// The output is prefixed with \"0x\" encoded using 2 hexadecimal digits per byte,\n    /// giving a total length of `length * 2 + 2` bytes.\n    /// Reverts if `length` is too small for the output to contain all the digits.\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory str) {\n        str = toHexStringNoPrefix(value, length);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let strLength := add(mload(str), 2) // Compute the length.\n            mstore(str, 0x3078) // Write the \"0x\" prefix.\n            str := sub(str, 2) // Move the pointer.\n            mstore(str, strLength) // Write the length.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`,\n    /// left-padded to an input length of `length` bytes.\n    /// The output is prefixed with \"0x\" encoded using 2 hexadecimal digits per byte,\n    /// giving a total length of `length * 2` bytes.\n    /// Reverts if `length` is too small for the output to contain all the digits.\n    function toHexStringNoPrefix(uint256 value, uint256 length)\n        internal\n        pure\n        returns (string memory str)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We need 0x20 bytes for the trailing zeros padding, `length * 2` bytes\n            // for the digits, 0x02 bytes for the prefix, and 0x20 bytes for the length.\n            // We add 0x20 to the total and round down to a multiple of 0x20.\n            // (0x20 + 0x20 + 0x02 + 0x20) = 0x62.\n            str := add(mload(0x40), and(add(shl(1, length), 0x42), not(0x1f)))\n            // Allocate the memory.\n            mstore(0x40, add(str, 0x20))\n            // Zeroize the slot after the string.\n            mstore(str, 0)\n\n            // Cache the end to calculate the length later.\n            let end := str\n            // Store \"0123456789abcdef\" in scratch space.\n            mstore(0x0f, 0x30313233343536373839616263646566)\n\n            let start := sub(str, add(length, length))\n            let w := not(1) // Tsk.\n            let temp := value\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            for {} 1 {} {\n                str := add(str, w) // `sub(str, 2)`.\n                mstore8(add(str, 1), mload(and(temp, 15)))\n                mstore8(str, mload(and(shr(4, temp), 15)))\n                temp := shr(8, temp)\n                if iszero(xor(str, start)) { break }\n            }\n\n            if temp {\n                mstore(0x00, 0x2194895a) // `HexLengthInsufficient()`.\n                revert(0x1c, 0x04)\n            }\n\n            // Compute the string's length.\n            let strLength := sub(end, str)\n            // Move the pointer and write the length.\n            str := sub(str, 0x20)\n            mstore(str, strLength)\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is prefixed with \"0x\" and encoded using 2 hexadecimal digits per byte.\n    /// As address are 20 bytes long, the output will left-padded to have\n    /// a length of `20 * 2 + 2` bytes.\n    function toHexString(uint256 value) internal pure returns (string memory str) {\n        str = toHexStringNoPrefix(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let strLength := add(mload(str), 2) // Compute the length.\n            mstore(str, 0x3078) // Write the \"0x\" prefix.\n            str := sub(str, 2) // Move the pointer.\n            mstore(str, strLength) // Write the length.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is prefixed with \"0x\".\n    /// The output excludes leading \"0\" from the `toHexString` output.\n    /// `0x00: \"0x0\", 0x01: \"0x1\", 0x12: \"0x12\", 0x123: \"0x123\"`.\n    function toMinimalHexString(uint256 value) internal pure returns (string memory str) {\n        str = toHexStringNoPrefix(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.\n            let strLength := add(mload(str), 2) // Compute the length.\n            mstore(add(str, o), 0x3078) // Write the \"0x\" prefix, accounting for leading zero.\n            str := sub(add(str, o), 2) // Move the pointer, accounting for leading zero.\n            mstore(str, sub(strLength, o)) // Write the length, accounting for leading zero.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output excludes leading \"0\" from the `toHexStringNoPrefix` output.\n    /// `0x00: \"0\", 0x01: \"1\", 0x12: \"12\", 0x123: \"123\"`.\n    function toMinimalHexStringNoPrefix(uint256 value) internal pure returns (string memory str) {\n        str = toHexStringNoPrefix(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.\n            let strLength := mload(str) // Get the length.\n            str := add(str, o) // Move the pointer, accounting for leading zero.\n            mstore(str, sub(strLength, o)) // Write the length, accounting for leading zero.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is encoded using 2 hexadecimal digits per byte.\n    /// As address are 20 bytes long, the output will left-padded to have\n    /// a length of `20 * 2` bytes.\n    function toHexStringNoPrefix(uint256 value) internal pure returns (string memory str) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\n            // 0x02 bytes for the prefix, and 0x40 bytes for the digits.\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x40) is 0xa0.\n            str := add(mload(0x40), 0x80)\n            // Allocate the memory.\n            mstore(0x40, add(str, 0x20))\n            // Zeroize the slot after the string.\n            mstore(str, 0)\n\n            // Cache the end to calculate the length later.\n            let end := str\n            // Store \"0123456789abcdef\" in scratch space.\n            mstore(0x0f, 0x30313233343536373839616263646566)\n\n            let w := not(1) // Tsk.\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            for { let temp := value } 1 {} {\n                str := add(str, w) // `sub(str, 2)`.\n                mstore8(add(str, 1), mload(and(temp, 15)))\n                mstore8(str, mload(and(shr(4, temp), 15)))\n                temp := shr(8, temp)\n                if iszero(temp) { break }\n            }\n\n            // Compute the string's length.\n            let strLength := sub(end, str)\n            // Move the pointer and write the length.\n            str := sub(str, 0x20)\n            mstore(str, strLength)\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is prefixed with \"0x\", encoded using 2 hexadecimal digits per byte,\n    /// and the alphabets are capitalized conditionally according to\n    /// https://eips.ethereum.org/EIPS/eip-55\n    function toHexStringChecksummed(address value) internal pure returns (string memory str) {\n        str = toHexString(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let mask := shl(6, div(not(0), 255)) // `0b010000000100000000 ...`\n            let o := add(str, 0x22)\n            let hashed := and(keccak256(o, 40), mul(34, mask)) // `0b10001000 ... `\n            let t := shl(240, 136) // `0b10001000 << 240`\n            for { let i := 0 } 1 {} {\n                mstore(add(i, i), mul(t, byte(i, hashed)))\n                i := add(i, 1)\n                if eq(i, 20) { break }\n            }\n            mstore(o, xor(mload(o), shr(1, and(mload(0x00), and(mload(o), mask)))))\n            o := add(o, 0x20)\n            mstore(o, xor(mload(o), shr(1, and(mload(0x20), and(mload(o), mask)))))\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is prefixed with \"0x\" and encoded using 2 hexadecimal digits per byte.\n    function toHexString(address value) internal pure returns (string memory str) {\n        str = toHexStringNoPrefix(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let strLength := add(mload(str), 2) // Compute the length.\n            mstore(str, 0x3078) // Write the \"0x\" prefix.\n            str := sub(str, 2) // Move the pointer.\n            mstore(str, strLength) // Write the length.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is encoded using 2 hexadecimal digits per byte.\n    function toHexStringNoPrefix(address value) internal pure returns (string memory str) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            str := mload(0x40)\n\n            // Allocate the memory.\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\n            // 0x02 bytes for the prefix, and 0x28 bytes for the digits.\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x28) is 0x80.\n            mstore(0x40, add(str, 0x80))\n\n            // Store \"0123456789abcdef\" in scratch space.\n            mstore(0x0f, 0x30313233343536373839616263646566)\n\n            str := add(str, 2)\n            mstore(str, 40)\n\n            let o := add(str, 0x20)\n            mstore(add(o, 40), 0)\n\n            value := shl(96, value)\n\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            for { let i := 0 } 1 {} {\n                let p := add(o, add(i, i))\n                let temp := byte(i, value)\n                mstore8(add(p, 1), mload(and(temp, 15)))\n                mstore8(p, mload(shr(4, temp)))\n                i := add(i, 1)\n                if eq(i, 20) { break }\n            }\n        }\n    }\n\n    /// @dev Returns the hex encoded string from the raw bytes.\n    /// The output is encoded using 2 hexadecimal digits per byte.\n    function toHexString(bytes memory raw) internal pure returns (string memory str) {\n        str = toHexStringNoPrefix(raw);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let strLength := add(mload(str), 2) // Compute the length.\n            mstore(str, 0x3078) // Write the \"0x\" prefix.\n            str := sub(str, 2) // Move the pointer.\n            mstore(str, strLength) // Write the length.\n        }\n    }\n\n    /// @dev Returns the hex encoded string from the raw bytes.\n    /// The output is encoded using 2 hexadecimal digits per byte.\n    function toHexStringNoPrefix(bytes memory raw) internal pure returns (string memory str) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let length := mload(raw)\n            str := add(mload(0x40), 2) // Skip 2 bytes for the optional prefix.\n            mstore(str, add(length, length)) // Store the length of the output.\n\n            // Store \"0123456789abcdef\" in scratch space.\n            mstore(0x0f, 0x30313233343536373839616263646566)\n\n            let o := add(str, 0x20)\n            let end := add(raw, length)\n\n            for {} iszero(eq(raw, end)) {} {\n                raw := add(raw, 1)\n                mstore8(add(o, 1), mload(and(mload(raw), 15)))\n                mstore8(o, mload(and(shr(4, mload(raw)), 15)))\n                o := add(o, 2)\n            }\n            mstore(o, 0) // Zeroize the slot after the string.\n            mstore(0x40, add(o, 0x20)) // Allocate the memory.\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   RUNE STRING OPERATIONS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the number of UTF characters in the string.\n    function runeCount(string memory s) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if mload(s) {\n                mstore(0x00, div(not(0), 255))\n                mstore(0x20, 0x0202020202020202020202020202020202020202020202020303030304040506)\n                let o := add(s, 0x20)\n                let end := add(o, mload(s))\n                for { result := 1 } 1 { result := add(result, 1) } {\n                    o := add(o, byte(0, mload(shr(250, mload(o)))))\n                    if iszero(lt(o, end)) { break }\n                }\n            }\n        }\n    }\n\n    /// @dev Returns if this string is a 7-bit ASCII string.\n    /// (i.e. all characters codes are in [0..127])\n    function is7BitASCII(string memory s) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let mask := shl(7, div(not(0), 255))\n            result := 1\n            let n := mload(s)\n            if n {\n                let o := add(s, 0x20)\n                let end := add(o, n)\n                let last := mload(end)\n                mstore(end, 0)\n                for {} 1 {} {\n                    if and(mask, mload(o)) {\n                        result := 0\n                        break\n                    }\n                    o := add(o, 0x20)\n                    if iszero(lt(o, end)) { break }\n                }\n                mstore(end, last)\n            }\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   BYTE STRING OPERATIONS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // For performance and bytecode compactness, byte string operations are restricted\n    // to 7-bit ASCII strings. All offsets are byte offsets, not UTF character offsets.\n    // Usage of byte string operations on charsets with runes spanning two or more bytes\n    // can lead to undefined behavior.\n\n    /// @dev Returns `subject` all occurrences of `search` replaced with `replacement`.\n    function replace(string memory subject, string memory search, string memory replacement)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let subjectLength := mload(subject)\n            let searchLength := mload(search)\n            let replacementLength := mload(replacement)\n\n            subject := add(subject, 0x20)\n            search := add(search, 0x20)\n            replacement := add(replacement, 0x20)\n            result := add(mload(0x40), 0x20)\n\n            let subjectEnd := add(subject, subjectLength)\n            if iszero(gt(searchLength, subjectLength)) {\n                let subjectSearchEnd := add(sub(subjectEnd, searchLength), 1)\n                let h := 0\n                if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\n                let s := mload(search)\n                for {} 1 {} {\n                    let t := mload(subject)\n                    // Whether the first `searchLength % 32` bytes of\n                    // `subject` and `search` matches.\n                    if iszero(shr(m, xor(t, s))) {\n                        if h {\n                            if iszero(eq(keccak256(subject, searchLength), h)) {\n                                mstore(result, t)\n                                result := add(result, 1)\n                                subject := add(subject, 1)\n                                if iszero(lt(subject, subjectSearchEnd)) { break }\n                                continue\n                            }\n                        }\n                        // Copy the `replacement` one word at a time.\n                        for { let o := 0 } 1 {} {\n                            mstore(add(result, o), mload(add(replacement, o)))\n                            o := add(o, 0x20)\n                            if iszero(lt(o, replacementLength)) { break }\n                        }\n                        result := add(result, replacementLength)\n                        subject := add(subject, searchLength)\n                        if searchLength {\n                            if iszero(lt(subject, subjectSearchEnd)) { break }\n                            continue\n                        }\n                    }\n                    mstore(result, t)\n                    result := add(result, 1)\n                    subject := add(subject, 1)\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\n                }\n            }\n\n            let resultRemainder := result\n            result := add(mload(0x40), 0x20)\n            let k := add(sub(resultRemainder, result), sub(subjectEnd, subject))\n            // Copy the rest of the string one word at a time.\n            for {} lt(subject, subjectEnd) {} {\n                mstore(resultRemainder, mload(subject))\n                resultRemainder := add(resultRemainder, 0x20)\n                subject := add(subject, 0x20)\n            }\n            result := sub(result, 0x20)\n            let last := add(add(result, 0x20), k) // Zeroize the slot after the string.\n            mstore(last, 0)\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\n            mstore(result, k) // Store the length.\n        }\n    }\n\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\n    /// searching from left to right, starting from `from`.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\n    function indexOf(string memory subject, string memory search, uint256 from)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for { let subjectLength := mload(subject) } 1 {} {\n                if iszero(mload(search)) {\n                    if iszero(gt(from, subjectLength)) {\n                        result := from\n                        break\n                    }\n                    result := subjectLength\n                    break\n                }\n                let searchLength := mload(search)\n                let subjectStart := add(subject, 0x20)\n\n                result := not(0) // Initialize to `NOT_FOUND`.\n\n                subject := add(subjectStart, from)\n                let end := add(sub(add(subjectStart, subjectLength), searchLength), 1)\n\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\n                let s := mload(add(search, 0x20))\n\n                if iszero(and(lt(subject, end), lt(from, subjectLength))) { break }\n\n                if iszero(lt(searchLength, 0x20)) {\n                    for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {\n                        if iszero(shr(m, xor(mload(subject), s))) {\n                            if eq(keccak256(subject, searchLength), h) {\n                                result := sub(subject, subjectStart)\n                                break\n                            }\n                        }\n                        subject := add(subject, 1)\n                        if iszero(lt(subject, end)) { break }\n                    }\n                    break\n                }\n                for {} 1 {} {\n                    if iszero(shr(m, xor(mload(subject), s))) {\n                        result := sub(subject, subjectStart)\n                        break\n                    }\n                    subject := add(subject, 1)\n                    if iszero(lt(subject, end)) { break }\n                }\n                break\n            }\n        }\n    }\n\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\n    /// searching from left to right.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\n    function indexOf(string memory subject, string memory search)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        result = indexOf(subject, search, 0);\n    }\n\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\n    /// searching from right to left, starting from `from`.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\n    function lastIndexOf(string memory subject, string memory search, uint256 from)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for {} 1 {} {\n                result := not(0) // Initialize to `NOT_FOUND`.\n                let searchLength := mload(search)\n                if gt(searchLength, mload(subject)) { break }\n                let w := result\n\n                let fromMax := sub(mload(subject), searchLength)\n                if iszero(gt(fromMax, from)) { from := fromMax }\n\n                let end := add(add(subject, 0x20), w)\n                subject := add(add(subject, 0x20), from)\n                if iszero(gt(subject, end)) { break }\n                // As this function is not too often used,\n                // we shall simply use keccak256 for smaller bytecode size.\n                for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {\n                    if eq(keccak256(subject, searchLength), h) {\n                        result := sub(subject, add(end, 1))\n                        break\n                    }\n                    subject := add(subject, w) // `sub(subject, 1)`.\n                    if iszero(gt(subject, end)) { break }\n                }\n                break\n            }\n        }\n    }\n\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\n    /// searching from right to left.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\n    function lastIndexOf(string memory subject, string memory search)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        result = lastIndexOf(subject, search, uint256(int256(-1)));\n    }\n\n    /// @dev Returns true if `search` is found in `subject`, false otherwise.\n    function contains(string memory subject, string memory search) internal pure returns (bool) {\n        return indexOf(subject, search) != NOT_FOUND;\n    }\n\n    /// @dev Returns whether `subject` starts with `search`.\n    function startsWith(string memory subject, string memory search)\n        internal\n        pure\n        returns (bool result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let searchLength := mload(search)\n            // Just using keccak256 directly is actually cheaper.\n            // forgefmt: disable-next-item\n            result := and(\n                iszero(gt(searchLength, mload(subject))),\n                eq(\n                    keccak256(add(subject, 0x20), searchLength),\n                    keccak256(add(search, 0x20), searchLength)\n                )\n            )\n        }\n    }\n\n    /// @dev Returns whether `subject` ends with `search`.\n    function endsWith(string memory subject, string memory search)\n        internal\n        pure\n        returns (bool result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let searchLength := mload(search)\n            let subjectLength := mload(subject)\n            // Whether `search` is not longer than `subject`.\n            let withinRange := iszero(gt(searchLength, subjectLength))\n            // Just using keccak256 directly is actually cheaper.\n            // forgefmt: disable-next-item\n            result := and(\n                withinRange,\n                eq(\n                    keccak256(\n                        // `subject + 0x20 + max(subjectLength - searchLength, 0)`.\n                        add(add(subject, 0x20), mul(withinRange, sub(subjectLength, searchLength))),\n                        searchLength\n                    ),\n                    keccak256(add(search, 0x20), searchLength)\n                )\n            )\n        }\n    }\n\n    /// @dev Returns `subject` repeated `times`.\n    function repeat(string memory subject, uint256 times)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let subjectLength := mload(subject)\n            if iszero(or(iszero(times), iszero(subjectLength))) {\n                subject := add(subject, 0x20)\n                result := mload(0x40)\n                let output := add(result, 0x20)\n                for {} 1 {} {\n                    // Copy the `subject` one word at a time.\n                    for { let o := 0 } 1 {} {\n                        mstore(add(output, o), mload(add(subject, o)))\n                        o := add(o, 0x20)\n                        if iszero(lt(o, subjectLength)) { break }\n                    }\n                    output := add(output, subjectLength)\n                    times := sub(times, 1)\n                    if iszero(times) { break }\n                }\n                mstore(output, 0) // Zeroize the slot after the string.\n                let resultLength := sub(output, add(result, 0x20))\n                mstore(result, resultLength) // Store the length.\n                // Allocate the memory.\n                mstore(0x40, add(result, add(resultLength, 0x20)))\n            }\n        }\n    }\n\n    /// @dev Returns a copy of `subject` sliced from `start` to `end` (exclusive).\n    /// `start` and `end` are byte offsets.\n    function slice(string memory subject, uint256 start, uint256 end)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let subjectLength := mload(subject)\n            if iszero(gt(subjectLength, end)) { end := subjectLength }\n            if iszero(gt(subjectLength, start)) { start := subjectLength }\n            if lt(start, end) {\n                result := mload(0x40)\n                let resultLength := sub(end, start)\n                mstore(result, resultLength)\n                subject := add(subject, start)\n                let w := not(0x1f)\n                // Copy the `subject` one word at a time, backwards.\n                for { let o := and(add(resultLength, 0x1f), w) } 1 {} {\n                    mstore(add(result, o), mload(add(subject, o)))\n                    o := add(o, w) // `sub(o, 0x20)`.\n                    if iszero(o) { break }\n                }\n                // Zeroize the slot after the string.\n                mstore(add(add(result, 0x20), resultLength), 0)\n                // Allocate memory for the length and the bytes,\n                // rounded up to a multiple of 32.\n                mstore(0x40, add(result, and(add(resultLength, 0x3f), w)))\n            }\n        }\n    }\n\n    /// @dev Returns a copy of `subject` sliced from `start` to the end of the string.\n    /// `start` is a byte offset.\n    function slice(string memory subject, uint256 start)\n        internal\n        pure\n        returns (string memory result)\n    {\n        result = slice(subject, start, uint256(int256(-1)));\n    }\n\n    /// @dev Returns all the indices of `search` in `subject`.\n    /// The indices are byte offsets.\n    function indicesOf(string memory subject, string memory search)\n        internal\n        pure\n        returns (uint256[] memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let subjectLength := mload(subject)\n            let searchLength := mload(search)\n\n            if iszero(gt(searchLength, subjectLength)) {\n                subject := add(subject, 0x20)\n                search := add(search, 0x20)\n                result := add(mload(0x40), 0x20)\n\n                let subjectStart := subject\n                let subjectSearchEnd := add(sub(add(subject, subjectLength), searchLength), 1)\n                let h := 0\n                if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\n                let s := mload(search)\n                for {} 1 {} {\n                    let t := mload(subject)\n                    // Whether the first `searchLength % 32` bytes of\n                    // `subject` and `search` matches.\n                    if iszero(shr(m, xor(t, s))) {\n                        if h {\n                            if iszero(eq(keccak256(subject, searchLength), h)) {\n                                subject := add(subject, 1)\n                                if iszero(lt(subject, subjectSearchEnd)) { break }\n                                continue\n                            }\n                        }\n                        // Append to `result`.\n                        mstore(result, sub(subject, subjectStart))\n                        result := add(result, 0x20)\n                        // Advance `subject` by `searchLength`.\n                        subject := add(subject, searchLength)\n                        if searchLength {\n                            if iszero(lt(subject, subjectSearchEnd)) { break }\n                            continue\n                        }\n                    }\n                    subject := add(subject, 1)\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\n                }\n                let resultEnd := result\n                // Assign `result` to the free memory pointer.\n                result := mload(0x40)\n                // Store the length of `result`.\n                mstore(result, shr(5, sub(resultEnd, add(result, 0x20))))\n                // Allocate memory for result.\n                // We allocate one more word, so this array can be recycled for {split}.\n                mstore(0x40, add(resultEnd, 0x20))\n            }\n        }\n    }\n\n    /// @dev Returns a arrays of strings based on the `delimiter` inside of the `subject` string.\n    function split(string memory subject, string memory delimiter)\n        internal\n        pure\n        returns (string[] memory result)\n    {\n        uint256[] memory indices = indicesOf(subject, delimiter);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let w := not(0x1f)\n            let indexPtr := add(indices, 0x20)\n            let indicesEnd := add(indexPtr, shl(5, add(mload(indices), 1)))\n            mstore(add(indicesEnd, w), mload(subject))\n            mstore(indices, add(mload(indices), 1))\n            let prevIndex := 0\n            for {} 1 {} {\n                let index := mload(indexPtr)\n                mstore(indexPtr, 0x60)\n                if iszero(eq(index, prevIndex)) {\n                    let element := mload(0x40)\n                    let elementLength := sub(index, prevIndex)\n                    mstore(element, elementLength)\n                    // Copy the `subject` one word at a time, backwards.\n                    for { let o := and(add(elementLength, 0x1f), w) } 1 {} {\n                        mstore(add(element, o), mload(add(add(subject, prevIndex), o)))\n                        o := add(o, w) // `sub(o, 0x20)`.\n                        if iszero(o) { break }\n                    }\n                    // Zeroize the slot after the string.\n                    mstore(add(add(element, 0x20), elementLength), 0)\n                    // Allocate memory for the length and the bytes,\n                    // rounded up to a multiple of 32.\n                    mstore(0x40, add(element, and(add(elementLength, 0x3f), w)))\n                    // Store the `element` into the array.\n                    mstore(indexPtr, element)\n                }\n                prevIndex := add(index, mload(delimiter))\n                indexPtr := add(indexPtr, 0x20)\n                if iszero(lt(indexPtr, indicesEnd)) { break }\n            }\n            result := indices\n            if iszero(mload(delimiter)) {\n                result := add(indices, 0x20)\n                mstore(result, sub(mload(indices), 2))\n            }\n        }\n    }\n\n    /// @dev Returns a concatenated string of `a` and `b`.\n    /// Cheaper than `string.concat()` and does not de-align the free memory pointer.\n    function concat(string memory a, string memory b)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let w := not(0x1f)\n            result := mload(0x40)\n            let aLength := mload(a)\n            // Copy `a` one word at a time, backwards.\n            for { let o := and(add(aLength, 0x20), w) } 1 {} {\n                mstore(add(result, o), mload(add(a, o)))\n                o := add(o, w) // `sub(o, 0x20)`.\n                if iszero(o) { break }\n            }\n            let bLength := mload(b)\n            let output := add(result, aLength)\n            // Copy `b` one word at a time, backwards.\n            for { let o := and(add(bLength, 0x20), w) } 1 {} {\n                mstore(add(output, o), mload(add(b, o)))\n                o := add(o, w) // `sub(o, 0x20)`.\n                if iszero(o) { break }\n            }\n            let totalLength := add(aLength, bLength)\n            let last := add(add(result, 0x20), totalLength)\n            // Zeroize the slot after the string.\n            mstore(last, 0)\n            // Stores the length.\n            mstore(result, totalLength)\n            // Allocate memory for the length and the bytes,\n            // rounded up to a multiple of 32.\n            mstore(0x40, and(add(last, 0x1f), w))\n        }\n    }\n\n    /// @dev Returns a copy of the string in either lowercase or UPPERCASE.\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\n    function toCase(string memory subject, bool toUpper)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let length := mload(subject)\n            if length {\n                result := add(mload(0x40), 0x20)\n                subject := add(subject, 1)\n                let flags := shl(add(70, shl(5, toUpper)), 0x3ffffff)\n                let w := not(0)\n                for { let o := length } 1 {} {\n                    o := add(o, w)\n                    let b := and(0xff, mload(add(subject, o)))\n                    mstore8(add(result, o), xor(b, and(shr(b, flags), 0x20)))\n                    if iszero(o) { break }\n                }\n                result := mload(0x40)\n                mstore(result, length) // Store the length.\n                let last := add(add(result, 0x20), length)\n                mstore(last, 0) // Zeroize the slot after the string.\n                mstore(0x40, add(last, 0x20)) // Allocate the memory.\n            }\n        }\n    }\n\n    /// @dev Returns a string from a small bytes32 string.\n    /// `s` must be null-terminated, or behavior will be undefined.\n    function fromSmallString(bytes32 s) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            let n := 0\n            for {} byte(n, s) { n := add(n, 1) } {} // Scan for '\\0'.\n            mstore(result, n)\n            let o := add(result, 0x20)\n            mstore(o, s)\n            mstore(add(o, n), 0)\n            mstore(0x40, add(result, 0x40))\n        }\n    }\n\n    /// @dev Returns the small string, with all bytes after the first null byte zeroized.\n    function normalizeSmallString(bytes32 s) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for {} byte(result, s) { result := add(result, 1) } {} // Scan for '\\0'.\n            mstore(0x00, s)\n            mstore(result, 0x00)\n            result := mload(0x00)\n        }\n    }\n\n    /// @dev Returns the string as a normalized null-terminated small string.\n    function toSmallString(string memory s) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(s)\n            if iszero(lt(result, 33)) {\n                mstore(0x00, 0xec92f9a3) // `TooBigForSmallString()`.\n                revert(0x1c, 0x04)\n            }\n            result := shl(shl(3, sub(32, result)), mload(add(s, result)))\n        }\n    }\n\n    /// @dev Returns a lowercased copy of the string.\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\n    function lower(string memory subject) internal pure returns (string memory result) {\n        result = toCase(subject, false);\n    }\n\n    /// @dev Returns an UPPERCASED copy of the string.\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\n    function upper(string memory subject) internal pure returns (string memory result) {\n        result = toCase(subject, true);\n    }\n\n    /// @dev Escapes the string to be used within HTML tags.\n    function escapeHTML(string memory s) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let end := add(s, mload(s))\n            result := add(mload(0x40), 0x20)\n            // Store the bytes of the packed offsets and strides into the scratch space.\n            // `packed = (stride << 5) | offset`. Max offset is 20. Max stride is 6.\n            mstore(0x1f, 0x900094)\n            mstore(0x08, 0xc0000000a6ab)\n            // Store \"&quot;&amp;&#39;&lt;&gt;\" into the scratch space.\n            mstore(0x00, shl(64, 0x2671756f743b26616d703b262333393b266c743b2667743b))\n            for {} iszero(eq(s, end)) {} {\n                s := add(s, 1)\n                let c := and(mload(s), 0xff)\n                // Not in `[\"\\\"\",\"'\",\"&\",\"<\",\">\"]`.\n                if iszero(and(shl(c, 1), 0x500000c400000000)) {\n                    mstore8(result, c)\n                    result := add(result, 1)\n                    continue\n                }\n                let t := shr(248, mload(c))\n                mstore(result, mload(and(t, 0x1f)))\n                result := add(result, shr(5, t))\n            }\n            let last := result\n            mstore(last, 0) // Zeroize the slot after the string.\n            result := mload(0x40)\n            mstore(result, sub(last, add(result, 0x20))) // Store the length.\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\n        }\n    }\n\n    /// @dev Escapes the string to be used within double-quotes in a JSON.\n    /// If `addDoubleQuotes` is true, the result will be enclosed in double-quotes.\n    function escapeJSON(string memory s, bool addDoubleQuotes)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let end := add(s, mload(s))\n            result := add(mload(0x40), 0x20)\n            if addDoubleQuotes {\n                mstore8(result, 34)\n                result := add(1, result)\n            }\n            // Store \"\\\\u0000\" in scratch space.\n            // Store \"0123456789abcdef\" in scratch space.\n            // Also, store `{0x08:\"b\", 0x09:\"t\", 0x0a:\"n\", 0x0c:\"f\", 0x0d:\"r\"}`.\n            // into the scratch space.\n            mstore(0x15, 0x5c75303030303031323334353637383961626364656662746e006672)\n            // Bitmask for detecting `[\"\\\"\",\"\\\\\"]`.\n            let e := or(shl(0x22, 1), shl(0x5c, 1))\n            for {} iszero(eq(s, end)) {} {\n                s := add(s, 1)\n                let c := and(mload(s), 0xff)\n                if iszero(lt(c, 0x20)) {\n                    if iszero(and(shl(c, 1), e)) {\n                        // Not in `[\"\\\"\",\"\\\\\"]`.\n                        mstore8(result, c)\n                        result := add(result, 1)\n                        continue\n                    }\n                    mstore8(result, 0x5c) // \"\\\\\".\n                    mstore8(add(result, 1), c)\n                    result := add(result, 2)\n                    continue\n                }\n                if iszero(and(shl(c, 1), 0x3700)) {\n                    // Not in `[\"\\b\",\"\\t\",\"\\n\",\"\\f\",\"\\d\"]`.\n                    mstore8(0x1d, mload(shr(4, c))) // Hex value.\n                    mstore8(0x1e, mload(and(c, 15))) // Hex value.\n                    mstore(result, mload(0x19)) // \"\\\\u00XX\".\n                    result := add(result, 6)\n                    continue\n                }\n                mstore8(result, 0x5c) // \"\\\\\".\n                mstore8(add(result, 1), mload(add(c, 8)))\n                result := add(result, 2)\n            }\n            if addDoubleQuotes {\n                mstore8(result, 34)\n                result := add(1, result)\n            }\n            let last := result\n            mstore(last, 0) // Zeroize the slot after the string.\n            result := mload(0x40)\n            mstore(result, sub(last, add(result, 0x20))) // Store the length.\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\n        }\n    }\n\n    /// @dev Escapes the string to be used within double-quotes in a JSON.\n    function escapeJSON(string memory s) internal pure returns (string memory result) {\n        result = escapeJSON(s, false);\n    }\n\n    /// @dev Returns whether `a` equals `b`.\n    function eq(string memory a, string memory b) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := eq(keccak256(add(a, 0x20), mload(a)), keccak256(add(b, 0x20), mload(b)))\n        }\n    }\n\n    /// @dev Returns whether `a` equals `b`, where `b` is a null-terminated small string.\n    function eqs(string memory a, bytes32 b) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // These should be evaluated on compile time, as far as possible.\n            let m := not(shl(7, div(not(iszero(b)), 255))) // `0x7f7f ...`.\n            let x := not(or(m, or(b, add(m, and(b, m)))))\n            let r := shl(7, iszero(iszero(shr(128, x))))\n            r := or(r, shl(6, iszero(iszero(shr(64, shr(r, x))))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // forgefmt: disable-next-item\n            result := gt(eq(mload(a), add(iszero(x), xor(31, shr(3, r)))),\n                xor(shr(add(8, r), b), shr(add(8, r), mload(add(a, 0x20)))))\n        }\n    }\n\n    /// @dev Packs a single string with its length into a single word.\n    /// Returns `bytes32(0)` if the length is zero or greater than 31.\n    function packOne(string memory a) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We don't need to zero right pad the string,\n            // since this is our own custom non-standard packing scheme.\n            result :=\n                mul(\n                    // Load the length and the bytes.\n                    mload(add(a, 0x1f)),\n                    // `length != 0 && length < 32`. Abuses underflow.\n                    // Assumes that the length is valid and within the block gas limit.\n                    lt(sub(mload(a), 1), 0x1f)\n                )\n        }\n    }\n\n    /// @dev Unpacks a string packed using {packOne}.\n    /// Returns the empty string if `packed` is `bytes32(0)`.\n    /// If `packed` is not an output of {packOne}, the output behavior is undefined.\n    function unpackOne(bytes32 packed) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Grab the free memory pointer.\n            result := mload(0x40)\n            // Allocate 2 words (1 for the length, 1 for the bytes).\n            mstore(0x40, add(result, 0x40))\n            // Zeroize the length slot.\n            mstore(result, 0)\n            // Store the length and bytes.\n            mstore(add(result, 0x1f), packed)\n            // Right pad with zeroes.\n            mstore(add(add(result, 0x20), mload(result)), 0)\n        }\n    }\n\n    /// @dev Packs two strings with their lengths into a single word.\n    /// Returns `bytes32(0)` if combined length is zero or greater than 30.\n    function packTwo(string memory a, string memory b) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let aLength := mload(a)\n            // We don't need to zero right pad the strings,\n            // since this is our own custom non-standard packing scheme.\n            result :=\n                mul(\n                    // Load the length and the bytes of `a` and `b`.\n                    or(\n                        shl(shl(3, sub(0x1f, aLength)), mload(add(a, aLength))),\n                        mload(sub(add(b, 0x1e), aLength))\n                    ),\n                    // `totalLength != 0 && totalLength < 31`. Abuses underflow.\n                    // Assumes that the lengths are valid and within the block gas limit.\n                    lt(sub(add(aLength, mload(b)), 1), 0x1e)\n                )\n        }\n    }\n\n    /// @dev Unpacks strings packed using {packTwo}.\n    /// Returns the empty strings if `packed` is `bytes32(0)`.\n    /// If `packed` is not an output of {packTwo}, the output behavior is undefined.\n    function unpackTwo(bytes32 packed)\n        internal\n        pure\n        returns (string memory resultA, string memory resultB)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Grab the free memory pointer.\n            resultA := mload(0x40)\n            resultB := add(resultA, 0x40)\n            // Allocate 2 words for each string (1 for the length, 1 for the byte). Total 4 words.\n            mstore(0x40, add(resultB, 0x40))\n            // Zeroize the length slots.\n            mstore(resultA, 0)\n            mstore(resultB, 0)\n            // Store the lengths and bytes.\n            mstore(add(resultA, 0x1f), packed)\n            mstore(add(resultB, 0x1f), mload(add(add(resultA, 0x20), mload(resultA))))\n            // Right pad with zeroes.\n            mstore(add(add(resultA, 0x20), mload(resultA)), 0)\n            mstore(add(add(resultB, 0x20), mload(resultB)), 0)\n        }\n    }\n\n    /// @dev Directly returns `a` without copying.\n    function directReturn(string memory a) internal pure {\n        assembly {\n            // Assumes that the string does not start from the scratch space.\n            let retStart := sub(a, 0x20)\n            let retSize := add(mload(a), 0x40)\n            // Right pad with zeroes. Just in case the string is produced\n            // by a method that doesn't zero right pad.\n            mstore(add(retStart, retSize), 0)\n            // Store the return offset.\n            mstore(retStart, 0x20)\n            // End the transaction, returning the string.\n            return(retStart, retSize)\n        }\n    }\n}\n"
    },
    "src/bridge/EspressoTEEVerifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {\n    V3QuoteVerifier\n} from \"@automata-network/dcap-attestation/contracts/verifiers/V3QuoteVerifier.sol\";\nimport {BELE} from \"@automata-network/dcap-attestation/contracts/utils/BELE.sol\";\nimport {Header} from \"@automata-network/dcap-attestation/contracts/types/CommonStruct.sol\";\nimport {\n    IQuoteVerifier\n} from \"@automata-network/dcap-attestation/contracts/interfaces/IQuoteVerifier.sol\";\nimport {\n    HEADER_LENGTH,\n    ENCLAVE_REPORT_LENGTH\n} from \"@automata-network/dcap-attestation/contracts/types/Constants.sol\";\nimport {EnclaveReport} from \"@automata-network/dcap-attestation/contracts/types/V3Structs.sol\";\nimport {BytesUtils} from \"@automata-network/dcap-attestation/contracts/utils/BytesUtils.sol\";\nimport \"@openzeppelin/contracts/access/Ownable2Step.sol\";\nimport {IEspressoTEEVerifier} from \"./IEspressoTEEVerifier.sol\";\n\n/**\n *\n * @title  Verifies quotes from the TEE and attests on-chain\n * @notice Contains the logic to verify a quote from the TEE and attest on-chain. It uses the V3QuoteVerifier contract\n *         from automata to verify the quote. Along with some additional verification logic.\n */\ncontract EspressoTEEVerifier is IEspressoTEEVerifier, Ownable2Step {\n    event MREnclaveSet(bytes32 indexed mrEnclave);\n    event MRSignerSet(bytes32 indexed mrSigner);\n\n    using BytesUtils for bytes;\n\n    // V3QuoteVerififer contract from automata to verify the quote\n    V3QuoteVerifier public quoteVerifier;\n    bytes32 public mrEnclave;\n    bytes32 public mrSigner;\n\n    constructor(bytes32 _mrEnclave, bytes32 _mrSigner, address _quoteVerifier) {\n        quoteVerifier = V3QuoteVerifier(_quoteVerifier);\n        mrEnclave = _mrEnclave;\n        mrSigner = _mrSigner;\n    }\n\n    /*\n        @notice Verify a quote from the TEE and attest on-chain\n        The verification is considered successful if the function does not revert.\n        @param rawQuote The quote from the TEE\n        @param reportDataHash The hash of the report data\n    */\n    function verify(bytes calldata rawQuote, bytes32 reportDataHash) external view {\n        // Parse the header\n        Header memory header = parseQuoteHeader(rawQuote);\n\n        // Currently only version 3 is supported\n        if (header.version != 3) {\n            revert InvalidHeaderVersion();\n        }\n\n        // Verify the quote\n        (bool success, ) = quoteVerifier.verifyQuote(header, rawQuote);\n        if (!success) {\n            revert InvalidQuote();\n        }\n\n        // Parse enclave quote\n        uint256 lastIndex = HEADER_LENGTH + ENCLAVE_REPORT_LENGTH;\n        EnclaveReport memory localReport;\n        (success, localReport) = parseEnclaveReport(rawQuote[HEADER_LENGTH:lastIndex]);\n        if (!success) {\n            revert FailedToParseEnclaveReport();\n        }\n\n        // Check that mrEnclave and mrSigner match\n        if (localReport.mrEnclave != mrEnclave || localReport.mrSigner != mrSigner) {\n            revert InvalidMREnclaveOrSigner();\n        }\n\n        //  Verify that the reportDataHash if the hash signed by the TEE\n        // We do not check the signature because `quoteVerifier.verifyQuote` already does that\n        if (reportDataHash != bytes32(localReport.reportData.substring(0, 32))) {\n            revert InvalidReportDataHash();\n        }\n    }\n\n    /*\n        @notice Parses the header from the quote\n        @param rawQuote The raw quote in bytes\n        @return header The parsed header\n    */\n    function parseQuoteHeader(bytes calldata rawQuote) public pure returns (Header memory header) {\n        header = Header({\n            version: uint16(BELE.leBytesToBeUint(rawQuote[0:2])),\n            attestationKeyType: bytes2(rawQuote[2:4]),\n            teeType: bytes4(uint32(BELE.leBytesToBeUint(rawQuote[4:8]))),\n            qeSvn: bytes2(rawQuote[8:10]),\n            pceSvn: bytes2(rawQuote[10:12]),\n            qeVendorId: bytes16(rawQuote[12:28]),\n            userData: bytes20(rawQuote[28:48])\n        });\n    }\n\n    /*\n        @notice Parses the enclave report from the quote\n        @param rawEnclaveReport The raw enclave report from the quote in bytes\n        @return success True if the enclave report was parsed successfully\n        @return enclaveReport The parsed enclave report\n    */\n    function parseEnclaveReport(\n        bytes memory rawEnclaveReport\n    ) public pure returns (bool success, EnclaveReport memory enclaveReport) {\n        if (rawEnclaveReport.length != ENCLAVE_REPORT_LENGTH) {\n            return (false, enclaveReport);\n        }\n        enclaveReport.cpuSvn = bytes16(rawEnclaveReport.substring(0, 16));\n        enclaveReport.miscSelect = bytes4(rawEnclaveReport.substring(16, 4));\n        enclaveReport.reserved1 = bytes28(rawEnclaveReport.substring(20, 28));\n        enclaveReport.attributes = bytes16(rawEnclaveReport.substring(48, 16));\n        enclaveReport.mrEnclave = bytes32(rawEnclaveReport.substring(64, 32));\n        enclaveReport.reserved2 = bytes32(rawEnclaveReport.substring(96, 32));\n        enclaveReport.mrSigner = bytes32(rawEnclaveReport.substring(128, 32));\n        enclaveReport.reserved3 = rawEnclaveReport.substring(160, 96);\n        enclaveReport.isvProdId = uint16(BELE.leBytesToBeUint(rawEnclaveReport.substring(256, 2)));\n        enclaveReport.isvSvn = uint16(BELE.leBytesToBeUint(rawEnclaveReport.substring(258, 2)));\n        enclaveReport.reserved4 = rawEnclaveReport.substring(260, 60);\n        enclaveReport.reportData = rawEnclaveReport.substring(320, 64);\n        success = true;\n    }\n\n    /*\n     * @dev Set the mrEnclave of the contract\n     */\n    function setMrEnclave(bytes32 _mrEnclave) external onlyOwner {\n        emit MREnclaveSet(_mrEnclave);\n        mrEnclave = _mrEnclave;\n    }\n\n    /*\n     * @dev Set the mrSigner of the contract\n     */\n    function setMrSigner(bytes32 _mrSigner) external onlyOwner {\n        emit MRSignerSet(_mrSigner);\n        mrSigner = _mrSigner;\n    }\n}\n"
    },
    "src/bridge/IEspressoTEEVerifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Header} from \"@automata-network/dcap-attestation/contracts/types/CommonStruct.sol\";\nimport {EnclaveReport} from \"@automata-network/dcap-attestation/contracts/types/V3Structs.sol\";\n\ninterface IEspressoTEEVerifier {\n    // We only support version 3 for now\n    error InvalidHeaderVersion();\n    // This error is thrown when the automata verification fails\n    error InvalidQuote();\n    // This error is thrown when the enclave report fails to parse\n    error FailedToParseEnclaveReport();\n    // This error is thrown when the mrEnclave and mrSigner don't match\n    error InvalidMREnclaveOrSigner();\n    // This error is thrown when the reportDataHash doesn't match the hash signed by the TEE\n    error InvalidReportDataHash();\n\n    function verify(bytes calldata rawQuote, bytes32 reportDataHash) external view;\n\n    function parseQuoteHeader(bytes calldata rawQuote) external pure returns (Header memory header);\n\n    function parseEnclaveReport(\n        bytes memory rawEnclaveReport\n    ) external pure returns (bool success, EnclaveReport memory enclaveReport);\n\n    function setMrEnclave(bytes32 _mrEnclave) external;\n\n    function setMrSigner(bytes32 _mrSigner) external;\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 2000
    },
    "viaIR": true,
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    },
    "libraries": {}
  }
}}