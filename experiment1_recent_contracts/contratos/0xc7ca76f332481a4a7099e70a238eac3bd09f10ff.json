{{
  "language": "Solidity",
  "sources": {
    "src/credentials/ResolverVerifier.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.28;\n\nimport {IRiscZeroVerifier} from \"risc0/IRiscZeroVerifier.sol\";\nimport {Steel} from \"risc0/steel/Steel.sol\";\nimport {IAccessVerifier, CredentialProofData} from \"src/interfaces/IAccessVerifier.sol\";\nimport {SchemaResolver} from \"eas-contracts/resolver/SchemaResolver.sol\";\nimport {IEAS, Attestation} from \"eas-contracts/IEAS.sol\";\nimport {IInvestorRegistry} from \"src/interfaces/IInvestorRegistry.sol\";\nimport \"src/utils/Constant.sol\";\n\n/**\n * @title ResolverVerifier\n * @notice This contract handles the verification of credentials and subscriptions using zkVM proofs.\n *         It integrates with RISC Zero Verifier and manages attestation schemas for investor compliance.\n * @dev The contract utilizes SchemaResolver for EAS-based attestation validation and implements IAccessVerifier.\n * @author Libre\n */\ncontract ResolverVerifier is SchemaResolver, IAccessVerifier {\n    /// @notice Image IDs of the zkVM binaries to accept verification from.\n    bytes32 public credentialImageID;\n    bytes32 public subscriptionImageID;\n\n    /// @notice RISC Zero verifier contract address.\n    IRiscZeroVerifier public immutable verifier;\n\n    /// @notice Investor registry to manage investor-related data and credentials.\n    IInvestorRegistry public immutable investorRegistry;\n\n    /// @notice Address of the policy viewer used to generate the proofs\n    address public immutable policyViewer;\n\n    /// @dev Error thrown when a non-investor registry address tries to update image IDs.\n    error ResolverVerifier_NotInvestorRegistry();\n\n    /// @dev Error thrown when a journal commitment fails validation.\n    error ResolverVerifier_InvalidCommitment();\n\n    constructor(\n        IEAS eas,\n        IInvestorRegistry _investorRegistry,\n        IRiscZeroVerifier _verifier,\n        bytes32 _credentialImageID,\n        bytes32 _subscriptionImageID,\n        address _policyViewer\n    ) SchemaResolver(eas) {\n        investorRegistry = _investorRegistry;\n        verifier = _verifier;\n        credentialImageID = _credentialImageID;\n        subscriptionImageID = _subscriptionImageID;\n        policyViewer = _policyViewer;\n    }\n\n    function updateImageIDs(bytes32 _credentialImageID, bytes32 _subscriptionImageID) external {\n        if (msg.sender != address(investorRegistry)) {\n            revert ResolverVerifier_NotInvestorRegistry();\n        }\n        credentialImageID = _credentialImageID;\n        subscriptionImageID = _subscriptionImageID;\n    }\n\n    function verifyCredential(CredentialProofData memory _proof) public view {\n        if (!Steel.validateCommitment(_proof.journal.commitment)) {\n            revert ResolverVerifier_InvalidCommitment();\n        }\n        bytes32 journalHash = sha256(abi.encode(_proof.journal));\n        verifier.verify(_proof.seal, credentialImageID, journalHash);\n    }\n\n    function verifySubscription(OrderProofData calldata _proof) public view {\n        if (!Steel.validateCommitment(_proof.journal.commitment)) {\n            revert ResolverVerifier_InvalidCommitment();\n        }\n        bytes32 journalHash = sha256(abi.encode(_proof.journal));\n        verifier.verify(_proof.seal, subscriptionImageID, journalHash);\n    }\n\n    /**\n     * @notice Handles logic for attestation verification.\n     * @param _attestation The attestation data.\n     * @return Whether the attestation passes verification.\n     * @dev Includes credential validation and instrument-specific compliance checks.\n     */\n    function onAttest(Attestation calldata _attestation, uint256 /*value*/ ) internal view override returns (bool) {\n        if (_attestation.attester != address(investorRegistry)) {\n            return false;\n        }\n        SteelProofData memory steelProofData = investorRegistry.getTempSteelProofData();\n        //Decode attestation schema\n        (bytes32 investorId, bytes32[] memory instrumentIds, uint64[] memory instrumentExpiryTimestamps) =\n            abi.decode(_attestation.data, (bytes32, bytes32[], uint64[]));\n\n        if (instrumentIds.length != instrumentExpiryTimestamps.length) {\n            return false;\n        }\n\n        bytes32 currentCredentialId = investorRegistry.getBytes(investorId, CREDENTIAL_ID);\n        if (currentCredentialId != bytes32(0)) {\n            Attestation memory oldAttestation = _eas.getAttestation(currentCredentialId);\n            if (oldAttestation.revocationTime == block.timestamp) {\n                return true;\n            }\n        }\n\n        CredentialProofData memory proof;\n        proof.journal.commitment = steelProofData.commitment;\n        proof.journal.expiryTimestamp = _attestation.expirationTime;\n        proof.journal.investorId = investorId;\n        proof.journal.policyViewer = policyViewer;\n        proof.seal = steelProofData.seal;\n\n        {\n            //Decode old attestation schema\n            bytes32 oldAttestationId = investorRegistry.getBytes(investorId, CREDENTIAL_ID);\n            if (oldAttestationId == bytes32(0)) {\n                proof.journal.instrumentIds = instrumentIds;\n                proof.journal.instrumentExpiryTimestamps = instrumentExpiryTimestamps;\n            } else {\n                Attestation memory oldAttestation = _eas.getAttestation(oldAttestationId);\n                (, bytes32[] memory oldInstrumentIds, uint64[] memory oldInstrumentExpiryTimestamps) =\n                    abi.decode(oldAttestation.data, (bytes32, bytes32[], uint64[]));\n\n                //only keeping instruments that are new or updated for proof checking\n                bytes32[] memory newInstrumentIds = new bytes32[](instrumentIds.length);\n                uint64[] memory newInstrumentExpiryTimestamps = new uint64[](instrumentExpiryTimestamps.length);\n                uint256 newOrUpdatedCount;\n                for (uint256 i; i < instrumentIds.length; ++i) {\n                    bool newOrUpdated = true;\n                    for (uint256 j; j < oldInstrumentIds.length; ++j) {\n                        if (instrumentIds[i] == oldInstrumentIds[j]) {\n                            if (instrumentExpiryTimestamps[i] == oldInstrumentExpiryTimestamps[j]) {\n                                newOrUpdated = false;\n                            }\n                            break;\n                        }\n                    }\n                    if (newOrUpdated) {\n                        newInstrumentIds[newOrUpdatedCount] = (instrumentIds[i]);\n                        newInstrumentExpiryTimestamps[newOrUpdatedCount] = (instrumentExpiryTimestamps[i]);\n                        ++newOrUpdatedCount;\n                    }\n                }\n\n                //Resize Arrays to have length of newOrUpdatedCount\n                assembly {\n                    mstore(newInstrumentIds, newOrUpdatedCount)\n                    mstore(newInstrumentExpiryTimestamps, newOrUpdatedCount)\n                }\n\n                proof.journal.instrumentIds = newInstrumentIds;\n                proof.journal.instrumentExpiryTimestamps = newInstrumentExpiryTimestamps;\n            }\n        }\n\n        //reverts if proof is invalid\n        verifyCredential(proof);\n\n        return true;\n    }\n\n    /**\n     * @notice Handles logic for attestation revocation.\n     * @return Always returns true as all revocation requests are allowed.\n     */\n    function onRevoke(Attestation calldata, /*attestation*/ uint256 /*value*/ ) internal pure override returns (bool) {\n        return true;\n    }\n}\n"
    },
    "lib/risc0-ethereum/contracts/src/IRiscZeroVerifier.sol": {
      "content": "// Copyright 2024 RISC Zero, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n\npragma solidity ^0.8.9;\n\nimport {reverseByteOrderUint32} from \"./Util.sol\";\n\n/// @notice A receipt attesting to the execution of a guest program.\n/// @dev A receipt contains two parts: a seal and a claim. The seal is a zero-knowledge proof\n/// attesting to knowledge of a zkVM execution resulting in the claim. The claim is a set of public\n/// outputs for the execution. Crucially, the claim includes the journal and the image ID. The\n/// image ID identifies the program that was executed, and the journal is the public data written\n/// by the program. Note that this struct only contains the claim digest, as can be obtained with\n/// the `digest()` function on `ReceiptClaimLib`.\nstruct Receipt {\n    bytes seal;\n    bytes32 claimDigest;\n}\n\n/// @notice Public claims about a zkVM guest execution, such as the journal committed to by the guest.\n/// @dev Also includes important information such as the exit code and the starting and ending system\n/// state (i.e. the state of memory). `ReceiptClaim` is a \"Merkle-ized struct\" supporting\n/// partial openings of the underlying fields from a hash commitment to the full structure.\nstruct ReceiptClaim {\n    /// @notice Digest of the SystemState just before execution has begun.\n    bytes32 preStateDigest;\n    /// @notice Digest of the SystemState just after execution has completed.\n    bytes32 postStateDigest;\n    /// @notice The exit code for the execution.\n    ExitCode exitCode;\n    /// @notice A digest of the input to the guest.\n    /// @dev This field is currently unused and must be set to the zero digest.\n    bytes32 input;\n    /// @notice Digest of the Output of the guest, including the journal\n    /// and assumptions set during execution.\n    bytes32 output;\n}\n\nlibrary ReceiptClaimLib {\n    using OutputLib for Output;\n    using SystemStateLib for SystemState;\n\n    bytes32 constant TAG_DIGEST = sha256(\"risc0.ReceiptClaim\");\n\n    // Define a constant to ensure hashing is done at compile time. Can't use the\n    // SystemStateLib.digest method here because the Solidity compiler complains.\n    bytes32 constant SYSTEM_STATE_ZERO_DIGEST = 0xa3acc27117418996340b84e5a90f3ef4c49d22c79e44aad822ec9c313e1eb8e2;\n\n    /// @notice Construct a ReceiptClaim from the given imageId and journalDigest.\n    ///         Returned ReceiptClaim will represent a successful execution of the zkVM, running\n    ///         the program committed by imageId and resulting in the journal specified by\n    ///         journalDigest.\n    /// @param imageId The identifier for the guest program.\n    /// @param journalDigest The SHA-256 digest of the journal bytes.\n    /// @dev Input hash and postStateDigest are set to all-zeros (i.e. no committed input, or\n    ///      final memory state), the exit code is (Halted, 0), and there are no assumptions\n    ///      (i.e. the receipt is unconditional).\n    function ok(bytes32 imageId, bytes32 journalDigest) internal pure returns (ReceiptClaim memory) {\n        return ReceiptClaim(\n            imageId,\n            SYSTEM_STATE_ZERO_DIGEST,\n            ExitCode(SystemExitCode.Halted, 0),\n            bytes32(0),\n            Output(journalDigest, bytes32(0)).digest()\n        );\n    }\n\n    function digest(ReceiptClaim memory claim) internal pure returns (bytes32) {\n        return sha256(\n            abi.encodePacked(\n                TAG_DIGEST,\n                // down\n                claim.input,\n                claim.preStateDigest,\n                claim.postStateDigest,\n                claim.output,\n                // data\n                uint32(claim.exitCode.system) << 24,\n                uint32(claim.exitCode.user) << 24,\n                // down.length\n                uint16(4) << 8\n            )\n        );\n    }\n}\n\n/// @notice Commitment to the memory state and program counter (pc) of the zkVM.\n/// @dev The \"pre\" and \"post\" fields of the ReceiptClaim are digests of the system state at the\n///      start are stop of execution. Programs are loaded into the zkVM by creating a memory image\n///      of the loaded program, and creating a system state for initializing the zkVM. This is\n///      known as the \"image ID\".\nstruct SystemState {\n    /// @notice Program counter.\n    uint32 pc;\n    /// @notice Root hash of a merkle tree which confirms the integrity of the memory image.\n    bytes32 merkle_root;\n}\n\nlibrary SystemStateLib {\n    bytes32 constant TAG_DIGEST = sha256(\"risc0.SystemState\");\n\n    function digest(SystemState memory state) internal pure returns (bytes32) {\n        return sha256(\n            abi.encodePacked(\n                TAG_DIGEST,\n                // down\n                state.merkle_root,\n                // data\n                reverseByteOrderUint32(state.pc),\n                // down.length\n                uint16(1) << 8\n            )\n        );\n    }\n}\n\n/// @notice Exit condition indicated by the zkVM at the end of the guest execution.\n/// @dev Exit codes have a \"system\" part and a \"user\" part. Semantically, the system part is set to\n/// indicate the type of exit (e.g. halt, pause, or system split) and is directly controlled by the\n/// zkVM. The user part is an exit code, similar to exit codes used in Linux, chosen by the guest\n/// program to indicate additional information (e.g. 0 to indicate success or 1 to indicate an\n/// error).\nstruct ExitCode {\n    SystemExitCode system;\n    uint8 user;\n}\n\n/// @notice Exit condition indicated by the zkVM at the end of the execution covered by this proof.\n/// @dev\n/// `Halted` indicates normal termination of a program with an interior exit code returned from the\n/// guest program. A halted program cannot be resumed.\n///\n/// `Paused` indicates the execution ended in a paused state with an interior exit code set by the\n/// guest program. A paused program can be resumed such that execution picks up where it left\n/// of, with the same memory state.\n///\n/// `SystemSplit` indicates the execution ended on a host-initiated system split. System split is\n/// mechanism by which the host can temporarily stop execution of the execution ended in a system\n/// split has no output and no conclusions can be drawn about whether the program will eventually\n/// halt. System split is used in continuations to split execution into individually provable segments.\nenum SystemExitCode {\n    Halted,\n    Paused,\n    SystemSplit\n}\n\n/// @notice Output field in the `ReceiptClaim`, committing to a claimed journal and assumptions list.\nstruct Output {\n    /// @notice Digest of the journal committed to by the guest execution.\n    bytes32 journalDigest;\n    /// @notice Digest of the ordered list of `ReceiptClaim` digests corresponding to the\n    /// calls to `env::verify` and `env::verify_integrity`.\n    /// @dev Verifying the integrity of a `Receipt` corresponding to a `ReceiptClaim` with a\n    /// non-empty assumptions list does not guarantee unconditionally any of the claims over the\n    /// guest execution (i.e. if the assumptions list is non-empty, then the journal digest cannot\n    /// be trusted to correspond to a genuine execution). The claims can be checked by additional\n    /// verifying a `Receipt` for every digest in the assumptions list.\n    bytes32 assumptionsDigest;\n}\n\nlibrary OutputLib {\n    bytes32 constant TAG_DIGEST = sha256(\"risc0.Output\");\n\n    function digest(Output memory output) internal pure returns (bytes32) {\n        return sha256(\n            abi.encodePacked(\n                TAG_DIGEST,\n                // down\n                output.journalDigest,\n                output.assumptionsDigest,\n                // down.length\n                uint16(2) << 8\n            )\n        );\n    }\n}\n\n/// @notice Error raised when cryptographic verification of the zero-knowledge proof fails.\nerror VerificationFailed();\n\n/// @notice Verifier interface for RISC Zero receipts of execution.\ninterface IRiscZeroVerifier {\n    /// @notice Verify that the given seal is a valid RISC Zero proof of execution with the\n    ///     given image ID and journal digest. Reverts on failure.\n    /// @dev This method additionally ensures that the input hash is all-zeros (i.e. no\n    /// committed input), the exit code is (Halted, 0), and there are no assumptions (i.e. the\n    /// receipt is unconditional).\n    /// @param seal The encoded cryptographic proof (i.e. SNARK).\n    /// @param imageId The identifier for the guest program.\n    /// @param journalDigest The SHA-256 digest of the journal bytes.\n    function verify(bytes calldata seal, bytes32 imageId, bytes32 journalDigest) external view;\n\n    /// @notice Verify that the given receipt is a valid RISC Zero receipt, ensuring the `seal` is\n    /// valid a cryptographic proof of the execution with the given `claim`. Reverts on failure.\n    /// @param receipt The receipt to be verified.\n    function verifyIntegrity(Receipt calldata receipt) external view;\n}\n"
    },
    "lib/risc0-ethereum/contracts/src/steel/Steel.sol": {
      "content": "// Copyright 2024 RISC Zero, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n\npragma solidity ^0.8.9;\n\n/// @title Steel Library\n/// @notice This library provides a collection of utilities to work with Steel commitments in Solidity.\nlibrary Steel {\n    /// @notice Represents a commitment to a specific block in the blockchain.\n    /// @dev The `id` combines the version and the actual identifier of the claim, such as the block number.\n    /// @dev The `digest` represents the data being committed to, e.g. the hash of the execution block.\n    /// @dev The `configID` is the cryptographic digest of the network configuration.\n    struct Commitment {\n        uint256 id;\n        bytes32 digest;\n        bytes32 configID;\n    }\n\n    /// @notice The version of the Commitment is incorrect.\n    error InvalidCommitmentVersion();\n\n    /// @notice The Commitment is too old and can no longer be validated.\n    error CommitmentTooOld();\n\n    /// @notice Validates if the provided Commitment matches the block hash of the given block number.\n    /// @param commitment The Commitment struct to validate.\n    /// @return True if the commitment's block hash matches the block hash of the block number, false otherwise.\n    function validateCommitment(Commitment memory commitment) internal view returns (bool) {\n        (uint240 claimID, uint16 version) = Encoding.decodeVersionedID(commitment.id);\n        if (version == 0) {\n            return validateBlockCommitment(claimID, commitment.digest);\n        } else if (version == 1) {\n            return validateBeaconCommitment(claimID, commitment.digest);\n        } else {\n            revert InvalidCommitmentVersion();\n        }\n    }\n\n    /// @notice Validates if the provided block commitment matches the block hash of the given block number.\n    /// @param blockNumber The block number to compare against.\n    /// @param blockHash The block hash to validate.\n    /// @return True if the block's block hash matches the block hash, false otherwise.\n    function validateBlockCommitment(uint256 blockNumber, bytes32 blockHash) internal view returns (bool) {\n        if (block.number - blockNumber > 256) {\n            revert CommitmentTooOld();\n        }\n        return blockHash == blockhash(blockNumber);\n    }\n\n    /// @notice Validates if the provided beacon commitment matches the block root of the given timestamp.\n    /// @param timestamp The timestamp to compare against.\n    /// @param blockRoot The block root to validate.\n    /// @return True if the block's block root matches the block root, false otherwise.\n    function validateBeaconCommitment(uint256 timestamp, bytes32 blockRoot) internal view returns (bool) {\n        if (block.timestamp - timestamp > 12 * 8191) {\n            revert CommitmentTooOld();\n        }\n        return blockRoot == Beacon.parentBlockRoot(timestamp);\n    }\n}\n\n/// @title Beacon Library\nlibrary Beacon {\n    /// @notice The address of the Beacon roots contract.\n    /// @dev https://eips.ethereum.org/EIPS/eip-4788\n    address internal constant BEACON_ROOTS_ADDRESS = 0x000F3df6D732807Ef1319fB7B8bB8522d0Beac02;\n\n    /// @notice Find the root of the Beacon block corresponding to the parent of the execution block with the given timestamp.\n    /// @return root Returns the corresponding Beacon block root or null, if no such block exists.\n    function parentBlockRoot(uint256 timestamp) internal view returns (bytes32 root) {\n        (bool success, bytes memory result) = BEACON_ROOTS_ADDRESS.staticcall(abi.encode(timestamp));\n        if (success) {\n            return abi.decode(result, (bytes32));\n        }\n    }\n}\n\n/// @title Encoding Library\nlibrary Encoding {\n    /// @notice Encodes a version and ID into a single uint256 value.\n    /// @param id The base ID to be encoded, limited by 240 bits (or the maximum value of a uint240).\n    /// @param version The version number to be encoded, limited by 16 bits (or the maximum value of a uint16).\n    /// @return Returns a single uint256 value that contains both the `id` and the `version` encoded into it.\n    function encodeVersionedID(uint240 id, uint16 version) internal pure returns (uint256) {\n        uint256 encoded;\n        assembly {\n            encoded := or(shl(240, version), id)\n        }\n        return encoded;\n    }\n\n    /// @notice Decodes a version and ID from a single uint256 value.\n    /// @param id The single uint256 value to be decoded.\n    /// @return Returns two values: a uint240 for the original base ID and a uint16 for the version number encoded into it.\n    function decodeVersionedID(uint256 id) internal pure returns (uint240, uint16) {\n        uint240 decoded;\n        uint16 version;\n        assembly {\n            decoded := and(id, 0x0000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n            version := shr(240, id)\n        }\n        return (decoded, version);\n    }\n}\n"
    },
    "src/interfaces/IAccessVerifier.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {CredentialProofData, OrderProofData} from \"src/utils/Types.sol\";\n\n/**\n * @title IAccessVerifier\n * @notice Interface for verifying access credentials and subscription orders using off-chain generated proofs.\n * This interface utilizes cryptographic proofs (e.g., Steel proofs) to ensure secure verification of investor credentials\n * and subscription orders in compliance with the defined rules and regulations.\n *\n * @dev The Steel proofs must be generated off-chain using RISC0-zkVM and then submitted on-chain for verification.\n * These proofs ensure privacy and correctness while validating investor actions and subscriptions.\n */\ninterface IAccessVerifier {\n    /// @notice Verifies the Credential for an investor, if the Steel proof verifies that they are allowed to interact with an instrument\n    /// @dev The Steel proof must be generated off-chain using RISC0-zkVM and submitted here.\n    function verifyCredential(CredentialProofData calldata _proof) external;\n\n    /// @notice Verifies a subscription order for an investor, if the Steel proof verifies that their subscription to an instrument is valid\n    /// @dev The Steel proof must be generated off-chain using RISC0-zkVM and submitted here.\n    function verifySubscription(OrderProofData calldata _proof) external view;\n\n    /// @notice Returns the image ID used for credential verification.\n    function credentialImageID() external view returns (bytes32);\n\n    /// @notice Returns the image ID used for subscription verification.\n    function subscriptionImageID() external view returns (bytes32);\n}\n"
    },
    "lib/eas-contracts/contracts/resolver/SchemaResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\n\nimport { AccessDenied, InvalidEAS, InvalidLength, uncheckedInc } from \"./../Common.sol\";\nimport { IEAS, Attestation } from \"./../IEAS.sol\";\nimport { Semver } from \"./../Semver.sol\";\nimport { ISchemaResolver } from \"./ISchemaResolver.sol\";\n\n/// @title SchemaResolver\n/// @notice The base schema resolver contract.\nabstract contract SchemaResolver is ISchemaResolver, Semver {\n    error InsufficientValue();\n    error NotPayable();\n\n    // The global EAS contract.\n    IEAS internal immutable _eas;\n\n    /// @dev Creates a new resolver.\n    /// @param eas The address of the global EAS contract.\n    constructor(IEAS eas) Semver(1, 3, 0) {\n        if (address(eas) == address(0)) {\n            revert InvalidEAS();\n        }\n\n        _eas = eas;\n    }\n\n    /// @dev Ensures that only the EAS contract can make this call.\n    modifier onlyEAS() {\n        _onlyEAS();\n\n        _;\n    }\n\n    /// @inheritdoc ISchemaResolver\n    function isPayable() public pure virtual returns (bool) {\n        return false;\n    }\n\n    /// @dev ETH callback.\n    receive() external payable virtual {\n        if (!isPayable()) {\n            revert NotPayable();\n        }\n    }\n\n    /// @inheritdoc ISchemaResolver\n    function attest(Attestation calldata attestation) external payable onlyEAS returns (bool) {\n        return onAttest(attestation, msg.value);\n    }\n\n    /// @inheritdoc ISchemaResolver\n    function multiAttest(\n        Attestation[] calldata attestations,\n        uint256[] calldata values\n    ) external payable onlyEAS returns (bool) {\n        uint256 length = attestations.length;\n        if (length != values.length) {\n            revert InvalidLength();\n        }\n\n        // We are keeping track of the remaining ETH amount that can be sent to resolvers and will keep deducting\n        // from it to verify that there isn't any attempt to send too much ETH to resolvers. Please note that unless\n        // some ETH was stuck in the contract by accident (which shouldn't happen in normal conditions), it won't be\n        // possible to send too much ETH anyway.\n        uint256 remainingValue = msg.value;\n\n        for (uint256 i = 0; i < length; i = uncheckedInc(i)) {\n            // Ensure that the attester/revoker doesn't try to spend more than available.\n            uint256 value = values[i];\n            if (value > remainingValue) {\n                revert InsufficientValue();\n            }\n\n            // Forward the attestation to the underlying resolver and return false in case it isn't approved.\n            if (!onAttest(attestations[i], value)) {\n                return false;\n            }\n\n            unchecked {\n                // Subtract the ETH amount, that was provided to this attestation, from the global remaining ETH amount.\n                remainingValue -= value;\n            }\n        }\n\n        return true;\n    }\n\n    /// @inheritdoc ISchemaResolver\n    function revoke(Attestation calldata attestation) external payable onlyEAS returns (bool) {\n        return onRevoke(attestation, msg.value);\n    }\n\n    /// @inheritdoc ISchemaResolver\n    function multiRevoke(\n        Attestation[] calldata attestations,\n        uint256[] calldata values\n    ) external payable onlyEAS returns (bool) {\n        uint256 length = attestations.length;\n        if (length != values.length) {\n            revert InvalidLength();\n        }\n\n        // We are keeping track of the remaining ETH amount that can be sent to resolvers and will keep deducting\n        // from it to verify that there isn't any attempt to send too much ETH to resolvers. Please note that unless\n        // some ETH was stuck in the contract by accident (which shouldn't happen in normal conditions), it won't be\n        // possible to send too much ETH anyway.\n        uint256 remainingValue = msg.value;\n\n        for (uint256 i = 0; i < length; i = uncheckedInc(i)) {\n            // Ensure that the attester/revoker doesn't try to spend more than available.\n            uint256 value = values[i];\n            if (value > remainingValue) {\n                revert InsufficientValue();\n            }\n\n            // Forward the revocation to the underlying resolver and return false in case it isn't approved.\n            if (!onRevoke(attestations[i], value)) {\n                return false;\n            }\n\n            unchecked {\n                // Subtract the ETH amount, that was provided to this attestation, from the global remaining ETH amount.\n                remainingValue -= value;\n            }\n        }\n\n        return true;\n    }\n\n    /// @notice A resolver callback that should be implemented by child contracts.\n    /// @param attestation The new attestation.\n    /// @param value An explicit ETH amount that was sent to the resolver. Please note that this value is verified in\n    ///     both attest() and multiAttest() callbacks EAS-only callbacks and that in case of multi attestations, it'll\n    ///     usually hold that msg.value != value, since msg.value aggregated the sent ETH amounts for all the\n    ///     attestations in the batch.\n    /// @return Whether the attestation is valid.\n    function onAttest(Attestation calldata attestation, uint256 value) internal virtual returns (bool);\n\n    /// @notice Processes an attestation revocation and verifies if it can be revoked.\n    /// @param attestation The existing attestation to be revoked.\n    /// @param value An explicit ETH amount that was sent to the resolver. Please note that this value is verified in\n    ///     both revoke() and multiRevoke() callbacks EAS-only callbacks and that in case of multi attestations, it'll\n    ///     usually hold that msg.value != value, since msg.value aggregated the sent ETH amounts for all the\n    ///     attestations in the batch.\n    /// @return Whether the attestation can be revoked.\n    function onRevoke(Attestation calldata attestation, uint256 value) internal virtual returns (bool);\n\n    /// @dev Ensures that only the EAS contract can make this call.\n    function _onlyEAS() private view {\n        if (msg.sender != address(_eas)) {\n            revert AccessDenied();\n        }\n    }\n}\n"
    },
    "lib/eas-contracts/contracts/IEAS.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { ISchemaRegistry } from \"./ISchemaRegistry.sol\";\nimport { ISemver } from \"./ISemver.sol\";\nimport { Attestation, Signature } from \"./Common.sol\";\n\n/// @notice A struct representing the arguments of the attestation request.\nstruct AttestationRequestData {\n    address recipient; // The recipient of the attestation.\n    uint64 expirationTime; // The time when the attestation expires (Unix timestamp).\n    bool revocable; // Whether the attestation is revocable.\n    bytes32 refUID; // The UID of the related attestation.\n    bytes data; // Custom attestation data.\n    uint256 value; // An explicit ETH amount to send to the resolver. This is important to prevent accidental user errors.\n}\n\n/// @notice A struct representing the full arguments of the attestation request.\nstruct AttestationRequest {\n    bytes32 schema; // The unique identifier of the schema.\n    AttestationRequestData data; // The arguments of the attestation request.\n}\n\n/// @notice A struct representing the full arguments of the full delegated attestation request.\nstruct DelegatedAttestationRequest {\n    bytes32 schema; // The unique identifier of the schema.\n    AttestationRequestData data; // The arguments of the attestation request.\n    Signature signature; // The ECDSA signature data.\n    address attester; // The attesting account.\n    uint64 deadline; // The deadline of the signature/request.\n}\n\n/// @notice A struct representing the full arguments of the multi attestation request.\nstruct MultiAttestationRequest {\n    bytes32 schema; // The unique identifier of the schema.\n    AttestationRequestData[] data; // The arguments of the attestation request.\n}\n\n/// @notice A struct representing the full arguments of the delegated multi attestation request.\nstruct MultiDelegatedAttestationRequest {\n    bytes32 schema; // The unique identifier of the schema.\n    AttestationRequestData[] data; // The arguments of the attestation requests.\n    Signature[] signatures; // The ECDSA signatures data. Please note that the signatures are assumed to be signed with increasing nonces.\n    address attester; // The attesting account.\n    uint64 deadline; // The deadline of the signature/request.\n}\n\n/// @notice A struct representing the arguments of the revocation request.\nstruct RevocationRequestData {\n    bytes32 uid; // The UID of the attestation to revoke.\n    uint256 value; // An explicit ETH amount to send to the resolver. This is important to prevent accidental user errors.\n}\n\n/// @notice A struct representing the full arguments of the revocation request.\nstruct RevocationRequest {\n    bytes32 schema; // The unique identifier of the schema.\n    RevocationRequestData data; // The arguments of the revocation request.\n}\n\n/// @notice A struct representing the arguments of the full delegated revocation request.\nstruct DelegatedRevocationRequest {\n    bytes32 schema; // The unique identifier of the schema.\n    RevocationRequestData data; // The arguments of the revocation request.\n    Signature signature; // The ECDSA signature data.\n    address revoker; // The revoking account.\n    uint64 deadline; // The deadline of the signature/request.\n}\n\n/// @notice A struct representing the full arguments of the multi revocation request.\nstruct MultiRevocationRequest {\n    bytes32 schema; // The unique identifier of the schema.\n    RevocationRequestData[] data; // The arguments of the revocation request.\n}\n\n/// @notice A struct representing the full arguments of the delegated multi revocation request.\nstruct MultiDelegatedRevocationRequest {\n    bytes32 schema; // The unique identifier of the schema.\n    RevocationRequestData[] data; // The arguments of the revocation requests.\n    Signature[] signatures; // The ECDSA signatures data. Please note that the signatures are assumed to be signed with increasing nonces.\n    address revoker; // The revoking account.\n    uint64 deadline; // The deadline of the signature/request.\n}\n\n/// @title IEAS\n/// @notice EAS - Ethereum Attestation Service interface.\ninterface IEAS is ISemver {\n    /// @notice Emitted when an attestation has been made.\n    /// @param recipient The recipient of the attestation.\n    /// @param attester The attesting account.\n    /// @param uid The UID of the new attestation.\n    /// @param schemaUID The UID of the schema.\n    event Attested(address indexed recipient, address indexed attester, bytes32 uid, bytes32 indexed schemaUID);\n\n    /// @notice Emitted when an attestation has been revoked.\n    /// @param recipient The recipient of the attestation.\n    /// @param attester The attesting account.\n    /// @param schemaUID The UID of the schema.\n    /// @param uid The UID the revoked attestation.\n    event Revoked(address indexed recipient, address indexed attester, bytes32 uid, bytes32 indexed schemaUID);\n\n    /// @notice Emitted when a data has been timestamped.\n    /// @param data The data.\n    /// @param timestamp The timestamp.\n    event Timestamped(bytes32 indexed data, uint64 indexed timestamp);\n\n    /// @notice Emitted when a data has been revoked.\n    /// @param revoker The address of the revoker.\n    /// @param data The data.\n    /// @param timestamp The timestamp.\n    event RevokedOffchain(address indexed revoker, bytes32 indexed data, uint64 indexed timestamp);\n\n    /// @notice Returns the address of the global schema registry.\n    /// @return The address of the global schema registry.\n    function getSchemaRegistry() external view returns (ISchemaRegistry);\n\n    /// @notice Attests to a specific schema.\n    /// @param request The arguments of the attestation request.\n    /// @return The UID of the new attestation.\n    ///\n    /// Example:\n    ///     attest({\n    ///         schema: \"0facc36681cbe2456019c1b0d1e7bedd6d1d40f6f324bf3dd3a4cef2999200a0\",\n    ///         data: {\n    ///             recipient: \"0xdEADBeAFdeAdbEafdeadbeafDeAdbEAFdeadbeaf\",\n    ///             expirationTime: 0,\n    ///             revocable: true,\n    ///             refUID: \"0x0000000000000000000000000000000000000000000000000000000000000000\",\n    ///             data: \"0xF00D\",\n    ///             value: 0\n    ///         }\n    ///     })\n    function attest(AttestationRequest calldata request) external payable returns (bytes32);\n\n    /// @notice Attests to a specific schema via the provided ECDSA signature.\n    /// @param delegatedRequest The arguments of the delegated attestation request.\n    /// @return The UID of the new attestation.\n    ///\n    /// Example:\n    ///     attestByDelegation({\n    ///         schema: '0x8e72f5bc0a8d4be6aa98360baa889040c50a0e51f32dbf0baa5199bd93472ebc',\n    ///         data: {\n    ///             recipient: '0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266',\n    ///             expirationTime: 1673891048,\n    ///             revocable: true,\n    ///             refUID: '0x0000000000000000000000000000000000000000000000000000000000000000',\n    ///             data: '0x1234',\n    ///             value: 0\n    ///         },\n    ///         signature: {\n    ///             v: 28,\n    ///             r: '0x148c...b25b',\n    ///             s: '0x5a72...be22'\n    ///         },\n    ///         attester: '0xc5E8740aD971409492b1A63Db8d83025e0Fc427e',\n    ///         deadline: 1673891048\n    ///     })\n    function attestByDelegation(\n        DelegatedAttestationRequest calldata delegatedRequest\n    ) external payable returns (bytes32);\n\n    /// @notice Attests to multiple schemas.\n    /// @param multiRequests The arguments of the multi attestation requests. The requests should be grouped by distinct\n    ///     schema ids to benefit from the best batching optimization.\n    /// @return The UIDs of the new attestations.\n    ///\n    /// Example:\n    ///     multiAttest([{\n    ///         schema: '0x33e9094830a5cba5554d1954310e4fbed2ef5f859ec1404619adea4207f391fd',\n    ///         data: [{\n    ///             recipient: '0xdEADBeAFdeAdbEafdeadbeafDeAdbEAFdeadbeaf',\n    ///             expirationTime: 1673891048,\n    ///             revocable: true,\n    ///             refUID: '0x0000000000000000000000000000000000000000000000000000000000000000',\n    ///             data: '0x1234',\n    ///             value: 1000\n    ///         },\n    ///         {\n    ///             recipient: '0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266',\n    ///             expirationTime: 0,\n    ///             revocable: false,\n    ///             refUID: '0x480df4a039efc31b11bfdf491b383ca138b6bde160988222a2a3509c02cee174',\n    ///             data: '0x00',\n    ///             value: 0\n    ///         }],\n    ///     },\n    ///     {\n    ///         schema: '0x5ac273ce41e3c8bfa383efe7c03e54c5f0bff29c9f11ef6ffa930fc84ca32425',\n    ///         data: [{\n    ///             recipient: '0xdEADBeAFdeAdbEafdeadbeafDeAdbEAFdeadbeaf',\n    ///             expirationTime: 0,\n    ///             revocable: true,\n    ///             refUID: '0x75bf2ed8dca25a8190c50c52db136664de25b2449535839008ccfdab469b214f',\n    ///             data: '0x12345678',\n    ///             value: 0\n    ///         },\n    ///     }])\n    function multiAttest(MultiAttestationRequest[] calldata multiRequests) external payable returns (bytes32[] memory);\n\n    /// @notice Attests to multiple schemas using via provided ECDSA signatures.\n    /// @param multiDelegatedRequests The arguments of the delegated multi attestation requests. The requests should be\n    ///     grouped by distinct schema ids to benefit from the best batching optimization.\n    /// @return The UIDs of the new attestations.\n    ///\n    /// Example:\n    ///     multiAttestByDelegation([{\n    ///         schema: '0x8e72f5bc0a8d4be6aa98360baa889040c50a0e51f32dbf0baa5199bd93472ebc',\n    ///         data: [{\n    ///             recipient: '0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266',\n    ///             expirationTime: 1673891048,\n    ///             revocable: true,\n    ///             refUID: '0x0000000000000000000000000000000000000000000000000000000000000000',\n    ///             data: '0x1234',\n    ///             value: 0\n    ///         },\n    ///         {\n    ///             recipient: '0xdEADBeAFdeAdbEafdeadbeafDeAdbEAFdeadbeaf',\n    ///             expirationTime: 0,\n    ///             revocable: false,\n    ///             refUID: '0x0000000000000000000000000000000000000000000000000000000000000000',\n    ///             data: '0x00',\n    ///             value: 0\n    ///         }],\n    ///         signatures: [{\n    ///             v: 28,\n    ///             r: '0x148c...b25b',\n    ///             s: '0x5a72...be22'\n    ///         },\n    ///         {\n    ///             v: 28,\n    ///             r: '0x487s...67bb',\n    ///             s: '0x12ad...2366'\n    ///         }],\n    ///         attester: '0x1D86495b2A7B524D747d2839b3C645Bed32e8CF4',\n    ///         deadline: 1673891048\n    ///     }])\n    function multiAttestByDelegation(\n        MultiDelegatedAttestationRequest[] calldata multiDelegatedRequests\n    ) external payable returns (bytes32[] memory);\n\n    /// @notice Revokes an existing attestation to a specific schema.\n    /// @param request The arguments of the revocation request.\n    ///\n    /// Example:\n    ///     revoke({\n    ///         schema: '0x8e72f5bc0a8d4be6aa98360baa889040c50a0e51f32dbf0baa5199bd93472ebc',\n    ///         data: {\n    ///             uid: '0x101032e487642ee04ee17049f99a70590c735b8614079fc9275f9dd57c00966d',\n    ///             value: 0\n    ///         }\n    ///     })\n    function revoke(RevocationRequest calldata request) external payable;\n\n    /// @notice Revokes an existing attestation to a specific schema via the provided ECDSA signature.\n    /// @param delegatedRequest The arguments of the delegated revocation request.\n    ///\n    /// Example:\n    ///     revokeByDelegation({\n    ///         schema: '0x8e72f5bc0a8d4be6aa98360baa889040c50a0e51f32dbf0baa5199bd93472ebc',\n    ///         data: {\n    ///             uid: '0xcbbc12102578c642a0f7b34fe7111e41afa25683b6cd7b5a14caf90fa14d24ba',\n    ///             value: 0\n    ///         },\n    ///         signature: {\n    ///             v: 27,\n    ///             r: '0xb593...7142',\n    ///             s: '0x0f5b...2cce'\n    ///         },\n    ///         revoker: '0x244934dd3e31bE2c81f84ECf0b3E6329F5381992',\n    ///         deadline: 1673891048\n    ///     })\n    function revokeByDelegation(DelegatedRevocationRequest calldata delegatedRequest) external payable;\n\n    /// @notice Revokes existing attestations to multiple schemas.\n    /// @param multiRequests The arguments of the multi revocation requests. The requests should be grouped by distinct\n    ///     schema ids to benefit from the best batching optimization.\n    ///\n    /// Example:\n    ///     multiRevoke([{\n    ///         schema: '0x8e72f5bc0a8d4be6aa98360baa889040c50a0e51f32dbf0baa5199bd93472ebc',\n    ///         data: [{\n    ///             uid: '0x211296a1ca0d7f9f2cfebf0daaa575bea9b20e968d81aef4e743d699c6ac4b25',\n    ///             value: 1000\n    ///         },\n    ///         {\n    ///             uid: '0xe160ac1bd3606a287b4d53d5d1d6da5895f65b4b4bab6d93aaf5046e48167ade',\n    ///             value: 0\n    ///         }],\n    ///     },\n    ///     {\n    ///         schema: '0x5ac273ce41e3c8bfa383efe7c03e54c5f0bff29c9f11ef6ffa930fc84ca32425',\n    ///         data: [{\n    ///             uid: '0x053d42abce1fd7c8fcddfae21845ad34dae287b2c326220b03ba241bc5a8f019',\n    ///             value: 0\n    ///         },\n    ///     }])\n    function multiRevoke(MultiRevocationRequest[] calldata multiRequests) external payable;\n\n    /// @notice Revokes existing attestations to multiple schemas via provided ECDSA signatures.\n    /// @param multiDelegatedRequests The arguments of the delegated multi revocation attestation requests. The requests\n    ///     should be grouped by distinct schema ids to benefit from the best batching optimization.\n    ///\n    /// Example:\n    ///     multiRevokeByDelegation([{\n    ///         schema: '0x8e72f5bc0a8d4be6aa98360baa889040c50a0e51f32dbf0baa5199bd93472ebc',\n    ///         data: [{\n    ///             uid: '0x211296a1ca0d7f9f2cfebf0daaa575bea9b20e968d81aef4e743d699c6ac4b25',\n    ///             value: 1000\n    ///         },\n    ///         {\n    ///             uid: '0xe160ac1bd3606a287b4d53d5d1d6da5895f65b4b4bab6d93aaf5046e48167ade',\n    ///             value: 0\n    ///         }],\n    ///         signatures: [{\n    ///             v: 28,\n    ///             r: '0x148c...b25b',\n    ///             s: '0x5a72...be22'\n    ///         },\n    ///         {\n    ///             v: 28,\n    ///             r: '0x487s...67bb',\n    ///             s: '0x12ad...2366'\n    ///         }],\n    ///         revoker: '0x244934dd3e31bE2c81f84ECf0b3E6329F5381992',\n    ///         deadline: 1673891048\n    ///     }])\n    function multiRevokeByDelegation(\n        MultiDelegatedRevocationRequest[] calldata multiDelegatedRequests\n    ) external payable;\n\n    /// @notice Timestamps the specified bytes32 data.\n    /// @param data The data to timestamp.\n    /// @return The timestamp the data was timestamped with.\n    function timestamp(bytes32 data) external returns (uint64);\n\n    /// @notice Timestamps the specified multiple bytes32 data.\n    /// @param data The data to timestamp.\n    /// @return The timestamp the data was timestamped with.\n    function multiTimestamp(bytes32[] calldata data) external returns (uint64);\n\n    /// @notice Revokes the specified bytes32 data.\n    /// @param data The data to timestamp.\n    /// @return The timestamp the data was revoked with.\n    function revokeOffchain(bytes32 data) external returns (uint64);\n\n    /// @notice Revokes the specified multiple bytes32 data.\n    /// @param data The data to timestamp.\n    /// @return The timestamp the data was revoked with.\n    function multiRevokeOffchain(bytes32[] calldata data) external returns (uint64);\n\n    /// @notice Returns an existing attestation by UID.\n    /// @param uid The UID of the attestation to retrieve.\n    /// @return The attestation data members.\n    function getAttestation(bytes32 uid) external view returns (Attestation memory);\n\n    /// @notice Checks whether an attestation exists.\n    /// @param uid The UID of the attestation to retrieve.\n    /// @return Whether an attestation exists.\n    function isAttestationValid(bytes32 uid) external view returns (bool);\n\n    /// @notice Returns the timestamp that the specified data was timestamped with.\n    /// @param data The data to query.\n    /// @return The timestamp the data was timestamped with.\n    function getTimestamp(bytes32 data) external view returns (uint64);\n\n    /// @notice Returns the timestamp that the specified data was timestamped with.\n    /// @param data The data to query.\n    /// @return The timestamp the data was timestamped with.\n    function getRevokeOffchain(address revoker, bytes32 data) external view returns (uint64);\n}\n"
    },
    "src/interfaces/IInvestorRegistry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {IERC20MetadataUpgradeable} from\n    \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\n\nimport {IEAS, AttestationRequestData} from \"eas-contracts/IEAS.sol\";\nimport {IRiscZeroVerifier} from \"risc0/IRiscZeroVerifier.sol\";\n\nimport {IBaseRegistry} from \"src/interfaces/IBaseRegistry.sol\";\nimport {IRoleRegistry} from \"src/interfaces/IRoleRegistry.sol\";\nimport {IInstrumentRegistry} from \"src/interfaces/IInstrumentRegistry.sol\";\nimport {IDealerRegistry} from \"src/interfaces/IDealerRegistry.sol\";\nimport {IOperationsEngine} from \"src/interfaces/IOperationsEngine.sol\";\nimport {IUserRegistry} from \"src/interfaces/IUserRegistry.sol\";\nimport {IGatewayManager} from \"src/interfaces/IGatewayManager.sol\";\nimport {IEternalRegistryStorage} from \"src/interfaces/IEternalRegistryStorage.sol\";\nimport {OrderProofData, SteelProofData, CredentialProofData} from \"src/utils/Types.sol\";\nimport {IRiscZeroVerifier} from \"risc0/IRiscZeroVerifier.sol\";\n\n/**\n * @title IInvestorRegistry\n * @author Libre\n * @notice Interface for managing investors, including adding new investors, managing credentials, and verifying subscriptions.\n * It integrates with Ethereum Attestation Service (EAS) and zk-verifiers to ensure security and compliance.\n */\ninterface IInvestorRegistry is IBaseRegistry, IUserRegistry {\n    /// @notice Thrown when an operation is not permitted due to insufficient privileges.\n    error IInvestorRegistry_OperationNotPermitted();\n\n    /// @notice Thrown when the sender is not the dealer associated with the specified investor.\n    error IInvestorRegistry_NotInvestorsDealer();\n\n    /// @notice Thrown when the caller is not the Operations Engine.\n    error IInvestorRegistry_NotOperationsEngine();\n\n    /// @notice Thrown when the caller is not the Jurisdiction Registry.\n    error IInvestorRegistry_NotJurisdictionRegistry();\n\n    /// @notice Thrown when attempting to add an investor who is already registered.\n    error IInvestorRegistry_AlreadyAnInvestor();\n\n    /// @notice Thrown when the sender does not have the Contract Manager role.\n    error IInvestorRegistry_NoContractManagerRole();\n\n    /// @notice Thrown when the Resolver Verifier address is empty or invalid.\n    error IInvestorRegistry_EmptyResolverVerifier();\n\n    /// @notice Thrown when the provided zk program image IDs are empty.\n    error IInvestorRegistry_EmptyImageIDs();\n\n    /// @notice Thrown when the sender does not have the Attester role.\n    error IInvestorRegistry_NoAttesterRole();\n\n    /// @notice Thrown when attempting to access a schema that has not been set.\n    error IInvestorRegistry_SchemaNotSet();\n\n    /// @notice Thrown when attempting to access a credential that does not exist.\n    error IInvestorRegistry_NonExistingCredential();\n\n    /// @notice Thrown when the credential is found to be invalid or revoked.\n    error IInvestorRegistry_CredentialInvalid();\n\n    /// @notice Thrown when the Investor Id doesn't match with the attestation's investor Id.\n    error IInvestorRegistry_MismatchInvestorId();\n\n    /// @notice Thrown when a credential does not grant access to the specified instrument.\n    error IInvestorRegistry_InstrumentCredentialInvalid();\n\n    /// @notice Thrown when attempting to revoke access to instruments that are not part of the credential.\n    error IInvestorRegistry_InstrumentsToRevokeNotInCredential();\n\n    /// @notice Thrown when there is a mismatch in the policy viewer proof.\n    error IInvestorRegistry_PolicyViewerProofMismatch();\n\n    /// @notice Thrown when an invalid dealer ID is provided.\n    error IInvestorRegistry_InvalidDealerId();\n\n    // Events\n    /**\n     * @notice Emitted when a new investor is added to the registry.\n     * @param investorId The unique identifier of the new investor.\n     * @param wallet The initial wallet address associated with the investor.\n     */\n    event NewInvestorAdded(bytes32 investorId, address wallet);\n\n    /**\n     * @notice Emitted when a credential is set for an investor.\n     * @param investorId The unique identifier of the investor.\n     * @param instrumentIds The list of instrument IDs included in the credential.\n     */\n    event InvestorRegistryCredentialSet(bytes32 investorId, bytes32[] instrumentIds);\n\n    /**\n     * @notice Emitted when a credential is revoked for an investor.\n     * @param investorId The unique identifier of the investor.\n     * @param instrumentIds The list of instrument IDs that have been revoked.\n     */\n    event InvestorRegistryCredentialRevoked(bytes32 investorId, bytes32[] instrumentIds);\n\n    /**\n     * @notice Emitted when the Resolver Verifier is updated.\n     * @param resolverVerifierAddress The address of the new Resolver Verifier.\n     */\n    event InvestorRegistryResolverVerifierChanged(address resolverVerifierAddress);\n\n    /**\n     * @notice Emitted when the zk program image IDs are updated.\n     * @param credentialImageID The new image ID for the credential zk program.\n     * @param subscriptionImageID The new image ID for the subscription zk program.\n     */\n    event InvestorRegistryImageIDsChanged(bytes32 credentialImageID, bytes32 subscriptionImageID);\n\n    /**\n     * @notice Initialize the registry\n     * @param _roleRegistry Address of the Role Registry\n     * @param _instrumentRegistry Address of the Instrument Registry\n     * @param _dealerRegistry Address of the Dealer Registry\n     * @param _jurisdictionRegistry Address of the Jurisdiction Registry\n     * @param _operationsEngine Address of the Operations Engine\n     * @param _eas Address of the Ethereum Attestation Service contract\n     * @param _gatewayManager Address of the gateway manager contract\n     * @param _resolverVerifier Address of the Resolver Verifier\n     * @param _policyViewer Address of the Policy Viewer\n     */\n    function initialize(\n        IRoleRegistry _roleRegistry,\n        IInstrumentRegistry _instrumentRegistry,\n        IDealerRegistry _dealerRegistry,\n        IEternalRegistryStorage _jurisdictionRegistry,\n        IOperationsEngine _operationsEngine,\n        IEAS _eas,\n        IGatewayManager _gatewayManager,\n        address _resolverVerifier,\n        address _policyViewer\n    ) external;\n\n    /**\n     * @notice Adds a new investor to the registry\n     * @param _senderRole Role the sender claims to have\n     * @param _investorId ID of the investor\n     * @param _wallet Default address of the investor\n     * @param _dealerId ID of the dealer\n     */\n    function addInvestor(bytes32 _senderRole, bytes32 _investorId, address _wallet, bytes32 _dealerId) external;\n\n    /**\n     * @notice Checks a subscription is allowed into the instrument\n     * @param _proof proof data for zk verifier\n     */\n    function checkSubscription(OrderProofData calldata _proof) external view;\n\n    /**\n     * @notice Replaces the ResolverVerifier contract with a new version, renewing the schema in the process\n     * @param _resolverVerifier address of new resolverVerifier\n     */\n    function configureResolverVerifier(address _resolverVerifier) external;\n\n    /**\n     * @notice Changes the zk program image IDs to use with the verifier\n     * @param _credentialImageID new image ID for the credential zk program\n     * @param _subscriptionImageID new image ID for the subscription zk program\n     */\n    function configureImageIDs(bytes32 _credentialImageID, bytes32 _subscriptionImageID) external;\n\n    /**\n     * @notice Creates a new investor credential or updates an existing/revoked one\n     * @param _proof contains data for setting the credential, including the zk-proof to verify\n     * @dev When updating credential, seal should contain the proof for new instruments, while\n     * the journal should include existing ones to be kept, bridge new credential via gateway manager\n     */\n    function setCredential(CredentialProofData calldata _proof) external;\n\n    /**\n     * @notice Revokes an investor credential, or access to certain instruments, bridge revoked credential via gateway manager\n     * @param _investorId Id of the investor\n     * @param _instrumentIds Instruments to revoke access from (entire credential revoked if left empty)\n     */\n    function revokeCredential(bytes32 _investorId, bytes32[] calldata _instrumentIds) external;\n\n    /**\n     * @notice Checks if the investor has a valid credential\n     * @param _investorId Id of the investor\n     */\n    function checkCredential(bytes32 _investorId) external view;\n\n    /**\n     * @notice Checks if the investor has a valid credential granting access to the instrument\n     * @param _investorId Id of the investor\n     * @param _instrumentId Id of the instrument\n     */\n    function checkCredentialInstrument(bytes32 _investorId, bytes32 _instrumentId) external view;\n\n    /**\n     * @notice Get dealer id of an investor\n     * @param _investorId The ID of the investor\n     * @return dealerId_ Id of the dealer associated to the investor\n     */\n    function getDealer(bytes32 _investorId) external view returns (bytes32 dealerId_);\n\n    /**\n     * Used by the ResolverVerifier to fetch the proof data for the current attestation\n     * @return Proof Data\n     */\n    function getTempSteelProofData() external view returns (SteelProofData memory);\n}\n"
    },
    "src/utils/Constant.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.28;\n\nimport \"src/utils/JurisdictionEncodings.sol\";\nimport \"src/utils/Types.sol\";\n\n// General Config\nbytes32 constant TIMEZONE = keccak256(\"TIMEZONE\");\nbytes32 constant MAX_TIMEZONE = keccak256(\"MAX_TIMEZONE\");\n\n// Chain/Gateway Config\nuint16 constant NATIVE_CHAIN_SELECTOR = 101;\n\n// NAV\nbytes32 constant AUDITED_NAV_PER_SHARE = keccak256(\"AUDITED_NAV_PER_SHARE\");\nbytes32 constant INSTRUMENT_ALLOWED_ADDRESSES = keccak256(\"INSTRUMENT_ALLOWED_ADDRESSES\");\n\n// Volatility\nbytes32 constant ANNUALIZED_VOLATILITY = keccak256(\"ANNUALIZED_VOLATILITY\");\n\n// Subscription Config\nbytes32 constant SUBSCRIPTION_PHASES = keccak256(\"SUBSCRIPTION_PHASES\");\nbytes32 constant SUBSCRIPTION_START = keccak256(\"SUBSCRIPTION_START\");\nbytes32 constant SUBSCRIPTION_END = keccak256(\"SUBSCRIPTION_END\");\nbytes32 constant SUBSCRIPTION_FREQUENCY = keccak256(\"SUBSCRIPTION_FREQUENCY\");\nbytes32 constant SUBSCRIPTION_FREQUENCY_TIME_UNIT = keccak256(\"SUBSCRIPTION_FREQUENCY_TIME_UNIT\");\n\n// Redemption Config\nbytes32 constant REDEMPTION_START = keccak256(\"REDEMPTION_START\");\nbytes32 constant REDEMPTION_END = keccak256(\"REDEMPTION_END\");\nbytes32 constant REDEMPTION_FREQUENCY = keccak256(\"REDEMPTION_FREQUENCY\");\nbytes32 constant REDEMPTION_FREQUENCY_TIME_UNIT = keccak256(\"REDEMPTION_FREQUENCY_TIME_UNIT\");\n\n// Fund data\nbytes32 constant FUND_ID = keccak256(\"FUND_ID\");\nbytes32 constant DISCLOSURE_DOCUMENTS = keccak256(\"DISCLOSURE_DOCUMENTS\");\nbytes32 constant LISTED_ON_REGULATED_VENUE = keccak256(\"LISTED_ON_REGULATED_VENUE\");\nbytes32 constant LOCAL_AIFM = keccak256(\"LOCAL_AIFM\");\nbytes32 constant NON_EU_AIFM = keccak256(\"NON_EU_AIFM\");\n\n// Fund Instruments data\nbytes32 constant INSTRUMENT_TOKEN = keccak256(\"INSTRUMENT_TOKEN\");\nbytes32 constant LOCAL_INVESTOR_MINIMUM_HOLDING = keccak256(\"LOCAL_INVESTOR_MINIMUM_HOLDING\");\nbytes32 constant AGGREGATED_MINIMUM_REDEMPTION_VALUE = keccak256(\"AGGREGATED_MINIMUM_REDEMPTION_VALUE\");\nbytes32 constant AGGREGATED_MINIMUM_SUBSEQUENT_SUBSCRIPTION = keccak256(\"AGGREGATED_MINIMUM_SUBSEQUENT_SUBSCRIPTION\");\nbytes32 constant INVESTOR_MINIMUM_INITIAL_SUBSCRIPTION = keccak256(\"INVESTOR_MINIMUM_INITIAL_SUBSCRIPTION\");\nbytes32 constant INVESTOR_MINIMUM_SUBSEQUENT_SUBSCRIPTION = keccak256(\"INVESTOR_MINIMUM_SUBSEQUENT_SUBSCRIPTION\");\nbytes32 constant REDEMPTION_BOOK = keccak256(\"REDEMPTION_BOOK\");\nbytes32 constant SUBSCRIPTION_BOOK = keccak256(\"SUBSCRIPTION_BOOK\");\n\n// Subscription Cutoff\nbytes32 constant SUBSCRIPTION_CUT_OFF_CALENDAR_DAYS = keccak256(\"SUBSCRIPTION_CUT_OFF_CALENDAR_DAYS\");\nbytes32 constant SUBSCRIPTION_CUT_OFF_BUSINESS_DAYS = keccak256(\"SUBSCRIPTION_CUT_OFF_BUSINESS_DAYS\");\nbytes32 constant SUBSCRIPTION_CUT_OFF_TIME = keccak256(\"SUBSCRIPTION_CUT_OFF_TIME\");\nbytes32 constant SUBSCRIPTION_CUT_OFF_PERIOD = keccak256(\"SUBSCRIPTION_CUT_OFF_PERIOD\");\n\nbytes32 constant LOCAL_AGGREGATE_MINIMUM_HOLDING = keccak256(\"LOCAL_AGGREGATE_MINIMUM_HOLDING\");\nbytes32 constant SUBSCRIPTION_SIZE_MULTIPLE = keccak256(\"SUBSCRIPTION_SIZE_MULTIPLE\");\nbytes32 constant GLOBAL_AGGREGATE_MINIMUM_BREACH = keccak256(\"GLOBAL_AGGREGATE_MINIMUM_BREACH\");\nbytes32 constant FORCED_REDEMPTION_TOP_UP_PERIOD = keccak256(\"FORCED_REDEMPTION_TOP_UP_PERIOD\");\nbytes32 constant FORCED_REDEMPTION_TOP_UP_PERIOD_UNIT = keccak256(\"FORCED_REDEMPTION_TOP_UP_PERIOD_UNIT\");\nbytes32 constant REDEMPTION_VOLUME_LIMIT = keccak256(\"REDEMPTION_VOLUME_LIMIT\");\nbytes32 constant REDEMPTION_VOLUME_LIMIT_PER_INVESTOR = keccak256(\"REDEMPTION_VOLUME_LIMIT_PER_INVESTOR\");\nbytes32 constant REDEMPTION_VOLUME_LIMIT_PER_INVESTOR_FEE = keccak256(\"REDEMPTION_VOLUME_LIMIT_PER_INVESTOR_FEE\");\nbytes32 constant REDEMPTION_LOOKBACK_PERIOD = keccak256(\"REDEMPTION_LOOKBACK_PERIOD\");\nbytes32 constant REDEMPTION_LOOKBACK_PERIOD_UNIT = keccak256(\"REDEMPTION_LOOKBACK_PERIOD_UNIT\");\nbytes32 constant GATE_CRITERIA_1 = keccak256(\"GATE_CRITERIA_1\");\nbytes32 constant REDEMPTION_NOTICE_PERIOD = keccak256(\"REDEMPTION_NOTICE_PERIOD\");\nbytes32 constant REDEMPTION_NOTICE_PERIOD_UNIT = keccak256(\"REDEMPTION_NOTICE_PERIOD_UNIT\");\nbytes32 constant REDEMPTION_CUT_OFF_PERIOD = keccak256(\"REDEMPTION_CUT_OFF_PERIOD\");\n// Calendar\nbytes32 constant BUSINESS_DAY_BITMAP_PART_1 = keccak256(\"BUSINESS_DAY_BITMAP_PART_1\");\nbytes32 constant BUSINESS_DAY_BITMAP_PART_2 = keccak256(\"BUSINESS_DAY_BITMAP_PART_2\");\n\n// Redemption Cutoff\nbytes32 constant REDEMPTION_CUT_OFF_CALENDAR_DAYS = keccak256(\"REDEMPTION_CUT_OFF_CALENDAR_DAYS\");\nbytes32 constant REDEMPTION_CUT_OFF_BUSINESS_DAYS = keccak256(\"REDEMPTION_CUT_OFF_BUSINESS_DAYS\");\nbytes32 constant REDEMPTION_CUT_OFF_TIME = keccak256(\"REDEMPTION_CUT_OFF_TIME\");\n\n// Execution Date\nbytes32 constant SUBSCRIPTION_NOTICE_PERIOD_CALENDAR_MONTHS = keccak256(\"SUBSCRIPTION_NOTICE_PERIOD_CALENDAR_MONTHS\");\nbytes32 constant SUBSCRIPTION_NOTICE_PERIOD_CALENDAR_DAYS = keccak256(\"SUBSCRIPTION_NOTICE_PERIOD_CALENDAR_DAYS\");\nbytes32 constant SUBSCRIPTION_NOTICE_PERIOD_BUSINESS_DAYS = keccak256(\"SUBSCRIPTION_NOTICE_PERIOD_BUSINESS_DAYS\");\nbytes32 constant SUBSCRIPTION_CUTOFF_TIME = keccak256(\"SUBSCRIPTION_CUTOFF_TIME\");\nbytes32 constant WAIVE_SUBSCRIPTION_NOTICE_PERIOD = keccak256(\"WAIVE_SUBSCRIPTION_NOTICE_PERIOD\");\nbytes32 constant SUBSCRIPTION_PREADJUSTMENT_DEALING_DAY_OF_MONTH =\n    keccak256(\"SUBSCRIPTION_PREADJUSTMENT_DEALING_DAY_OF_MONTH\");\nbytes32 constant REDEMPTION_NOTICE_PERIOD_CALENDAR_MONTHS = keccak256(\"REDEMPTION_NOTICE_PERIOD_CALENDAR_MONTHS\");\nbytes32 constant REDEMPTION_NOTICE_PERIOD_CALENDAR_DAYS = keccak256(\"REDEMPTION_NOTICE_PERIOD_CALENDAR_DAYS\");\nbytes32 constant REDEMPTION_NOTICE_PERIOD_BUSINESS_DAYS = keccak256(\"REDEMPTION_NOTICE_PERIOD_BUSINESS_DAYS\");\nbytes32 constant REDEMPTION_CUTOFF_TIME = keccak256(\"REDEMPTION_CUTOFF_TIME\");\nbytes32 constant WAIVE_REDEMPTION_NOTICE_PERIOD = keccak256(\"WAIVE_REDEMPTION_NOTICE_PERIOD\");\nbytes32 constant REDEMPTION_PREADJUSTMENT_DEALING_DAY_OF_MONTH =\n    keccak256(\"REDEMPTION_PREADJUSTMENT_DEALING_DAY_OF_MONTH\");\n\n// Redemption Holding Intervals\nbytes32 constant REDEMPTION_FIRST_UNLOCK_PERIOD = keccak256(\"REDEMPTION_FIRST_UNLOCK_PERIOD\");\nbytes32 constant REDEMPTION_SECOND_UNLOCK_PERIOD = keccak256(\"REDEMPTION_SECOND_UNLOCK_PERIOD\");\n\nbytes32 constant CUMULATIVE_REDEMPTION_PERIOD = keccak256(\"CUMULATIVE_REDEMPTION_PERIOD\");\nbytes32 constant CUMULATIVE_REDEMPTION_PERIOD_UNIT = keccak256(\"CUMULATIVE_REDEMPTION_PERIOD_UNIT\");\nbytes32 constant CUMULATIVE_REDEMPTION_LIMIT_FEE = keccak256(\"CUMULATIVE_REDEMPTION_LIMIT_FEE\");\nbytes32 constant CUMULATIVE_REDEMPTION_LIMIT_ALLOWANCE = keccak256(\"CUMULATIVE_REDEMPTION_LIMIT_ALLOWANCE\");\nbytes32 constant CUMULATIVE_REDEMPTION_LIMIT_PER_INVESTOR_ALLOWANCE =\n    keccak256(\"CUMULATIVE_REDEMPTION_LIMIT_PER_INVESTOR_ALLOWANCE\");\nbytes32 constant CUMULATIVE_REDEMPTION_LIMIT_PER_INVESTOR_FEE =\n    keccak256(\"CUMULATIVE_REDEMPTION_LIMIT_PER_INVESTOR_FEE\");\nbytes32 constant INITIAL_REDEMPTION_RESTRICTED_PERIOD = keccak256(\"INITIAL_REDEMPTION_RESTRICTED_PERIOD\");\nbytes32 constant INITIAL_SUBSCRIPTION_RESTRICTED_PERIOD = keccak256(\"INITIAL_SUBSCRIPTION_RESTRICTED_PERIOD\");\nbytes32 constant INITIAL_SUBSCRIPTION_RESTRICTED_PERIOD_UNIT = keccak256(\"INITIAL_SUBSCRIPTION_RESTRICTED_PERIOD_UNIT\");\nbytes32 constant INITIAL_SUBSCRIPTION_RESTRICTED_PERIOD_ALLOWANCE =\n    keccak256(\"INITIAL_SUBSCRIPTION_RESTRICTED_PERIOD_ALLOWANCE\");\nbytes32 constant INITIAL_SUBSCRIPTION_RESTRICTED_PERIOD_FEE = keccak256(\"INITIAL_SUBSCRIPTION_RESTRICTED_PERIOD_FEE\");\nbytes32 constant INITIAL_REDEMPTION_RESTRICTED_PERIOD_ALLOWANCE =\n    keccak256(\"INITIAL_REDEMPTION_RESTRICTED_PERIOD_ALLOWANCE\");\nbytes32 constant POST_SUBSCRIPTION_RESTRICTED_PERIOD_ALLOWANCE =\n    keccak256(\"POST_SUBSCRIPTION_RESTRICTED_PERIOD_ALLOWANCE\");\nbytes32 constant POST_SUBSCRIPTION_RESTRICTED_PERIOD_FEE = keccak256(\"POST_SUBSCRIPTION_RESTRICTED_PERIOD_FEE\");\nbytes32 constant INITIAL_REDEMPTION_RESTRICTED_PERIOD_FEE = keccak256(\"INITIAL_REDEMPTION_RESTRICTED_PERIOD_FEE\");\nbytes32 constant POST_REDEMPTION_RESTRICTED_PERIOD_ALLOWANCE = keccak256(\"POST_REDEMPTION_RESTRICTED_PERIOD_ALLOWANCE\");\nbytes32 constant POST_REDEMPTION_RESTRICTED_PERIOD_FEE = keccak256(\"POST_REDEMPTION_RESTRICTED_PERIOD_FEE\");\nbytes32 constant GLOBAL_AGGREGATE_MINIMUM_HOLDING = keccak256(\"GLOBAL_AGGREGATE_MINIMUM_HOLDING\");\nbytes32 constant BLOCKED = keccak256(\"BLOCKED\");\nbytes32 constant RESIDENCES_ALLOWED = keccak256(\"RESIDENCES_ALLOWED\");\nbytes32 constant NATIONALITIES_ALLOWED = keccak256(\"NATIONALITIES_ALLOWED\");\nbytes32 constant INVESTOR_TYPES_ALLOWED = keccak256(\"INVESTOR_TYPES_ALLOWED\");\nbytes32 constant ESTIMATED_REDEMPTION_FEE = keccak256(\"ESTIMATED_REDEMPTION_FEE\");\nbytes32 constant IS_INVESTOR_ALLOWED = keccak256(\"IS_INVESTOR_ALLOWED\");\nbytes32 constant HOLDING_FEE = keccak256(\"HOLDING_FEE\");\nbytes32 constant HOLDING_FEE_PERIOD = keccak256(\"HOLDING_FEE_PERIOD\");\nbytes32 constant HOLDING_FEE_PERIOD_UNIT = keccak256(\"HOLDING_FEE_PERIOD_UNIT\");\n\n// Investors data\nbytes32 constant INVESTOR_TYPE = keccak256(\"INVESTOR_TYPE\");\nbytes32 constant MAX_INVESTOR_TYPE = keccak256(\"MAX_INVESTOR_TYPE\");\nbytes32 constant NATIONALITIES = keccak256(\"NATIONALITIES\");\nbytes32 constant REVIEW_DATE = keccak256(\"REVIEW_DATE\");\nbytes32 constant KYC_PASSED = keccak256(\"KYC_PASSED\");\nbytes32 constant AML_PASSED = keccak256(\"AML_PASSED\");\nbytes32 constant SANCTIONS_PASSED = keccak256(\"SANCTIONS_PASSED\");\nbytes32 constant SELF_CERTIFICATION = keccak256(\"SELF_CERTIFICATION\");\nbytes32 constant FITNESS_TEST = keccak256(\"FITNESS_TEST\");\nbytes32 constant FROZEN = keccak256(\"FROZEN\");\nbytes32 constant USA_STATE = keccak256(\"USA_STATE\");\nbytes32 constant ALLOWED_TO_INTERACT_DAY = keccak256(\"ALLOWED_TO_INTERACT_DAY\");\nbytes32 constant DEALER = keccak256(\"DEALER\");\nbytes32 constant REVERSE_ENQUIRY = keccak256(\"REVERSE_ENQUIRY\");\n\n// Jurisdictions data\nbytes32 constant JURISDICTION_ALLOWED = keccak256(\"JURISDICTION_ALLOWED\");\nbytes32 constant INVESTOR_ALLOWLISTED_REQUIRED = keccak256(\"INVESTOR_ALLOWLISTED_REQUIRED\");\nbytes32 constant SELF_CERTIFICATION_REQUIRED = keccak256(\"SELF_CERTIFICATION_REQUIRED\");\nbytes32 constant FITNESS_TEST_REQUIRED = keccak256(\"FITNESS_TEST_REQUIRED\");\nbytes32 constant DISCLOSURE_DOCUMENTS_REQUIRED = keccak256(\"DISCLOSURE_DOCUMENTS_REQUIRED\");\nbytes32 constant LISTED_ON_REGULATED_VENUE_REQUIRED = keccak256(\"LISTED_ON_REGULATED_VENUE_REQUIRED\");\nbytes32 constant LOCAL_AIFM_REQUIRED = keccak256(\"LOCAL_AIFM_REQUIRED\");\nbytes32 constant NON_EU_AIFM_REQUIRED = keccak256(\"NON_EU_AIFM_REQUIRED\");\nbytes32 constant MINIMUM_INVESTMENT_REQUIRED = keccak256(\"MINIMUM_INVESTMENT_REQUIRED\");\nbytes32 constant MINIMUM_INVESTMENT = keccak256(\"MINIMUM_INVESTMENT\");\nbytes32 constant NO_MINIMUM_INVESTMENT_HOLDER_NUMBER = keccak256(\"NO_MINIMUM_INVESTMENT_HOLDER_NUMBER\");\n\n// Registries\nbytes32 constant GENERAL_DATA_ID = bytes32(0);\nbytes32 constant ETERNAL_STORAGE_SLOT = keccak256(\"ETERNAL_STORAGE_SLOT\");\nbytes32 constant BLACKLISTED_WALLET = keccak256(\"BLACKLISTED_WALLET\");\n\n// Tracking\nbytes32 constant CURRENT_SUBSCRIPTIONS_AMOUNT = keccak256(\"CURRENT_SUBSCRIPTIONS_AMOUNT\");\nbytes32 constant INVESTOR_SUBSCRIPTION_AMOUNT = keccak256(\"INVESTOR_SUBSCRIPTION_AMOUNT\");\nbytes32 constant CURRENT_REDEMPTIONS_AMOUNT = keccak256(\"CURRENT_REDEMPTIONS_AMOUNT\");\nbytes32 constant INVESTOR_REDEMPTION_AMOUNT = keccak256(\"INVESTOR_REDEMPTION_AMOUNT\");\nbytes32 constant REDEMPTION_RECORDS = keccak256(\"REDEMPTION_RECORDS\");\nbytes32 constant REDEMPTION_RECORDS_COUNT = keccak256(\"REDEMPTION_RECORDS_COUNT\");\nbytes32 constant REDEMPTION_RECORDS_AGGREGATE = keccak256(\"REDEMPTION_RECORDS_AGGREGATE\");\nbytes32 constant REDEMPTION_RECORDS_TIMESTAMP = keccak256(\"REDEMPTION_RECORDS_TIMESTAMP\");\nbytes32 constant HOLDING_FEE_EXEMPTION_CREDITS = keccak256(\"HOLDING_FEE_EXEMPTION_CREDITS\");\nbytes32 constant HOLDING_FEE_EXEMPTION_CREDITS_START = keccak256(\"HOLDING_FEE_EXEMPTION_CREDITS_START\");\nbytes32 constant HOLDING_FEE_EXEMPTION_CREDITS_COUNT = keccak256(\"HOLDING_FEE_EXEMPTION_CREDITS_COUNT\");\nbytes32 constant HOLDING_FEE_EXEMPTION_CREDITS_AMOUNT = keccak256(\"HOLDING_FEE_EXEMPTION_CREDITS_AMOUNT\");\nbytes32 constant HOLDING_FEE_EXEMPTION_CREDITS_TIMESTAMP = keccak256(\"HOLDING_FEE_EXEMPTION_CREDITS_TIMESTAMP\");\n\n// Tracking (Holding Intervals)\nbytes32 constant HOLDING_TIME_CREDITS = keccak256(\"HOLDING_TIME_CREDITS\");\nbytes32 constant HOLDING_TIME_CREDITS_START = keccak256(\"HOLDING_TIME_CREDITS_START\");\nbytes32 constant HOLDING_TIME_CREDITS_COUNT = keccak256(\"HOLDING_TIME_CREDITS_COUNT\");\nbytes32 constant HOLDING_TIME_CREDITS_TIMESTAMP = keccak256(\"HOLDING_TIME_CREDITS_TIMESTAMP\");\n\nbytes32 constant HOLDING_CREDITS_FIRST_PERIOD = keccak256(\"HOLDING_CREDITS_FIRST_PERIOD\"); // related to REDEMPTION_FIRST_UNLOCK_PERIOD\nbytes32 constant HOLDING_CREDITS_SECOND_PERIOD = keccak256(\"HOLDING_CREDITS_SECOND_PERIOD\"); // related to REDEMPTION_SECOND_UNLOCK_PERIOD\n\nbytes32 constant HOLDING_PERCENTAGE_FIRST_PERIOD = keccak256(\"HOLDING_PERCENTAGE_FIRST_PERIOD\");\nbytes32 constant HOLDING_PERCENTAGE_SECOND_PERIOD = keccak256(\"HOLDING_PERCENTAGE_SECOND_PERIOD\");\n\n// Tracking (NAV Track Module)\nbytes32 constant NAV_NUM_CHECKPOINTS = keccak256(\"NAV_NUM_CHECKPOINTS\");\nbytes32 constant NAV_CHECKPOINT = keccak256(\"NAV_CHECKPOINT\");\nbytes32 constant NAV_CHECKPOINT_TIMESTAMP = keccak256(\"NAV_CHECKPOINT_TIMESTAMP\");\n\n// Security Token Track (Per investor)\nbytes32 constant SECURITY_TOKEN_NUM_CHECKPOINTS = keccak256(\"SECURITY_TOKEN_NUM_CHECKPOINTS\");\nbytes32 constant SECURITY_TOKEN_CHECKPOINT_TIMESTAMP = keccak256(\"SECURITY_TOKEN_CHECKPOINT_TIMESTAMP\");\nbytes32 constant SECURITY_TOKEN_CHECKPOINTS = keccak256(\"SECURITY_TOKEN_CHECKPOINTS\");\n\n// Investor Registry\nbytes32 constant IS_INVESTOR = keccak256(\"IS_INVESTOR\");\nbytes32 constant LAST_OPERATION_TIMESTAMP = keccak256(\"LAST_OPERATION_TIMESTAMP\");\nbytes32 constant CREDENTIAL_ID = keccak256(\"CREDENTIAL_ID\");\nbytes32 constant INVESTOR_CROSS_CHAIN_ADDRESSES = keccak256(\"INVESTOR_CROSS_CHAIN_ADDRESSES\");\n\n// Instrument Registry\nbytes32 constant IS_INSTRUMENT = keccak256(\"IS_INSTRUMENT\");\nbytes32 constant TRADING_DAYS_IN_YEAR = keccak256(\"TRADING_DAYS_IN_YEAR\");\nbytes32 constant INSTRUMENT_INITIALIZED = keccak256(\"INSTRUMENT_INITIALIZED\");\nbytes32 constant INSTRUMENT_CLOSED = keccak256(\"INSTRUMENT_CLOSED\");\nbytes32 constant INSTANT_SETTLEMENT = keccak256(\"INSTANT_SETTLEMENT\");\nbytes32 constant CAN_TRANSFER_SETTLEMENT_TOKEN = keccak256(\"CAN_TRANSFER_SETTLEMENT_TOKEN\");\nbytes32 constant CAN_TRANSFER_SECURITY_TOKEN = keccak256(\"CAN_TRANSFER_SECURITY_TOKEN\");\nbytes32 constant INSTRUMENT_PAUSED = keccak256(\"INSTRUMENT_PAUSED\");\n\n// Dealer Registry\nbytes32 constant IS_DEALER = keccak256(\"IS_DEALER\");\n\n// Fund Registry\nbytes32 constant IS_FUND = keccak256(\"IS_FUND\");\nbytes32 constant DEFAULT_FUND_MODULES = keccak256(\"DEFAULT_FUND_MODULES\");\n\n// Roles\nbytes32 constant DEFAULT_ADMIN_ROLE = bytes32(0);\nbytes32 constant DEALER_MANAGER_ROLE = keccak256(\"DEALER_MANAGER_ROLE\");\nbytes32 constant LIBRE_DEALER_ROLE = keccak256(\"LIBRE_DEALER_ROLE\");\nbytes32 constant INSTRUMENT_MANAGER_ROLE = keccak256(\"INSTRUMENT_MANAGER_ROLE\");\nbytes32 constant SETTLEMENT_TOKEN_MINTER_ROLE = keccak256(\"SETTLEMENT_TOKEN_MINTER_ROLE\");\nbytes32 constant SETTLEMENT_TOKEN_BURNER_ROLE = keccak256(\"SETTLEMENT_TOKEN_BURNER_ROLE\");\nbytes32 constant RELAYER_ROLE = keccak256(\"RELAYER_ROLE\");\nbytes32 constant CONTRACT_MANAGER_ROLE = keccak256(\"CONTRACT_MANAGER_ROLE\");\nbytes32 constant REGISTRY_WRITER_ROLE_ADMIN = keccak256(\"REGISTRY_WRITER_ROLE_ADMIN\");\nbytes32 constant REGISTRY_WRITER_ROLE = keccak256(\"REGISTRY_WRITER_ROLE\");\nbytes32 constant ATTESTER_ROLE = keccak256(\"ATTESTER_ROLE\");\nbytes32 constant GATEWAY_MANAGER_ROLE = keccak256(\"GATEWAY_MANAGER_ROLE\");\nbytes32 constant CORE_GATEWAY_ROLE = keccak256(\"CORE_GATEWAY_ROLE\");\nbytes32 constant BRIDGE_ROLE = keccak256(\"BRIDGE_ROLE\");\nbytes32 constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n\n// Hash of module names\nbytes32 constant TRANSFER_MODULE = keccak256(\"TransferModule\");\nbytes32 constant DAILY_EXECUTION_CALCULATOR_MODULE = keccak256(\"DailyExecutionCalculatorModule\");\nbytes32 constant EXECUTION_DATE_ENFORCEMENT_MODULE = keccak256(\"ExecutionDateEnforcementModule\");\nbytes32 constant HALT_MODULE = keccak256(\"HaltModule\");\nbytes32 constant HOLDINGS_MODULE = keccak256(\"HoldingsModule\");\nbytes32 constant MONTHLY_EXECUTION_CALCULATOR_MODULE = keccak256(\"MonthlyExecutionCalculatorModule\");\nbytes32 constant FORCED_REDEMPTION_MODULE = keccak256(\"ForcedRedemptionModule\");\nbytes32 constant GATE_1_MODULE = keccak256(\"Gate1Module\");\nbytes32 constant HOLDING_INTERVALS_MODULE = keccak256(\"HoldingIntervalsModule\");\nbytes32 constant REDEMPTIONS_AGGREGATION_LIMIT_MODULE = keccak256(\"RedemptionsAggregationLimitModule\");\nbytes32 constant SUBSCRIPTIONS_AGGREGATION_LIMIT_MODULE = keccak256(\"SubscriptionsAggregationLimitModule\");\nbytes32 constant HOLDING_FEE_MODULE = keccak256(\"HoldingFeeModule\");\nbytes32 constant REDEMPTION_VOLUME_LIMIT_PER_INVESTOR_FEE_MODULE =\n    keccak256(\"RedemptionVolumeLimitPerInvestorFeeModule\");\nbytes32 constant INVESTOR_LAST_OPERATION_TRACKING_MODULE = keccak256(\"InvestorLastOperationTrackingModule\");\nbytes32 constant NAV_TRACKING_MODULE = keccak256(\"NAVTrackingModule\");\nbytes32 constant REDEMPTIONS_RECORDS_MODULE = keccak256(\"RedemptionsRecordsModule\");\nbytes32 constant REDEMPTIONS_TOTAL_AMOUNT_MODULE = keccak256(\"RedemptionsTotalAmountModule\");\nbytes32 constant SECURITY_TOKEN_TRACKING_MODULE = keccak256(\"SecurityTokenTrackingModule\");\nbytes32 constant SUBSCRIPTIONS_TOTAL_AMOUNT_MODULE = keccak256(\"SubscriptionsTotalAmountModule\");\nbytes32 constant HOLDING_FEE_EXEMPTION_MODULE = keccak256(\"HoldingFeeExemptionModule\");\nbytes32 constant HOLDING_INTERVALS_TRACKING_MODULE = keccak256(\"HoldingIntervalsTrackingModule\");\n\n// Percentage calculations\nuint256 constant PERCENTAGE_BASE = 100_00;\n"
    },
    "lib/risc0-ethereum/contracts/src/Util.sol": {
      "content": "// Copyright 2024 RISC Zero, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n\npragma solidity ^0.8.9;\n\n/// @notice reverse the byte order of the uint256 value.\n/// @dev Solidity uses a big-endian ABI encoding. Reversing the byte order before encoding\n/// ensure that the encoded value will be little-endian.\n/// Written by k06a. https://ethereum.stackexchange.com/a/83627\nfunction reverseByteOrderUint256(uint256 input) pure returns (uint256 v) {\n    v = input;\n\n    // swap bytes\n    v = ((v & 0xFF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00) >> 8)\n        | ((v & 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) << 8);\n\n    // swap 2-byte long pairs\n    v = ((v & 0xFFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000) >> 16)\n        | ((v & 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) << 16);\n\n    // swap 4-byte long pairs\n    v = ((v & 0xFFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000) >> 32)\n        | ((v & 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) << 32);\n\n    // swap 8-byte long pairs\n    v = ((v & 0xFFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF0000000000000000) >> 64)\n        | ((v & 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) << 64);\n\n    // swap 16-byte long pairs\n    v = (v >> 128) | (v << 128);\n}\n\n/// @notice reverse the byte order of the uint32 value.\n/// @dev Solidity uses a big-endian ABI encoding. Reversing the byte order before encoding\n/// ensure that the encoded value will be little-endian.\n/// Written by k06a. https://ethereum.stackexchange.com/a/83627\nfunction reverseByteOrderUint32(uint32 input) pure returns (uint32 v) {\n    v = input;\n\n    // swap bytes\n    v = ((v & 0xFF00FF00) >> 8) | ((v & 0x00FF00FF) << 8);\n\n    // swap 2-byte long pairs\n    v = (v >> 16) | (v << 16);\n}\n\n/// @notice reverse the byte order of the uint16 value.\n/// @dev Solidity uses a big-endian ABI encoding. Reversing the byte order before encoding\n/// ensure that the encoded value will be little-endian.\n/// Written by k06a. https://ethereum.stackexchange.com/a/83627\nfunction reverseByteOrderUint16(uint16 input) pure returns (uint16 v) {\n    v = input;\n\n    // swap bytes\n    v = (v >> 8) | ((v & 0x00FF) << 8);\n}\n"
    },
    "src/utils/Types.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {Steel} from \"risc0/steel/Steel.sol\";\n\nstruct SteelProofData {\n    //Block hash commitment for Steel\n    Steel.Commitment commitment;\n    //Seal for Steel\n    bytes seal;\n}\n\nstruct CredentialProofData {\n    //Journal Data for Steel\n    CredentialJournal journal;\n    //Seal for Steel\n    bytes seal;\n}\n\n// @notice Journal that is committed to for Credentials\nstruct CredentialJournal {\n    //Block hash commitment for Steel\n    Steel.Commitment commitment;\n    //Id of the investor\n    bytes32 investorId;\n    //Credential expiry timestamp\n    uint64 expiryTimestamp;\n    //Ids of instruments the investor is registered for\n    bytes32[] instrumentIds;\n    //Access expiry timestamps for instruments the investor is registered for\n    uint64[] instrumentExpiryTimestamps;\n    address policyViewer;\n}\n\nstruct OrderProofData {\n    //Journal Data for Steel\n    OrderJournal journal;\n    //Seal for Steel\n    bytes seal;\n}\n\n// @notice Journal that is committed to for Orders\nstruct OrderJournal {\n    //Block hash commitment for Steel\n    Steel.Commitment commitment;\n    //Id of the investor\n    bytes32 investorId;\n    //Id of the instrument the investor is subscribing or redeeming to\n    bytes32 instrumentId;\n    //Amount the investor is subscribing or redeeming with\n    uint256 amount;\n    address policyViewer;\n}\n"
    },
    "lib/eas-contracts/contracts/Common.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n// A representation of an empty/uninitialized UID.\nbytes32 constant EMPTY_UID = 0;\n\n// A zero expiration represents an non-expiring attestation.\nuint64 constant NO_EXPIRATION_TIME = 0;\n\nerror AccessDenied();\nerror DeadlineExpired();\nerror InvalidEAS();\nerror InvalidLength();\nerror InvalidSignature();\nerror NotFound();\n\n/// @notice A struct representing ECDSA signature data.\nstruct Signature {\n    uint8 v; // The recovery ID.\n    bytes32 r; // The x-coordinate of the nonce R.\n    bytes32 s; // The signature data.\n}\n\n/// @notice A struct representing a single attestation.\nstruct Attestation {\n    bytes32 uid; // A unique identifier of the attestation.\n    bytes32 schema; // The unique identifier of the schema.\n    uint64 time; // The time when the attestation was created (Unix timestamp).\n    uint64 expirationTime; // The time when the attestation expires (Unix timestamp).\n    uint64 revocationTime; // The time when the attestation was revoked (Unix timestamp).\n    bytes32 refUID; // The UID of the related attestation.\n    address recipient; // The recipient of the attestation.\n    address attester; // The attester/sender of the attestation.\n    bool revocable; // Whether the attestation is revocable.\n    bytes data; // Custom attestation data.\n}\n\n/// @notice A helper function to work with unchecked iterators in loops.\nfunction uncheckedInc(uint256 i) pure returns (uint256 j) {\n    unchecked {\n        j = i + 1;\n    }\n}\n"
    },
    "lib/eas-contracts/contracts/Semver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\n\nimport { Strings } from \"@openzeppelin/contracts/utils/Strings.sol\";\n\nimport { ISemver } from \"./ISemver.sol\";\n\n/// @title Semver\n/// @notice A simple contract for managing contract versions.\ncontract Semver is ISemver {\n    // Contract's major version number.\n    uint256 private immutable _major;\n\n    // Contract's minor version number.\n    uint256 private immutable _minor;\n\n    // Contract's patch version number.\n    uint256 private immutable _patch;\n\n    /// @dev Create a new Semver instance.\n    /// @param major Major version number.\n    /// @param minor Minor version number.\n    /// @param patch Patch version number.\n    constructor(uint256 major, uint256 minor, uint256 patch) {\n        _major = major;\n        _minor = minor;\n        _patch = patch;\n    }\n\n    /// @notice Returns the full semver contract version.\n    /// @return Semver contract version as a string.\n    function version() external view returns (string memory) {\n        return\n            string(\n                abi.encodePacked(Strings.toString(_major), \".\", Strings.toString(_minor), \".\", Strings.toString(_patch))\n            );\n    }\n}\n"
    },
    "lib/eas-contracts/contracts/resolver/ISchemaResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { Attestation } from \"./../Common.sol\";\nimport { ISemver } from \"./../ISemver.sol\";\n\n/// @title ISchemaResolver\n/// @notice The interface of an optional schema resolver.\ninterface ISchemaResolver is ISemver {\n    /// @notice Checks if the resolver can be sent ETH.\n    /// @return Whether the resolver supports ETH transfers.\n    function isPayable() external pure returns (bool);\n\n    /// @notice Processes an attestation and verifies whether it's valid.\n    /// @param attestation The new attestation.\n    /// @return Whether the attestation is valid.\n    function attest(Attestation calldata attestation) external payable returns (bool);\n\n    /// @notice Processes multiple attestations and verifies whether they are valid.\n    /// @param attestations The new attestations.\n    /// @param values Explicit ETH amounts which were sent with each attestation.\n    /// @return Whether all the attestations are valid.\n    function multiAttest(\n        Attestation[] calldata attestations,\n        uint256[] calldata values\n    ) external payable returns (bool);\n\n    /// @notice Processes an attestation revocation and verifies if it can be revoked.\n    /// @param attestation The existing attestation to be revoked.\n    /// @return Whether the attestation can be revoked.\n    function revoke(Attestation calldata attestation) external payable returns (bool);\n\n    /// @notice Processes revocation of multiple attestation and verifies they can be revoked.\n    /// @param attestations The existing attestations to be revoked.\n    /// @param values Explicit ETH amounts which were sent with each revocation.\n    /// @return Whether the attestations can be revoked.\n    function multiRevoke(\n        Attestation[] calldata attestations,\n        uint256[] calldata values\n    ) external payable returns (bool);\n}\n"
    },
    "lib/eas-contracts/contracts/ISchemaRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { ISemver } from \"./ISemver.sol\";\n\nimport { ISchemaResolver } from \"./resolver/ISchemaResolver.sol\";\n\n/// @notice A struct representing a record for a submitted schema.\nstruct SchemaRecord {\n    bytes32 uid; // The unique identifier of the schema.\n    ISchemaResolver resolver; // Optional schema resolver.\n    bool revocable; // Whether the schema allows revocations explicitly.\n    string schema; // Custom specification of the schema (e.g., an ABI).\n}\n\n/// @title ISchemaRegistry\n/// @notice The interface of global attestation schemas for the Ethereum Attestation Service protocol.\ninterface ISchemaRegistry is ISemver {\n    /// @notice Emitted when a new schema has been registered\n    /// @param uid The schema UID.\n    /// @param registerer The address of the account used to register the schema.\n    /// @param schema The schema data.\n    event Registered(bytes32 indexed uid, address indexed registerer, SchemaRecord schema);\n\n    /// @notice Submits and reserves a new schema\n    /// @param schema The schema data schema.\n    /// @param resolver An optional schema resolver.\n    /// @param revocable Whether the schema allows revocations explicitly.\n    /// @return The UID of the new schema.\n    function register(string calldata schema, ISchemaResolver resolver, bool revocable) external returns (bytes32);\n\n    /// @notice Returns an existing schema by UID\n    /// @param uid The UID of the schema to retrieve.\n    /// @return The schema data members.\n    function getSchema(bytes32 uid) external view returns (SchemaRecord memory);\n}\n"
    },
    "lib/eas-contracts/contracts/ISemver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/// @title ISemver\n/// @notice A semver interface.\ninterface ISemver {\n    /// @notice Returns the full semver contract version.\n    /// @return Semver contract version as a string.\n    function version() external view returns (string memory);\n}\n"
    },
    "lib/openzeppelin-contracts-upgradeable/contracts/token/ERC20/extensions/IERC20MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.19;\n\nimport \"../IERC20Upgradeable.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "src/interfaces/IBaseRegistry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {IEternalRegistryStorage} from \"src/interfaces/IEternalRegistryStorage.sol\";\n\n/**\n * @title IBaseRegistry\n * @notice Interface for the base registry, which provides functionality for tracking and retrieving data\n * specific to modules that interact with the registry.\n * @dev The tracked data can be queried via a delegatecall callback to the relevant module,\n * which implements the query logic.\n */\ninterface IBaseRegistry is IEternalRegistryStorage {\n    /**\n     * @notice Thrown when an unauthorized caller tries to access a restricted function or resource.\n     */\n    error IBaseRegistry_AccessDenied();\n\n    /**\n     * @notice Thrown when an action is attempted on a module that is not registered in the registry.\n     */\n    error IBaseRegistry_NotRegisteredModule();\n\n    /**\n     * @notice Thrown when an invalid or non-existent ID is provided for an operation.\n     */\n    error IBaseRegistry_NotAValidId();\n\n    /**\n     * @notice Thrown when the system fails to retrieve the tracked data for a specific operation or ID.\n     */\n    error IBaseRegistry_FailedToGetTrackedData();\n\n    /**\n     * @notice Get the tracked data of the registry\n     * @param _data Data to be used by the module to get the tracked data\n     * @return bytes memory of the tracked data\n     * @dev This function is used to get the tracked data from the registry\n     * by doing a delegatecall callback to the module requesting the data\n     * which can implement the query logic\n     */\n    function getTrackedData(bytes memory _data) external returns (bytes memory);\n}\n"
    },
    "src/interfaces/IRoleRegistry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {IAccessControlUpgradeable} from\n    \"openzeppelin-contracts-upgradeable/contracts/access/IAccessControlUpgradeable.sol\";\n\n/**\n * @title Roles Registry\n * @author Libre\n * @notice Store all the roles of the system as well as the permissions a user get by having each role.\n * @dev It is meant to be used for roles access validation in all the components of the system.\n */\ninterface IRoleRegistry is IAccessControlUpgradeable {\n    /**\n     * @notice Thrown when attempting to create a role that already exists.\n     */\n    error IRoleRegistry_RoleAlreadyExists();\n\n    /**\n     * @notice Thrown when attempting to grant a role that does not exist.\n     */\n    error IRoleRegistry_RoleDoesNotExist();\n\n    /**\n     * @notice Thrown when attempting to use a blacklisted wallet.\n     */\n    error IRoleRegistry_WalletBlacklisted();\n\n    /**\n     * @notice Used when a new role is created\n     * @param _role Parent role\n     * @param _subRole Newly created Role\n     */\n    event RoleCreated(bytes32 _role, bytes32 _subRole);\n\n    /**\n     * @notice Used when a contract manager is set\n     * @param _contract Contract managed\n     * @param _roleManager New contract manager role\n     */\n    event ContractManagerAdded(address _contract, bytes32 _roleManager);\n\n    /**\n     * @notice Used when a wallet is blacklisted\n     * @param _wallet Wallet blacklisted\n     */\n    event WalletBlacklisted(address _wallet);\n\n    /**\n     * @notice Used when a contract function access is granted\n     * @param _contract Contract managed\n     * @param _selector Selector of the funtion which access is modified\n     * @param _role Role getting access gratend\n     */\n    event AccessGranted(address _contract, bytes4 _selector, bytes32 _role);\n\n    /**\n     * @notice Used when a contract function access is revoked\n     * @param _contract Contract managed\n     * @param _selector Selector of the funtion which access is modified\n     * @param _role Role which access is revoked\n     */\n    event RevokedAccess(address _contract, bytes4 _selector, bytes32 _role);\n\n    /**\n     * @notice Used when a contract access is reset\n     * @param _contract Contract managed\n     * @param _timestamp Time when the reset is executed\n     */\n    event ResetedAccess(address _contract, uint256 _timestamp);\n\n    /**\n     * @notice Function to create subroles\n     * @param _role New role to create\n     * @param _adminRole Parent role of the newly created role\n     * @dev Caller needs to has role _adminRole\n     */\n    function createRole(bytes32 _role, bytes32 _adminRole) external;\n\n    /**\n     * @notice Set the role going to manage permissions in a specific contract\n     * @param _contract Address of the contract to where permissions are needed to be managed\n     * @param _roleManager Role in charge of managing the permissions\n     */\n    function setContractManager(address _contract, bytes32 _roleManager) external;\n\n    /**\n     * @notice Get the role that manages permissions in a specific contract\n     * @param _contract Address of the contract\n     */\n    function getContractManager(address _contract) external view returns (bytes32);\n\n    /**\n     * @notice Grant a role the right access a functionality of a contract\n     * @param _contract Contract where the access is granted\n     * @param _selector Functionality granted access for\n     * @param _role Role getting the access\n     */\n    function grantAccess(address _contract, bytes4 _selector, bytes32 _role) external;\n\n    /**\n     * @notice Prevent a role for having access to a functionality of a contract\n     * @param _contract Contract where the access is revoked\n     * @param _selector Functionality revoked access for\n     * @param _role Role losing the access\n     */\n    function revokeAccess(address _contract, bytes4 _selector, bytes32 _role) external;\n\n    /**\n     * @notice Revoke access to a functionality of a contract for all roles\n     * @param _contract Contract where the access is reset\n     * @param _selector Functionality reset access for\n     * @dev Cleans all the previously granted roles\n     */\n    function resetAccess(address _contract, bytes4 _selector) external;\n\n    /**\n     * @notice Blacklists a wallet.\n     * @param _wallet The wallet to blacklist.\n     */\n    function blacklistWallet(address _wallet) external;\n\n    /**\n     * @notice Check access of a role to a contract functionality\n     * @param _contract Contract where accessed\n     * @param _selector Functionality accessed\n     * @param _requestor Address attempting to access\n     * @param _role Role of the address attempting to access\n     */\n    function hasAccess(address _contract, bytes4 _selector, address _requestor, bytes32 _role)\n        external\n        view\n        returns (bool);\n\n    /**\n     * @notice Checks if a wallet is blacklisted.\n     * @param _wallet The wallet to check.\n     * @return Boolean indicating whether the wallet is blacklisted.\n     */\n    function isBlacklisted(address _wallet) external view returns (bool);\n}\n"
    },
    "src/interfaces/IInstrumentRegistry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {IERC20Metadata} from \"openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport {IBaseRegistry} from \"src/interfaces/IBaseRegistry.sol\";\nimport {IDealerRegistry} from \"src/interfaces/IDealerRegistry.sol\";\nimport {IFundRegistry} from \"src/interfaces/IFundRegistry.sol\";\nimport {IRoleRegistry} from \"src/interfaces/IRoleRegistry.sol\";\nimport {IInvestorRegistry} from \"src/interfaces/IInvestorRegistry.sol\";\nimport {IOperationsEngine} from \"src/interfaces/IOperationsEngine.sol\";\nimport {IEternalRegistryStorage} from \"src/interfaces/IEternalRegistryStorage.sol\";\n\n/**\n * @title IInstrumentRegistry\n * @author Libre\n * @notice Interface for managing instruments within a fund registry system.\n * Provides functionalities to initialize, add, and manage instruments, track their subscription and redemption periods,\n * update Net Asset Value (NAV) per share, and manage investor access.\n */\ninterface IInstrumentRegistry is IBaseRegistry {\n    /**\n     * @notice Thrown when attempting to add an instrument that already exists in the registry.\n     */\n    error IInstrumentRegistry_InstrumentAlreadyExists();\n\n    /**\n     * @notice Thrown when the specified instrument does not exist in the registry.\n     */\n    error IInstrumentRegistry_InstrumentDoesNotExist();\n\n    /**\n     * @notice Thrown when attempting to initialize an instrument that has already been initialized.\n     */\n    error IInstrumentRegistry_InstrumentAlreadyInitialized();\n\n    /**\n     * @notice Emited when a new instrument is added\n     * @param fundId Id of the fund where the instrument is added\n     * @param instrumentId Id of the new instrument\n     */\n    event NewFundInstrumentAdded(bytes32 indexed fundId, bytes32 indexed instrumentId);\n\n    /**\n     * @notice Emited when an instrument is initialized\n     * @param instrumentId Id of the new instrument\n     * @param settlementToken Address of the settlement token of the instrument\n     * @param securityToken Address of the deployed security token\n     * @param subscriptionBook Address of the deployed subscription book\n     * @param redemptionBook Address of the deployed redemption book\n     */\n    event FundInstrumentInitialized(\n        bytes32 indexed instrumentId,\n        address settlementToken,\n        address securityToken,\n        address subscriptionBook,\n        address redemptionBook\n    );\n\n    /**\n     * @notice Emited when an instrument is closed\n     * @param instrumentId Id of the instrument\n     */\n    event InstrumentClosed(bytes32 indexed instrumentId);\n\n    /**\n     * @notice Emited when an instrument is paused\n     * @param instrumentId Id of the instrument\n     * @param paused Y/N value indicating if the instrument is paused or not\n     */\n    event InstrumentPaused(bytes32 indexed instrumentId, bool paused);\n\n    /**\n     * @notice Emited when an investor's allowlist status is updated for an instrument\n     * @param instrumentId Id of the instrument\n     * @param investorId Id of the investor\n     * @param allowed Y/N value indicating if the investor is allowed or not\n     */\n    event InvestorAllowedUpdated(bytes32 indexed instrumentId, bytes32 indexed investorId, bool allowed);\n\n    /**\n     * @notice Initialize the registry\n     * @param _roleRegistry Address of the Role Registry\n     * @param _investorRegistry Address of the Investor Registry\n     * @param _dealerRegistry Address of the Dealer Registry\n     * @param _fundRegistry Address of the Fund Registry\n     * @param _jurisdictionRegistry Address of the Jurisdiction Registry\n     * @param _operationsEngine Address of the Rules Engine\n     */\n    function initialize(\n        IRoleRegistry _roleRegistry,\n        IInvestorRegistry _investorRegistry,\n        IDealerRegistry _dealerRegistry,\n        IFundRegistry _fundRegistry,\n        IEternalRegistryStorage _jurisdictionRegistry,\n        IOperationsEngine _operationsEngine\n    ) external;\n\n    /**\n     * @notice Adds a new fund instrument to the registry\n     * @dev _senderRole is ignored if the caller if the Fund Admin of the instrument\n     * @param _senderRole Role of the sender which allow the operation execution\n     * @param _instrumentId the instrument ID\n     * @param _fundId the fund ID\n     */\n    function addFundInstrument(bytes32 _senderRole, bytes32 _instrumentId, bytes32 _fundId) external;\n\n    /**\n     * @notice Adds a new instrument to the registry\n     * @dev _senderRole is ignored if the caller if the Fund Admin of the instrument\n     * @param _senderRole Role of the sender which allow the operation execution\n     * @param _instrumentId the instrument ID\n     * @param _settlementToken settlement token address\n     * @param _name the instrument token name\n     * @param _symbol the instrument token symbol\n     * @param _subscriptionBookImp The implementation of subscription book to be cloned\n     * @param _redemptionBookImp The implementation of redemption book to be cloned\n     * @param _stTokenImpl The implementation of security token implementation to be cloned\n     * @param _treasury The address of instrument treasury\n     * @param _policyViewerAddress The address of instrument policy viewer\n     */\n    function initializeFundInstrument(\n        bytes32 _senderRole,\n        bytes32 _fundId,\n        bytes32 _instrumentId,\n        address _settlementToken,\n        string memory _name,\n        string memory _symbol,\n        address _subscriptionBookImp,\n        address _redemptionBookImp,\n        address _stTokenImpl,\n        address _treasury,\n        address _policyViewerAddress\n    ) external;\n\n    /**\n     * @notice Close a fund instrument\n     * @param _senderRole Role of the sender which allow the operation execution\n     * @param _instrumentId The ID of the instrument\n     */\n    function closeFundInstrument(bytes32 _senderRole, bytes32 _instrumentId) external;\n\n    /**\n     * @notice Return the number of the current subscription period or\n     * 0 in case subscription is not started or infinite if subscriptions are done\n     * @dev Infinite is represented by type(uint256).max;\n     * @param _instrumentId Id of the instrument\n     * @return The current period of the subscription, the start & the end of it\n     */\n    function currentSubscriptionPeriod(bytes32 _instrumentId) external view returns (uint256, uint256, uint256);\n\n    /**\n     * @notice Return the number of the current redemption period or\n     * 0 in case redemption is not started or infinite if redemptions are done\n     * @param _instrumentId Id of the instrument\n     * @return The current period of the redemption, the start & the end of it\n     */\n    function currentRedemptionPeriod(bytes32 _instrumentId) external view returns (uint256, uint256, uint256);\n\n    /**\n     * @notice Sets a new value for the audited NAV per share of a fund\n     * @param _senderRole Role of the sender which allow the operation execution\n     * @param _instrumentId ID of the fund\n     * @param _newNavPerShare new value of the nav\n     * @dev Expressed with 6 decimals as it is in settlement tokens units\n     */\n    function updateAuditedNavPerShare(bytes32 _senderRole, bytes32 _instrumentId, uint256 _newNavPerShare) external;\n\n    /**\n     * @notice Allow investor for a specific instrument\n     * @param _instrumentId The ID of the instrument\n     * @param _investorId Id of the investor\n     * @param _allowed Y/N value indicating if the investor is allowed or not\n     * @param _senderRole Role of the sender\n     */\n    function allowInvestor(bytes32 _instrumentId, bytes32 _investorId, bool _allowed, bytes32 _senderRole) external;\n}\n"
    },
    "src/interfaces/IDealerRegistry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {IBaseRegistry} from \"src/interfaces/IBaseRegistry.sol\";\nimport {IRoleRegistry} from \"src/interfaces/IRoleRegistry.sol\";\nimport {IInvestorRegistry} from \"src/interfaces/IInvestorRegistry.sol\";\nimport {IUserRegistry} from \"src/interfaces/IUserRegistry.sol\";\nimport {IOperationsEngine} from \"src/interfaces/IOperationsEngine.sol\";\nimport {IInstrumentRegistry} from \"src/interfaces/IInstrumentRegistry.sol\";\n\n/**\n * @title IDealerRegistry\n * @notice Interface for managing dealers within the registry, including adding new dealers,\n * allowing dealers for specific instruments, and checking dealer permissions.\n * @dev Extends both `IBaseRegistry` and `IUserRegistry` for core registry and user management functionality.\n */\ninterface IDealerRegistry is IBaseRegistry, IUserRegistry {\n    /**\n     * @notice Thrown when attempting to add a dealer who is already registered.\n     */\n    error IDealerRegistry_AlreadyADealer();\n\n    /**\n     * @notice Thrown when invalid input parameters are provided.\n     */\n    error IDealerRegistry_InvalidInput();\n\n    /**\n     * @notice Thrown when the specified instrument does not exist in the registry.\n     */\n    error IDealerRegistry_NonExistingInstrument();\n\n    /**\n     * @notice Thrown when the dealer is not allowed for the specified instrument.\n     */\n    error IDealerRegistry_DealerNotAllowed();\n\n    /**\n     * @notice Emited when a new dealer is added\n     * @param dealerId Id of the new dealer\n     * @param wallet Initial wallet of the dealer\n     */\n    event NewDealerAdded(bytes32 dealerId, address wallet);\n\n    /**\n     * @notice Emited when an dealer's allowed status is updated\n     * @param dealerId Id of the dealer updated\n     * @param allowed Y/N if dealer is allowed for the instrument\n     */\n    event dealerAllowedUpdated(bytes32 dealerId, bytes32 instrumentId, bool allowed);\n\n    /**\n     * @notice Initialize the registry\n     * @param _roleRegistry Address of the role registry\n     */\n    function initialize(\n        IRoleRegistry _roleRegistry,\n        IOperationsEngine _operationsEngine,\n        IInvestorRegistry _investorRegistry,\n        IInstrumentRegistry _instrumentRegistry\n    ) external;\n\n    /**\n     * @notice Adds a new dealer to the registry\n     * @param _senderRole Role of the sender which allows the operation execution\n     * @param _dealerId ID of the dealer\n     * @param _wallet Wallet of the dealer\n     */\n    function addDealer(bytes32 _senderRole, bytes32 _dealerId, address _wallet) external;\n\n    /**\n     * @notice Allows a dealer for a specific instrument\n     * @param _senderRole Role of the sender which allows the operation execution\n     * @param _dealerId ID of the dealer\n     * @param _instrumentId ID of the instrument\n     * @param _allowed Y/N if dealer is allowed for the instrument\n     */\n    function allowDealer(bytes32 _senderRole, bytes32 _dealerId, bytes32 _instrumentId, bool _allowed) external;\n\n    /**\n     * @notice Returns if the dealer is allowed for a specific instrument\n     * @param _dealerId ID of the dealer\n     * @param _instrumentId ID of the instrument\n     * @return Bool indicating if dealer if allowed\n     */\n    function isDealerAllowed(bytes32 _dealerId, bytes32 _instrumentId) external view returns (bool);\n\n    /**\n     * @notice Reverts if the dealer is not allowed for a specific instrument\n     * @param _dealerId ID of the dealer\n     * @param _instrumentId ID of the instrument\n     */\n    function checkDealerAllowed(bytes32 _dealerId, bytes32 _instrumentId) external view;\n}\n"
    },
    "src/interfaces/IOperationsEngine.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {IInvestorRegistry} from \"src/interfaces/IInvestorRegistry.sol\";\nimport {IFundRegistry} from \"src/interfaces/IFundRegistry.sol\";\nimport {IDealerRegistry} from \"src/interfaces/IDealerRegistry.sol\";\nimport {IInstrumentRegistry} from \"src/interfaces/IInstrumentRegistry.sol\";\nimport {IRoleRegistry} from \"src/interfaces/IRoleRegistry.sol\";\nimport {IEternalRegistryStorage} from \"src/interfaces/IEternalRegistryStorage.sol\";\nimport {OPERATIONS} from \"./operations/IOperationModule.sol\";\n\n/**\n * @title Operations Engine Interface\n * @author Libre\n * @notice Defines the interface for managing modules, operations, and dependencies in the system.\n * @dev Includes error definitions, events, and function signatures for interacting with the operations engine.\n */\ninterface IOperationsEngine {\n    // Enums\n    /**\n     * @notice Defines the type of ID for the module check, modules are either tracking ones or check ones.\n     */\n    enum IdType {\n        NULL,\n        INSTRUMENT_CHECK,\n        FEE,\n        TRACKING\n    }\n\n    /**\n     * @notice Defines the type of check a module performs.\n     */\n    enum CHECK_TYPE {\n        BOOLEAN,\n        NUMERIC_MIN,\n        NUMERIC_MAX\n    }\n\n    // Errors\n    /**\n     * @dev Revert when the tracking module reverts for any reason\n     */\n    error IOperationsEngine_TrackingModuleFailure();\n\n    /**\n     * @dev Revert when the fee module reverts for any reason\n     */\n    error IOperationsEngine_FeeModuleFailure();\n\n    /**\n     * @dev Revert when the module address provided is invalid.\n     */\n    error IOperationsEngine_InvalidModuleAddress();\n\n    /**\n     * @dev Revert when the module is not of the Libre type.\n     */\n    error IOperationsEngine_ModuleIsNotLibreType();\n\n    /**\n     * @dev Revert when a lending module cannot be disabled.\n     */\n    error IOperationsEngine_LendingModuleDisable();\n\n    /**\n     * @dev Revert when dependencies required for an operation are missing.\n     */\n    error IOperationsEngine_MissingDependencies();\n\n    /**\n     * @dev Revert when an invalid check type is used.\n     */\n    error IOperationsEngine_InvalidCheckType();\n\n    /**\n     * @dev Revert when the caller is not authorized to perform the action.\n     */\n    error IOperationsEngine_CallerNotAuthorized();\n\n    /**\n     * @dev Revert when adding a module that is already been added.\n     */\n    error IOperationsEngine_ModuleAlreadyAdded();\n\n    /**\n     * @dev Revert when module already enabled for the same instrument.\n     */\n    error IOperationsEngine_ModuleAlreadyEnabled();\n\n    /**\n     * @dev Revert when a module to be disabled for an instrument is not enabled\n     */\n    error IOperationsEngine_ModuleNotEnabled();\n\n    // Events\n    /**\n     * @notice Emitted when a module is added to the available modules library.\n     * @param moduleAddress Address of the module that was added.\n     */\n    event ModuleAdded(address indexed moduleAddress);\n\n    /**\n     * @notice Emitted when a module is removed from the available modules library.\n     * @param moduleAddress Address of the module that was removed.\n     */\n    event ModuleRemoved(address indexed moduleAddress);\n\n    /**\n     * @notice Emitted when a module is enabled for a specific instrument.\n     * @param moduleAddress Address of the module that was enabled.\n     * @param instrumentId Id of the instrument for which the module was enabled.\n     */\n    event ModuleEnabled(address indexed moduleAddress, bytes32 instrumentId);\n\n    /**\n     * @notice Emitted when a module is disabled for a specific instrument.\n     * @param moduleAddress Address of the module that was disabled.\n     * @param instrumentId Id of the instrument for which the module was disabled.\n     */\n    event ModuleDisabled(address indexed moduleAddress, bytes32 instrumentId);\n\n    /**\n     * @dev Event emitted when a fee is applied.\n     * @param instrumentId The ID of the instrument.\n     * @param orderId The ID of the order.\n     * @param feeModule The address of the fee module.\n     * @param feeAmount The amount of the fee applied.\n     */\n    event FeeApplied(bytes32 indexed instrumentId, uint256 orderId, address feeModule, uint256 feeAmount);\n\n    //functions\n\n    /**\n     * @notice Initializes the Rules Engine with necessary registries.\n     * @param _investorRegistry Address of the Investor Registry.\n     * @param _dealerRegistry Address of the Dealer Registry.\n     * @param _fundRegistry Address of the Fund Registry.\n     * @param _instrumentRegistry Address of the Instrument Registry.\n     * @param _roleRegistry Address of the Role Registry.\n     * @param _jurisdictionRegistry Address of the Jurisdiction Registry.\n     */\n    function initialize(\n        IInvestorRegistry _investorRegistry,\n        IDealerRegistry _dealerRegistry,\n        IFundRegistry _fundRegistry,\n        IInstrumentRegistry _instrumentRegistry,\n        IRoleRegistry _roleRegistry,\n        IEternalRegistryStorage _jurisdictionRegistry\n    ) external;\n\n    /**\n     * @notice Gets the addresses for registered check modules implementing the given operation.\n     * @param _id Id of the dealer or instrument the modules belong to.\n     * @param _operation Operation implemented in modules.\n     * @return An array of addresses of modules implementing the given operation.\n     */\n    function getCheckModules(bytes32 _id, OPERATIONS _operation) external view returns (address[] memory);\n\n    /**\n     * @notice Gets the addresses for registered fee modules implementing the given operation.\n     * @param _id Id of the dealer or instrument the modules belong to.\n     * @param _operation Operation implemented in modules.\n     * @return An array of addresses of modules implementing the given operation.\n     */\n    function getFeeModules(bytes32 _id, OPERATIONS _operation) external view returns (address[] memory);\n\n    /**\n     * @notice Gets the addresses for registered tracking modules implementing the given operation.\n     * @param _id Id of the dealer or instrument the modules belong to.\n     * @param _operation Operation implemented in modules.\n     * @return An array of addresses of modules implementing the given operation.\n     */\n    function getTrackingModules(bytes32 _id, OPERATIONS _operation) external view returns (address[] memory);\n\n    /**\n     * @notice Adds a module to the available modules library.\n     * @param _moduleAddress Address of the module to add.\n     * @param _role Role required to add the module.\n     * @param _idType Type of the module.\n     */\n    function addModule(address _moduleAddress, bytes32 _role, IdType _idType) external;\n\n    /**\n     * @notice Removes a module from the available modules library.\n     * @param _moduleAddress Address of the module to remove.\n     * @param _role Role required to remove the module.\n     */\n    function removeModule(address _moduleAddress, bytes32 _role) external;\n\n    /**\n     * @notice Enables a module for a specific instrument.\n     * @param _moduleAddress Address of the module to enable.\n     * @param _instrumentId Id of the instrument.\n     * @param _role Role required to enable the module.\n     */\n    function enableModule(address _moduleAddress, bytes32 _instrumentId, bytes32 _role) external;\n\n    /**\n     * @notice Disables a module for a specific instrument.\n     * @param _moduleAddress Address of the module to disable.\n     * @param _instrumentId Id of the instrument.\n     * @param _role Role required to disable the module.\n     * @dev Lending modules cannot be disabled, because at least one module must be enabled at all times.\n     * Instead, the lending module can be replaced with another lending module by enabling the new module.\n     */\n    function disableModule(address _moduleAddress, bytes32 _instrumentId, bytes32 _role) external;\n\n    /**\n     * @notice Checks if a module is available in the available modules library.\n     * @param _moduleAddress Address of the module to check.\n     * @return True if the module is available, false otherwise.\n     */\n    function isAvailableModule(address _moduleAddress) external view returns (bool);\n\n    /**\n     * @notice Checks if a module is enabled for a specific instrument.\n     * @param _id Id of the instrument.\n     * @param _moduleName Hash of the abi.encodePacked of the module name\n     * @return True if the module is enabled, false otherwise.\n     */\n    function hasModuleEnabled(bytes32 _id, bytes32 _moduleName) external view returns (bool);\n\n    /**\n     * @notice Function to be delegatecalled by the registry to perform the check\n     * @param _operation The operation to be checked\n     * @param _id The id of the operation\n     * @param _data Arbitrary data that can be used by the module to perform the check\n     * @return result memory Result of the check\n     */\n    function check(OPERATIONS _operation, bytes32 _id, bytes calldata _data) external returns (bytes memory result);\n\n    /**\n     * @notice Tracks the operation\n     * @param _operation The operation to track\n     * @param _id The id of the instrument or investor\n     * @param _data The data to track\n     * @return True if the tracking was successful, false otherwise\n     */\n    function track(OPERATIONS _operation, bytes32 _id, bytes memory _data) external returns (bool);\n\n    /**\n     * @notice Calculates the total fee amount to be deducted for a given operation and instrument.\n     * @dev Loops through all enabled fee modules for the given operation and instrument, calls them with the input data,\n     *      and sums up the returned fee amounts. Also emits `FeeApplied` events for each individual module fee.\n     *\n     * @param _operation The operation type (e.g., SETTLE_SUBSCRIPTION_PER_ORDER).\n     * @param _id The instrument ID for which the fees are being calculated.\n     * @param _data ABI-encoded parameters required for fee calculation. Must encode the following values in order:\n     *        - `uint256 _orderId`: Unique identifier of the order\n     *        - `bytes32 _investorId`: The ID of the investor associated with the order\n     *        - `uint256 _amountToSettle`: The current amount to be settled\n     *\n     * @return totalFee The total fee amount to be deducted across all enabled fee modules.\n     */\n    function calculateFees(OPERATIONS _operation, bytes32 _id, bytes memory _data)\n        external\n        returns (uint256 totalFee);\n}\n"
    },
    "src/interfaces/IUserRegistry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title IUserRegistry\n * @author Libre\n * @notice Interface for managing user wallets and their association with investor/dealer IDs.\n * @dev Provides functions for adding wallets, retrieving wallets, and mapping wallets to user IDs.\n */\ninterface IUserRegistry {\n    /**\n     * @notice Thrown when the wallet address being added is already associated with another user ID.\n     */\n    error IUserRegistry_WalletAlreadyClaimed();\n\n    /**\n     * @notice Thrown when the provided signature fails to verify ownership of the wallet address.\n     */\n    error IUserRegistry_WalletOwnershipVerificationFailure();\n\n    /**\n     * @notice Thrown when the provided wallet signature has expired.\n     */\n    error IUserRegistry_WalletSignatureExpired();\n\n    /**\n     * @notice Thrown when the provided wallet address to add is blacklisted.\n     */\n    error IUserRegistry_WalletBlacklisted();\n\n    /**\n     * @notice Emited when secondary wallet is removed\n     * @param wallet User wallet address\n     */\n    event WalletAdded(address indexed wallet);\n\n    /**\n     * @notice Emited when secondary wallet is removed\n     * @param wallet User wallet address\n     */\n    event WalletRemoved(address indexed wallet);\n\n    /**\n     * @notice Adds a new investor to the registry\n     * @param _userId The ID of the user.\n     * @param _wallet The wallet address to associate with the user ID.\n     * @param _role The role used by the caller.\n     */\n    function addWallet(bytes32 _userId, address _wallet, bytes32 _role) external;\n\n    /**\n     * @notice Removes a wallet from the registry\n     * @param _wallet The wallet address to remove.\n     * @param _role The role used by the caller.\n     * @return The user ID that the wallet was removed from\n     */\n    function removeWallet(address _wallet, bytes32 _role) external returns (bytes32);\n\n    /**\n     * @notice Get Investor/Dealer array of wallets\n     * @param _userId Investor/Dealer ID\n     */\n    function getWallets(bytes32 _userId) external view returns (address[] memory);\n\n    /**\n     * @notice Get Investor/Dealer ID\n     * @param _wallet Investor/Dealer address\n     */\n    function getIdFromWallet(address _wallet) external view returns (bytes32);\n}\n"
    },
    "src/interfaces/IGatewayManager.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {IInvestorRegistry} from \"src/interfaces/IInvestorRegistry.sol\";\nimport {IRoleRegistry} from \"src/interfaces/IRoleRegistry.sol\";\nimport {ILibreCoreGateway} from \"src/interfaces/ILibreCoreGateway.sol\";\nimport {IEAS} from \"eas-contracts/IEAS.sol\";\n\n/**\n * @title IGatewayManager Interface\n * @notice Interface for managing cross-chain addresses and investor chain preferences\n * @dev Coordinates with LibreCoreGateway for cross-chain operations\n */\ninterface IGatewayManager {\n    /**\n     * @notice Emitted when an investor's preferred chains are updated or set\n     * @param investorId The unique identifier of the investor\n     * @param chains Array of custom chain IDs that the investor prefers\n     * @param oldChains Previous array of chain IDs for the investor\n     */\n    event InvestorChainsUpdated(bytes32 investorId, uint16[] chains, uint16[] oldChains);\n\n    /**\n     * @notice Emitted when cross-chain addresses are updated for an investor\n     * @dev Each address change is encoded as: [1 byte action][2 bytes chainSelector][n bytes address]\n     * @param investorId The unique identifier of the investor\n     * @param addressChanges A list of concatenated bytes describing a change in multi-chain address\n     */\n    event InvestorAddressesUpdated(bytes32 investorId, bytes[] addressChanges);\n\n    /// @notice Thrown when an unsupported or invalid chain ID is provided\n    error GatewayManager_InvalidChain();\n\n    /// @notice Thrown when the investor ID doesn't exist or is invalid\n    error GatewayManager_InvalidInvestor();\n\n    /// @notice Thrown when input parameters are invalid or missing\n    error GatewayManager_InvalidInput();\n\n    /// @notice Thrown when a cross-chain address is already associated with another investor\n    error GatewayManager_AddressAlreadyUsed();\n\n    /**\n     * @notice Initializes the gateway manager\n     * @param _coreGateway Address of the LibreCoreGateway contract\n     * @param _eas Address of the Ethereum Attestation Service\n     * @param _investorRegistry Address of the InvestorRegistry contract\n     * @param _roleRegistry Address of the RoleRegistry contract\n     */\n    function initialize(\n        ILibreCoreGateway _coreGateway,\n        IEAS _eas,\n        IInvestorRegistry _investorRegistry,\n        IRoleRegistry _roleRegistry\n    ) external;\n\n    /**\n     * @notice Sets the preferred chains for an investor\n     * @param _senderRole Role of the transaction sender\n     * @param _investorId Unique identifier of the investor\n     * @param _chains Array of chain IDs to set as preferred\n     */\n    function setInvestorChains(bytes32 _senderRole, bytes32 _investorId, uint16[] calldata _chains) external;\n\n    /**\n     * @notice Updates investor's cross-chain addresses and propagates changes to other chains\n     * @dev Adds or removes addresses and bridges the updates to other chains\n     * @param _senderRole Role of the transaction sender\n     * @param _investorId Unique identifier of the investor\n     * @param _addressChanges A list of concatenated bytes describing a change in multi-chain address\n     */\n    function manageCrossChainAddresses(bytes32 _senderRole, bytes32 _investorId, bytes[] calldata _addressChanges)\n        external;\n\n    /**\n     * @notice Bridges a credential to all investor's preferred chains via core gateway.\n     * @param _attestationId The unique ID of the attestation to be bridged.\n     * @param _senderRole Role of the transaction sender.\n     * @param _chains Chains to bridge credential to (all investor chains if empty)\n     */\n    function bridgeCredential(bytes32 _attestationId, bytes32 _senderRole, uint16[] memory _chains) external;\n\n    /**\n     * @notice Validates if an address is a valid cross-chain address for an investor\n     * @param _investorId The investor ID to check\n     * @param _chainSelector The chain ID to check\n     * @param _address The address to validate\n     * @return bool True if the address is valid for the investor on the chain\n     */\n    function isValidCrossChainAddress(bytes32 _investorId, uint16 _chainSelector, bytes calldata _address)\n        external\n        view\n        returns (bool);\n\n    /**\n     * @notice Gets an investor's preferred chains\n     * @param _investorId The investor's unique identifier\n     * @return uint16[] Array of preferred chain IDs\n     */\n    function getInvestorChains(bytes32 _investorId) external view returns (uint16[] memory);\n\n    /**\n     * @notice Gets the owner of a cross-chain address\n     * @param _chainSelector The chain ID of the address\n     * @param _address The address to get the owner of\n     * @return bytes32 The owner of the address\n     */\n    function getAddressOwner(uint16 _chainSelector, bytes calldata _address) external view returns (bytes32);\n}\n"
    },
    "src/interfaces/IEternalRegistryStorage.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title IEternalRegistryStorage\n * @notice Interface for managing a flexible and extensible storage system, allowing various types of values to be\n * stored and retrieved for specific registry entries. Provides a robust and modular way to interact with registry data.\n * @dev Enables storage and retrieval of multiple data types (e.g., uint256, address, string, bool, bytes32) and\n * supports operations like batch updates, array manipulations, and role-based access control for data modifications.\n */\ninterface IEternalRegistryStorage {\n    /**\n     * @notice Thrown when attempting to modify a key that has been restricted.\n     */\n    error IEternalRegistryStorage_AttemptToSetARestrictedKey();\n\n    /**\n     * @notice Thrown when the length of the provided input arrays does not match.\n     */\n    error IEternalRegistryStorage_BatchLengthMismatch();\n\n    /**\n     * @notice Thrown when attempting to access an array index that is out of bounds.\n     */\n    error IEternalRegistryStorage_IndexShouldBeLessThanLengthOfTheArray();\n\n    /**\n     * @notice Emitted when a boolean value is added to the registry.\n     * @param id The identifier of the registry entry.\n     * @param key The key associated with the boolean value.\n     * @param value The boolean value added to the registry.\n     */\n    event AddedBool(bytes32 indexed id, bytes32 indexed key, bool value);\n\n    /**\n     * @notice Emitted when a uint256 value is added to the registry.\n     * @param id The identifier of the registry entry.\n     * @param key The key associated with the uint256 value.\n     * @param value The uint256 value added to the registry.\n     */\n    event AddedUint(bytes32 indexed id, bytes32 indexed key, uint256 value);\n\n    /**\n     * @notice Emitted when an address value is added to the registry.\n     * @param id The identifier of the registry entry.\n     * @param key The key associated with the address value.\n     * @param value The address value added to the registry.\n     */\n    event AddedAddress(bytes32 indexed id, bytes32 indexed key, address value);\n\n    /**\n     * @notice Emitted when a string value is added to the registry.\n     * @param id The identifier of the registry entry.\n     * @param key The key associated with the string value.\n     * @param value The string value added to the registry.\n     */\n    event AddedString(bytes32 indexed id, bytes32 indexed key, string value);\n\n    /**\n     * @notice Emitted when a bytes32 value is added to the registry.\n     * @param id The identifier of the registry entry.\n     * @param key The key associated with the bytes32 value.\n     * @param value The bytes32 value added to the registry.\n     */\n    event AddedBytes(bytes32 indexed id, bytes32 indexed key, bytes32 value);\n\n    /**\n     * @notice Emitted every time a key is restricted from being set\n     * for an specific entry\n     * @param _id Id of the entry where the key is restricted\n     * @param _key Key being restricted\n     */\n    event KeyRestricted(bytes32 indexed _id, bytes32 indexed _key);\n\n    /**\n     * @notice Get a boolean value from the storage\n     * @param _id Id of the registry entry to get the value from\n     * @param _key Key identifying the value to get\n     * @return bool value of the element associated to the key\n     * in the requested registry entry\n     */\n    function getBool(bytes32 _id, bytes32 _key) external view returns (bool);\n\n    /**\n     * @notice Get a uint256 value from the storage\n     * @param _id Id of the registry entry to get the value from\n     * @param _key Key identifying the value to get\n     * @return uint256 value of the element associated to the key\n     * in the requested registry entry\n     */\n    function getUint(bytes32 _id, bytes32 _key) external view returns (uint256);\n\n    /**\n     * @notice Get an address value from the storage\n     * @param _id Id of the registry entry to get the value from\n     * @param _key Key identifying the value to get\n     * @return address value of the element associated to the key\n     * in the requested registry entry\n     */\n    function getAddress(bytes32 _id, bytes32 _key) external view returns (address);\n\n    /**\n     * @notice Get a string value from the storage\n     * @param _id Id of the registry entry to get the value from\n     * @param _key Key identifying the value to get\n     * @return string value of the element associated to the key\n     * in the requested registry entry\n     */\n    function getString(bytes32 _id, bytes32 _key) external view returns (string memory);\n\n    /**\n     * @notice Get a bytes value from the storage\n     * @param _id Id of the registry entry to get the value from\n     * @param _key Key identifying the value to get\n     * @return bytes value of the element associated to the key\n     * in the requested registry entry\n     */\n    function getBytes(bytes32 _id, bytes32 _key) external view returns (bytes32);\n\n    /**\n     * @notice Set a boolean value on the storage\n     * @param _id Id of the registry entry to set the value on\n     * @param _key Key identifying the value to set\n     * @param _value Value to set\n     * @param _senderRole Role of the sender allowing the operation\n     */\n    function setBool(bytes32 _id, bytes32 _key, bool _value, bytes32 _senderRole) external;\n\n    /**\n     * @notice Set a uint256 value on the storage\n     * @param _id Id of the registry entry to set the value on\n     * @param _key Key identifying the value to set\n     * @param _value Value to set\n     * @param _senderRole Role of the sender allowing the operation\n     */\n    function setUint(bytes32 _id, bytes32 _key, uint256 _value, bytes32 _senderRole) external;\n\n    /**\n     * @notice Set an address value on the storage\n     * @param _id Id of the registry entry to set the value on\n     * @param _key Key identifying the value to set\n     * @param _value Value to set\n     * @param _senderRole Role of the sender allowing the operation\n     */\n    function setAddress(bytes32 _id, bytes32 _key, address _value, bytes32 _senderRole) external;\n\n    /**\n     * @notice Set a string value on the storage\n     * @param _id Id of the registry entry to set the value on\n     * @param _key Key identifying the value to set\n     * @param _value Value to set\n     * @param _senderRole Role of the sender allowing the operation\n     */\n    function setString(bytes32 _id, bytes32 _key, string calldata _value, bytes32 _senderRole) external;\n\n    /**\n     * @notice Set a bytes value on the storage\n     * @param _id Id of the registry entry to set the value on\n     * @param _key Key identifying the value to set\n     * @param _value Value to set\n     * @param _senderRole Role of the sender allowing the operation\n     */\n    function setBytes(bytes32 _id, bytes32 _key, bytes32 _value, bytes32 _senderRole) external;\n\n    /**\n     * @notice Set multiple values in one transaction\n     * @param _ids Ids associated to the values to set\n     * @param _keys Key associated to the values to set\n     * @param _boolValues Bool values to set\n     * @param _uintValues Uint256 values to set\n     * @param _addressValues Address values to set\n     * @param _stringValues String values to set\n     * @param _bytesValues Bytes32 values to set\n     * @param _senderRole Role of the sender allowing the operation\n     */\n    function setBatch(\n        bytes32[] memory _ids,\n        bytes32[] memory _keys,\n        bool[] memory _boolValues,\n        uint256[] memory _uintValues,\n        address[] memory _addressValues,\n        string[] memory _stringValues,\n        bytes32[] memory _bytesValues,\n        bytes32 _senderRole\n    ) external;\n\n    /**\n     * @notice Get multiple values in one transaction\n     * @param _ids Ids associated to the values to get\n     * @param _keys Keys associated to the values to get\n     * @param _boolCount Number of bool values to get\n     * @param _uintCount Number of uint256 values to get\n     * @param _addressCount Number of address values to get\n     * @param _stringCount Number of string values to get\n     * @param _bytesCount Number of bytes32 values to get\n     * @return _boolValues Bool values return array\n     * @return _uintValues Uint256 values return array\n     * @return _addressValues Address values return array\n     * @return _stringValues String values return array\n     * @return _bytesValues Bytes32 values return array\n     */\n    function getBatch(\n        bytes32[] memory _ids,\n        bytes32[] memory _keys,\n        uint256 _boolCount,\n        uint256 _uintCount,\n        uint256 _addressCount,\n        uint256 _stringCount,\n        uint256 _bytesCount\n    )\n        external\n        view\n        returns (\n            bool[] memory _boolValues,\n            uint256[] memory _uintValues,\n            address[] memory _addressValues,\n            string[] memory _stringValues,\n            bytes32[] memory _bytesValues\n        );\n}\n"
    },
    "src/utils/JurisdictionEncodings.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n//The encodings used for jurisdictions are based and ordered after the ISO 3166 standard as of 2023/11/28\n//(https://en.wikipedia.org/wiki/List_of_ISO_3166_country_codes)\n//Any new additions after this date will be added at the end as to not modify existing encodings\n//allowed values are in the range of: 2^x, 0  x  255\nuint256 constant AF = 2 ** 0;\nuint256 constant AX = 2 ** 1;\nuint256 constant AL = 2 ** 2;\nuint256 constant DZ = 2 ** 3;\nuint256 constant AS = 2 ** 4;\nuint256 constant AD = 2 ** 5;\nuint256 constant AO = 2 ** 6;\nuint256 constant AI = 2 ** 7;\nuint256 constant AQ = 2 ** 8;\nuint256 constant AG = 2 ** 9;\nuint256 constant AR = 2 ** 10;\nuint256 constant AM = 2 ** 11;\nuint256 constant AW = 2 ** 12;\nuint256 constant AU = 2 ** 13;\nuint256 constant AT = 2 ** 14;\nuint256 constant AZ = 2 ** 15;\nuint256 constant BS = 2 ** 16;\nuint256 constant BH = 2 ** 17;\nuint256 constant BD = 2 ** 18;\nuint256 constant BB = 2 ** 19;\nuint256 constant BY = 2 ** 20;\nuint256 constant BE = 2 ** 21;\nuint256 constant BZ = 2 ** 22;\nuint256 constant BJ = 2 ** 23;\nuint256 constant BM = 2 ** 24;\nuint256 constant BT = 2 ** 25;\nuint256 constant BO = 2 ** 26;\nuint256 constant BQ = 2 ** 27;\nuint256 constant BA = 2 ** 28;\nuint256 constant BW = 2 ** 29;\nuint256 constant BV = 2 ** 30;\nuint256 constant BR = 2 ** 31;\nuint256 constant IO = 2 ** 32;\nuint256 constant BN = 2 ** 33;\nuint256 constant BG = 2 ** 34;\nuint256 constant BF = 2 ** 35;\nuint256 constant BI = 2 ** 36;\nuint256 constant CV = 2 ** 37;\nuint256 constant KH = 2 ** 38;\nuint256 constant CM = 2 ** 39;\nuint256 constant CA = 2 ** 40;\nuint256 constant KY = 2 ** 41;\nuint256 constant CF = 2 ** 42;\nuint256 constant TD = 2 ** 43;\nuint256 constant CL = 2 ** 44;\nuint256 constant CN = 2 ** 45;\nuint256 constant CX = 2 ** 46;\nuint256 constant CC = 2 ** 47;\nuint256 constant CO = 2 ** 48;\nuint256 constant KM = 2 ** 49;\nuint256 constant CD = 2 ** 50;\nuint256 constant CG = 2 ** 51;\nuint256 constant CK = 2 ** 52;\nuint256 constant CR = 2 ** 53;\nuint256 constant CI = 2 ** 54;\nuint256 constant HR = 2 ** 55;\nuint256 constant CU = 2 ** 56;\nuint256 constant CW = 2 ** 57;\nuint256 constant CY = 2 ** 58;\nuint256 constant CZ = 2 ** 59;\nuint256 constant DK = 2 ** 60;\nuint256 constant DJ = 2 ** 61;\nuint256 constant DM = 2 ** 62;\nuint256 constant DO = 2 ** 63;\nuint256 constant EC = 2 ** 64;\nuint256 constant EG = 2 ** 65;\nuint256 constant SV = 2 ** 66;\nuint256 constant GQ = 2 ** 67;\nuint256 constant ER = 2 ** 68;\nuint256 constant EE = 2 ** 69;\nuint256 constant SZ = 2 ** 70;\nuint256 constant ET = 2 ** 71;\nuint256 constant FK = 2 ** 72;\nuint256 constant FO = 2 ** 73;\nuint256 constant FJ = 2 ** 74;\nuint256 constant FI = 2 ** 75;\nuint256 constant FR = 2 ** 76;\nuint256 constant GF = 2 ** 77;\nuint256 constant PF = 2 ** 78;\nuint256 constant TF = 2 ** 79;\nuint256 constant GA = 2 ** 80;\nuint256 constant GM = 2 ** 81;\nuint256 constant GE = 2 ** 82;\nuint256 constant DE = 2 ** 83;\nuint256 constant GH = 2 ** 84;\nuint256 constant GI = 2 ** 85;\nuint256 constant GR = 2 ** 86;\nuint256 constant GL = 2 ** 87;\nuint256 constant GD = 2 ** 88;\nuint256 constant GP = 2 ** 89;\nuint256 constant GU = 2 ** 90;\nuint256 constant GT = 2 ** 91;\nuint256 constant GG = 2 ** 92;\nuint256 constant GN = 2 ** 93;\nuint256 constant GW = 2 ** 94;\nuint256 constant GY = 2 ** 95;\nuint256 constant HT = 2 ** 96;\nuint256 constant HM = 2 ** 97;\nuint256 constant VA = 2 ** 98;\nuint256 constant HN = 2 ** 99;\nuint256 constant HK = 2 ** 100;\nuint256 constant HU = 2 ** 101;\nuint256 constant IS = 2 ** 102;\nuint256 constant IN = 2 ** 103;\nuint256 constant ID = 2 ** 104;\nuint256 constant IR = 2 ** 105;\nuint256 constant IQ = 2 ** 106;\nuint256 constant IE = 2 ** 107;\nuint256 constant IM = 2 ** 108;\nuint256 constant IL = 2 ** 109;\nuint256 constant IT = 2 ** 110;\nuint256 constant JM = 2 ** 111;\nuint256 constant JP = 2 ** 112;\nuint256 constant JE = 2 ** 113;\nuint256 constant JO = 2 ** 114;\nuint256 constant KZ = 2 ** 115;\nuint256 constant KE = 2 ** 116;\nuint256 constant KI = 2 ** 117;\nuint256 constant KP = 2 ** 118;\nuint256 constant KR = 2 ** 119;\nuint256 constant KW = 2 ** 120;\nuint256 constant KG = 2 ** 121;\nuint256 constant LA = 2 ** 122;\nuint256 constant LV = 2 ** 123;\nuint256 constant LB = 2 ** 124;\nuint256 constant LS = 2 ** 125;\nuint256 constant LR = 2 ** 126;\nuint256 constant LY = 2 ** 127;\nuint256 constant LI = 2 ** 128;\nuint256 constant LT = 2 ** 129;\nuint256 constant LU = 2 ** 130;\nuint256 constant MO = 2 ** 131;\nuint256 constant MK = 2 ** 132;\nuint256 constant MG = 2 ** 133;\nuint256 constant MW = 2 ** 134;\nuint256 constant MY = 2 ** 135;\nuint256 constant MV = 2 ** 136;\nuint256 constant ML = 2 ** 137;\nuint256 constant MT = 2 ** 138;\nuint256 constant MH = 2 ** 139;\nuint256 constant MQ = 2 ** 140;\nuint256 constant MR = 2 ** 141;\nuint256 constant MU = 2 ** 142;\nuint256 constant YT = 2 ** 143;\nuint256 constant MX = 2 ** 144;\nuint256 constant FM = 2 ** 145;\nuint256 constant MD = 2 ** 146;\nuint256 constant MC = 2 ** 147;\nuint256 constant MN = 2 ** 148;\nuint256 constant ME = 2 ** 149;\nuint256 constant MS = 2 ** 150;\nuint256 constant MA = 2 ** 151;\nuint256 constant MZ = 2 ** 152;\nuint256 constant MM = 2 ** 153;\nuint256 constant NA = 2 ** 154;\nuint256 constant NR = 2 ** 155;\nuint256 constant NP = 2 ** 156;\nuint256 constant NL = 2 ** 157;\nuint256 constant NC = 2 ** 158;\nuint256 constant NZ = 2 ** 159;\nuint256 constant NI = 2 ** 160;\nuint256 constant NE = 2 ** 161;\nuint256 constant NG = 2 ** 162;\nuint256 constant NU = 2 ** 163;\nuint256 constant NF = 2 ** 164;\nuint256 constant MP = 2 ** 165;\nuint256 constant NO = 2 ** 166;\nuint256 constant OM = 2 ** 167;\nuint256 constant PK = 2 ** 168;\nuint256 constant PW = 2 ** 169;\nuint256 constant PS = 2 ** 170;\nuint256 constant PA = 2 ** 171;\nuint256 constant PG = 2 ** 172;\nuint256 constant PY = 2 ** 173;\nuint256 constant PE = 2 ** 174;\nuint256 constant PH = 2 ** 175;\nuint256 constant PN = 2 ** 176;\nuint256 constant PL = 2 ** 177;\nuint256 constant PT = 2 ** 178;\nuint256 constant PR = 2 ** 179;\nuint256 constant QA = 2 ** 180;\nuint256 constant RE = 2 ** 181;\nuint256 constant RO = 2 ** 182;\nuint256 constant RU = 2 ** 183;\nuint256 constant RW = 2 ** 184;\nuint256 constant BL = 2 ** 185;\nuint256 constant SH = 2 ** 186;\nuint256 constant KN = 2 ** 187;\nuint256 constant LC = 2 ** 188;\nuint256 constant MF = 2 ** 189;\nuint256 constant PM = 2 ** 190;\nuint256 constant VC = 2 ** 191;\nuint256 constant WS = 2 ** 192;\nuint256 constant SM = 2 ** 193;\nuint256 constant ST = 2 ** 194;\nuint256 constant SA = 2 ** 195;\nuint256 constant SN = 2 ** 196;\nuint256 constant RS = 2 ** 197;\nuint256 constant SC = 2 ** 198;\nuint256 constant SL = 2 ** 199;\nuint256 constant SG = 2 ** 200;\nuint256 constant SX = 2 ** 201;\nuint256 constant SK = 2 ** 202;\nuint256 constant SI = 2 ** 203;\nuint256 constant SB = 2 ** 204;\nuint256 constant SO = 2 ** 205;\nuint256 constant ZA = 2 ** 206;\nuint256 constant GS = 2 ** 207;\nuint256 constant SS = 2 ** 208;\nuint256 constant ES = 2 ** 209;\nuint256 constant LK = 2 ** 210;\nuint256 constant SD = 2 ** 211;\nuint256 constant SR = 2 ** 212;\nuint256 constant SJ = 2 ** 213;\nuint256 constant SE = 2 ** 214;\nuint256 constant CH = 2 ** 215;\nuint256 constant SY = 2 ** 216;\nuint256 constant TW = 2 ** 217;\nuint256 constant TJ = 2 ** 218;\nuint256 constant TZ = 2 ** 219;\nuint256 constant TH = 2 ** 220;\nuint256 constant TL = 2 ** 221;\nuint256 constant TG = 2 ** 222;\nuint256 constant TK = 2 ** 223;\nuint256 constant TO = 2 ** 224;\nuint256 constant TT = 2 ** 225;\nuint256 constant TN = 2 ** 226;\nuint256 constant TR = 2 ** 227;\nuint256 constant TM = 2 ** 228;\nuint256 constant TC = 2 ** 229;\nuint256 constant TV = 2 ** 230;\nuint256 constant UG = 2 ** 231;\nuint256 constant UA = 2 ** 232;\nuint256 constant AE = 2 ** 233;\nuint256 constant GB = 2 ** 234;\nuint256 constant UM = 2 ** 235;\nuint256 constant US = 2 ** 236;\nuint256 constant UY = 2 ** 237;\nuint256 constant UZ = 2 ** 238;\nuint256 constant VU = 2 ** 239;\nuint256 constant VE = 2 ** 240;\nuint256 constant VN = 2 ** 241;\nuint256 constant VG = 2 ** 242;\nuint256 constant VI = 2 ** 243;\nuint256 constant WF = 2 ** 244;\nuint256 constant EH = 2 ** 245;\nuint256 constant YE = 2 ** 246;\nuint256 constant ZM = 2 ** 247;\nuint256 constant ZW = 2 ** 248;\n//values 249-255 reserved for future additions\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\n\npragma solidity ^0.8.19;\n\nimport \"./math/Math.sol\";\nimport \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev The `value` string doesn't fit in the specified `length`.\n     */\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toString(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value)));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "lib/openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.19;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "lib/openzeppelin-contracts-upgradeable/contracts/access/IAccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.19;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControlUpgradeable {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.19;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "src/interfaces/IFundRegistry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {IBaseRegistry} from \"src/interfaces/IBaseRegistry.sol\";\nimport {IRoleRegistry} from \"src/interfaces/IRoleRegistry.sol\";\nimport {IOperationsEngine} from \"src/interfaces/IOperationsEngine.sol\";\n\n/**\n * @title IFundRegistry\n * @author Libre\n * @notice Interface for managing and storing information related to funds within a registry.\n * Provides functionality to initialize the registry, add new funds, and emit events for key actions.\n */\ninterface IFundRegistry is IBaseRegistry {\n    /// @notice Error raised when attempting to register a fund that is already registered.\n    error IFundRegistry_AlreadyRegistered();\n\n    /**\n     * @notice Emited when a new Fund is added\n     * @param fundId Id of the new fund\n     */\n    event NewFundAdded(bytes32 indexed fundId);\n\n    /**\n     * @notice Initialize the registry\n     * @param _roleRegistry Address of the role registry\n     */\n    function initialize(IRoleRegistry _roleRegistry, IOperationsEngine _operationsEngine) external;\n\n    /**\n     * @notice Adds a new fund to the registry\n     * @param _senderRole Role of the sender which allow the operation execution\n     * @param _fundId The ID of the fund\n     */\n    function addNewFund(bytes32 _senderRole, bytes32 _fundId) external;\n}\n"
    },
    "src/interfaces/operations/IOperationModule.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {IInvestorRegistry} from \"src/interfaces/IInvestorRegistry.sol\";\nimport {IFundRegistry} from \"src/interfaces/IFundRegistry.sol\";\nimport {IDealerRegistry} from \"src/interfaces/IDealerRegistry.sol\";\nimport {IInstrumentRegistry} from \"src/interfaces/IInstrumentRegistry.sol\";\nimport {IEternalRegistryStorage} from \"src/interfaces/IEternalRegistryStorage.sol\";\nimport {IRoleRegistry} from \"src/interfaces/IRoleRegistry.sol\";\n\nenum OPERATIONS {\n    // Transfer specific operations:\n    TRANSFER,\n    FORCED_TRANSFER,\n    RECEIVE,\n    SEND,\n    CLAWBACK,\n    // Subscription specific operations:\n    ADVISED_CREATE_SUBSCRIPTION,\n    CREATE_SUBSCRIPTION,\n    SUBSCRIPTION_EXECUTION_DATE_CALCULATION,\n    SETTLE_SUBSCRIPTIONS,\n    SETTLE_SUBSCRIPTION_PER_ORDER,\n    SUBSCRIPTION_CANCELLATION,\n    // Redemption specific operations:\n    ADVISED_CREATE_REDEMPTION,\n    CREATE_REDEMPTION,\n    REDEMPTION_EXECUTION_DATE_CALCULATION,\n    REDEMPTION_CANCELLATION,\n    SETTLE_REDEMPTIONS,\n    SETTLE_REDEMPTION_PER_ORDER,\n    FORCED_REDEMPTION,\n    REDEMPTION_FEE,\n    // Secondary Market specific operations:\n    FILL,\n    ORDER,\n    TRADE,\n    // NAV operations:\n    UPDATE_AUDITED_NAV_PER_SHARE\n}\n\ninterface IOperationModule {\n    /**\n     * @return The list of operations associated with a module\n     * @dev It should contains all the Operation ids of all\n     * the IOperations it implements\n     */\n    function getOperations() external pure returns (OPERATIONS[] memory);\n\n    /**\n     * @return Returns the name of the module\n     */\n    function name() external pure returns (string memory);\n\n    /**\n     * @return Returns the hash of the module name\n     */\n    function nameHash() external pure returns (bytes32);\n}\n"
    },
    "src/interfaces/ILibreCoreGateway.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {IInvestorRegistry} from \"src/interfaces/IInvestorRegistry.sol\";\nimport {IInstrumentRegistry} from \"src/interfaces/IInstrumentRegistry.sol\";\nimport {IRoleRegistry} from \"src/interfaces/IRoleRegistry.sol\";\nimport {IGatewayManager} from \"src/interfaces/IGatewayManager.sol\";\nimport {Attestation} from \"eas-contracts/IEAS.sol\";\n\n/**\n * @notice Structure representing token transfer details across chains\n * @dev Used for both locking and unlocking operations\n */\nstruct TokenTransfer {\n    uint16 chainSelector; // Unique 16-bit Custom Chain ID where the Token is transfered\n    bytes32 instrumentId; // Instrument ID associated with the security token\n    bytes32 investorId; // Investor ID associated with the sender\n    bytes receiver; // Recipient's address for minting/unlocking\n    uint256 amount; // Amount of the asset to transfer\n}\n\n/**\n * @notice Structure for managing investor addresses across specific chain\n * @dev Each address change is encoded as: [1 byte action][n bytes address]\n */\nstruct ChainInvestorAddresses {\n    // Unique investor ID\n    bytes32 investorId;\n    // Unique chain ID\n    uint16 chainSelector;\n    // Address size for that chain\n    uint8 addressSize;\n    // A list of concatenated bytes describing a change in addresses\n    // Format `addressChanges`` := bytes1 action ++ bytes accountAddress\n    // where `action`: 0b0 -> Add, 0b1 -> Remove\n    bytes[] addressChanges;\n}\n\n/// @notice Interface for the Libre Core Gateway.\ninterface ILibreCoreGateway {\n    // Events\n    /**\n     * @notice Emitted when tokens are locked on source chain\n     * @param encodedTransferDetails ABI-encoded TokenTransfer struct\n     */\n    event TokenLockedAndBridged(bytes encodedTransferDetails);\n\n    /**\n     * @notice Emitted when tokens are unlocked on destination chain\n     * @param encodedTransferDetails ABI-encoded TokenTransfer struct\n     */\n    event TokenUnlocked(bytes encodedTransferDetails);\n\n    /**\n     * @notice Emitted when a credential is bridged to other chains\n     * @param investorId Investor ID of the investor\n     * @param chainSelectors Array of investor preffered chains on which credential to be bridged\n     * @param credentialId Unique identifier of the bridged credential\n     */\n    event CredentialBridged(bytes32 investorId, uint16[] chainSelectors, bytes32 credentialId);\n\n    /**\n     * @notice Emitted when investor chain-specific addresses are bridged\n     * @param investorId Investor ID of the investor\n     * @param chainSelectors Array of investor preferred chains on which addresses updates to be bridged\n     * @param encodedChainInvestorAddresses ABI-encoded ChainInvestorAddresses struct\n     */\n    event ChainInvestorAddressesBridged(\n        bytes32 investorId, uint16[] chainSelectors, bytes encodedChainInvestorAddresses\n    );\n\n    /**\n     * @notice Emitted when chain support status is updated\n     * @param chainSelector Chain ID whose support status changed\n     * @param isSupported New support status\n     */\n    event ChainSupportUpdated(uint16 chainSelector, bool isSupported);\n\n    /**\n     * @notice Emitted when chain variable length address support status is updated\n     * @param _chainSelector Chain ID whose support status changed\n     * @param _isVariableLengthAddress New support status\n     */\n    event ChainVariableLengthAddressSupportUpdated(uint16 _chainSelector, bool _isVariableLengthAddress);\n\n    // Custom Errors\n    /// @notice Thrown when operation is attempted on an unsupported chain\n    /// @param chainSelector The unsupported chain ID\n    error CoreGateway_ChainNotSupported(uint16 chainSelector);\n\n    /// @notice Thrown when the chain selector (chain ID) not matches with Native chain ID for unlock requests\n    error CoreGateway_InvalidNativeChainSelector();\n\n    /// @notice Thrown when token address is not found or invalid\n    /// @param token The invalid token address\n    error CoreGateway_TokenAddressNotFound(address token);\n\n    /// @notice Thrown when attempting transfer with zero amount\n    error CoreGateway_ZeroAmount();\n\n    /// @notice Thrown when transfer validation fails\n    error CoreGateway_InvalidTransfer();\n\n    /// @notice Thrown when provided investor id is not found\n    error CoreGateway_InvalidInvestor();\n\n    /// @notice Thrown when wrong inputs are provided\n    error CoreGateway_InvalidInput();\n\n    /// @notice Thrown when credential to be bridged are not stored or mismatches with registry\n    error CoreGateway_InvalidCredential();\n\n    /// @notice Thrown when an attempted status update results in no actual change.\n    error CoreGateway_NoStatusChanged();\n\n    /**\n     * @notice Initializes the gateway contract\n     * @param _instrumentRegistry Address of the Instrument Registry\n     * @param _investorRegistry Address of the Investor Registry\n     * @param _gatewayManager Address of the Gateway Manager\n     * @param _roleRegistry Address of the Role Registry\n     * @param _nativeChainSelector Native Custom Chain ID\n     * @param _supportedChains Array of supported custom chain Ids\n     */\n    function initialize(\n        IInstrumentRegistry _instrumentRegistry,\n        IInvestorRegistry _investorRegistry,\n        IGatewayManager _gatewayManager,\n        IRoleRegistry _roleRegistry,\n        uint16 _nativeChainSelector,\n        uint16[] memory _supportedChains\n    ) external;\n\n    /**\n     * @notice Locks tokens for cross-chain transfer and emits event for minting\n     * @dev Validates investor credentials and cross-chain addresses before locking\n     * @param transferDetails The details of the token transfer.\n     */\n    function lockAndBridge(TokenTransfer calldata transferDetails) external;\n\n    /**\n     * @notice Unlocks tokens on the source chain\n     * @dev Called by bridge operators to release tokens to the recipient\n     * @param _senderRole The role of the caller\n     * @param encodedTransferDetails ABI-encoded transfer details.\n     */\n    function unlock(bytes32 _senderRole, bytes calldata encodedTransferDetails) external;\n\n    /**\n     * @notice Bridges a credential to one or more destination chains.\n     * @dev Perform below steps:\n     *      1. Verifies all destination chains are supported\n     *      2. Validates the attestation matches the stored credential for the investor\n     *      3. Emits CredentialBridged event for cross-chain communication\n     * @param _senderRole The role of the caller\n     * @param attestation The attestation details to bridge.\n     * @param destinationChainSelectors Array of destination chain IDs.\n     */\n    function bridgeCredential(\n        bytes32 _senderRole,\n        Attestation calldata attestation,\n        uint16[] calldata destinationChainSelectors\n    ) external;\n\n    /**\n     * @notice Bridges investor addresses updates.\n     * @dev Processes and broadcasts chain specific address changes across investor preferred chains\n     *         Emits `ChainInvestorAddressesBridged` event for each chain's address updates.\n     *\n     * @param _senderRole The role of the caller.\n     * @param _investorId The unique identifier of the investor whose addresses are being updated.\n     * @param _addressChanges ABI-encoded updates representing address changes per chain or context.\n     * @param chainSelectors Array of investor preferred chains on which addresses updates to be bridged\n     */\n    function bridgeInvestorAddresses(\n        bytes32 _senderRole,\n        bytes32 _investorId,\n        bytes[] calldata _addressChanges,\n        uint16[] calldata chainSelectors\n    ) external;\n\n    /**\n     * @notice Pauses all gateway operations\n     * @param _senderRole The role of the caller\n     */\n    function pause(bytes32 _senderRole) external;\n\n    /**\n     * @notice Unpauses gateway operations\n     * @param _senderRole The role of the caller\n     */\n    function unpause(bytes32 _senderRole) external;\n\n    /**\n     * @notice Enables or disables support for a specific chain.\n     * @param _senderRole The role of the caller\n     * @param chainSelector The Custom chain ID.\n     * @param isSupported Whether the chain is supported.\n     */\n    function setChainSupport(bytes32 _senderRole, uint16 chainSelector, bool isSupported) external;\n\n    /**\n     * @notice Enables or disables support for variable length addresses for a specific chain.\n     * @param _senderRole The role of the caller\n     * @param _chainSelector The Custom chain ID.\n     * @param _isVariableLengthAddress Whether variable length addresses for the chain are supported.\n     */\n    function setChainVariableLengthAddressSupport(\n        bytes32 _senderRole,\n        uint16 _chainSelector,\n        bool _isVariableLengthAddress\n    ) external;\n\n    /**\n     * @notice Retrieves the total amount of a specific instrument/token locked in the gateway.\n     * @param instrumentId The Instrument ID associated with the security token\n     * @return The total amount of the token locked in the gateway\n     */\n    function getLockedBalance(bytes32 instrumentId) external view returns (uint256);\n\n    /**\n     * @notice Checks if a chain is supported.\n     * @param chainSelector The ID of the chain to check.\n     * @return True if the chain is supported, false otherwise.\n     */\n    function isSupportedChain(uint16 chainSelector) external view returns (bool);\n\n    /**\n     * @notice Gets the list of supported chains\n     * @return uint16[] Array of supported chain IDs\n     */\n    function getSupportedChains() external view returns (uint16[] memory);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.19;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Muldiv operation overflow.\n     */\n    error MathOverflowedMulDiv();\n\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v5.0._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v5.0._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v5.0._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v5.0._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v5.0._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            return a / b;\n        }\n\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.19;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.19;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    }
  },
  "settings": {
    "remappings": [
      "BokkyPooBahsDateTimeLibrary/=lib/BokkyPooBahsDateTimeLibrary/",
      "ds-test/=lib/forge-std/lib/ds-test/src/",
      "forge-std/=lib/forge-std/src/",
      "openzeppelin-contracts/=lib/openzeppelin-contracts/",
      "openzeppelin/=lib/openzeppelin-contracts/",
      "@openzeppelin/=lib/openzeppelin-contracts/",
      "openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/",
      "risc0/=lib/risc0-ethereum/contracts/src/",
      "eas-contracts/=lib/eas-contracts/contracts/",
      "safe-contracts/=lib/safe-contracts/contracts/",
      "erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/",
      "risc0-ethereum/=lib/risc0-ethereum/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "metadata": {
      "useLiteralContent": false,
      "bytecodeHash": "ipfs",
      "appendCBOR": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "evmVersion": "cancun",
    "viaIR": false,
    "libraries": {
      "src/lib/SortedLinkedList.sol": {
        "SortedLinkedList": "0x07B879C1bAaeeDe4dbC7383f6342556Ef144b27F"
      },
      "src/lib/TimeOperations.sol": {
        "TimeOperations": "0x852BE1E091189E68cD8721163286172d1e162a5a"
      },
      "src/utils/GatewayUtils.sol": {
        "GatewayUtils": "0xaB8b3a4CDdcf7B83C57880926Ba940F388897D11"
      }
    }
  }
}}