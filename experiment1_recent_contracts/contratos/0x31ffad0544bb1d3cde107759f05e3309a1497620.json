{{
  "language": "Solidity",
  "sources": {
    "contracts/workers/CurveWorker.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Holdings, 2025\npragma solidity ^0.8.23;\n\nimport {IAdapter} from \"@gearbox-protocol/core-v3/contracts/interfaces/base/IAdapter.sol\";\nimport {RouterComponentConfigurator} from \"../helpers/RouterComponentConfigurator.sol\";\n\nimport {ICurvePool} from \"@gearbox-protocol/integrations-v3/contracts/integrations/curve/ICurvePool.sol\";\nimport {ICurvePool2Assets} from \"@gearbox-protocol/integrations-v3/contracts/integrations/curve/ICurvePool_2.sol\";\nimport {ICurvePool3Assets} from \"@gearbox-protocol/integrations-v3/contracts/integrations/curve/ICurvePool_3.sol\";\nimport {ICurvePool4Assets} from \"@gearbox-protocol/integrations-v3/contracts/integrations/curve/ICurvePool_4.sol\";\nimport {ICurvePoolStableNG} from\n    \"@gearbox-protocol/integrations-v3/contracts/integrations/curve/ICurvePool_StableNG.sol\";\nimport {ICurveV1Adapter} from \"@gearbox-protocol/integrations-v3/contracts/interfaces/curve/ICurveV1Adapter.sol\";\n\nimport {MultiCall} from \"../lib/MultiCall.sol\";\nimport {Graph, Vertex, Edge, GraphOps} from \"../data/Graph.sol\";\nimport {AddressList} from \"../helpers/AddressList.sol\";\nimport {IWorkerBase, IWorkerNonLinear} from \"../interfaces/IWorker.sol\";\n\ncontract CurveWorker is IWorkerNonLinear, RouterComponentConfigurator {\n    using AddressList for address[];\n    using GraphOps for Graph;\n\n    enum Action {\n        SWAP,\n        ADD_LIQUIDITY,\n        REMOVE_LIQUIDITY\n    }\n\n    bytes32 public constant override contractType = \"RC::CURVE_V1_WORKER\";\n    uint256 public constant override version = 3_10;\n    bool public constant override isNonLinear = true;\n\n    constructor(address _router) RouterComponentConfigurator(_router) {}\n\n    function getMulticalls(Edge memory edge, Graph memory graph)\n        external\n        pure\n        returns (MultiCall[] memory calls, Graph memory)\n    {\n        (Action action, uint256 i, uint256 j) = abi.decode(edge.extraData, (Action, uint256, uint256));\n        calls = new MultiCall[](1);\n\n        Vertex memory vertex = graph.getVertex(edge.tokenIn);\n        edge = graph.getEdgeById(edge.id);\n\n        if (vertex.balance == edge.amountInTotal) {\n            edge.amountInTotal -= 1;\n        }\n\n        uint256 amount = vertex.balance - edge.amountInTotal;\n\n        if (action == Action.SWAP) {\n            calls[0] = MultiCall({\n                target: edge.adapter,\n                callData: abi.encodeCall(ICurveV1Adapter.exchange_diff, (i, j, amount, 0))\n            });\n        } else if (action == Action.ADD_LIQUIDITY) {\n            calls[0] = MultiCall({\n                target: edge.adapter,\n                callData: abi.encodeCall(ICurveV1Adapter.add_diff_liquidity_one_coin, (amount, i, 0))\n            });\n        } else {\n            calls[0] = MultiCall({\n                target: edge.adapter,\n                callData: abi.encodeCall(ICurveV1Adapter.remove_diff_liquidity_one_coin, (amount, i, 0))\n            });\n        }\n\n        vertex.balance -= edge.amountInTotal;\n        graph.getVertex(edge.tokenOut).balance += edge.amountOutTotal;\n\n        return (calls, graph);\n    }\n\n    function getEdgeAmountOutCurrent(Edge memory edge, Graph memory graph) external view returns (uint256) {\n        if (_hasInputThroughAdapter(edge, graph)) return 0;\n\n        if (_hasOtherActiveEdges(edge, graph)) {\n            return _approximateOutputFromAggregate(edge, graph);\n        } else {\n            return _computeSingleOutput(edge, graph);\n        }\n    }\n\n    function _computeSingleOutput(Edge memory edge, Graph memory) internal view returns (uint256) {\n        (Action action, uint256 i, uint256 j) = abi.decode(edge.extraData, (Action, uint256, uint256));\n\n        uint256 amountOut;\n\n        if (action == Action.SWAP) {\n            amountOut = _calcDy(edge.adapter, i, j, edge.amountInCurrent + edge.amountInTotal);\n        } else if (action == Action.ADD_LIQUIDITY) {\n            (address[] memory coins,) = _getCoins(edge.adapter);\n            uint256[] memory inputAmounts = new uint256[](coins.length);\n            inputAmounts[i] += edge.amountInCurrent + edge.amountInTotal;\n            amountOut = _calcTokenAmount(inputAmounts, edge.adapter, true);\n        } else {\n            amountOut = _calcWithdrawOneCoin(edge.adapter, i, edge.amountInCurrent + edge.amountInTotal);\n        }\n\n        return amountOut < edge.amountOutTotal ? 0 : amountOut - edge.amountOutTotal;\n    }\n\n    function _approximateOutputFromAggregate(Edge memory edge, Graph memory graph) internal view returns (uint256) {\n        (Action action, uint256 i, uint256 j) = abi.decode(edge.extraData, (Action, uint256, uint256));\n\n        if (action == Action.SWAP) {\n            return _approximateSwapAmountOut(edge, graph, i, j);\n        } else if (action == Action.ADD_LIQUIDITY) {\n            (uint256[] memory inputAmounts, uint256[] memory outputAmounts, uint256 deposits, uint256 withdrawals) =\n                _computeInputOutputAmounts(graph, edge.adapter);\n            inputAmounts[i] += edge.amountInCurrent;\n\n            uint256 lpEquivalentInputs = _calcTokenAmount(inputAmounts, edge.adapter, true) + withdrawals;\n            uint256 lpEquivalentOutputs = _calcTokenAmount(outputAmounts, edge.adapter, false) + deposits;\n\n            if (lpEquivalentInputs <= lpEquivalentOutputs) return 0;\n\n            return lpEquivalentInputs - lpEquivalentOutputs;\n        } else {\n            uint256 amountOut = _calcWithdrawOneCoin(edge.adapter, i, edge.amountInCurrent);\n            (uint256[] memory inputAmounts, uint256[] memory outputAmounts, uint256 deposits, uint256 withdrawals) =\n                _computeInputOutputAmounts(graph, edge.adapter);\n            outputAmounts[i] += amountOut;\n\n            uint256 lpEquivalentInputs =\n                _calcTokenAmount(inputAmounts, edge.adapter, true) + withdrawals + edge.amountInCurrent;\n            uint256 lpEquivalentOutputs = _calcTokenAmount(outputAmounts, edge.adapter, false) + deposits;\n\n            if (lpEquivalentOutputs > lpEquivalentInputs) return amountOut;\n\n            amountOut = amountOut + amountOut * (lpEquivalentInputs - lpEquivalentOutputs) / edge.amountInCurrent;\n\n            return amountOut;\n        }\n    }\n\n    function _approximateSwapAmountOut(Edge memory edge, Graph memory graph, uint256 i, uint256 j)\n        internal\n        view\n        returns (uint256)\n    {\n        (uint256[] memory inputAmounts, uint256[] memory outputAmounts, uint256 deposits, uint256 withdrawals) =\n            _computeInputOutputAmounts(graph, edge.adapter);\n        inputAmounts[i] += edge.amountInCurrent;\n\n        uint256 lpEquivalentInputs = _calcTokenAmount(inputAmounts, edge.adapter, true) + withdrawals;\n        uint256 lpEquivalentOutputs = _calcTokenAmount(outputAmounts, edge.adapter, false) + deposits;\n\n        if (lpEquivalentInputs <= lpEquivalentOutputs) return 0;\n\n        uint256 amountOut = _calcWithdrawOneCoin(edge.adapter, j, lpEquivalentInputs - lpEquivalentOutputs);\n\n        outputAmounts[j] += amountOut;\n\n        uint256 lpEquivalentOutputsAfter = _calcTokenAmount(outputAmounts, edge.adapter, false) + deposits;\n\n        if (lpEquivalentOutputsAfter > lpEquivalentInputs) return amountOut;\n\n        amountOut = amountOut\n            + amountOut * (lpEquivalentInputs - lpEquivalentOutputsAfter) / (lpEquivalentInputs - lpEquivalentOutputs);\n\n        return amountOut;\n    }\n\n    /// @dev Calculates `dy`, accounting to different Curve pools having a potentially different interface\n    function _calcDy(address adapter, uint256 i, uint256 j, uint256 dx) internal view returns (uint256) {\n        address pool = IAdapter(adapter).targetContract();\n\n        try ICurvePool(pool).get_dy(i, j, dx) returns (uint256 dy) {\n            return dy;\n        } catch {\n            try ICurvePool(pool).get_dy(int128(int256(i)), int128(int256(j)), dx) returns (uint256 dy) {\n                return dy;\n            } catch {\n                return 0;\n            }\n        }\n    }\n\n    /// @dev Calculates one-coin withdrawal, accounting to different Curve pools having a potentially different interface\n    function _calcWithdrawOneCoin(address adapter, uint256 i, uint256 amount) internal view returns (uint256) {\n        address pool = IAdapter(adapter).targetContract();\n\n        try ICurvePool(pool).calc_withdraw_one_coin(amount, i) returns (uint256 amountOut) {\n            return amountOut;\n        } catch {\n            try ICurvePool(pool).calc_withdraw_one_coin(amount, int128(int256(i))) returns (uint256 amountOut) {\n                return amountOut;\n            } catch {\n                return 0;\n            }\n        }\n    }\n\n    /// @dev Returns whether the current vertex already has a non-zero edge through this adapter.\n    ///      Since all swaps through a Curve adapter can be done in one hop, we can prohibit paths of length > 2\n    ///      to avoid incorrect computation of amounts.\n    function _hasInputThroughAdapter(Edge memory edge, Graph memory graph) internal view returns (bool) {\n        Edge[] memory workerEdges = graph.getWorkerEdges(address(this));\n\n        for (uint256 i = 0; i < workerEdges.length; i++) {\n            if (\n                workerEdges[i].adapter == edge.adapter\n                    && (workerEdges[i].tokenOut == edge.tokenIn || workerEdges[i].tokenIn == edge.tokenOut)\n                    && workerEdges[i].amountOutCurrent > 1\n            ) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /// @dev Returns whether there are other edges through this adapter besides the current one that\n    ///      already have an active path through. If not, we can use basic Curve getters to compute the output.\n    function _hasOtherActiveEdges(Edge memory edge, Graph memory graph) internal view returns (bool) {\n        Edge[] memory workerEdges = graph.getWorkerEdges(address(this));\n\n        for (uint256 i = 0; i < workerEdges.length; i++) {\n            if (\n                workerEdges[i].adapter == edge.adapter\n                    && (workerEdges[i].tokenIn != edge.tokenIn || workerEdges[i].tokenOut != edge.tokenOut)\n                    && workerEdges[i].amountInTotal > 1\n            ) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    function _computeInputOutputAmounts(Graph memory graph, address adapter)\n        internal\n        view\n        returns (uint256[] memory inputAmounts, uint256[] memory outputAmounts, uint256 deposits, uint256 withdrawals)\n    {\n        Edge[] memory workerEdges = graph.getWorkerEdges(address(this));\n\n        (address[] memory coins, address lpToken) = _getCoins(adapter);\n        inputAmounts = new uint256[](coins.length);\n        outputAmounts = new uint256[](coins.length);\n\n        for (uint256 i = 0; i < coins.length; ++i) {\n            for (uint256 j = 0; j < workerEdges.length; ++j) {\n                if (workerEdges[j].adapter == adapter) {\n                    if (workerEdges[j].tokenIn == coins[i]) {\n                        inputAmounts[i] += workerEdges[j].amountInTotal;\n                    }\n                    if (workerEdges[j].tokenOut == coins[i]) {\n                        outputAmounts[i] += workerEdges[j].amountOutTotal;\n                    }\n                }\n            }\n        }\n\n        for (uint256 j = 0; j < workerEdges.length; ++j) {\n            if (workerEdges[j].tokenOut == lpToken) {\n                deposits += workerEdges[j].amountOutTotal;\n            }\n            if (workerEdges[j].tokenIn == lpToken) {\n                withdrawals += workerEdges[j].amountInTotal;\n            }\n        }\n    }\n\n    /// @dev Computes the LP token amount yielded by a deposit, accounting for Curve pool possibly having different\n    ///      interfaces. If input amounts are all zero, returns 0.\n    function _calcTokenAmount(uint256[] memory inputAmounts, address adapter, bool isDeposit)\n        internal\n        view\n        returns (uint256)\n    {\n        bytes32 cType = IAdapter(adapter).contractType();\n        address pool = IAdapter(adapter).targetContract();\n\n        for (uint256 i = 0; i < inputAmounts.length; ++i) {\n            if (inputAmounts[i] > 0) {\n                break;\n            }\n\n            if (i == inputAmounts.length - 1) {\n                return 0;\n            }\n        }\n\n        if (cType == \"ADAPTER::CURVE_V1_2ASSETS\" || cType == \"ADAPTER::CURVE_V1_STECRV_POOL\") {\n            uint256[2] memory amounts = [inputAmounts[0], inputAmounts[1]];\n\n            (bool success, bytes memory returnData) = _callWithAlternative(\n                pool,\n                abi.encodeCall(ICurvePool2Assets.calc_token_amount, (amounts, isDeposit)),\n                abi.encodeWithSignature(\"calc_token_amount(uint256[2])\", amounts)\n            );\n\n            if (success) {\n                return abi.decode(returnData, (uint256));\n            } else {\n                return 0;\n            }\n        } else if (cType == \"ADAPTER::CURVE_V1_3ASSETS\") {\n            uint256[3] memory amounts = [inputAmounts[0], inputAmounts[1], inputAmounts[2]];\n\n            (bool success, bytes memory returnData) = _callWithAlternative(\n                pool,\n                abi.encodeCall(ICurvePool3Assets.calc_token_amount, (amounts, isDeposit)),\n                abi.encodeWithSignature(\"calc_token_amount(uint256[3])\", amounts)\n            );\n\n            if (success) {\n                return abi.decode(returnData, (uint256));\n            } else {\n                return 0;\n            }\n        } else if (cType == \"ADAPTER::CURVE_V1_4ASSETS\") {\n            uint256[4] memory amounts = [inputAmounts[0], inputAmounts[1], inputAmounts[2], inputAmounts[3]];\n\n            (bool success, bytes memory returnData) = _callWithAlternative(\n                pool,\n                abi.encodeCall(ICurvePool4Assets.calc_token_amount, (amounts, isDeposit)),\n                abi.encodeWithSignature(\"calc_token_amount(uint256[4])\", amounts)\n            );\n\n            if (success) {\n                return abi.decode(returnData, (uint256));\n            } else {\n                return 0;\n            }\n        } else if (cType == \"ADAPTER::CURVE_STABLE_NG\") {\n            (bool success, bytes memory returnData) = _callWithAlternative(\n                pool,\n                abi.encodeCall(ICurvePoolStableNG.calc_token_amount, (inputAmounts, isDeposit)),\n                abi.encodeWithSignature(\"calc_token_amount(uint256[])\", inputAmounts)\n            );\n\n            if (success) {\n                return abi.decode(returnData, (uint256));\n            } else {\n                return 0;\n            }\n        }\n\n        return 0;\n    }\n\n    function _callWithAlternative(address targetContract, bytes memory callData, bytes memory callDataAlt)\n        internal\n        view\n        returns (bool success, bytes memory returnData)\n    {\n        (success, returnData) = targetContract.staticcall(callData);\n        if (!success || returnData.length == 0) {\n            (success, returnData) = targetContract.staticcall(callDataAlt);\n        }\n    }\n\n    function buildEdges(Graph memory graph, address adapter) external view returns (Graph memory) {\n        (address[] memory coins, address lpToken) = _getCoins(adapter);\n        uint256 len = coins.length;\n\n        for (uint256 i = 0; i < len; ++i) {\n            for (uint256 j = i + 1; j < len; ++j) {\n                graph.appendEdge(coins[i], coins[j], abi.encode(Action.SWAP, i, j), adapter, address(this));\n                graph.appendEdge(coins[j], coins[i], abi.encode(Action.SWAP, j, i), adapter, address(this));\n            }\n\n            graph.appendEdge(coins[i], lpToken, abi.encode(Action.ADD_LIQUIDITY, i, 0), adapter, address(this));\n            graph.appendEdge(lpToken, coins[i], abi.encode(Action.REMOVE_LIQUIDITY, i, 0), adapter, address(this));\n        }\n\n        return graph;\n    }\n\n    function _getCoins(address adapter) internal view returns (address[] memory coins, address lpToken) {\n        uint256 nCoins = ICurveV1Adapter(adapter).nCoins();\n\n        coins = new address[](nCoins);\n\n        coins[0] = ICurveV1Adapter(adapter).token0();\n        coins[1] = ICurveV1Adapter(adapter).token1();\n        if (nCoins > 2) coins[2] = ICurveV1Adapter(adapter).token2();\n        if (nCoins > 3) coins[3] = ICurveV1Adapter(adapter).token3();\n\n        lpToken = ICurveV1Adapter(adapter).lp_token();\n    }\n\n    /// @notice Trims Curve LP token vertices if they are not a target or input, and have no neighbors other than pool coins\n    function trimSpecialVertex(Edge memory edge, Graph memory graph, address targetToken)\n        external\n        view\n        returns (bool)\n    {\n        (Action action,,) = abi.decode(edge.extraData, (Action, uint256, uint256));\n\n        if (action == Action.ADD_LIQUIDITY) {\n            address lpToken = edge.tokenOut;\n            uint256 nCoins = ICurveV1Adapter(edge.adapter).nCoins();\n            if (lpToken != targetToken && graph.getBalanceDiff(lpToken) <= 1) {\n                address[] memory neighbors = graph.getNeighborsOf(lpToken);\n                if (neighbors.length <= nCoins) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    function processClaims(Edge memory, Graph memory graph, address)\n        external\n        pure\n        returns (Graph memory, MultiCall[] memory)\n    {\n        return (graph, new MultiCall[](0));\n    }\n}\n"
    },
    "lib/@gearbox-protocol/core-v3/contracts/interfaces/base/IAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Foundation, 2024.\npragma solidity ^0.8.17;\n\nimport {IVersion} from \"./IVersion.sol\";\nimport {IStateSerializer} from \"./IStateSerializer.sol\";\n\n/// @title Adapter interface\n/// @notice Generic interface for an adapter that can be used to interact with external protocols.\n///         Adapters can be assumed to be non-malicious since they are developed by Gearbox DAO.\n/// @dev Adapters must have type `ADAPTER::{POSTFIX}`\ninterface IAdapter is IVersion, IStateSerializer {\n    /// @notice Credit manager this adapter is connected to\n    /// @dev Assumed to be an immutable state variable\n    function creditManager() external view returns (address);\n\n    /// @notice Target contract adapter helps to interact with\n    /// @dev Assumed to be an immutable state variable\n    function targetContract() external view returns (address);\n}\n"
    },
    "contracts/helpers/RouterComponentConfigurator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Holdings, 2025\npragma solidity ^0.8.10;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {IAdapter} from \"@gearbox-protocol/core-v3/contracts/interfaces/base/IAdapter.sol\";\nimport {IGearboxRouter} from \"../interfaces/IGearboxRouter.sol\";\n\ncontract RouterComponentConfigurator {\n    IGearboxRouter public router;\n\n    event NewRouter(address indexed);\n\n    error RouterOnlyException();\n    error RouterOwnerOnlyException();\n    error FutureRouterOnlyException();\n    error MigrationErrorException();\n\n    constructor(address _router) {\n        router = IGearboxRouter(_router);\n    }\n\n    modifier routerOwnerOnly() {\n        if (!router.isRouterConfigurator(msg.sender)) {\n            revert RouterOwnerOnlyException();\n        }\n        _;\n    }\n\n    modifier routerOnly() {\n        if (msg.sender != address(router)) revert RouterOnlyException();\n        _;\n    }\n\n    modifier futureRouterOnly() {\n        if (msg.sender != router.futureRouter()) {\n            revert FutureRouterOnlyException();\n        }\n        _;\n    }\n\n    function migrate() external futureRouterOnly {\n        if (msg.sender != address(router)) {\n            router = IGearboxRouter(msg.sender);\n            emit NewRouter(msg.sender);\n        }\n    }\n\n    function updateRouter(address newRouter) external virtual routerOwnerOnly {\n        if (newRouter != address(router)) {\n            if (!IGearboxRouter(newRouter).isRouterConfigurator(msg.sender)) {\n                revert MigrationErrorException();\n            }\n\n            router = IGearboxRouter(newRouter);\n            emit NewRouter(newRouter);\n        }\n    }\n}\n"
    },
    "lib/@gearbox-protocol/integrations-v3/contracts/integrations/curve/ICurvePool.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\ninterface ICurvePool {\n    function coins(uint256 i) external view returns (address);\n\n    function underlying_coins(uint256 i) external view returns (address);\n\n    function balances(uint256 i) external view returns (uint256);\n\n    function coins(int128) external view returns (address);\n\n    function underlying_coins(int128) external view returns (address);\n\n    function balances(int128) external view returns (uint256);\n\n    function exchange(int128 i, int128 j, uint256 dx, uint256 min_dy) external;\n\n    function exchange(uint256 i, uint256 j, uint256 dx, uint256 min_dy) external;\n\n    function exchange_underlying(int128 i, int128 j, uint256 dx, uint256 min_dy) external;\n\n    function exchange_underlying(uint256 i, uint256 j, uint256 dx, uint256 min_dy) external;\n\n    function get_dy_underlying(int128 i, int128 j, uint256 dx) external view returns (uint256);\n\n    function get_dy_underlying(uint256 i, uint256 j, uint256 dx) external view returns (uint256);\n\n    function get_dy(int128 i, int128 j, uint256 dx) external view returns (uint256);\n\n    function get_dy(uint256 i, uint256 j, uint256 dx) external view returns (uint256);\n\n    function get_virtual_price() external view returns (uint256);\n\n    function virtual_price() external view returns (uint256);\n\n    function token() external view returns (address);\n\n    function remove_liquidity_one_coin(uint256 _token_amount, int128 i, uint256 min_amount) external;\n\n    function remove_liquidity_one_coin(uint256 _token_amount, uint256 i, uint256 min_amount) external;\n\n    function A() external view returns (uint256);\n\n    function A_precise() external view returns (uint256);\n\n    function calc_withdraw_one_coin(uint256 _burn_amount, int128 i) external view returns (uint256);\n\n    function calc_withdraw_one_coin(uint256 _burn_amount, uint256 i) external view returns (uint256);\n\n    function admin_balances(uint256 i) external view returns (uint256);\n\n    function admin() external view returns (address);\n\n    function fee() external view returns (uint256);\n\n    function admin_fee() external view returns (uint256);\n\n    function block_timestamp_last() external view returns (uint256);\n\n    function initial_A() external view returns (uint256);\n\n    function future_A() external view returns (uint256);\n\n    function initial_A_time() external view returns (uint256);\n\n    function future_A_time() external view returns (uint256);\n\n    function mid_fee() external view returns (uint256);\n\n    // Some pools implement ERC20\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint256);\n\n    function balanceOf(address) external view returns (uint256);\n\n    function allowance(address, address) external view returns (uint256);\n\n    function totalSupply() external view returns (uint256);\n}\n"
    },
    "lib/@gearbox-protocol/integrations-v3/contracts/integrations/curve/ICurvePool_2.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport {ICurvePool} from \"./ICurvePool.sol\";\n\nuint256 constant N_COINS = 2;\n\n/// @title ICurvePool2Assets\n/// @dev Extends original pool contract with liquidity functions\ninterface ICurvePool2Assets is ICurvePool {\n    function add_liquidity(uint256[N_COINS] memory amounts, uint256 min_mint_amount) external;\n\n    function remove_liquidity(uint256 _amount, uint256[N_COINS] memory min_amounts) external;\n\n    function remove_liquidity_imbalance(uint256[N_COINS] calldata amounts, uint256 max_burn_amount) external;\n\n    function calc_token_amount(uint256[N_COINS] calldata _amounts, bool _is_deposit) external view returns (uint256);\n\n    function get_twap_balances(\n        uint256[N_COINS] calldata _first_balances,\n        uint256[N_COINS] calldata _last_balances,\n        uint256 _time_elapsed\n    ) external view returns (uint256[N_COINS] memory);\n\n    function get_balances() external view returns (uint256[N_COINS] memory);\n\n    function get_previous_balances() external view returns (uint256[N_COINS] memory);\n\n    function get_price_cumulative_last() external view returns (uint256[N_COINS] memory);\n}\n"
    },
    "lib/@gearbox-protocol/integrations-v3/contracts/integrations/curve/ICurvePool_3.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport {ICurvePool} from \"./ICurvePool.sol\";\n\nuint256 constant N_COINS = 3;\n\n/// @title ICurvePool3Assets\n/// @dev Extends original pool contract with liquidity functions\ninterface ICurvePool3Assets is ICurvePool {\n    function add_liquidity(uint256[N_COINS] memory amounts, uint256 min_mint_amount) external;\n\n    function remove_liquidity(uint256 _amount, uint256[N_COINS] memory min_amounts) external;\n\n    function remove_liquidity_imbalance(uint256[N_COINS] memory amounts, uint256 max_burn_amount) external;\n\n    function calc_token_amount(uint256[N_COINS] calldata _amounts, bool _is_deposit) external view returns (uint256);\n\n    function get_twap_balances(\n        uint256[N_COINS] calldata _first_balances,\n        uint256[N_COINS] calldata _last_balances,\n        uint256 _time_elapsed\n    ) external view returns (uint256[N_COINS] memory);\n\n    function get_balances() external view returns (uint256[N_COINS] memory);\n\n    function get_previous_balances() external view returns (uint256[N_COINS] memory);\n\n    function get_price_cumulative_last() external view returns (uint256[N_COINS] memory);\n}\n"
    },
    "lib/@gearbox-protocol/integrations-v3/contracts/integrations/curve/ICurvePool_4.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport {ICurvePool} from \"./ICurvePool.sol\";\n\nuint256 constant N_COINS = 4;\n\n/// @title ICurvePool4Assets\n/// @dev Extends original pool contract with liquidity functions\ninterface ICurvePool4Assets is ICurvePool {\n    function add_liquidity(uint256[N_COINS] memory amounts, uint256 min_mint_amount) external;\n\n    function remove_liquidity(uint256 _amount, uint256[N_COINS] memory min_amounts) external;\n\n    function remove_liquidity_imbalance(uint256[N_COINS] memory amounts, uint256 max_burn_amount) external;\n\n    function calc_token_amount(uint256[N_COINS] calldata _amounts, bool _is_deposit) external view returns (uint256);\n\n    function get_twap_balances(\n        uint256[N_COINS] calldata _first_balances,\n        uint256[N_COINS] calldata _last_balances,\n        uint256 _time_elapsed\n    ) external view returns (uint256[N_COINS] memory);\n\n    function get_balances() external view returns (uint256[N_COINS] memory);\n\n    function get_previous_balances() external view returns (uint256[N_COINS] memory);\n\n    function get_price_cumulative_last() external view returns (uint256[N_COINS] memory);\n}\n"
    },
    "lib/@gearbox-protocol/integrations-v3/contracts/integrations/curve/ICurvePool_StableNG.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport {ICurvePool} from \"./ICurvePool.sol\";\n\n/// @title ICurvePoolStableNG\n/// @dev Extends original pool contract with liquidity functions\ninterface ICurvePoolStableNG is ICurvePool {\n    function add_liquidity(uint256[] memory amounts, uint256 min_mint_amount) external;\n\n    function remove_liquidity(uint256 _amount, uint256[] memory min_amounts) external;\n\n    function remove_liquidity_imbalance(uint256[] calldata amounts, uint256 max_burn_amount) external;\n\n    function calc_token_amount(uint256[] calldata _amounts, bool _is_deposit) external view returns (uint256);\n\n    function get_balances() external view returns (uint256[] memory);\n\n    function N_COINS() external view returns (uint256);\n}\n"
    },
    "lib/@gearbox-protocol/integrations-v3/contracts/interfaces/curve/ICurveV1Adapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Foundation, 2024.\npragma solidity ^0.8.23;\n\nimport {IAdapter} from \"@gearbox-protocol/core-v3/contracts/interfaces/base/IAdapter.sol\";\n\n/// @title Curve V1 base adapter interface\ninterface ICurveV1Adapter is IAdapter {\n    function token() external view returns (address);\n\n    function lp_token() external view returns (address);\n\n    function metapoolBase() external view returns (address);\n\n    function nCoins() external view returns (uint256);\n\n    function use256() external view returns (bool);\n\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function token2() external view returns (address);\n    function token3() external view returns (address);\n\n    function underlying0() external view returns (address);\n    function underlying1() external view returns (address);\n    function underlying2() external view returns (address);\n    function underlying3() external view returns (address);\n\n    // -------- //\n    // EXCHANGE //\n    // -------- //\n\n    function exchange(uint256 i, uint256 j, uint256 dx, uint256 min_dy) external returns (bool useSafePrices);\n\n    function exchange(int128 i, int128 j, uint256 dx, uint256 min_dy) external returns (bool useSafePrices);\n\n    function exchange_diff(uint256 i, uint256 j, uint256 leftoverAmount, uint256 rateMinRAY)\n        external\n        returns (bool useSafePrices);\n\n    function exchange_underlying(uint256 i, uint256 j, uint256 dx, uint256 min_dy)\n        external\n        returns (bool useSafePrices);\n\n    function exchange_underlying(int128 i, int128 j, uint256 dx, uint256 min_dy)\n        external\n        returns (bool useSafePrices);\n\n    function exchange_diff_underlying(uint256 i, uint256 j, uint256 leftoverAmount, uint256 rateMinRAY)\n        external\n        returns (bool useSafePrices);\n\n    // ------------- //\n    // ADD LIQUIDITY //\n    // ------------- //\n\n    function add_liquidity_one_coin(uint256 amount, uint256 i, uint256 minAmount)\n        external\n        returns (bool useSafePrices);\n\n    function add_diff_liquidity_one_coin(uint256 leftoverAmount, uint256 i, uint256 rateMinRAY)\n        external\n        returns (bool useSafePrices);\n\n    function calc_add_one_coin(uint256 amount, uint256 i) external view returns (uint256);\n\n    // ---------------- //\n    // REMOVE LIQUIDITY //\n    // ---------------- //\n\n    function remove_liquidity_one_coin(uint256 amount, uint256 i, uint256 minAmount)\n        external\n        returns (bool useSafePrices);\n\n    function remove_liquidity_one_coin(uint256 amount, int128 i, uint256 minAmount)\n        external\n        returns (bool useSafePrices);\n\n    function remove_diff_liquidity_one_coin(uint256 leftoverAmount, uint256 i, uint256 rateMinRAY)\n        external\n        returns (bool useSafePrices);\n}\n"
    },
    "contracts/lib/MultiCall.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Holdings, 2025\npragma solidity ^0.8.17;\n\nimport {MultiCall} from \"@gearbox-protocol/core-v3/contracts/interfaces/ICreditFacadeV3.sol\";\n\nlibrary MultiCallOps {\n    function copyMulticall(MultiCall memory call) internal pure returns (MultiCall memory) {\n        return MultiCall({target: call.target, callData: call.callData});\n    }\n\n    function trim(MultiCall[] memory calls) internal pure returns (MultiCall[] memory trimmed) {\n        uint256 len = calls.length;\n\n        if (len == 0) return calls;\n\n        uint256 foundLen;\n        while (calls[foundLen].target != address(0)) {\n            unchecked {\n                ++foundLen;\n                if (foundLen == len) return calls;\n            }\n        }\n\n        if (foundLen > 0) return copy(calls, foundLen);\n    }\n\n    function copy(MultiCall[] memory calls, uint256 len) internal pure returns (MultiCall[] memory res) {\n        res = new MultiCall[](len);\n        for (uint256 i; i < len;) {\n            res[i] = copyMulticall(calls[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function clone(MultiCall[] memory calls) internal pure returns (MultiCall[] memory res) {\n        return copy(calls, calls.length);\n    }\n\n    function append(MultiCall[] memory calls, MultiCall memory newCall)\n        internal\n        pure\n        returns (MultiCall[] memory res)\n    {\n        uint256 len = calls.length;\n        res = new MultiCall[](len + 1);\n        for (uint256 i; i < len;) {\n            res[i] = copyMulticall(calls[i]);\n            unchecked {\n                ++i;\n            }\n        }\n        res[len] = copyMulticall(newCall);\n    }\n\n    function prepend(MultiCall[] memory calls, MultiCall memory newCall)\n        internal\n        pure\n        returns (MultiCall[] memory res)\n    {\n        uint256 len = calls.length;\n        res = new MultiCall[](len + 1);\n        res[0] = copyMulticall(newCall);\n\n        for (uint256 i = 1; i < len + 1;) {\n            res[i] = copyMulticall(calls[i - 1]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function concat(MultiCall[] memory calls1, MultiCall[] memory calls2)\n        internal\n        pure\n        returns (MultiCall[] memory res)\n    {\n        uint256 len1 = calls1.length;\n        uint256 lenTotal = len1 + calls2.length;\n\n        if (lenTotal == calls1.length) return clone(calls1);\n        if (lenTotal == calls2.length) return clone(calls2);\n\n        res = new MultiCall[](lenTotal);\n\n        for (uint256 i; i < lenTotal;) {\n            res[i] = (i < len1) ? copyMulticall(calls1[i]) : copyMulticall(calls2[i - len1]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n}\n"
    },
    "contracts/data/Graph.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Holdings, 2025\npragma solidity ^0.8.10;\n\nimport {MultiCall} from \"@gearbox-protocol/core-v3/contracts/interfaces/ICreditFacadeV3.sol\";\nimport {MultiCallOps} from \"../lib/MultiCall.sol\";\nimport {AddressList} from \"../helpers/AddressList.sol\";\nimport {IWorkerBase, IWorker, IWorkerNonLinear} from \"../interfaces/IWorker.sol\";\n\nstruct Edge {\n    uint256 id;\n    address tokenIn;\n    address tokenOut;\n    address adapter;\n    address worker;\n    bytes extraData;\n    uint256 amountInTotal;\n    uint256 amountOutTotal;\n    uint256 amountInCurrent;\n    uint256 amountOutCurrent;\n}\n\nstruct Vertex {\n    address token;\n    uint256 balance;\n    uint256 leftoverBalance;\n    uint256 numSplits;\n    uint256 currentOptimalEdge;\n}\n\nstruct Graph {\n    Vertex[] vertices;\n    Edge[] edges;\n}\n\nlibrary EdgeOps {\n    function includes(Edge[] memory edges, Edge memory edge) internal pure returns (bool) {\n        uint256 len = edges.length;\n        for (uint256 i = 0; i < len; ++i) {\n            if (edges[i].id == edge.id) return true;\n        }\n        return false;\n    }\n\n    function append(Edge[] memory edges, Edge memory newEdge) internal pure returns (Edge[] memory res) {\n        uint256 len = edges.length;\n        res = new Edge[](len + 1);\n        for (uint256 i = 0; i < len; ++i) {\n            res[i] = edges[i];\n        }\n        res[len] = newEdge;\n    }\n\n    function prepend(Edge[] memory edges, Edge memory newEdge) internal pure returns (Edge[] memory res) {\n        uint256 len = edges.length;\n        res = new Edge[](len + 1);\n        for (uint256 i = 0; i < len; ++i) {\n            res[i + 1] = edges[i];\n        }\n        res[0] = newEdge;\n    }\n\n    function trim(Edge[] memory edges) internal pure returns (Edge[] memory res) {\n        uint256 len = edges.length;\n        uint256 foundLen = 0;\n\n        for (uint256 i = 0; i < len; ++i) {\n            if (edges[i].id == 0) {\n                break;\n            }\n            ++foundLen;\n        }\n\n        res = new Edge[](foundLen);\n\n        for (uint256 i = 0; i < foundLen; ++i) {\n            res[i] = edges[i];\n        }\n    }\n}\n\nlibrary GraphOps {\n    using AddressList for address[];\n    using MultiCallOps for MultiCall[];\n    using EdgeOps for Edge[];\n\n    function isVertex(Graph memory g, address token) internal pure returns (bool) {\n        uint256 len = g.vertices.length;\n\n        for (uint256 i = 0; i < len; ++i) {\n            if (g.vertices[i].token == token) return true;\n        }\n\n        return false;\n    }\n\n    function getVertex(Graph memory g, address token) internal pure returns (Vertex memory vertex) {\n        uint256 len = g.vertices.length;\n\n        for (uint256 i = 0; i < len; ++i) {\n            if (g.vertices[i].token == token) return g.vertices[i];\n        }\n    }\n\n    function getBalance(Graph memory g, address token) internal pure returns (uint256) {\n        return getVertex(g, token).balance;\n    }\n\n    function getBalanceDiff(Graph memory g, address token) internal pure returns (uint256) {\n        Vertex memory v = getVertex(g, token);\n        if (v.balance < v.leftoverBalance) return 0;\n        return v.balance - v.leftoverBalance;\n    }\n\n    function getTokenOptimalAmount(Graph memory g, address token) internal pure returns (uint256) {\n        Vertex memory v = getVertex(g, token);\n\n        if (v.currentOptimalEdge == 0) return 0;\n\n        Edge memory e = getEdgeById(g, v.currentOptimalEdge);\n\n        return e.amountOutCurrent;\n    }\n\n    function getEdgesIn(Graph memory g, address token) internal pure returns (Edge[] memory edgesIn) {\n        uint256 k = 0;\n        uint256 len = g.edges.length;\n        edgesIn = new Edge[](len);\n\n        for (uint256 i = 0; i < len; ++i) {\n            if (g.edges[i].tokenOut == token) {\n                edgesIn[k] = g.edges[i];\n                ++k;\n            }\n        }\n\n        edgesIn = edgesIn.trim();\n    }\n\n    function getEdgesOut(Graph memory g, address token) internal pure returns (Edge[] memory edgesOut) {\n        uint256 k = 0;\n        uint256 len = g.edges.length;\n        edgesOut = new Edge[](len);\n\n        for (uint256 i = 0; i < len; ++i) {\n            if (g.edges[i].tokenIn == token) {\n                edgesOut[k] = g.edges[i];\n                ++k;\n            }\n        }\n\n        edgesOut = edgesOut.trim();\n    }\n\n    function getEdgeById(Graph memory g, uint256 id) internal pure returns (Edge memory) {\n        uint256 lenE = g.edges.length;\n\n        for (uint256 i = 0; i < lenE; ++i) {\n            if (g.edges[i].id == id) return g.edges[i];\n        }\n\n        revert(\"Edge not found\");\n    }\n\n    function getWorkerEdges(Graph memory g, address worker) internal pure returns (Edge[] memory workerEdges) {\n        uint256 k = 0;\n        uint256 len = g.edges.length;\n        workerEdges = new Edge[](len);\n\n        for (uint256 i = 0; i < len; ++i) {\n            if (g.edges[i].worker == worker) {\n                workerEdges[k] = g.edges[i];\n                ++k;\n            }\n        }\n\n        workerEdges = workerEdges.trim();\n    }\n\n    function activateVertex(Graph memory g, address token, uint256 amount) internal pure {\n        Vertex memory vertex = getVertex(g, token);\n        vertex.balance = amount;\n        vertex.numSplits = vertex.numSplits == 0 ? 1 : vertex.numSplits;\n    }\n\n    function removeVertex(Graph memory g, address token) internal pure {\n        uint256 k = 0;\n        uint256 lenV = g.vertices.length;\n        uint256 lenE = g.edges.length;\n\n        for (uint256 i = 0; i < lenV; ++i) {\n            if (g.vertices[i].token == token) {\n                g.vertices[i] = g.vertices[lenV - 1];\n                Vertex[] memory vertices = g.vertices;\n                assembly {\n                    mstore(vertices, sub(lenV, 1))\n                }\n                break;\n            }\n        }\n\n        Edge[] memory newEdges = new Edge[](lenE);\n\n        for (uint256 i = 0; i < lenE; ++i) {\n            if (g.edges[i].tokenIn != token && g.edges[i].tokenOut != token) {\n                newEdges[k] = g.edges[i];\n                ++k;\n            }\n        }\n\n        g.edges = newEdges.trim();\n    }\n\n    function appendEdge(\n        Graph memory g,\n        address tokenIn,\n        address tokenOut,\n        bytes memory extraData,\n        address adapter,\n        address worker\n    ) internal pure {\n        uint256 len = g.edges.length;\n\n        if (!isVertex(g, tokenIn) || !isVertex(g, tokenOut)) return;\n\n        Edge memory newEdge;\n        newEdge.id = len + 1;\n        newEdge.tokenIn = tokenIn;\n        newEdge.tokenOut = tokenOut;\n        newEdge.extraData = extraData;\n        newEdge.adapter = adapter;\n        newEdge.worker = worker;\n\n        g.edges = g.edges.append(newEdge);\n    }\n\n    function getNeighborsOf(Graph memory g, address token) internal pure returns (address[] memory neighbors) {\n        Edge[] memory edgesIn = getEdgesIn(g, token);\n        Edge[] memory edgesOut = getEdgesOut(g, token);\n\n        uint256 len = edgesIn.length;\n\n        for (uint256 i = 0; i < len; ++i) {\n            address tokenIn = edgesIn[i].tokenIn;\n            if (!neighbors.includes(tokenIn)) neighbors = neighbors.append(tokenIn);\n        }\n\n        len = edgesOut.length;\n\n        for (uint256 i = 0; i < len; ++i) {\n            address tokenOut = edgesOut[i].tokenOut;\n            if (!neighbors.includes(tokenOut)) neighbors = neighbors.append(tokenOut);\n        }\n    }\n\n    function hasOptimalOrCommittedOppositeEdge(Graph memory g, Edge memory edge) internal pure returns (bool) {\n        uint256 len = g.edges.length;\n\n        Vertex memory v = getVertex(g, edge.tokenIn);\n\n        for (uint256 i = 0; i < len; ++i) {\n            if (\n                g.edges[i].tokenIn == edge.tokenOut && g.edges[i].tokenOut == edge.tokenIn\n                    && (v.currentOptimalEdge == g.edges[i].id || g.edges[i].amountOutTotal > 1)\n            ) return true;\n        }\n        return false;\n    }\n\n    function processClaims(Graph memory g, address token, address creditAccount)\n        internal\n        view\n        returns (Graph memory, MultiCall[] memory)\n    {\n        Edge[] memory edgesIn = getEdgesIn(g, token);\n        MultiCall[] memory calls;\n\n        for (uint256 i = 0; i < edgesIn.length; ++i) {\n            MultiCall[] memory callsCurrent;\n            (g, callsCurrent) = IWorkerBase(edgesIn[i].worker).processClaims(edgesIn[i], g, creditAccount);\n            calls = calls.concat(callsCurrent);\n        }\n\n        return (g, calls);\n    }\n\n    function trimUselessVerticesRec(Graph memory g, address token, address targetToken, address[] memory walked)\n        internal\n        view\n        returns (address[] memory)\n    {\n        if (!walked.includes(token)) walked = walked.append(token);\n\n        Edge[] memory edgesIn = getEdgesIn(g, token);\n\n        uint256 len = edgesIn.length;\n\n        for (uint256 i = 0; i < len; ++i) {\n            if (!walked.includes(edgesIn[i].tokenIn)) {\n                walked = trimUselessVerticesRec(g, edgesIn[i].tokenIn, targetToken, walked);\n            }\n        }\n\n        address[] memory neighbors = getNeighborsOf(g, token);\n        bool trimSpecial = false;\n\n        /// This is a special procedure that removes vertices which cannot be detected by a generic algorithm\n        /// E.g., a Curve LP is clearly redundant if it only connects to underlying coins and is non-target,\n        /// but will not be detected by the general pass, since it always has at least 2 underlyings as neighbors\n        for (uint256 i = 0; i < len; ++i) {\n            if (IWorkerBase(edgesIn[i].worker).trimSpecialVertex(edgesIn[i], g, targetToken)) {\n                trimSpecial = true;\n                break;\n            }\n        }\n\n        if (trimSpecial || (neighbors.length == 1 && token != targetToken && getBalanceDiff(g, token) <= 1)) {\n            removeVertex(g, token);\n        }\n\n        return walked;\n    }\n\n    function trimUselessVertices(Graph memory g, address targetToken) internal view {\n        address[] memory walked = trimUselessVerticesRec(g, targetToken, targetToken, new address[](0));\n\n        address[] memory unreachable = new address[](0);\n\n        uint256 lenV = g.vertices.length;\n\n        for (uint256 i = 0; i < lenV; ++i) {\n            if (!walked.includes(g.vertices[i].token)) unreachable.append(g.vertices[i].token);\n        }\n\n        uint256 len = unreachable.length;\n\n        for (uint256 i = 0; i < len; ++i) {\n            if (getBalanceDiff(g, unreachable[i]) > 1) {\n                revert(\"Error: Unreachable token has non-zero balance diff (is input token)\");\n            }\n            removeVertex(g, unreachable[i]);\n        }\n    }\n\n    function clearCurrents(Graph memory g) internal pure {\n        uint256 lenV = g.vertices.length;\n        uint256 lenE = g.edges.length;\n\n        for (uint256 i = 0; i < lenV; ++i) {\n            g.vertices[i].currentOptimalEdge = 0;\n        }\n\n        for (uint256 i = 0; i < lenE; ++i) {\n            g.edges[i].amountInCurrent = 0;\n            g.edges[i].amountOutCurrent = 0;\n        }\n    }\n\n    function computeOptimalAmounts(Graph memory g, address inputToken, address targetToken, uint256 amount) internal {\n        clearCurrents(g);\n\n        uint256 lenV = g.vertices.length;\n        uint256 lenE = g.edges.length;\n\n        for (uint256 i = 0; i < lenV - 1; ++i) {\n            bool iterationRelaxed = false;\n            for (uint256 j = 0; j < lenE; ++j) {\n                if (\n                    g.edges[j].tokenIn == targetToken || g.edges[j].tokenOut == inputToken\n                        || hasOptimalOrCommittedOppositeEdge(g, g.edges[j])\n                ) {\n                    continue;\n                }\n\n                uint256 amountInNew;\n\n                if (g.edges[j].tokenIn == inputToken) {\n                    amountInNew = amount;\n                } else {\n                    amountInNew = getTokenOptimalAmount(g, g.edges[j].tokenIn);\n                }\n\n                if (g.edges[j].amountInCurrent == amountInNew) {\n                    continue;\n                } else {\n                    g.edges[j].amountInCurrent = amountInNew;\n                }\n\n                if (g.edges[j].amountInCurrent != 0) {\n                    address worker = g.edges[j].worker;\n\n                    g.edges[j].amountOutCurrent = IWorkerBase(worker).isNonLinear()\n                        ? IWorkerNonLinear(worker).getEdgeAmountOutCurrent(g.edges[j], g)\n                        : IWorker(worker).getEdgeAmountOutCurrent(g.edges[j]);\n                }\n\n                uint256 currentOptimalAmount = getTokenOptimalAmount(g, g.edges[j].tokenOut);\n\n                if (g.edges[j].amountOutCurrent > currentOptimalAmount) {\n                    getVertex(g, g.edges[j].tokenOut).currentOptimalEdge = g.edges[j].id;\n                    iterationRelaxed = true;\n                }\n            }\n            if (!iterationRelaxed) break;\n        }\n\n        address currentToken = targetToken;\n\n        while (currentToken != inputToken) {\n            Vertex memory vertex = getVertex(g, currentToken);\n\n            if (vertex.currentOptimalEdge == 0) {\n                revert(\n                    \"Error: no optimal edge found for token. The swapped amount may be too small to yield a positive output\"\n                );\n            }\n\n            Edge memory edge = getEdgeById(g, vertex.currentOptimalEdge);\n\n            edge.amountInTotal += edge.amountInCurrent;\n            edge.amountOutTotal += edge.amountOutCurrent;\n\n            currentToken = edge.tokenIn;\n        }\n    }\n\n    function collectMulticalls(Graph memory g, address targetToken)\n        internal\n        returns (Graph memory, MultiCall[] memory calls)\n    {\n        Edge[] memory orderedEdges = new Edge[](0);\n        address[] memory queue = new address[](1);\n\n        queue[0] = targetToken;\n\n        while (queue.length > 0) {\n            address token = queue[0];\n            queue = queue.popFirst();\n\n            Edge[] memory edgesOut = getEdgesOut(g, token);\n\n            {\n                bool defer = false;\n                for (uint256 i = 0; i < edgesOut.length; ++i) {\n                    if (\n                        edgesOut[i].amountOutTotal > 1 && !queue.includes(edgesOut[i].tokenOut)\n                            && !orderedEdges.includes(edgesOut[i])\n                    ) {\n                        defer = true;\n                        break;\n                    }\n                }\n                if (defer) {\n                    queue = queue.append(token);\n                    continue;\n                }\n            }\n\n            for (uint256 i = 0; i < edgesOut.length; ++i) {\n                if (edgesOut[i].amountOutTotal > 1 && !orderedEdges.includes(edgesOut[i])) {\n                    orderedEdges = orderedEdges.prepend(edgesOut[i]);\n                }\n            }\n\n            Edge[] memory edgesIn = getEdgesIn(g, token);\n\n            for (uint256 i = 0; i < edgesIn.length; ++i) {\n                if (edgesIn[i].amountOutTotal > 1 && !orderedEdges.includes(edgesIn[i])) {\n                    orderedEdges = orderedEdges.prepend(edgesIn[i]);\n                    queue = queue.append(edgesIn[i].tokenIn);\n                }\n            }\n        }\n\n        for (uint256 i = 0; i < orderedEdges.length; ++i) {\n            (calls, g) = collectEdgeMulticalls(g, orderedEdges[i], calls);\n        }\n\n        return (g, calls);\n    }\n\n    function collectEdgeMulticalls(Graph memory g, Edge memory edge, MultiCall[] memory calls)\n        internal\n        returns (MultiCall[] memory, Graph memory)\n    {\n        Vertex memory vertexIn = getVertex(g, edge.tokenIn);\n        MultiCall[] memory newCalls;\n        if (IWorkerBase(edge.worker).isNonLinear()) {\n            (newCalls, g) = IWorkerNonLinear(edge.worker).getMulticalls(edge, g);\n        } else {\n            if (vertexIn.balance == edge.amountInTotal) {\n                edge.amountInTotal -= 1;\n            }\n\n            newCalls = IWorker(edge.worker).getMulticalls(edge, vertexIn.balance);\n            vertexIn.balance -= edge.amountInTotal;\n            getVertex(g, edge.tokenOut).balance += edge.amountOutTotal;\n        }\n\n        calls = calls.concat(newCalls);\n\n        return (calls, g);\n    }\n}\n"
    },
    "contracts/helpers/AddressList.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Holdings, 2025\npragma solidity ^0.8.10;\n\nlibrary AddressList {\n    function includes(address[] memory array, address item) internal pure returns (bool) {\n        uint256 len = array.length;\n\n        for (uint256 i; i < len;) {\n            if (array[i] == item) return true;\n            unchecked {\n                ++i;\n            }\n        }\n\n        return false;\n    }\n\n    function trim(address[] memory array) internal pure returns (address[] memory trimmed) {\n        uint256 len = array.length;\n\n        if (len == 0) return array;\n\n        uint256 foundLen;\n        while (array[foundLen] != address(0)) {\n            unchecked {\n                ++foundLen;\n                if (foundLen == len) return array;\n            }\n        }\n\n        if (foundLen > 0) return copy(array, foundLen);\n    }\n\n    function copy(address[] memory array, uint256 len) internal pure returns (address[] memory res) {\n        res = new address[](len);\n        for (uint256 i; i < len;) {\n            res[i] = array[i];\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function concat(address[] memory calls1, address[] memory calls2) internal pure returns (address[] memory res) {\n        uint256 len1 = calls1.length;\n        uint256 lenTotal = len1 + calls2.length;\n\n        if (lenTotal == len1) return calls1;\n\n        res = new address[](lenTotal);\n\n        for (uint256 i; i < lenTotal;) {\n            res[i] = (i < len1) ? calls1[i] : calls2[i - len1];\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function append(address[] memory addrs, address newAddr) internal pure returns (address[] memory res) {\n        address[] memory newAddrArray = new address[](1);\n        newAddrArray[0] = newAddr;\n        return concat(addrs, newAddrArray);\n    }\n\n    function popFirst(address[] memory addrs) internal pure returns (address[] memory res) {\n        uint256 len = addrs.length;\n        res = new address[](len - 1);\n\n        for (uint256 i = 1; i < len; ++i) {\n            res[i - 1] = addrs[i];\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IWorker.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Holdings, 2021\npragma solidity ^0.8.10;\n\nimport {IRouterComponent} from \"./IRouterComponent.sol\";\nimport {MultiCall} from \"@gearbox-protocol/core-v3/contracts/interfaces/ICreditFacadeV3.sol\";\nimport {Graph, Edge} from \"../data/Graph.sol\";\n\ninterface IWorkerBase is IRouterComponent {\n    function isNonLinear() external pure returns (bool);\n\n    function buildEdges(Graph memory graph, address adapter) external view returns (Graph memory);\n\n    function trimSpecialVertex(Edge memory edge, Graph memory graph, address targetToken)\n        external\n        view\n        returns (bool);\n\n    function processClaims(Edge memory edge, Graph memory graph, address creditAccount)\n        external\n        view\n        returns (Graph memory, MultiCall[] memory);\n}\n\ninterface IWorker is IWorkerBase {\n    function getEdgeAmountOutCurrent(Edge memory edge) external returns (uint256 amountOutCurrent);\n\n    function getMulticalls(Edge memory edge, uint256 currentBalance) external returns (MultiCall[] memory calls);\n}\n\ninterface IWorkerNonLinear is IWorkerBase {\n    function getEdgeAmountOutCurrent(Edge memory edge, Graph memory graph)\n        external\n        returns (uint256 amountOutCurrent);\n\n    function getMulticalls(Edge memory edge, Graph memory graph) external returns (MultiCall[] memory, Graph memory);\n}\n"
    },
    "lib/@gearbox-protocol/core-v3/contracts/interfaces/base/IVersion.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Foundation, 2024.\npragma solidity ^0.8.17;\n\n/// @title Version interface\n/// @notice Defines contract version and type\ninterface IVersion {\n    /// @notice Contract version\n    function version() external view returns (uint256);\n\n    /// @notice Contract type\n    function contractType() external view returns (bytes32);\n}\n"
    },
    "lib/@gearbox-protocol/core-v3/contracts/interfaces/base/IStateSerializer.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Foundation, 2024.\npragma solidity ^0.8.17;\n\n/// @title State serializer interface\n/// @notice Generic interface for a contract that can serialize its state into a bytes array\ninterface IStateSerializer {\n    /// @notice Serializes the state of the contract into a bytes array `serializedData`\n    function serialize() external view returns (bytes memory serializedData);\n}\n"
    },
    "lib/@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "contracts/interfaces/IGearboxRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Holdings, 2021\npragma solidity ^0.8.10;\n\nimport {IVersion} from \"@gearbox-protocol/core-v3/contracts/interfaces/base/IVersion.sol\";\n\nimport {RouterResult} from \"../data/RouterResult.sol\";\n\nstruct TokenData {\n    address token;\n    uint256 balance;\n    uint256 leftoverBalance;\n    uint256 numSplits;\n    bool claimRewards;\n}\n\nerror PathNotFoundExceptionTyped(uint8 ttIn, address tokenOut);\nerror PathNotFoundException(address tokenIn, address tokenOut);\nerror PathToTargetNotFound(address tokenOut);\nerror UnsupportedAdapterType();\nerror UnsupportedRouterComponent(address);\n\ninterface IGearboxRouter is IVersion {\n    /// @dev Emits each time when routerComponent is set / updated\n    event RouterComponentUpdate(bytes32 indexed, address indexed, uint256 version);\n\n    event SetFutureRouter(address indexed);\n\n    function routeOneToOne(\n        address creditAccount,\n        address tokenIn,\n        uint256 amount,\n        address target,\n        uint256 slippage,\n        uint256 numSplits\n    ) external returns (RouterResult memory);\n\n    function routeOneToOneDiff(\n        address creditAccount,\n        address tokenIn,\n        uint256 balance,\n        uint256 leftoverBalance,\n        address target,\n        uint256 slippage,\n        uint256 numSplits\n    ) external returns (RouterResult memory);\n\n    function routeOpenManyToOne(address creditManager, address target, uint256 slippage, TokenData[] calldata tData)\n        external\n        returns (RouterResult memory);\n\n    function routeManyToOne(address creditAccount, address target, uint256 slippage, TokenData[] calldata tData)\n        external\n        returns (RouterResult memory);\n\n    function componentAddressByType(bytes32) external view returns (address);\n\n    function isRouterConfigurator(address account) external view returns (bool);\n\n    function futureRouter() external view returns (address);\n\n    function knownComponentTypes() external view returns (bytes32[] memory);\n}\n"
    },
    "lib/@gearbox-protocol/core-v3/contracts/interfaces/ICreditFacadeV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Foundation, 2024.\npragma solidity ^0.8.17;\n\nimport {AllowanceAction} from \"./ICreditConfiguratorV3.sol\";\nimport \"./ICreditFacadeV3Multicall.sol\";\nimport {IACLTrait} from \"./base/IACLTrait.sol\";\nimport {PriceUpdate} from \"./base/IPriceFeedStore.sol\";\nimport {IVersion} from \"./base/IVersion.sol\";\n\n/// @notice Multicall element\n/// @param target Call target, which is either credit facade or adapter\n/// @param callData Call data\nstruct MultiCall {\n    address target;\n    bytes callData;\n}\n\n/// @notice Debt limits packed into a single slot\n/// @param minDebt Minimum debt amount per credit account\n/// @param maxDebt Maximum debt amount per credit account\nstruct DebtLimits {\n    uint128 minDebt;\n    uint128 maxDebt;\n}\n\n/// @notice Collateral check params\n/// @param collateralHints Optional array of token masks to check first to reduce the amount of computation\n///        when known subset of account's collateral tokens covers all the debt\n/// @param minHealthFactor Min account's health factor in bps in order not to revert\nstruct FullCheckParams {\n    uint256[] collateralHints;\n    uint16 minHealthFactor;\n}\n\ninterface ICreditFacadeV3Events {\n    /// @notice Emitted when a new credit account is opened\n    event OpenCreditAccount(\n        address indexed creditAccount, address indexed onBehalfOf, address indexed caller, uint256 referralCode\n    );\n\n    /// @notice Emitted when account is closed\n    event CloseCreditAccount(address indexed creditAccount, address indexed borrower);\n\n    /// @notice Emitted when account is liquidated\n    event LiquidateCreditAccount(\n        address indexed creditAccount, address indexed liquidator, address to, uint256 remainingFunds\n    );\n\n    /// @notice Emitted when account is partially liquidated\n    event PartiallyLiquidateCreditAccount(\n        address indexed creditAccount,\n        address indexed token,\n        address indexed liquidator,\n        uint256 repaidDebt,\n        uint256 seizedCollateral,\n        uint256 fee\n    );\n\n    /// @notice Emitted when collateral is added to account\n    event AddCollateral(address indexed creditAccount, address indexed token, uint256 amount);\n\n    /// @notice Emitted when collateral is withdrawn from account\n    event WithdrawCollateral(address indexed creditAccount, address indexed token, uint256 amount, address to);\n\n    /// @notice Emitted when a multicall is started\n    event StartMultiCall(address indexed creditAccount, address indexed caller);\n\n    /// @notice Emitted when phantom token is withdrawn by account\n    event WithdrawPhantomToken(address indexed creditAccount, address indexed token, uint256 amount);\n\n    /// @notice Emitted when a call from account to an external contract is made during a multicall\n    event Execute(address indexed creditAccount, address indexed targetContract);\n\n    /// @notice Emitted when a multicall is finished\n    event FinishMultiCall();\n}\n\n/// @title Credit facade V3 interface\ninterface ICreditFacadeV3 is IVersion, IACLTrait, ICreditFacadeV3Events {\n    function creditManager() external view returns (address);\n\n    function underlying() external view returns (address);\n\n    function treasury() external view returns (address);\n\n    function priceFeedStore() external view returns (address);\n\n    function degenNFT() external view returns (address);\n\n    function weth() external view returns (address);\n\n    function botList() external view returns (address);\n\n    function maxDebtPerBlockMultiplier() external view returns (uint8);\n\n    function maxQuotaMultiplier() external view returns (uint256);\n\n    function expirable() external view returns (bool);\n\n    function expirationDate() external view returns (uint40);\n\n    function debtLimits() external view returns (uint128 minDebt, uint128 maxDebt);\n\n    function lossPolicy() external view returns (address);\n\n    function forbiddenTokenMask() external view returns (uint256);\n\n    // ------------------ //\n    // ACCOUNT MANAGEMENT //\n    // ------------------ //\n\n    function openCreditAccount(address onBehalfOf, MultiCall[] calldata calls, uint256 referralCode)\n        external\n        payable\n        returns (address creditAccount);\n\n    function closeCreditAccount(address creditAccount, MultiCall[] calldata calls) external payable;\n\n    function liquidateCreditAccount(\n        address creditAccount,\n        address to,\n        MultiCall[] calldata calls,\n        bytes memory lossPolicyData\n    ) external;\n\n    function liquidateCreditAccount(address creditAccount, address to, MultiCall[] calldata calls) external;\n\n    function partiallyLiquidateCreditAccount(\n        address creditAccount,\n        address token,\n        uint256 repaidAmount,\n        uint256 minSeizedAmount,\n        address to,\n        PriceUpdate[] calldata priceUpdates\n    ) external returns (uint256 seizedAmount);\n\n    function multicall(address creditAccount, MultiCall[] calldata calls) external payable;\n\n    function botMulticall(address creditAccount, MultiCall[] calldata calls) external;\n\n    // ------------- //\n    // CONFIGURATION //\n    // ------------- //\n\n    function setExpirationDate(uint40 newExpirationDate) external;\n\n    function setDebtLimits(uint128 newMinDebt, uint128 newMaxDebt, uint8 newMaxDebtPerBlockMultiplier) external;\n\n    function setLossPolicy(address newLossPolicy) external;\n\n    function setTokenAllowance(address token, AllowanceAction allowance) external;\n\n    function pause() external;\n\n    function unpause() external;\n}\n"
    },
    "contracts/interfaces/IRouterComponent.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Gearbox. Generalized leverage protocol that allows to take leverage and then use it across other DeFi protocols and platforms in a composable way.\n// (c) Gearbox.fi, 2021\npragma solidity ^0.8.10;\n\ninterface IRouterComponent {\n    function contractType() external view returns (bytes32);\n\n    function version() external view returns (uint256);\n}\n"
    },
    "lib/@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "contracts/data/RouterResult.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Holdings, 2025\npragma solidity ^0.8.10;\n\nimport {RAY} from \"@gearbox-protocol/core-v3/contracts/libraries/Constants.sol\";\nimport {MultiCall, MultiCallOps} from \"../lib/MultiCall.sol\";\n\nstruct RouterResult {\n    uint256 amount;\n    uint256 minAmount;\n    MultiCall[] calls;\n}\n\nlibrary RouterResultOps {\n    using MultiCallOps for MultiCall[];\n\n    function trim(RouterResult memory r) internal pure returns (RouterResult memory) {\n        r.calls = r.calls.trim();\n        return r;\n    }\n\n    function isBetter(RouterResult memory pfr1, RouterResult memory pfr2) internal pure returns (bool) {\n        return pfr1.amount > pfr2.amount;\n    }\n}\n"
    },
    "lib/@gearbox-protocol/core-v3/contracts/interfaces/ICreditConfiguratorV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Foundation, 2024.\npragma solidity ^0.8.17;\n\nimport {IACLTrait} from \"./base/IACLTrait.sol\";\nimport {IVersion} from \"./base/IVersion.sol\";\n\nenum AllowanceAction {\n    FORBID,\n    ALLOW\n}\n\ninterface ICreditConfiguratorV3Events {\n    // ------ //\n    // TOKENS //\n    // ------ //\n\n    /// @notice Emitted when a token is made recognizable as collateral in the credit manager\n    event AddCollateralToken(address indexed token);\n\n    /// @notice Emitted when a new collateral token liquidation threshold is set\n    event SetTokenLiquidationThreshold(address indexed token, uint16 liquidationThreshold);\n\n    /// @notice Emitted when a collateral token liquidation threshold ramping is scheduled\n    event ScheduleTokenLiquidationThresholdRamp(\n        address indexed token,\n        uint16 liquidationThresholdInitial,\n        uint16 liquidationThresholdFinal,\n        uint40 timestampRampStart,\n        uint40 timestampRampEnd\n    );\n\n    /// @notice Emitted when a collateral token is forbidden\n    event ForbidToken(address indexed token);\n\n    /// @notice Emitted when a previously forbidden collateral token is allowed\n    event AllowToken(address indexed token);\n\n    // -------- //\n    // ADAPTERS //\n    // -------- //\n\n    /// @notice Emitted when a new adapter and its target contract are allowed in the credit manager\n    event AllowAdapter(address indexed targetContract, address indexed adapter);\n\n    /// @notice Emitted when adapter and its target contract are forbidden in the credit manager\n    event ForbidAdapter(address indexed targetContract, address indexed adapter);\n\n    // -------------- //\n    // CREDIT MANAGER //\n    // -------------- //\n\n    /// @notice Emitted when new fee parameters are set in the credit manager\n    event UpdateFees(\n        uint16 feeLiquidation, uint16 liquidationPremium, uint16 feeLiquidationExpired, uint16 liquidationPremiumExpired\n    );\n\n    // -------- //\n    // UPGRADES //\n    // -------- //\n\n    /// @notice Emitted when a new price oracle is set in the credit manager\n    event SetPriceOracle(address indexed priceOracle);\n\n    /// @notice Emitted when a new facade is connected to the credit manager\n    event SetCreditFacade(address indexed creditFacade);\n\n    /// @notice Emitted when credit manager's configurator contract is upgraded\n    event CreditConfiguratorUpgraded(address indexed creditConfigurator);\n\n    // ------------- //\n    // CREDIT FACADE //\n    // ------------- //\n\n    /// @notice Emitted when new debt principal limits are set\n    event SetBorrowingLimits(uint256 minDebt, uint256 maxDebt);\n\n    /// @notice Emitted when a new max debt per block multiplier is set\n    event SetMaxDebtPerBlockMultiplier(uint8 maxDebtPerBlockMultiplier);\n\n    /// @notice Emitted when new loss policy is set\n    event SetLossPolicy(address indexed lossPolicy);\n\n    /// @notice Emitted when a new expiration timestamp is set in the credit facade\n    event SetExpirationDate(uint40 expirationDate);\n}\n\n/// @title Credit configurator V3 interface\ninterface ICreditConfiguratorV3 is IVersion, IACLTrait, ICreditConfiguratorV3Events {\n    function creditManager() external view returns (address);\n\n    function creditFacade() external view returns (address);\n\n    function underlying() external view returns (address);\n\n    // ------ //\n    // TOKENS //\n    // ------ //\n\n    function makeAllTokensQuoted() external;\n\n    function addCollateralToken(address token, uint16 liquidationThreshold) external;\n\n    function setLiquidationThreshold(address token, uint16 liquidationThreshold) external;\n\n    function rampLiquidationThreshold(\n        address token,\n        uint16 liquidationThresholdFinal,\n        uint40 rampStart,\n        uint24 rampDuration\n    ) external;\n\n    function forbidToken(address token) external;\n\n    function allowToken(address token) external;\n\n    // -------- //\n    // ADAPTERS //\n    // -------- //\n\n    function allowedAdapters() external view returns (address[] memory);\n\n    function allowAdapter(address adapter) external;\n\n    function forbidAdapter(address adapter) external;\n\n    // -------------- //\n    // CREDIT MANAGER //\n    // -------------- //\n\n    function setFees(\n        uint16 feeLiquidation,\n        uint16 liquidationPremium,\n        uint16 feeLiquidationExpired,\n        uint16 liquidationPremiumExpired\n    ) external;\n\n    // -------- //\n    // UPGRADES //\n    // -------- //\n\n    function setPriceOracle(address newPriceOracle) external;\n\n    function setCreditFacade(address newCreditFacade, bool migrateParams) external;\n\n    function upgradeCreditConfigurator(address newCreditConfigurator) external;\n\n    // ------------- //\n    // CREDIT FACADE //\n    // ------------- //\n\n    function setDebtLimits(uint128 newMinDebt, uint128 newMaxDebt) external;\n\n    function setMaxDebtPerBlockMultiplier(uint8 newMaxDebtLimitPerBlockMultiplier) external;\n\n    function forbidBorrowing() external;\n\n    function setLossPolicy(address newLossPolicy) external;\n\n    function setExpirationDate(uint40 newExpirationDate) external;\n}\n"
    },
    "lib/@gearbox-protocol/core-v3/contracts/interfaces/ICreditFacadeV3Multicall.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Foundation, 2024.\npragma solidity ^0.8.17;\n\nimport {BalanceDelta} from \"../libraries/BalancesLogic.sol\";\nimport {PriceUpdate} from \"./base/IPriceFeedStore.sol\";\n\n// ----------- //\n// PERMISSIONS //\n// ----------- //\n\n// NOTE: permissions 1 << 3, 1 << 4 and 1 << 7 were used by now deprecated methods, thus non-consecutive values\n\nuint192 constant ADD_COLLATERAL_PERMISSION = 1 << 0;\nuint192 constant INCREASE_DEBT_PERMISSION = 1 << 1;\nuint192 constant DECREASE_DEBT_PERMISSION = 1 << 2;\nuint192 constant WITHDRAW_COLLATERAL_PERMISSION = 1 << 5;\nuint192 constant UPDATE_QUOTA_PERMISSION = 1 << 6;\nuint192 constant SET_BOT_PERMISSIONS_PERMISSION = 1 << 8;\nuint192 constant EXTERNAL_CALLS_PERMISSION = 1 << 16;\n\nuint192 constant ALL_PERMISSIONS = ADD_COLLATERAL_PERMISSION | WITHDRAW_COLLATERAL_PERMISSION | UPDATE_QUOTA_PERMISSION\n    | INCREASE_DEBT_PERMISSION | DECREASE_DEBT_PERMISSION | SET_BOT_PERMISSIONS_PERMISSION | EXTERNAL_CALLS_PERMISSION;\nuint192 constant OPEN_CREDIT_ACCOUNT_PERMISSIONS = ALL_PERMISSIONS & ~DECREASE_DEBT_PERMISSION;\nuint192 constant CLOSE_CREDIT_ACCOUNT_PERMISSIONS = ALL_PERMISSIONS & ~INCREASE_DEBT_PERMISSION;\nuint192 constant LIQUIDATE_CREDIT_ACCOUNT_PERMISSIONS =\n    EXTERNAL_CALLS_PERMISSION | ADD_COLLATERAL_PERMISSION | WITHDRAW_COLLATERAL_PERMISSION;\n\n// ----- //\n// FLAGS //\n// ----- //\n\n/// @dev Indicates that collateral check after the multicall can be skipped, set to true on account closure or liquidation\nuint256 constant SKIP_COLLATERAL_CHECK_FLAG = 1 << 192;\n\n/// @dev Indicates that external calls from credit account to adapters were made during multicall,\n///      set to true on the first call to the adapter\nuint256 constant EXTERNAL_CONTRACT_WAS_CALLED_FLAG = 1 << 193;\n\n/// @dev Indicates that the price updates call should be skipped, set to true on liquidation when the first call\n///      of the multicall is `onDemandPriceUpdates`\nuint256 constant SKIP_PRICE_UPDATES_CALL_FLAG = 1 << 194;\n\n/// @dev Indicates that collateral check must revert if any forbidden token is encountered on the account,\n///      set to true after risky operations, such as `increaseDebt` or `withdrawCollateral`\nuint256 constant REVERT_ON_FORBIDDEN_TOKENS_FLAG = 1 << 195;\n\n/// @dev Indicates that collateral check must be performed using safe prices, set to true on `withdrawCollateral`\n///      or if account has enabled forbidden tokens\nuint256 constant USE_SAFE_PRICES_FLAG = 1 << 196;\n\n/// @title Credit facade V3 multicall interface\n/// @dev Unless specified otherwise, all these methods are only available in `openCreditAccount`,\n///      `closeCreditAccount`, `multicall`, and, with account owner's permission, `botMulticall`\ninterface ICreditFacadeV3Multicall {\n    /// @notice Applies on-demand price feed updates\n    /// @param updates Array of price updates, see `PriceUpdate` for details\n    /// @dev Reverts if placed not at the first position in the multicall\n    /// @dev This method is available in all kinds of multicalls\n    function onDemandPriceUpdates(PriceUpdate[] calldata updates) external;\n\n    /// @notice Stores expected token balances (current balance + delta) after operations for a slippage check.\n    ///         Normally, a check is performed automatically at the end of the multicall, but more fine-grained\n    ///         behavior can be achieved by placing `storeExpectedBalances` and `compareBalances` where needed.\n    /// @param balanceDeltas Array of (token, minBalanceDelta) pairs, deltas are allowed to be negative\n    /// @dev Reverts if expected balances are already set\n    /// @dev This method is available in all kinds of multicalls\n    function storeExpectedBalances(BalanceDelta[] calldata balanceDeltas) external;\n\n    /// @notice Performs a slippage check ensuring that current token balances are greater than saved expected ones\n    /// @dev Resets stored expected balances\n    /// @dev Reverts if expected balances are not stored\n    /// @dev This method is available in all kinds of multicalls\n    function compareBalances() external;\n\n    /// @notice Adds collateral to account.\n    ///         Only the underlying token counts towards account's collateral value by default, while all other tokens\n    ///         must be enabled as collateral by \"purchasing\" quota for it. Holding non-enabled token on account with\n    ///         non-zero debt poses a risk of losing it entirely to the liquidator. Adding non-enabled tokens is still\n    ///         supported to allow users to later swap them into enabled ones in the same multicall.\n    /// @param token Token to add\n    /// @param amount Amount to add\n    /// @dev Requires token approval from caller to the credit manager\n    /// @dev This method can also be called during liquidation\n    function addCollateral(address token, uint256 amount) external;\n\n    /// @notice Adds collateral to account using signed EIP-2612 permit message.\n    ///         Only the underlying token counts towards account's collateral value by default, while all other tokens\n    ///         must be enabled as collateral by \"purchasing\" quota for it. Holding non-enabled token on account with\n    ///         non-zero debt poses a risk of losing it entirely to the liquidator. Adding non-enabled tokens is still\n    ///         supported to allow users to later swap them into enabled ones in the same multicall.\n    /// @param token Token to add\n    /// @param amount Amount to add\n    /// @param deadline Permit deadline\n    /// @dev `v`, `r`, `s` must be a valid signature of the permit message from caller to the credit manager\n    /// @dev This method can also be called during liquidation\n    function addCollateralWithPermit(address token, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s)\n        external;\n\n    /// @notice Increases account's debt\n    /// @param amount Underlying amount to borrow\n    /// @dev Increasing debt is prohibited when closing an account\n    /// @dev Increasing debt is prohibited if it was previously updated in the same block\n    /// @dev The resulting debt amount must be within allowed limits\n    /// @dev Increasing debt is prohibited if there are forbidden tokens enabled as collateral on the account\n    /// @dev After debt increase, total amount borrowed by the credit manager in the current block must not exceed\n    ///      the limit defined in the facade\n    function increaseDebt(uint256 amount) external;\n\n    /// @notice Decreases account's debt\n    /// @param amount Underlying amount to repay, value above account's total debt indicates full repayment\n    /// @dev Decreasing debt is prohibited when opening an account\n    /// @dev Decreasing debt is prohibited if it was previously updated in the same block\n    /// @dev The resulting debt amount must be above allowed minimum or zero (maximum is not checked here\n    ///      to allow small repayments and partial liquidations in case configurator lowers it)\n    /// @dev Full repayment brings account into a special mode that skips collateral checks and thus requires\n    ///      an account to have no potential debt sources, e.g., all quotas must be disabled\n    function decreaseDebt(uint256 amount) external;\n\n    /// @notice Updates account's quota for a token\n    /// @param token Collateral token to update the quota for (can't be underlying)\n    /// @param quotaChange Desired quota change in underlying token units (`type(int96).min` to disable quota)\n    /// @param minQuota Minimum resulting account's quota for token required not to revert\n    /// @dev Enables token as collateral if quota is increased from zero, disables if decreased to zero\n    /// @dev Quota increase is prohibited for forbidden tokens\n    /// @dev Quota update is prohibited if account has zero debt\n    /// @dev Resulting account's quota for token must not exceed the limit defined in the facade\n    function updateQuota(address token, int96 quotaChange, uint96 minQuota) external;\n\n    /// @notice Withdraws collateral from account\n    /// @param token Token to withdraw\n    /// @param amount Amount to withdraw, `type(uint256).max` to withdraw all balance\n    /// @param to Token recipient\n    /// @dev This method can also be called during liquidation\n    /// @dev Withdrawals are prohibited in multicalls if there are forbidden tokens enabled as collateral on the account\n    /// @dev Withdrawals activate safe pricing (min of main and reserve feeds) in collateral check\n    /// @dev If `token` is a phantom token, it's withdrawn first, and its `depositedToken` is then sent to the recipient.\n    ///      No slippage prevention mechanism is provided as withdrawals are assumed to happen at non-manipulatable rate.\n    ///      Although an adapter call is made in process, permission for external calls is not required.\n    function withdrawCollateral(address token, uint256 amount, address to) external;\n\n    /// @notice Sets advanced collateral check parameters\n    /// @param collateralHints Optional array of token masks to check first to reduce the amount of computation\n    ///        when known subset of account's collateral tokens covers all the debt. Underlying token is always\n    ///        checked last so it's forbidden to pass its mask.\n    /// @param minHealthFactor Min account's health factor in bps in order not to revert, must be at least 10000\n    /// @dev This method can't be called during closure or liquidation\n    function setFullCheckParams(uint256[] calldata collateralHints, uint16 minHealthFactor) external;\n\n    /// @notice Sets `bot`'s permissions to manage account to `permissions`\n    /// @param bot Bot to set permissions for\n    /// @param permissions A bitmask encoding bot permissions\n    /// @dev Reverts if `permissions` has unexpected bits enabled or doesn't match permissions required by `bot`\n    function setBotPermissions(address bot, uint192 permissions) external;\n}\n"
    },
    "lib/@gearbox-protocol/core-v3/contracts/interfaces/base/IACLTrait.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Foundation, 2024.\npragma solidity ^0.8.17;\n\ninterface IACLTrait {\n    function acl() external view returns (address);\n}\n"
    },
    "lib/@gearbox-protocol/core-v3/contracts/interfaces/base/IPriceFeedStore.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Foundation, 2024.\npragma solidity ^0.8.17;\n\nimport {IVersion} from \"./IVersion.sol\";\n\nstruct PriceUpdate {\n    address priceFeed;\n    bytes data;\n}\n\ninterface IPriceFeedStore {\n    function getStalenessPeriod(address priceFeed) external view returns (uint32);\n    function updatePrices(PriceUpdate[] calldata updates) external;\n}\n"
    },
    "lib/@gearbox-protocol/core-v3/contracts/libraries/Constants.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Foundation, 2024.\npragma solidity ^0.8.17;\n\nbytes32 constant AP_GEAR_TOKEN = \"GLOBAL::GEAR_TOKEN\";\nbytes32 constant AP_INSTANCE_MANAGER_PROXY = \"INSTANCE_MANAGER_PROXY\";\nbytes32 constant AP_CROSS_CHAIN_GOVERNANCE_PROXY = \"CROSS_CHAIN_GOVERNANCE_PROXY\";\nbytes32 constant AP_PRICE_FEED_STORE = \"PRICE_FEED_STORE\";\nuint256 constant NO_VERSION_CONTROL = 0;\n\nuint256 constant WAD = 1e18;\nuint256 constant RAY = 1e27;\nuint16 constant PERCENTAGE_FACTOR = 1e4;\n\nuint256 constant SECONDS_PER_YEAR = 365 days;\nuint256 constant EPOCH_LENGTH = 7 days;\nuint256 constant FIRST_EPOCH_TIMESTAMP = 1702900800;\nuint256 constant EPOCHS_TO_WITHDRAW = 4;\n\nuint8 constant MAX_SANE_ENABLED_TOKENS = 20;\nuint256 constant MAX_SANE_EPOCH_LENGTH = 28 days;\nuint256 constant MAX_SANE_ACTIVE_BOTS = 5;\n\nuint8 constant MAX_WITHDRAW_FEE = 100;\n\nuint8 constant DEFAULT_LIMIT_PER_BLOCK_MULTIPLIER = 2;\n\nuint8 constant BOT_PERMISSIONS_SET_FLAG = 1;\n\nuint256 constant UNDERLYING_TOKEN_MASK = 1;\n\naddress constant INACTIVE_CREDIT_ACCOUNT_ADDRESS = address(1);\n"
    },
    "lib/@gearbox-protocol/core-v3/contracts/libraries/BalancesLogic.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Foundation, 2024.\npragma solidity ^0.8.17;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {SafeERC20} from \"@1inch/solidity-utils/contracts/libraries/SafeERC20.sol\";\n\nimport {BitMask} from \"./BitMask.sol\";\n\nstruct Balance {\n    address token;\n    uint256 balance;\n}\n\nstruct BalanceWithMask {\n    address token;\n    uint256 tokenMask;\n    uint256 balance;\n}\n\nstruct BalanceDelta {\n    address token;\n    int256 amount;\n}\n\nenum Comparison {\n    GREATER_OR_EQUAL,\n    LESS_OR_EQUAL\n}\n\n/// @title Balances logic library\n/// @notice Implements functions for before-and-after balance comparisons\nlibrary BalancesLogic {\n    using BitMask for uint256;\n    using SafeCast for int256;\n    using SafeCast for uint256;\n    using SafeERC20 for IERC20;\n\n    /// @dev Compares current `token` balance with `value`\n    /// @param token Token to check balance for\n    /// @param value Value to compare current token balance with\n    /// @param comparison Whether current balance must be greater/less than or equal to `value`\n    function checkBalance(address creditAccount, address token, uint256 value, Comparison comparison)\n        internal\n        view\n        returns (bool)\n    {\n        uint256 current = IERC20(token).safeBalanceOf(creditAccount);\n        return (comparison == Comparison.GREATER_OR_EQUAL && current >= value)\n            || (comparison == Comparison.LESS_OR_EQUAL && current <= value); // U:[BLL-1]\n    }\n\n    /// @dev Returns an array of expected token balances after operations\n    /// @param creditAccount Credit account to compute balances for\n    /// @param deltas Array of expected token balance changes\n    function storeBalances(address creditAccount, BalanceDelta[] memory deltas)\n        internal\n        view\n        returns (Balance[] memory balances)\n    {\n        uint256 len = deltas.length;\n        balances = new Balance[](len); // U:[BLL-2]\n        for (uint256 i = 0; i < len;) {\n            int256 balance = IERC20(deltas[i].token).safeBalanceOf(creditAccount).toInt256();\n            balances[i] = Balance({token: deltas[i].token, balance: (balance + deltas[i].amount).toUint256()}); // U:[BLL-2]\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @dev Compares current balances with the previously stored ones\n    /// @param creditAccount Credit account to compare balances for\n    /// @param balances Array of previously stored balances\n    /// @param comparison Whether current balances must be greater/less than or equal to stored ones\n    /// @return failedToken The first token for which the condition specified by `comparison` fails, if any\n    function compareBalances(address creditAccount, Balance[] memory balances, Comparison comparison)\n        internal\n        view\n        returns (address failedToken)\n    {\n        unchecked {\n            uint256 len = balances.length;\n            for (uint256 i; i < len; ++i) {\n                if (!BalancesLogic.checkBalance(creditAccount, balances[i].token, balances[i].balance, comparison)) {\n                    return balances[i].token; // U:[BLL-3]\n                }\n            }\n        }\n    }\n\n    /// @dev Returns balances of specified tokens on the credit account\n    /// @param creditAccount Credit account to compute balances for\n    /// @param tokensMask Bit mask of tokens to compute balances for\n    /// @param getTokenByMaskFn Function that returns token's address by its mask\n    function storeBalances(\n        address creditAccount,\n        uint256 tokensMask,\n        function (uint256) view returns (address) getTokenByMaskFn\n    ) internal view returns (BalanceWithMask[] memory balances) {\n        if (tokensMask == 0) return balances;\n\n        balances = new BalanceWithMask[](tokensMask.calcEnabledTokens()); // U:[BLL-4]\n        unchecked {\n            uint256 i;\n            while (tokensMask != 0) {\n                uint256 tokenMask = tokensMask.lsbMask();\n                tokensMask ^= tokenMask;\n\n                address token = getTokenByMaskFn(tokenMask);\n                balances[i] = BalanceWithMask({\n                    token: token,\n                    tokenMask: tokenMask,\n                    balance: IERC20(token).safeBalanceOf(creditAccount)\n                }); // U:[BLL-4]\n                ++i;\n            }\n        }\n    }\n\n    /// @dev Compares current balances of specified tokens with the previously stored ones\n    /// @param creditAccount Credit account to compare balances for\n    /// @param tokensMask Bit mask of tokens to compare balances for\n    /// @param balances Array of previously stored balances\n    /// @param comparison Whether current balances must be greater/less than or equal to stored ones\n    /// @return failedToken The first token for which the condition specified by `comparison` fails, if any\n    /// @dev This function assumes that `tokensMask` encodes a subset of tokens from `balances`\n    function compareBalances(\n        address creditAccount,\n        uint256 tokensMask,\n        BalanceWithMask[] memory balances,\n        Comparison comparison\n    ) internal view returns (address failedToken) {\n        if (tokensMask == 0) return address(0);\n\n        unchecked {\n            uint256 len = balances.length;\n            for (uint256 i; i < len; ++i) {\n                if (tokensMask & balances[i].tokenMask == 0) continue;\n                if (!BalancesLogic.checkBalance(creditAccount, balances[i].token, balances[i].balance, comparison)) {\n                    return balances[i].token; // U:[BLL-5]\n                }\n            }\n        }\n    }\n}\n"
    },
    "lib/@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "lib/@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        require(value <= type(uint248).max, \"SafeCast: value doesn't fit in 248 bits\");\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        require(value <= type(uint240).max, \"SafeCast: value doesn't fit in 240 bits\");\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        require(value <= type(uint232).max, \"SafeCast: value doesn't fit in 232 bits\");\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        require(value <= type(uint216).max, \"SafeCast: value doesn't fit in 216 bits\");\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        require(value <= type(uint208).max, \"SafeCast: value doesn't fit in 208 bits\");\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        require(value <= type(uint200).max, \"SafeCast: value doesn't fit in 200 bits\");\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        require(value <= type(uint192).max, \"SafeCast: value doesn't fit in 192 bits\");\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        require(value <= type(uint184).max, \"SafeCast: value doesn't fit in 184 bits\");\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        require(value <= type(uint176).max, \"SafeCast: value doesn't fit in 176 bits\");\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        require(value <= type(uint168).max, \"SafeCast: value doesn't fit in 168 bits\");\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        require(value <= type(uint160).max, \"SafeCast: value doesn't fit in 160 bits\");\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        require(value <= type(uint152).max, \"SafeCast: value doesn't fit in 152 bits\");\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        require(value <= type(uint144).max, \"SafeCast: value doesn't fit in 144 bits\");\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        require(value <= type(uint136).max, \"SafeCast: value doesn't fit in 136 bits\");\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        require(value <= type(uint120).max, \"SafeCast: value doesn't fit in 120 bits\");\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        require(value <= type(uint112).max, \"SafeCast: value doesn't fit in 112 bits\");\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        require(value <= type(uint104).max, \"SafeCast: value doesn't fit in 104 bits\");\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        require(value <= type(uint88).max, \"SafeCast: value doesn't fit in 88 bits\");\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        require(value <= type(uint80).max, \"SafeCast: value doesn't fit in 80 bits\");\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        require(value <= type(uint72).max, \"SafeCast: value doesn't fit in 72 bits\");\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        require(value <= type(uint56).max, \"SafeCast: value doesn't fit in 56 bits\");\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        require(value <= type(uint48).max, \"SafeCast: value doesn't fit in 48 bits\");\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        require(value <= type(uint40).max, \"SafeCast: value doesn't fit in 40 bits\");\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        require(value <= type(uint24).max, \"SafeCast: value doesn't fit in 24 bits\");\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     *\n     * _Available since v3.0._\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 248 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 240 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 232 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 224 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 216 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 208 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 200 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 192 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 184 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 176 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 168 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 160 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 152 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 144 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 136 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 128 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 120 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 112 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 104 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 96 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 88 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 80 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 72 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 64 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 56 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 48 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 40 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 32 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 24 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 16 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 8 bits\");\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     *\n     * _Available since v3.0._\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "lib/@1inch/solidity-utils/contracts/libraries/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\";\nimport \"../interfaces/IDaiLikePermit.sol\";\nimport \"../interfaces/IPermit2.sol\";\nimport \"../interfaces/IERC7597Permit.sol\";\nimport \"../interfaces/IWETH.sol\";\nimport \"../libraries/RevertReasonForwarder.sol\";\n\n/**\n * @title Implements efficient safe methods for ERC20 interface.\n * @notice Compared to the standard ERC20, this implementation offers several enhancements:\n * 1. more gas-efficient, providing significant savings in transaction costs.\n * 2. support for different permit implementations\n * 3. forceApprove functionality\n * 4. support for WETH deposit and withdraw\n */\nlibrary SafeERC20 {\n    error SafeTransferFailed();\n    error SafeTransferFromFailed();\n    error ForceApproveFailed();\n    error SafeIncreaseAllowanceFailed();\n    error SafeDecreaseAllowanceFailed();\n    error SafePermitBadLength();\n    error Permit2TransferAmountTooHigh();\n\n    // Uniswap Permit2 address\n    address private constant _PERMIT2 = 0x000000000022D473030F116dDEE9F6B43aC78BA3;\n    bytes4 private constant _PERMIT_LENGTH_ERROR = 0x68275857;  // SafePermitBadLength.selector\n    uint256 private constant _RAW_CALL_GAS_LIMIT = 5000;\n\n    /**\n     * @notice Fetches the balance of a specific ERC20 token held by an account.\n     * Consumes less gas then regular `ERC20.balanceOf`.\n     * @dev Note that the implementation does not perform dirty bits cleaning, so it is the\n     * responsibility of the caller to make sure that the higher 96 bits of the `account` parameter are clean.\n     * @param token The IERC20 token contract for which the balance will be fetched.\n     * @param account The address of the account whose token balance will be fetched.\n     * @return tokenBalance The balance of the specified ERC20 token held by the account.\n     */\n    function safeBalanceOf(\n        IERC20 token,\n        address account\n    ) internal view returns(uint256 tokenBalance) {\n        bytes4 selector = IERC20.balanceOf.selector;\n        assembly (\"memory-safe\") { // solhint-disable-line no-inline-assembly\n            mstore(0x00, selector)\n            mstore(0x04, account)\n            let success := staticcall(gas(), token, 0x00, 0x24, 0x00, 0x20)\n            tokenBalance := mload(0)\n\n            if or(iszero(success), lt(returndatasize(), 0x20)) {\n                let ptr := mload(0x40)\n                returndatacopy(ptr, 0, returndatasize())\n                revert(ptr, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @notice Attempts to safely transfer tokens from one address to another.\n     * @dev If permit2 is true, uses the Permit2 standard; otherwise uses the standard ERC20 transferFrom.\n     * Either requires `true` in return data, or requires target to be smart-contract and empty return data.\n     * Note that the implementation does not perform dirty bits cleaning, so it is the responsibility of\n     * the caller to make sure that the higher 96 bits of the `from` and `to` parameters are clean.\n     * @param token The IERC20 token contract from which the tokens will be transferred.\n     * @param from The address from which the tokens will be transferred.\n     * @param to The address to which the tokens will be transferred.\n     * @param amount The amount of tokens to transfer.\n     * @param permit2 If true, uses the Permit2 standard for the transfer; otherwise uses the standard ERC20 transferFrom.\n     */\n    function safeTransferFromUniversal(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 amount,\n        bool permit2\n    ) internal {\n        if (permit2) {\n            safeTransferFromPermit2(token, from, to, amount);\n        } else {\n            safeTransferFrom(token, from, to, amount);\n        }\n    }\n\n    /**\n     * @notice Attempts to safely transfer tokens from one address to another using the ERC20 standard.\n     * @dev Either requires `true` in return data, or requires target to be smart-contract and empty return data.\n     * Note that the implementation does not perform dirty bits cleaning, so it is the responsibility of\n     * the caller to make sure that the higher 96 bits of the `from` and `to` parameters are clean.\n     * @param token The IERC20 token contract from which the tokens will be transferred.\n     * @param from The address from which the tokens will be transferred.\n     * @param to The address to which the tokens will be transferred.\n     * @param amount The amount of tokens to transfer.\n     */\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        bytes4 selector = token.transferFrom.selector;\n        bool success;\n        assembly (\"memory-safe\") { // solhint-disable-line no-inline-assembly\n            let data := mload(0x40)\n\n            mstore(data, selector)\n            mstore(add(data, 0x04), from)\n            mstore(add(data, 0x24), to)\n            mstore(add(data, 0x44), amount)\n            success := call(gas(), token, 0, data, 100, 0x0, 0x20)\n            if success {\n                switch returndatasize()\n                case 0 {\n                    success := gt(extcodesize(token), 0)\n                }\n                default {\n                    success := and(gt(returndatasize(), 31), eq(mload(0), 1))\n                }\n            }\n        }\n        if (!success) revert SafeTransferFromFailed();\n    }\n\n    /**\n     * @notice Attempts to safely transfer tokens from one address to another using the Permit2 standard.\n     * @dev Either requires `true` in return data, or requires target to be smart-contract and empty return data.\n     * Note that the implementation does not perform dirty bits cleaning, so it is the responsibility of\n     * the caller to make sure that the higher 96 bits of the `from` and `to` parameters are clean.\n     * @param token The IERC20 token contract from which the tokens will be transferred.\n     * @param from The address from which the tokens will be transferred.\n     * @param to The address to which the tokens will be transferred.\n     * @param amount The amount of tokens to transfer.\n     */\n    function safeTransferFromPermit2(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        if (amount > type(uint160).max) revert Permit2TransferAmountTooHigh();\n        bytes4 selector = IPermit2.transferFrom.selector;\n        bool success;\n        assembly (\"memory-safe\") { // solhint-disable-line no-inline-assembly\n            let data := mload(0x40)\n\n            mstore(data, selector)\n            mstore(add(data, 0x04), from)\n            mstore(add(data, 0x24), to)\n            mstore(add(data, 0x44), amount)\n            mstore(add(data, 0x64), token)\n            success := call(gas(), _PERMIT2, 0, data, 0x84, 0x0, 0x0)\n            if success {\n                success := gt(extcodesize(_PERMIT2), 0)\n            }\n        }\n        if (!success) revert SafeTransferFromFailed();\n    }\n\n    /**\n     * @notice Attempts to safely transfer tokens to another address.\n     * @dev Either requires `true` in return data, or requires target to be smart-contract and empty return data.\n     * Note that the implementation does not perform dirty bits cleaning, so it is the responsibility of\n     * the caller to make sure that the higher 96 bits of the `to` parameter are clean.\n     * @param token The IERC20 token contract from which the tokens will be transferred.\n     * @param to The address to which the tokens will be transferred.\n     * @param value The amount of tokens to transfer.\n     */\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        if (!_makeCall(token, token.transfer.selector, to, value)) {\n            revert SafeTransferFailed();\n        }\n    }\n\n    /**\n     * @notice Attempts to approve a spender to spend a certain amount of tokens.\n     * @dev If `approve(from, to, amount)` fails, it tries to set the allowance to zero, and retries the `approve` call.\n     * Note that the implementation does not perform dirty bits cleaning, so it is the responsibility of\n     * the caller to make sure that the higher 96 bits of the `spender` parameter are clean.\n     * @param token The IERC20 token contract on which the call will be made.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     */\n    function forceApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        if (!_makeCall(token, token.approve.selector, spender, value)) {\n            if (\n                !_makeCall(token, token.approve.selector, spender, 0) ||\n                !_makeCall(token, token.approve.selector, spender, value)\n            ) {\n                revert ForceApproveFailed();\n            }\n        }\n    }\n\n    /**\n     * @notice Safely increases the allowance of a spender.\n     * @dev Increases with safe math check. Checks if the increased allowance will overflow, if yes, then it reverts the transaction.\n     * Then uses `forceApprove` to increase the allowance.\n     * Note that the implementation does not perform dirty bits cleaning, so it is the responsibility of\n     * the caller to make sure that the higher 96 bits of the `spender` parameter are clean.\n     * @param token The IERC20 token contract on which the call will be made.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to increase the allowance by.\n     */\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 allowance = token.allowance(address(this), spender);\n        if (value > type(uint256).max - allowance) revert SafeIncreaseAllowanceFailed();\n        forceApprove(token, spender, allowance + value);\n    }\n\n    /**\n     * @notice Safely decreases the allowance of a spender.\n     * @dev Decreases with safe math check. Checks if the decreased allowance will underflow, if yes, then it reverts the transaction.\n     * Then uses `forceApprove` to increase the allowance.\n     * Note that the implementation does not perform dirty bits cleaning, so it is the responsibility of\n     * the caller to make sure that the higher 96 bits of the `spender` parameter are clean.\n     * @param token The IERC20 token contract on which the call will be made.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to decrease the allowance by.\n     */\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 allowance = token.allowance(address(this), spender);\n        if (value > allowance) revert SafeDecreaseAllowanceFailed();\n        forceApprove(token, spender, allowance - value);\n    }\n\n    /**\n     * @notice Attempts to execute the `permit` function on the provided token with the sender and contract as parameters.\n     * Permit type is determined automatically based on permit calldata (IERC20Permit, IDaiLikePermit, and IPermit2).\n     * @dev Wraps `tryPermit` function and forwards revert reason if permit fails.\n     * @param token The IERC20 token to execute the permit function on.\n     * @param permit The permit data to be used in the function call.\n     */\n    function safePermit(IERC20 token, bytes calldata permit) internal {\n        if (!tryPermit(token, msg.sender, address(this), permit)) RevertReasonForwarder.reRevert();\n    }\n\n    /**\n     * @notice Attempts to execute the `permit` function on the provided token with custom owner and spender parameters.\n     * Permit type is determined automatically based on permit calldata (IERC20Permit, IDaiLikePermit, and IPermit2).\n     * @dev Wraps `tryPermit` function and forwards revert reason if permit fails.\n     * Note that the implementation does not perform dirty bits cleaning, so it is the responsibility of\n     * the caller to make sure that the higher 96 bits of the `owner` and `spender` parameters are clean.\n     * @param token The IERC20 token to execute the permit function on.\n     * @param owner The owner of the tokens for which the permit is made.\n     * @param spender The spender allowed to spend the tokens by the permit.\n     * @param permit The permit data to be used in the function call.\n     */\n    function safePermit(IERC20 token, address owner, address spender, bytes calldata permit) internal {\n        if (!tryPermit(token, owner, spender, permit)) RevertReasonForwarder.reRevert();\n    }\n\n    /**\n     * @notice Attempts to execute the `permit` function on the provided token with the sender and contract as parameters.\n     * @dev Invokes `tryPermit` with sender as owner and contract as spender.\n     * @param token The IERC20 token to execute the permit function on.\n     * @param permit The permit data to be used in the function call.\n     * @return success Returns true if the permit function was successfully executed, false otherwise.\n     */\n    function tryPermit(IERC20 token, bytes calldata permit) internal returns(bool success) {\n        return tryPermit(token, msg.sender, address(this), permit);\n    }\n\n    /**\n     * @notice The function attempts to call the permit function on a given ERC20 token.\n     * @dev The function is designed to support a variety of permit functions, namely: IERC20Permit, IDaiLikePermit, IERC7597Permit and IPermit2.\n     * It accommodates both Compact and Full formats of these permit types.\n     * Please note, it is expected that the `expiration` parameter for the compact Permit2 and the `deadline` parameter\n     * for the compact Permit are to be incremented by one before invoking this function. This approach is motivated by\n     * gas efficiency considerations; as the unlimited expiration period is likely to be the most common scenario, and\n     * zeros are cheaper to pass in terms of gas cost. Thus, callers should increment the expiration or deadline by one\n     * before invocation for optimized performance.\n     * Note that the implementation does not perform dirty bits cleaning, so it is the responsibility of\n     * the caller to make sure that the higher 96 bits of the `owner` and `spender` parameters are clean.\n     * @param token The address of the ERC20 token on which to call the permit function.\n     * @param owner The owner of the tokens. This address should have signed the off-chain permit.\n     * @param spender The address which will be approved for transfer of tokens.\n     * @param permit The off-chain permit data, containing different fields depending on the type of permit function.\n     * @return success A boolean indicating whether the permit call was successful.\n     */\n    function tryPermit(IERC20 token, address owner, address spender, bytes calldata permit) internal returns(bool success) {\n        // load function selectors for different permit standards\n        bytes4 permitSelector = IERC20Permit.permit.selector;\n        bytes4 daiPermitSelector = IDaiLikePermit.permit.selector;\n        bytes4 permit2Selector = IPermit2.permit.selector;\n        bytes4 erc7597PermitSelector = IERC7597Permit.permit.selector;\n        assembly (\"memory-safe\") { // solhint-disable-line no-inline-assembly\n            let ptr := mload(0x40)\n\n            // Switch case for different permit lengths, indicating different permit standards\n            switch permit.length\n            // Compact IERC20Permit\n            case 100 {\n                mstore(ptr, permitSelector)     // store selector\n                mstore(add(ptr, 0x04), owner)   // store owner\n                mstore(add(ptr, 0x24), spender) // store spender\n\n                // Compact IERC20Permit.permit(uint256 value, uint32 deadline, uint256 r, uint256 vs)\n                {  // stack too deep\n                    let deadline := shr(224, calldataload(add(permit.offset, 0x20))) // loads permit.offset 0x20..0x23\n                    let vs := calldataload(add(permit.offset, 0x44))                 // loads permit.offset 0x44..0x63\n\n                    calldatacopy(add(ptr, 0x44), permit.offset, 0x20)            // store value     = copy permit.offset 0x00..0x19\n                    mstore(add(ptr, 0x64), sub(deadline, 1))                     // store deadline  = deadline - 1\n                    mstore(add(ptr, 0x84), add(27, shr(255, vs)))                // store v         = most significant bit of vs + 27 (27 or 28)\n                    calldatacopy(add(ptr, 0xa4), add(permit.offset, 0x24), 0x20) // store r         = copy permit.offset 0x24..0x43\n                    mstore(add(ptr, 0xc4), shr(1, shl(1, vs)))                   // store s         = vs without most significant bit\n                }\n                // IERC20Permit.permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)\n                success := call(gas(), token, 0, ptr, 0xe4, 0, 0)\n            }\n            // Compact IDaiLikePermit\n            case 72 {\n                mstore(ptr, daiPermitSelector)  // store selector\n                mstore(add(ptr, 0x04), owner)   // store owner\n                mstore(add(ptr, 0x24), spender) // store spender\n\n                // Compact IDaiLikePermit.permit(uint32 nonce, uint32 expiry, uint256 r, uint256 vs)\n                {  // stack too deep\n                    let expiry := shr(224, calldataload(add(permit.offset, 0x04))) // loads permit.offset 0x04..0x07\n                    let vs := calldataload(add(permit.offset, 0x28))               // loads permit.offset 0x28..0x47\n\n                    mstore(add(ptr, 0x44), shr(224, calldataload(permit.offset))) // store nonce   = copy permit.offset 0x00..0x03\n                    mstore(add(ptr, 0x64), sub(expiry, 1))                        // store expiry  = expiry - 1\n                    mstore(add(ptr, 0x84), true)                                  // store allowed = true\n                    mstore(add(ptr, 0xa4), add(27, shr(255, vs)))                 // store v       = most significant bit of vs + 27 (27 or 28)\n                    calldatacopy(add(ptr, 0xc4), add(permit.offset, 0x08), 0x20)  // store r       = copy permit.offset 0x08..0x27\n                    mstore(add(ptr, 0xe4), shr(1, shl(1, vs)))                    // store s       = vs without most significant bit\n                }\n                // IDaiLikePermit.permit(address holder, address spender, uint256 nonce, uint256 expiry, bool allowed, uint8 v, bytes32 r, bytes32 s)\n                success := call(gas(), token, 0, ptr, 0x104, 0, 0)\n            }\n            // IERC20Permit\n            case 224 {\n                mstore(ptr, permitSelector)\n                calldatacopy(add(ptr, 0x04), permit.offset, permit.length) // copy permit calldata\n                // IERC20Permit.permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)\n                success := call(gas(), token, 0, ptr, 0xe4, 0, 0)\n            }\n            // IDaiLikePermit\n            case 256 {\n                mstore(ptr, daiPermitSelector)\n                calldatacopy(add(ptr, 0x04), permit.offset, permit.length) // copy permit calldata\n                // IDaiLikePermit.permit(address holder, address spender, uint256 nonce, uint256 expiry, bool allowed, uint8 v, bytes32 r, bytes32 s)\n                success := call(gas(), token, 0, ptr, 0x104, 0, 0)\n            }\n            // Compact IPermit2\n            case 96 {\n                // Compact IPermit2.permit(uint160 amount, uint32 expiration, uint32 nonce, uint32 sigDeadline, uint256 r, uint256 vs)\n                mstore(ptr, permit2Selector)  // store selector\n                mstore(add(ptr, 0x04), owner) // store owner\n                mstore(add(ptr, 0x24), token) // store token\n\n                calldatacopy(add(ptr, 0x50), permit.offset, 0x14)             // store amount = copy permit.offset 0x00..0x13\n                // and(0xffffffffffff, ...) - conversion to uint48\n                mstore(add(ptr, 0x64), and(0xffffffffffff, sub(shr(224, calldataload(add(permit.offset, 0x14))), 1))) // store expiration = ((permit.offset 0x14..0x17 - 1) & 0xffffffffffff)\n                mstore(add(ptr, 0x84), shr(224, calldataload(add(permit.offset, 0x18)))) // store nonce = copy permit.offset 0x18..0x1b\n                mstore(add(ptr, 0xa4), spender)                               // store spender\n                // and(0xffffffffffff, ...) - conversion to uint48\n                mstore(add(ptr, 0xc4), and(0xffffffffffff, sub(shr(224, calldataload(add(permit.offset, 0x1c))), 1))) // store sigDeadline = ((permit.offset 0x1c..0x1f - 1) & 0xffffffffffff)\n                mstore(add(ptr, 0xe4), 0x100)                                 // store offset = 256\n                mstore(add(ptr, 0x104), 0x40)                                 // store length = 64\n                calldatacopy(add(ptr, 0x124), add(permit.offset, 0x20), 0x20) // store r      = copy permit.offset 0x20..0x3f\n                calldatacopy(add(ptr, 0x144), add(permit.offset, 0x40), 0x20) // store vs     = copy permit.offset 0x40..0x5f\n                // IPermit2.permit(address owner, PermitSingle calldata permitSingle, bytes calldata signature)\n                success := call(gas(), _PERMIT2, 0, ptr, 0x164, 0, 0)\n            }\n            // IPermit2\n            case 352 {\n                mstore(ptr, permit2Selector)\n                calldatacopy(add(ptr, 0x04), permit.offset, permit.length) // copy permit calldata\n                // IPermit2.permit(address owner, PermitSingle calldata permitSingle, bytes calldata signature)\n                success := call(gas(), _PERMIT2, 0, ptr, 0x164, 0, 0)\n            }\n            // Dynamic length\n            default {\n                mstore(ptr, erc7597PermitSelector)\n                calldatacopy(add(ptr, 0x04), permit.offset, permit.length) // copy permit calldata\n                // IERC7597Permit.permit(address owner, address spender, uint256 value, uint256 deadline, bytes memory signature)\n                success := call(gas(), token, 0, ptr, add(permit.length, 4), 0, 0)\n            }\n        }\n    }\n\n    /**\n     * @dev Executes a low level call to a token contract, making it resistant to reversion and erroneous boolean returns.\n     * @param token The IERC20 token contract on which the call will be made.\n     * @param selector The function signature that is to be called on the token contract.\n     * @param to The address to which the token amount will be transferred.\n     * @param amount The token amount to be transferred.\n     * @return success A boolean indicating if the call was successful. Returns 'true' on success and 'false' on failure.\n     * In case of success but no returned data, validates that the contract code exists.\n     * In case of returned data, ensures that it's a boolean `true`.\n     */\n    function _makeCall(\n        IERC20 token,\n        bytes4 selector,\n        address to,\n        uint256 amount\n    ) private returns (bool success) {\n        assembly (\"memory-safe\") { // solhint-disable-line no-inline-assembly\n            let data := mload(0x40)\n\n            mstore(data, selector)\n            mstore(add(data, 0x04), to)\n            mstore(add(data, 0x24), amount)\n            success := call(gas(), token, 0, data, 0x44, 0x0, 0x20)\n            if success {\n                switch returndatasize()\n                case 0 {\n                    success := gt(extcodesize(token), 0)\n                }\n                default {\n                    success := and(gt(returndatasize(), 31), eq(mload(0), 1))\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Safely deposits a specified amount of Ether into the IWETH contract. Consumes less gas then regular `IWETH.deposit`.\n     * @param weth The IWETH token contract.\n     * @param amount The amount of Ether to deposit into the IWETH contract.\n     */\n    function safeDeposit(IWETH weth, uint256 amount) internal {\n        if (amount > 0) {\n            bytes4 selector = IWETH.deposit.selector;\n            assembly (\"memory-safe\") { // solhint-disable-line no-inline-assembly\n                mstore(0, selector)\n                if iszero(call(gas(), weth, amount, 0, 4, 0, 0)) {\n                    let ptr := mload(0x40)\n                    returndatacopy(ptr, 0, returndatasize())\n                    revert(ptr, returndatasize())\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Safely withdraws a specified amount of wrapped Ether from the IWETH contract. Consumes less gas then regular `IWETH.withdraw`.\n     * @dev Uses inline assembly to interact with the IWETH contract.\n     * @param weth The IWETH token contract.\n     * @param amount The amount of wrapped Ether to withdraw from the IWETH contract.\n     */\n    function safeWithdraw(IWETH weth, uint256 amount) internal {\n        bytes4 selector = IWETH.withdraw.selector;\n        assembly (\"memory-safe\") {  // solhint-disable-line no-inline-assembly\n            mstore(0, selector)\n            mstore(4, amount)\n            if iszero(call(gas(), weth, 0, 0, 0x24, 0, 0)) {\n                let ptr := mload(0x40)\n                returndatacopy(ptr, 0, returndatasize())\n                revert(ptr, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @notice Safely withdraws a specified amount of wrapped Ether from the IWETH contract to a specified recipient.\n     * Consumes less gas then regular `IWETH.withdraw`.\n     * @param weth The IWETH token contract.\n     * @param amount The amount of wrapped Ether to withdraw from the IWETH contract.\n     * @param to The recipient of the withdrawn Ether.\n     */\n    function safeWithdrawTo(IWETH weth, uint256 amount, address to) internal {\n        safeWithdraw(weth, amount);\n        if (to != address(this)) {\n            assembly (\"memory-safe\") {  // solhint-disable-line no-inline-assembly\n                if iszero(call(_RAW_CALL_GAS_LIMIT, to, amount, 0, 0, 0, 0)) {\n                    let ptr := mload(0x40)\n                    returndatacopy(ptr, 0, returndatasize())\n                    revert(ptr, returndatasize())\n                }\n            }\n        }\n    }\n}\n"
    },
    "lib/@gearbox-protocol/core-v3/contracts/libraries/BitMask.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Foundation, 2024.\npragma solidity ^0.8.17;\n\nimport {IncorrectParameterException} from \"../interfaces/IExceptions.sol\";\n\n/// @title Bit mask library\n/// @notice Implements functions that manipulate bit masks\n///         Bit masks are utilized extensively by Gearbox to efficiently store token sets (enabled tokens on accounts\n///         or forbidden tokens) and check for set inclusion. A mask is a uint256 number that has its i-th bit set to\n///         1 if i-th item is included into the set. For example, each token has a mask equal to 2**i, so set inclusion\n///         can be checked by checking tokenMask & setMask != 0.\nlibrary BitMask {\n    /// @dev Calculates the number of `1` bits\n    /// @param enabledTokensMask Bit mask to compute the number of `1` bits in\n    function calcEnabledTokens(uint256 enabledTokensMask) internal pure returns (uint256 totalTokensEnabled) {\n        unchecked {\n            while (enabledTokensMask > 0) {\n                enabledTokensMask &= enabledTokensMask - 1; // U:[BM-3]\n                ++totalTokensEnabled; // U:[BM-3]\n            }\n        }\n    }\n\n    /// @dev Enables bits from the second mask in the first mask\n    /// @param enabledTokenMask The initial mask\n    /// @param bitsToEnable Mask of bits to enable\n    function enable(uint256 enabledTokenMask, uint256 bitsToEnable) internal pure returns (uint256) {\n        return enabledTokenMask | bitsToEnable; // U:[BM-4]\n    }\n\n    /// @dev Disables bits from the second mask in the first mask\n    /// @param enabledTokenMask The initial mask\n    /// @param bitsToDisable Mask of bits to disable\n    function disable(uint256 enabledTokenMask, uint256 bitsToDisable) internal pure returns (uint256) {\n        return enabledTokenMask & ~bitsToDisable; // U:[BM-4]\n    }\n\n    /// @dev Computes a new mask with sets of new enabled and disabled bits\n    /// @dev bitsToEnable and bitsToDisable are applied sequentially to original mask\n    /// @param enabledTokensMask The initial mask\n    /// @param bitsToEnable Mask with bits to enable\n    /// @param bitsToDisable Mask with bits to disable\n    function enableDisable(uint256 enabledTokensMask, uint256 bitsToEnable, uint256 bitsToDisable)\n        internal\n        pure\n        returns (uint256)\n    {\n        return (enabledTokensMask | bitsToEnable) & (~bitsToDisable); // U:[BM-5]\n    }\n\n    /// @dev Returns a mask with only the least significant bit of `mask` enabled\n    /// @dev This function can be used to efficiently iterate over enabled bits in a mask\n    function lsbMask(uint256 mask) internal pure returns (uint256) {\n        unchecked {\n            return mask & uint256(-int256(mask)); // U:[BM-6]\n        }\n    }\n}\n"
    },
    "lib/@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "lib/@1inch/solidity-utils/contracts/interfaces/IDaiLikePermit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title IDaiLikePermit\n * @dev Interface for Dai-like permit function allowing token spending via signatures.\n */\ninterface IDaiLikePermit {\n    /**\n     * @notice Approves spending of tokens via off-chain signatures.\n     * @param holder Token holder's address.\n     * @param spender Spender's address.\n     * @param nonce Current nonce of the holder.\n     * @param expiry Time when the permit expires.\n     * @param allowed True to allow, false to disallow spending.\n     * @param v, r, s Signature components.\n     */\n    function permit(\n        address holder,\n        address spender,\n        uint256 nonce,\n        uint256 expiry,\n        bool allowed,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n"
    },
    "lib/@1inch/solidity-utils/contracts/interfaces/IPermit2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title IPermit2\n * @dev Interface for a flexible permit system that extends ERC20 tokens to support permits in tokens lacking native permit functionality.\n */\ninterface IPermit2 {\n    /**\n     * @dev Struct for holding permit details.\n     * @param token ERC20 token address for which the permit is issued.\n     * @param amount The maximum amount allowed to spend.\n     * @param expiration Timestamp until which the permit is valid.\n     * @param nonce An incrementing value for each signature, unique per owner, token, and spender.\n     */\n    struct PermitDetails {\n        address token;\n        uint160 amount;\n        uint48 expiration;\n        uint48 nonce;\n    }\n\n    /**\n     * @dev Struct for a single token allowance permit.\n     * @param details Permit details including token, amount, expiration, and nonce.\n     * @param spender Address authorized to spend the tokens.\n     * @param sigDeadline Deadline for the permit signature, ensuring timeliness of the permit.\n     */\n    struct PermitSingle {\n        PermitDetails details;\n        address spender;\n        uint256 sigDeadline;\n    }\n\n    /**\n     * @dev Struct for packed allowance data to optimize storage.\n     * @param amount Amount allowed.\n     * @param expiration Permission expiry timestamp.\n     * @param nonce Unique incrementing value for tracking allowances.\n     */\n    struct PackedAllowance {\n        uint160 amount;\n        uint48 expiration;\n        uint48 nonce;\n    }\n\n    /**\n     * @notice Executes a token transfer from one address to another.\n     * @param user The token owner's address.\n     * @param spender The address authorized to spend the tokens.\n     * @param amount The amount of tokens to transfer.\n     * @param token The address of the token being transferred.\n     */\n    function transferFrom(address user, address spender, uint160 amount, address token) external;\n\n    /**\n     * @notice Issues a permit for spending tokens via a signed authorization.\n     * @param owner The token owner's address.\n     * @param permitSingle Struct containing the permit details.\n     * @param signature The signature proving the owner authorized the permit.\n     */\n    function permit(address owner, PermitSingle memory permitSingle, bytes calldata signature) external;\n\n    /**\n     * @notice Retrieves the allowance details between a token owner and spender.\n     * @param user The token owner's address.\n     * @param token The token address.\n     * @param spender The spender's address.\n     * @return The packed allowance details.\n     */\n    function allowance(address user, address token, address spender) external view returns (PackedAllowance memory);\n\n    /**\n     * @notice Approves the spender to use up to amount of the specified token up until the expiration\n     * @param token The token to approve\n     * @param spender The spender address to approve\n     * @param amount The approved amount of the token\n     * @param expiration The timestamp at which the approval is no longer valid\n     * @dev The packed allowance also holds a nonce, which will stay unchanged in approve\n     * @dev Setting amount to type(uint160).max sets an unlimited approval\n     */\n    function approve(address token, address spender, uint160 amount, uint48 expiration) external;\n}\n"
    },
    "lib/@1inch/solidity-utils/contracts/interfaces/IERC7597Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title IERC7597Permit\n * @dev A new extension for ERC-2612 permit, which has already been added to USDC v2.2.\n */\ninterface IERC7597Permit {\n    /**\n     * @notice Update allowance with a signed permit.\n     * @dev Signature bytes can be used for both EOA wallets and contract wallets.\n     * @param owner Token owner's address (Authorizer).\n     * @param spender Spender's address.\n     * @param value Amount of allowance.\n     * @param deadline The time at which the signature expires (unixtime).\n     * @param signature Unstructured bytes signature signed by an EOA wallet or a contract wallet.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        bytes memory signature\n    ) external;\n}\n"
    },
    "lib/@1inch/solidity-utils/contracts/interfaces/IWETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title IWETH\n * @dev Interface for wrapper as WETH-like token.\n */\ninterface IWETH is IERC20 {\n    /**\n     * @notice Emitted when Ether is deposited to get wrapper tokens.\n     */\n    event Deposit(address indexed dst, uint256 wad);\n\n    /**\n     * @notice Emitted when wrapper tokens is withdrawn as Ether.\n     */\n    event Withdrawal(address indexed src, uint256 wad);\n\n    /**\n     * @notice Deposit Ether to get wrapper tokens.\n     */\n    function deposit() external payable;\n\n    /**\n     * @notice Withdraw wrapped tokens as Ether.\n     * @param amount Amount of wrapped tokens to withdraw.\n     */\n    function withdraw(uint256 amount) external;\n}\n"
    },
    "lib/@1inch/solidity-utils/contracts/libraries/RevertReasonForwarder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title RevertReasonForwarder\n * @notice Provides utilities for forwarding and retrieving revert reasons from failed external calls.\n */\nlibrary RevertReasonForwarder {\n    /**\n     * @dev Forwards the revert reason from the latest external call.\n     * This method allows propagating the revert reason of a failed external call to the caller.\n     */\n    function reRevert() internal pure {\n        // bubble up revert reason from latest external call\n        assembly (\"memory-safe\") { // solhint-disable-line no-inline-assembly\n            let ptr := mload(0x40)\n            returndatacopy(ptr, 0, returndatasize())\n            revert(ptr, returndatasize())\n        }\n    }\n\n    /**\n     * @dev Retrieves the revert reason from the latest external call.\n     * This method enables capturing the revert reason of a failed external call for inspection or processing.\n     * @return reason The latest external call revert reason.\n     */\n    function reReason() internal pure returns (bytes memory reason) {\n        assembly (\"memory-safe\") { // solhint-disable-line no-inline-assembly\n            reason := mload(0x40)\n            let length := returndatasize()\n            mstore(reason, length)\n            returndatacopy(add(reason, 0x20), 0, length)\n            mstore(0x40, add(reason, add(0x20, length)))\n        }\n    }\n}\n"
    },
    "lib/@gearbox-protocol/core-v3/contracts/interfaces/IExceptions.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Foundation, 2024.\npragma solidity ^0.8.17;\n\n// ------- //\n// GENERAL //\n// ------- //\n\n/// @notice Thrown on attempting to set an important address to zero address\nerror ZeroAddressException();\n\n/// @notice Thrown when attempting to pass a zero amount to a funding-related operation\nerror AmountCantBeZeroException();\n\n/// @notice Thrown on incorrect input parameter\nerror IncorrectParameterException();\n\n/// @notice Thrown when balance is insufficient to perform an operation\nerror InsufficientBalanceException();\n\n/// @notice Thrown if parameter is out of range\nerror ValueOutOfRangeException();\n\n/// @notice Thrown when trying to send ETH to a contract that is not allowed to receive ETH directly\nerror ReceiveIsNotAllowedException();\n\n/// @notice Thrown on attempting to set an EOA as an important contract in the system\nerror AddressIsNotContractException(address);\n\n/// @notice Thrown on attempting to receive a token that is not a collateral token or was forbidden\nerror TokenNotAllowedException();\n\n/// @notice Thrown on attempting to add a token that is already in a collateral list\nerror TokenAlreadyAddedException();\n\n/// @notice Thrown when attempting to use quota-related logic for a token that is not quoted in quota keeper\nerror TokenIsNotQuotedException();\n\n/// @notice Thrown on attempting to interact with an address that is not a valid target contract\nerror TargetContractNotAllowedException();\n\n/// @notice Thrown if function is not implemented\nerror NotImplementedException();\n\n// ------------------ //\n// CONTRACTS REGISTER //\n// ------------------ //\n\n/// @notice Thrown when an address is expected to be a registered credit manager, but is not\nerror RegisteredCreditManagerOnlyException();\n\n/// @notice Thrown when an address is expected to be a registered pool, but is not\nerror RegisteredPoolOnlyException();\n\n// ---------------- //\n// ADDRESS PROVIDER //\n// ---------------- //\n\n/// @notice Reverts if address key isn't found in address provider\nerror AddressNotFoundException();\n\n// ----------------- //\n// POOL, PQK, GAUGES //\n// ----------------- //\n\n/// @notice Thrown by pool-adjacent contracts when a credit manager being connected has a wrong pool address\nerror IncompatibleCreditManagerException();\n\n/// @notice Thrown when attempting to set an incompatible successor staking contract\nerror IncompatibleSuccessorException();\n\n/// @notice Thrown when attempting to vote in a non-approved contract\nerror VotingContractNotAllowedException();\n\n/// @notice Thrown when attempting to unvote more votes than there are\nerror InsufficientVotesException();\n\n/// @notice Thrown when attempting to borrow more than the second point on a two-point curve\nerror BorrowingMoreThanU2ForbiddenException();\n\n/// @notice Thrown when a credit manager attempts to borrow more than its limit in the current block, or in general\nerror CreditManagerCantBorrowException();\n\n/// @notice Thrown when attempting to connect a quota keeper to an incompatible pool\nerror IncompatiblePoolQuotaKeeperException();\n\n/// @notice Thrown when attempting to connect a gauge to an incompatible pool quota keeper\nerror IncompatibleGaugeException();\n\n/// @notice Thrown when the quota is outside of min/max bounds\nerror QuotaIsOutOfBoundsException();\n\n// -------------- //\n// CREDIT MANAGER //\n// -------------- //\n\n/// @notice Thrown on failing a full collateral check after multicall\nerror NotEnoughCollateralException();\n\n/// @notice Thrown if an attempt to approve a collateral token to adapter's target contract fails\nerror AllowanceFailedException();\n\n/// @notice Thrown on attempting to perform an action for a credit account that does not exist\nerror CreditAccountDoesNotExistException();\n\n/// @notice Thrown on configurator attempting to add more than 255 collateral tokens\nerror TooManyTokensException();\n\n/// @notice Thrown if more than the maximum number of tokens were enabled on a credit account\nerror TooManyEnabledTokensException();\n\n/// @notice Thrown when attempting to execute a protocol interaction without active credit account set\nerror ActiveCreditAccountNotSetException();\n\n/// @notice Thrown when trying to update credit account's debt more than once in the same block\nerror DebtUpdatedTwiceInOneBlockException();\n\n/// @notice Thrown when trying to repay all debt while having active quotas\nerror DebtToZeroWithActiveQuotasException();\n\n/// @notice Thrown when a zero-debt account attempts to update quota\nerror UpdateQuotaOnZeroDebtAccountException();\n\n/// @notice Thrown when attempting to close an account with non-zero debt\nerror CloseAccountWithNonZeroDebtException();\n\n/// @notice Thrown when value of funds remaining on the account after liquidation is insufficient\nerror InsufficientRemainingFundsException();\n\n/// @notice Thrown when Credit Facade tries to write over a non-zero active Credit Account\nerror ActiveCreditAccountOverridenException();\n\n// ------------------- //\n// CREDIT CONFIGURATOR //\n// ------------------- //\n\n/// @notice Thrown on attempting to use a non-ERC20 contract or an EOA as a token\nerror IncorrectTokenContractException();\n\n/// @notice Thrown if the newly set LT if zero or greater than the underlying's LT\nerror IncorrectLiquidationThresholdException();\n\n/// @notice Thrown if borrowing limits are incorrect: minLimit > maxLimit or maxLimit > blockLimit\nerror IncorrectLimitsException();\n\n/// @notice Thrown if the new expiration date is less than the current expiration date or current timestamp\nerror IncorrectExpirationDateException();\n\n/// @notice Thrown if a contract returns a wrong credit manager or reverts when trying to retrieve it\nerror IncompatibleContractException();\n\n/// @notice Thrown if attempting to forbid an adapter that is not registered in the credit manager\nerror AdapterIsNotRegisteredException();\n\n/// @notice Thrown if new credit configurator's set of allowed adapters differs from the current one\nerror IncorrectAdaptersSetException();\n\n/// @notice Thrown if attempting to schedule a token's LT ramping that is too short in duration\nerror RampDurationTooShortException();\n\n/// @notice Thrown if attempting to set liquidation fees such that the sum of premium and fee changes\nerror InconsistentLiquidationFeesException();\n\n/// @notice Thrown if attempting to set expired liquidation fees such that the sum of premium and fee changes\nerror InconsistentExpiredLiquidationFeesException();\n\n// ------------- //\n// CREDIT FACADE //\n// ------------- //\n\n/// @notice Thrown when attempting to perform an action that is forbidden in whitelisted mode\nerror ForbiddenInWhitelistedModeException();\n\n/// @notice Thrown if credit facade is not expirable, and attempted aciton requires expirability\nerror NotAllowedWhenNotExpirableException();\n\n/// @notice Thrown if a selector that doesn't match any allowed function is passed to the credit facade in a multicall\nerror UnknownMethodException(bytes4 selector);\n\n/// @notice Thrown if a liquidator tries to liquidate an account with a health factor above 1\nerror CreditAccountNotLiquidatableException();\n\n/// @notice Thrown if a liquidator tries to liquidate an account with loss but violates the loss policy\nerror CreditAccountNotLiquidatableWithLossException();\n\n/// @notice Thrown if too much new debt was taken within a single block\nerror BorrowedBlockLimitException();\n\n/// @notice Thrown if the new debt principal for a credit account falls outside of borrowing limits\nerror BorrowAmountOutOfLimitsException();\n\n/// @notice Thrown if a user attempts to open an account via an expired credit facade\nerror NotAllowedAfterExpirationException();\n\n/// @notice Thrown if expected balances are attempted to be set twice without performing a slippage check\nerror ExpectedBalancesAlreadySetException();\n\n/// @notice Thrown if attempting to perform a slippage check when excepted balances are not set\nerror ExpectedBalancesNotSetException();\n\n/// @notice Thrown if balance of at least one token is less than expected during a slippage check\nerror BalanceLessThanExpectedException(address token);\n\n/// @notice Thrown when trying to perform an action that is forbidden when credit account has enabled forbidden tokens\nerror ForbiddenTokensException(uint256 forbiddenTokensMask);\n\n/// @notice Thrown when forbidden token quota is increased during the multicall\nerror ForbiddenTokenQuotaIncreasedException(address token);\n\n/// @notice Thrown when enabled forbidden token balance is increased during the multicall\nerror ForbiddenTokenBalanceIncreasedException(address token);\n\n/// @notice Thrown when the remaining token balance is increased during the liquidation\nerror RemainingTokenBalanceIncreasedException(address token);\n\n/// @notice Thrown if `botMulticall` is called by an address that is not approved by account owner or is forbidden\nerror NotApprovedBotException(address bot);\n\n/// @notice Thrown when attempting to perform a multicall action with no permission for it\nerror NoPermissionException(uint256 permission);\n\n/// @notice Thrown when attempting to give a bot unexpected permissions\nerror UnexpectedPermissionsException(uint256 permissions);\n\n/// @notice Thrown when a custom HF parameter lower than 10000 is passed into the full collateral check\nerror CustomHealthFactorTooLowException();\n\n/// @notice Thrown when submitted collateral hint is not a valid token mask\nerror InvalidCollateralHintException(uint256 mask);\n\n/// @notice Thrown when trying to seize underlying token during partial liquidation\nerror UnderlyingIsNotLiquidatableException();\n\n/// @notice Thrown when amount of collateral seized during partial liquidation is less than required\nerror SeizedLessThanRequiredException(uint256 seizedAmount);\n\n// ------ //\n// ACCESS //\n// ------ //\n\n/// @notice Thrown on attempting to call an access restricted function not as credit account owner\nerror CallerNotCreditAccountOwnerException();\n\n/// @notice Thrown on attempting to call an access restricted function not as configurator\nerror CallerNotConfiguratorException();\n\n/// @notice Thrown on attempting to call an access-restructed function not as account factory\nerror CallerNotAccountFactoryException();\n\n/// @notice Thrown on attempting to call an access restricted function not as credit manager\nerror CallerNotCreditManagerException();\n\n/// @notice Thrown on attempting to call an access restricted function not as credit facade\nerror CallerNotCreditFacadeException();\n\n/// @notice Thrown on attempting to pause a contract without pausable admin rights\nerror CallerNotPausableAdminException();\n\n/// @notice Thrown on attempting to unpause a contract without unpausable admin rights\nerror CallerNotUnpausableAdminException();\n\n/// @notice Thrown on attempting to call an access restricted function not as gauge\nerror CallerNotGaugeException();\n\n/// @notice Thrown on attempting to call an access restricted function not as quota keeper\nerror CallerNotPoolQuotaKeeperException();\n\n/// @notice Thrown on attempting to call an access restricted function not as voter\nerror CallerNotVoterException();\n\n/// @notice Thrown on attempting to call an access restricted function not as allowed adapter\nerror CallerNotAdapterException();\n\n/// @notice Thrown on attempting to call an access restricted function not as migrator\nerror CallerNotMigratorException();\n\n/// @notice Thrown when an address that is not the designated executor attempts to execute a transaction\nerror CallerNotExecutorException();\n\n/// @notice Thrown on attempting to call an access restricted function not as veto admin\nerror CallerNotVetoAdminException();\n\n// -------- //\n// BOT LIST //\n// -------- //\n\n/// @notice Thrown when attempting to set non-zero permissions for a forbidden bot\nerror InvalidBotException();\n\n/// @notice Thrown when attempting to set permissions for a bot that don't meet its requirements\nerror IncorrectBotPermissionsException();\n\n/// @notice Thrown when attempting to set non-zero permissions for too many bots\nerror TooManyActiveBotsException();\n\n// --------------- //\n// ACCOUNT FACTORY //\n// --------------- //\n\n/// @notice Thrown when trying to deploy second master credit account for a credit manager\nerror MasterCreditAccountAlreadyDeployedException();\n\n/// @notice Thrown when trying to rescue funds from a credit account that is currently in use\nerror CreditAccountIsInUseException();\n\n// ------------ //\n// PRICE ORACLE //\n// ------------ //\n\n/// @notice Thrown on attempting to set a token price feed to an address that is not a correct price feed\nerror IncorrectPriceFeedException();\n\n/// @notice Thrown on attempting to interact with a price feed for a token not added to the price oracle\nerror PriceFeedDoesNotExistException();\n\n/// @notice Thrown when trying to apply an on-demand price update to a non-updatable price feed\nerror PriceFeedIsNotUpdatableException();\n\n/// @notice Thrown when price feed returns incorrect price for a token\nerror IncorrectPriceException();\n\n/// @notice Thrown when token's price feed becomes stale\nerror StalePriceException();\n"
    }
  },
  "settings": {
    "remappings": [
      "ds-test/=lib/forge-std/lib/ds-test/src/",
      "forge-std/=lib/forge-std/src/",
      "@openzeppelin/=lib/@openzeppelin/",
      "@1inch/=lib/@1inch/",
      "@chainlink/=node_modules/@chainlink/",
      "@gearbox-protocol/=lib/@gearbox-protocol/",
      "@redstone-finance/=node_modules/@redstone-finance/",
      "@solady/=lib/@gearbox-protocol/oracles-v3/lib/@solady/src/",
      "erc4626-tests/=lib/@openzeppelin/lib/erc4626-tests/",
      "openzeppelin/=lib/@openzeppelin/contracts/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 1000
    },
    "metadata": {
      "useLiteralContent": false,
      "bytecodeHash": "ipfs",
      "appendCBOR": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "evmVersion": "shanghai",
    "viaIR": false,
    "libraries": {}
  }
}}