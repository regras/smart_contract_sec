{{
  "language": "Solidity",
  "sources": {
    "contracts/workers/BalancerV2Worker.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Holdings, 2025\npragma solidity ^0.8.23;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IAdapter} from \"@gearbox-protocol/core-v3/contracts/interfaces/base/IAdapter.sol\";\nimport {RouterComponentConfigurator} from \"../helpers/RouterComponentConfigurator.sol\";\n\nimport {BalancerV2VaultAdapter} from\n    \"@gearbox-protocol/integrations-v3/contracts/adapters/balancer/BalancerV2VaultAdapter.sol\";\nimport {\n    IBalancerV2Vault,\n    SingleSwap,\n    FundManagement,\n    SwapKind,\n    BatchSwapStep,\n    JoinPoolRequest,\n    ExitPoolRequest,\n    IAsset\n} from \"@gearbox-protocol/integrations-v3/contracts/integrations/balancer/IBalancerV2Vault.sol\";\nimport {IBalancerWeightedPool} from\n    \"@gearbox-protocol/integrations-v3/contracts/integrations/balancer/IBalancerWeightedPool.sol\";\nimport {IBalancerQueries} from \"@gearbox-protocol/integrations-v3/contracts/integrations/balancer/IBalancerQueries.sol\";\nimport {\n    IBalancerV2VaultAdapter,\n    SingleSwapDiff,\n    PoolStatus\n} from \"@gearbox-protocol/integrations-v3/contracts/interfaces/balancer/IBalancerV2VaultAdapter.sol\";\n\nimport {MultiCall} from \"../lib/MultiCall.sol\";\nimport {Graph, Vertex, Edge, GraphOps} from \"../data/Graph.sol\";\nimport {AddressList} from \"../helpers/AddressList.sol\";\nimport {IWorkerNonLinear} from \"../interfaces/IWorker.sol\";\n\ninterface IBalancerComposablePool {\n    function getBptIndex() external view returns (uint256);\n}\n\ncontract BalancerV2Worker is IWorkerNonLinear, RouterComponentConfigurator {\n    using AddressList for address[];\n    using GraphOps for Graph;\n\n    enum Action {\n        SWAP,\n        JOIN,\n        EXIT\n    }\n\n    bytes32 public constant override contractType = \"RC::BALANCER_V2_WORKER\";\n    uint256 public constant override version = 3_10;\n    bool public constant override isNonLinear = true;\n\n    IBalancerQueries public immutable queries;\n\n    constructor(address _router, address _queries) RouterComponentConfigurator(_router) {\n        queries = IBalancerQueries(_queries);\n    }\n\n    function getMulticalls(Edge memory edge, Graph memory graph)\n        external\n        view\n        returns (MultiCall[] memory calls, Graph memory)\n    {\n        (Action action, bytes32 poolId,) = abi.decode(edge.extraData, (Action, bytes32, uint256));\n\n        calls = new MultiCall[](1);\n\n        Vertex memory vertex = graph.getVertex(edge.tokenIn);\n\n        if (vertex.balance == edge.amountInTotal) {\n            edge.amountInTotal -= 1;\n        }\n\n        uint256 amount = vertex.balance - edge.amountInTotal;\n\n        vertex.balance -= edge.amountInTotal;\n        graph.getVertex(edge.tokenOut).balance += edge.amountOutTotal;\n\n        if (action == Action.SWAP) {\n            SingleSwapDiff memory params = SingleSwapDiff({\n                poolId: poolId,\n                assetIn: IAsset(edge.tokenIn),\n                assetOut: IAsset(edge.tokenOut),\n                leftoverAmount: amount,\n                userData: \"\"\n            });\n\n            calls[0] = MultiCall({\n                target: edge.adapter,\n                callData: abi.encodeCall(IBalancerV2VaultAdapter.swapDiff, (params, 0, block.timestamp + 3600))\n            });\n        } else if (action == Action.JOIN) {\n            calls[0] = MultiCall({\n                target: edge.adapter,\n                callData: abi.encodeCall(\n                    IBalancerV2VaultAdapter.joinPoolSingleAssetDiff, (poolId, IAsset(edge.tokenIn), amount, 0)\n                )\n            });\n        } else {\n            calls[0] = MultiCall({\n                target: edge.adapter,\n                callData: abi.encodeCall(\n                    IBalancerV2VaultAdapter.exitPoolSingleAssetDiff, (poolId, IAsset(edge.tokenOut), amount, 0)\n                )\n            });\n        }\n\n        return (calls, graph);\n    }\n\n    function getEdgeAmountOutCurrent(Edge memory edge, Graph memory graph) external returns (uint256) {\n        if (_hasInputThroughPool(edge, graph)) return 0;\n\n        if (_hasOtherActiveEdgesThroughPool(edge, graph)) {\n            return _approximateOutputFromAggregate(edge, graph);\n        } else {\n            return _getSingleActionOutput(edge, graph);\n        }\n    }\n\n    function _approximateOutputFromAggregate(Edge memory edge, Graph memory graph) internal returns (uint256) {\n        (Action action, bytes32 poolId,) = abi.decode(edge.extraData, (Action, bytes32, uint256));\n\n        if (action == Action.SWAP) {\n            uint256 lpEquivalentInputs = _getLpEquivalentInputs(edge.amountInCurrent, edge, graph);\n            uint256 lpEquivalentOutputs = _getLpEquivalentOutputs(0, edge, graph);\n\n            if (lpEquivalentInputs < lpEquivalentOutputs) return 0;\n\n            uint256 amountOut =\n                _getSingleAssetExitAmount(edge.adapter, poolId, edge.tokenOut, lpEquivalentInputs - lpEquivalentOutputs);\n\n            uint256 lpEquivalentOutputsAfter = _getLpEquivalentOutputs(amountOut, edge, graph);\n\n            if (lpEquivalentOutputsAfter > lpEquivalentInputs) return amountOut;\n\n            amountOut = amountOut\n                + amountOut * (lpEquivalentInputs - lpEquivalentOutputsAfter) / (lpEquivalentInputs - lpEquivalentOutputs);\n\n            return amountOut;\n        } else if (action == Action.JOIN) {\n            uint256 lpEquivalentInputs = _getLpEquivalentInputs(edge.amountInCurrent, edge, graph);\n            uint256 lpEquivalentOutputs = _getLpEquivalentOutputs(0, edge, graph);\n\n            return lpEquivalentInputs - lpEquivalentOutputs;\n        } else {\n            uint256 amountOut = _getSingleAssetExitAmount(edge.adapter, poolId, edge.tokenOut, edge.amountInCurrent);\n\n            uint256 lpEquivalentInputs = _getLpEquivalentInputs(0, edge, graph) + edge.amountInCurrent;\n            uint256 lpEquivalentOutputs = _getLpEquivalentOutputs(amountOut, edge, graph);\n\n            if (lpEquivalentOutputs > lpEquivalentInputs) return amountOut;\n\n            amountOut = amountOut + amountOut * (lpEquivalentInputs - lpEquivalentOutputs) / edge.amountInCurrent;\n\n            return amountOut;\n        }\n    }\n\n    function _getSingleActionOutput(Edge memory edge, Graph memory) internal returns (uint256 amountOut) {\n        (Action action, bytes32 poolId,) = abi.decode(edge.extraData, (Action, bytes32, uint256));\n\n        if (action == Action.SWAP) {\n            amountOut = _getSingleAssetSwapAmount(\n                edge.adapter, poolId, edge.tokenIn, edge.tokenOut, edge.amountInCurrent + edge.amountInTotal\n            );\n        } else if (action == Action.JOIN) {\n            amountOut = _getSingleAssetJoinAmount(edge.adapter, poolId, edge.tokenIn, edge.amountInCurrent);\n        } else {\n            amountOut = _getSingleAssetExitAmount(edge.adapter, poolId, edge.tokenOut, edge.amountInCurrent);\n        }\n\n        return amountOut < edge.amountOutTotal ? 0 : amountOut - edge.amountOutTotal;\n    }\n\n    function buildEdges(Graph memory graph, address adapter) external view returns (Graph memory) {\n        bytes32[] memory poolIds = BalancerV2VaultAdapter(adapter).supportedPoolIds();\n\n        for (uint256 i = 0; i < poolIds.length; i++) {\n            PoolStatus status = IBalancerV2VaultAdapter(adapter).poolStatus(poolIds[i]);\n\n            (address pool,) = IBalancerV2Vault(IAdapter(adapter).targetContract()).getPool(poolIds[i]);\n            (IERC20[] memory tokens,,) = IBalancerV2Vault(IAdapter(adapter).targetContract()).getPoolTokens(poolIds[i]);\n\n            for (uint256 j = 0; j < tokens.length; j++) {\n                if (address(tokens[j]) != pool) {\n                    if (status == PoolStatus.ALLOWED) {\n                        graph.appendEdge(\n                            address(tokens[j]), pool, abi.encode(Action.JOIN, poolIds[i], j, 0), adapter, address(this)\n                        );\n                    }\n\n                    graph.appendEdge(\n                        pool, address(tokens[j]), abi.encode(Action.EXIT, poolIds[i], 0, j), adapter, address(this)\n                    );\n                }\n            }\n\n            if (status == PoolStatus.ALLOWED || status == PoolStatus.SWAP_ONLY) {\n                for (uint256 j = 0; j < tokens.length; j++) {\n                    for (uint256 k = j + 1; k < tokens.length; k++) {\n                        if (address(tokens[j]) != pool && address(tokens[k]) != pool) {\n                            graph.appendEdge(\n                                address(tokens[j]),\n                                address(tokens[k]),\n                                abi.encode(Action.SWAP, poolIds[i], j, k),\n                                adapter,\n                                address(this)\n                            );\n\n                            graph.appendEdge(\n                                address(tokens[k]),\n                                address(tokens[j]),\n                                abi.encode(Action.SWAP, poolIds[i], k, j),\n                                adapter,\n                                address(this)\n                            );\n                        }\n                    }\n                }\n            }\n        }\n\n        return graph;\n    }\n\n    function trimSpecialVertex(Edge memory edge, Graph memory graph, address targetToken)\n        external\n        view\n        returns (bool)\n    {\n        (Action action, bytes32 poolId,) = abi.decode(edge.extraData, (Action, bytes32, uint256));\n\n        if (action == Action.JOIN) {\n            address lpToken = edge.tokenOut;\n            if (lpToken != targetToken && graph.getBalanceDiff(lpToken) <= 1) {\n                address[] memory neighbors = graph.getNeighborsOf(lpToken);\n                (IERC20[] memory poolTokens,,) =\n                    IBalancerV2Vault(IAdapter(edge.adapter).targetContract()).getPoolTokens(poolId);\n                if (neighbors.length <= poolTokens.length) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    function _hasInputThroughPool(Edge memory edge, Graph memory graph) internal view returns (bool) {\n        (, bytes32 edgePoolId,) = abi.decode(edge.extraData, (Action, bytes32, uint256));\n        Edge[] memory workerEdges = graph.getWorkerEdges(address(this));\n\n        for (uint256 i = 0; i < workerEdges.length; i++) {\n            (, bytes32 poolId,) = abi.decode(workerEdges[i].extraData, (Action, bytes32, uint256));\n\n            if (\n                poolId == edgePoolId\n                    && (workerEdges[i].tokenOut == edge.tokenIn || workerEdges[i].tokenIn == edge.tokenOut)\n                    && workerEdges[i].amountOutCurrent > 1\n            ) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    function _hasOtherActiveEdgesThroughPool(Edge memory edge, Graph memory graph) internal view returns (bool) {\n        (, bytes32 edgePoolId,) = abi.decode(edge.extraData, (Action, bytes32, uint256));\n        Edge[] memory workerEdges = graph.getWorkerEdges(address(this));\n\n        for (uint256 i = 0; i < workerEdges.length; i++) {\n            (, bytes32 poolId,) = abi.decode(workerEdges[i].extraData, (Action, bytes32, uint256));\n\n            if (\n                poolId == edgePoolId\n                    && (workerEdges[i].tokenIn != edge.tokenIn || workerEdges[i].tokenOut != edge.tokenOut)\n                    && workerEdges[i].amountInTotal > 1\n            ) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    function _getDefaultFundManagement() internal pure returns (FundManagement memory) {\n        return FundManagement({\n            sender: address(0),\n            fromInternalBalance: false,\n            recipient: payable(address(0)),\n            toInternalBalance: false\n        });\n    }\n\n    function _getPoolTokens(address adapter, bytes32 poolId, bool raw)\n        internal\n        view\n        returns (address[] memory tokens)\n    {\n        address vault = IAdapter(adapter).targetContract();\n\n        (address pool,) = IBalancerV2Vault(vault).getPool(poolId);\n        (IERC20[] memory poolTokens,,) = IBalancerV2Vault(vault).getPoolTokens(poolId);\n        uint256 len = poolTokens.length;\n        tokens = new address[](len);\n        uint256 k = 0;\n\n        for (uint256 i = 0; i < len; ++i) {\n            if (address(poolTokens[i]) != pool || raw) {\n                tokens[k] = address(poolTokens[i]);\n                ++k;\n            }\n        }\n\n        return tokens.trim();\n    }\n\n    function _getPool(address adapter, bytes32 poolId) internal view returns (address pool) {\n        address vault = IAdapter(adapter).targetContract();\n\n        (pool,) = IBalancerV2Vault(vault).getPool(poolId);\n    }\n\n    function _tokensToAssets(address[] memory tokens) internal pure returns (IAsset[] memory assets) {\n        uint256 len = tokens.length;\n        assets = new IAsset[](len);\n        for (uint256 i = 0; i < len; ++i) {\n            assets[i] = IAsset(tokens[i]);\n        }\n    }\n\n    function _getSingleAssetSwapAmount(\n        address adapter,\n        bytes32 poolId,\n        address assetIn,\n        address assetOut,\n        uint256 amountIn\n    ) internal returns (uint256 amountOut) {\n        address balancerVault = IAdapter(adapter).targetContract();\n\n        IAsset[] memory assets = new IAsset[](2);\n        assets[0] = IAsset(assetIn);\n        assets[1] = IAsset(assetOut);\n\n        BatchSwapStep[] memory swaps = new BatchSwapStep[](1);\n\n        swaps[0] = BatchSwapStep({poolId: poolId, assetInIndex: 0, assetOutIndex: 1, amount: amountIn, userData: \"\"});\n\n        int256[] memory deltas;\n\n        try IBalancerV2Vault(balancerVault).queryBatchSwap(\n            SwapKind.GIVEN_IN, swaps, assets, _getDefaultFundManagement()\n        ) returns (int256[] memory returnedDeltas) {\n            deltas = returnedDeltas;\n        } catch {\n            return 0;\n        }\n\n        return uint256(-deltas[1]);\n    }\n\n    function _getJoinSingleAssetRequest(address adapter, bytes32 poolId, address assetIn, uint256 amountIn, address bpt)\n        internal\n        view\n        returns (JoinPoolRequest memory request)\n    {\n        address[] memory tokens = _getPoolTokens(adapter, poolId, true);\n\n        uint256 len = tokens.length;\n\n        request.assets = new IAsset[](tokens.length);\n        request.maxAmountsIn = new uint256[](tokens.length);\n\n        for (uint256 i; i < len; ++i) {\n            request.assets[i] = IAsset(tokens[i]);\n\n            if (tokens[i] == assetIn) {\n                request.maxAmountsIn[i] = amountIn;\n            }\n        }\n\n        request.userData = abi.encode(uint256(1), _removeBptAmount(bpt, request.assets, request.maxAmountsIn), 0);\n\n        return request;\n    }\n\n    function _getSingleAssetJoinAmount(address adapter, bytes32 poolId, address assetIn, uint256 amountIn)\n        internal\n        returns (uint256 amountOut)\n    {\n        JoinPoolRequest memory request =\n            _getJoinSingleAssetRequest(adapter, poolId, assetIn, amountIn, _getPool(adapter, poolId));\n\n        (amountOut,) = queries.queryJoin(poolId, address(0), address(0), request);\n    }\n\n    function _getExitSingleAssetRequest(\n        address adapter,\n        bytes32 poolId,\n        address assetOut,\n        uint256 amountIn,\n        address bpt\n    ) internal view returns (ExitPoolRequest memory request, uint256 tokenIndex) {\n        address[] memory tokens = _getPoolTokens(adapter, poolId, true);\n\n        uint256 len = tokens.length;\n\n        request.assets = new IAsset[](tokens.length);\n        request.minAmountsOut = new uint256[](tokens.length);\n        tokenIndex = tokens.length;\n        uint256 bptIndex = tokens.length;\n\n        for (uint256 i; i < len; ++i) {\n            request.assets[i] = IAsset(tokens[i]);\n\n            if (address(request.assets[i]) == assetOut) {\n                tokenIndex = i;\n            }\n\n            if (address(request.assets[i]) == bpt) {\n                bptIndex = i;\n            }\n        }\n\n        request.userData = abi.encode(uint256(0), amountIn, tokenIndex > bptIndex ? tokenIndex - 1 : tokenIndex);\n\n        return (request, tokenIndex);\n    }\n\n    function _getSingleAssetExitAmount(address adapter, bytes32 poolId, address assetOut, uint256 amountIn)\n        internal\n        returns (uint256)\n    {\n        (ExitPoolRequest memory request, uint256 tokenIndex) =\n            _getExitSingleAssetRequest(adapter, poolId, assetOut, amountIn, _getPool(adapter, poolId));\n\n        (, uint256[] memory amountsOut) = queries.queryExit(poolId, address(0), address(0), request);\n\n        return amountsOut[tokenIndex];\n    }\n\n    function _getLpEquivalentInputs(uint256 amountInOffset, Edge memory edge, Graph memory graph)\n        internal\n        returns (uint256 lpEquivalentInputs)\n    {\n        JoinPoolRequest memory request;\n        bytes32 poolId;\n        address bpt;\n\n        {\n            uint256 tokenIndex;\n            (, poolId, tokenIndex,) = abi.decode(edge.extraData, (Action, bytes32, uint256, uint256));\n            bpt = _getPool(edge.adapter, poolId);\n            request.assets = _tokensToAssets(_getPoolTokens(edge.adapter, poolId, true));\n            request.maxAmountsIn = new uint256[](request.assets.length);\n\n            request.maxAmountsIn[tokenIndex] += amountInOffset;\n        }\n\n        Edge[] memory workerEdges = graph.getWorkerEdges(address(this));\n\n        for (uint256 i = 0; i < request.assets.length; ++i) {\n            for (uint256 j = 0; j < workerEdges.length; ++j) {\n                (, bytes32 poolIdCurrent, uint256 tokenIndex,) =\n                    abi.decode(workerEdges[j].extraData, (Action, bytes32, uint256, uint256));\n\n                if (poolIdCurrent == poolId) {\n                    if (workerEdges[j].tokenIn == address(request.assets[i]) && workerEdges[j].tokenIn != bpt) {\n                        request.maxAmountsIn[tokenIndex] += workerEdges[j].amountInTotal;\n                    }\n                }\n            }\n        }\n\n        for (uint256 j = 0; j < workerEdges.length; ++j) {\n            if (workerEdges[j].tokenIn == bpt) {\n                lpEquivalentInputs += workerEdges[j].amountInTotal;\n            }\n        }\n\n        for (uint256 i = 0; i < request.maxAmountsIn.length; ++i) {\n            if (request.maxAmountsIn[i] > 0) {\n                break;\n            }\n\n            if (i == request.maxAmountsIn.length - 1) {\n                return lpEquivalentInputs;\n            }\n        }\n\n        request.userData = abi.encode(uint256(1), _removeBptAmount(bpt, request.assets, request.maxAmountsIn), 0);\n\n        (uint256 amountOut,) = queries.queryJoin(poolId, address(0), address(0), request);\n\n        return amountOut + lpEquivalentInputs;\n    }\n\n    function _getLpEquivalentOutputs(uint256 amountOutOffset, Edge memory edge, Graph memory graph)\n        internal\n        returns (uint256 lpEquivalentOutputs)\n    {\n        ExitPoolRequest memory request;\n        bytes32 poolId;\n        address bpt;\n\n        {\n            uint256 tokenIndex;\n            (, poolId,, tokenIndex) = abi.decode(edge.extraData, (Action, bytes32, uint256, uint256));\n            bpt = _getPool(edge.adapter, poolId);\n            request.assets = _tokensToAssets(_getPoolTokens(edge.adapter, poolId, true));\n            request.minAmountsOut = new uint256[](request.assets.length);\n\n            request.minAmountsOut[tokenIndex] += amountOutOffset;\n        }\n\n        Edge[] memory workerEdges = graph.getWorkerEdges(address(this));\n\n        for (uint256 i = 0; i < request.assets.length; ++i) {\n            for (uint256 j = 0; j < workerEdges.length; ++j) {\n                (, bytes32 poolIdCurrent,, uint256 tokenIndex) =\n                    abi.decode(workerEdges[j].extraData, (Action, bytes32, uint256, uint256));\n\n                if (poolIdCurrent == poolId) {\n                    if (workerEdges[j].tokenOut == address(request.assets[i]) && workerEdges[j].tokenOut != bpt) {\n                        request.minAmountsOut[tokenIndex] += workerEdges[j].amountOutTotal;\n                    }\n                }\n            }\n        }\n\n        for (uint256 j = 0; j < workerEdges.length; ++j) {\n            if (workerEdges[j].tokenOut == bpt) {\n                lpEquivalentOutputs += workerEdges[j].amountOutTotal;\n            }\n        }\n\n        for (uint256 i = 0; i < request.minAmountsOut.length; ++i) {\n            if (request.minAmountsOut[i] > 0) {\n                break;\n            }\n\n            if (i == request.minAmountsOut.length - 1) {\n                return lpEquivalentOutputs;\n            }\n        }\n\n        request.userData = abi.encode(\n            _isComposableStablePool(bpt) ? uint256(1) : uint256(2),\n            _removeBptAmount(bpt, request.assets, request.minAmountsOut),\n            type(uint256).max\n        );\n\n        (uint256 amountIn,) = queries.queryExit(poolId, address(0), address(0), request);\n\n        return amountIn + lpEquivalentOutputs;\n    }\n\n    function _removeBptAmount(address bpt, IAsset[] memory assets, uint256[] memory amounts)\n        internal\n        pure\n        returns (uint256[] memory newAmounts)\n    {\n        uint256 bptIndex = assets.length;\n\n        for (uint256 i = 0; i < assets.length; ++i) {\n            if (bpt == address(assets[i])) {\n                bptIndex = i;\n                break;\n            }\n        }\n\n        if (bptIndex == assets.length) return amounts;\n\n        newAmounts = new uint256[](assets.length - 1);\n\n        for (uint256 i = 0; i < assets.length - 1; ++i) {\n            if (i < bptIndex) {\n                newAmounts[i] = amounts[i];\n            } else {\n                newAmounts[i] = amounts[i + 1];\n            }\n        }\n    }\n\n    function _getAssetIndex(IAsset[] memory assets, address token) internal pure returns (uint256) {\n        uint256 len = assets.length;\n\n        for (uint256 i = 0; i < len; ++i) {\n            if (address(assets[i]) == token) return i;\n        }\n\n        revert(\"Error: Balancer asset index not found\");\n    }\n\n    function _isComposableStablePool(address pool) internal view returns (bool) {\n        try IBalancerComposablePool(pool).getBptIndex{gas: 100_000}() returns (uint256) {\n            return true;\n        } catch {\n            return false;\n        }\n    }\n\n    function processClaims(Edge memory, Graph memory graph, address)\n        external\n        pure\n        returns (Graph memory, MultiCall[] memory)\n    {\n        return (graph, new MultiCall[](0));\n    }\n}\n"
    },
    "lib/@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "lib/@gearbox-protocol/core-v3/contracts/interfaces/base/IAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Foundation, 2024.\npragma solidity ^0.8.17;\n\nimport {IVersion} from \"./IVersion.sol\";\nimport {IStateSerializer} from \"./IStateSerializer.sol\";\n\n/// @title Adapter interface\n/// @notice Generic interface for an adapter that can be used to interact with external protocols.\n///         Adapters can be assumed to be non-malicious since they are developed by Gearbox DAO.\n/// @dev Adapters must have type `ADAPTER::{POSTFIX}`\ninterface IAdapter is IVersion, IStateSerializer {\n    /// @notice Credit manager this adapter is connected to\n    /// @dev Assumed to be an immutable state variable\n    function creditManager() external view returns (address);\n\n    /// @notice Target contract adapter helps to interact with\n    /// @dev Assumed to be an immutable state variable\n    function targetContract() external view returns (address);\n}\n"
    },
    "contracts/helpers/RouterComponentConfigurator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Holdings, 2025\npragma solidity ^0.8.10;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {IAdapter} from \"@gearbox-protocol/core-v3/contracts/interfaces/base/IAdapter.sol\";\nimport {IGearboxRouter} from \"../interfaces/IGearboxRouter.sol\";\n\ncontract RouterComponentConfigurator {\n    IGearboxRouter public router;\n\n    event NewRouter(address indexed);\n\n    error RouterOnlyException();\n    error RouterOwnerOnlyException();\n    error FutureRouterOnlyException();\n    error MigrationErrorException();\n\n    constructor(address _router) {\n        router = IGearboxRouter(_router);\n    }\n\n    modifier routerOwnerOnly() {\n        if (!router.isRouterConfigurator(msg.sender)) {\n            revert RouterOwnerOnlyException();\n        }\n        _;\n    }\n\n    modifier routerOnly() {\n        if (msg.sender != address(router)) revert RouterOnlyException();\n        _;\n    }\n\n    modifier futureRouterOnly() {\n        if (msg.sender != router.futureRouter()) {\n            revert FutureRouterOnlyException();\n        }\n        _;\n    }\n\n    function migrate() external futureRouterOnly {\n        if (msg.sender != address(router)) {\n            router = IGearboxRouter(msg.sender);\n            emit NewRouter(msg.sender);\n        }\n    }\n\n    function updateRouter(address newRouter) external virtual routerOwnerOnly {\n        if (newRouter != address(router)) {\n            if (!IGearboxRouter(newRouter).isRouterConfigurator(msg.sender)) {\n                revert MigrationErrorException();\n            }\n\n            router = IGearboxRouter(newRouter);\n            emit NewRouter(newRouter);\n        }\n    }\n}\n"
    },
    "lib/@gearbox-protocol/integrations-v3/contracts/adapters/balancer/BalancerV2VaultAdapter.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Foundation, 2024.\npragma solidity ^0.8.23;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\nimport {RAY} from \"@gearbox-protocol/core-v3/contracts/libraries/Constants.sol\";\nimport {BitMask} from \"@gearbox-protocol/core-v3/contracts/libraries/BitMask.sol\";\n\nimport {AbstractAdapter} from \"../AbstractAdapter.sol\";\n\nimport {IAsset} from \"../../integrations/balancer/IAsset.sol\";\nimport {\n    IBalancerV2Vault,\n    SwapKind,\n    SingleSwap,\n    FundManagement,\n    BatchSwapStep,\n    JoinPoolRequest,\n    ExitPoolRequest\n} from \"../../integrations/balancer/IBalancerV2Vault.sol\";\nimport {\n    IBalancerV2VaultAdapter, SingleSwapDiff, PoolStatus\n} from \"../../interfaces/balancer/IBalancerV2VaultAdapter.sol\";\n\n/// @title Balancer V2 Vault adapter\n/// @notice Implements logic allowing CAs to swap through and LP in Balancer vaults\ncontract BalancerV2VaultAdapter is AbstractAdapter, IBalancerV2VaultAdapter {\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n    using BitMask for uint256;\n\n    bytes32 public constant override contractType = \"ADAPTER::BALANCER_VAULT\";\n    uint256 public constant override version = 3_10;\n\n    /// @notice Mapping from poolId to status of the pool: whether it is not supported, fully supported or swap-only\n    mapping(bytes32 => PoolStatus) public override poolStatus;\n\n    /// @dev Set of pool ids with \"ALLOW\" and \"SWAP_ONLY\" status\n    EnumerableSet.Bytes32Set internal _supportedPoolIds;\n\n    /// @notice Constructor\n    /// @param _creditManager Credit manager address\n    /// @param _vault Balancer vault address\n    constructor(address _creditManager, address _vault)\n        AbstractAdapter(_creditManager, _vault) // U:[BAL2-1]\n    {}\n\n    // ----- //\n    // SWAPS //\n    // ----- //\n\n    /// @notice Swaps a token for another token within a single pool\n    /// @param singleSwap Struct containing swap parameters\n    ///        * `poolId` - ID of the pool to perform a swap in\n    ///        * `kind` - type of swap (GIVEN IN / GIVEN OUT)\n    ///        * `assetIn` - asset to send\n    ///        * `assetOut` - asset to receive\n    ///        * `amount` - amount of input asset to send (for GIVEN IN) or output asset to receive (for GIVEN OUT)\n    ///        * `userData` - generic blob used to pass extra data\n    /// @param limit The minimal amount of `assetOut` to receive or maximal amount of `assetIn` to spend (depending on `kind`)\n    /// @param deadline The latest timestamp at which the swap would be executed\n    /// @dev `fundManagement` param from the original interface is ignored, as the adapter does not use internal balances and\n    ///       only has one sender/recipient\n    /// @dev The function reverts if the poolId status is not ALLOWED or SWAP_ONLY\n    function swap(SingleSwap memory singleSwap, FundManagement memory, uint256 limit, uint256 deadline)\n        external\n        override\n        creditFacadeOnly // U:[BAL2-2]\n        returns (bool)\n    {\n        PoolStatus pStatus = poolStatus[singleSwap.poolId];\n        if (pStatus != PoolStatus.ALLOWED && pStatus != PoolStatus.SWAP_ONLY) {\n            revert PoolNotSupportedException(); // U:[BAL2-3]\n        }\n\n        address creditAccount = _creditAccount(); // U:[BAL2-3]\n\n        address tokenIn = address(singleSwap.assetIn);\n\n        FundManagement memory fundManagement = _getDefaultFundManagement(creditAccount); // U:[BAL2-3]\n\n        _executeSwapSafeApprove(\n            tokenIn, abi.encodeCall(IBalancerV2Vault.swap, (singleSwap, fundManagement, limit, deadline))\n        ); // U:[BAL2-3]\n\n        return true;\n    }\n\n    /// @notice Swaps the entire balance of a token for another token within a single pool, except the specified amount\n    /// @param singleSwapDiff Struct containing swap parameters\n    ///        * `poolId` - ID of the pool to perform a swap in\n    ///        * `leftoverAmount` - amount of assetIn to leave after operation\n    ///        * `assetIn` - asset to send\n    ///        * `assetOut` - asset to receive\n    ///        * `userData` - additional generic blob used to pass extra data\n    /// @param limitRateRAY The minimal resulting exchange rate of assetOut to assetIn, scaled by 1e27\n    /// @param deadline The latest timestamp at which the swap would be executed\n    /// @dev The function reverts if the poolId status is not ALLOWED or SWAP_ONLY\n    function swapDiff(SingleSwapDiff memory singleSwapDiff, uint256 limitRateRAY, uint256 deadline)\n        external\n        override\n        creditFacadeOnly // U:[BAL2-2]\n        returns (bool)\n    {\n        PoolStatus pStatus = poolStatus[singleSwapDiff.poolId];\n        if (pStatus != PoolStatus.ALLOWED && pStatus != PoolStatus.SWAP_ONLY) {\n            revert PoolNotSupportedException(); // U:[BAL2-4]\n        }\n\n        address creditAccount = _creditAccount(); // U:[BAL2-4]\n\n        uint256 amount = IERC20(address(singleSwapDiff.assetIn)).balanceOf(creditAccount); // U:[BAL2-4]\n        if (amount <= singleSwapDiff.leftoverAmount) return false;\n\n        unchecked {\n            amount -= singleSwapDiff.leftoverAmount; // U:[BAL2-4]\n        }\n\n        FundManagement memory fundManagement = _getDefaultFundManagement(creditAccount); // U:[BAL2-4]\n\n        // calling `_executeSwap` because we need to check if output token is registered as collateral token in the CM\n        _executeSwapSafeApprove(\n            address(singleSwapDiff.assetIn),\n            abi.encodeCall(\n                IBalancerV2Vault.swap,\n                (\n                    SingleSwap({\n                        poolId: singleSwapDiff.poolId,\n                        kind: SwapKind.GIVEN_IN,\n                        assetIn: singleSwapDiff.assetIn,\n                        assetOut: singleSwapDiff.assetOut,\n                        amount: amount,\n                        userData: singleSwapDiff.userData\n                    }),\n                    fundManagement,\n                    (amount * limitRateRAY) / RAY,\n                    deadline\n                )\n            )\n        ); // U:[BAL2-4]\n\n        return true;\n    }\n\n    /// @notice Performs a multi-hop swap through several Balancer pools\n    /// @param kind Type of swap (GIVEN IN or GIVEN OUT)\n    /// @param swaps Array of structs containing data for each individual swap:\n    ///        * `poolId` - ID of the pool to perform a swap in\n    ///        * `assetInIndex` - Index of the input asset in the pool (in an alphanumerically sorted array of asset addresses)\n    ///        * `assetOutIndex` - Index of the output asset in the pool (in an alphanumerically sorted array of asset addresses)\n    ///        * `amount` - amount of asset to send / receive. 0 signals to either spend the entire amount received from the last step,\n    ///           or to receive the exact amount needed for the next step\n    ///        * `userData` - generic blob used to pass extra data\n    /// @param assets Array of all assets participating in the swap\n    /// @param limits Array of minimal received (negative) / maximal spent (positive) amounts, in the same order as the assets array\n    /// @param deadline The latest timestamp at which the swap would be executed\n    /// @dev `fundManagement` param from the original interface is ignored, as the adapter does not use internal balances and\n    ///       only has one sender/recipient\n    /// @dev The function reverts if any of the poolId statuses is not ALLOWED or SWAP_ONLY\n    function batchSwap(\n        SwapKind kind,\n        BatchSwapStep[] memory swaps,\n        IAsset[] memory assets,\n        FundManagement memory,\n        int256[] memory limits,\n        uint256 deadline\n    )\n        external\n        override\n        creditFacadeOnly // U:[BAL2-2]\n        returns (bool)\n    {\n        for (uint256 i; i < swaps.length; ++i) {\n            PoolStatus pStatus = poolStatus[swaps[i].poolId];\n            if (pStatus != PoolStatus.ALLOWED && pStatus != PoolStatus.SWAP_ONLY) {\n                revert PoolNotSupportedException(); // U:[BAL2-5]\n            }\n        }\n\n        address creditAccount = _creditAccount(); // U:[BAL2-5]\n\n        FundManagement memory fundManagement = _getDefaultFundManagement(creditAccount); // U:[BAL2-5]\n\n        _approveAssets(assets, limits, type(uint256).max); // U:[BAL2-5]\n\n        _execute(abi.encodeCall(IBalancerV2Vault.batchSwap, (kind, swaps, assets, fundManagement, limits, deadline))); // U:[BAL2-5]\n\n        _approveAssets(assets, limits, 1); // U:[BAL2-5]\n\n        return true;\n    }\n\n    // --------- //\n    // JOIN POOL //\n    // --------- //\n\n    /// @notice Deposits liquidity into a Balancer pool in exchange for BPT\n    /// @param poolId ID of the pool to deposit into\n    /// @param request A struct containing data for executing a deposit:\n    ///        * `assets` - Array of assets in the pool\n    ///        * `maxAmountsIn` - Array of maximal amounts to be spent for each asset\n    ///        * `userData` - a blob encoding the type of deposit and additional parameters\n    ///          (see https://dev.balancer.fi/resources/joins-and-exits/pool-joins#userdata for more info)\n    ///        * `fromInternalBalance` - whether to use internal balances for assets\n    ///          (ignored as the adapter does not use internal balances)\n    /// @dev `sender` and `recipient` are ignored, since they are always set to the CA address\n    /// @dev The function reverts if poolId status is not ALLOWED\n    function joinPool(bytes32 poolId, address, address, JoinPoolRequest memory request)\n        external\n        override\n        creditFacadeOnly // U:[BAL2-2]\n        returns (bool)\n    {\n        if (poolStatus[poolId] != PoolStatus.ALLOWED) {\n            revert PoolNotSupportedException(); // U:[BAL2-6]\n        }\n\n        address creditAccount = _creditAccount(); // U:[BAL2-6]\n\n        request.fromInternalBalance = false; // U:[BAL2-6]\n\n        _approveAssets(request.assets, request.maxAmountsIn, type(uint256).max); // U:[BAL2-6]\n        _execute(abi.encodeCall(IBalancerV2Vault.joinPool, (poolId, creditAccount, creditAccount, request))); // U:[BAL2-6]\n        _approveAssets(request.assets, request.maxAmountsIn, 1); // U:[BAL2-6]\n        return true;\n    }\n\n    /// @notice Deposits single asset as liquidity into a Balancer pool\n    /// @param poolId ID of the pool to deposit into\n    /// @param assetIn Asset to deposit\n    /// @param amountIn Amount of asset to deposit\n    /// @param minAmountOut The minimal amount of BPT to receive\n    /// @dev The function reverts if poolId status is not ALLOWED\n    function joinPoolSingleAsset(bytes32 poolId, IAsset assetIn, uint256 amountIn, uint256 minAmountOut)\n        external\n        override\n        creditFacadeOnly // U:[BAL2-2]\n        returns (bool)\n    {\n        if (poolStatus[poolId] != PoolStatus.ALLOWED) {\n            revert PoolNotSupportedException(); // U:[BAL2-7]\n        }\n\n        address creditAccount = _creditAccount(); // U:[BAL2-7]\n\n        _executeSwapSafeApprove(\n            address(assetIn),\n            abi.encodeCall(\n                IBalancerV2Vault.joinPool,\n                (\n                    poolId,\n                    creditAccount,\n                    creditAccount,\n                    _getJoinSingleAssetRequest(poolId, assetIn, amountIn, minAmountOut)\n                )\n            )\n        ); // U:[BAL2-7]\n        return true;\n    }\n\n    /// @notice Deposits the entire balance of given asset, except a specified amount, as liquidity into a Balancer pool\n    /// @param poolId ID of the pool to deposit into\n    /// @param assetIn Asset to deposit\n    /// @param leftoverAmount Amount of underlying to keep on the account\n    /// @param minRateRAY The minimal exchange rate of assetIn to BPT, scaled by 1e27\n    /// @dev The function reverts if poolId status is not ALLOWED\n    function joinPoolSingleAssetDiff(bytes32 poolId, IAsset assetIn, uint256 leftoverAmount, uint256 minRateRAY)\n        external\n        override\n        creditFacadeOnly // U:[BAL2-2]\n        returns (bool)\n    {\n        if (poolStatus[poolId] != PoolStatus.ALLOWED) {\n            revert PoolNotSupportedException(); // U:[BAL2-8]\n        }\n\n        address creditAccount = _creditAccount(); // U:[BAL2-8]\n\n        uint256 amount = IERC20(address(assetIn)).balanceOf(creditAccount); // U:[BAL2-8]\n        if (amount <= leftoverAmount) return false;\n\n        unchecked {\n            amount -= leftoverAmount; // U:[BAL2-8]\n        }\n\n        uint256 amountOutMin = (amount * minRateRAY) / RAY; // U:[BAL2-8]\n        JoinPoolRequest memory request = _getJoinSingleAssetRequest(poolId, assetIn, amount, amountOutMin); // U:[BAL2-8]\n\n        _executeSwapSafeApprove(\n            address(assetIn), abi.encodeCall(IBalancerV2Vault.joinPool, (poolId, creditAccount, creditAccount, request))\n        ); // U:[BAL2-8]\n\n        return true;\n    }\n\n    /// @dev Internal function that builds a `JoinPoolRequest` struct for one-sided deposits\n    function _getJoinSingleAssetRequest(bytes32 poolId, IAsset assetIn, uint256 amountIn, uint256 minAmountOut)\n        internal\n        view\n        returns (JoinPoolRequest memory request)\n    {\n        (IERC20[] memory tokens,,) = IBalancerV2Vault(targetContract).getPoolTokens(poolId);\n        (address bpt,) = IBalancerV2Vault(targetContract).getPool(poolId);\n\n        uint256 len = tokens.length;\n\n        request.assets = new IAsset[](tokens.length);\n        request.maxAmountsIn = new uint256[](tokens.length);\n        uint256 bptIndex = tokens.length;\n\n        for (uint256 i; i < len; ++i) {\n            request.assets[i] = IAsset(address(tokens[i]));\n\n            if (request.assets[i] == assetIn) {\n                request.maxAmountsIn[i] = amountIn; // U:[BAL2-7,8]\n            }\n\n            if (address(request.assets[i]) == bpt) {\n                bptIndex = i;\n            }\n        }\n\n        request.userData = abi.encode(uint256(1), _removeIndex(request.maxAmountsIn, bptIndex), minAmountOut); // U:[BAL2-7,8]\n    }\n\n    // --------- //\n    // EXIT POOL //\n    // --------- //\n\n    /// @notice Withdraws liquidity from a Balancer pool, burning BPT and receiving assets\n    /// @param poolId ID of the pool to withdraw from\n    /// @param request A struct containing data for executing a withdrawal:\n    ///        * `assets` - Array of all assets in the pool\n    ///        * `minAmountsOut` - The minimal amounts to receive for each asset\n    ///        * `userData` - a blob encoding the type of deposit and additional parameters\n    ///          (see https://dev.balancer.fi/resources/joins-and-exits/pool-exits#userdata for more info)\n    ///        * `toInternalBalance` - whether to use internal balances for assets\n    ///          (ignored as the adapter does not use internal balances)\n    /// @dev `sender` and `recipient` are ignored, since they are always set to the CA address\n    function exitPool(bytes32 poolId, address, address payable, ExitPoolRequest memory request)\n        external\n        override\n        creditFacadeOnly // U:[BAL2-2]\n        returns (bool)\n    {\n        if (poolStatus[poolId] == PoolStatus.NOT_ALLOWED) {\n            revert PoolNotSupportedException(); // U:[BAL2-9]\n        }\n\n        address creditAccount = _creditAccount(); // U:[BAL2-9]\n\n        request.toInternalBalance = false; // U:[BAL2-9]\n\n        _execute(abi.encodeCall(IBalancerV2Vault.exitPool, (poolId, creditAccount, payable(creditAccount), request))); // U:[BAL2-9]\n        return true;\n    }\n\n    /// @notice Withdraws liquidity from a Balancer pool, burning BPT and receiving a single asset\n    /// @param poolId ID of the pool to withdraw from\n    /// @param assetOut Asset to withdraw\n    /// @param amountIn Amount of BPT to burn\n    /// @param minAmountOut Minimal amount of asset to receive\n    function exitPoolSingleAsset(bytes32 poolId, IAsset assetOut, uint256 amountIn, uint256 minAmountOut)\n        external\n        override\n        creditFacadeOnly // U:[BAL2-2]\n        returns (bool)\n    {\n        if (poolStatus[poolId] == PoolStatus.NOT_ALLOWED) {\n            revert PoolNotSupportedException(); // U:[BAL2-10]\n        }\n\n        address creditAccount = _creditAccount(); // U:[BAL2-10]\n\n        (address bpt,) = IBalancerV2Vault(targetContract).getPool(poolId);\n\n        _execute(\n            abi.encodeCall(\n                IBalancerV2Vault.exitPool,\n                (\n                    poolId,\n                    creditAccount,\n                    payable(creditAccount),\n                    _getExitSingleAssetRequest(poolId, assetOut, amountIn, minAmountOut, bpt)\n                )\n            )\n        ); // U:[BAL2-10]\n        return true;\n    }\n\n    /// @notice Withdraws all liquidity from a Balancer pool except the specified amount, burning BPT and receiving a single asset\n    /// @param poolId ID of the pool to withdraw from\n    /// @param assetOut Asset to withdraw\n    /// @param leftoverAmount Amount of pool token to keep on the account\n    /// @param minRateRAY Minimal exchange rate of BPT to assetOut, scaled by 1e27\n    function exitPoolSingleAssetDiff(bytes32 poolId, IAsset assetOut, uint256 leftoverAmount, uint256 minRateRAY)\n        external\n        override\n        creditFacadeOnly // U:[BAL2-2]\n        returns (bool)\n    {\n        if (poolStatus[poolId] == PoolStatus.NOT_ALLOWED) {\n            revert PoolNotSupportedException(); // U:[BAL2-11]\n        }\n\n        address creditAccount = _creditAccount(); // U:[BAL2-11]\n\n        (address bpt,) = IBalancerV2Vault(targetContract).getPool(poolId);\n\n        uint256 amount = IERC20(bpt).balanceOf(creditAccount); // U:[BAL2-11]\n        if (amount <= leftoverAmount) return false;\n\n        unchecked {\n            amount -= leftoverAmount; // U:[BAL2-11]\n        }\n\n        uint256 amountOutMin = (amount * minRateRAY) / RAY; // U:[BAL2-11]\n        ExitPoolRequest memory request = _getExitSingleAssetRequest(poolId, assetOut, amount, amountOutMin, bpt); // U:[BAL2-11]\n\n        _execute(abi.encodeCall(IBalancerV2Vault.exitPool, (poolId, creditAccount, payable(creditAccount), request))); // U:[BAL2-11]\n        return true;\n    }\n\n    /// @dev Internal function that builds an `ExitPoolRequest` struct for one-sided withdrawals\n    function _getExitSingleAssetRequest(\n        bytes32 poolId,\n        IAsset assetOut,\n        uint256 amountIn,\n        uint256 minAmountOut,\n        address bpt\n    ) internal view returns (ExitPoolRequest memory request) {\n        (IERC20[] memory tokens,,) = IBalancerV2Vault(targetContract).getPoolTokens(poolId);\n\n        uint256 len = tokens.length;\n\n        request.assets = new IAsset[](tokens.length);\n        request.minAmountsOut = new uint256[](tokens.length);\n        uint256 tokenIndex = tokens.length;\n        uint256 bptIndex = tokens.length;\n\n        for (uint256 i; i < len; ++i) {\n            request.assets[i] = IAsset(address(tokens[i]));\n\n            if (request.assets[i] == assetOut) {\n                request.minAmountsOut[i] = minAmountOut; // U:[BAL2-10,11]\n                tokenIndex = i;\n            }\n\n            if (address(request.assets[i]) == bpt) {\n                bptIndex = i;\n            }\n        }\n\n        tokenIndex = tokenIndex > bptIndex ? tokenIndex - 1 : tokenIndex; // U:[BAL2-10,11]\n\n        request.userData = abi.encode(uint256(0), amountIn, tokenIndex);\n    }\n\n    // ---- //\n    // DATA //\n    // ---- //\n\n    /// @notice Returns the set of all supported pool IDs\n    function supportedPoolIds() public view returns (bytes32[] memory poolIds) {\n        return _supportedPoolIds.values();\n    }\n\n    /// @notice Serialized adapter parameters\n    function serialize() external view returns (bytes memory serializedData) {\n        bytes32[] memory supportedIDs = supportedPoolIds();\n        PoolStatus[] memory supportedPoolStatus = new PoolStatus[](supportedIDs.length);\n\n        for (uint256 i = 0; i < supportedIDs.length; ++i) {\n            supportedPoolStatus[i] = poolStatus[supportedIDs[i]];\n        }\n\n        serializedData = abi.encode(creditManager, targetContract, supportedIDs, supportedPoolStatus);\n    }\n\n    // ------- //\n    // HELPERS //\n    // ------- //\n\n    /// @dev Internal function that changes approval for a batch of assets in the vault\n    function _approveAssets(IAsset[] memory assets, int256[] memory filter, uint256 amount) internal {\n        uint256 len = assets.length;\n\n        for (uint256 i; i < len; ++i) {\n            if (filter[i] > 1) _approveToken(address(assets[i]), amount);\n        }\n    }\n\n    /// @dev Internal function that changes approval for a batch of assets in the vault (overloading)\n    function _approveAssets(IAsset[] memory assets, uint256[] memory filter, uint256 amount) internal {\n        uint256 len = assets.length;\n        for (uint256 i = 0; i < len; ++i) {\n            if (filter[i] > 1) _approveToken(address(assets[i]), amount);\n        }\n    }\n\n    /// @dev Returns a standard `FundManagement` struct used by the adapter\n    function _getDefaultFundManagement(address creditAccount) internal pure returns (FundManagement memory) {\n        return FundManagement({\n            sender: creditAccount,\n            fromInternalBalance: false,\n            recipient: payable(creditAccount),\n            toInternalBalance: false\n        });\n    }\n\n    /// @dev Returns copy of `array` without an element at `index`\n    function _removeIndex(uint256[] memory array, uint256 index) internal pure returns (uint256[] memory res) {\n        uint256 len = array.length;\n\n        if (index >= len) {\n            return array;\n        }\n\n        len--;\n\n        res = new uint256[](len);\n\n        for (uint256 i = 0; i < len; ++i) {\n            if (i < index) {\n                res[i] = array[i];\n            } else {\n                res[i] = array[i + 1];\n            }\n        }\n    }\n\n    // ------------- //\n    // CONFIGURATION //\n    // ------------- //\n\n    /// @notice Sets the pool status\n    function setPoolStatus(bytes32 poolId, PoolStatus newStatus)\n        external\n        override\n        configuratorOnly // U:[BAL2-12]\n    {\n        if (poolStatus[poolId] != newStatus) {\n            if (\n                newStatus == PoolStatus.ALLOWED || newStatus == PoolStatus.SWAP_ONLY\n                    || newStatus == PoolStatus.WITHDRAWAL_ONLY\n            ) {\n                _verifyPoolAssets(poolId);\n                _supportedPoolIds.add(poolId);\n            } else {\n                _supportedPoolIds.remove(poolId);\n            }\n\n            poolStatus[poolId] = newStatus; // U:[BAL2-12]\n            emit SetPoolStatus(poolId, newStatus); // U:[BAL2-12]\n        }\n    }\n\n    /// @dev Verifies that assets in the pool are valid collaterals before adding the pool to supported list\n    function _verifyPoolAssets(bytes32 poolId) internal view {\n        (IERC20[] memory tokens,,) = IBalancerV2Vault(targetContract).getPoolTokens(poolId);\n        (address bpt,) = IBalancerV2Vault(targetContract).getPool(poolId);\n\n        uint256 len = tokens.length;\n\n        for (uint256 i = 0; i < len; ++i) {\n            if (address(tokens[i]) != bpt) _getMaskOrRevert(address(tokens[i]));\n        }\n\n        _getMaskOrRevert(bpt);\n    }\n}\n"
    },
    "lib/@gearbox-protocol/integrations-v3/contracts/integrations/balancer/IBalancerV2Vault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IAsset} from \"./IAsset.sol\";\n\nenum SwapKind {\n    GIVEN_IN,\n    GIVEN_OUT\n}\n\nenum PoolSpecialization {\n    GENERAL,\n    MINIMAL_SWAP_INFO,\n    TWO_TOKEN\n}\n\nenum JoinKind {\n    INIT,\n    EXACT_TOKENS_IN_FOR_BPT_OUT,\n    TOKEN_IN_FOR_EXACT_BPT_OUT,\n    ALL_TOKENS_IN_FOR_EXACT_BPT_OUT\n}\n\nenum ExitKind {\n    EXACT_BPT_IN_FOR_ONE_TOKEN_OUT,\n    EXACT_BPT_IN_FOR_TOKENS_OUT,\n    BPT_IN_FOR_EXACT_TOKENS_OUT\n}\n\nstruct SingleSwap {\n    bytes32 poolId;\n    SwapKind kind;\n    IAsset assetIn;\n    IAsset assetOut;\n    uint256 amount;\n    bytes userData;\n}\n\nstruct BatchSwapStep {\n    bytes32 poolId;\n    uint256 assetInIndex;\n    uint256 assetOutIndex;\n    uint256 amount;\n    bytes userData;\n}\n\nstruct FundManagement {\n    address sender;\n    bool fromInternalBalance;\n    address payable recipient;\n    bool toInternalBalance;\n}\n\nstruct JoinPoolRequest {\n    IAsset[] assets;\n    uint256[] maxAmountsIn;\n    bytes userData;\n    bool fromInternalBalance;\n}\n\nstruct ExitPoolRequest {\n    IAsset[] assets;\n    uint256[] minAmountsOut;\n    bytes userData;\n    bool toInternalBalance;\n}\n\ninterface IBalancerV2VaultGetters {\n    function getPool(bytes32 poolId) external view returns (address, PoolSpecialization);\n\n    function getPoolTokenInfo(bytes32 poolId, IERC20 token)\n        external\n        view\n        returns (uint256 cash, uint256 managed, uint256 lastChangeBlock, address assetManager);\n\n    function getPoolTokens(bytes32 poolId)\n        external\n        view\n        returns (IERC20[] memory tokens, uint256[] memory balances, uint256 lastChangeBlock);\n}\n\ninterface IBalancerV2Vault is IBalancerV2VaultGetters {\n    function batchSwap(\n        SwapKind kind,\n        BatchSwapStep[] memory swaps,\n        IAsset[] memory assets,\n        FundManagement memory funds,\n        int256[] memory limits,\n        uint256 deadline\n    ) external returns (int256[] memory assetDeltas);\n\n    function queryBatchSwap(\n        SwapKind kind,\n        BatchSwapStep[] memory swaps,\n        IAsset[] memory assets,\n        FundManagement memory funds\n    ) external returns (int256[] memory assetDeltas);\n\n    function swap(SingleSwap memory singleSwap, FundManagement memory funds, uint256 limit, uint256 deadline)\n        external\n        returns (uint256 amountCalculated);\n\n    function joinPool(bytes32 poolId, address sender, address recipient, JoinPoolRequest memory request) external;\n\n    function exitPool(bytes32 poolId, address sender, address payable recipient, ExitPoolRequest memory request)\n        external;\n}\n"
    },
    "lib/@gearbox-protocol/integrations-v3/contracts/integrations/balancer/IBalancerWeightedPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\ninterface IBalancerWeightedPool {\n    function getRate() external view returns (uint256);\n\n    function getNormalizedWeights() external view returns (uint256[] memory);\n\n    function totalSupply() external view returns (uint256);\n\n    function getActualSupply() external view returns (uint256);\n\n    function getPoolId() external view returns (bytes32);\n}\n"
    },
    "lib/@gearbox-protocol/integrations-v3/contracts/integrations/balancer/IBalancerQueries.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.7.0 <0.9.0;\npragma experimental ABIEncoderV2;\n\nimport {IAsset} from \"./IAsset.sol\";\nimport {\n    BatchSwapStep,\n    ExitPoolRequest,\n    FundManagement,\n    JoinPoolRequest,\n    SingleSwap,\n    SwapKind\n} from \"./IBalancerV2Vault.sol\";\n\n/**\n * @dev Provides a way to perform queries on swaps, joins and exits, simulating these operations and returning the exact\n * result they would have if called on the Vault given the current state. Note that the results will be affected by\n * other transactions interacting with the Pools involved.\n *\n * All query functions can be called both on-chain and off-chain.\n *\n * If calling them from a contract, note that all query functions are not `view`. Despite this, these functions produce\n * no net state change, and for all intents and purposes can be thought of as if they were indeed `view`. However,\n * calling them via STATICCALL will fail.\n *\n * If calling them from an off-chain client, make sure to use eth_call: most clients default to eth_sendTransaction for\n * non-view functions.\n *\n * In all cases, the `fromInternalBalance` and `toInternalBalance` fields are entirely ignored: we just use the same\n * structs for simplicity.\n */\ninterface IBalancerQueries {\n    function querySwap(SingleSwap memory singleSwap, FundManagement memory funds) external returns (uint256);\n\n    function queryBatchSwap(\n        SwapKind kind,\n        BatchSwapStep[] memory swaps,\n        IAsset[] memory assets,\n        FundManagement memory funds\n    ) external returns (int256[] memory assetDeltas);\n\n    function queryJoin(bytes32 poolId, address sender, address recipient, JoinPoolRequest memory request)\n        external\n        returns (uint256 bptOut, uint256[] memory amountsIn);\n\n    function queryExit(bytes32 poolId, address sender, address recipient, ExitPoolRequest memory request)\n        external\n        returns (uint256 bptIn, uint256[] memory amountsOut);\n}\n"
    },
    "lib/@gearbox-protocol/integrations-v3/contracts/interfaces/balancer/IBalancerV2VaultAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Foundation, 2024.\npragma solidity ^0.8.23;\n\nimport {IAdapter} from \"@gearbox-protocol/core-v3/contracts/interfaces/base/IAdapter.sol\";\n\nimport {\n    IAsset,\n    SingleSwap,\n    FundManagement,\n    SwapKind,\n    BatchSwapStep,\n    JoinPoolRequest,\n    ExitPoolRequest\n} from \"../../integrations/balancer/IBalancerV2Vault.sol\";\n\nenum PoolStatus {\n    NOT_ALLOWED,\n    ALLOWED,\n    SWAP_ONLY,\n    WITHDRAWAL_ONLY\n}\n\nstruct SingleSwapDiff {\n    bytes32 poolId;\n    uint256 leftoverAmount;\n    IAsset assetIn;\n    IAsset assetOut;\n    bytes userData;\n}\n\n/// @title Balancer V2 Vault adapter interface\ninterface IBalancerV2VaultAdapter is IAdapter {\n    /// @notice Emitted when new status is set for a pool with given ID\n    event SetPoolStatus(bytes32 indexed poolId, PoolStatus newStatus);\n\n    /// @notice Thrown when attempting to swap or change liqudity in the pool that is not supported for that action\n    error PoolNotSupportedException();\n    // ----- //\n    // SWAPS //\n    // ----- //\n\n    function swap(SingleSwap memory singleSwap, FundManagement memory, uint256 limit, uint256 deadline)\n        external\n        returns (bool useSafePrices);\n\n    function swapDiff(SingleSwapDiff memory singleSwapDiff, uint256 limitRateRAY, uint256 deadline)\n        external\n        returns (bool useSafePrices);\n\n    function batchSwap(\n        SwapKind kind,\n        BatchSwapStep[] memory swaps,\n        IAsset[] memory assets,\n        FundManagement memory,\n        int256[] memory limits,\n        uint256 deadline\n    ) external returns (bool useSafePrices);\n\n    // --------- //\n    // JOIN POOL //\n    // --------- //\n\n    function joinPool(bytes32 poolId, address, address, JoinPoolRequest memory request)\n        external\n        returns (bool useSafePrices);\n\n    function joinPoolSingleAsset(bytes32 poolId, IAsset assetIn, uint256 amountIn, uint256 minAmountOut)\n        external\n        returns (bool useSafePrices);\n\n    function joinPoolSingleAssetDiff(bytes32 poolId, IAsset assetIn, uint256 leftoverAmount, uint256 minRateRAY)\n        external\n        returns (bool useSafePrices);\n\n    // --------- //\n    // EXIT POOL //\n    // --------- //\n\n    function exitPool(bytes32 poolId, address, address payable, ExitPoolRequest memory request)\n        external\n        returns (bool useSafePrices);\n\n    function exitPoolSingleAsset(bytes32 poolId, IAsset assetOut, uint256 amountIn, uint256 minAmountOut)\n        external\n        returns (bool useSafePrices);\n\n    function exitPoolSingleAssetDiff(bytes32 poolId, IAsset assetOut, uint256 leftoverAmount, uint256 minRateRAY)\n        external\n        returns (bool useSafePrices);\n\n    // ------------- //\n    // CONFIGURATION //\n    // ------------- //\n\n    function poolStatus(bytes32 poolId) external view returns (PoolStatus);\n\n    function setPoolStatus(bytes32 poolId, PoolStatus newStatus) external;\n}\n"
    },
    "contracts/lib/MultiCall.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Holdings, 2025\npragma solidity ^0.8.17;\n\nimport {MultiCall} from \"@gearbox-protocol/core-v3/contracts/interfaces/ICreditFacadeV3.sol\";\n\nlibrary MultiCallOps {\n    function copyMulticall(MultiCall memory call) internal pure returns (MultiCall memory) {\n        return MultiCall({target: call.target, callData: call.callData});\n    }\n\n    function trim(MultiCall[] memory calls) internal pure returns (MultiCall[] memory trimmed) {\n        uint256 len = calls.length;\n\n        if (len == 0) return calls;\n\n        uint256 foundLen;\n        while (calls[foundLen].target != address(0)) {\n            unchecked {\n                ++foundLen;\n                if (foundLen == len) return calls;\n            }\n        }\n\n        if (foundLen > 0) return copy(calls, foundLen);\n    }\n\n    function copy(MultiCall[] memory calls, uint256 len) internal pure returns (MultiCall[] memory res) {\n        res = new MultiCall[](len);\n        for (uint256 i; i < len;) {\n            res[i] = copyMulticall(calls[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function clone(MultiCall[] memory calls) internal pure returns (MultiCall[] memory res) {\n        return copy(calls, calls.length);\n    }\n\n    function append(MultiCall[] memory calls, MultiCall memory newCall)\n        internal\n        pure\n        returns (MultiCall[] memory res)\n    {\n        uint256 len = calls.length;\n        res = new MultiCall[](len + 1);\n        for (uint256 i; i < len;) {\n            res[i] = copyMulticall(calls[i]);\n            unchecked {\n                ++i;\n            }\n        }\n        res[len] = copyMulticall(newCall);\n    }\n\n    function prepend(MultiCall[] memory calls, MultiCall memory newCall)\n        internal\n        pure\n        returns (MultiCall[] memory res)\n    {\n        uint256 len = calls.length;\n        res = new MultiCall[](len + 1);\n        res[0] = copyMulticall(newCall);\n\n        for (uint256 i = 1; i < len + 1;) {\n            res[i] = copyMulticall(calls[i - 1]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function concat(MultiCall[] memory calls1, MultiCall[] memory calls2)\n        internal\n        pure\n        returns (MultiCall[] memory res)\n    {\n        uint256 len1 = calls1.length;\n        uint256 lenTotal = len1 + calls2.length;\n\n        if (lenTotal == calls1.length) return clone(calls1);\n        if (lenTotal == calls2.length) return clone(calls2);\n\n        res = new MultiCall[](lenTotal);\n\n        for (uint256 i; i < lenTotal;) {\n            res[i] = (i < len1) ? copyMulticall(calls1[i]) : copyMulticall(calls2[i - len1]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n}\n"
    },
    "contracts/data/Graph.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Holdings, 2025\npragma solidity ^0.8.10;\n\nimport {MultiCall} from \"@gearbox-protocol/core-v3/contracts/interfaces/ICreditFacadeV3.sol\";\nimport {MultiCallOps} from \"../lib/MultiCall.sol\";\nimport {AddressList} from \"../helpers/AddressList.sol\";\nimport {IWorkerBase, IWorker, IWorkerNonLinear} from \"../interfaces/IWorker.sol\";\n\nstruct Edge {\n    uint256 id;\n    address tokenIn;\n    address tokenOut;\n    address adapter;\n    address worker;\n    bytes extraData;\n    uint256 amountInTotal;\n    uint256 amountOutTotal;\n    uint256 amountInCurrent;\n    uint256 amountOutCurrent;\n}\n\nstruct Vertex {\n    address token;\n    uint256 balance;\n    uint256 leftoverBalance;\n    uint256 numSplits;\n    uint256 currentOptimalEdge;\n}\n\nstruct Graph {\n    Vertex[] vertices;\n    Edge[] edges;\n}\n\nlibrary EdgeOps {\n    function includes(Edge[] memory edges, Edge memory edge) internal pure returns (bool) {\n        uint256 len = edges.length;\n        for (uint256 i = 0; i < len; ++i) {\n            if (edges[i].id == edge.id) return true;\n        }\n        return false;\n    }\n\n    function append(Edge[] memory edges, Edge memory newEdge) internal pure returns (Edge[] memory res) {\n        uint256 len = edges.length;\n        res = new Edge[](len + 1);\n        for (uint256 i = 0; i < len; ++i) {\n            res[i] = edges[i];\n        }\n        res[len] = newEdge;\n    }\n\n    function prepend(Edge[] memory edges, Edge memory newEdge) internal pure returns (Edge[] memory res) {\n        uint256 len = edges.length;\n        res = new Edge[](len + 1);\n        for (uint256 i = 0; i < len; ++i) {\n            res[i + 1] = edges[i];\n        }\n        res[0] = newEdge;\n    }\n\n    function trim(Edge[] memory edges) internal pure returns (Edge[] memory res) {\n        uint256 len = edges.length;\n        uint256 foundLen = 0;\n\n        for (uint256 i = 0; i < len; ++i) {\n            if (edges[i].id == 0) {\n                break;\n            }\n            ++foundLen;\n        }\n\n        res = new Edge[](foundLen);\n\n        for (uint256 i = 0; i < foundLen; ++i) {\n            res[i] = edges[i];\n        }\n    }\n}\n\nlibrary GraphOps {\n    using AddressList for address[];\n    using MultiCallOps for MultiCall[];\n    using EdgeOps for Edge[];\n\n    function isVertex(Graph memory g, address token) internal pure returns (bool) {\n        uint256 len = g.vertices.length;\n\n        for (uint256 i = 0; i < len; ++i) {\n            if (g.vertices[i].token == token) return true;\n        }\n\n        return false;\n    }\n\n    function getVertex(Graph memory g, address token) internal pure returns (Vertex memory vertex) {\n        uint256 len = g.vertices.length;\n\n        for (uint256 i = 0; i < len; ++i) {\n            if (g.vertices[i].token == token) return g.vertices[i];\n        }\n    }\n\n    function getBalance(Graph memory g, address token) internal pure returns (uint256) {\n        return getVertex(g, token).balance;\n    }\n\n    function getBalanceDiff(Graph memory g, address token) internal pure returns (uint256) {\n        Vertex memory v = getVertex(g, token);\n        if (v.balance < v.leftoverBalance) return 0;\n        return v.balance - v.leftoverBalance;\n    }\n\n    function getTokenOptimalAmount(Graph memory g, address token) internal pure returns (uint256) {\n        Vertex memory v = getVertex(g, token);\n\n        if (v.currentOptimalEdge == 0) return 0;\n\n        Edge memory e = getEdgeById(g, v.currentOptimalEdge);\n\n        return e.amountOutCurrent;\n    }\n\n    function getEdgesIn(Graph memory g, address token) internal pure returns (Edge[] memory edgesIn) {\n        uint256 k = 0;\n        uint256 len = g.edges.length;\n        edgesIn = new Edge[](len);\n\n        for (uint256 i = 0; i < len; ++i) {\n            if (g.edges[i].tokenOut == token) {\n                edgesIn[k] = g.edges[i];\n                ++k;\n            }\n        }\n\n        edgesIn = edgesIn.trim();\n    }\n\n    function getEdgesOut(Graph memory g, address token) internal pure returns (Edge[] memory edgesOut) {\n        uint256 k = 0;\n        uint256 len = g.edges.length;\n        edgesOut = new Edge[](len);\n\n        for (uint256 i = 0; i < len; ++i) {\n            if (g.edges[i].tokenIn == token) {\n                edgesOut[k] = g.edges[i];\n                ++k;\n            }\n        }\n\n        edgesOut = edgesOut.trim();\n    }\n\n    function getEdgeById(Graph memory g, uint256 id) internal pure returns (Edge memory) {\n        uint256 lenE = g.edges.length;\n\n        for (uint256 i = 0; i < lenE; ++i) {\n            if (g.edges[i].id == id) return g.edges[i];\n        }\n\n        revert(\"Edge not found\");\n    }\n\n    function getWorkerEdges(Graph memory g, address worker) internal pure returns (Edge[] memory workerEdges) {\n        uint256 k = 0;\n        uint256 len = g.edges.length;\n        workerEdges = new Edge[](len);\n\n        for (uint256 i = 0; i < len; ++i) {\n            if (g.edges[i].worker == worker) {\n                workerEdges[k] = g.edges[i];\n                ++k;\n            }\n        }\n\n        workerEdges = workerEdges.trim();\n    }\n\n    function activateVertex(Graph memory g, address token, uint256 amount) internal pure {\n        Vertex memory vertex = getVertex(g, token);\n        vertex.balance = amount;\n        vertex.numSplits = vertex.numSplits == 0 ? 1 : vertex.numSplits;\n    }\n\n    function removeVertex(Graph memory g, address token) internal pure {\n        uint256 k = 0;\n        uint256 lenV = g.vertices.length;\n        uint256 lenE = g.edges.length;\n\n        for (uint256 i = 0; i < lenV; ++i) {\n            if (g.vertices[i].token == token) {\n                g.vertices[i] = g.vertices[lenV - 1];\n                Vertex[] memory vertices = g.vertices;\n                assembly {\n                    mstore(vertices, sub(lenV, 1))\n                }\n                break;\n            }\n        }\n\n        Edge[] memory newEdges = new Edge[](lenE);\n\n        for (uint256 i = 0; i < lenE; ++i) {\n            if (g.edges[i].tokenIn != token && g.edges[i].tokenOut != token) {\n                newEdges[k] = g.edges[i];\n                ++k;\n            }\n        }\n\n        g.edges = newEdges.trim();\n    }\n\n    function appendEdge(\n        Graph memory g,\n        address tokenIn,\n        address tokenOut,\n        bytes memory extraData,\n        address adapter,\n        address worker\n    ) internal pure {\n        uint256 len = g.edges.length;\n\n        if (!isVertex(g, tokenIn) || !isVertex(g, tokenOut)) return;\n\n        Edge memory newEdge;\n        newEdge.id = len + 1;\n        newEdge.tokenIn = tokenIn;\n        newEdge.tokenOut = tokenOut;\n        newEdge.extraData = extraData;\n        newEdge.adapter = adapter;\n        newEdge.worker = worker;\n\n        g.edges = g.edges.append(newEdge);\n    }\n\n    function getNeighborsOf(Graph memory g, address token) internal pure returns (address[] memory neighbors) {\n        Edge[] memory edgesIn = getEdgesIn(g, token);\n        Edge[] memory edgesOut = getEdgesOut(g, token);\n\n        uint256 len = edgesIn.length;\n\n        for (uint256 i = 0; i < len; ++i) {\n            address tokenIn = edgesIn[i].tokenIn;\n            if (!neighbors.includes(tokenIn)) neighbors = neighbors.append(tokenIn);\n        }\n\n        len = edgesOut.length;\n\n        for (uint256 i = 0; i < len; ++i) {\n            address tokenOut = edgesOut[i].tokenOut;\n            if (!neighbors.includes(tokenOut)) neighbors = neighbors.append(tokenOut);\n        }\n    }\n\n    function hasOptimalOrCommittedOppositeEdge(Graph memory g, Edge memory edge) internal pure returns (bool) {\n        uint256 len = g.edges.length;\n\n        Vertex memory v = getVertex(g, edge.tokenIn);\n\n        for (uint256 i = 0; i < len; ++i) {\n            if (\n                g.edges[i].tokenIn == edge.tokenOut && g.edges[i].tokenOut == edge.tokenIn\n                    && (v.currentOptimalEdge == g.edges[i].id || g.edges[i].amountOutTotal > 1)\n            ) return true;\n        }\n        return false;\n    }\n\n    function processClaims(Graph memory g, address token, address creditAccount)\n        internal\n        view\n        returns (Graph memory, MultiCall[] memory)\n    {\n        Edge[] memory edgesIn = getEdgesIn(g, token);\n        MultiCall[] memory calls;\n\n        for (uint256 i = 0; i < edgesIn.length; ++i) {\n            MultiCall[] memory callsCurrent;\n            (g, callsCurrent) = IWorkerBase(edgesIn[i].worker).processClaims(edgesIn[i], g, creditAccount);\n            calls = calls.concat(callsCurrent);\n        }\n\n        return (g, calls);\n    }\n\n    function trimUselessVerticesRec(Graph memory g, address token, address targetToken, address[] memory walked)\n        internal\n        view\n        returns (address[] memory)\n    {\n        if (!walked.includes(token)) walked = walked.append(token);\n\n        Edge[] memory edgesIn = getEdgesIn(g, token);\n\n        uint256 len = edgesIn.length;\n\n        for (uint256 i = 0; i < len; ++i) {\n            if (!walked.includes(edgesIn[i].tokenIn)) {\n                walked = trimUselessVerticesRec(g, edgesIn[i].tokenIn, targetToken, walked);\n            }\n        }\n\n        address[] memory neighbors = getNeighborsOf(g, token);\n        bool trimSpecial = false;\n\n        /// This is a special procedure that removes vertices which cannot be detected by a generic algorithm\n        /// E.g., a Curve LP is clearly redundant if it only connects to underlying coins and is non-target,\n        /// but will not be detected by the general pass, since it always has at least 2 underlyings as neighbors\n        for (uint256 i = 0; i < len; ++i) {\n            if (IWorkerBase(edgesIn[i].worker).trimSpecialVertex(edgesIn[i], g, targetToken)) {\n                trimSpecial = true;\n                break;\n            }\n        }\n\n        if (trimSpecial || (neighbors.length == 1 && token != targetToken && getBalanceDiff(g, token) <= 1)) {\n            removeVertex(g, token);\n        }\n\n        return walked;\n    }\n\n    function trimUselessVertices(Graph memory g, address targetToken) internal view {\n        address[] memory walked = trimUselessVerticesRec(g, targetToken, targetToken, new address[](0));\n\n        address[] memory unreachable = new address[](0);\n\n        uint256 lenV = g.vertices.length;\n\n        for (uint256 i = 0; i < lenV; ++i) {\n            if (!walked.includes(g.vertices[i].token)) unreachable.append(g.vertices[i].token);\n        }\n\n        uint256 len = unreachable.length;\n\n        for (uint256 i = 0; i < len; ++i) {\n            if (getBalanceDiff(g, unreachable[i]) > 1) {\n                revert(\"Error: Unreachable token has non-zero balance diff (is input token)\");\n            }\n            removeVertex(g, unreachable[i]);\n        }\n    }\n\n    function clearCurrents(Graph memory g) internal pure {\n        uint256 lenV = g.vertices.length;\n        uint256 lenE = g.edges.length;\n\n        for (uint256 i = 0; i < lenV; ++i) {\n            g.vertices[i].currentOptimalEdge = 0;\n        }\n\n        for (uint256 i = 0; i < lenE; ++i) {\n            g.edges[i].amountInCurrent = 0;\n            g.edges[i].amountOutCurrent = 0;\n        }\n    }\n\n    function computeOptimalAmounts(Graph memory g, address inputToken, address targetToken, uint256 amount) internal {\n        clearCurrents(g);\n\n        uint256 lenV = g.vertices.length;\n        uint256 lenE = g.edges.length;\n\n        for (uint256 i = 0; i < lenV - 1; ++i) {\n            bool iterationRelaxed = false;\n            for (uint256 j = 0; j < lenE; ++j) {\n                if (\n                    g.edges[j].tokenIn == targetToken || g.edges[j].tokenOut == inputToken\n                        || hasOptimalOrCommittedOppositeEdge(g, g.edges[j])\n                ) {\n                    continue;\n                }\n\n                uint256 amountInNew;\n\n                if (g.edges[j].tokenIn == inputToken) {\n                    amountInNew = amount;\n                } else {\n                    amountInNew = getTokenOptimalAmount(g, g.edges[j].tokenIn);\n                }\n\n                if (g.edges[j].amountInCurrent == amountInNew) {\n                    continue;\n                } else {\n                    g.edges[j].amountInCurrent = amountInNew;\n                }\n\n                if (g.edges[j].amountInCurrent != 0) {\n                    address worker = g.edges[j].worker;\n\n                    g.edges[j].amountOutCurrent = IWorkerBase(worker).isNonLinear()\n                        ? IWorkerNonLinear(worker).getEdgeAmountOutCurrent(g.edges[j], g)\n                        : IWorker(worker).getEdgeAmountOutCurrent(g.edges[j]);\n                }\n\n                uint256 currentOptimalAmount = getTokenOptimalAmount(g, g.edges[j].tokenOut);\n\n                if (g.edges[j].amountOutCurrent > currentOptimalAmount) {\n                    getVertex(g, g.edges[j].tokenOut).currentOptimalEdge = g.edges[j].id;\n                    iterationRelaxed = true;\n                }\n            }\n            if (!iterationRelaxed) break;\n        }\n\n        address currentToken = targetToken;\n\n        while (currentToken != inputToken) {\n            Vertex memory vertex = getVertex(g, currentToken);\n\n            if (vertex.currentOptimalEdge == 0) {\n                revert(\n                    \"Error: no optimal edge found for token. The swapped amount may be too small to yield a positive output\"\n                );\n            }\n\n            Edge memory edge = getEdgeById(g, vertex.currentOptimalEdge);\n\n            edge.amountInTotal += edge.amountInCurrent;\n            edge.amountOutTotal += edge.amountOutCurrent;\n\n            currentToken = edge.tokenIn;\n        }\n    }\n\n    function collectMulticalls(Graph memory g, address targetToken)\n        internal\n        returns (Graph memory, MultiCall[] memory calls)\n    {\n        Edge[] memory orderedEdges = new Edge[](0);\n        address[] memory queue = new address[](1);\n\n        queue[0] = targetToken;\n\n        while (queue.length > 0) {\n            address token = queue[0];\n            queue = queue.popFirst();\n\n            Edge[] memory edgesOut = getEdgesOut(g, token);\n\n            {\n                bool defer = false;\n                for (uint256 i = 0; i < edgesOut.length; ++i) {\n                    if (\n                        edgesOut[i].amountOutTotal > 1 && !queue.includes(edgesOut[i].tokenOut)\n                            && !orderedEdges.includes(edgesOut[i])\n                    ) {\n                        defer = true;\n                        break;\n                    }\n                }\n                if (defer) {\n                    queue = queue.append(token);\n                    continue;\n                }\n            }\n\n            for (uint256 i = 0; i < edgesOut.length; ++i) {\n                if (edgesOut[i].amountOutTotal > 1 && !orderedEdges.includes(edgesOut[i])) {\n                    orderedEdges = orderedEdges.prepend(edgesOut[i]);\n                }\n            }\n\n            Edge[] memory edgesIn = getEdgesIn(g, token);\n\n            for (uint256 i = 0; i < edgesIn.length; ++i) {\n                if (edgesIn[i].amountOutTotal > 1 && !orderedEdges.includes(edgesIn[i])) {\n                    orderedEdges = orderedEdges.prepend(edgesIn[i]);\n                    queue = queue.append(edgesIn[i].tokenIn);\n                }\n            }\n        }\n\n        for (uint256 i = 0; i < orderedEdges.length; ++i) {\n            (calls, g) = collectEdgeMulticalls(g, orderedEdges[i], calls);\n        }\n\n        return (g, calls);\n    }\n\n    function collectEdgeMulticalls(Graph memory g, Edge memory edge, MultiCall[] memory calls)\n        internal\n        returns (MultiCall[] memory, Graph memory)\n    {\n        Vertex memory vertexIn = getVertex(g, edge.tokenIn);\n        MultiCall[] memory newCalls;\n        if (IWorkerBase(edge.worker).isNonLinear()) {\n            (newCalls, g) = IWorkerNonLinear(edge.worker).getMulticalls(edge, g);\n        } else {\n            if (vertexIn.balance == edge.amountInTotal) {\n                edge.amountInTotal -= 1;\n            }\n\n            newCalls = IWorker(edge.worker).getMulticalls(edge, vertexIn.balance);\n            vertexIn.balance -= edge.amountInTotal;\n            getVertex(g, edge.tokenOut).balance += edge.amountOutTotal;\n        }\n\n        calls = calls.concat(newCalls);\n\n        return (calls, g);\n    }\n}\n"
    },
    "contracts/helpers/AddressList.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Holdings, 2025\npragma solidity ^0.8.10;\n\nlibrary AddressList {\n    function includes(address[] memory array, address item) internal pure returns (bool) {\n        uint256 len = array.length;\n\n        for (uint256 i; i < len;) {\n            if (array[i] == item) return true;\n            unchecked {\n                ++i;\n            }\n        }\n\n        return false;\n    }\n\n    function trim(address[] memory array) internal pure returns (address[] memory trimmed) {\n        uint256 len = array.length;\n\n        if (len == 0) return array;\n\n        uint256 foundLen;\n        while (array[foundLen] != address(0)) {\n            unchecked {\n                ++foundLen;\n                if (foundLen == len) return array;\n            }\n        }\n\n        if (foundLen > 0) return copy(array, foundLen);\n    }\n\n    function copy(address[] memory array, uint256 len) internal pure returns (address[] memory res) {\n        res = new address[](len);\n        for (uint256 i; i < len;) {\n            res[i] = array[i];\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function concat(address[] memory calls1, address[] memory calls2) internal pure returns (address[] memory res) {\n        uint256 len1 = calls1.length;\n        uint256 lenTotal = len1 + calls2.length;\n\n        if (lenTotal == len1) return calls1;\n\n        res = new address[](lenTotal);\n\n        for (uint256 i; i < lenTotal;) {\n            res[i] = (i < len1) ? calls1[i] : calls2[i - len1];\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function append(address[] memory addrs, address newAddr) internal pure returns (address[] memory res) {\n        address[] memory newAddrArray = new address[](1);\n        newAddrArray[0] = newAddr;\n        return concat(addrs, newAddrArray);\n    }\n\n    function popFirst(address[] memory addrs) internal pure returns (address[] memory res) {\n        uint256 len = addrs.length;\n        res = new address[](len - 1);\n\n        for (uint256 i = 1; i < len; ++i) {\n            res[i - 1] = addrs[i];\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IWorker.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Holdings, 2021\npragma solidity ^0.8.10;\n\nimport {IRouterComponent} from \"./IRouterComponent.sol\";\nimport {MultiCall} from \"@gearbox-protocol/core-v3/contracts/interfaces/ICreditFacadeV3.sol\";\nimport {Graph, Edge} from \"../data/Graph.sol\";\n\ninterface IWorkerBase is IRouterComponent {\n    function isNonLinear() external pure returns (bool);\n\n    function buildEdges(Graph memory graph, address adapter) external view returns (Graph memory);\n\n    function trimSpecialVertex(Edge memory edge, Graph memory graph, address targetToken)\n        external\n        view\n        returns (bool);\n\n    function processClaims(Edge memory edge, Graph memory graph, address creditAccount)\n        external\n        view\n        returns (Graph memory, MultiCall[] memory);\n}\n\ninterface IWorker is IWorkerBase {\n    function getEdgeAmountOutCurrent(Edge memory edge) external returns (uint256 amountOutCurrent);\n\n    function getMulticalls(Edge memory edge, uint256 currentBalance) external returns (MultiCall[] memory calls);\n}\n\ninterface IWorkerNonLinear is IWorkerBase {\n    function getEdgeAmountOutCurrent(Edge memory edge, Graph memory graph)\n        external\n        returns (uint256 amountOutCurrent);\n\n    function getMulticalls(Edge memory edge, Graph memory graph) external returns (MultiCall[] memory, Graph memory);\n}\n"
    },
    "lib/@gearbox-protocol/core-v3/contracts/interfaces/base/IVersion.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Foundation, 2024.\npragma solidity ^0.8.17;\n\n/// @title Version interface\n/// @notice Defines contract version and type\ninterface IVersion {\n    /// @notice Contract version\n    function version() external view returns (uint256);\n\n    /// @notice Contract type\n    function contractType() external view returns (bytes32);\n}\n"
    },
    "lib/@gearbox-protocol/core-v3/contracts/interfaces/base/IStateSerializer.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Foundation, 2024.\npragma solidity ^0.8.17;\n\n/// @title State serializer interface\n/// @notice Generic interface for a contract that can serialize its state into a bytes array\ninterface IStateSerializer {\n    /// @notice Serializes the state of the contract into a bytes array `serializedData`\n    function serialize() external view returns (bytes memory serializedData);\n}\n"
    },
    "lib/@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "contracts/interfaces/IGearboxRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Holdings, 2021\npragma solidity ^0.8.10;\n\nimport {IVersion} from \"@gearbox-protocol/core-v3/contracts/interfaces/base/IVersion.sol\";\n\nimport {RouterResult} from \"../data/RouterResult.sol\";\n\nstruct TokenData {\n    address token;\n    uint256 balance;\n    uint256 leftoverBalance;\n    uint256 numSplits;\n    bool claimRewards;\n}\n\nerror PathNotFoundExceptionTyped(uint8 ttIn, address tokenOut);\nerror PathNotFoundException(address tokenIn, address tokenOut);\nerror PathToTargetNotFound(address tokenOut);\nerror UnsupportedAdapterType();\nerror UnsupportedRouterComponent(address);\n\ninterface IGearboxRouter is IVersion {\n    /// @dev Emits each time when routerComponent is set / updated\n    event RouterComponentUpdate(bytes32 indexed, address indexed, uint256 version);\n\n    event SetFutureRouter(address indexed);\n\n    function routeOneToOne(\n        address creditAccount,\n        address tokenIn,\n        uint256 amount,\n        address target,\n        uint256 slippage,\n        uint256 numSplits\n    ) external returns (RouterResult memory);\n\n    function routeOneToOneDiff(\n        address creditAccount,\n        address tokenIn,\n        uint256 balance,\n        uint256 leftoverBalance,\n        address target,\n        uint256 slippage,\n        uint256 numSplits\n    ) external returns (RouterResult memory);\n\n    function routeOpenManyToOne(address creditManager, address target, uint256 slippage, TokenData[] calldata tData)\n        external\n        returns (RouterResult memory);\n\n    function routeManyToOne(address creditAccount, address target, uint256 slippage, TokenData[] calldata tData)\n        external\n        returns (RouterResult memory);\n\n    function componentAddressByType(bytes32) external view returns (address);\n\n    function isRouterConfigurator(address account) external view returns (bool);\n\n    function futureRouter() external view returns (address);\n\n    function knownComponentTypes() external view returns (bytes32[] memory);\n}\n"
    },
    "lib/@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "lib/@gearbox-protocol/core-v3/contracts/libraries/Constants.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Foundation, 2024.\npragma solidity ^0.8.17;\n\nbytes32 constant AP_GEAR_TOKEN = \"GLOBAL::GEAR_TOKEN\";\nbytes32 constant AP_INSTANCE_MANAGER_PROXY = \"INSTANCE_MANAGER_PROXY\";\nbytes32 constant AP_CROSS_CHAIN_GOVERNANCE_PROXY = \"CROSS_CHAIN_GOVERNANCE_PROXY\";\nbytes32 constant AP_PRICE_FEED_STORE = \"PRICE_FEED_STORE\";\nuint256 constant NO_VERSION_CONTROL = 0;\n\nuint256 constant WAD = 1e18;\nuint256 constant RAY = 1e27;\nuint16 constant PERCENTAGE_FACTOR = 1e4;\n\nuint256 constant SECONDS_PER_YEAR = 365 days;\nuint256 constant EPOCH_LENGTH = 7 days;\nuint256 constant FIRST_EPOCH_TIMESTAMP = 1702900800;\nuint256 constant EPOCHS_TO_WITHDRAW = 4;\n\nuint8 constant MAX_SANE_ENABLED_TOKENS = 20;\nuint256 constant MAX_SANE_EPOCH_LENGTH = 28 days;\nuint256 constant MAX_SANE_ACTIVE_BOTS = 5;\n\nuint8 constant MAX_WITHDRAW_FEE = 100;\n\nuint8 constant DEFAULT_LIMIT_PER_BLOCK_MULTIPLIER = 2;\n\nuint8 constant BOT_PERMISSIONS_SET_FLAG = 1;\n\nuint256 constant UNDERLYING_TOKEN_MASK = 1;\n\naddress constant INACTIVE_CREDIT_ACCOUNT_ADDRESS = address(1);\n"
    },
    "lib/@gearbox-protocol/core-v3/contracts/libraries/BitMask.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Foundation, 2024.\npragma solidity ^0.8.17;\n\nimport {IncorrectParameterException} from \"../interfaces/IExceptions.sol\";\n\n/// @title Bit mask library\n/// @notice Implements functions that manipulate bit masks\n///         Bit masks are utilized extensively by Gearbox to efficiently store token sets (enabled tokens on accounts\n///         or forbidden tokens) and check for set inclusion. A mask is a uint256 number that has its i-th bit set to\n///         1 if i-th item is included into the set. For example, each token has a mask equal to 2**i, so set inclusion\n///         can be checked by checking tokenMask & setMask != 0.\nlibrary BitMask {\n    /// @dev Calculates the number of `1` bits\n    /// @param enabledTokensMask Bit mask to compute the number of `1` bits in\n    function calcEnabledTokens(uint256 enabledTokensMask) internal pure returns (uint256 totalTokensEnabled) {\n        unchecked {\n            while (enabledTokensMask > 0) {\n                enabledTokensMask &= enabledTokensMask - 1; // U:[BM-3]\n                ++totalTokensEnabled; // U:[BM-3]\n            }\n        }\n    }\n\n    /// @dev Enables bits from the second mask in the first mask\n    /// @param enabledTokenMask The initial mask\n    /// @param bitsToEnable Mask of bits to enable\n    function enable(uint256 enabledTokenMask, uint256 bitsToEnable) internal pure returns (uint256) {\n        return enabledTokenMask | bitsToEnable; // U:[BM-4]\n    }\n\n    /// @dev Disables bits from the second mask in the first mask\n    /// @param enabledTokenMask The initial mask\n    /// @param bitsToDisable Mask of bits to disable\n    function disable(uint256 enabledTokenMask, uint256 bitsToDisable) internal pure returns (uint256) {\n        return enabledTokenMask & ~bitsToDisable; // U:[BM-4]\n    }\n\n    /// @dev Computes a new mask with sets of new enabled and disabled bits\n    /// @dev bitsToEnable and bitsToDisable are applied sequentially to original mask\n    /// @param enabledTokensMask The initial mask\n    /// @param bitsToEnable Mask with bits to enable\n    /// @param bitsToDisable Mask with bits to disable\n    function enableDisable(uint256 enabledTokensMask, uint256 bitsToEnable, uint256 bitsToDisable)\n        internal\n        pure\n        returns (uint256)\n    {\n        return (enabledTokensMask | bitsToEnable) & (~bitsToDisable); // U:[BM-5]\n    }\n\n    /// @dev Returns a mask with only the least significant bit of `mask` enabled\n    /// @dev This function can be used to efficiently iterate over enabled bits in a mask\n    function lsbMask(uint256 mask) internal pure returns (uint256) {\n        unchecked {\n            return mask & uint256(-int256(mask)); // U:[BM-6]\n        }\n    }\n}\n"
    },
    "lib/@gearbox-protocol/integrations-v3/contracts/adapters/AbstractAdapter.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Foundation, 2024.\npragma solidity ^0.8.23;\n\nimport {IAdapter} from \"@gearbox-protocol/core-v3/contracts/interfaces/base/IAdapter.sol\";\nimport {ICreditManagerV3} from \"@gearbox-protocol/core-v3/contracts/interfaces/ICreditManagerV3.sol\";\nimport {PoolV3} from \"@gearbox-protocol/core-v3/contracts/pool/PoolV3.sol\";\nimport {CallerNotCreditFacadeException} from \"@gearbox-protocol/core-v3/contracts/interfaces/IExceptions.sol\";\nimport {ACLTrait} from \"@gearbox-protocol/core-v3/contracts/traits/ACLTrait.sol\";\nimport {SanityCheckTrait} from \"@gearbox-protocol/core-v3/contracts/traits/SanityCheckTrait.sol\";\n\n/// @title Abstract adapter\n/// @dev Inheriting adapters MUST use provided internal functions to perform all operations with credit accounts\nabstract contract AbstractAdapter is IAdapter, ACLTrait, SanityCheckTrait {\n    /// @notice Credit manager the adapter is connected to\n    address public immutable override creditManager;\n\n    /// @notice Address of the contract the adapter is interacting with\n    address public immutable override targetContract;\n\n    /// @notice Constructor\n    /// @param _creditManager Credit manager to connect the adapter to\n    /// @param _targetContract Address of the adapted contract\n    constructor(address _creditManager, address _targetContract)\n        ACLTrait(PoolV3(ICreditManagerV3(_creditManager).pool()).acl())\n        nonZeroAddress(_targetContract)\n    {\n        creditManager = _creditManager;\n        targetContract = _targetContract;\n    }\n\n    /// @dev Ensures that caller of the function is credit facade connected to the credit manager\n    /// @dev Inheriting adapters MUST use this modifier in all external functions that operate on credit accounts\n    modifier creditFacadeOnly() {\n        _revertIfCallerNotCreditFacade();\n        _;\n    }\n\n    /// @dev Ensures that caller is credit facade connected to the credit manager\n    function _revertIfCallerNotCreditFacade() internal view {\n        if (msg.sender != ICreditManagerV3(creditManager).creditFacade()) {\n            revert CallerNotCreditFacadeException();\n        }\n    }\n\n    /// @dev Ensures that active credit account is set and returns its address\n    function _creditAccount() internal view returns (address) {\n        return ICreditManagerV3(creditManager).getActiveCreditAccountOrRevert();\n    }\n\n    /// @dev Ensures that token is registered as collateral in the credit manager and returns its mask\n    function _getMaskOrRevert(address token) internal view returns (uint256 tokenMask) {\n        tokenMask = ICreditManagerV3(creditManager).getTokenMaskOrRevert(token);\n    }\n\n    /// @dev Approves target contract to spend given token from the active credit account\n    ///      Reverts if active credit account is not set or token is not registered as collateral\n    /// @param token Token to approve\n    /// @param amount Amount to approve\n    function _approveToken(address token, uint256 amount) internal {\n        ICreditManagerV3(creditManager).approveCreditAccount(token, amount);\n    }\n\n    /// @dev Executes an external call from the active credit account to the target contract\n    ///      Reverts if active credit account is not set\n    /// @param callData Data to call the target contract with\n    /// @return result Call result\n    function _execute(bytes memory callData) internal returns (bytes memory result) {\n        return ICreditManagerV3(creditManager).execute(callData);\n    }\n\n    /// @dev Executes a swap operation with maximum input token approval, and revokes approval after the call\n    ///      Reverts if active credit account is not set or any of passed tokens is not registered as collateral\n    /// @param tokenIn Input token that credit account spends in the call\n    /// @param callData Data to call the target contract with\n    /// @return result Call result\n    /// @custom:expects Credit manager reverts when trying to approve non-collateral token\n    function _executeSwapSafeApprove(address tokenIn, bytes memory callData) internal returns (bytes memory result) {\n        _approveToken(tokenIn, type(uint256).max);\n        result = _execute(callData);\n        _approveToken(tokenIn, 1);\n    }\n}\n"
    },
    "lib/@gearbox-protocol/integrations-v3/contracts/integrations/balancer/IAsset.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.7.0 <0.9.0;\n\n/**\n * @dev This is an empty interface used to represent either ERC20-conforming token contracts or ETH (using the zero\n * address sentinel value). We're just relying on the fact that `interface` can be used to declare new address-like\n * types.\n *\n * This concept is unrelated to a Pool's Asset Managers.\n */\ninterface IAsset {\n// solhint-disable-previous-line no-empty-blocks\n}\n"
    },
    "lib/@gearbox-protocol/core-v3/contracts/interfaces/ICreditFacadeV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Foundation, 2024.\npragma solidity ^0.8.17;\n\nimport {AllowanceAction} from \"./ICreditConfiguratorV3.sol\";\nimport \"./ICreditFacadeV3Multicall.sol\";\nimport {IACLTrait} from \"./base/IACLTrait.sol\";\nimport {PriceUpdate} from \"./base/IPriceFeedStore.sol\";\nimport {IVersion} from \"./base/IVersion.sol\";\n\n/// @notice Multicall element\n/// @param target Call target, which is either credit facade or adapter\n/// @param callData Call data\nstruct MultiCall {\n    address target;\n    bytes callData;\n}\n\n/// @notice Debt limits packed into a single slot\n/// @param minDebt Minimum debt amount per credit account\n/// @param maxDebt Maximum debt amount per credit account\nstruct DebtLimits {\n    uint128 minDebt;\n    uint128 maxDebt;\n}\n\n/// @notice Collateral check params\n/// @param collateralHints Optional array of token masks to check first to reduce the amount of computation\n///        when known subset of account's collateral tokens covers all the debt\n/// @param minHealthFactor Min account's health factor in bps in order not to revert\nstruct FullCheckParams {\n    uint256[] collateralHints;\n    uint16 minHealthFactor;\n}\n\ninterface ICreditFacadeV3Events {\n    /// @notice Emitted when a new credit account is opened\n    event OpenCreditAccount(\n        address indexed creditAccount, address indexed onBehalfOf, address indexed caller, uint256 referralCode\n    );\n\n    /// @notice Emitted when account is closed\n    event CloseCreditAccount(address indexed creditAccount, address indexed borrower);\n\n    /// @notice Emitted when account is liquidated\n    event LiquidateCreditAccount(\n        address indexed creditAccount, address indexed liquidator, address to, uint256 remainingFunds\n    );\n\n    /// @notice Emitted when account is partially liquidated\n    event PartiallyLiquidateCreditAccount(\n        address indexed creditAccount,\n        address indexed token,\n        address indexed liquidator,\n        uint256 repaidDebt,\n        uint256 seizedCollateral,\n        uint256 fee\n    );\n\n    /// @notice Emitted when collateral is added to account\n    event AddCollateral(address indexed creditAccount, address indexed token, uint256 amount);\n\n    /// @notice Emitted when collateral is withdrawn from account\n    event WithdrawCollateral(address indexed creditAccount, address indexed token, uint256 amount, address to);\n\n    /// @notice Emitted when a multicall is started\n    event StartMultiCall(address indexed creditAccount, address indexed caller);\n\n    /// @notice Emitted when phantom token is withdrawn by account\n    event WithdrawPhantomToken(address indexed creditAccount, address indexed token, uint256 amount);\n\n    /// @notice Emitted when a call from account to an external contract is made during a multicall\n    event Execute(address indexed creditAccount, address indexed targetContract);\n\n    /// @notice Emitted when a multicall is finished\n    event FinishMultiCall();\n}\n\n/// @title Credit facade V3 interface\ninterface ICreditFacadeV3 is IVersion, IACLTrait, ICreditFacadeV3Events {\n    function creditManager() external view returns (address);\n\n    function underlying() external view returns (address);\n\n    function treasury() external view returns (address);\n\n    function priceFeedStore() external view returns (address);\n\n    function degenNFT() external view returns (address);\n\n    function weth() external view returns (address);\n\n    function botList() external view returns (address);\n\n    function maxDebtPerBlockMultiplier() external view returns (uint8);\n\n    function maxQuotaMultiplier() external view returns (uint256);\n\n    function expirable() external view returns (bool);\n\n    function expirationDate() external view returns (uint40);\n\n    function debtLimits() external view returns (uint128 minDebt, uint128 maxDebt);\n\n    function lossPolicy() external view returns (address);\n\n    function forbiddenTokenMask() external view returns (uint256);\n\n    // ------------------ //\n    // ACCOUNT MANAGEMENT //\n    // ------------------ //\n\n    function openCreditAccount(address onBehalfOf, MultiCall[] calldata calls, uint256 referralCode)\n        external\n        payable\n        returns (address creditAccount);\n\n    function closeCreditAccount(address creditAccount, MultiCall[] calldata calls) external payable;\n\n    function liquidateCreditAccount(\n        address creditAccount,\n        address to,\n        MultiCall[] calldata calls,\n        bytes memory lossPolicyData\n    ) external;\n\n    function liquidateCreditAccount(address creditAccount, address to, MultiCall[] calldata calls) external;\n\n    function partiallyLiquidateCreditAccount(\n        address creditAccount,\n        address token,\n        uint256 repaidAmount,\n        uint256 minSeizedAmount,\n        address to,\n        PriceUpdate[] calldata priceUpdates\n    ) external returns (uint256 seizedAmount);\n\n    function multicall(address creditAccount, MultiCall[] calldata calls) external payable;\n\n    function botMulticall(address creditAccount, MultiCall[] calldata calls) external;\n\n    // ------------- //\n    // CONFIGURATION //\n    // ------------- //\n\n    function setExpirationDate(uint40 newExpirationDate) external;\n\n    function setDebtLimits(uint128 newMinDebt, uint128 newMaxDebt, uint8 newMaxDebtPerBlockMultiplier) external;\n\n    function setLossPolicy(address newLossPolicy) external;\n\n    function setTokenAllowance(address token, AllowanceAction allowance) external;\n\n    function pause() external;\n\n    function unpause() external;\n}\n"
    },
    "contracts/interfaces/IRouterComponent.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Gearbox. Generalized leverage protocol that allows to take leverage and then use it across other DeFi protocols and platforms in a composable way.\n// (c) Gearbox.fi, 2021\npragma solidity ^0.8.10;\n\ninterface IRouterComponent {\n    function contractType() external view returns (bytes32);\n\n    function version() external view returns (uint256);\n}\n"
    },
    "lib/@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "contracts/data/RouterResult.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Holdings, 2025\npragma solidity ^0.8.10;\n\nimport {RAY} from \"@gearbox-protocol/core-v3/contracts/libraries/Constants.sol\";\nimport {MultiCall, MultiCallOps} from \"../lib/MultiCall.sol\";\n\nstruct RouterResult {\n    uint256 amount;\n    uint256 minAmount;\n    MultiCall[] calls;\n}\n\nlibrary RouterResultOps {\n    using MultiCallOps for MultiCall[];\n\n    function trim(RouterResult memory r) internal pure returns (RouterResult memory) {\n        r.calls = r.calls.trim();\n        return r;\n    }\n\n    function isBetter(RouterResult memory pfr1, RouterResult memory pfr2) internal pure returns (bool) {\n        return pfr1.amount > pfr2.amount;\n    }\n}\n"
    },
    "lib/@gearbox-protocol/core-v3/contracts/interfaces/IExceptions.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Foundation, 2024.\npragma solidity ^0.8.17;\n\n// ------- //\n// GENERAL //\n// ------- //\n\n/// @notice Thrown on attempting to set an important address to zero address\nerror ZeroAddressException();\n\n/// @notice Thrown when attempting to pass a zero amount to a funding-related operation\nerror AmountCantBeZeroException();\n\n/// @notice Thrown on incorrect input parameter\nerror IncorrectParameterException();\n\n/// @notice Thrown when balance is insufficient to perform an operation\nerror InsufficientBalanceException();\n\n/// @notice Thrown if parameter is out of range\nerror ValueOutOfRangeException();\n\n/// @notice Thrown when trying to send ETH to a contract that is not allowed to receive ETH directly\nerror ReceiveIsNotAllowedException();\n\n/// @notice Thrown on attempting to set an EOA as an important contract in the system\nerror AddressIsNotContractException(address);\n\n/// @notice Thrown on attempting to receive a token that is not a collateral token or was forbidden\nerror TokenNotAllowedException();\n\n/// @notice Thrown on attempting to add a token that is already in a collateral list\nerror TokenAlreadyAddedException();\n\n/// @notice Thrown when attempting to use quota-related logic for a token that is not quoted in quota keeper\nerror TokenIsNotQuotedException();\n\n/// @notice Thrown on attempting to interact with an address that is not a valid target contract\nerror TargetContractNotAllowedException();\n\n/// @notice Thrown if function is not implemented\nerror NotImplementedException();\n\n// ------------------ //\n// CONTRACTS REGISTER //\n// ------------------ //\n\n/// @notice Thrown when an address is expected to be a registered credit manager, but is not\nerror RegisteredCreditManagerOnlyException();\n\n/// @notice Thrown when an address is expected to be a registered pool, but is not\nerror RegisteredPoolOnlyException();\n\n// ---------------- //\n// ADDRESS PROVIDER //\n// ---------------- //\n\n/// @notice Reverts if address key isn't found in address provider\nerror AddressNotFoundException();\n\n// ----------------- //\n// POOL, PQK, GAUGES //\n// ----------------- //\n\n/// @notice Thrown by pool-adjacent contracts when a credit manager being connected has a wrong pool address\nerror IncompatibleCreditManagerException();\n\n/// @notice Thrown when attempting to set an incompatible successor staking contract\nerror IncompatibleSuccessorException();\n\n/// @notice Thrown when attempting to vote in a non-approved contract\nerror VotingContractNotAllowedException();\n\n/// @notice Thrown when attempting to unvote more votes than there are\nerror InsufficientVotesException();\n\n/// @notice Thrown when attempting to borrow more than the second point on a two-point curve\nerror BorrowingMoreThanU2ForbiddenException();\n\n/// @notice Thrown when a credit manager attempts to borrow more than its limit in the current block, or in general\nerror CreditManagerCantBorrowException();\n\n/// @notice Thrown when attempting to connect a quota keeper to an incompatible pool\nerror IncompatiblePoolQuotaKeeperException();\n\n/// @notice Thrown when attempting to connect a gauge to an incompatible pool quota keeper\nerror IncompatibleGaugeException();\n\n/// @notice Thrown when the quota is outside of min/max bounds\nerror QuotaIsOutOfBoundsException();\n\n// -------------- //\n// CREDIT MANAGER //\n// -------------- //\n\n/// @notice Thrown on failing a full collateral check after multicall\nerror NotEnoughCollateralException();\n\n/// @notice Thrown if an attempt to approve a collateral token to adapter's target contract fails\nerror AllowanceFailedException();\n\n/// @notice Thrown on attempting to perform an action for a credit account that does not exist\nerror CreditAccountDoesNotExistException();\n\n/// @notice Thrown on configurator attempting to add more than 255 collateral tokens\nerror TooManyTokensException();\n\n/// @notice Thrown if more than the maximum number of tokens were enabled on a credit account\nerror TooManyEnabledTokensException();\n\n/// @notice Thrown when attempting to execute a protocol interaction without active credit account set\nerror ActiveCreditAccountNotSetException();\n\n/// @notice Thrown when trying to update credit account's debt more than once in the same block\nerror DebtUpdatedTwiceInOneBlockException();\n\n/// @notice Thrown when trying to repay all debt while having active quotas\nerror DebtToZeroWithActiveQuotasException();\n\n/// @notice Thrown when a zero-debt account attempts to update quota\nerror UpdateQuotaOnZeroDebtAccountException();\n\n/// @notice Thrown when attempting to close an account with non-zero debt\nerror CloseAccountWithNonZeroDebtException();\n\n/// @notice Thrown when value of funds remaining on the account after liquidation is insufficient\nerror InsufficientRemainingFundsException();\n\n/// @notice Thrown when Credit Facade tries to write over a non-zero active Credit Account\nerror ActiveCreditAccountOverridenException();\n\n// ------------------- //\n// CREDIT CONFIGURATOR //\n// ------------------- //\n\n/// @notice Thrown on attempting to use a non-ERC20 contract or an EOA as a token\nerror IncorrectTokenContractException();\n\n/// @notice Thrown if the newly set LT if zero or greater than the underlying's LT\nerror IncorrectLiquidationThresholdException();\n\n/// @notice Thrown if borrowing limits are incorrect: minLimit > maxLimit or maxLimit > blockLimit\nerror IncorrectLimitsException();\n\n/// @notice Thrown if the new expiration date is less than the current expiration date or current timestamp\nerror IncorrectExpirationDateException();\n\n/// @notice Thrown if a contract returns a wrong credit manager or reverts when trying to retrieve it\nerror IncompatibleContractException();\n\n/// @notice Thrown if attempting to forbid an adapter that is not registered in the credit manager\nerror AdapterIsNotRegisteredException();\n\n/// @notice Thrown if new credit configurator's set of allowed adapters differs from the current one\nerror IncorrectAdaptersSetException();\n\n/// @notice Thrown if attempting to schedule a token's LT ramping that is too short in duration\nerror RampDurationTooShortException();\n\n/// @notice Thrown if attempting to set liquidation fees such that the sum of premium and fee changes\nerror InconsistentLiquidationFeesException();\n\n/// @notice Thrown if attempting to set expired liquidation fees such that the sum of premium and fee changes\nerror InconsistentExpiredLiquidationFeesException();\n\n// ------------- //\n// CREDIT FACADE //\n// ------------- //\n\n/// @notice Thrown when attempting to perform an action that is forbidden in whitelisted mode\nerror ForbiddenInWhitelistedModeException();\n\n/// @notice Thrown if credit facade is not expirable, and attempted aciton requires expirability\nerror NotAllowedWhenNotExpirableException();\n\n/// @notice Thrown if a selector that doesn't match any allowed function is passed to the credit facade in a multicall\nerror UnknownMethodException(bytes4 selector);\n\n/// @notice Thrown if a liquidator tries to liquidate an account with a health factor above 1\nerror CreditAccountNotLiquidatableException();\n\n/// @notice Thrown if a liquidator tries to liquidate an account with loss but violates the loss policy\nerror CreditAccountNotLiquidatableWithLossException();\n\n/// @notice Thrown if too much new debt was taken within a single block\nerror BorrowedBlockLimitException();\n\n/// @notice Thrown if the new debt principal for a credit account falls outside of borrowing limits\nerror BorrowAmountOutOfLimitsException();\n\n/// @notice Thrown if a user attempts to open an account via an expired credit facade\nerror NotAllowedAfterExpirationException();\n\n/// @notice Thrown if expected balances are attempted to be set twice without performing a slippage check\nerror ExpectedBalancesAlreadySetException();\n\n/// @notice Thrown if attempting to perform a slippage check when excepted balances are not set\nerror ExpectedBalancesNotSetException();\n\n/// @notice Thrown if balance of at least one token is less than expected during a slippage check\nerror BalanceLessThanExpectedException(address token);\n\n/// @notice Thrown when trying to perform an action that is forbidden when credit account has enabled forbidden tokens\nerror ForbiddenTokensException(uint256 forbiddenTokensMask);\n\n/// @notice Thrown when forbidden token quota is increased during the multicall\nerror ForbiddenTokenQuotaIncreasedException(address token);\n\n/// @notice Thrown when enabled forbidden token balance is increased during the multicall\nerror ForbiddenTokenBalanceIncreasedException(address token);\n\n/// @notice Thrown when the remaining token balance is increased during the liquidation\nerror RemainingTokenBalanceIncreasedException(address token);\n\n/// @notice Thrown if `botMulticall` is called by an address that is not approved by account owner or is forbidden\nerror NotApprovedBotException(address bot);\n\n/// @notice Thrown when attempting to perform a multicall action with no permission for it\nerror NoPermissionException(uint256 permission);\n\n/// @notice Thrown when attempting to give a bot unexpected permissions\nerror UnexpectedPermissionsException(uint256 permissions);\n\n/// @notice Thrown when a custom HF parameter lower than 10000 is passed into the full collateral check\nerror CustomHealthFactorTooLowException();\n\n/// @notice Thrown when submitted collateral hint is not a valid token mask\nerror InvalidCollateralHintException(uint256 mask);\n\n/// @notice Thrown when trying to seize underlying token during partial liquidation\nerror UnderlyingIsNotLiquidatableException();\n\n/// @notice Thrown when amount of collateral seized during partial liquidation is less than required\nerror SeizedLessThanRequiredException(uint256 seizedAmount);\n\n// ------ //\n// ACCESS //\n// ------ //\n\n/// @notice Thrown on attempting to call an access restricted function not as credit account owner\nerror CallerNotCreditAccountOwnerException();\n\n/// @notice Thrown on attempting to call an access restricted function not as configurator\nerror CallerNotConfiguratorException();\n\n/// @notice Thrown on attempting to call an access-restructed function not as account factory\nerror CallerNotAccountFactoryException();\n\n/// @notice Thrown on attempting to call an access restricted function not as credit manager\nerror CallerNotCreditManagerException();\n\n/// @notice Thrown on attempting to call an access restricted function not as credit facade\nerror CallerNotCreditFacadeException();\n\n/// @notice Thrown on attempting to pause a contract without pausable admin rights\nerror CallerNotPausableAdminException();\n\n/// @notice Thrown on attempting to unpause a contract without unpausable admin rights\nerror CallerNotUnpausableAdminException();\n\n/// @notice Thrown on attempting to call an access restricted function not as gauge\nerror CallerNotGaugeException();\n\n/// @notice Thrown on attempting to call an access restricted function not as quota keeper\nerror CallerNotPoolQuotaKeeperException();\n\n/// @notice Thrown on attempting to call an access restricted function not as voter\nerror CallerNotVoterException();\n\n/// @notice Thrown on attempting to call an access restricted function not as allowed adapter\nerror CallerNotAdapterException();\n\n/// @notice Thrown on attempting to call an access restricted function not as migrator\nerror CallerNotMigratorException();\n\n/// @notice Thrown when an address that is not the designated executor attempts to execute a transaction\nerror CallerNotExecutorException();\n\n/// @notice Thrown on attempting to call an access restricted function not as veto admin\nerror CallerNotVetoAdminException();\n\n// -------- //\n// BOT LIST //\n// -------- //\n\n/// @notice Thrown when attempting to set non-zero permissions for a forbidden bot\nerror InvalidBotException();\n\n/// @notice Thrown when attempting to set permissions for a bot that don't meet its requirements\nerror IncorrectBotPermissionsException();\n\n/// @notice Thrown when attempting to set non-zero permissions for too many bots\nerror TooManyActiveBotsException();\n\n// --------------- //\n// ACCOUNT FACTORY //\n// --------------- //\n\n/// @notice Thrown when trying to deploy second master credit account for a credit manager\nerror MasterCreditAccountAlreadyDeployedException();\n\n/// @notice Thrown when trying to rescue funds from a credit account that is currently in use\nerror CreditAccountIsInUseException();\n\n// ------------ //\n// PRICE ORACLE //\n// ------------ //\n\n/// @notice Thrown on attempting to set a token price feed to an address that is not a correct price feed\nerror IncorrectPriceFeedException();\n\n/// @notice Thrown on attempting to interact with a price feed for a token not added to the price oracle\nerror PriceFeedDoesNotExistException();\n\n/// @notice Thrown when trying to apply an on-demand price update to a non-updatable price feed\nerror PriceFeedIsNotUpdatableException();\n\n/// @notice Thrown when price feed returns incorrect price for a token\nerror IncorrectPriceException();\n\n/// @notice Thrown when token's price feed becomes stale\nerror StalePriceException();\n"
    },
    "lib/@gearbox-protocol/core-v3/contracts/interfaces/ICreditManagerV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Foundation, 2024.\npragma solidity ^0.8.17;\n\nimport {IVersion} from \"./base/IVersion.sol\";\n\n/// @notice Debt management type\n///         - `INCREASE_DEBT` borrows additional funds from the pool, updates account's debt and cumulative interest index\n///         - `DECREASE_DEBT` repays debt components (quota interest and fees -> base interest and fees -> debt principal)\n///           and updates all corresponding state variables (base interest index, quota interest and fees, debt).\n///           When repaying all the debt, ensures that account has no enabled quotas.\nenum ManageDebtAction {\n    INCREASE_DEBT,\n    DECREASE_DEBT\n}\n\n/// @notice Collateral/debt calculation mode\n///         - `GENERIC_PARAMS` returns generic data like account debt and cumulative indexes\n///         - `DEBT_ONLY` is same as `GENERIC_PARAMS` but includes more detailed debt info, like accrued base/quota\n///           interest and fees\n///         - `FULL_COLLATERAL_CHECK_LAZY` checks whether account is sufficiently collateralized in a lazy fashion,\n///           i.e. it stops iterating over collateral tokens once TWV reaches the desired target.\n///           Since it may return underestimated TWV, it's only available for internal use.\n///         - `DEBT_COLLATERAL` is same as `DEBT_ONLY` but also returns total value and total LT-weighted value of\n///           account's tokens, this mode is used during account liquidation\n///         - `DEBT_COLLATERAL_SAFE_PRICES` is same as `DEBT_COLLATERAL` but uses safe prices from price oracle\nenum CollateralCalcTask {\n    GENERIC_PARAMS,\n    DEBT_ONLY,\n    FULL_COLLATERAL_CHECK_LAZY,\n    DEBT_COLLATERAL,\n    DEBT_COLLATERAL_SAFE_PRICES\n}\n\nstruct CreditAccountInfo {\n    uint256 debt;\n    uint256 cumulativeIndexLastUpdate;\n    uint128 cumulativeQuotaInterest;\n    uint128 quotaFees;\n    uint256 enabledTokensMask;\n    uint16 flags;\n    uint64 lastDebtUpdate;\n    address borrower;\n}\n\nstruct CollateralDebtData {\n    uint256 debt;\n    uint256 cumulativeIndexNow;\n    uint256 cumulativeIndexLastUpdate;\n    uint128 cumulativeQuotaInterest;\n    uint256 accruedInterest;\n    uint256 accruedFees;\n    uint256 totalDebtUSD;\n    uint256 totalValue;\n    uint256 totalValueUSD;\n    uint256 twvUSD;\n    uint256 enabledTokensMask;\n    uint256 quotedTokensMask;\n    address[] quotedTokens;\n    address _poolQuotaKeeper;\n}\n\nstruct CollateralTokenData {\n    address token;\n    uint16 ltInitial;\n    uint16 ltFinal;\n    uint40 timestampRampStart;\n    uint24 rampDuration;\n}\n\ninterface ICreditManagerV3Events {\n    /// @notice Emitted when new credit configurator is set\n    event SetCreditConfigurator(address indexed newConfigurator);\n}\n\n/// @title Credit manager V3 interface\ninterface ICreditManagerV3 is IVersion, ICreditManagerV3Events {\n    function pool() external view returns (address);\n\n    function underlying() external view returns (address);\n\n    function creditFacade() external view returns (address);\n\n    function creditConfigurator() external view returns (address);\n\n    function accountFactory() external view returns (address);\n\n    function name() external view returns (string memory);\n\n    // ------------------ //\n    // ACCOUNT MANAGEMENT //\n    // ------------------ //\n\n    function openCreditAccount(address onBehalfOf) external returns (address);\n\n    function closeCreditAccount(address creditAccount) external;\n\n    function liquidateCreditAccount(\n        address creditAccount,\n        CollateralDebtData calldata collateralDebtData,\n        address to,\n        bool isExpired\n    ) external returns (uint256 remainingFunds, uint256 loss);\n\n    function manageDebt(address creditAccount, uint256 amount, uint256 enabledTokensMask, ManageDebtAction action)\n        external\n        returns (uint256 newDebt, uint256, uint256);\n\n    function addCollateral(address payer, address creditAccount, address token, uint256 amount)\n        external\n        returns (uint256);\n\n    function withdrawCollateral(address creditAccount, address token, uint256 amount, address to)\n        external\n        returns (uint256);\n\n    function externalCall(address creditAccount, address target, bytes calldata callData)\n        external\n        returns (bytes memory result);\n\n    function approveToken(address creditAccount, address token, address spender, uint256 amount) external;\n\n    // -------- //\n    // ADAPTERS //\n    // -------- //\n\n    function adapterToContract(address adapter) external view returns (address targetContract);\n\n    function contractToAdapter(address targetContract) external view returns (address adapter);\n\n    function execute(bytes calldata data) external returns (bytes memory result);\n\n    function approveCreditAccount(address token, uint256 amount) external;\n\n    function setActiveCreditAccount(address creditAccount) external;\n\n    function getActiveCreditAccountOrRevert() external view returns (address creditAccount);\n\n    // ----------------- //\n    // COLLATERAL CHECKS //\n    // ----------------- //\n\n    function priceOracle() external view returns (address);\n\n    function fullCollateralCheck(\n        address creditAccount,\n        uint256 enabledTokensMask,\n        uint256[] calldata collateralHints,\n        uint16 minHealthFactor,\n        bool useSafePrices\n    ) external returns (uint256);\n\n    function isLiquidatable(address creditAccount, uint16 minHealthFactor) external view returns (bool);\n\n    function calcDebtAndCollateral(address creditAccount, CollateralCalcTask task)\n        external\n        view\n        returns (CollateralDebtData memory cdd);\n\n    // ------ //\n    // QUOTAS //\n    // ------ //\n\n    function poolQuotaKeeper() external view returns (address);\n\n    function quotedTokensMask() external view returns (uint256);\n\n    function updateQuota(address creditAccount, address token, int96 quotaChange, uint96 minQuota, uint96 maxQuota)\n        external\n        returns (uint256 tokensToEnable, uint256 tokensToDisable);\n\n    // --------------------- //\n    // CREDIT MANAGER PARAMS //\n    // --------------------- //\n\n    function maxEnabledTokens() external view returns (uint8);\n\n    function fees()\n        external\n        view\n        returns (\n            uint16 feeInterest,\n            uint16 feeLiquidation,\n            uint16 liquidationDiscount,\n            uint16 feeLiquidationExpired,\n            uint16 liquidationDiscountExpired\n        );\n\n    function collateralTokensCount() external view returns (uint8);\n\n    function getTokenMaskOrRevert(address token) external view returns (uint256 tokenMask);\n\n    function getTokenByMask(uint256 tokenMask) external view returns (address token);\n\n    function liquidationThresholds(address token) external view returns (uint16 lt);\n\n    function ltParams(address token)\n        external\n        view\n        returns (uint16 ltInitial, uint16 ltFinal, uint40 timestampRampStart, uint24 rampDuration);\n\n    function collateralTokenByMask(uint256 tokenMask)\n        external\n        view\n        returns (address token, uint16 liquidationThreshold);\n\n    // ------------ //\n    // ACCOUNT INFO //\n    // ------------ //\n\n    function creditAccountInfo(address creditAccount)\n        external\n        view\n        returns (\n            uint256 debt,\n            uint256 cumulativeIndexLastUpdate,\n            uint128 cumulativeQuotaInterest,\n            uint128 quotaFees,\n            uint256 enabledTokensMask,\n            uint16 flags,\n            uint64 lastDebtUpdate,\n            address borrower\n        );\n\n    function getBorrowerOrRevert(address creditAccount) external view returns (address borrower);\n\n    function flagsOf(address creditAccount) external view returns (uint16);\n\n    function setFlagFor(address creditAccount, uint16 flag, bool value) external;\n\n    function enabledTokensMaskOf(address creditAccount) external view returns (uint256);\n\n    function creditAccounts() external view returns (address[] memory);\n\n    function creditAccounts(uint256 offset, uint256 limit) external view returns (address[] memory);\n\n    function creditAccountsLen() external view returns (uint256);\n\n    // ------------- //\n    // CONFIGURATION //\n    // ------------- //\n\n    function addToken(address token) external;\n\n    function setCollateralTokenData(\n        address token,\n        uint16 ltInitial,\n        uint16 ltFinal,\n        uint40 timestampRampStart,\n        uint24 rampDuration\n    ) external;\n\n    function setFees(\n        uint16 feeInterest,\n        uint16 feeLiquidation,\n        uint16 liquidationDiscount,\n        uint16 feeLiquidationExpired,\n        uint16 liquidationDiscountExpired\n    ) external;\n\n    function setContractAllowance(address adapter, address targetContract) external;\n\n    function setCreditFacade(address creditFacade) external;\n\n    function setPriceOracle(address priceOracle) external;\n\n    function setCreditConfigurator(address creditConfigurator) external;\n}\n"
    },
    "lib/@gearbox-protocol/core-v3/contracts/pool/PoolV3.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Foundation, 2024.\npragma solidity ^0.8.17;\npragma abicoder v1;\n\nimport {SafeERC20} from \"@1inch/solidity-utils/contracts/libraries/SafeERC20.sol\";\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC4626} from \"@openzeppelin/contracts/interfaces/IERC4626.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/interfaces/IERC20Metadata.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {ERC4626} from \"@openzeppelin/contracts/token/ERC20/extensions/ERC4626.sol\";\nimport {ERC20Permit} from \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol\";\n\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport {Pausable} from \"@openzeppelin/contracts/security/Pausable.sol\";\n\n// INTERFACES\nimport {ICreditManagerV3} from \"../interfaces/ICreditManagerV3.sol\";\nimport {IPoolQuotaKeeperV3} from \"../interfaces/IPoolQuotaKeeperV3.sol\";\nimport {IPoolV3} from \"../interfaces/IPoolV3.sol\";\nimport {IInterestRateModel} from \"../interfaces/base/IInterestRateModel.sol\";\n\n// LIBS & TRAITS\nimport {CreditLogic} from \"../libraries/CreditLogic.sol\";\nimport {ACLTrait} from \"../traits/ACLTrait.sol\";\nimport {ContractsRegisterTrait} from \"../traits/ContractsRegisterTrait.sol\";\nimport {ReentrancyGuardTrait} from \"../traits/ReentrancyGuardTrait.sol\";\nimport {SanityCheckTrait} from \"../traits/SanityCheckTrait.sol\";\n\n// CONSTANTS\nimport {RAY, MAX_WITHDRAW_FEE, PERCENTAGE_FACTOR} from \"../libraries/Constants.sol\";\n\n// EXCEPTIONS\nimport \"../interfaces/IExceptions.sol\";\n\n/// @dev Struct that holds borrowed amount and debt limit\nstruct DebtParams {\n    uint128 borrowed;\n    uint128 limit;\n}\n\n/// @title Pool V3\n/// @notice Pool contract that implements lending and borrowing logic, compatible with ERC-4626 standard and\n///         supporting EIP-2612 permits. Pool's underlying is expected to be your normal ERC-20 token:\n///         - no rebasing or any calculations that can affect transfers accuracy (fee-on-transfer tokens can\n///         be supported though by overriding `_amountWithFee` and `_amountMinusFee` functions)\n///         - such scale that amounts fit into `uint96` and are not sensitive to ~4 digits precision loss\n///         (nearly all tokens with decimals between 6 and 18 work)\n/// @dev To prevent the first depositor front-running attack, small amount of shares must be minted to some\n///      dead address before allowing borrowing\ncontract PoolV3 is\n    ERC4626,\n    ERC20Permit,\n    Pausable,\n    ReentrancyGuardTrait,\n    SanityCheckTrait,\n    ACLTrait,\n    ContractsRegisterTrait,\n    IPoolV3\n{\n    using Math for uint256;\n    using SafeCast for int256;\n    using SafeCast for uint256;\n    using CreditLogic for uint256;\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using SafeERC20 for IERC20;\n\n    /// @notice Contract version\n    uint256 public constant override version = 3_10;\n\n    /// @notice Protocol treasury address\n    address public immutable override treasury;\n\n    /// @notice Interest rate model contract address\n    address public override interestRateModel;\n    /// @notice Timestamp of the last base interest rate and index update\n    uint40 public override lastBaseInterestUpdate;\n    /// @notice Timestamp of the last quota revenue update\n    uint40 public override lastQuotaRevenueUpdate;\n    /// @notice Withdrawal fee in bps\n    uint16 public override withdrawFee;\n\n    /// @notice Pool quota keeper contract address\n    address public override poolQuotaKeeper;\n    /// @dev Current quota revenue\n    uint96 internal _quotaRevenue;\n\n    /// @dev Current base interest rate in ray\n    uint128 internal _baseInterestRate;\n    /// @dev Cumulative base interest index stored as of last update in ray\n    uint128 internal _baseInterestIndexLU;\n\n    /// @dev Expected liquidity stored as of last update\n    uint128 internal _expectedLiquidityLU;\n\n    /// @dev Aggregate debt params\n    DebtParams internal _totalDebt;\n\n    /// @dev Mapping credit manager => debt params\n    mapping(address => DebtParams) internal _creditManagerDebt;\n\n    /// @dev List of all connected credit managers\n    EnumerableSet.AddressSet internal _creditManagerSet;\n\n    /// @dev Ensures that function can only be called by the pool quota keeper\n    modifier poolQuotaKeeperOnly() {\n        _revertIfCallerIsNotPoolQuotaKeeper();\n        _;\n    }\n\n    /// @notice Constructor\n    /// @param acl_ ACL contract address\n    /// @param contractsRegister_ Contracts register address\n    /// @param underlyingToken_ Pool underlying token address\n    /// @param treasury_ Treasury address\n    /// @param interestRateModel_ Interest rate model contract address\n    /// @param totalDebtLimit_ Initial total debt limit, `type(uint256).max` for no limit\n    /// @param name_ Name of the pool\n    /// @param symbol_ Symbol of the pool's LP token\n    constructor(\n        address acl_,\n        address contractsRegister_,\n        address underlyingToken_,\n        address treasury_,\n        address interestRateModel_,\n        uint256 totalDebtLimit_,\n        string memory name_,\n        string memory symbol_\n    )\n        ACLTrait(acl_) // U:[LP-1A]\n        ContractsRegisterTrait(contractsRegister_)\n        ERC4626(IERC20(underlyingToken_)) // U:[LP-1B]\n        ERC20(name_, symbol_) // U:[LP-1B]\n        ERC20Permit(name_) // U:[LP-1B]\n        nonZeroAddress(underlyingToken_) // U:[LP-1A]\n        nonZeroAddress(treasury_) // U:[LP-1A]\n        nonZeroAddress(interestRateModel_) // U:[LP-1A]\n    {\n        if (bytes(name_).length == 0 || bytes(symbol_).length == 0) revert IncorrectParameterException(); // U:[LP-1A]\n\n        treasury = treasury_; // U:[LP-1B]\n\n        lastBaseInterestUpdate = uint40(block.timestamp); // U:[LP-1B]\n        _baseInterestIndexLU = uint128(RAY); // U:[LP-1B]\n\n        interestRateModel = interestRateModel_; // U:[LP-1B]\n        emit SetInterestRateModel(interestRateModel_); // U:[LP-1B]\n\n        _setTotalDebtLimit(totalDebtLimit_); // U:[LP-1B]\n    }\n\n    /// @notice Contract type\n    function contractType() external view virtual override returns (bytes32) {\n        return \"POOL\";\n    }\n\n    /// @notice Pool shares decimals, matches underlying token decimals\n    function decimals() public view override(ERC20, ERC4626, IERC20Metadata) returns (uint8) {\n        return ERC4626.decimals();\n    }\n\n    /// @notice Addresses of all connected credit managers\n    function creditManagers() external view override returns (address[] memory) {\n        return _creditManagerSet.values();\n    }\n\n    /// @notice Pool's underlying token, same as `asset()`\n    /// @dev Exists for backward compatibility\n    function underlyingToken() external view override returns (address) {\n        return asset(); // U:[LP-1B]\n    }\n\n    /// @notice Available liquidity in the pool\n    function availableLiquidity() public view override returns (uint256) {\n        return IERC20(asset()).safeBalanceOf(address(this)); // U:[LP-3]\n    }\n\n    /// @notice Amount of underlying that would be in the pool if debt principal, base interest\n    ///         and quota revenue were fully repaid\n    function expectedLiquidity() public view override returns (uint256) {\n        return _expectedLiquidityLU + _calcBaseInterestAccrued() + _calcQuotaRevenueAccrued(); // U:[LP-4]\n    }\n\n    /// @notice Expected liquidity stored as of last update\n    function expectedLiquidityLU() public view override returns (uint256) {\n        return _expectedLiquidityLU;\n    }\n\n    // ---------------- //\n    // ERC-4626 LENDING //\n    // ---------------- //\n\n    /// @notice Total amount of underlying tokens managed by the pool, same as `expectedLiquidity`\n    function totalAssets() public view override(ERC4626, IERC4626) returns (uint256 assets) {\n        return expectedLiquidity();\n    }\n\n    /// @notice Deposits given amount of underlying tokens to the pool in exchange for pool shares\n    /// @param assets Amount of underlying to deposit\n    /// @param receiver Account to mint pool shares to\n    /// @return shares Number of shares minted\n    function deposit(uint256 assets, address receiver)\n        public\n        override(ERC4626, IERC4626)\n        whenNotPaused // U:[LP-2A]\n        nonReentrant // U:[LP-2B]\n        nonZeroAddress(receiver) // U:[LP-5A]\n        returns (uint256 shares)\n    {\n        uint256 assetsReceived = _amountMinusFee(assets); // U:[LP-6]\n        shares = _convertToShares(assetsReceived, Math.Rounding.Down); // U:[LP-6]\n        _deposit(receiver, assets, assetsReceived, shares); // U:[LP-6]\n    }\n\n    /// @dev Same as `deposit`, but allows to specify the referral code\n    function depositWithReferral(uint256 assets, address receiver, uint256 referralCode)\n        external\n        override\n        returns (uint256 shares)\n    {\n        shares = deposit(assets, receiver); // U:[LP-2A,2B,5A,5B,6]\n        emit Refer(receiver, referralCode, assets); // U:[LP-6]\n    }\n\n    /// @notice Deposits underlying tokens to the pool in exhcange for given number of pool shares\n    /// @param shares Number of shares to mint\n    /// @param receiver Account to mint pool shares to\n    /// @return assets Amount of underlying transferred from caller\n    function mint(uint256 shares, address receiver)\n        public\n        override(ERC4626, IERC4626)\n        whenNotPaused // U:[LP-2A]\n        nonReentrant // U:[LP-2B]\n        nonZeroAddress(receiver) // U:[LP-5A]\n        returns (uint256 assets)\n    {\n        uint256 assetsReceived = _convertToAssets(shares, Math.Rounding.Up); // U:[LP-7]\n        assets = _amountWithFee(assetsReceived); // U:[LP-7]\n        _deposit(receiver, assets, assetsReceived, shares); // U:[LP-7]\n    }\n\n    /// @dev Same as `mint`, but allows to specify the referral code\n    function mintWithReferral(uint256 shares, address receiver, uint256 referralCode)\n        external\n        override\n        returns (uint256 assets)\n    {\n        assets = mint(shares, receiver); // U:[LP-2A,2B,5A,5B,7]\n        emit Refer(receiver, referralCode, assets); // U:[LP-7]\n    }\n\n    /// @notice Burns pool shares in exchange for given amount of underlying tokens\n    /// @param assets Amount of underlying to withdraw\n    /// @param receiver Account to send underlying to\n    /// @param owner Account to burn pool shares from\n    /// @return shares Number of pool shares burned\n    function withdraw(uint256 assets, address receiver, address owner)\n        public\n        override(ERC4626, IERC4626)\n        whenNotPaused // U:[LP-2A]\n        nonReentrant // U:[LP-2B]\n        nonZeroAddress(receiver) // U:[LP-5A]\n        returns (uint256 shares)\n    {\n        uint256 assetsToUser = _amountWithFee(assets);\n        uint256 assetsSent = _amountWithWithdrawalFee(assetsToUser); // U:[LP-8]\n        shares = _convertToShares(assetsSent, Math.Rounding.Up); // U:[LP-8]\n        _withdraw(receiver, owner, assetsSent, assets, assetsToUser, shares); // U:[LP-8]\n    }\n\n    /// @notice Redeems given number of pool shares in exchange for underlying tokens\n    /// @param shares Number of pool shares to redeem\n    /// @param receiver Account to send underlying to\n    /// @param owner Account to burn pool shares from\n    /// @return assets Amount of underlying withdrawn\n    function redeem(uint256 shares, address receiver, address owner)\n        public\n        override(ERC4626, IERC4626)\n        whenNotPaused // U:[LP-2A]\n        nonReentrant // U:[LP-2B]\n        nonZeroAddress(receiver) // U:[LP-5A]\n        returns (uint256 assets)\n    {\n        uint256 assetsSent = _convertToAssets(shares, Math.Rounding.Down); // U:[LP-9]\n        uint256 assetsToUser = _amountMinusWithdrawalFee(assetsSent);\n        assets = _amountMinusFee(assetsToUser); // U:[LP-9]\n        _withdraw(receiver, owner, assetsSent, assets, assetsToUser, shares); // U:[LP-9]\n    }\n\n    /// @notice Number of pool shares that would be minted on depositing `assets`\n    function previewDeposit(uint256 assets) public view override(ERC4626, IERC4626) returns (uint256) {\n        return _convertToShares(_amountMinusFee(assets), Math.Rounding.Down); // U:[LP-10]\n    }\n\n    /// @notice Amount of underlying that would be spent to mint `shares`\n    function previewMint(uint256 shares) public view override(ERC4626, IERC4626) returns (uint256) {\n        return _amountWithFee(_convertToAssets(shares, Math.Rounding.Up)); // U:[LP-10]\n    }\n\n    /// @notice Number of pool shares that would be burned on withdrawing `assets`\n    function previewWithdraw(uint256 assets) public view override(ERC4626, IERC4626) returns (uint256) {\n        return _convertToShares(_amountWithWithdrawalFee(_amountWithFee(assets)), Math.Rounding.Up); // U:[LP-10]\n    }\n\n    /// @notice Amount of underlying that would be received after redeeming `shares`\n    function previewRedeem(uint256 shares) public view override(ERC4626, IERC4626) returns (uint256) {\n        return _amountMinusFee(_amountMinusWithdrawalFee(_convertToAssets(shares, Math.Rounding.Down))); // U:[LP-10]\n    }\n\n    /// @notice Maximum amount of underlying that can be deposited to the pool, 0 if pool is on pause\n    function maxDeposit(address) public view override(ERC4626, IERC4626) returns (uint256) {\n        return paused() ? 0 : type(uint256).max; // U:[LP-11]\n    }\n\n    /// @notice Maximum number of pool shares that can be minted, 0 if pool is on pause\n    function maxMint(address) public view override(ERC4626, IERC4626) returns (uint256) {\n        return paused() ? 0 : type(uint256).max; // U:[LP-11]\n    }\n\n    /// @notice Maximum amount of underlying that can be withdrawn from the pool by `owner`, 0 if pool is on pause\n    function maxWithdraw(address owner) public view override(ERC4626, IERC4626) returns (uint256) {\n        return paused()\n            ? 0\n            : _amountMinusFee(\n                _amountMinusWithdrawalFee(\n                    Math.min(availableLiquidity(), _convertToAssets(balanceOf(owner), Math.Rounding.Down))\n                )\n            ); // U:[LP-11]\n    }\n\n    /// @notice Maximum number of shares that can be redeemed for underlying by `owner`, 0 if pool is on pause\n    function maxRedeem(address owner) public view override(ERC4626, IERC4626) returns (uint256) {\n        return paused() ? 0 : Math.min(balanceOf(owner), _convertToShares(availableLiquidity(), Math.Rounding.Down)); // U:[LP-11]\n    }\n\n    /// @dev `deposit` / `mint` implementation\n    ///      - transfers underlying from the caller\n    ///      - updates base interest rate and index\n    ///      - mints pool shares to `receiver`\n    function _deposit(address receiver, uint256 assetsSent, uint256 assetsReceived, uint256 shares) internal {\n        if (assetsReceived == 0 || shares == 0) revert AmountCantBeZeroException(); // U:[LP-5B]\n        IERC20(asset()).safeTransferFrom({from: msg.sender, to: address(this), amount: assetsSent}); // U:[LP-6,7]\n\n        _updateBaseInterest({\n            expectedLiquidityDelta: assetsReceived.toInt256(),\n            availableLiquidityDelta: 0,\n            checkOptimalBorrowing: false\n        }); // U:[LP-6,7]\n\n        _mint(receiver, shares); // U:[LP-6,7]\n        emit Deposit(msg.sender, receiver, assetsSent, shares); // U:[LP-6,7]\n    }\n\n    /// @dev `withdraw` / `redeem` implementation\n    ///      - burns pool shares from `owner`\n    ///      - updates base interest rate and index\n    ///      - transfers underlying to `receiver` and, if withdrawal fee is activated, to the treasury\n    function _withdraw(\n        address receiver,\n        address owner,\n        uint256 assetsSent,\n        uint256 assetsReceived,\n        uint256 amountToUser,\n        uint256 shares\n    ) internal {\n        if (assetsReceived == 0 || shares == 0) revert AmountCantBeZeroException(); // U:[LP-5B]\n        if (msg.sender != owner) _spendAllowance({owner: owner, spender: msg.sender, amount: shares}); // U:[LP-8,9]\n        _burn(owner, shares); // U:[LP-8,9]\n\n        _updateBaseInterest({\n            expectedLiquidityDelta: -assetsSent.toInt256(),\n            availableLiquidityDelta: -assetsSent.toInt256(),\n            checkOptimalBorrowing: false\n        }); // U:[LP-8,9]\n\n        IERC20(asset()).safeTransfer({to: receiver, value: amountToUser}); // U:[LP-8,9]\n        if (assetsSent > amountToUser) {\n            unchecked {\n                IERC20(asset()).safeTransfer({to: treasury, value: assetsSent - amountToUser}); // U:[LP-8,9]\n            }\n        }\n        emit Withdraw(msg.sender, receiver, owner, assetsReceived, shares); // U:[LP-8,9]\n    }\n\n    /// @dev Internal conversion function (from assets to shares) with support for rounding direction\n    function _convertToShares(uint256 assets, Math.Rounding rounding) internal view override returns (uint256 shares) {\n        uint256 supply = totalSupply();\n        return (assets == 0 || supply == 0) ? assets : assets.mulDiv(supply, totalAssets(), rounding);\n    }\n\n    /// @dev Internal conversion function (from shares to assets) with support for rounding direction\n    function _convertToAssets(uint256 shares, Math.Rounding rounding) internal view override returns (uint256 assets) {\n        uint256 supply = totalSupply();\n        return (supply == 0) ? shares : shares.mulDiv(totalAssets(), supply, rounding);\n    }\n\n    // --------- //\n    // BORROWING //\n    // --------- //\n\n    /// @notice Total borrowed amount (principal only)\n    function totalBorrowed() external view override returns (uint256) {\n        return _totalDebt.borrowed;\n    }\n\n    /// @notice Total debt limit, `type(uint256).max` means no limit\n    function totalDebtLimit() external view override returns (uint256) {\n        return _convertToU256(_totalDebt.limit);\n    }\n\n    /// @notice Amount borrowed by a given credit manager\n    function creditManagerBorrowed(address creditManager) external view override returns (uint256) {\n        return _creditManagerDebt[creditManager].borrowed;\n    }\n\n    /// @notice Debt limit for a given credit manager, `type(uint256).max` means no limit\n    function creditManagerDebtLimit(address creditManager) external view override returns (uint256) {\n        return _convertToU256(_creditManagerDebt[creditManager].limit);\n    }\n\n    /// @notice Amount available to borrow for a given credit manager\n    function creditManagerBorrowable(address creditManager) external view override returns (uint256 borrowable) {\n        borrowable = _borrowable(_totalDebt); // U:[LP-12]\n        if (borrowable == 0) return 0; // U:[LP-12]\n\n        borrowable = Math.min(borrowable, _borrowable(_creditManagerDebt[creditManager])); // U:[LP-12]\n        if (borrowable == 0) return 0; // U:[LP-12]\n\n        uint256 available = IInterestRateModel(interestRateModel).availableToBorrow({\n            expectedLiquidity: expectedLiquidity(),\n            availableLiquidity: availableLiquidity()\n        }); // U:[LP-12]\n\n        borrowable = Math.min(borrowable, available); // U:[LP-12]\n    }\n\n    /// @notice Lends funds to a credit account, can only be called by credit managers\n    /// @param borrowedAmount Amount to borrow\n    /// @param creditAccount Credit account to send the funds to\n    function lendCreditAccount(uint256 borrowedAmount, address creditAccount)\n        external\n        override\n        nonReentrant // U:[LP-2B]\n    {\n        uint128 borrowedAmountU128 = borrowedAmount.toUint128();\n\n        DebtParams storage cmDebt = _creditManagerDebt[msg.sender];\n        uint128 totalBorrowed_ = _totalDebt.borrowed + borrowedAmountU128;\n        uint128 cmBorrowed_ = cmDebt.borrowed + borrowedAmountU128;\n        if (borrowedAmount == 0 || cmBorrowed_ > cmDebt.limit || totalBorrowed_ > _totalDebt.limit) {\n            revert CreditManagerCantBorrowException(); // U:[LP-2C,13A]\n        }\n\n        _updateBaseInterest({\n            expectedLiquidityDelta: 0,\n            availableLiquidityDelta: -borrowedAmount.toInt256(),\n            checkOptimalBorrowing: true\n        }); // U:[LP-13B]\n\n        cmDebt.borrowed = cmBorrowed_; // U:[LP-13B]\n        _totalDebt.borrowed = totalBorrowed_; // U:[LP-13B]\n\n        IERC20(asset()).safeTransfer({to: creditAccount, value: borrowedAmount}); // U:[LP-13B]\n        emit Borrow(msg.sender, creditAccount, borrowedAmount); // U:[LP-13B]\n    }\n\n    /// @notice Updates pool state to indicate debt repayment, can only be called by credit managers\n    ///         after transferring underlying from a credit account to the pool.\n    ///         - If transferred amount exceeds debt principal + base interest + quota interest,\n    ///           the difference is deemed protocol's profit and the respective number of shares\n    ///           is minted to the treasury.\n    ///         - If, however, transferred amount is insufficient to repay debt and interest,\n    ///           which may only happen during liquidation, treasury's shares are burned to\n    ///           cover as much of the loss as possible.\n    /// @param repaidAmount Amount of debt principal repaid\n    /// @param profit Pool's profit in underlying after repaying\n    /// @param loss Pool's loss in underlying after repaying\n    /// @custom:expects Credit manager transfers underlying from a credit account to the pool before calling this function\n    /// @custom:expects Profit/loss computed in the credit manager are cosistent with pool's implicit calculations\n    function repayCreditAccount(uint256 repaidAmount, uint256 profit, uint256 loss)\n        external\n        override\n        nonReentrant // U:[LP-2B]\n    {\n        uint128 repaidAmountU128 = repaidAmount.toUint128();\n\n        DebtParams storage cmDebt = _creditManagerDebt[msg.sender];\n        uint128 cmBorrowed = cmDebt.borrowed;\n        if (cmBorrowed == 0) {\n            revert CallerNotCreditManagerException(); // U:[LP-2C,14A]\n        }\n\n        if (profit > 0) {\n            _mint(treasury, convertToShares(profit)); // U:[LP-14B]\n        } else if (loss > 0) {\n            address treasury_ = treasury;\n            uint256 sharesInTreasury = balanceOf(treasury_);\n            uint256 sharesToBurn = convertToShares(loss);\n            if (sharesToBurn > sharesInTreasury) {\n                unchecked {\n                    emit IncurUncoveredLoss({\n                        creditManager: msg.sender,\n                        loss: convertToAssets(sharesToBurn - sharesInTreasury)\n                    }); // U:[LP-14D]\n                }\n                sharesToBurn = sharesInTreasury;\n            }\n            _burn(treasury_, sharesToBurn); // U:[LP-14C,14D]\n        }\n\n        _updateBaseInterest({\n            expectedLiquidityDelta: profit.toInt256() - loss.toInt256(),\n            availableLiquidityDelta: 0,\n            checkOptimalBorrowing: false\n        }); // U:[LP-14B,14C,14D]\n\n        _totalDebt.borrowed -= repaidAmountU128; // U:[LP-14B,14C,14D]\n        cmDebt.borrowed = cmBorrowed - repaidAmountU128; // U:[LP-14B,14C,14D]\n\n        emit Repay(msg.sender, repaidAmount, profit, loss); // U:[LP-14B,14C,14D]\n    }\n\n    /// @dev Returns borrowable amount based on debt limit and current borrowed amount\n    function _borrowable(DebtParams storage debt) internal view returns (uint256) {\n        uint256 limit = debt.limit;\n        if (limit == type(uint128).max) {\n            return type(uint256).max;\n        }\n        uint256 borrowed = debt.borrowed;\n        if (borrowed >= limit) return 0;\n        unchecked {\n            return limit - borrowed;\n        }\n    }\n\n    // ------------- //\n    // INTEREST RATE //\n    // ------------- //\n\n    /// @notice Annual interest rate in ray that credit account owners pay per unit of borrowed capital\n    function baseInterestRate() public view override returns (uint256) {\n        return _baseInterestRate;\n    }\n\n    /// @notice Annual interest rate in ray that liquidity providers receive per unit of deposited capital,\n    ///         consists of base interest and quota revenue\n    function supplyRate() external view override returns (uint256) {\n        uint256 assets = expectedLiquidity();\n        uint256 baseInterestRate_ = baseInterestRate();\n        if (assets == 0) return baseInterestRate_;\n        return (baseInterestRate_ * _totalDebt.borrowed + quotaRevenue() * RAY) * (PERCENTAGE_FACTOR - withdrawFee)\n            / PERCENTAGE_FACTOR / assets; // U:[LP-15]\n    }\n\n    /// @notice Current cumulative base interest index in ray\n    function baseInterestIndex() public view override returns (uint256) {\n        uint256 timestampLU = lastBaseInterestUpdate;\n        if (block.timestamp == timestampLU) return _baseInterestIndexLU; // U:[LP-16]\n        return _calcBaseInterestIndex(timestampLU); // U:[LP-16]\n    }\n\n    /// @notice Cumulative base interest index stored as of last update in ray\n    function baseInterestIndexLU() external view override returns (uint256) {\n        return _baseInterestIndexLU;\n    }\n\n    /// @dev Computes base interest accrued since the last update\n    function _calcBaseInterestAccrued() internal view returns (uint256) {\n        uint256 timestampLU = lastBaseInterestUpdate;\n        if (block.timestamp == timestampLU) return 0; // U:[LP-17]\n        return _calcBaseInterestAccrued(timestampLU); // U:[LP-17]\n    }\n\n    /// @dev Updates base interest rate based on expected and available liquidity deltas\n    ///      - Adds expected liquidity delta to stored expected liquidity\n    ///      - If time has passed since the last base interest update, adds accrued interest\n    ///        to stored expected liquidity, updates interest index and last update timestamp\n    ///      - If time has passed since the last quota revenue update, adds accrued revenue\n    ///        to stored expected liquidity and updates last update timestamp\n    function _updateBaseInterest(\n        int256 expectedLiquidityDelta,\n        int256 availableLiquidityDelta,\n        bool checkOptimalBorrowing\n    ) internal {\n        uint256 expectedLiquidity_ = (expectedLiquidity().toInt256() + expectedLiquidityDelta).toUint256();\n        uint256 availableLiquidity_ = (availableLiquidity().toInt256() + availableLiquidityDelta).toUint256();\n\n        uint256 lastBaseInterestUpdate_ = lastBaseInterestUpdate;\n        if (block.timestamp != lastBaseInterestUpdate_) {\n            _baseInterestIndexLU = _calcBaseInterestIndex(lastBaseInterestUpdate_).toUint128(); // U:[LP-18]\n            lastBaseInterestUpdate = uint40(block.timestamp); // U:[LP-18]\n        }\n\n        if (block.timestamp != lastQuotaRevenueUpdate) {\n            lastQuotaRevenueUpdate = uint40(block.timestamp); // U:[LP-18]\n        }\n\n        _expectedLiquidityLU = expectedLiquidity_.toUint128(); // U:[LP-18]\n        _baseInterestRate = IInterestRateModel(interestRateModel).calcBorrowRate({\n            expectedLiquidity: expectedLiquidity_,\n            availableLiquidity: availableLiquidity_,\n            checkOptimalBorrowing: checkOptimalBorrowing\n        }).toUint128(); // U:[LP-18]\n    }\n\n    /// @dev Computes base interest accrued since given timestamp\n    function _calcBaseInterestAccrued(uint256 timestamp) private view returns (uint256) {\n        return _totalDebt.borrowed * baseInterestRate().calcLinearGrowth(timestamp) / RAY;\n    }\n\n    /// @dev Computes current value of base interest index\n    function _calcBaseInterestIndex(uint256 timestamp) private view returns (uint256) {\n        return _baseInterestIndexLU * (RAY + baseInterestRate().calcLinearGrowth(timestamp)) / RAY;\n    }\n\n    // ------ //\n    // QUOTAS //\n    // ------ //\n\n    /// @notice Current annual quota revenue in underlying tokens\n    function quotaRevenue() public view override returns (uint256) {\n        return _quotaRevenue;\n    }\n\n    /// @notice Updates quota revenue value by given delta\n    /// @param quotaRevenueDelta Quota revenue delta\n    function updateQuotaRevenue(int256 quotaRevenueDelta)\n        external\n        override\n        nonReentrant // U:[LP-2B]\n        poolQuotaKeeperOnly // U:[LP-2C]\n    {\n        _setQuotaRevenue((quotaRevenue().toInt256() + quotaRevenueDelta).toUint256()); // U:[LP-19]\n    }\n\n    /// @notice Sets new quota revenue value\n    /// @param newQuotaRevenue New quota revenue value\n    function setQuotaRevenue(uint256 newQuotaRevenue)\n        external\n        override\n        nonReentrant // U:[LP-2B]\n        poolQuotaKeeperOnly // U:[LP-2C]\n    {\n        _setQuotaRevenue(newQuotaRevenue); // U:[LP-20]\n    }\n\n    /// @dev Computes quota revenue accrued since the last update\n    function _calcQuotaRevenueAccrued() internal view returns (uint256) {\n        uint256 timestampLU = lastQuotaRevenueUpdate;\n        if (block.timestamp == timestampLU) return 0; // U:[LP-21]\n        return _calcQuotaRevenueAccrued(timestampLU); // U:[LP-21]\n    }\n\n    /// @dev Sets new quota revenue value\n    ///      - If time has passed since the last quota revenue update, adds accrued revenue\n    ///        to stored expected liquidity and updates last update timestamp\n    function _setQuotaRevenue(uint256 newQuotaRevenue) internal {\n        uint256 timestampLU = lastQuotaRevenueUpdate;\n        if (block.timestamp != timestampLU) {\n            _expectedLiquidityLU += _calcQuotaRevenueAccrued(timestampLU).toUint128(); // U:[LP-20]\n            lastQuotaRevenueUpdate = uint40(block.timestamp); // U:[LP-20]\n        }\n        _quotaRevenue = newQuotaRevenue.toUint96(); // U:[LP-20]\n    }\n\n    /// @dev Computes quota revenue accrued since given timestamp\n    function _calcQuotaRevenueAccrued(uint256 timestamp) private view returns (uint256) {\n        return quotaRevenue().calcLinearGrowth(timestamp);\n    }\n\n    // ------------- //\n    // CONFIGURATION //\n    // ------------- //\n\n    /// @notice Sets new interest rate model, can only be called by configurator\n    /// @param newInterestRateModel Address of the new interest rate model contract\n    function setInterestRateModel(address newInterestRateModel)\n        external\n        override\n        configuratorOnly // U:[LP-2C]\n        nonZeroAddress(newInterestRateModel) // U:[LP-22A]\n    {\n        interestRateModel = newInterestRateModel; // U:[LP-22B]\n        _updateBaseInterest(0, 0, false); // U:[LP-22B]\n        emit SetInterestRateModel(newInterestRateModel); // U:[LP-22B]\n    }\n\n    /// @notice Sets new pool quota keeper, can only be called by configurator\n    /// @param newPoolQuotaKeeper Address of the new pool quota keeper contract\n    function setPoolQuotaKeeper(address newPoolQuotaKeeper)\n        external\n        override\n        configuratorOnly // U:[LP-2C]\n        nonZeroAddress(newPoolQuotaKeeper) // U:[LP-23A]\n    {\n        if (IPoolQuotaKeeperV3(newPoolQuotaKeeper).pool() != address(this)) {\n            revert IncompatiblePoolQuotaKeeperException(); // U:[LP-23C]\n        }\n\n        poolQuotaKeeper = newPoolQuotaKeeper; // U:[LP-23D]\n\n        uint256 newQuotaRevenue = IPoolQuotaKeeperV3(poolQuotaKeeper).poolQuotaRevenue();\n        _setQuotaRevenue(newQuotaRevenue); // U:[LP-23D]\n\n        emit SetPoolQuotaKeeper(newPoolQuotaKeeper); // U:[LP-23D]\n    }\n\n    /// @notice Sets new total debt limit, can only be called by configurator\n    /// @param newLimit New debt limit, `type(uint256).max` for no limit\n    function setTotalDebtLimit(uint256 newLimit)\n        external\n        override\n        configuratorOnly // U:[LP-2C]\n    {\n        _setTotalDebtLimit(newLimit); // U:[LP-24]\n    }\n\n    /// @notice Sets new debt limit for a given credit manager, can only be called by configurator\n    ///         Adds credit manager to the list of connected managers when called for the first time\n    /// @param creditManager Credit manager to set the limit for\n    /// @param newLimit New debt limit, `type(uint256).max` for no limit (has smaller priority than total debt limit)\n    function setCreditManagerDebtLimit(address creditManager, uint256 newLimit)\n        external\n        override\n        configuratorOnly // U:[LP-2C]\n        nonZeroAddress(creditManager) // U:[LP-25A]\n        registeredCreditManagerOnly(creditManager) // U:[LP-25B]\n    {\n        if (!_creditManagerSet.contains(creditManager)) {\n            if (address(this) != ICreditManagerV3(creditManager).pool()) {\n                revert IncompatibleCreditManagerException(); // U:[LP-25C]\n            }\n            _creditManagerSet.add(creditManager); // U:[LP-25D]\n            emit AddCreditManager(creditManager); // U:[LP-25D]\n        }\n        _creditManagerDebt[creditManager].limit = _convertToU128(newLimit); // U:[LP-25D]\n        emit SetCreditManagerDebtLimit(creditManager, newLimit); // U:[LP-25D]\n    }\n\n    /// @notice Sets new withdrawal fee, can only be called by configurator\n    /// @param newWithdrawFee New withdrawal fee in bps\n    function setWithdrawFee(uint256 newWithdrawFee)\n        external\n        override\n        configuratorOnly // U:[LP-2C]\n    {\n        if (newWithdrawFee > MAX_WITHDRAW_FEE) {\n            revert IncorrectParameterException(); // U:[LP-26A]\n        }\n        if (newWithdrawFee == withdrawFee) return;\n\n        withdrawFee = newWithdrawFee.toUint16(); // U:[LP-26B]\n        emit SetWithdrawFee(newWithdrawFee); // U:[LP-26B]\n    }\n\n    /// @notice Pauses contract, can only be called by an account with pausable admin role\n    /// @dev Pause only blocks deposits, withdrawals and transfers.\n    ///      Borrowing and repayment can be paused on the credit side but are not blocked here\n    ///      to allow emergency liquidations to proceed.\n    /// @dev Reverts if contract is already paused\n    function pause() external override pausableAdminsOnly {\n        _pause();\n    }\n\n    /// @notice Unpauses contract, can only be called by an account with unpausable admin role\n    /// @dev Reverts if contract is already unpaused\n    function unpause() external override unpausableAdminsOnly {\n        _unpause();\n    }\n\n    /// @dev Sets new total debt limit\n    function _setTotalDebtLimit(uint256 limit) internal {\n        uint128 newLimit = _convertToU128(limit);\n        if (newLimit == _totalDebt.limit) return;\n\n        _totalDebt.limit = newLimit; // U:[LP-1B,24]\n        emit SetTotalDebtLimit(limit); // U:[LP-1B,24]\n    }\n\n    // --------- //\n    // INTERNALS //\n    // --------- //\n\n    /// @dev Same as `ERC20._transfer` but reverts if contract is paused\n    function _transfer(address from, address to, uint256 amount)\n        internal\n        override\n        whenNotPaused // U:[LP-2A]\n    {\n        super._transfer(from, to, amount);\n    }\n\n    /// @dev Returns amount of token that should be transferred to receive `amount`\n    ///      Pools with fee-on-transfer underlying should override this method\n    function _amountWithFee(uint256 amount) internal view virtual returns (uint256) {\n        return amount;\n    }\n\n    /// @dev Returns amount of token that will be received if `amount` is transferred\n    ///      Pools with fee-on-transfer underlying should override this method\n    function _amountMinusFee(uint256 amount) internal view virtual returns (uint256) {\n        return amount;\n    }\n\n    /// @dev Returns amount of token that should be withdrawn so that `amount` is actually sent to the receiver\n    function _amountWithWithdrawalFee(uint256 amount) internal view returns (uint256) {\n        return amount * PERCENTAGE_FACTOR / (PERCENTAGE_FACTOR - withdrawFee);\n    }\n\n    /// @dev Returns amount of token that would actually be sent to the receiver when withdrawing `amount`\n    function _amountMinusWithdrawalFee(uint256 amount) internal view returns (uint256) {\n        return amount * (PERCENTAGE_FACTOR - withdrawFee) / PERCENTAGE_FACTOR;\n    }\n\n    /// @dev Converts `uint128` to `uint256`, preserves maximum value\n    function _convertToU256(uint128 limit) internal pure returns (uint256) {\n        return (limit == type(uint128).max) ? type(uint256).max : limit;\n    }\n\n    /// @dev Converts `uint256` to `uint128`, preserves maximum value\n    function _convertToU128(uint256 limit) internal pure returns (uint128) {\n        return (limit == type(uint256).max) ? type(uint128).max : limit.toUint128();\n    }\n\n    function _revertIfCallerIsNotPoolQuotaKeeper() internal view {\n        if (msg.sender != poolQuotaKeeper) revert CallerNotPoolQuotaKeeperException(); // U:[LP-2C]\n    }\n}\n"
    },
    "lib/@gearbox-protocol/core-v3/contracts/traits/ACLTrait.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Foundation, 2024.\npragma solidity ^0.8.17;\n\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport {IACL} from \"../interfaces/base/IACL.sol\";\nimport {IACLTrait} from \"../interfaces/base/IACLTrait.sol\";\nimport {\n    AddressIsNotContractException,\n    CallerNotConfiguratorException,\n    CallerNotPausableAdminException,\n    CallerNotUnpausableAdminException,\n    ZeroAddressException\n} from \"../interfaces/IExceptions.sol\";\n\n/// @title ACL trait\n/// @notice Utility class for ACL (access-control list) consumers\nabstract contract ACLTrait is IACLTrait {\n    using Address for address;\n\n    /// @notice ACL contract address\n    address public immutable override acl;\n\n    /// @dev Ensures that function caller has configurator role\n    modifier configuratorOnly() {\n        _ensureCallerIsConfigurator();\n        _;\n    }\n\n    /// @dev Ensures that function caller has pausable admin role\n    modifier pausableAdminsOnly() {\n        _ensureCallerIsPausableAdmin();\n        _;\n    }\n\n    /// @dev Ensures that function caller has unpausable admin role\n    modifier unpausableAdminsOnly() {\n        _ensureCallerIsUnpausableAdmin();\n        _;\n    }\n\n    /// @notice Constructor\n    /// @param _acl ACL contract address\n    constructor(address _acl) {\n        if (_acl == address(0)) revert ZeroAddressException();\n        if (!_acl.isContract()) revert AddressIsNotContractException(_acl);\n        acl = _acl;\n    }\n\n    /// @dev Reverts if the caller is not the configurator\n    /// @dev Used to cut contract size on modifiers\n    function _ensureCallerIsConfigurator() internal view {\n        if (!_isConfigurator(msg.sender)) revert CallerNotConfiguratorException();\n    }\n\n    /// @dev Checks whether given account has configurator role\n    function _isConfigurator(address account) internal view returns (bool) {\n        return IACL(acl).isConfigurator(account);\n    }\n\n    /// @dev Reverts if the caller is not pausable admin\n    /// @dev Used to cut contract size on modifiers\n    function _ensureCallerIsPausableAdmin() internal view {\n        if (!_hasRole(\"PAUSABLE_ADMIN\", msg.sender)) revert CallerNotPausableAdminException();\n    }\n\n    /// @dev Reverts if the caller is not unpausable admin\n    /// @dev Used to cut contract size on modifiers\n    function _ensureCallerIsUnpausableAdmin() internal view {\n        if (!_hasRole(\"UNPAUSABLE_ADMIN\", msg.sender)) revert CallerNotUnpausableAdminException();\n    }\n\n    /// @dev Whether account `account` has role `role`\n    /// @dev Used to cut contract size on external calls\n    function _hasRole(bytes32 role, address account) internal view returns (bool) {\n        return IACL(acl).hasRole(role, account);\n    }\n}\n"
    },
    "lib/@gearbox-protocol/core-v3/contracts/traits/SanityCheckTrait.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Foundation, 2024.\npragma solidity ^0.8.17;\n\nimport {ZeroAddressException} from \"../interfaces/IExceptions.sol\";\n\n/// @title Sanity check trait\nabstract contract SanityCheckTrait {\n    /// @dev Ensures that passed address is non-zero\n    modifier nonZeroAddress(address addr) {\n        _revertIfZeroAddress(addr);\n        _;\n    }\n\n    /// @dev Reverts if address is zero\n    function _revertIfZeroAddress(address addr) private pure {\n        if (addr == address(0)) revert ZeroAddressException();\n    }\n}\n"
    },
    "lib/@gearbox-protocol/core-v3/contracts/interfaces/ICreditConfiguratorV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Foundation, 2024.\npragma solidity ^0.8.17;\n\nimport {IACLTrait} from \"./base/IACLTrait.sol\";\nimport {IVersion} from \"./base/IVersion.sol\";\n\nenum AllowanceAction {\n    FORBID,\n    ALLOW\n}\n\ninterface ICreditConfiguratorV3Events {\n    // ------ //\n    // TOKENS //\n    // ------ //\n\n    /// @notice Emitted when a token is made recognizable as collateral in the credit manager\n    event AddCollateralToken(address indexed token);\n\n    /// @notice Emitted when a new collateral token liquidation threshold is set\n    event SetTokenLiquidationThreshold(address indexed token, uint16 liquidationThreshold);\n\n    /// @notice Emitted when a collateral token liquidation threshold ramping is scheduled\n    event ScheduleTokenLiquidationThresholdRamp(\n        address indexed token,\n        uint16 liquidationThresholdInitial,\n        uint16 liquidationThresholdFinal,\n        uint40 timestampRampStart,\n        uint40 timestampRampEnd\n    );\n\n    /// @notice Emitted when a collateral token is forbidden\n    event ForbidToken(address indexed token);\n\n    /// @notice Emitted when a previously forbidden collateral token is allowed\n    event AllowToken(address indexed token);\n\n    // -------- //\n    // ADAPTERS //\n    // -------- //\n\n    /// @notice Emitted when a new adapter and its target contract are allowed in the credit manager\n    event AllowAdapter(address indexed targetContract, address indexed adapter);\n\n    /// @notice Emitted when adapter and its target contract are forbidden in the credit manager\n    event ForbidAdapter(address indexed targetContract, address indexed adapter);\n\n    // -------------- //\n    // CREDIT MANAGER //\n    // -------------- //\n\n    /// @notice Emitted when new fee parameters are set in the credit manager\n    event UpdateFees(\n        uint16 feeLiquidation, uint16 liquidationPremium, uint16 feeLiquidationExpired, uint16 liquidationPremiumExpired\n    );\n\n    // -------- //\n    // UPGRADES //\n    // -------- //\n\n    /// @notice Emitted when a new price oracle is set in the credit manager\n    event SetPriceOracle(address indexed priceOracle);\n\n    /// @notice Emitted when a new facade is connected to the credit manager\n    event SetCreditFacade(address indexed creditFacade);\n\n    /// @notice Emitted when credit manager's configurator contract is upgraded\n    event CreditConfiguratorUpgraded(address indexed creditConfigurator);\n\n    // ------------- //\n    // CREDIT FACADE //\n    // ------------- //\n\n    /// @notice Emitted when new debt principal limits are set\n    event SetBorrowingLimits(uint256 minDebt, uint256 maxDebt);\n\n    /// @notice Emitted when a new max debt per block multiplier is set\n    event SetMaxDebtPerBlockMultiplier(uint8 maxDebtPerBlockMultiplier);\n\n    /// @notice Emitted when new loss policy is set\n    event SetLossPolicy(address indexed lossPolicy);\n\n    /// @notice Emitted when a new expiration timestamp is set in the credit facade\n    event SetExpirationDate(uint40 expirationDate);\n}\n\n/// @title Credit configurator V3 interface\ninterface ICreditConfiguratorV3 is IVersion, IACLTrait, ICreditConfiguratorV3Events {\n    function creditManager() external view returns (address);\n\n    function creditFacade() external view returns (address);\n\n    function underlying() external view returns (address);\n\n    // ------ //\n    // TOKENS //\n    // ------ //\n\n    function makeAllTokensQuoted() external;\n\n    function addCollateralToken(address token, uint16 liquidationThreshold) external;\n\n    function setLiquidationThreshold(address token, uint16 liquidationThreshold) external;\n\n    function rampLiquidationThreshold(\n        address token,\n        uint16 liquidationThresholdFinal,\n        uint40 rampStart,\n        uint24 rampDuration\n    ) external;\n\n    function forbidToken(address token) external;\n\n    function allowToken(address token) external;\n\n    // -------- //\n    // ADAPTERS //\n    // -------- //\n\n    function allowedAdapters() external view returns (address[] memory);\n\n    function allowAdapter(address adapter) external;\n\n    function forbidAdapter(address adapter) external;\n\n    // -------------- //\n    // CREDIT MANAGER //\n    // -------------- //\n\n    function setFees(\n        uint16 feeLiquidation,\n        uint16 liquidationPremium,\n        uint16 feeLiquidationExpired,\n        uint16 liquidationPremiumExpired\n    ) external;\n\n    // -------- //\n    // UPGRADES //\n    // -------- //\n\n    function setPriceOracle(address newPriceOracle) external;\n\n    function setCreditFacade(address newCreditFacade, bool migrateParams) external;\n\n    function upgradeCreditConfigurator(address newCreditConfigurator) external;\n\n    // ------------- //\n    // CREDIT FACADE //\n    // ------------- //\n\n    function setDebtLimits(uint128 newMinDebt, uint128 newMaxDebt) external;\n\n    function setMaxDebtPerBlockMultiplier(uint8 newMaxDebtLimitPerBlockMultiplier) external;\n\n    function forbidBorrowing() external;\n\n    function setLossPolicy(address newLossPolicy) external;\n\n    function setExpirationDate(uint40 newExpirationDate) external;\n}\n"
    },
    "lib/@gearbox-protocol/core-v3/contracts/interfaces/ICreditFacadeV3Multicall.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Foundation, 2024.\npragma solidity ^0.8.17;\n\nimport {BalanceDelta} from \"../libraries/BalancesLogic.sol\";\nimport {PriceUpdate} from \"./base/IPriceFeedStore.sol\";\n\n// ----------- //\n// PERMISSIONS //\n// ----------- //\n\n// NOTE: permissions 1 << 3, 1 << 4 and 1 << 7 were used by now deprecated methods, thus non-consecutive values\n\nuint192 constant ADD_COLLATERAL_PERMISSION = 1 << 0;\nuint192 constant INCREASE_DEBT_PERMISSION = 1 << 1;\nuint192 constant DECREASE_DEBT_PERMISSION = 1 << 2;\nuint192 constant WITHDRAW_COLLATERAL_PERMISSION = 1 << 5;\nuint192 constant UPDATE_QUOTA_PERMISSION = 1 << 6;\nuint192 constant SET_BOT_PERMISSIONS_PERMISSION = 1 << 8;\nuint192 constant EXTERNAL_CALLS_PERMISSION = 1 << 16;\n\nuint192 constant ALL_PERMISSIONS = ADD_COLLATERAL_PERMISSION | WITHDRAW_COLLATERAL_PERMISSION | UPDATE_QUOTA_PERMISSION\n    | INCREASE_DEBT_PERMISSION | DECREASE_DEBT_PERMISSION | SET_BOT_PERMISSIONS_PERMISSION | EXTERNAL_CALLS_PERMISSION;\nuint192 constant OPEN_CREDIT_ACCOUNT_PERMISSIONS = ALL_PERMISSIONS & ~DECREASE_DEBT_PERMISSION;\nuint192 constant CLOSE_CREDIT_ACCOUNT_PERMISSIONS = ALL_PERMISSIONS & ~INCREASE_DEBT_PERMISSION;\nuint192 constant LIQUIDATE_CREDIT_ACCOUNT_PERMISSIONS =\n    EXTERNAL_CALLS_PERMISSION | ADD_COLLATERAL_PERMISSION | WITHDRAW_COLLATERAL_PERMISSION;\n\n// ----- //\n// FLAGS //\n// ----- //\n\n/// @dev Indicates that collateral check after the multicall can be skipped, set to true on account closure or liquidation\nuint256 constant SKIP_COLLATERAL_CHECK_FLAG = 1 << 192;\n\n/// @dev Indicates that external calls from credit account to adapters were made during multicall,\n///      set to true on the first call to the adapter\nuint256 constant EXTERNAL_CONTRACT_WAS_CALLED_FLAG = 1 << 193;\n\n/// @dev Indicates that the price updates call should be skipped, set to true on liquidation when the first call\n///      of the multicall is `onDemandPriceUpdates`\nuint256 constant SKIP_PRICE_UPDATES_CALL_FLAG = 1 << 194;\n\n/// @dev Indicates that collateral check must revert if any forbidden token is encountered on the account,\n///      set to true after risky operations, such as `increaseDebt` or `withdrawCollateral`\nuint256 constant REVERT_ON_FORBIDDEN_TOKENS_FLAG = 1 << 195;\n\n/// @dev Indicates that collateral check must be performed using safe prices, set to true on `withdrawCollateral`\n///      or if account has enabled forbidden tokens\nuint256 constant USE_SAFE_PRICES_FLAG = 1 << 196;\n\n/// @title Credit facade V3 multicall interface\n/// @dev Unless specified otherwise, all these methods are only available in `openCreditAccount`,\n///      `closeCreditAccount`, `multicall`, and, with account owner's permission, `botMulticall`\ninterface ICreditFacadeV3Multicall {\n    /// @notice Applies on-demand price feed updates\n    /// @param updates Array of price updates, see `PriceUpdate` for details\n    /// @dev Reverts if placed not at the first position in the multicall\n    /// @dev This method is available in all kinds of multicalls\n    function onDemandPriceUpdates(PriceUpdate[] calldata updates) external;\n\n    /// @notice Stores expected token balances (current balance + delta) after operations for a slippage check.\n    ///         Normally, a check is performed automatically at the end of the multicall, but more fine-grained\n    ///         behavior can be achieved by placing `storeExpectedBalances` and `compareBalances` where needed.\n    /// @param balanceDeltas Array of (token, minBalanceDelta) pairs, deltas are allowed to be negative\n    /// @dev Reverts if expected balances are already set\n    /// @dev This method is available in all kinds of multicalls\n    function storeExpectedBalances(BalanceDelta[] calldata balanceDeltas) external;\n\n    /// @notice Performs a slippage check ensuring that current token balances are greater than saved expected ones\n    /// @dev Resets stored expected balances\n    /// @dev Reverts if expected balances are not stored\n    /// @dev This method is available in all kinds of multicalls\n    function compareBalances() external;\n\n    /// @notice Adds collateral to account.\n    ///         Only the underlying token counts towards account's collateral value by default, while all other tokens\n    ///         must be enabled as collateral by \"purchasing\" quota for it. Holding non-enabled token on account with\n    ///         non-zero debt poses a risk of losing it entirely to the liquidator. Adding non-enabled tokens is still\n    ///         supported to allow users to later swap them into enabled ones in the same multicall.\n    /// @param token Token to add\n    /// @param amount Amount to add\n    /// @dev Requires token approval from caller to the credit manager\n    /// @dev This method can also be called during liquidation\n    function addCollateral(address token, uint256 amount) external;\n\n    /// @notice Adds collateral to account using signed EIP-2612 permit message.\n    ///         Only the underlying token counts towards account's collateral value by default, while all other tokens\n    ///         must be enabled as collateral by \"purchasing\" quota for it. Holding non-enabled token on account with\n    ///         non-zero debt poses a risk of losing it entirely to the liquidator. Adding non-enabled tokens is still\n    ///         supported to allow users to later swap them into enabled ones in the same multicall.\n    /// @param token Token to add\n    /// @param amount Amount to add\n    /// @param deadline Permit deadline\n    /// @dev `v`, `r`, `s` must be a valid signature of the permit message from caller to the credit manager\n    /// @dev This method can also be called during liquidation\n    function addCollateralWithPermit(address token, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s)\n        external;\n\n    /// @notice Increases account's debt\n    /// @param amount Underlying amount to borrow\n    /// @dev Increasing debt is prohibited when closing an account\n    /// @dev Increasing debt is prohibited if it was previously updated in the same block\n    /// @dev The resulting debt amount must be within allowed limits\n    /// @dev Increasing debt is prohibited if there are forbidden tokens enabled as collateral on the account\n    /// @dev After debt increase, total amount borrowed by the credit manager in the current block must not exceed\n    ///      the limit defined in the facade\n    function increaseDebt(uint256 amount) external;\n\n    /// @notice Decreases account's debt\n    /// @param amount Underlying amount to repay, value above account's total debt indicates full repayment\n    /// @dev Decreasing debt is prohibited when opening an account\n    /// @dev Decreasing debt is prohibited if it was previously updated in the same block\n    /// @dev The resulting debt amount must be above allowed minimum or zero (maximum is not checked here\n    ///      to allow small repayments and partial liquidations in case configurator lowers it)\n    /// @dev Full repayment brings account into a special mode that skips collateral checks and thus requires\n    ///      an account to have no potential debt sources, e.g., all quotas must be disabled\n    function decreaseDebt(uint256 amount) external;\n\n    /// @notice Updates account's quota for a token\n    /// @param token Collateral token to update the quota for (can't be underlying)\n    /// @param quotaChange Desired quota change in underlying token units (`type(int96).min` to disable quota)\n    /// @param minQuota Minimum resulting account's quota for token required not to revert\n    /// @dev Enables token as collateral if quota is increased from zero, disables if decreased to zero\n    /// @dev Quota increase is prohibited for forbidden tokens\n    /// @dev Quota update is prohibited if account has zero debt\n    /// @dev Resulting account's quota for token must not exceed the limit defined in the facade\n    function updateQuota(address token, int96 quotaChange, uint96 minQuota) external;\n\n    /// @notice Withdraws collateral from account\n    /// @param token Token to withdraw\n    /// @param amount Amount to withdraw, `type(uint256).max` to withdraw all balance\n    /// @param to Token recipient\n    /// @dev This method can also be called during liquidation\n    /// @dev Withdrawals are prohibited in multicalls if there are forbidden tokens enabled as collateral on the account\n    /// @dev Withdrawals activate safe pricing (min of main and reserve feeds) in collateral check\n    /// @dev If `token` is a phantom token, it's withdrawn first, and its `depositedToken` is then sent to the recipient.\n    ///      No slippage prevention mechanism is provided as withdrawals are assumed to happen at non-manipulatable rate.\n    ///      Although an adapter call is made in process, permission for external calls is not required.\n    function withdrawCollateral(address token, uint256 amount, address to) external;\n\n    /// @notice Sets advanced collateral check parameters\n    /// @param collateralHints Optional array of token masks to check first to reduce the amount of computation\n    ///        when known subset of account's collateral tokens covers all the debt. Underlying token is always\n    ///        checked last so it's forbidden to pass its mask.\n    /// @param minHealthFactor Min account's health factor in bps in order not to revert, must be at least 10000\n    /// @dev This method can't be called during closure or liquidation\n    function setFullCheckParams(uint256[] calldata collateralHints, uint16 minHealthFactor) external;\n\n    /// @notice Sets `bot`'s permissions to manage account to `permissions`\n    /// @param bot Bot to set permissions for\n    /// @param permissions A bitmask encoding bot permissions\n    /// @dev Reverts if `permissions` has unexpected bits enabled or doesn't match permissions required by `bot`\n    function setBotPermissions(address bot, uint192 permissions) external;\n}\n"
    },
    "lib/@gearbox-protocol/core-v3/contracts/interfaces/base/IACLTrait.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Foundation, 2024.\npragma solidity ^0.8.17;\n\ninterface IACLTrait {\n    function acl() external view returns (address);\n}\n"
    },
    "lib/@gearbox-protocol/core-v3/contracts/interfaces/base/IPriceFeedStore.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Foundation, 2024.\npragma solidity ^0.8.17;\n\nimport {IVersion} from \"./IVersion.sol\";\n\nstruct PriceUpdate {\n    address priceFeed;\n    bytes data;\n}\n\ninterface IPriceFeedStore {\n    function getStalenessPeriod(address priceFeed) external view returns (uint32);\n    function updatePrices(PriceUpdate[] calldata updates) external;\n}\n"
    },
    "lib/@1inch/solidity-utils/contracts/libraries/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\";\nimport \"../interfaces/IDaiLikePermit.sol\";\nimport \"../interfaces/IPermit2.sol\";\nimport \"../interfaces/IERC7597Permit.sol\";\nimport \"../interfaces/IWETH.sol\";\nimport \"../libraries/RevertReasonForwarder.sol\";\n\n/**\n * @title Implements efficient safe methods for ERC20 interface.\n * @notice Compared to the standard ERC20, this implementation offers several enhancements:\n * 1. more gas-efficient, providing significant savings in transaction costs.\n * 2. support for different permit implementations\n * 3. forceApprove functionality\n * 4. support for WETH deposit and withdraw\n */\nlibrary SafeERC20 {\n    error SafeTransferFailed();\n    error SafeTransferFromFailed();\n    error ForceApproveFailed();\n    error SafeIncreaseAllowanceFailed();\n    error SafeDecreaseAllowanceFailed();\n    error SafePermitBadLength();\n    error Permit2TransferAmountTooHigh();\n\n    // Uniswap Permit2 address\n    address private constant _PERMIT2 = 0x000000000022D473030F116dDEE9F6B43aC78BA3;\n    bytes4 private constant _PERMIT_LENGTH_ERROR = 0x68275857;  // SafePermitBadLength.selector\n    uint256 private constant _RAW_CALL_GAS_LIMIT = 5000;\n\n    /**\n     * @notice Fetches the balance of a specific ERC20 token held by an account.\n     * Consumes less gas then regular `ERC20.balanceOf`.\n     * @dev Note that the implementation does not perform dirty bits cleaning, so it is the\n     * responsibility of the caller to make sure that the higher 96 bits of the `account` parameter are clean.\n     * @param token The IERC20 token contract for which the balance will be fetched.\n     * @param account The address of the account whose token balance will be fetched.\n     * @return tokenBalance The balance of the specified ERC20 token held by the account.\n     */\n    function safeBalanceOf(\n        IERC20 token,\n        address account\n    ) internal view returns(uint256 tokenBalance) {\n        bytes4 selector = IERC20.balanceOf.selector;\n        assembly (\"memory-safe\") { // solhint-disable-line no-inline-assembly\n            mstore(0x00, selector)\n            mstore(0x04, account)\n            let success := staticcall(gas(), token, 0x00, 0x24, 0x00, 0x20)\n            tokenBalance := mload(0)\n\n            if or(iszero(success), lt(returndatasize(), 0x20)) {\n                let ptr := mload(0x40)\n                returndatacopy(ptr, 0, returndatasize())\n                revert(ptr, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @notice Attempts to safely transfer tokens from one address to another.\n     * @dev If permit2 is true, uses the Permit2 standard; otherwise uses the standard ERC20 transferFrom.\n     * Either requires `true` in return data, or requires target to be smart-contract and empty return data.\n     * Note that the implementation does not perform dirty bits cleaning, so it is the responsibility of\n     * the caller to make sure that the higher 96 bits of the `from` and `to` parameters are clean.\n     * @param token The IERC20 token contract from which the tokens will be transferred.\n     * @param from The address from which the tokens will be transferred.\n     * @param to The address to which the tokens will be transferred.\n     * @param amount The amount of tokens to transfer.\n     * @param permit2 If true, uses the Permit2 standard for the transfer; otherwise uses the standard ERC20 transferFrom.\n     */\n    function safeTransferFromUniversal(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 amount,\n        bool permit2\n    ) internal {\n        if (permit2) {\n            safeTransferFromPermit2(token, from, to, amount);\n        } else {\n            safeTransferFrom(token, from, to, amount);\n        }\n    }\n\n    /**\n     * @notice Attempts to safely transfer tokens from one address to another using the ERC20 standard.\n     * @dev Either requires `true` in return data, or requires target to be smart-contract and empty return data.\n     * Note that the implementation does not perform dirty bits cleaning, so it is the responsibility of\n     * the caller to make sure that the higher 96 bits of the `from` and `to` parameters are clean.\n     * @param token The IERC20 token contract from which the tokens will be transferred.\n     * @param from The address from which the tokens will be transferred.\n     * @param to The address to which the tokens will be transferred.\n     * @param amount The amount of tokens to transfer.\n     */\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        bytes4 selector = token.transferFrom.selector;\n        bool success;\n        assembly (\"memory-safe\") { // solhint-disable-line no-inline-assembly\n            let data := mload(0x40)\n\n            mstore(data, selector)\n            mstore(add(data, 0x04), from)\n            mstore(add(data, 0x24), to)\n            mstore(add(data, 0x44), amount)\n            success := call(gas(), token, 0, data, 100, 0x0, 0x20)\n            if success {\n                switch returndatasize()\n                case 0 {\n                    success := gt(extcodesize(token), 0)\n                }\n                default {\n                    success := and(gt(returndatasize(), 31), eq(mload(0), 1))\n                }\n            }\n        }\n        if (!success) revert SafeTransferFromFailed();\n    }\n\n    /**\n     * @notice Attempts to safely transfer tokens from one address to another using the Permit2 standard.\n     * @dev Either requires `true` in return data, or requires target to be smart-contract and empty return data.\n     * Note that the implementation does not perform dirty bits cleaning, so it is the responsibility of\n     * the caller to make sure that the higher 96 bits of the `from` and `to` parameters are clean.\n     * @param token The IERC20 token contract from which the tokens will be transferred.\n     * @param from The address from which the tokens will be transferred.\n     * @param to The address to which the tokens will be transferred.\n     * @param amount The amount of tokens to transfer.\n     */\n    function safeTransferFromPermit2(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        if (amount > type(uint160).max) revert Permit2TransferAmountTooHigh();\n        bytes4 selector = IPermit2.transferFrom.selector;\n        bool success;\n        assembly (\"memory-safe\") { // solhint-disable-line no-inline-assembly\n            let data := mload(0x40)\n\n            mstore(data, selector)\n            mstore(add(data, 0x04), from)\n            mstore(add(data, 0x24), to)\n            mstore(add(data, 0x44), amount)\n            mstore(add(data, 0x64), token)\n            success := call(gas(), _PERMIT2, 0, data, 0x84, 0x0, 0x0)\n            if success {\n                success := gt(extcodesize(_PERMIT2), 0)\n            }\n        }\n        if (!success) revert SafeTransferFromFailed();\n    }\n\n    /**\n     * @notice Attempts to safely transfer tokens to another address.\n     * @dev Either requires `true` in return data, or requires target to be smart-contract and empty return data.\n     * Note that the implementation does not perform dirty bits cleaning, so it is the responsibility of\n     * the caller to make sure that the higher 96 bits of the `to` parameter are clean.\n     * @param token The IERC20 token contract from which the tokens will be transferred.\n     * @param to The address to which the tokens will be transferred.\n     * @param value The amount of tokens to transfer.\n     */\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        if (!_makeCall(token, token.transfer.selector, to, value)) {\n            revert SafeTransferFailed();\n        }\n    }\n\n    /**\n     * @notice Attempts to approve a spender to spend a certain amount of tokens.\n     * @dev If `approve(from, to, amount)` fails, it tries to set the allowance to zero, and retries the `approve` call.\n     * Note that the implementation does not perform dirty bits cleaning, so it is the responsibility of\n     * the caller to make sure that the higher 96 bits of the `spender` parameter are clean.\n     * @param token The IERC20 token contract on which the call will be made.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     */\n    function forceApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        if (!_makeCall(token, token.approve.selector, spender, value)) {\n            if (\n                !_makeCall(token, token.approve.selector, spender, 0) ||\n                !_makeCall(token, token.approve.selector, spender, value)\n            ) {\n                revert ForceApproveFailed();\n            }\n        }\n    }\n\n    /**\n     * @notice Safely increases the allowance of a spender.\n     * @dev Increases with safe math check. Checks if the increased allowance will overflow, if yes, then it reverts the transaction.\n     * Then uses `forceApprove` to increase the allowance.\n     * Note that the implementation does not perform dirty bits cleaning, so it is the responsibility of\n     * the caller to make sure that the higher 96 bits of the `spender` parameter are clean.\n     * @param token The IERC20 token contract on which the call will be made.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to increase the allowance by.\n     */\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 allowance = token.allowance(address(this), spender);\n        if (value > type(uint256).max - allowance) revert SafeIncreaseAllowanceFailed();\n        forceApprove(token, spender, allowance + value);\n    }\n\n    /**\n     * @notice Safely decreases the allowance of a spender.\n     * @dev Decreases with safe math check. Checks if the decreased allowance will underflow, if yes, then it reverts the transaction.\n     * Then uses `forceApprove` to increase the allowance.\n     * Note that the implementation does not perform dirty bits cleaning, so it is the responsibility of\n     * the caller to make sure that the higher 96 bits of the `spender` parameter are clean.\n     * @param token The IERC20 token contract on which the call will be made.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to decrease the allowance by.\n     */\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 allowance = token.allowance(address(this), spender);\n        if (value > allowance) revert SafeDecreaseAllowanceFailed();\n        forceApprove(token, spender, allowance - value);\n    }\n\n    /**\n     * @notice Attempts to execute the `permit` function on the provided token with the sender and contract as parameters.\n     * Permit type is determined automatically based on permit calldata (IERC20Permit, IDaiLikePermit, and IPermit2).\n     * @dev Wraps `tryPermit` function and forwards revert reason if permit fails.\n     * @param token The IERC20 token to execute the permit function on.\n     * @param permit The permit data to be used in the function call.\n     */\n    function safePermit(IERC20 token, bytes calldata permit) internal {\n        if (!tryPermit(token, msg.sender, address(this), permit)) RevertReasonForwarder.reRevert();\n    }\n\n    /**\n     * @notice Attempts to execute the `permit` function on the provided token with custom owner and spender parameters.\n     * Permit type is determined automatically based on permit calldata (IERC20Permit, IDaiLikePermit, and IPermit2).\n     * @dev Wraps `tryPermit` function and forwards revert reason if permit fails.\n     * Note that the implementation does not perform dirty bits cleaning, so it is the responsibility of\n     * the caller to make sure that the higher 96 bits of the `owner` and `spender` parameters are clean.\n     * @param token The IERC20 token to execute the permit function on.\n     * @param owner The owner of the tokens for which the permit is made.\n     * @param spender The spender allowed to spend the tokens by the permit.\n     * @param permit The permit data to be used in the function call.\n     */\n    function safePermit(IERC20 token, address owner, address spender, bytes calldata permit) internal {\n        if (!tryPermit(token, owner, spender, permit)) RevertReasonForwarder.reRevert();\n    }\n\n    /**\n     * @notice Attempts to execute the `permit` function on the provided token with the sender and contract as parameters.\n     * @dev Invokes `tryPermit` with sender as owner and contract as spender.\n     * @param token The IERC20 token to execute the permit function on.\n     * @param permit The permit data to be used in the function call.\n     * @return success Returns true if the permit function was successfully executed, false otherwise.\n     */\n    function tryPermit(IERC20 token, bytes calldata permit) internal returns(bool success) {\n        return tryPermit(token, msg.sender, address(this), permit);\n    }\n\n    /**\n     * @notice The function attempts to call the permit function on a given ERC20 token.\n     * @dev The function is designed to support a variety of permit functions, namely: IERC20Permit, IDaiLikePermit, IERC7597Permit and IPermit2.\n     * It accommodates both Compact and Full formats of these permit types.\n     * Please note, it is expected that the `expiration` parameter for the compact Permit2 and the `deadline` parameter\n     * for the compact Permit are to be incremented by one before invoking this function. This approach is motivated by\n     * gas efficiency considerations; as the unlimited expiration period is likely to be the most common scenario, and\n     * zeros are cheaper to pass in terms of gas cost. Thus, callers should increment the expiration or deadline by one\n     * before invocation for optimized performance.\n     * Note that the implementation does not perform dirty bits cleaning, so it is the responsibility of\n     * the caller to make sure that the higher 96 bits of the `owner` and `spender` parameters are clean.\n     * @param token The address of the ERC20 token on which to call the permit function.\n     * @param owner The owner of the tokens. This address should have signed the off-chain permit.\n     * @param spender The address which will be approved for transfer of tokens.\n     * @param permit The off-chain permit data, containing different fields depending on the type of permit function.\n     * @return success A boolean indicating whether the permit call was successful.\n     */\n    function tryPermit(IERC20 token, address owner, address spender, bytes calldata permit) internal returns(bool success) {\n        // load function selectors for different permit standards\n        bytes4 permitSelector = IERC20Permit.permit.selector;\n        bytes4 daiPermitSelector = IDaiLikePermit.permit.selector;\n        bytes4 permit2Selector = IPermit2.permit.selector;\n        bytes4 erc7597PermitSelector = IERC7597Permit.permit.selector;\n        assembly (\"memory-safe\") { // solhint-disable-line no-inline-assembly\n            let ptr := mload(0x40)\n\n            // Switch case for different permit lengths, indicating different permit standards\n            switch permit.length\n            // Compact IERC20Permit\n            case 100 {\n                mstore(ptr, permitSelector)     // store selector\n                mstore(add(ptr, 0x04), owner)   // store owner\n                mstore(add(ptr, 0x24), spender) // store spender\n\n                // Compact IERC20Permit.permit(uint256 value, uint32 deadline, uint256 r, uint256 vs)\n                {  // stack too deep\n                    let deadline := shr(224, calldataload(add(permit.offset, 0x20))) // loads permit.offset 0x20..0x23\n                    let vs := calldataload(add(permit.offset, 0x44))                 // loads permit.offset 0x44..0x63\n\n                    calldatacopy(add(ptr, 0x44), permit.offset, 0x20)            // store value     = copy permit.offset 0x00..0x19\n                    mstore(add(ptr, 0x64), sub(deadline, 1))                     // store deadline  = deadline - 1\n                    mstore(add(ptr, 0x84), add(27, shr(255, vs)))                // store v         = most significant bit of vs + 27 (27 or 28)\n                    calldatacopy(add(ptr, 0xa4), add(permit.offset, 0x24), 0x20) // store r         = copy permit.offset 0x24..0x43\n                    mstore(add(ptr, 0xc4), shr(1, shl(1, vs)))                   // store s         = vs without most significant bit\n                }\n                // IERC20Permit.permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)\n                success := call(gas(), token, 0, ptr, 0xe4, 0, 0)\n            }\n            // Compact IDaiLikePermit\n            case 72 {\n                mstore(ptr, daiPermitSelector)  // store selector\n                mstore(add(ptr, 0x04), owner)   // store owner\n                mstore(add(ptr, 0x24), spender) // store spender\n\n                // Compact IDaiLikePermit.permit(uint32 nonce, uint32 expiry, uint256 r, uint256 vs)\n                {  // stack too deep\n                    let expiry := shr(224, calldataload(add(permit.offset, 0x04))) // loads permit.offset 0x04..0x07\n                    let vs := calldataload(add(permit.offset, 0x28))               // loads permit.offset 0x28..0x47\n\n                    mstore(add(ptr, 0x44), shr(224, calldataload(permit.offset))) // store nonce   = copy permit.offset 0x00..0x03\n                    mstore(add(ptr, 0x64), sub(expiry, 1))                        // store expiry  = expiry - 1\n                    mstore(add(ptr, 0x84), true)                                  // store allowed = true\n                    mstore(add(ptr, 0xa4), add(27, shr(255, vs)))                 // store v       = most significant bit of vs + 27 (27 or 28)\n                    calldatacopy(add(ptr, 0xc4), add(permit.offset, 0x08), 0x20)  // store r       = copy permit.offset 0x08..0x27\n                    mstore(add(ptr, 0xe4), shr(1, shl(1, vs)))                    // store s       = vs without most significant bit\n                }\n                // IDaiLikePermit.permit(address holder, address spender, uint256 nonce, uint256 expiry, bool allowed, uint8 v, bytes32 r, bytes32 s)\n                success := call(gas(), token, 0, ptr, 0x104, 0, 0)\n            }\n            // IERC20Permit\n            case 224 {\n                mstore(ptr, permitSelector)\n                calldatacopy(add(ptr, 0x04), permit.offset, permit.length) // copy permit calldata\n                // IERC20Permit.permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)\n                success := call(gas(), token, 0, ptr, 0xe4, 0, 0)\n            }\n            // IDaiLikePermit\n            case 256 {\n                mstore(ptr, daiPermitSelector)\n                calldatacopy(add(ptr, 0x04), permit.offset, permit.length) // copy permit calldata\n                // IDaiLikePermit.permit(address holder, address spender, uint256 nonce, uint256 expiry, bool allowed, uint8 v, bytes32 r, bytes32 s)\n                success := call(gas(), token, 0, ptr, 0x104, 0, 0)\n            }\n            // Compact IPermit2\n            case 96 {\n                // Compact IPermit2.permit(uint160 amount, uint32 expiration, uint32 nonce, uint32 sigDeadline, uint256 r, uint256 vs)\n                mstore(ptr, permit2Selector)  // store selector\n                mstore(add(ptr, 0x04), owner) // store owner\n                mstore(add(ptr, 0x24), token) // store token\n\n                calldatacopy(add(ptr, 0x50), permit.offset, 0x14)             // store amount = copy permit.offset 0x00..0x13\n                // and(0xffffffffffff, ...) - conversion to uint48\n                mstore(add(ptr, 0x64), and(0xffffffffffff, sub(shr(224, calldataload(add(permit.offset, 0x14))), 1))) // store expiration = ((permit.offset 0x14..0x17 - 1) & 0xffffffffffff)\n                mstore(add(ptr, 0x84), shr(224, calldataload(add(permit.offset, 0x18)))) // store nonce = copy permit.offset 0x18..0x1b\n                mstore(add(ptr, 0xa4), spender)                               // store spender\n                // and(0xffffffffffff, ...) - conversion to uint48\n                mstore(add(ptr, 0xc4), and(0xffffffffffff, sub(shr(224, calldataload(add(permit.offset, 0x1c))), 1))) // store sigDeadline = ((permit.offset 0x1c..0x1f - 1) & 0xffffffffffff)\n                mstore(add(ptr, 0xe4), 0x100)                                 // store offset = 256\n                mstore(add(ptr, 0x104), 0x40)                                 // store length = 64\n                calldatacopy(add(ptr, 0x124), add(permit.offset, 0x20), 0x20) // store r      = copy permit.offset 0x20..0x3f\n                calldatacopy(add(ptr, 0x144), add(permit.offset, 0x40), 0x20) // store vs     = copy permit.offset 0x40..0x5f\n                // IPermit2.permit(address owner, PermitSingle calldata permitSingle, bytes calldata signature)\n                success := call(gas(), _PERMIT2, 0, ptr, 0x164, 0, 0)\n            }\n            // IPermit2\n            case 352 {\n                mstore(ptr, permit2Selector)\n                calldatacopy(add(ptr, 0x04), permit.offset, permit.length) // copy permit calldata\n                // IPermit2.permit(address owner, PermitSingle calldata permitSingle, bytes calldata signature)\n                success := call(gas(), _PERMIT2, 0, ptr, 0x164, 0, 0)\n            }\n            // Dynamic length\n            default {\n                mstore(ptr, erc7597PermitSelector)\n                calldatacopy(add(ptr, 0x04), permit.offset, permit.length) // copy permit calldata\n                // IERC7597Permit.permit(address owner, address spender, uint256 value, uint256 deadline, bytes memory signature)\n                success := call(gas(), token, 0, ptr, add(permit.length, 4), 0, 0)\n            }\n        }\n    }\n\n    /**\n     * @dev Executes a low level call to a token contract, making it resistant to reversion and erroneous boolean returns.\n     * @param token The IERC20 token contract on which the call will be made.\n     * @param selector The function signature that is to be called on the token contract.\n     * @param to The address to which the token amount will be transferred.\n     * @param amount The token amount to be transferred.\n     * @return success A boolean indicating if the call was successful. Returns 'true' on success and 'false' on failure.\n     * In case of success but no returned data, validates that the contract code exists.\n     * In case of returned data, ensures that it's a boolean `true`.\n     */\n    function _makeCall(\n        IERC20 token,\n        bytes4 selector,\n        address to,\n        uint256 amount\n    ) private returns (bool success) {\n        assembly (\"memory-safe\") { // solhint-disable-line no-inline-assembly\n            let data := mload(0x40)\n\n            mstore(data, selector)\n            mstore(add(data, 0x04), to)\n            mstore(add(data, 0x24), amount)\n            success := call(gas(), token, 0, data, 0x44, 0x0, 0x20)\n            if success {\n                switch returndatasize()\n                case 0 {\n                    success := gt(extcodesize(token), 0)\n                }\n                default {\n                    success := and(gt(returndatasize(), 31), eq(mload(0), 1))\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Safely deposits a specified amount of Ether into the IWETH contract. Consumes less gas then regular `IWETH.deposit`.\n     * @param weth The IWETH token contract.\n     * @param amount The amount of Ether to deposit into the IWETH contract.\n     */\n    function safeDeposit(IWETH weth, uint256 amount) internal {\n        if (amount > 0) {\n            bytes4 selector = IWETH.deposit.selector;\n            assembly (\"memory-safe\") { // solhint-disable-line no-inline-assembly\n                mstore(0, selector)\n                if iszero(call(gas(), weth, amount, 0, 4, 0, 0)) {\n                    let ptr := mload(0x40)\n                    returndatacopy(ptr, 0, returndatasize())\n                    revert(ptr, returndatasize())\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Safely withdraws a specified amount of wrapped Ether from the IWETH contract. Consumes less gas then regular `IWETH.withdraw`.\n     * @dev Uses inline assembly to interact with the IWETH contract.\n     * @param weth The IWETH token contract.\n     * @param amount The amount of wrapped Ether to withdraw from the IWETH contract.\n     */\n    function safeWithdraw(IWETH weth, uint256 amount) internal {\n        bytes4 selector = IWETH.withdraw.selector;\n        assembly (\"memory-safe\") {  // solhint-disable-line no-inline-assembly\n            mstore(0, selector)\n            mstore(4, amount)\n            if iszero(call(gas(), weth, 0, 0, 0x24, 0, 0)) {\n                let ptr := mload(0x40)\n                returndatacopy(ptr, 0, returndatasize())\n                revert(ptr, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @notice Safely withdraws a specified amount of wrapped Ether from the IWETH contract to a specified recipient.\n     * Consumes less gas then regular `IWETH.withdraw`.\n     * @param weth The IWETH token contract.\n     * @param amount The amount of wrapped Ether to withdraw from the IWETH contract.\n     * @param to The recipient of the withdrawn Ether.\n     */\n    function safeWithdrawTo(IWETH weth, uint256 amount, address to) internal {\n        safeWithdraw(weth, amount);\n        if (to != address(this)) {\n            assembly (\"memory-safe\") {  // solhint-disable-line no-inline-assembly\n                if iszero(call(_RAW_CALL_GAS_LIMIT, to, amount, 0, 0, 0, 0)) {\n                    let ptr := mload(0x40)\n                    returndatacopy(ptr, 0, returndatasize())\n                    revert(ptr, returndatasize())\n                }\n            }\n        }\n    }\n}\n"
    },
    "lib/@openzeppelin/contracts/interfaces/IERC4626.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC4626.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC20/IERC20.sol\";\nimport \"../token/ERC20/extensions/IERC20Metadata.sol\";\n\n/**\n * @dev Interface of the ERC4626 \"Tokenized Vault Standard\", as defined in\n * https://eips.ethereum.org/EIPS/eip-4626[ERC-4626].\n *\n * _Available since v4.7._\n */\ninterface IERC4626 is IERC20, IERC20Metadata {\n    event Deposit(address indexed sender, address indexed owner, uint256 assets, uint256 shares);\n\n    event Withdraw(\n        address indexed sender,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /**\n     * @dev Returns the address of the underlying token used for the Vault for accounting, depositing, and withdrawing.\n     *\n     * - MUST be an ERC-20 token contract.\n     * - MUST NOT revert.\n     */\n    function asset() external view returns (address assetTokenAddress);\n\n    /**\n     * @dev Returns the total amount of the underlying asset that is “managed” by Vault.\n     *\n     * - SHOULD include any compounding that occurs from yield.\n     * - MUST be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT revert.\n     */\n    function totalAssets() external view returns (uint256 totalManagedAssets);\n\n    /**\n     * @dev Returns the amount of shares that the Vault would exchange for the amount of assets provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert.\n     *\n     * NOTE: This calculation MAY NOT reflect the “per-user” price-per-share, and instead should reflect the\n     * “average-user’s” price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n    function convertToShares(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Returns the amount of assets that the Vault would exchange for the amount of shares provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert.\n     *\n     * NOTE: This calculation MAY NOT reflect the “per-user” price-per-share, and instead should reflect the\n     * “average-user’s” price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n    function convertToAssets(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Returns the maximum amount of the underlying asset that can be deposited into the Vault for the receiver,\n     * through a deposit call.\n     *\n     * - MUST return a limited value if receiver is subject to some deposit limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of assets that may be deposited.\n     * - MUST NOT revert.\n     */\n    function maxDeposit(address receiver) external view returns (uint256 maxAssets);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their deposit at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of Vault shares that would be minted in a deposit\n     *   call in the same transaction. I.e. deposit should return the same or more shares as previewDeposit if called\n     *   in the same transaction.\n     * - MUST NOT account for deposit limits like those returned from maxDeposit and should always act as though the\n     *   deposit would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewDeposit SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n    function previewDeposit(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Mints shares Vault shares to receiver by depositing exactly amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   deposit execution, and are accounted for during deposit.\n     * - MUST revert if all of assets cannot be deposited (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault’s underlying asset token.\n     */\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\n\n    /**\n     * @dev Returns the maximum amount of the Vault shares that can be minted for the receiver, through a mint call.\n     * - MUST return a limited value if receiver is subject to some mint limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of shares that may be minted.\n     * - MUST NOT revert.\n     */\n    function maxMint(address receiver) external view returns (uint256 maxShares);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their mint at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of assets that would be deposited in a mint call\n     *   in the same transaction. I.e. mint should return the same or fewer assets as previewMint if called in the\n     *   same transaction.\n     * - MUST NOT account for mint limits like those returned from maxMint and should always act as though the mint\n     *   would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewMint SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by minting.\n     */\n    function previewMint(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the mint\n     *   execution, and are accounted for during mint.\n     * - MUST revert if all of shares cannot be minted (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault’s underlying asset token.\n     */\n    function mint(uint256 shares, address receiver) external returns (uint256 assets);\n\n    /**\n     * @dev Returns the maximum amount of the underlying asset that can be withdrawn from the owner balance in the\n     * Vault, through a withdraw call.\n     *\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n    function maxWithdraw(address owner) external view returns (uint256 maxAssets);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their withdrawal at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of Vault shares that would be burned in a withdraw\n     *   call in the same transaction. I.e. withdraw should return the same or fewer shares as previewWithdraw if\n     *   called\n     *   in the same transaction.\n     * - MUST NOT account for withdrawal limits like those returned from maxWithdraw and should always act as though\n     *   the withdrawal would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewWithdraw SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n    function previewWithdraw(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Burns shares from owner and sends exactly assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   withdraw execution, and are accounted for during withdraw.\n     * - MUST revert if all of assets cannot be withdrawn (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * Note that some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n    function withdraw(uint256 assets, address receiver, address owner) external returns (uint256 shares);\n\n    /**\n     * @dev Returns the maximum amount of Vault shares that can be redeemed from the owner balance in the Vault,\n     * through a redeem call.\n     *\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST return balanceOf(owner) if owner is not subject to any withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n    function maxRedeem(address owner) external view returns (uint256 maxShares);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their redeemption at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of assets that would be withdrawn in a redeem call\n     *   in the same transaction. I.e. redeem should return the same or more assets as previewRedeem if called in the\n     *   same transaction.\n     * - MUST NOT account for redemption limits like those returned from maxRedeem and should always act as though the\n     *   redemption would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewRedeem SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by redeeming.\n     */\n    function previewRedeem(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Burns exactly shares from owner and sends assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   redeem execution, and are accounted for during redeem.\n     * - MUST revert if all of shares cannot be redeemed (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * NOTE: some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n    function redeem(uint256 shares, address receiver, address owner) external returns (uint256 assets);\n}\n"
    },
    "lib/@openzeppelin/contracts/interfaces/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC20/extensions/IERC20Metadata.sol\";\n"
    },
    "lib/@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}\n"
    },
    "lib/@openzeppelin/contracts/token/ERC20/extensions/ERC4626.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/ERC4626.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\nimport \"../utils/SafeERC20.sol\";\nimport \"../../../interfaces/IERC4626.sol\";\nimport \"../../../utils/math/Math.sol\";\n\n/**\n * @dev Implementation of the ERC4626 \"Tokenized Vault Standard\" as defined in\n * https://eips.ethereum.org/EIPS/eip-4626[EIP-4626].\n *\n * This extension allows the minting and burning of \"shares\" (represented using the ERC20 inheritance) in exchange for\n * underlying \"assets\" through standardized {deposit}, {mint}, {redeem} and {burn} workflows. This contract extends\n * the ERC20 standard. Any additional extensions included along it would affect the \"shares\" token represented by this\n * contract and not the \"assets\" token which is an independent contract.\n *\n * [CAUTION]\n * ====\n * In empty (or nearly empty) ERC-4626 vaults, deposits are at high risk of being stolen through frontrunning\n * with a \"donation\" to the vault that inflates the price of a share. This is variously known as a donation or inflation\n * attack and is essentially a problem of slippage. Vault deployers can protect against this attack by making an initial\n * deposit of a non-trivial amount of the asset, such that price manipulation becomes infeasible. Withdrawals may\n * similarly be affected by slippage. Users can protect against this attack as well as unexpected slippage in general by\n * verifying the amount received is as expected, using a wrapper that performs these checks such as\n * https://github.com/fei-protocol/ERC4626#erc4626router-and-base[ERC4626Router].\n *\n * Since v4.9, this implementation uses virtual assets and shares to mitigate that risk. The `_decimalsOffset()`\n * corresponds to an offset in the decimal representation between the underlying asset's decimals and the vault\n * decimals. This offset also determines the rate of virtual shares to virtual assets in the vault, which itself\n * determines the initial exchange rate. While not fully preventing the attack, analysis shows that the default offset\n * (0) makes it non-profitable, as a result of the value being captured by the virtual shares (out of the attacker's\n * donation) matching the attacker's expected gains. With a larger offset, the attack becomes orders of magnitude more\n * expensive than it is profitable. More details about the underlying math can be found\n * xref:erc4626.adoc#inflation-attack[here].\n *\n * The drawback of this approach is that the virtual shares do capture (a very small) part of the value being accrued\n * to the vault. Also, if the vault experiences losses, the users try to exit the vault, the virtual shares and assets\n * will cause the first user to exit to experience reduced losses in detriment to the last users that will experience\n * bigger losses. Developers willing to revert back to the pre-v4.9 behavior just need to override the\n * `_convertToShares` and `_convertToAssets` functions.\n *\n * To learn more, check out our xref:ROOT:erc4626.adoc[ERC-4626 guide].\n * ====\n *\n * _Available since v4.7._\n */\nabstract contract ERC4626 is ERC20, IERC4626 {\n    using Math for uint256;\n\n    IERC20 private immutable _asset;\n    uint8 private immutable _underlyingDecimals;\n\n    /**\n     * @dev Set the underlying asset contract. This must be an ERC20-compatible contract (ERC20 or ERC777).\n     */\n    constructor(IERC20 asset_) {\n        (bool success, uint8 assetDecimals) = _tryGetAssetDecimals(asset_);\n        _underlyingDecimals = success ? assetDecimals : 18;\n        _asset = asset_;\n    }\n\n    /**\n     * @dev Attempts to fetch the asset decimals. A return value of false indicates that the attempt failed in some way.\n     */\n    function _tryGetAssetDecimals(IERC20 asset_) private view returns (bool, uint8) {\n        (bool success, bytes memory encodedDecimals) = address(asset_).staticcall(\n            abi.encodeWithSelector(IERC20Metadata.decimals.selector)\n        );\n        if (success && encodedDecimals.length >= 32) {\n            uint256 returnedDecimals = abi.decode(encodedDecimals, (uint256));\n            if (returnedDecimals <= type(uint8).max) {\n                return (true, uint8(returnedDecimals));\n            }\n        }\n        return (false, 0);\n    }\n\n    /**\n     * @dev Decimals are computed by adding the decimal offset on top of the underlying asset's decimals. This\n     * \"original\" value is cached during construction of the vault contract. If this read operation fails (e.g., the\n     * asset has not been created yet), a default of 18 is used to represent the underlying asset's decimals.\n     *\n     * See {IERC20Metadata-decimals}.\n     */\n    function decimals() public view virtual override(IERC20Metadata, ERC20) returns (uint8) {\n        return _underlyingDecimals + _decimalsOffset();\n    }\n\n    /** @dev See {IERC4626-asset}. */\n    function asset() public view virtual override returns (address) {\n        return address(_asset);\n    }\n\n    /** @dev See {IERC4626-totalAssets}. */\n    function totalAssets() public view virtual override returns (uint256) {\n        return _asset.balanceOf(address(this));\n    }\n\n    /** @dev See {IERC4626-convertToShares}. */\n    function convertToShares(uint256 assets) public view virtual override returns (uint256) {\n        return _convertToShares(assets, Math.Rounding.Down);\n    }\n\n    /** @dev See {IERC4626-convertToAssets}. */\n    function convertToAssets(uint256 shares) public view virtual override returns (uint256) {\n        return _convertToAssets(shares, Math.Rounding.Down);\n    }\n\n    /** @dev See {IERC4626-maxDeposit}. */\n    function maxDeposit(address) public view virtual override returns (uint256) {\n        return type(uint256).max;\n    }\n\n    /** @dev See {IERC4626-maxMint}. */\n    function maxMint(address) public view virtual override returns (uint256) {\n        return type(uint256).max;\n    }\n\n    /** @dev See {IERC4626-maxWithdraw}. */\n    function maxWithdraw(address owner) public view virtual override returns (uint256) {\n        return _convertToAssets(balanceOf(owner), Math.Rounding.Down);\n    }\n\n    /** @dev See {IERC4626-maxRedeem}. */\n    function maxRedeem(address owner) public view virtual override returns (uint256) {\n        return balanceOf(owner);\n    }\n\n    /** @dev See {IERC4626-previewDeposit}. */\n    function previewDeposit(uint256 assets) public view virtual override returns (uint256) {\n        return _convertToShares(assets, Math.Rounding.Down);\n    }\n\n    /** @dev See {IERC4626-previewMint}. */\n    function previewMint(uint256 shares) public view virtual override returns (uint256) {\n        return _convertToAssets(shares, Math.Rounding.Up);\n    }\n\n    /** @dev See {IERC4626-previewWithdraw}. */\n    function previewWithdraw(uint256 assets) public view virtual override returns (uint256) {\n        return _convertToShares(assets, Math.Rounding.Up);\n    }\n\n    /** @dev See {IERC4626-previewRedeem}. */\n    function previewRedeem(uint256 shares) public view virtual override returns (uint256) {\n        return _convertToAssets(shares, Math.Rounding.Down);\n    }\n\n    /** @dev See {IERC4626-deposit}. */\n    function deposit(uint256 assets, address receiver) public virtual override returns (uint256) {\n        require(assets <= maxDeposit(receiver), \"ERC4626: deposit more than max\");\n\n        uint256 shares = previewDeposit(assets);\n        _deposit(_msgSender(), receiver, assets, shares);\n\n        return shares;\n    }\n\n    /** @dev See {IERC4626-mint}.\n     *\n     * As opposed to {deposit}, minting is allowed even if the vault is in a state where the price of a share is zero.\n     * In this case, the shares will be minted without requiring any assets to be deposited.\n     */\n    function mint(uint256 shares, address receiver) public virtual override returns (uint256) {\n        require(shares <= maxMint(receiver), \"ERC4626: mint more than max\");\n\n        uint256 assets = previewMint(shares);\n        _deposit(_msgSender(), receiver, assets, shares);\n\n        return assets;\n    }\n\n    /** @dev See {IERC4626-withdraw}. */\n    function withdraw(uint256 assets, address receiver, address owner) public virtual override returns (uint256) {\n        require(assets <= maxWithdraw(owner), \"ERC4626: withdraw more than max\");\n\n        uint256 shares = previewWithdraw(assets);\n        _withdraw(_msgSender(), receiver, owner, assets, shares);\n\n        return shares;\n    }\n\n    /** @dev See {IERC4626-redeem}. */\n    function redeem(uint256 shares, address receiver, address owner) public virtual override returns (uint256) {\n        require(shares <= maxRedeem(owner), \"ERC4626: redeem more than max\");\n\n        uint256 assets = previewRedeem(shares);\n        _withdraw(_msgSender(), receiver, owner, assets, shares);\n\n        return assets;\n    }\n\n    /**\n     * @dev Internal conversion function (from assets to shares) with support for rounding direction.\n     */\n    function _convertToShares(uint256 assets, Math.Rounding rounding) internal view virtual returns (uint256) {\n        return assets.mulDiv(totalSupply() + 10 ** _decimalsOffset(), totalAssets() + 1, rounding);\n    }\n\n    /**\n     * @dev Internal conversion function (from shares to assets) with support for rounding direction.\n     */\n    function _convertToAssets(uint256 shares, Math.Rounding rounding) internal view virtual returns (uint256) {\n        return shares.mulDiv(totalAssets() + 1, totalSupply() + 10 ** _decimalsOffset(), rounding);\n    }\n\n    /**\n     * @dev Deposit/mint common workflow.\n     */\n    function _deposit(address caller, address receiver, uint256 assets, uint256 shares) internal virtual {\n        // If _asset is ERC777, `transferFrom` can trigger a reentrancy BEFORE the transfer happens through the\n        // `tokensToSend` hook. On the other hand, the `tokenReceived` hook, that is triggered after the transfer,\n        // calls the vault, which is assumed not malicious.\n        //\n        // Conclusion: we need to do the transfer before we mint so that any reentrancy would happen before the\n        // assets are transferred and before the shares are minted, which is a valid state.\n        // slither-disable-next-line reentrancy-no-eth\n        SafeERC20.safeTransferFrom(_asset, caller, address(this), assets);\n        _mint(receiver, shares);\n\n        emit Deposit(caller, receiver, assets, shares);\n    }\n\n    /**\n     * @dev Withdraw/redeem common workflow.\n     */\n    function _withdraw(\n        address caller,\n        address receiver,\n        address owner,\n        uint256 assets,\n        uint256 shares\n    ) internal virtual {\n        if (caller != owner) {\n            _spendAllowance(owner, caller, shares);\n        }\n\n        // If _asset is ERC777, `transfer` can trigger a reentrancy AFTER the transfer happens through the\n        // `tokensReceived` hook. On the other hand, the `tokensToSend` hook, that is triggered before the transfer,\n        // calls the vault, which is assumed not malicious.\n        //\n        // Conclusion: we need to do the transfer after the burn so that any reentrancy would happen after the\n        // shares are burned and after the assets are transferred, which is a valid state.\n        _burn(owner, shares);\n        SafeERC20.safeTransfer(_asset, receiver, assets);\n\n        emit Withdraw(caller, receiver, owner, assets, shares);\n    }\n\n    function _decimalsOffset() internal view virtual returns (uint8) {\n        return 0;\n    }\n}\n"
    },
    "lib/@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (token/ERC20/extensions/ERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20Permit.sol\";\nimport \"../ERC20.sol\";\nimport \"../../../utils/cryptography/ECDSA.sol\";\nimport \"../../../utils/cryptography/EIP712.sol\";\nimport \"../../../utils/Counters.sol\";\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * _Available since v3.4._\n */\nabstract contract ERC20Permit is ERC20, IERC20Permit, EIP712 {\n    using Counters for Counters.Counter;\n\n    mapping(address => Counters.Counter) private _nonces;\n\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private constant _PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    /**\n     * @dev In previous versions `_PERMIT_TYPEHASH` was declared as `immutable`.\n     * However, to ensure consistency with the upgradeable transpiler, we will continue\n     * to reserve a slot.\n     * @custom:oz-renamed-from _PERMIT_TYPEHASH\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private _PERMIT_TYPEHASH_DEPRECATED_SLOT;\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n     */\n    constructor(string memory name) EIP712(name, \"1\") {}\n\n    /**\n     * @inheritdoc IERC20Permit\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= deadline, \"ERC20Permit: expired deadline\");\n\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSA.recover(hash, v, r, s);\n        require(signer == owner, \"ERC20Permit: invalid signature\");\n\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @inheritdoc IERC20Permit\n     */\n    function nonces(address owner) public view virtual override returns (uint256) {\n        return _nonces[owner].current();\n    }\n\n    /**\n     * @inheritdoc IERC20Permit\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /**\n     * @dev \"Consume a nonce\": return the current value and increment.\n     *\n     * _Available since v4.1._\n     */\n    function _useNonce(address owner) internal virtual returns (uint256 current) {\n        Counters.Counter storage nonce = _nonces[owner];\n        current = nonce.current();\n        nonce.increment();\n    }\n}\n"
    },
    "lib/@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "lib/@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        require(value <= type(uint248).max, \"SafeCast: value doesn't fit in 248 bits\");\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        require(value <= type(uint240).max, \"SafeCast: value doesn't fit in 240 bits\");\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        require(value <= type(uint232).max, \"SafeCast: value doesn't fit in 232 bits\");\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        require(value <= type(uint216).max, \"SafeCast: value doesn't fit in 216 bits\");\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        require(value <= type(uint208).max, \"SafeCast: value doesn't fit in 208 bits\");\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        require(value <= type(uint200).max, \"SafeCast: value doesn't fit in 200 bits\");\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        require(value <= type(uint192).max, \"SafeCast: value doesn't fit in 192 bits\");\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        require(value <= type(uint184).max, \"SafeCast: value doesn't fit in 184 bits\");\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        require(value <= type(uint176).max, \"SafeCast: value doesn't fit in 176 bits\");\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        require(value <= type(uint168).max, \"SafeCast: value doesn't fit in 168 bits\");\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        require(value <= type(uint160).max, \"SafeCast: value doesn't fit in 160 bits\");\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        require(value <= type(uint152).max, \"SafeCast: value doesn't fit in 152 bits\");\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        require(value <= type(uint144).max, \"SafeCast: value doesn't fit in 144 bits\");\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        require(value <= type(uint136).max, \"SafeCast: value doesn't fit in 136 bits\");\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        require(value <= type(uint120).max, \"SafeCast: value doesn't fit in 120 bits\");\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        require(value <= type(uint112).max, \"SafeCast: value doesn't fit in 112 bits\");\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        require(value <= type(uint104).max, \"SafeCast: value doesn't fit in 104 bits\");\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        require(value <= type(uint88).max, \"SafeCast: value doesn't fit in 88 bits\");\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        require(value <= type(uint80).max, \"SafeCast: value doesn't fit in 80 bits\");\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        require(value <= type(uint72).max, \"SafeCast: value doesn't fit in 72 bits\");\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        require(value <= type(uint56).max, \"SafeCast: value doesn't fit in 56 bits\");\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        require(value <= type(uint48).max, \"SafeCast: value doesn't fit in 48 bits\");\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        require(value <= type(uint40).max, \"SafeCast: value doesn't fit in 40 bits\");\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        require(value <= type(uint24).max, \"SafeCast: value doesn't fit in 24 bits\");\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     *\n     * _Available since v3.0._\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 248 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 240 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 232 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 224 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 216 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 208 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 200 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 192 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 184 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 176 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 168 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 160 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 152 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 144 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 136 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 128 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 120 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 112 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 104 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 96 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 88 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 80 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 72 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 64 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 56 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 48 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 40 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 32 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 24 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 16 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 8 bits\");\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     *\n     * _Available since v3.0._\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "lib/@openzeppelin/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "lib/@gearbox-protocol/core-v3/contracts/interfaces/IPoolQuotaKeeperV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Foundation, 2024.\npragma solidity ^0.8.17;\n\nimport {IACLTrait} from \"./base/IACLTrait.sol\";\nimport {IContractsRegisterTrait} from \"./base/IContractsRegisterTrait.sol\";\nimport {IVersion} from \"./base/IVersion.sol\";\n\nstruct TokenQuotaParams {\n    uint16 rate;\n    uint192 cumulativeIndexLU;\n    uint16 quotaIncreaseFee;\n    uint96 totalQuoted;\n    uint96 limit;\n}\n\nstruct AccountQuota {\n    uint96 quota;\n    uint192 cumulativeIndexLU;\n}\n\ninterface IPoolQuotaKeeperV3Events {\n    /// @notice Emitted when account's quota for a token is updated\n    event UpdateQuota(address indexed creditAccount, address indexed token, int96 quotaChange);\n\n    /// @notice Emitted when token's quota rate is updated\n    event UpdateTokenQuotaRate(address indexed token, uint16 rate);\n\n    /// @notice Emitted when the gauge is updated\n    event SetGauge(address indexed newGauge);\n\n    /// @notice Emitted when a new credit manager is allowed\n    event AddCreditManager(address indexed creditManager);\n\n    /// @notice Emitted when a new token is added as quoted\n    event AddQuotaToken(address indexed token);\n\n    /// @notice Emitted when a new total quota limit is set for a token\n    event SetTokenLimit(address indexed token, uint96 limit);\n\n    /// @notice Emitted when a new one-time quota increase fee is set for a token\n    event SetQuotaIncreaseFee(address indexed token, uint16 fee);\n}\n\n/// @title Pool quota keeper V3 interface\ninterface IPoolQuotaKeeperV3 is IPoolQuotaKeeperV3Events, IVersion, IACLTrait, IContractsRegisterTrait {\n    function pool() external view returns (address);\n\n    function underlying() external view returns (address);\n\n    // ----------------- //\n    // QUOTAS MANAGEMENT //\n    // ----------------- //\n\n    function updateQuota(address creditAccount, address token, int96 requestedChange, uint96 minQuota, uint96 maxQuota)\n        external\n        returns (uint128 caQuotaInterestChange, uint128 fees, bool enableToken, bool disableToken);\n\n    function removeQuotas(address creditAccount, address[] calldata tokens, bool setLimitsToZero) external;\n\n    function accrueQuotaInterest(address creditAccount, address[] calldata tokens) external;\n\n    function getQuotaRate(address) external view returns (uint16);\n\n    function cumulativeIndex(address token) external view returns (uint192);\n\n    function isQuotedToken(address token) external view returns (bool);\n\n    function getQuota(address creditAccount, address token)\n        external\n        view\n        returns (uint96 quota, uint192 cumulativeIndexLU);\n\n    function getTokenQuotaParams(address token)\n        external\n        view\n        returns (\n            uint16 rate,\n            uint192 cumulativeIndexLU,\n            uint16 quotaIncreaseFee,\n            uint96 totalQuoted,\n            uint96 limit,\n            bool isActive\n        );\n\n    function getQuotaAndOutstandingInterest(address creditAccount, address token)\n        external\n        view\n        returns (uint96 quoted, uint128 outstandingInterest);\n\n    function poolQuotaRevenue() external view returns (uint256);\n\n    function lastQuotaRateUpdate() external view returns (uint40);\n\n    // ------------- //\n    // CONFIGURATION //\n    // ------------- //\n\n    function gauge() external view returns (address);\n\n    function setGauge(address _gauge) external;\n\n    function creditManagers() external view returns (address[] memory);\n\n    function addCreditManager(address _creditManager) external;\n\n    function quotedTokens() external view returns (address[] memory);\n\n    function addQuotaToken(address token) external;\n\n    function updateRates() external;\n\n    function setTokenLimit(address token, uint96 limit) external;\n\n    function setTokenQuotaIncreaseFee(address token, uint16 fee) external;\n}\n"
    },
    "lib/@gearbox-protocol/core-v3/contracts/interfaces/IPoolV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Foundation, 2024.\npragma solidity ^0.8.17;\npragma abicoder v1;\n\nimport {IERC4626} from \"@openzeppelin/contracts/interfaces/IERC4626.sol\";\nimport {IERC20Permit} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\";\nimport {IACLTrait} from \"./base/IACLTrait.sol\";\nimport {IContractsRegisterTrait} from \"./base/IContractsRegisterTrait.sol\";\nimport {IVersion} from \"./base/IVersion.sol\";\n\ninterface IPoolV3Events {\n    /// @notice Emitted when depositing liquidity with referral code\n    event Refer(address indexed onBehalfOf, uint256 indexed referralCode, uint256 amount);\n\n    /// @notice Emitted when credit account borrows funds from the pool\n    event Borrow(address indexed creditManager, address indexed creditAccount, uint256 amount);\n\n    /// @notice Emitted when credit account's debt is repaid to the pool\n    event Repay(address indexed creditManager, uint256 borrowedAmount, uint256 profit, uint256 loss);\n\n    /// @notice Emitted when incurred loss can't be fully covered by burning treasury's shares\n    event IncurUncoveredLoss(address indexed creditManager, uint256 loss);\n\n    /// @notice Emitted when new interest rate model contract is set\n    event SetInterestRateModel(address indexed newInterestRateModel);\n\n    /// @notice Emitted when new pool quota keeper contract is set\n    event SetPoolQuotaKeeper(address indexed newPoolQuotaKeeper);\n\n    /// @notice Emitted when new total debt limit is set\n    event SetTotalDebtLimit(uint256 limit);\n\n    /// @notice Emitted when new credit manager is connected to the pool\n    event AddCreditManager(address indexed creditManager);\n\n    /// @notice Emitted when new debt limit is set for a credit manager\n    event SetCreditManagerDebtLimit(address indexed creditManager, uint256 newLimit);\n\n    /// @notice Emitted when new withdrawal fee is set\n    event SetWithdrawFee(uint256 fee);\n}\n\n/// @title Pool V3 interface\ninterface IPoolV3 is IVersion, IACLTrait, IContractsRegisterTrait, IPoolV3Events, IERC4626, IERC20Permit {\n    function underlyingToken() external view returns (address);\n\n    function treasury() external view returns (address);\n\n    function withdrawFee() external view returns (uint16);\n\n    function creditManagers() external view returns (address[] memory);\n\n    function availableLiquidity() external view returns (uint256);\n\n    function expectedLiquidity() external view returns (uint256);\n\n    function expectedLiquidityLU() external view returns (uint256);\n\n    // ---------------- //\n    // ERC-4626 LENDING //\n    // ---------------- //\n\n    function depositWithReferral(uint256 assets, address receiver, uint256 referralCode)\n        external\n        returns (uint256 shares);\n\n    function mintWithReferral(uint256 shares, address receiver, uint256 referralCode)\n        external\n        returns (uint256 assets);\n\n    // --------- //\n    // BORROWING //\n    // --------- //\n\n    function totalBorrowed() external view returns (uint256);\n\n    function totalDebtLimit() external view returns (uint256);\n\n    function creditManagerBorrowed(address creditManager) external view returns (uint256);\n\n    function creditManagerDebtLimit(address creditManager) external view returns (uint256);\n\n    function creditManagerBorrowable(address creditManager) external view returns (uint256 borrowable);\n\n    function lendCreditAccount(uint256 borrowedAmount, address creditAccount) external;\n\n    function repayCreditAccount(uint256 repaidAmount, uint256 profit, uint256 loss) external;\n\n    // ------------- //\n    // INTEREST RATE //\n    // ------------- //\n\n    function interestRateModel() external view returns (address);\n\n    function baseInterestRate() external view returns (uint256);\n\n    function supplyRate() external view returns (uint256);\n\n    function baseInterestIndex() external view returns (uint256);\n\n    function baseInterestIndexLU() external view returns (uint256);\n\n    function lastBaseInterestUpdate() external view returns (uint40);\n\n    // ------ //\n    // QUOTAS //\n    // ------ //\n\n    function poolQuotaKeeper() external view returns (address);\n\n    function quotaRevenue() external view returns (uint256);\n\n    function lastQuotaRevenueUpdate() external view returns (uint40);\n\n    function updateQuotaRevenue(int256 quotaRevenueDelta) external;\n\n    function setQuotaRevenue(uint256 newQuotaRevenue) external;\n\n    // ------------- //\n    // CONFIGURATION //\n    // ------------- //\n\n    function setInterestRateModel(address newInterestRateModel) external;\n\n    function setPoolQuotaKeeper(address newPoolQuotaKeeper) external;\n\n    function setTotalDebtLimit(uint256 newLimit) external;\n\n    function setCreditManagerDebtLimit(address creditManager, uint256 newLimit) external;\n\n    function setWithdrawFee(uint256 newWithdrawFee) external;\n\n    function pause() external;\n\n    function unpause() external;\n}\n"
    },
    "lib/@gearbox-protocol/core-v3/contracts/interfaces/base/IInterestRateModel.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Foundation, 2024.\npragma solidity ^0.8.17;\n\nimport {IVersion} from \"./IVersion.sol\";\nimport {IStateSerializer} from \"./IStateSerializer.sol\";\n\n/// @title Interest rate model interface\n/// @notice Generic interface for an interest rate model contract that can be used in a pool\n/// @dev Interest rate models must have type `IRM::{POSTFIX}`\ninterface IInterestRateModel is IVersion, IStateSerializer {\n    /// @notice Calculates borrow rate based on utilization\n    /// @dev The last parameter can be used to prevent borrowing above maximum allowed utilization\n    /// @dev This function can be state-changing in case the IRM is stateful\n    function calcBorrowRate(uint256 expectedLiquidity, uint256 availableLiquidity, bool checkOptimalBorrowing)\n        external\n        returns (uint256);\n\n    /// @notice Returns amount that can be borrowed before maximum allowed utilization is reached\n    function availableToBorrow(uint256 expectedLiquidity, uint256 availableLiquidity) external view returns (uint256);\n}\n"
    },
    "lib/@gearbox-protocol/core-v3/contracts/libraries/CreditLogic.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Foundation, 2024.\npragma solidity ^0.8.17;\n\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport {CollateralDebtData, CollateralTokenData} from \"../interfaces/ICreditManagerV3.sol\";\nimport {SECONDS_PER_YEAR, PERCENTAGE_FACTOR} from \"../libraries/Constants.sol\";\n\nimport {BitMask} from \"./BitMask.sol\";\n\nuint256 constant INDEX_PRECISION = 10 ** 9;\n\n/// @title Credit logic library\n/// @notice Implements functions used for debt and repayment calculations\nlibrary CreditLogic {\n    using BitMask for uint256;\n    using SafeCast for uint256;\n\n    // ----------------- //\n    // DEBT AND INTEREST //\n    // ----------------- //\n\n    /// @dev Computes growth since last update given yearly growth\n    function calcLinearGrowth(uint256 value, uint256 timestampLastUpdate) internal view returns (uint256) {\n        return value * (block.timestamp - timestampLastUpdate) / SECONDS_PER_YEAR;\n    }\n\n    /// @dev Computes interest accrued since the last update\n    function calcAccruedInterest(uint256 amount, uint256 cumulativeIndexLastUpdate, uint256 cumulativeIndexNow)\n        internal\n        pure\n        returns (uint256)\n    {\n        if (amount == 0) return 0;\n        return (amount * cumulativeIndexNow) / cumulativeIndexLastUpdate - amount; // U:[CL-1]\n    }\n\n    /// @dev Computes total debt, given raw debt data\n    /// @param collateralDebtData See `CollateralDebtData` (must have debt data filled)\n    function calcTotalDebt(CollateralDebtData memory collateralDebtData) internal pure returns (uint256) {\n        return collateralDebtData.debt + collateralDebtData.accruedInterest + collateralDebtData.accruedFees;\n    }\n\n    // ----------- //\n    // LIQUIDATION //\n    // ----------- //\n\n    /// @dev Computes the amount of underlying tokens to send to the pool on credit account liquidation\n    ///      - First, liquidation premium and fee are subtracted from account's total value\n    ///      - The resulting value is then used to repay the debt to the pool, and any remaining fudns\n    ///        are send back to the account owner\n    ///      - If, however, funds are insufficient to fully repay the debt, the function will first reduce\n    ///        protocol profits before finally reporting a bad debt liquidation with loss\n    /// @param collateralDebtData See `CollateralDebtData` (must have both collateral and debt data filled)\n    /// @param feeLiquidation Liquidation fee charged by the DAO on the account collateral\n    /// @param liquidationDiscount Percentage to discount account collateral by (equals 1 - liquidation premium)\n    /// @param amountWithFeeFn Function that, given the exact amount of underlying tokens to receive,\n    ///        returns the amount that needs to be sent\n    /// @param amountWithFeeFn Function that, given the exact amount of underlying tokens to send,\n    ///        returns the amount that will be received\n    /// @return amountToPool Amount of underlying tokens to send to the pool\n    /// @return remainingFunds Amount of underlying tokens to send to the credit account owner\n    /// @return profit Amount of underlying tokens received as fees by the DAO\n    /// @return loss Portion of account's debt that can't be repaid\n    function calcLiquidationPayments(\n        CollateralDebtData memory collateralDebtData,\n        uint16 feeLiquidation,\n        uint16 liquidationDiscount,\n        function (uint256) view returns (uint256) amountWithFeeFn,\n        function (uint256) view returns (uint256) amountMinusFeeFn\n    ) internal view returns (uint256 amountToPool, uint256 remainingFunds, uint256 profit, uint256 loss) {\n        amountToPool = calcTotalDebt(collateralDebtData); // U:[CL-4]\n\n        uint256 debtWithInterest = collateralDebtData.debt + collateralDebtData.accruedInterest;\n\n        uint256 totalValue = collateralDebtData.totalValue;\n\n        uint256 totalFunds = totalValue * liquidationDiscount / PERCENTAGE_FACTOR;\n\n        amountToPool += totalValue * feeLiquidation / PERCENTAGE_FACTOR; // U:[CL-4]\n\n        uint256 amountToPoolWithFee = amountWithFeeFn(amountToPool);\n        unchecked {\n            if (totalFunds > amountToPoolWithFee) {\n                remainingFunds = totalFunds - amountToPoolWithFee; // U:[CL-4]\n            } else {\n                amountToPoolWithFee = totalFunds;\n                amountToPool = amountMinusFeeFn(totalFunds); // U:[CL-4]\n            }\n\n            if (amountToPool >= debtWithInterest) {\n                profit = amountToPool - debtWithInterest; // U:[CL-4]\n            } else {\n                loss = debtWithInterest - amountToPool; // U:[CL-4]\n            }\n        }\n\n        amountToPool = amountToPoolWithFee; // U:[CL-4]\n    }\n\n    // --------------------- //\n    // LIQUIDATION THRESHOLD //\n    // --------------------- //\n\n    /// @dev Returns the current liquidation threshold based on token data\n    /// @dev GearboxV3 supports liquidation threshold ramping, which means that the LT can be set to change dynamically\n    ///      from one value to another over time. LT changes linearly, starting at `ltInitial` and ending at `ltFinal`.\n    ///      To make LT static, the value can be written to `ltInitial` with ramp start set far in the future.\n    function getLiquidationThreshold(uint16 ltInitial, uint16 ltFinal, uint40 timestampRampStart, uint24 rampDuration)\n        internal\n        view\n        returns (uint16)\n    {\n        if (block.timestamp <= timestampRampStart) return ltInitial; // U:[CL-5]\n\n        uint40 timestampRampEnd = timestampRampStart + rampDuration;\n        if (block.timestamp >= timestampRampEnd) return ltFinal; // U:[CL-5]\n\n        // cast is safe since LT is between `ltInitial` and `ltFinal`, both of which are `uint16`\n        return uint16(\n            (ltInitial * (timestampRampEnd - block.timestamp) + ltFinal * (block.timestamp - timestampRampStart))\n                / (timestampRampEnd - timestampRampStart)\n        ); // U:[CL-5]\n    }\n\n    // ----------- //\n    // MANAGE DEBT //\n    // ----------- //\n\n    /// @dev Computes new debt principal and interest index after increasing debt\n    ///      - The new debt principal is simply `debt + amount`\n    ///      - The new credit account's interest index is a solution to the equation\n    ///        `debt * (indexNow / indexLastUpdate - 1) = (debt + amount) * (indexNow / indexNew - 1)`,\n    ///        which essentially writes that interest accrued since last update remains the same\n    /// @param amount Amount to increase debt by\n    /// @param debt Debt principal before increase\n    /// @param cumulativeIndexNow The current interest index\n    /// @param cumulativeIndexLastUpdate Credit account's interest index as of last update\n    /// @return newDebt Debt principal after increase\n    /// @return newCumulativeIndex New credit account's interest index\n    function calcIncrease(uint256 amount, uint256 debt, uint256 cumulativeIndexNow, uint256 cumulativeIndexLastUpdate)\n        internal\n        pure\n        returns (uint256 newDebt, uint256 newCumulativeIndex)\n    {\n        if (debt == 0) return (amount, cumulativeIndexNow);\n        newDebt = debt + amount; // U:[CL-2]\n        newCumulativeIndex = (\n            (cumulativeIndexNow * newDebt * INDEX_PRECISION)\n                / ((INDEX_PRECISION * cumulativeIndexNow * debt) / cumulativeIndexLastUpdate + INDEX_PRECISION * amount)\n        ); // U:[CL-2]\n    }\n\n    /// @dev Computes new debt principal and interest index (and other values) after decreasing debt\n    ///      - Debt comprises of multiple components which are repaid in the following order:\n    ///        quota update fees => quota interest => base interest => debt principal.\n    ///        New values for all these components depend on what portion of each was repaid.\n    ///      - Debt principal, for example, only decreases if all previous components were fully repaid\n    ///      - The new credit account's interest index stays the same if base interest was not repaid at all,\n    ///        is set to the current interest index if base interest was repaid fully, and is a solution to\n    ///        the equation `debt * (indexNow / indexLastUpdate - 1) - delta = debt * (indexNow / indexNew - 1)`\n    ///        when only `delta` of accrued interest was repaid\n    /// @param amount Amount of debt to repay\n    /// @param debt Debt principal before repayment\n    /// @param cumulativeIndexNow The current interest index\n    /// @param cumulativeIndexLastUpdate Credit account's interest index as of last update\n    /// @param cumulativeQuotaInterest Credit account's quota interest before repayment\n    /// @param quotaFees Accrued quota fees\n    /// @param feeInterest Fee on accrued interest (both base and quota) charged by the DAO\n    /// @return newDebt Debt principal after repayment\n    /// @return newCumulativeIndex Credit account's quota interest after repayment\n    /// @return profit Amount of underlying tokens received as fees by the DAO\n    /// @return newCumulativeQuotaInterest Credit account's accrued quota interest after repayment\n    /// @return newQuotaFees Amount of unpaid quota fees left after repayment\n    function calcDecrease(\n        uint256 amount,\n        uint256 debt,\n        uint256 cumulativeIndexNow,\n        uint256 cumulativeIndexLastUpdate,\n        uint128 cumulativeQuotaInterest,\n        uint128 quotaFees,\n        uint16 feeInterest\n    )\n        internal\n        pure\n        returns (\n            uint256 newDebt,\n            uint256 newCumulativeIndex,\n            uint256 profit,\n            uint128 newCumulativeQuotaInterest,\n            uint128 newQuotaFees\n        )\n    {\n        uint256 amountToRepay = amount;\n\n        unchecked {\n            if (quotaFees != 0) {\n                if (amountToRepay > quotaFees) {\n                    newQuotaFees = 0; // U:[CL-3]\n                    amountToRepay -= quotaFees;\n                    profit = quotaFees; // U:[CL-3]\n                } else {\n                    newQuotaFees = quotaFees - uint128(amountToRepay); // U:[CL-3]\n                    profit = amountToRepay; // U:[CL-3]\n                    amountToRepay = 0;\n                }\n            }\n        }\n\n        if (cumulativeQuotaInterest != 0 && amountToRepay != 0) {\n            uint256 quotaProfit = (cumulativeQuotaInterest * feeInterest) / PERCENTAGE_FACTOR;\n\n            if (amountToRepay >= cumulativeQuotaInterest + quotaProfit) {\n                amountToRepay -= cumulativeQuotaInterest + quotaProfit; // U:[CL-3]\n                profit += quotaProfit; // U:[CL-3]\n\n                newCumulativeQuotaInterest = 0; // U:[CL-3]\n            } else {\n                // If amount is not enough to repay quota interest + DAO fee, then it is split pro-rata between them\n                uint256 amountToPool = (amountToRepay * PERCENTAGE_FACTOR) / (PERCENTAGE_FACTOR + feeInterest);\n\n                profit += amountToRepay - amountToPool; // U:[CL-3]\n                amountToRepay = 0; // U:[CL-3]\n\n                newCumulativeQuotaInterest = uint128(cumulativeQuotaInterest - amountToPool); // U:[CL-3]\n            }\n        } else {\n            newCumulativeQuotaInterest = cumulativeQuotaInterest;\n        }\n\n        if (amountToRepay != 0) {\n            uint256 interestAccrued = calcAccruedInterest({\n                amount: debt,\n                cumulativeIndexLastUpdate: cumulativeIndexLastUpdate,\n                cumulativeIndexNow: cumulativeIndexNow\n            }); // U:[CL-3]\n            uint256 profitFromInterest = (interestAccrued * feeInterest) / PERCENTAGE_FACTOR; // U:[CL-3]\n\n            if (amountToRepay >= interestAccrued + profitFromInterest) {\n                amountToRepay -= interestAccrued + profitFromInterest;\n\n                profit += profitFromInterest; // U:[CL-3]\n\n                newCumulativeIndex = cumulativeIndexNow; // U:[CL-3]\n            } else {\n                // If amount is not enough to repay base interest + DAO fee, then it is split pro-rata between them\n                uint256 amountToPool = (amountToRepay * PERCENTAGE_FACTOR) / (PERCENTAGE_FACTOR + feeInterest);\n\n                profit += amountToRepay - amountToPool; // U:[CL-3]\n                amountToRepay = 0; // U:[CL-3]\n\n                newCumulativeIndex = (INDEX_PRECISION * cumulativeIndexNow * cumulativeIndexLastUpdate)\n                    / (\n                        INDEX_PRECISION * cumulativeIndexNow\n                            - (INDEX_PRECISION * amountToPool * cumulativeIndexLastUpdate) / debt\n                    ); // U:[CL-3]\n            }\n        } else {\n            newCumulativeIndex = cumulativeIndexLastUpdate; // U:[CL-3]\n        }\n        newDebt = debt - amountToRepay; // U:[CL-3]\n    }\n}\n"
    },
    "lib/@gearbox-protocol/core-v3/contracts/traits/ContractsRegisterTrait.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Foundation, 2024.\npragma solidity ^0.8.17;\n\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport {IContractsRegister} from \"../interfaces/base/IContractsRegister.sol\";\nimport {IContractsRegisterTrait} from \"../interfaces/base/IContractsRegisterTrait.sol\";\nimport {\n    AddressIsNotContractException,\n    RegisteredCreditManagerOnlyException,\n    RegisteredPoolOnlyException,\n    ZeroAddressException\n} from \"../interfaces/IExceptions.sol\";\n\n/// @title Contracts register trait\n/// @notice Trait that simplifies validation of pools and credit managers\nabstract contract ContractsRegisterTrait is IContractsRegisterTrait {\n    using Address for address;\n\n    /// @notice Contracts register contract address\n    address public immutable override contractsRegister;\n\n    /// @dev Ensures that given address is a registered pool\n    modifier registeredPoolOnly(address addr) {\n        _ensureRegisteredPool(addr);\n        _;\n    }\n\n    /// @dev Ensures that given address is a registered credit manager\n    modifier registeredCreditManagerOnly(address addr) {\n        _ensureRegisteredCreditManager(addr);\n        _;\n    }\n\n    /// @notice Constructor\n    /// @param _contractsRegister Contracts register address\n    constructor(address _contractsRegister) {\n        if (_contractsRegister == address(0)) revert ZeroAddressException();\n        if (!_contractsRegister.isContract()) revert AddressIsNotContractException(_contractsRegister);\n        contractsRegister = _contractsRegister;\n    }\n\n    /// @dev Ensures that given address is a registered pool\n    function _ensureRegisteredPool(address addr) internal view {\n        if (!IContractsRegister(contractsRegister).isPool(addr)) revert RegisteredPoolOnlyException();\n    }\n\n    /// @dev Ensures that given address is a registered credit manager\n    function _ensureRegisteredCreditManager(address addr) internal view {\n        if (!IContractsRegister(contractsRegister).isCreditManager(addr)) revert RegisteredCreditManagerOnlyException();\n    }\n}\n"
    },
    "lib/@gearbox-protocol/core-v3/contracts/traits/ReentrancyGuardTrait.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Foundation, 2024.\npragma solidity ^0.8.17;\n\nuint8 constant NOT_ENTERED = 1;\nuint8 constant ENTERED = 2;\n\n/// @title Reentrancy guard trait\n/// @notice Same as OpenZeppelin's `ReentrancyGuard` but the flag only uses 1 byte of storage instead of 32,\n///         which allows to pack it with other frequently accessed state variables\nabstract contract ReentrancyGuardTrait {\n    uint8 internal _reentrancyStatus = NOT_ENTERED;\n\n    /// @dev Prevents a contract from calling itself, directly or indirectly.\n    /// Calling a `nonReentrant` function from another `nonReentrant`\n    /// function is not supported. It is possible to prevent this from happening\n    /// by making the `nonReentrant` function external, and making it call a\n    /// `private` function that does the actual work.\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        _ensureNotEntered();\n\n        // Any calls to nonReentrant after this point will fail\n        _reentrancyStatus = ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _reentrancyStatus = NOT_ENTERED;\n    }\n\n    /// @dev Reverts if the contract is currently entered\n    /// @dev Used to cut contract size on modifiers\n    function _ensureNotEntered() internal view {\n        require(_reentrancyStatus != ENTERED, \"ReentrancyGuard: reentrant call\");\n    }\n}\n"
    },
    "lib/@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "lib/@gearbox-protocol/core-v3/contracts/interfaces/base/IACL.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Foundation, 2024.\npragma solidity ^0.8.17;\n\ninterface IACL {\n    function isConfigurator(address account) external view returns (bool);\n    function hasRole(bytes32 role, address account) external view returns (bool);\n}\n"
    },
    "lib/@gearbox-protocol/core-v3/contracts/libraries/BalancesLogic.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Foundation, 2024.\npragma solidity ^0.8.17;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {SafeERC20} from \"@1inch/solidity-utils/contracts/libraries/SafeERC20.sol\";\n\nimport {BitMask} from \"./BitMask.sol\";\n\nstruct Balance {\n    address token;\n    uint256 balance;\n}\n\nstruct BalanceWithMask {\n    address token;\n    uint256 tokenMask;\n    uint256 balance;\n}\n\nstruct BalanceDelta {\n    address token;\n    int256 amount;\n}\n\nenum Comparison {\n    GREATER_OR_EQUAL,\n    LESS_OR_EQUAL\n}\n\n/// @title Balances logic library\n/// @notice Implements functions for before-and-after balance comparisons\nlibrary BalancesLogic {\n    using BitMask for uint256;\n    using SafeCast for int256;\n    using SafeCast for uint256;\n    using SafeERC20 for IERC20;\n\n    /// @dev Compares current `token` balance with `value`\n    /// @param token Token to check balance for\n    /// @param value Value to compare current token balance with\n    /// @param comparison Whether current balance must be greater/less than or equal to `value`\n    function checkBalance(address creditAccount, address token, uint256 value, Comparison comparison)\n        internal\n        view\n        returns (bool)\n    {\n        uint256 current = IERC20(token).safeBalanceOf(creditAccount);\n        return (comparison == Comparison.GREATER_OR_EQUAL && current >= value)\n            || (comparison == Comparison.LESS_OR_EQUAL && current <= value); // U:[BLL-1]\n    }\n\n    /// @dev Returns an array of expected token balances after operations\n    /// @param creditAccount Credit account to compute balances for\n    /// @param deltas Array of expected token balance changes\n    function storeBalances(address creditAccount, BalanceDelta[] memory deltas)\n        internal\n        view\n        returns (Balance[] memory balances)\n    {\n        uint256 len = deltas.length;\n        balances = new Balance[](len); // U:[BLL-2]\n        for (uint256 i = 0; i < len;) {\n            int256 balance = IERC20(deltas[i].token).safeBalanceOf(creditAccount).toInt256();\n            balances[i] = Balance({token: deltas[i].token, balance: (balance + deltas[i].amount).toUint256()}); // U:[BLL-2]\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @dev Compares current balances with the previously stored ones\n    /// @param creditAccount Credit account to compare balances for\n    /// @param balances Array of previously stored balances\n    /// @param comparison Whether current balances must be greater/less than or equal to stored ones\n    /// @return failedToken The first token for which the condition specified by `comparison` fails, if any\n    function compareBalances(address creditAccount, Balance[] memory balances, Comparison comparison)\n        internal\n        view\n        returns (address failedToken)\n    {\n        unchecked {\n            uint256 len = balances.length;\n            for (uint256 i; i < len; ++i) {\n                if (!BalancesLogic.checkBalance(creditAccount, balances[i].token, balances[i].balance, comparison)) {\n                    return balances[i].token; // U:[BLL-3]\n                }\n            }\n        }\n    }\n\n    /// @dev Returns balances of specified tokens on the credit account\n    /// @param creditAccount Credit account to compute balances for\n    /// @param tokensMask Bit mask of tokens to compute balances for\n    /// @param getTokenByMaskFn Function that returns token's address by its mask\n    function storeBalances(\n        address creditAccount,\n        uint256 tokensMask,\n        function (uint256) view returns (address) getTokenByMaskFn\n    ) internal view returns (BalanceWithMask[] memory balances) {\n        if (tokensMask == 0) return balances;\n\n        balances = new BalanceWithMask[](tokensMask.calcEnabledTokens()); // U:[BLL-4]\n        unchecked {\n            uint256 i;\n            while (tokensMask != 0) {\n                uint256 tokenMask = tokensMask.lsbMask();\n                tokensMask ^= tokenMask;\n\n                address token = getTokenByMaskFn(tokenMask);\n                balances[i] = BalanceWithMask({\n                    token: token,\n                    tokenMask: tokenMask,\n                    balance: IERC20(token).safeBalanceOf(creditAccount)\n                }); // U:[BLL-4]\n                ++i;\n            }\n        }\n    }\n\n    /// @dev Compares current balances of specified tokens with the previously stored ones\n    /// @param creditAccount Credit account to compare balances for\n    /// @param tokensMask Bit mask of tokens to compare balances for\n    /// @param balances Array of previously stored balances\n    /// @param comparison Whether current balances must be greater/less than or equal to stored ones\n    /// @return failedToken The first token for which the condition specified by `comparison` fails, if any\n    /// @dev This function assumes that `tokensMask` encodes a subset of tokens from `balances`\n    function compareBalances(\n        address creditAccount,\n        uint256 tokensMask,\n        BalanceWithMask[] memory balances,\n        Comparison comparison\n    ) internal view returns (address failedToken) {\n        if (tokensMask == 0) return address(0);\n\n        unchecked {\n            uint256 len = balances.length;\n            for (uint256 i; i < len; ++i) {\n                if (tokensMask & balances[i].tokenMask == 0) continue;\n                if (!BalancesLogic.checkBalance(creditAccount, balances[i].token, balances[i].balance, comparison)) {\n                    return balances[i].token; // U:[BLL-5]\n                }\n            }\n        }\n    }\n}\n"
    },
    "lib/@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "lib/@1inch/solidity-utils/contracts/interfaces/IDaiLikePermit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title IDaiLikePermit\n * @dev Interface for Dai-like permit function allowing token spending via signatures.\n */\ninterface IDaiLikePermit {\n    /**\n     * @notice Approves spending of tokens via off-chain signatures.\n     * @param holder Token holder's address.\n     * @param spender Spender's address.\n     * @param nonce Current nonce of the holder.\n     * @param expiry Time when the permit expires.\n     * @param allowed True to allow, false to disallow spending.\n     * @param v, r, s Signature components.\n     */\n    function permit(\n        address holder,\n        address spender,\n        uint256 nonce,\n        uint256 expiry,\n        bool allowed,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n"
    },
    "lib/@1inch/solidity-utils/contracts/interfaces/IPermit2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title IPermit2\n * @dev Interface for a flexible permit system that extends ERC20 tokens to support permits in tokens lacking native permit functionality.\n */\ninterface IPermit2 {\n    /**\n     * @dev Struct for holding permit details.\n     * @param token ERC20 token address for which the permit is issued.\n     * @param amount The maximum amount allowed to spend.\n     * @param expiration Timestamp until which the permit is valid.\n     * @param nonce An incrementing value for each signature, unique per owner, token, and spender.\n     */\n    struct PermitDetails {\n        address token;\n        uint160 amount;\n        uint48 expiration;\n        uint48 nonce;\n    }\n\n    /**\n     * @dev Struct for a single token allowance permit.\n     * @param details Permit details including token, amount, expiration, and nonce.\n     * @param spender Address authorized to spend the tokens.\n     * @param sigDeadline Deadline for the permit signature, ensuring timeliness of the permit.\n     */\n    struct PermitSingle {\n        PermitDetails details;\n        address spender;\n        uint256 sigDeadline;\n    }\n\n    /**\n     * @dev Struct for packed allowance data to optimize storage.\n     * @param amount Amount allowed.\n     * @param expiration Permission expiry timestamp.\n     * @param nonce Unique incrementing value for tracking allowances.\n     */\n    struct PackedAllowance {\n        uint160 amount;\n        uint48 expiration;\n        uint48 nonce;\n    }\n\n    /**\n     * @notice Executes a token transfer from one address to another.\n     * @param user The token owner's address.\n     * @param spender The address authorized to spend the tokens.\n     * @param amount The amount of tokens to transfer.\n     * @param token The address of the token being transferred.\n     */\n    function transferFrom(address user, address spender, uint160 amount, address token) external;\n\n    /**\n     * @notice Issues a permit for spending tokens via a signed authorization.\n     * @param owner The token owner's address.\n     * @param permitSingle Struct containing the permit details.\n     * @param signature The signature proving the owner authorized the permit.\n     */\n    function permit(address owner, PermitSingle memory permitSingle, bytes calldata signature) external;\n\n    /**\n     * @notice Retrieves the allowance details between a token owner and spender.\n     * @param user The token owner's address.\n     * @param token The token address.\n     * @param spender The spender's address.\n     * @return The packed allowance details.\n     */\n    function allowance(address user, address token, address spender) external view returns (PackedAllowance memory);\n\n    /**\n     * @notice Approves the spender to use up to amount of the specified token up until the expiration\n     * @param token The token to approve\n     * @param spender The spender address to approve\n     * @param amount The approved amount of the token\n     * @param expiration The timestamp at which the approval is no longer valid\n     * @dev The packed allowance also holds a nonce, which will stay unchanged in approve\n     * @dev Setting amount to type(uint160).max sets an unlimited approval\n     */\n    function approve(address token, address spender, uint160 amount, uint48 expiration) external;\n}\n"
    },
    "lib/@1inch/solidity-utils/contracts/interfaces/IERC7597Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title IERC7597Permit\n * @dev A new extension for ERC-2612 permit, which has already been added to USDC v2.2.\n */\ninterface IERC7597Permit {\n    /**\n     * @notice Update allowance with a signed permit.\n     * @dev Signature bytes can be used for both EOA wallets and contract wallets.\n     * @param owner Token owner's address (Authorizer).\n     * @param spender Spender's address.\n     * @param value Amount of allowance.\n     * @param deadline The time at which the signature expires (unixtime).\n     * @param signature Unstructured bytes signature signed by an EOA wallet or a contract wallet.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        bytes memory signature\n    ) external;\n}\n"
    },
    "lib/@1inch/solidity-utils/contracts/interfaces/IWETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title IWETH\n * @dev Interface for wrapper as WETH-like token.\n */\ninterface IWETH is IERC20 {\n    /**\n     * @notice Emitted when Ether is deposited to get wrapper tokens.\n     */\n    event Deposit(address indexed dst, uint256 wad);\n\n    /**\n     * @notice Emitted when wrapper tokens is withdrawn as Ether.\n     */\n    event Withdrawal(address indexed src, uint256 wad);\n\n    /**\n     * @notice Deposit Ether to get wrapper tokens.\n     */\n    function deposit() external payable;\n\n    /**\n     * @notice Withdraw wrapped tokens as Ether.\n     * @param amount Amount of wrapped tokens to withdraw.\n     */\n    function withdraw(uint256 amount) external;\n}\n"
    },
    "lib/@1inch/solidity-utils/contracts/libraries/RevertReasonForwarder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title RevertReasonForwarder\n * @notice Provides utilities for forwarding and retrieving revert reasons from failed external calls.\n */\nlibrary RevertReasonForwarder {\n    /**\n     * @dev Forwards the revert reason from the latest external call.\n     * This method allows propagating the revert reason of a failed external call to the caller.\n     */\n    function reRevert() internal pure {\n        // bubble up revert reason from latest external call\n        assembly (\"memory-safe\") { // solhint-disable-line no-inline-assembly\n            let ptr := mload(0x40)\n            returndatacopy(ptr, 0, returndatasize())\n            revert(ptr, returndatasize())\n        }\n    }\n\n    /**\n     * @dev Retrieves the revert reason from the latest external call.\n     * This method enables capturing the revert reason of a failed external call for inspection or processing.\n     * @return reason The latest external call revert reason.\n     */\n    function reReason() internal pure returns (bytes memory reason) {\n        assembly (\"memory-safe\") { // solhint-disable-line no-inline-assembly\n            reason := mload(0x40)\n            let length := returndatasize()\n            mstore(reason, length)\n            returndatacopy(add(reason, 0x20), 0, length)\n            mstore(0x40, add(reason, add(0x20, length)))\n        }\n    }\n}\n"
    },
    "lib/@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "lib/@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }\n}\n"
    },
    "lib/@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV // Deprecated in v4.8\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\")\n            mstore(0x1c, hash)\n            message := keccak256(0x00, 0x3c)\n        }\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, \"\\x19\\x01\")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            data := keccak256(ptr, 0x42)\n        }\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Data with intended validator, created from a\n     * `validator` and `data` according to the version 0 of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x00\", validator, data));\n    }\n}\n"
    },
    "lib/@openzeppelin/contracts/utils/cryptography/EIP712.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/EIP712.sol)\n\npragma solidity ^0.8.8;\n\nimport \"./ECDSA.sol\";\nimport \"../ShortStrings.sol\";\nimport \"../../interfaces/IERC5267.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * NOTE: In the upgradeable version of this contract, the cached values will correspond to the address, and the domain\n * separator of the implementation contract. This will cause the `_domainSeparatorV4` function to always rebuild the\n * separator from the immutable values, which is cheaper than accessing a cached version in cold storage.\n *\n * _Available since v3.4._\n *\n * @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\n */\nabstract contract EIP712 is IERC5267 {\n    using ShortStrings for *;\n\n    bytes32 private constant _TYPE_HASH =\n        keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _cachedDomainSeparator;\n    uint256 private immutable _cachedChainId;\n    address private immutable _cachedThis;\n\n    bytes32 private immutable _hashedName;\n    bytes32 private immutable _hashedVersion;\n\n    ShortString private immutable _name;\n    ShortString private immutable _version;\n    string private _nameFallback;\n    string private _versionFallback;\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n        _name = name.toShortStringWithFallback(_nameFallback);\n        _version = version.toShortStringWithFallback(_versionFallback);\n        _hashedName = keccak256(bytes(name));\n        _hashedVersion = keccak256(bytes(version));\n\n        _cachedChainId = block.chainid;\n        _cachedDomainSeparator = _buildDomainSeparator();\n        _cachedThis = address(this);\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (address(this) == _cachedThis && block.chainid == _cachedChainId) {\n            return _cachedDomainSeparator;\n        } else {\n            return _buildDomainSeparator();\n        }\n    }\n\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(_TYPE_HASH, _hashedName, _hashedVersion, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n\n    /**\n     * @dev See {EIP-5267}.\n     *\n     * _Available since v4.9._\n     */\n    function eip712Domain()\n        public\n        view\n        virtual\n        override\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        return (\n            hex\"0f\", // 01111\n            _name.toStringWithFallback(_nameFallback),\n            _version.toStringWithFallback(_versionFallback),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n}\n"
    },
    "lib/@openzeppelin/contracts/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "lib/@gearbox-protocol/core-v3/contracts/interfaces/base/IContractsRegisterTrait.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Foundation, 2024.\npragma solidity ^0.8.17;\n\ninterface IContractsRegisterTrait {\n    function contractsRegister() external view returns (address);\n}\n"
    },
    "lib/@gearbox-protocol/core-v3/contracts/interfaces/base/IContractsRegister.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Foundation, 2024.\npragma solidity ^0.8.17;\n\ninterface IContractsRegister {\n    function isPool(address) external view returns (bool);\n    function getPools() external view returns (address[] memory);\n    function isCreditManager(address) external view returns (bool);\n    function getCreditManagers() external view returns (address[] memory);\n}\n"
    },
    "lib/@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\nimport \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value))));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "lib/@openzeppelin/contracts/utils/ShortStrings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/ShortStrings.sol)\n\npragma solidity ^0.8.8;\n\nimport \"./StorageSlot.sol\";\n\n// | string  | 0xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA   |\n// | length  | 0x                                                              BB |\ntype ShortString is bytes32;\n\n/**\n * @dev This library provides functions to convert short memory strings\n * into a `ShortString` type that can be used as an immutable variable.\n *\n * Strings of arbitrary length can be optimized using this library if\n * they are short enough (up to 31 bytes) by packing them with their\n * length (1 byte) in a single EVM word (32 bytes). Additionally, a\n * fallback mechanism can be used for every other case.\n *\n * Usage example:\n *\n * ```solidity\n * contract Named {\n *     using ShortStrings for *;\n *\n *     ShortString private immutable _name;\n *     string private _nameFallback;\n *\n *     constructor(string memory contractName) {\n *         _name = contractName.toShortStringWithFallback(_nameFallback);\n *     }\n *\n *     function name() external view returns (string memory) {\n *         return _name.toStringWithFallback(_nameFallback);\n *     }\n * }\n * ```\n */\nlibrary ShortStrings {\n    // Used as an identifier for strings longer than 31 bytes.\n    bytes32 private constant _FALLBACK_SENTINEL = 0x00000000000000000000000000000000000000000000000000000000000000FF;\n\n    error StringTooLong(string str);\n    error InvalidShortString();\n\n    /**\n     * @dev Encode a string of at most 31 chars into a `ShortString`.\n     *\n     * This will trigger a `StringTooLong` error is the input string is too long.\n     */\n    function toShortString(string memory str) internal pure returns (ShortString) {\n        bytes memory bstr = bytes(str);\n        if (bstr.length > 31) {\n            revert StringTooLong(str);\n        }\n        return ShortString.wrap(bytes32(uint256(bytes32(bstr)) | bstr.length));\n    }\n\n    /**\n     * @dev Decode a `ShortString` back to a \"normal\" string.\n     */\n    function toString(ShortString sstr) internal pure returns (string memory) {\n        uint256 len = byteLength(sstr);\n        // using `new string(len)` would work locally but is not memory safe.\n        string memory str = new string(32);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(str, len)\n            mstore(add(str, 0x20), sstr)\n        }\n        return str;\n    }\n\n    /**\n     * @dev Return the length of a `ShortString`.\n     */\n    function byteLength(ShortString sstr) internal pure returns (uint256) {\n        uint256 result = uint256(ShortString.unwrap(sstr)) & 0xFF;\n        if (result > 31) {\n            revert InvalidShortString();\n        }\n        return result;\n    }\n\n    /**\n     * @dev Encode a string into a `ShortString`, or write it to storage if it is too long.\n     */\n    function toShortStringWithFallback(string memory value, string storage store) internal returns (ShortString) {\n        if (bytes(value).length < 32) {\n            return toShortString(value);\n        } else {\n            StorageSlot.getStringSlot(store).value = value;\n            return ShortString.wrap(_FALLBACK_SENTINEL);\n        }\n    }\n\n    /**\n     * @dev Decode a string that was encoded to `ShortString` or written to storage using {setWithFallback}.\n     */\n    function toStringWithFallback(ShortString value, string storage store) internal pure returns (string memory) {\n        if (ShortString.unwrap(value) != _FALLBACK_SENTINEL) {\n            return toString(value);\n        } else {\n            return store;\n        }\n    }\n\n    /**\n     * @dev Return the length of a string that was encoded to `ShortString` or written to storage using {setWithFallback}.\n     *\n     * WARNING: This will return the \"byte length\" of the string. This may not reflect the actual length in terms of\n     * actual characters as the UTF-8 encoding of a single character can span over multiple bytes.\n     */\n    function byteLengthWithFallback(ShortString value, string storage store) internal view returns (uint256) {\n        if (ShortString.unwrap(value) != _FALLBACK_SENTINEL) {\n            return byteLength(value);\n        } else {\n            return bytes(store).length;\n        }\n    }\n}\n"
    },
    "lib/@openzeppelin/contracts/interfaces/IERC5267.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC5267.sol)\n\npragma solidity ^0.8.0;\n\ninterface IERC5267 {\n    /**\n     * @dev MAY be emitted to signal that the domain could have changed.\n     */\n    event EIP712DomainChanged();\n\n    /**\n     * @dev returns the fields and values that describe the domain separator used by this contract for EIP-712\n     * signature.\n     */\n    function eip712Domain()\n        external\n        view\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        );\n}\n"
    },
    "lib/@openzeppelin/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "lib/@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, `uint256`._\n * _Available since v4.9 for `string`, `bytes`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "remappings": [
      "ds-test/=lib/forge-std/lib/ds-test/src/",
      "forge-std/=lib/forge-std/src/",
      "@openzeppelin/=lib/@openzeppelin/",
      "@1inch/=lib/@1inch/",
      "@chainlink/=node_modules/@chainlink/",
      "@gearbox-protocol/=lib/@gearbox-protocol/",
      "@redstone-finance/=node_modules/@redstone-finance/",
      "@solady/=lib/@gearbox-protocol/oracles-v3/lib/@solady/src/",
      "erc4626-tests/=lib/@openzeppelin/lib/erc4626-tests/",
      "openzeppelin/=lib/@openzeppelin/contracts/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 1000
    },
    "metadata": {
      "useLiteralContent": false,
      "bytecodeHash": "ipfs",
      "appendCBOR": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "evmVersion": "shanghai",
    "viaIR": false,
    "libraries": {}
  }
}}