{{
  "language": "Solidity",
  "sources": {
    "@synthetixio/core-contracts/contracts/errors/AccessError.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.11 <0.9.0;\n\n/**\n * @title Library for access related errors.\n */\nlibrary AccessError {\n    /**\n     * @dev Thrown when an address tries to perform an unauthorized action.\n     * @param addr The address that attempts the action.\n     */\n    error Unauthorized(address addr);\n}\n"
    },
    "@synthetixio/core-contracts/contracts/errors/AddressError.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.11 <0.9.0;\n\n/**\n * @title Library for address related errors.\n */\nlibrary AddressError {\n    /**\n     * @dev Thrown when a zero address was passed as a function parameter (0x0000000000000000000000000000000000000000).\n     */\n    error ZeroAddress();\n\n    /**\n     * @dev Thrown when an address representing a contract is expected, but no code is found at the address.\n     * @param contr The address that was expected to be a contract.\n     */\n    error NotAContract(address contr);\n}\n"
    },
    "@synthetixio/core-contracts/contracts/errors/ChangeError.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.11 <0.9.0;\n\n/**\n * @title Library for change related errors.\n */\nlibrary ChangeError {\n    /**\n     * @dev Thrown when a change is expected but none is detected.\n     */\n    error NoChange();\n}\n"
    },
    "@synthetixio/core-contracts/contracts/errors/ParameterError.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.11 <0.9.0;\n\n/**\n * @title Library for errors related with expected function parameters.\n */\nlibrary ParameterError {\n    /**\n     * @dev Thrown when an invalid parameter is used in a function.\n     * @param parameter The name of the parameter.\n     * @param reason The reason why the received parameter is invalid.\n     */\n    error InvalidParameter(string parameter, string reason);\n}\n"
    },
    "@synthetixio/core-contracts/contracts/interfaces/IERC165.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.11 <0.9.0;\n\n/**\n * @title ERC165 interface for determining if a contract supports a given interface.\n */\ninterface IERC165 {\n    /**\n     * @notice Determines if the contract in question supports the specified interface.\n     * @param interfaceID XOR of all selectors in the contract.\n     * @return True if the contract supports the specified interface.\n     */\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\n}\n"
    },
    "@synthetixio/core-contracts/contracts/interfaces/IERC20.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.11 <0.9.0;\n\n/**\n * @title ERC20 token implementation.\n */\ninterface IERC20 {\n    /**\n     * @notice Emitted when tokens have been transferred.\n     * @param from The address that originally owned the tokens.\n     * @param to The address that received the tokens.\n     * @param amount The number of tokens that were transferred.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    /**\n     * @notice Emitted when a user has provided allowance to another user for transferring tokens on its behalf.\n     * @param owner The address that is providing the allowance.\n     * @param spender The address that received the allowance.\n     * @param amount The number of tokens that were added to `spender`'s allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /**\n     * @notice Thrown when the address interacting with the contract does not have sufficient allowance to transfer tokens from another contract.\n     * @param required The necessary allowance.\n     * @param existing The current allowance.\n     */\n    error InsufficientAllowance(uint256 required, uint256 existing);\n\n    /**\n     * @notice Thrown when the address interacting with the contract does not have sufficient tokens.\n     * @param required The necessary balance.\n     * @param existing The current balance.\n     */\n    error InsufficientBalance(uint256 required, uint256 existing);\n\n    /**\n     * @notice Retrieves the name of the token, e.g. \"Synthetix Network Token\".\n     * @return A string with the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @notice Retrieves the symbol of the token, e.g. \"SNX\".\n     * @return A string with the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @notice Retrieves the number of decimals used by the token. The default is 18.\n     * @return The number of decimals.\n     */\n    function decimals() external view returns (uint8);\n\n    /**\n     * @notice Returns the total number of tokens in circulation (minted - burnt).\n     * @return The total number of tokens.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @notice Returns the balance of a user.\n     * @param owner The address whose balance is being retrieved.\n     * @return The number of tokens owned by the user.\n     */\n    function balanceOf(address owner) external view returns (uint256);\n\n    /**\n     * @notice Returns how many tokens a user has allowed another user to transfer on its behalf.\n     * @param owner The user who has given the allowance.\n     * @param spender The user who was given the allowance.\n     * @return The amount of tokens `spender` can transfer on `owner`'s behalf.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @notice Transfer tokens from one address to another.\n     * @param to The address that will receive the tokens.\n     * @param amount The amount of tokens to be transferred.\n     * @return A boolean which is true if the operation succeeded.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @notice Allows users to provide allowance to other users so that they can transfer tokens on their behalf.\n     * @param spender The address that is receiving the allowance.\n     * @param amount The amount of tokens that are being added to the allowance.\n     * @return A boolean which is true if the operation succeeded.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @notice Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\n\n    /**\n     * @notice Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\n\n    /**\n     * @notice Allows a user who has been given allowance to transfer tokens on another user's behalf.\n     * @param from The address that owns the tokens that are being transferred.\n     * @param to The address that will receive the tokens.\n     * @param amount The number of tokens to transfer.\n     * @return A boolean which is true if the operation succeeded.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@synthetixio/core-contracts/contracts/interfaces/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.11 <0.9.0;\n\n/**\n * @title ERC721 non-fungible token (NFT) contract.\n */\ninterface IERC721 {\n    /**\n     * @notice Thrown when an address attempts to provide allowance to itself.\n     * @param addr The address attempting to provide allowance.\n     */\n    error CannotSelfApprove(address addr);\n\n    /**\n     * @notice Thrown when attempting to transfer a token to an address that does not satisfy IERC721Receiver requirements.\n     * @param addr The address that cannot receive the tokens.\n     */\n    error InvalidTransferRecipient(address addr);\n\n    /**\n     * @notice Thrown when attempting to specify an owner which is not valid (ex. the 0x00000... address)\n     */\n    error InvalidOwner(address addr);\n\n    /**\n     * @notice Thrown when attempting to operate on a token id that does not exist.\n     * @param id The token id that does not exist.\n     */\n    error TokenDoesNotExist(uint256 id);\n\n    /**\n     * @notice Thrown when attempting to mint a token that already exists.\n     * @param id The token id that already exists.\n     */\n    error TokenAlreadyMinted(uint256 id);\n\n    /**\n     * @notice Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @notice Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @notice Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @notice Returns the number of tokens in ``owner``'s account.\n     *\n     * Requirements:\n     *\n     * - `holder` must be a valid address\n     */\n    function balanceOf(address holder) external view returns (uint256 balance);\n\n    /**\n     * @notice Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @notice Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @notice Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @notice Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @notice Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @notice Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @notice Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @notice Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@synthetixio/core-contracts/contracts/interfaces/IERC721Receiver.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.11 <0.9.0;\n\n/**\n * @title ERC721 extension that allows contracts to receive tokens with `safeTransferFrom`.\n */\ninterface IERC721Receiver {\n    /**\n     * @notice Function that will be called by ERC721 tokens implementing the `safeTransferFrom` function.\n     * @dev The contract transferring the token will revert if the receiving contract does not implement this function.\n     * @param operator The address that is executing the transfer.\n     * @param from The address whose token is being transferred.\n     * @param tokenId The numeric id of the token being transferred.\n     * @param data Optional additional data that may be passed by the operator, and could be used by the implementing contract.\n     * @return The selector of this function (IERC721Receiver.onERC721Received.selector). Caller will revert if not returned.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes memory data\n    ) external returns (bytes4);\n}\n"
    },
    "@synthetixio/core-contracts/contracts/interfaces/IOwnable.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.11 <0.9.0;\n\n/**\n * @title Contract for facilitating ownership by a single address.\n */\ninterface IOwnable {\n    /**\n     * @notice Thrown when an address tries to accept ownership but has not been nominated.\n     * @param addr The address that is trying to accept ownership.\n     */\n    error NotNominated(address addr);\n\n    /**\n     * @notice Emitted when an address has been nominated.\n     * @param newOwner The address that has been nominated.\n     */\n    event OwnerNominated(address newOwner);\n\n    /**\n     * @notice Emitted when the owner of the contract has changed.\n     * @param oldOwner The previous owner of the contract.\n     * @param newOwner The new owner of the contract.\n     */\n    event OwnerChanged(address oldOwner, address newOwner);\n\n    /**\n     * @notice Allows a nominated address to accept ownership of the contract.\n     * @dev Reverts if the caller is not nominated.\n     */\n    function acceptOwnership() external;\n\n    /**\n     * @notice Allows the current owner to nominate a new owner.\n     * @dev The nominated owner will have to call `acceptOwnership` in a separate transaction in order to finalize the action and become the new contract owner.\n     * @param newNominatedOwner The address that is to become nominated.\n     */\n    function nominateNewOwner(address newNominatedOwner) external;\n\n    /**\n     * @notice Allows a nominated owner to reject the nomination.\n     */\n    function renounceNomination() external;\n\n    /**\n     * @notice Returns the current owner of the contract.\n     */\n    function owner() external view returns (address);\n\n    /**\n     * @notice Returns the current nominated owner of the contract.\n     * @dev Only one address can be nominated at a time.\n     */\n    function nominatedOwner() external view returns (address);\n}\n"
    },
    "@synthetixio/core-contracts/contracts/interfaces/IUUPSImplementation.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.11 <0.9.0;\n\n/**\n * @title Contract to be used as the implementation of a Universal Upgradeable Proxy Standard (UUPS) proxy.\n *\n * Important: A UUPS proxy requires its upgradeability functions to be in the implementation as opposed to the proxy. This means that if the proxy is upgraded to an implementation that does not support this interface, it will no longer be upgradeable.\n */\ninterface IUUPSImplementation {\n    /**\n     * @notice Thrown when an incoming implementation will not be able to receive future upgrades.\n     */\n    error ImplementationIsSterile(address implementation);\n\n    /**\n     * @notice Thrown intentionally when testing future upgradeability of an implementation.\n     */\n    error UpgradeSimulationFailed();\n\n    /**\n     * @notice Emitted when the implementation of the proxy has been upgraded.\n     * @param self The address of the proxy whose implementation was upgraded.\n     * @param implementation The address of the proxy's new implementation.\n     */\n    event Upgraded(address indexed self, address implementation);\n\n    /**\n     * @notice Allows the proxy to be upgraded to a new implementation.\n     * @param newImplementation The address of the proxy's new implementation.\n     * @dev Will revert if `newImplementation` is not upgradeable.\n     * @dev The implementation of this function needs to be protected by some sort of access control such as `onlyOwner`.\n     */\n    function upgradeTo(address newImplementation) external;\n\n    /**\n     * @notice Function used to determine if a new implementation will be able to receive future upgrades in `upgradeTo`.\n     * @param newImplementation The address of the new implementation being tested for future upgradeability.\n     * @dev This function will always revert, but will revert with different error messages. The function `upgradeTo` uses this error to determine the future upgradeability of the implementation in question.\n     */\n    function simulateUpgradeTo(address newImplementation) external;\n\n    /**\n     * @notice Retrieves the current implementation of the proxy.\n     * @return The address of the current implementation.\n     */\n    function getImplementation() external view returns (address);\n}\n"
    },
    "@synthetixio/core-contracts/contracts/ownership/Ownable.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.11 <0.9.0;\n\nimport \"./OwnableStorage.sol\";\nimport \"../interfaces/IOwnable.sol\";\nimport \"../errors/AddressError.sol\";\nimport \"../errors/ChangeError.sol\";\n\n/**\n * @title Contract for facilitating ownership by a single address.\n * See IOwnable.\n */\ncontract Ownable is IOwnable {\n    constructor(address initialOwner) {\n        OwnableStorage.load().owner = initialOwner;\n    }\n\n    /**\n     * @inheritdoc IOwnable\n     */\n    function acceptOwnership() public override {\n        OwnableStorage.Data storage store = OwnableStorage.load();\n\n        address currentNominatedOwner = store.nominatedOwner;\n        if (msg.sender != currentNominatedOwner) {\n            revert NotNominated(msg.sender);\n        }\n\n        emit OwnerChanged(store.owner, currentNominatedOwner);\n        store.owner = currentNominatedOwner;\n\n        store.nominatedOwner = address(0);\n    }\n\n    /**\n     * @inheritdoc IOwnable\n     */\n    function nominateNewOwner(address newNominatedOwner) public override onlyOwner {\n        OwnableStorage.Data storage store = OwnableStorage.load();\n\n        if (newNominatedOwner == address(0)) {\n            revert AddressError.ZeroAddress();\n        }\n\n        if (newNominatedOwner == store.nominatedOwner) {\n            revert ChangeError.NoChange();\n        }\n\n        store.nominatedOwner = newNominatedOwner;\n        emit OwnerNominated(newNominatedOwner);\n    }\n\n    /**\n     * @inheritdoc IOwnable\n     */\n    function renounceNomination() external override {\n        OwnableStorage.Data storage store = OwnableStorage.load();\n\n        if (store.nominatedOwner != msg.sender) {\n            revert NotNominated(msg.sender);\n        }\n\n        store.nominatedOwner = address(0);\n    }\n\n    /**\n     * @inheritdoc IOwnable\n     */\n    function owner() external view override returns (address) {\n        return OwnableStorage.load().owner;\n    }\n\n    /**\n     * @inheritdoc IOwnable\n     */\n    function nominatedOwner() external view override returns (address) {\n        return OwnableStorage.load().nominatedOwner;\n    }\n\n    /**\n     * @dev Reverts if the caller is not the owner.\n     */\n    modifier onlyOwner() {\n        OwnableStorage.onlyOwner();\n\n        _;\n    }\n}\n"
    },
    "@synthetixio/core-contracts/contracts/ownership/OwnableStorage.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.11 <0.9.0;\n\nimport \"../errors/AccessError.sol\";\n\nlibrary OwnableStorage {\n    bytes32 private constant _SLOT_OWNABLE_STORAGE =\n        keccak256(abi.encode(\"io.synthetix.core-contracts.Ownable\"));\n\n    struct Data {\n        address owner;\n        address nominatedOwner;\n    }\n\n    function load() internal pure returns (Data storage store) {\n        bytes32 s = _SLOT_OWNABLE_STORAGE;\n        assembly {\n            store.slot := s\n        }\n    }\n\n    function onlyOwner() internal view {\n        if (msg.sender != getOwner()) {\n            revert AccessError.Unauthorized(msg.sender);\n        }\n    }\n\n    function getOwner() internal view returns (address) {\n        return OwnableStorage.load().owner;\n    }\n}\n"
    },
    "@synthetixio/core-contracts/contracts/proxy/ProxyStorage.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.11 <0.9.0;\n\ncontract ProxyStorage {\n    bytes32 private constant _SLOT_PROXY_STORAGE =\n        keccak256(abi.encode(\"io.synthetix.core-contracts.Proxy\"));\n\n    struct ProxyStore {\n        address implementation;\n        bool simulatingUpgrade;\n    }\n\n    function _proxyStore() internal pure returns (ProxyStore storage store) {\n        bytes32 s = _SLOT_PROXY_STORAGE;\n        assembly {\n            store.slot := s\n        }\n    }\n}\n"
    },
    "@synthetixio/core-contracts/contracts/proxy/UUPSImplementation.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.11 <0.9.0;\n\nimport \"../interfaces/IUUPSImplementation.sol\";\nimport \"../errors/AddressError.sol\";\nimport \"../errors/ChangeError.sol\";\nimport \"../utils/AddressUtil.sol\";\nimport \"./ProxyStorage.sol\";\n\nabstract contract UUPSImplementation is IUUPSImplementation, ProxyStorage {\n    /**\n     * @inheritdoc IUUPSImplementation\n     */\n    function simulateUpgradeTo(address newImplementation) public override {\n        ProxyStore storage store = _proxyStore();\n\n        store.simulatingUpgrade = true;\n\n        address currentImplementation = store.implementation;\n        store.implementation = newImplementation;\n\n        (bool rollbackSuccessful, ) = newImplementation.delegatecall(\n            abi.encodeCall(this.upgradeTo, (currentImplementation))\n        );\n\n        if (!rollbackSuccessful || _proxyStore().implementation != currentImplementation) {\n            revert UpgradeSimulationFailed();\n        }\n\n        store.simulatingUpgrade = false;\n\n        // solhint-disable-next-line reason-string\n        revert();\n    }\n\n    /**\n     * @inheritdoc IUUPSImplementation\n     */\n    function getImplementation() external view override returns (address) {\n        return _proxyStore().implementation;\n    }\n\n    function _upgradeTo(address newImplementation) internal virtual {\n        if (newImplementation == address(0)) {\n            revert AddressError.ZeroAddress();\n        }\n\n        if (!AddressUtil.isContract(newImplementation)) {\n            revert AddressError.NotAContract(newImplementation);\n        }\n\n        ProxyStore storage store = _proxyStore();\n\n        if (newImplementation == store.implementation) {\n            revert ChangeError.NoChange();\n        }\n\n        if (!store.simulatingUpgrade && _implementationIsSterile(newImplementation)) {\n            revert ImplementationIsSterile(newImplementation);\n        }\n\n        store.implementation = newImplementation;\n\n        emit Upgraded(address(this), newImplementation);\n    }\n\n    function _implementationIsSterile(\n        address candidateImplementation\n    ) internal virtual returns (bool) {\n        (bool simulationReverted, bytes memory simulationResponse) = address(this).delegatecall(\n            abi.encodeCall(this.simulateUpgradeTo, (candidateImplementation))\n        );\n\n        return\n            !simulationReverted &&\n            keccak256(abi.encodePacked(simulationResponse)) ==\n            keccak256(abi.encodePacked(UpgradeSimulationFailed.selector));\n    }\n}\n"
    },
    "@synthetixio/core-contracts/contracts/utils/AddressUtil.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.11 <0.9.0;\n\nlibrary AddressUtil {\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n\n        assembly {\n            size := extcodesize(account)\n        }\n\n        return size > 0;\n    }\n}\n"
    },
    "@synthetixio/core-contracts/contracts/utils/DecimalMath.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.11 <0.9.0;\n\nimport \"./SafeCast.sol\";\n\n/**\n * @title Utility library used to represent \"decimals\" (fixed point numbers) with integers, with two different levels of precision.\n *\n * They are represented by N * UNIT, where UNIT is the number of decimals of precision in the representation.\n *\n * Examples:\n * 1) Given UNIT = 100\n * then if A = 50, A represents the decimal 0.50\n * 2) Given UNIT = 1000000000000000000\n * then if A = 500000000000000000, A represents the decimal 0.500000000000000000\n *\n * Note: An accompanying naming convention of the postfix \"D<Precision>\" is helpful with this utility. I.e. if a variable \"myValue\" represents a low resolution decimal, it should be named \"myValueD18\", and if it was a high resolution decimal \"myValueD27\". While scaling, intermediate precision decimals like \"myValue45\" could arise. Non-decimals should have no postfix, i.e. just \"myValue\".\n *\n * Important: Multiplication and division operations are currently not supported for high precision decimals. Using these operations on them will yield incorrect results and fail silently.\n */\nlibrary DecimalMath {\n    using SafeCastU256 for uint256;\n    using SafeCastI256 for int256;\n\n    // solhint-disable numcast/safe-cast\n\n    // Numbers representing 1.0 (low precision).\n    uint256 public constant UNIT = 1e18;\n    int256 public constant UNIT_INT = int256(UNIT);\n    uint128 public constant UNIT_UINT128 = uint128(UNIT);\n    int128 public constant UNIT_INT128 = int128(UNIT_INT);\n\n    // Numbers representing 1.0 (high precision).\n    uint256 public constant UNIT_PRECISE = 1e27;\n    int256 public constant UNIT_PRECISE_INT = int256(UNIT_PRECISE);\n    int128 public constant UNIT_PRECISE_INT128 = int128(UNIT_PRECISE_INT);\n\n    // Precision scaling, (used to scale down/up from one precision to the other).\n    uint256 public constant PRECISION_FACTOR = 9; // 27 - 18 = 9 :)\n\n    // solhint-enable numcast/safe-cast\n\n    // -----------------\n    // uint256\n    // -----------------\n\n    /**\n     * @dev Multiplies two low precision decimals.\n     *\n     * Since the two numbers are assumed to be fixed point numbers,\n     * (x * UNIT) * (y * UNIT) = x * y * UNIT ^ 2,\n     * the result is divided by UNIT to remove double scaling.\n     */\n    function mulDecimal(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        return (x * y) / UNIT;\n    }\n\n    /**\n     * @dev Divides two low precision decimals.\n     *\n     * Since the two numbers are assumed to be fixed point numbers,\n     * (x * UNIT) / (y * UNIT) = x / y (Decimal representation is lost),\n     * x is first scaled up to end up with a decimal representation.\n     */\n    function divDecimal(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        return (x * UNIT) / y;\n    }\n\n    /**\n     * @dev Scales up a value.\n     *\n     * E.g. if value is not a decimal, a scale up by 18 makes it a low precision decimal.\n     * If value is a low precision decimal, a scale up by 9 makes it a high precision decimal.\n     */\n    function upscale(uint256 x, uint256 factor) internal pure returns (uint256) {\n        return x * 10 ** factor;\n    }\n\n    /**\n     * @dev Scales down a value.\n     *\n     * E.g. if value is a high precision decimal, a scale down by 9 makes it a low precision decimal.\n     * If value is a low precision decimal, a scale down by 9 makes it a regular integer.\n     *\n     * Scaling down a regular integer would not make sense.\n     */\n    function downscale(uint256 x, uint256 factor) internal pure returns (uint256) {\n        return x / 10 ** factor;\n    }\n\n    // -----------------\n    // uint128\n    // -----------------\n\n    // Note: Overloading doesn't seem to work for similar types, i.e. int256 and int128, uint256 and uint128, etc, so explicitly naming the functions differently here.\n\n    /**\n     * @dev See mulDecimal for uint256.\n     */\n    function mulDecimalUint128(uint128 x, uint128 y) internal pure returns (uint128) {\n        return (x * y) / UNIT_UINT128;\n    }\n\n    /**\n     * @dev See divDecimal for uint256.\n     */\n    function divDecimalUint128(uint128 x, uint128 y) internal pure returns (uint128) {\n        return (x * UNIT_UINT128) / y;\n    }\n\n    /**\n     * @dev See upscale for uint256.\n     */\n    function upscaleUint128(uint128 x, uint256 factor) internal pure returns (uint128) {\n        return x * (10 ** factor).to128();\n    }\n\n    /**\n     * @dev See downscale for uint256.\n     */\n    function downscaleUint128(uint128 x, uint256 factor) internal pure returns (uint128) {\n        return x / (10 ** factor).to128();\n    }\n\n    // -----------------\n    // int256\n    // -----------------\n\n    /**\n     * @dev See mulDecimal for uint256.\n     */\n    function mulDecimal(int256 x, int256 y) internal pure returns (int256) {\n        return (x * y) / UNIT_INT;\n    }\n\n    /**\n     * @dev See divDecimal for uint256.\n     */\n    function divDecimal(int256 x, int256 y) internal pure returns (int256) {\n        return (x * UNIT_INT) / y;\n    }\n\n    /**\n     * @dev See upscale for uint256.\n     */\n    function upscale(int256 x, uint256 factor) internal pure returns (int256) {\n        return x * (10 ** factor).toInt();\n    }\n\n    /**\n     * @dev See downscale for uint256.\n     */\n    function downscale(int256 x, uint256 factor) internal pure returns (int256) {\n        return x / (10 ** factor).toInt();\n    }\n\n    // -----------------\n    // int128\n    // -----------------\n\n    /**\n     * @dev See mulDecimal for uint256.\n     */\n    function mulDecimalInt128(int128 x, int128 y) internal pure returns (int128) {\n        return (x * y) / UNIT_INT128;\n    }\n\n    /**\n     * @dev See divDecimal for uint256.\n     */\n    function divDecimalInt128(int128 x, int128 y) internal pure returns (int128) {\n        return (x * UNIT_INT128) / y;\n    }\n\n    /**\n     * @dev See upscale for uint256.\n     */\n    function upscaleInt128(int128 x, uint256 factor) internal pure returns (int128) {\n        return x * ((10 ** factor).toInt()).to128();\n    }\n\n    /**\n     * @dev See downscale for uint256.\n     */\n    function downscaleInt128(int128 x, uint256 factor) internal pure returns (int128) {\n        return x / ((10 ** factor).toInt().to128());\n    }\n}\n"
    },
    "@synthetixio/core-contracts/contracts/utils/ERC2771Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/* solhint-disable meta-transactions/no-msg-sender */\n/* solhint-disable meta-transactions/no-msg-data */\n\nlibrary ERC2771Context {\n    // This is the trusted-multicall-forwarder. The address is constant due to CREATE2.\n    address private constant TRUSTED_FORWARDER = 0xE2C5658cC5C448B48141168f3e475dF8f65A1e3e;\n\n    function _msgSender() internal view returns (address sender) {\n        if (isTrustedForwarder(msg.sender) && msg.data.length >= 20) {\n            // The assembly code is more direct than the Solidity version using `abi.decode`.\n            /// @solidity memory-safe-assembly\n            assembly {\n                sender := shr(96, calldataload(sub(calldatasize(), 20)))\n            }\n        } else {\n            return msg.sender;\n        }\n    }\n\n    function _msgData() internal view returns (bytes calldata) {\n        if (isTrustedForwarder(msg.sender) && msg.data.length >= 20) {\n            return msg.data[:msg.data.length - 20];\n        } else {\n            return msg.data;\n        }\n    }\n\n    function isTrustedForwarder(address forwarder) internal pure returns (bool) {\n        return forwarder == TRUSTED_FORWARDER;\n    }\n\n    function trustedForwarder() internal pure returns (address) {\n        return TRUSTED_FORWARDER;\n    }\n}\n"
    },
    "@synthetixio/core-contracts/contracts/utils/SafeCast.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.11 <0.9.0;\n\n/**\n * Utilities that convert numeric types avoiding silent overflows.\n */\nimport \"./SafeCast/SafeCastU32.sol\";\nimport \"./SafeCast/SafeCastI32.sol\";\nimport \"./SafeCast/SafeCastI24.sol\";\nimport \"./SafeCast/SafeCastU56.sol\";\nimport \"./SafeCast/SafeCastI56.sol\";\nimport \"./SafeCast/SafeCastU64.sol\";\nimport \"./SafeCast/SafeCastI64.sol\";\nimport \"./SafeCast/SafeCastI128.sol\";\nimport \"./SafeCast/SafeCastI256.sol\";\nimport \"./SafeCast/SafeCastU128.sol\";\nimport \"./SafeCast/SafeCastU160.sol\";\nimport \"./SafeCast/SafeCastU256.sol\";\nimport \"./SafeCast/SafeCastAddress.sol\";\nimport \"./SafeCast/SafeCastBytes32.sol\";\n"
    },
    "@synthetixio/core-contracts/contracts/utils/SafeCast/SafeCastAddress.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.11 <0.9.0;\n\n/**\n * @title See SafeCast.sol.\n */\nlibrary SafeCastAddress {\n    function to256(address x) internal pure returns (uint256) {\n        return uint256(uint160(x));\n    }\n\n    function toBytes32(address x) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(x)));\n    }\n}\n"
    },
    "@synthetixio/core-contracts/contracts/utils/SafeCast/SafeCastBytes32.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.11 <0.9.0;\n\n/**\n * @title See SafeCast.sol.\n */\nlibrary SafeCastBytes32 {\n    function toAddress(bytes32 x) internal pure returns (address) {\n        return address(uint160(uint256(x)));\n    }\n\n    function toUint(bytes32 x) internal pure returns (uint) {\n        return uint(x);\n    }\n}\n"
    },
    "@synthetixio/core-contracts/contracts/utils/SafeCast/SafeCastI128.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.11 <0.9.0;\n\n/**\n * @title See SafeCast.sol.\n */\nlibrary SafeCastI128 {\n    error OverflowInt128ToUint128();\n    error OverflowInt128ToInt32();\n\n    function toUint(int128 x) internal pure returns (uint128) {\n        // ----------------<==============o==============>-----------------\n        // ----------------xxxxxxxxxxxxxxxo===============>----------------\n        if (x < 0) {\n            revert OverflowInt128ToUint128();\n        }\n\n        return uint128(x);\n    }\n\n    function to256(int128 x) internal pure returns (int256) {\n        return int256(x);\n    }\n\n    function to32(int128 x) internal pure returns (int32) {\n        // ----------------<==============o==============>-----------------\n        // ----------------xxxxxxxxxxxx<==o==>xxxxxxxxxxxx-----------------\n        if (x < int256(type(int32).min) || x > int256(type(int32).max)) {\n            revert OverflowInt128ToInt32();\n        }\n\n        return int32(x);\n    }\n\n    function zero() internal pure returns (int128) {\n        return int128(0);\n    }\n}\n"
    },
    "@synthetixio/core-contracts/contracts/utils/SafeCast/SafeCastI24.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.11 <0.9.0;\n\n/**\n * @title See SafeCast.sol.\n */\nlibrary SafeCastI24 {\n    function to256(int24 x) internal pure returns (int256) {\n        return int256(x);\n    }\n}\n"
    },
    "@synthetixio/core-contracts/contracts/utils/SafeCast/SafeCastI256.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.11 <0.9.0;\n\n/**\n * @title See SafeCast.sol.\n */\nlibrary SafeCastI256 {\n    error OverflowInt256ToUint256();\n    error OverflowInt256ToInt128();\n    error OverflowInt256ToInt24();\n\n    function to128(int256 x) internal pure returns (int128) {\n        // ----<==========================o===========================>----\n        // ----xxxxxxxxxxxx<==============o==============>xxxxxxxxxxxxx----\n        if (x < int256(type(int128).min) || x > int256(type(int128).max)) {\n            revert OverflowInt256ToInt128();\n        }\n\n        return int128(x);\n    }\n\n    function to24(int256 x) internal pure returns (int24) {\n        // ----<==========================o===========================>----\n        // ----xxxxxxxxxxxxxxxxxxxx<======o=======>xxxxxxxxxxxxxxxxxxxx----\n        if (x < int256(type(int24).min) || x > int256(type(int24).max)) {\n            revert OverflowInt256ToInt24();\n        }\n\n        return int24(x);\n    }\n\n    function toUint(int256 x) internal pure returns (uint256) {\n        // ----<==========================o===========================>----\n        // ----xxxxxxxxxxxxxxxxxxxxxxxxxxxo===============================>\n        if (x < 0) {\n            revert OverflowInt256ToUint256();\n        }\n\n        return uint256(x);\n    }\n\n    function zero() internal pure returns (int256) {\n        return int256(0);\n    }\n}\n"
    },
    "@synthetixio/core-contracts/contracts/utils/SafeCast/SafeCastI32.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.11 <0.9.0;\n\n/**\n * @title See SafeCast.sol.\n */\nlibrary SafeCastI32 {\n    error OverflowInt32ToUint32();\n\n    function toUint(int32 x) internal pure returns (uint32) {\n        // ----------------------<========o========>----------------------\n        // ----------------------xxxxxxxxxo=========>----------------------\n        if (x < 0) {\n            revert OverflowInt32ToUint32();\n        }\n\n        return uint32(x);\n    }\n}\n"
    },
    "@synthetixio/core-contracts/contracts/utils/SafeCast/SafeCastI56.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.11 <0.9.0;\n\n/**\n * @title See SafeCast.sol.\n */\nlibrary SafeCastI56 {\n    error OverflowInt56ToInt24();\n\n    function to24(int56 x) internal pure returns (int24) {\n        // ----------------------<========o========>-----------------------\n        // ----------------------xxx<=====o=====>xxx-----------------------\n        if (x < int256(type(int24).min) || x > int256(type(int24).max)) {\n            revert OverflowInt56ToInt24();\n        }\n\n        return int24(x);\n    }\n}\n"
    },
    "@synthetixio/core-contracts/contracts/utils/SafeCast/SafeCastI64.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.11 <0.9.0;\n\n/**\n * @title See SafeCast.sol.\n */\nlibrary SafeCastI64 {\n    error OverflowInt64ToUint64();\n\n    function toUint(int64 x) internal pure returns (uint64) {\n        // ----------------------<========o========>----------------------\n        // ----------------------xxxxxxxxxo=========>----------------------\n        if (x < 0) {\n            revert OverflowInt64ToUint64();\n        }\n\n        return uint64(x);\n    }\n}\n"
    },
    "@synthetixio/core-contracts/contracts/utils/SafeCast/SafeCastU128.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.11 <0.9.0;\n\n/**\n * @title See SafeCast.sol.\n */\nlibrary SafeCastU128 {\n    error OverflowUint128ToInt128();\n\n    function to256(uint128 x) internal pure returns (uint256) {\n        return uint256(x);\n    }\n\n    function toInt(uint128 x) internal pure returns (int128) {\n        // -------------------------------o===============>----------------\n        // ----------------<==============o==============>x----------------\n        if (x > uint128(type(int128).max)) {\n            revert OverflowUint128ToInt128();\n        }\n\n        return int128(x);\n    }\n\n    function toBytes32(uint128 x) internal pure returns (bytes32) {\n        return bytes32(uint256(x));\n    }\n}\n"
    },
    "@synthetixio/core-contracts/contracts/utils/SafeCast/SafeCastU160.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.11 <0.9.0;\n\n/**\n * @title See SafeCast.sol.\n */\nlibrary SafeCastU160 {\n    function to256(uint160 x) internal pure returns (uint256) {\n        return uint256(x);\n    }\n}\n"
    },
    "@synthetixio/core-contracts/contracts/utils/SafeCast/SafeCastU256.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.11 <0.9.0;\n\n/**\n * @title See SafeCast.sol.\n */\nlibrary SafeCastU256 {\n    error OverflowUint256ToUint128();\n    error OverflowUint256ToInt256();\n    error OverflowUint256ToUint64();\n    error OverflowUint256ToUint32();\n    error OverflowUint256ToUint16();\n    error OverflowUint256ToUint160();\n\n    function to128(uint256 x) internal pure returns (uint128) {\n        // -------------------------------o===============================>\n        // -------------------------------o===============>xxxxxxxxxxxxxxxx\n        if (x > type(uint128).max) {\n            revert OverflowUint256ToUint128();\n        }\n\n        return uint128(x);\n    }\n\n    function to64(uint256 x) internal pure returns (uint64) {\n        // -------------------------------o===============================>\n        // -------------------------------o======>xxxxxxxxxxxxxxxxxxxxxxxxx\n        if (x > type(uint64).max) {\n            revert OverflowUint256ToUint64();\n        }\n\n        return uint64(x);\n    }\n\n    function to32(uint256 x) internal pure returns (uint32) {\n        // -------------------------------o===============================>\n        // -------------------------------o===>xxxxxxxxxxxxxxxxxxxxxxxxxxxx\n        if (x > type(uint32).max) {\n            revert OverflowUint256ToUint32();\n        }\n\n        return uint32(x);\n    }\n\n    function to16(uint256 x) internal pure returns (uint16) {\n        // -------------------------------o===============================>\n        // -------------------------------o==>xxxxxxxxxxxxxxxxxxxxxxxxxxxxx\n        if (x > type(uint16).max) {\n            revert OverflowUint256ToUint16();\n        }\n\n        return uint16(x);\n    }\n\n    function to160(uint256 x) internal pure returns (uint160) {\n        // -------------------------------o===============================>\n        // -------------------------------o==================>xxxxxxxxxxxxx\n        if (x > type(uint160).max) {\n            revert OverflowUint256ToUint160();\n        }\n\n        return uint160(x);\n    }\n\n    function toBytes32(uint256 x) internal pure returns (bytes32) {\n        return bytes32(x);\n    }\n\n    function toInt(uint256 x) internal pure returns (int256) {\n        // -------------------------------o===============================>\n        // ----<==========================o===========================>xxxx\n        if (x > uint256(type(int256).max)) {\n            revert OverflowUint256ToInt256();\n        }\n\n        return int256(x);\n    }\n}\n"
    },
    "@synthetixio/core-contracts/contracts/utils/SafeCast/SafeCastU32.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.11 <0.9.0;\n\n/**\n * @title See SafeCast.sol.\n */\nlibrary SafeCastU32 {\n    error OverflowUint32ToInt32();\n\n    function toInt(uint32 x) internal pure returns (int32) {\n        // -------------------------------o=========>----------------------\n        // ----------------------<========o========>x----------------------\n        if (x > uint32(type(int32).max)) {\n            revert OverflowUint32ToInt32();\n        }\n\n        return int32(x);\n    }\n\n    function to256(uint32 x) internal pure returns (uint256) {\n        return uint256(x);\n    }\n\n    function to56(uint32 x) internal pure returns (uint56) {\n        return uint56(x);\n    }\n}\n"
    },
    "@synthetixio/core-contracts/contracts/utils/SafeCast/SafeCastU56.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.11 <0.9.0;\n\n/**\n * @title See SafeCast.sol.\n */\nlibrary SafeCastU56 {\n    error OverflowUint56ToInt56();\n\n    function toInt(uint56 x) internal pure returns (int56) {\n        // -------------------------------o=========>----------------------\n        // ----------------------<========o========>x----------------------\n        if (x > uint56(type(int56).max)) {\n            revert OverflowUint56ToInt56();\n        }\n\n        return int56(x);\n    }\n}\n"
    },
    "@synthetixio/core-contracts/contracts/utils/SafeCast/SafeCastU64.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.11 <0.9.0;\n\n/**\n * @title See SafeCast.sol.\n */\nlibrary SafeCastU64 {\n    error OverflowUint64ToInt64();\n\n    function toInt(uint64 x) internal pure returns (int64) {\n        // -------------------------------o=========>----------------------\n        // ----------------------<========o========>x----------------------\n        if (x > uint64(type(int64).max)) {\n            revert OverflowUint64ToInt64();\n        }\n\n        return int64(x);\n    }\n\n    function to256(uint64 x) internal pure returns (uint256) {\n        return uint256(x);\n    }\n}\n"
    },
    "@synthetixio/main/contracts/interfaces/external/IMarket.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.11 <0.9.0;\n\nimport \"@synthetixio/core-contracts/contracts/interfaces/IERC165.sol\";\n\n/// @title Interface for markets integrated with Synthetix\ninterface IMarket is IERC165 {\n    /// @notice returns a human-readable name for a given market\n    function name(uint128 marketId) external view returns (string memory);\n\n    /// @notice returns amount of USD that the market would try to mint if everything was withdrawn\n    function reportedDebt(uint128 marketId) external view returns (uint256);\n\n    /// @notice prevents reduction of available credit capacity by specifying this amount, for which withdrawals will be disallowed\n    function minimumCredit(uint128 marketId) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/external/IOracleManagerProxy.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.11 <0.9.0;\n\n/// @title Module for managing nodes\ninterface IOracleManagerProxy {\n    enum NodeType {\n        NONE,\n        REDUCER,\n        EXTERNAL,\n        CHAINLINK,\n        UNISWAP,\n        PYTH,\n        PRICE_DEVIATION_CIRCUIT_BREAKER,\n        STALENESS_CIRCUIT_BREAKER,\n        CONSTANT,\n        PYTH_OFFCHAIN_LOOKUP // works in conjunction with PYTH node\n    }\n\n    struct NodeDefinition {\n        /**\n         * @dev Oracle node type enum\n         */\n        NodeType nodeType;\n        /**\n         * @dev Node parameters, specific to each node type\n         */\n        bytes parameters;\n        /**\n         * @dev Parent node IDs, if any\n         */\n        bytes32[] parents;\n    }\n\n    struct NodeOutput {\n        /**\n         * @dev Price returned from the oracle node, expressed with 18 decimals of precision\n         */\n        int256 price;\n        /**\n         * @dev Timestamp associated with the price\n         */\n        uint256 timestamp;\n        // solhint-disable-next-line private-vars-leading-underscore\n        uint256 __slotAvailableForFutureUse1;\n        // solhint-disable-next-line private-vars-leading-underscore\n        uint256 __slotAvailableForFutureUse2;\n    }\n\n    /**\n     * @notice Thrown when the specified nodeId has not been registered in the system.\n     */\n    error NodeNotRegistered(bytes32 nodeId);\n\n    /**\n     * @notice Thrown when a node is registered without a valid definition.\n     */\n    error InvalidNodeDefinition(NodeDefinition nodeType);\n\n    /**\n     * @notice An array of revert reasons when an array of nodes is processed, but some of the nodes failed\n     */\n    error Errors(bytes[] revertReasons);\n\n    /**\n     * @notice ERC-7412 OracleDataRequired error definition. While not explicitly reverted by NodeModule, its a commonly encountered error that makes it useful to have it declared here\n     */\n    error OracleDataRequired(address oracleContract, bytes oracleQuery);\n\n    /**\n     * @notice Emitted when `registerNode` is called.\n     * @param nodeId The id of the registered node.\n     * @param nodeType The nodeType assigned to this node.\n     * @param parameters The parameters assigned to this node.\n     * @param parents The parents assigned to this node.\n     */\n    event NodeRegistered(\n        bytes32 nodeId,\n        NodeDefinition nodeType,\n        bytes parameters,\n        bytes32[] parents\n    );\n\n    /**\n     * @notice Registers a node\n     * @param nodeType The nodeType assigned to this node.\n     * @param parameters The parameters assigned to this node.\n     * @param parents The parents assigned to this node.\n     * @return nodeId The id of the registered node.\n     */\n    function registerNode(\n        NodeDefinition memory nodeType,\n        bytes memory parameters,\n        bytes32[] memory parents\n    ) external returns (bytes32 nodeId);\n\n    /**\n     * @notice Returns the ID of a node, whether or not it has been registered.\n     * @param parents The parents assigned to this node.\n     * @param nodeType The nodeType assigned to this node.\n     * @param parameters The parameters assigned to this node.\n     * @return nodeId The id of the node.\n     */\n    function getNodeId(\n        NodeDefinition memory nodeType,\n        bytes memory parameters,\n        bytes32[] memory parents\n    ) external pure returns (bytes32 nodeId);\n\n    /**\n     * @notice Returns a node's definition (type, parameters, and parents)\n     * @param nodeId The node ID\n     * @return node The node's definition data\n     */\n    function getNode(bytes32 nodeId) external pure returns (NodeDefinition memory node);\n\n    /**\n     * @notice Returns a node current output data\n     * @param nodeId The node ID\n     * @return node The node's output data\n     */\n    function process(bytes32 nodeId) external view returns (NodeOutput memory node);\n\n    /**\n     * @notice Returns a node current output data\n     * @param nodeId The node ID\n     * @param runtimeKeys Keys corresponding to runtime values which could be used by the node graph\n     * @param runtimeValues The values used by the node graph\n     * @return node The node's output data\n     */\n    function processWithRuntime(\n        bytes32 nodeId,\n        bytes32[] memory runtimeKeys,\n        bytes32[] memory runtimeValues\n    ) external view returns (NodeOutput memory node);\n\n    /**\n     * @notice Returns node current output data for many nodes at the same time, aggregating errors (if any)\n     * @param nodeIds The node ID\n     * @param runtimeKeys Keys corresponding to runtime values which could be used by the node graph. The same keys are used for all nodes\n     * @param runtimeValues The values used by the node graph. The same values are used for all nodes\n     * @return nodes The output data for all the nodes\n     */\n    function processManyWithRuntime(\n        bytes32[] memory nodeIds,\n        bytes32[] memory runtimeKeys,\n        bytes32[] memory runtimeValues\n    ) external view returns (NodeOutput memory nodes);\n\n    /**\n     * @notice Same as `processManyWithRuntime`, but allows for different runtime for each oracle call.\n     * @param nodeIds The node ID\n     * @param runtimeKeys Keys corresponding to runtime values which could be used by the node graph.\n     * @param runtimeValues The values used by the node graph.\n     * @return nodes The output data for all the nodes\n     */\n    function processManyWithManyRuntime(\n        bytes32[] memory nodeIds,\n        bytes32[][] memory runtimeKeys,\n        bytes32[][] memory runtimeValues\n    ) external view returns (NodeOutput memory nodes);\n}\n"
    },
    "contracts/interfaces/external/IV3CoreProxy.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n// !! THIS FILE WAS AUTOGENERATED BY abi-to-sol v0.7.1. SEE SOURCE BELOW. !!\npragma solidity ^0.8.4;\n\ninterface IV3CoreProxy {\n    error ImplementationIsSterile(address implementation);\n    error NoChange();\n    error NotAContract(address contr);\n    error NotNominated(address addr);\n    error Unauthorized(address addr);\n    error UpgradeSimulationFailed();\n    error ZeroAddress();\n    event OwnerChanged(address oldOwner, address newOwner);\n    event OwnerNominated(address newOwner);\n    event Upgraded(address indexed self, address implementation);\n\n    function acceptOwnership() external;\n\n    function getImplementation() external view returns (address);\n\n    function nominateNewOwner(address newNominatedOwner) external;\n\n    function nominatedOwner() external view returns (address);\n\n    function owner() external view returns (address);\n\n    function renounceNomination() external;\n\n    function simulateUpgradeTo(address newImplementation) external;\n\n    function upgradeTo(address newImplementation) external;\n\n    error ValueAlreadyInSet();\n    error ValueNotInSet();\n    event FeatureFlagAllowAllSet(bytes32 indexed feature, bool allowAll);\n    event FeatureFlagAllowlistAdded(bytes32 indexed feature, address account);\n    event FeatureFlagAllowlistRemoved(bytes32 indexed feature, address account);\n    event FeatureFlagDeniersReset(bytes32 indexed feature, address[] deniers);\n    event FeatureFlagDenyAllSet(bytes32 indexed feature, bool denyAll);\n\n    function addToFeatureFlagAllowlist(bytes32 feature, address account) external;\n\n    function getDeniers(bytes32 feature) external view returns (address[] memory);\n\n    function getFeatureFlagAllowAll(bytes32 feature) external view returns (bool);\n\n    function getFeatureFlagAllowlist(bytes32 feature) external view returns (address[] memory);\n\n    function getFeatureFlagDenyAll(bytes32 feature) external view returns (bool);\n\n    function isFeatureAllowed(bytes32 feature, address account) external view returns (bool);\n\n    function removeFromFeatureFlagAllowlist(bytes32 feature, address account) external;\n\n    function setDeniers(bytes32 feature, address[] memory deniers) external;\n\n    function setFeatureFlagAllowAll(bytes32 feature, bool allowAll) external;\n\n    function setFeatureFlagDenyAll(bytes32 feature, bool denyAll) external;\n\n    error FeatureUnavailable(bytes32 which);\n    error InvalidAccountId(uint128 accountId);\n    error InvalidPermission(bytes32 permission);\n    error OnlyAccountTokenProxy(address origin);\n    error PermissionDenied(uint128 accountId, bytes32 permission, address target);\n    error PermissionNotGranted(uint128 accountId, bytes32 permission, address user);\n    error PositionOutOfBounds();\n    event AccountCreated(uint128 indexed accountId, address indexed owner);\n    event PermissionGranted(\n        uint128 indexed accountId,\n        bytes32 indexed permission,\n        address indexed user,\n        address sender\n    );\n    event PermissionRevoked(\n        uint128 indexed accountId,\n        bytes32 indexed permission,\n        address indexed user,\n        address sender\n    );\n\n    function createAccount() external returns (uint128 accountId);\n\n    function createAccount(uint128 requestedAccountId) external;\n\n    function getAccountLastInteraction(uint128 accountId) external view returns (uint256);\n\n    function getAccountOwner(uint128 accountId) external view returns (address);\n\n    function getAccountPermissions(\n        uint128 accountId\n    ) external view returns (IAccountModule.AccountPermissions[] memory accountPerms);\n\n    function getAccountTokenAddress() external view returns (address);\n\n    function grantPermission(uint128 accountId, bytes32 permission, address user) external;\n\n    function hasPermission(\n        uint128 accountId,\n        bytes32 permission,\n        address user\n    ) external view returns (bool);\n\n    function isAuthorized(\n        uint128 accountId,\n        bytes32 permission,\n        address user\n    ) external view returns (bool);\n\n    function notifyAccountTransfer(address to, uint128 accountId) external;\n\n    function renouncePermission(uint128 accountId, bytes32 permission) external;\n\n    function revokePermission(uint128 accountId, bytes32 permission, address user) external;\n\n    error AccountNotFound(uint128 accountId);\n    error EmptyDistribution();\n    error InsufficientCollateralRatio(\n        uint256 collateralValue,\n        uint256 debt,\n        uint256 ratio,\n        uint256 minRatio\n    );\n    error MarketNotFound(uint128 marketId);\n    error NotFundedByPool(uint256 marketId, uint256 poolId);\n    error OverflowInt256ToInt128();\n    error OverflowInt256ToUint256();\n    error OverflowUint128ToInt128();\n    error OverflowUint256ToInt256();\n    error OverflowUint256ToUint128();\n    event DebtAssociated(\n        uint128 indexed marketId,\n        uint128 indexed poolId,\n        address indexed collateralType,\n        uint128 accountId,\n        uint256 amount,\n        int256 updatedDebt\n    );\n\n    function associateDebt(\n        uint128 marketId,\n        uint128 poolId,\n        address collateralType,\n        uint128 accountId,\n        uint256 amount\n    ) external returns (int256);\n\n    error MismatchAssociatedSystemKind(bytes32 expected, bytes32 actual);\n    error MissingAssociatedSystem(bytes32 id);\n    event AssociatedSystemSet(\n        bytes32 indexed kind,\n        bytes32 indexed id,\n        address proxy,\n        address impl\n    );\n\n    function getAssociatedSystem(bytes32 id) external view returns (address addr, bytes32 kind);\n\n    function initOrUpgradeNft(\n        bytes32 id,\n        string memory name,\n        string memory symbol,\n        string memory uri,\n        address impl\n    ) external;\n\n    function initOrUpgradeToken(\n        bytes32 id,\n        string memory name,\n        string memory symbol,\n        uint8 decimals,\n        address impl\n    ) external;\n\n    function registerUnmanagedSystem(bytes32 id, address endpoint) external;\n\n    error AccountActivityTimeoutPending(\n        uint128 accountId,\n        uint256 currentTime,\n        uint256 requiredTime\n    );\n    error CollateralDepositDisabled(address collateralType);\n    error CollateralNotFound();\n    error FailedTransfer(address from, address to, uint256 value);\n    error InsufficientAccountCollateral(uint256 amount);\n    error InsufficientAllowance(uint256 required, uint256 existing);\n    error InvalidParameter(string parameter, string reason);\n    error OverflowUint256ToUint64();\n    error PrecisionLost(uint256 tokenAmount, uint8 decimals);\n    event CollateralLockCreated(\n        uint128 indexed accountId,\n        address indexed collateralType,\n        uint256 tokenAmount,\n        uint64 expireTimestamp\n    );\n    event CollateralLockExpired(\n        uint128 indexed accountId,\n        address indexed collateralType,\n        uint256 tokenAmount,\n        uint64 expireTimestamp\n    );\n    event Deposited(\n        uint128 indexed accountId,\n        address indexed collateralType,\n        uint256 tokenAmount,\n        address indexed sender\n    );\n    event Withdrawn(\n        uint128 indexed accountId,\n        address indexed collateralType,\n        uint256 tokenAmount,\n        address indexed sender\n    );\n\n    function cleanExpiredLocks(\n        uint128 accountId,\n        address collateralType,\n        uint256 offset,\n        uint256 count\n    ) external returns (uint256 cleared);\n\n    function createLock(\n        uint128 accountId,\n        address collateralType,\n        uint256 amount,\n        uint64 expireTimestamp\n    ) external;\n\n    function deposit(uint128 accountId, address collateralType, uint256 tokenAmount) external;\n\n    function getAccountAvailableCollateral(\n        uint128 accountId,\n        address collateralType\n    ) external view returns (uint256);\n\n    function getAccountCollateral(\n        uint128 accountId,\n        address collateralType\n    ) external view returns (uint256 totalDeposited, uint256 totalAssigned, uint256 totalLocked);\n\n    function getLocks(\n        uint128 accountId,\n        address collateralType,\n        uint256 offset,\n        uint256 count\n    ) external view returns (CollateralLock.Data[] memory locks);\n\n    function withdraw(uint128 accountId, address collateralType, uint256 tokenAmount) external;\n\n    event CollateralConfigured(address indexed collateralType, CollateralConfiguration.Data config);\n\n    function configureCollateral(CollateralConfiguration.Data memory config) external;\n\n    function getCollateralConfiguration(\n        address collateralType\n    ) external view returns (CollateralConfiguration.Data memory);\n\n    function getCollateralConfigurations(\n        bool hideDisabled\n    ) external view returns (CollateralConfiguration.Data[] memory);\n\n    function getCollateralPrice(address collateralType) external view returns (uint256);\n\n    error InsufficientDebt(int256 currentDebt);\n    error PoolNotFound(uint128 poolId);\n    event IssuanceFeePaid(\n        uint128 indexed accountId,\n        uint128 indexed poolId,\n        address collateralType,\n        uint256 feeAmount\n    );\n    event UsdBurned(\n        uint128 indexed accountId,\n        uint128 indexed poolId,\n        address collateralType,\n        uint256 amount,\n        address indexed sender\n    );\n    event UsdMinted(\n        uint128 indexed accountId,\n        uint128 indexed poolId,\n        address collateralType,\n        uint256 amount,\n        address indexed sender\n    );\n\n    function burnUsd(\n        uint128 accountId,\n        uint128 poolId,\n        address collateralType,\n        uint256 amount\n    ) external;\n\n    function mintUsd(\n        uint128 accountId,\n        uint128 poolId,\n        address collateralType,\n        uint256 amount\n    ) external;\n\n    error CannotScaleEmptyMapping();\n    error IneligibleForLiquidation(\n        uint256 collateralValue,\n        int256 debt,\n        uint256 currentCRatio,\n        uint256 cratio\n    );\n    error InsufficientMappedAmount();\n    error MustBeVaultLiquidated();\n    error OverflowInt128ToUint128();\n    event Liquidation(\n        uint128 indexed accountId,\n        uint128 indexed poolId,\n        address indexed collateralType,\n        ILiquidationModule.LiquidationData liquidationData,\n        uint128 liquidateAsAccountId,\n        address sender\n    );\n    event VaultLiquidation(\n        uint128 indexed poolId,\n        address indexed collateralType,\n        ILiquidationModule.LiquidationData liquidationData,\n        uint128 liquidateAsAccountId,\n        address sender\n    );\n\n    function isPositionLiquidatable(\n        uint128 accountId,\n        uint128 poolId,\n        address collateralType\n    ) external returns (bool);\n\n    function isVaultLiquidatable(uint128 poolId, address collateralType) external returns (bool);\n\n    function liquidate(\n        uint128 accountId,\n        uint128 poolId,\n        address collateralType,\n        uint128 liquidateAsAccountId\n    ) external returns (ILiquidationModule.LiquidationData memory liquidationData);\n\n    function liquidateVault(\n        uint128 poolId,\n        address collateralType,\n        uint128 liquidateAsAccountId,\n        uint256 maxUsd\n    ) external returns (ILiquidationModule.LiquidationData memory liquidationData);\n\n    error InsufficientMarketCollateralDepositable(\n        uint128 marketId,\n        address collateralType,\n        uint256 tokenAmountToDeposit\n    );\n    error InsufficientMarketCollateralWithdrawable(\n        uint128 marketId,\n        address collateralType,\n        uint256 tokenAmountToWithdraw\n    );\n    event MarketCollateralDeposited(\n        uint128 indexed marketId,\n        address indexed collateralType,\n        uint256 tokenAmount,\n        address indexed sender\n    );\n    event MarketCollateralWithdrawn(\n        uint128 indexed marketId,\n        address indexed collateralType,\n        uint256 tokenAmount,\n        address indexed sender\n    );\n    event MaximumMarketCollateralConfigured(\n        uint128 indexed marketId,\n        address indexed collateralType,\n        uint256 systemAmount,\n        address indexed owner\n    );\n\n    function configureMaximumMarketCollateral(\n        uint128 marketId,\n        address collateralType,\n        uint256 amount\n    ) external;\n\n    function depositMarketCollateral(\n        uint128 marketId,\n        address collateralType,\n        uint256 tokenAmount\n    ) external;\n\n    function getMarketCollateralAmount(\n        uint128 marketId,\n        address collateralType\n    ) external view returns (uint256 collateralAmountD18);\n\n    function getMarketCollateralValue(uint128 marketId) external view returns (uint256);\n\n    function getMaximumMarketCollateral(\n        uint128 marketId,\n        address collateralType\n    ) external view returns (uint256);\n\n    function withdrawMarketCollateral(\n        uint128 marketId,\n        address collateralType,\n        uint256 tokenAmount\n    ) external;\n\n    error IncorrectMarketInterface(address market);\n    error NotEnoughLiquidity(uint128 marketId, uint256 amount);\n    event MarketRegistered(\n        address indexed market,\n        uint128 indexed marketId,\n        address indexed sender\n    );\n    event MarketSystemFeePaid(uint128 indexed marketId, uint256 feeAmount);\n    event MarketUsdDeposited(\n        uint128 indexed marketId,\n        address indexed target,\n        uint256 amount,\n        address indexed market\n    );\n    event MarketUsdWithdrawn(\n        uint128 indexed marketId,\n        address indexed target,\n        uint256 amount,\n        address indexed market\n    );\n    event SetMarketMinLiquidityRatio(uint128 indexed marketId, uint256 minLiquidityRatio);\n    event SetMinDelegateTime(uint128 indexed marketId, uint32 minDelegateTime);\n\n    function depositMarketUsd(\n        uint128 marketId,\n        address target,\n        uint256 amount\n    ) external returns (uint256 feeAmount);\n\n    function distributeDebtToPools(uint128 marketId, uint256 maxIter) external returns (bool);\n\n    function getMarketCollateral(uint128 marketId) external view returns (uint256);\n\n    function getMarketDebtPerShare(uint128 marketId) external returns (int256);\n\n    function getMarketFees(\n        uint128,\n        uint256 amount\n    ) external view returns (uint256 depositFeeAmount, uint256 withdrawFeeAmount);\n\n    function getMarketMinDelegateTime(uint128 marketId) external view returns (uint32);\n\n    function getMarketNetIssuance(uint128 marketId) external view returns (int128);\n\n    function getMarketReportedDebt(uint128 marketId) external view returns (uint256);\n\n    function getMarketTotalDebt(uint128 marketId) external view returns (int256);\n\n    function getMinLiquidityRatio(uint128 marketId) external view returns (uint256);\n\n    function getOracleManager() external view returns (address);\n\n    function getUsdToken() external view returns (address);\n\n    function getWithdrawableMarketUsd(uint128 marketId) external view returns (uint256);\n\n    function isMarketCapacityLocked(uint128 marketId) external view returns (bool);\n\n    function registerMarket(address market) external returns (uint128 marketId);\n\n    function setMarketMinDelegateTime(uint128 marketId, uint32 minDelegateTime) external;\n\n    function setMinLiquidityRatio(uint128 marketId, uint256 minLiquidityRatio) external;\n\n    function withdrawMarketUsd(\n        uint128 marketId,\n        address target,\n        uint256 amount\n    ) external returns (uint256 feeAmount);\n\n    function multicall(bytes[] memory data) external payable returns (bytes[] memory results);\n\n    event PoolApprovedAdded(uint256 poolId);\n    event PoolApprovedRemoved(uint256 poolId);\n    event PreferredPoolSet(uint256 poolId);\n\n    function addApprovedPool(uint128 poolId) external;\n\n    function getApprovedPools() external view returns (uint256[] memory);\n\n    function getPreferredPool() external view returns (uint128);\n\n    function removeApprovedPool(uint128 poolId) external;\n\n    function setPreferredPool(uint128 poolId) external;\n\n    error CapacityLocked(uint256 marketId);\n    error MinDelegationTimeoutPending(uint128 poolId, uint32 timeRemaining);\n    error PoolAlreadyExists(uint128 poolId);\n    event PoolConfigurationSet(\n        uint128 indexed poolId,\n        MarketConfiguration.Data[] markets,\n        address indexed sender\n    );\n    event PoolCreated(uint128 indexed poolId, address indexed owner, address indexed sender);\n    event PoolNameUpdated(uint128 indexed poolId, string name, address indexed sender);\n    event PoolNominationRenounced(uint128 indexed poolId, address indexed owner);\n    event PoolNominationRevoked(uint128 indexed poolId, address indexed owner);\n    event PoolOwnerNominated(\n        uint128 indexed poolId,\n        address indexed nominatedOwner,\n        address indexed owner\n    );\n    event PoolOwnershipAccepted(uint128 indexed poolId, address indexed owner);\n    event SetMinLiquidityRatio(uint256 minLiquidityRatio);\n\n    function acceptPoolOwnership(uint128 poolId) external;\n\n    function createPool(uint128 requestedPoolId, address owner) external;\n\n    function getMinLiquidityRatio() external view returns (uint256);\n\n    function getNominatedPoolOwner(uint128 poolId) external view returns (address);\n\n    function getPoolConfiguration(\n        uint128 poolId\n    ) external view returns (MarketConfiguration.Data[] memory);\n\n    function getPoolName(uint128 poolId) external view returns (string memory poolName);\n\n    function getPoolOwner(uint128 poolId) external view returns (address);\n\n    function nominatePoolOwner(address nominatedOwner, uint128 poolId) external;\n\n    function renouncePoolNomination(uint128 poolId) external;\n\n    function revokePoolNomination(uint128 poolId) external;\n\n    function setMinLiquidityRatio(uint256 minLiquidityRatio) external;\n\n    function setPoolConfiguration(\n        uint128 poolId,\n        MarketConfiguration.Data[] memory newMarketConfigurations\n    ) external;\n\n    function setPoolName(uint128 poolId, string memory name) external;\n\n    error OverflowUint256ToUint32();\n    error OverflowUint32ToInt32();\n    error OverflowUint64ToInt64();\n    error RewardDistributorNotFound();\n    error RewardUnavailable(address distributor);\n    event RewardsClaimed(\n        uint128 indexed accountId,\n        uint128 indexed poolId,\n        address indexed collateralType,\n        address distributor,\n        uint256 amount\n    );\n    event RewardsDistributed(\n        uint128 indexed poolId,\n        address indexed collateralType,\n        address distributor,\n        uint256 amount,\n        uint256 start,\n        uint256 duration\n    );\n    event RewardsDistributorRegistered(\n        uint128 indexed poolId,\n        address indexed collateralType,\n        address indexed distributor\n    );\n    event RewardsDistributorRemoved(\n        uint128 indexed poolId,\n        address indexed collateralType,\n        address indexed distributor\n    );\n\n    function claimRewards(\n        uint128 accountId,\n        uint128 poolId,\n        address collateralType,\n        address distributor\n    ) external returns (uint256);\n\n    function distributeRewards(\n        uint128 poolId,\n        address collateralType,\n        uint256 amount,\n        uint64 start,\n        uint32 duration\n    ) external;\n\n    function getRewardRate(\n        uint128 poolId,\n        address collateralType,\n        address distributor\n    ) external view returns (uint256);\n\n    function registerRewardsDistributor(\n        uint128 poolId,\n        address collateralType,\n        address distributor\n    ) external;\n\n    function removeRewardsDistributor(\n        uint128 poolId,\n        address collateralType,\n        address distributor\n    ) external;\n\n    function updateRewards(\n        uint128 poolId,\n        address collateralType,\n        uint128 accountId\n    ) external returns (uint256[] memory, address[] memory);\n\n    function configureOracleManager(address oracleManagerAddress) external;\n\n    function getConfig(bytes32 k) external view returns (bytes32 v);\n\n    function registerCcip(address ccipSend, address ccipReceive, address ccipTokenPool) external;\n\n    function setConfig(bytes32 k, bytes32 v) external;\n\n    error InsufficientDelegation(uint256 minDelegation);\n    error InvalidCollateralAmount();\n    error InvalidLeverage(uint256 leverage);\n    event DelegationUpdated(\n        uint128 indexed accountId,\n        uint128 indexed poolId,\n        address collateralType,\n        uint256 amount,\n        uint256 leverage,\n        address indexed sender\n    );\n\n    function delegateCollateral(\n        uint128 accountId,\n        uint128 poolId,\n        address collateralType,\n        uint256 newCollateralAmountD18,\n        uint256 leverage\n    ) external;\n\n    function migrateDelegation(\n        uint128 accountId,\n        uint128 oldPoolId,\n        address collateralType,\n        uint128 newPoolId\n    ) external;\n\n    function getPosition(\n        uint128 accountId,\n        uint128 poolId,\n        address collateralType\n    )\n        external\n        returns (\n            uint256 collateralAmount,\n            uint256 collateralValue,\n            int256 debt,\n            uint256 collateralizationRatio\n        );\n\n    function getPositionCollateral(\n        uint128 accountId,\n        uint128 poolId,\n        address collateralType\n    ) external view returns (uint256 amount, uint256 value);\n\n    function getPositionCollateralRatio(\n        uint128 accountId,\n        uint128 poolId,\n        address collateralType\n    ) external returns (uint256);\n\n    function getPositionDebt(\n        uint128 accountId,\n        uint128 poolId,\n        address collateralType\n    ) external returns (int256);\n\n    function getVaultCollateral(\n        uint128 poolId,\n        address collateralType\n    ) external view returns (uint256 amount, uint256 value);\n\n    function getVaultCollateralRatio(\n        uint128 poolId,\n        address collateralType\n    ) external returns (uint256);\n\n    function getVaultDebt(uint128 poolId, address collateralType) external returns (int256);\n}\n\ninterface IAccountModule {\n    struct AccountPermissions {\n        address user;\n        bytes32[] permissions;\n    }\n}\n\ninterface CollateralLock {\n    struct Data {\n        uint128 amountD18;\n        uint64 lockExpirationTime;\n    }\n}\n\ninterface CollateralConfiguration {\n    struct Data {\n        bool depositingEnabled;\n        uint256 issuanceRatioD18;\n        uint256 liquidationRatioD18;\n        uint256 liquidationRewardD18;\n        bytes32 oracleNodeId;\n        address tokenAddress;\n        uint256 minDelegationD18;\n    }\n}\n\ninterface ILiquidationModule {\n    struct LiquidationData {\n        uint256 debtLiquidated;\n        uint256 collateralLiquidated;\n        uint256 amountRewarded;\n    }\n}\n\ninterface MarketConfiguration {\n    struct Data {\n        uint128 marketId;\n        uint128 weightD18;\n        int128 maxDebtShareValueD18;\n    }\n}\n\n// THIS FILE WAS AUTOGENERATED FROM THE FOLLOWING ABI JSON:\n/*\n[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"ImplementationIsSterile\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoChange\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contr\",\"type\":\"address\"}],\"name\":\"NotAContract\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"NotNominated\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"Unauthorized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UpgradeSimulationFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroAddress\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerNominated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"self\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"Upgraded\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getImplementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newNominatedOwner\",\"type\":\"address\"}],\"name\":\"nominateNewOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nominatedOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceNomination\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"}],\"name\":\"simulateUpgradeTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"}],\"name\":\"upgradeTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ValueAlreadyInSet\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ValueNotInSet\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"feature\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"allowAll\",\"type\":\"bool\"}],\"name\":\"FeatureFlagAllowAllSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"feature\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"FeatureFlagAllowlistAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"feature\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"FeatureFlagAllowlistRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"feature\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"deniers\",\"type\":\"address[]\"}],\"name\":\"FeatureFlagDeniersReset\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"feature\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"denyAll\",\"type\":\"bool\"}],\"name\":\"FeatureFlagDenyAllSet\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"feature\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addToFeatureFlagAllowlist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"feature\",\"type\":\"bytes32\"}],\"name\":\"getDeniers\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"feature\",\"type\":\"bytes32\"}],\"name\":\"getFeatureFlagAllowAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"feature\",\"type\":\"bytes32\"}],\"name\":\"getFeatureFlagAllowlist\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"feature\",\"type\":\"bytes32\"}],\"name\":\"getFeatureFlagDenyAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"feature\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isFeatureAllowed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"feature\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removeFromFeatureFlagAllowlist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"feature\",\"type\":\"bytes32\"},{\"internalType\":\"address[]\",\"name\":\"deniers\",\"type\":\"address[]\"}],\"name\":\"setDeniers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"feature\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"allowAll\",\"type\":\"bool\"}],\"name\":\"setFeatureFlagAllowAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"feature\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"denyAll\",\"type\":\"bool\"}],\"name\":\"setFeatureFlagDenyAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"which\",\"type\":\"bytes32\"}],\"name\":\"FeatureUnavailable\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"accountId\",\"type\":\"uint128\"}],\"name\":\"InvalidAccountId\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"permission\",\"type\":\"bytes32\"}],\"name\":\"InvalidPermission\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"origin\",\"type\":\"address\"}],\"name\":\"OnlyAccountTokenProxy\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"accountId\",\"type\":\"uint128\"},{\"internalType\":\"bytes32\",\"name\":\"permission\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"name\":\"PermissionDenied\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"accountId\",\"type\":\"uint128\"},{\"internalType\":\"bytes32\",\"name\":\"permission\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"PermissionNotGranted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PositionOutOfBounds\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint128\",\"name\":\"accountId\",\"type\":\"uint128\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"AccountCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint128\",\"name\":\"accountId\",\"type\":\"uint128\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"permission\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"PermissionGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint128\",\"name\":\"accountId\",\"type\":\"uint128\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"permission\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"PermissionRevoked\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"createAccount\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"accountId\",\"type\":\"uint128\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"requestedAccountId\",\"type\":\"uint128\"}],\"name\":\"createAccount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"accountId\",\"type\":\"uint128\"}],\"name\":\"getAccountLastInteraction\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"accountId\",\"type\":\"uint128\"}],\"name\":\"getAccountOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"accountId\",\"type\":\"uint128\"}],\"name\":\"getAccountPermissions\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"bytes32[]\",\"name\":\"permissions\",\"type\":\"bytes32[]\"}],\"internalType\":\"struct IAccountModule.AccountPermissions[]\",\"name\":\"accountPerms\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAccountTokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"accountId\",\"type\":\"uint128\"},{\"internalType\":\"bytes32\",\"name\":\"permission\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"grantPermission\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"accountId\",\"type\":\"uint128\"},{\"internalType\":\"bytes32\",\"name\":\"permission\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"hasPermission\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"accountId\",\"type\":\"uint128\"},{\"internalType\":\"bytes32\",\"name\":\"permission\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"isAuthorized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint128\",\"name\":\"accountId\",\"type\":\"uint128\"}],\"name\":\"notifyAccountTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"accountId\",\"type\":\"uint128\"},{\"internalType\":\"bytes32\",\"name\":\"permission\",\"type\":\"bytes32\"}],\"name\":\"renouncePermission\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"accountId\",\"type\":\"uint128\"},{\"internalType\":\"bytes32\",\"name\":\"permission\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"revokePermission\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"accountId\",\"type\":\"uint128\"}],\"name\":\"AccountNotFound\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"EmptyDistribution\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"collateralValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"debt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minRatio\",\"type\":\"uint256\"}],\"name\":\"InsufficientCollateralRatio\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"marketId\",\"type\":\"uint128\"}],\"name\":\"MarketNotFound\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"}],\"name\":\"NotFundedByPool\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OverflowInt256ToInt128\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OverflowInt256ToUint256\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OverflowUint128ToInt128\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OverflowUint256ToInt256\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OverflowUint256ToUint128\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint128\",\"name\":\"marketId\",\"type\":\"uint128\"},{\"indexed\":true,\"internalType\":\"uint128\",\"name\":\"poolId\",\"type\":\"uint128\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collateralType\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"accountId\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"updatedDebt\",\"type\":\"int256\"}],\"name\":\"DebtAssociated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"marketId\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"poolId\",\"type\":\"uint128\"},{\"internalType\":\"address\",\"name\":\"collateralType\",\"type\":\"address\"},{\"internalType\":\"uint128\",\"name\":\"accountId\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"associateDebt\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"expected\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"actual\",\"type\":\"bytes32\"}],\"name\":\"MismatchAssociatedSystemKind\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"MissingAssociatedSystem\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"kind\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"proxy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"impl\",\"type\":\"address\"}],\"name\":\"AssociatedSystemSet\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"getAssociatedSystem\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"kind\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"impl\",\"type\":\"address\"}],\"name\":\"initOrUpgradeNft\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"impl\",\"type\":\"address\"}],\"name\":\"initOrUpgradeToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"endpoint\",\"type\":\"address\"}],\"name\":\"registerUnmanagedSystem\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"accountId\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"currentTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"requiredTime\",\"type\":\"uint256\"}],\"name\":\"AccountActivityTimeoutPending\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collateralType\",\"type\":\"address\"}],\"name\":\"CollateralDepositDisabled\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CollateralNotFound\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"FailedTransfer\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"InsufficientAccountCollateral\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"required\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"existing\",\"type\":\"uint256\"}],\"name\":\"InsufficientAllowance\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"parameter\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"reason\",\"type\":\"string\"}],\"name\":\"InvalidParameter\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OverflowUint256ToUint64\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"}],\"name\":\"PrecisionLost\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint128\",\"name\":\"accountId\",\"type\":\"uint128\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collateralType\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"expireTimestamp\",\"type\":\"uint64\"}],\"name\":\"CollateralLockCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint128\",\"name\":\"accountId\",\"type\":\"uint128\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collateralType\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"expireTimestamp\",\"type\":\"uint64\"}],\"name\":\"CollateralLockExpired\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint128\",\"name\":\"accountId\",\"type\":\"uint128\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collateralType\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"Deposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint128\",\"name\":\"accountId\",\"type\":\"uint128\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collateralType\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"Withdrawn\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"accountId\",\"type\":\"uint128\"},{\"internalType\":\"address\",\"name\":\"collateralType\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"offset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"cleanExpiredLocks\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"cleared\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"accountId\",\"type\":\"uint128\"},{\"internalType\":\"address\",\"name\":\"collateralType\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"expireTimestamp\",\"type\":\"uint64\"}],\"name\":\"createLock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"accountId\",\"type\":\"uint128\"},{\"internalType\":\"address\",\"name\":\"collateralType\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"accountId\",\"type\":\"uint128\"},{\"internalType\":\"address\",\"name\":\"collateralType\",\"type\":\"address\"}],\"name\":\"getAccountAvailableCollateral\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"accountId\",\"type\":\"uint128\"},{\"internalType\":\"address\",\"name\":\"collateralType\",\"type\":\"address\"}],\"name\":\"getAccountCollateral\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalDeposited\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalAssigned\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalLocked\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"accountId\",\"type\":\"uint128\"},{\"internalType\":\"address\",\"name\":\"collateralType\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"offset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"getLocks\",\"outputs\":[{\"components\":[{\"internalType\":\"uint128\",\"name\":\"amountD18\",\"type\":\"uint128\"},{\"internalType\":\"uint64\",\"name\":\"lockExpirationTime\",\"type\":\"uint64\"}],\"internalType\":\"struct CollateralLock.Data[]\",\"name\":\"locks\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"accountId\",\"type\":\"uint128\"},{\"internalType\":\"address\",\"name\":\"collateralType\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collateralType\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"depositingEnabled\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"issuanceRatioD18\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidationRatioD18\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidationRewardD18\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"oracleNodeId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minDelegationD18\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct CollateralConfiguration.Data\",\"name\":\"config\",\"type\":\"tuple\"}],\"name\":\"CollateralConfigured\",\"type\":\"event\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"depositingEnabled\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"issuanceRatioD18\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidationRatioD18\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidationRewardD18\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"oracleNodeId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minDelegationD18\",\"type\":\"uint256\"}],\"internalType\":\"struct CollateralConfiguration.Data\",\"name\":\"config\",\"type\":\"tuple\"}],\"name\":\"configureCollateral\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collateralType\",\"type\":\"address\"}],\"name\":\"getCollateralConfiguration\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"depositingEnabled\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"issuanceRatioD18\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidationRatioD18\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidationRewardD18\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"oracleNodeId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minDelegationD18\",\"type\":\"uint256\"}],\"internalType\":\"struct CollateralConfiguration.Data\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"hideDisabled\",\"type\":\"bool\"}],\"name\":\"getCollateralConfigurations\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"depositingEnabled\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"issuanceRatioD18\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidationRatioD18\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidationRewardD18\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"oracleNodeId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minDelegationD18\",\"type\":\"uint256\"}],\"internalType\":\"struct CollateralConfiguration.Data[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collateralType\",\"type\":\"address\"}],\"name\":\"getCollateralPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"currentDebt\",\"type\":\"int256\"}],\"name\":\"InsufficientDebt\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"poolId\",\"type\":\"uint128\"}],\"name\":\"PoolNotFound\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint128\",\"name\":\"accountId\",\"type\":\"uint128\"},{\"indexed\":true,\"internalType\":\"uint128\",\"name\":\"poolId\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"collateralType\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feeAmount\",\"type\":\"uint256\"}],\"name\":\"IssuanceFeePaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint128\",\"name\":\"accountId\",\"type\":\"uint128\"},{\"indexed\":true,\"internalType\":\"uint128\",\"name\":\"poolId\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"collateralType\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"UsdBurned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint128\",\"name\":\"accountId\",\"type\":\"uint128\"},{\"indexed\":true,\"internalType\":\"uint128\",\"name\":\"poolId\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"collateralType\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"UsdMinted\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"accountId\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"poolId\",\"type\":\"uint128\"},{\"internalType\":\"address\",\"name\":\"collateralType\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burnUsd\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"accountId\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"poolId\",\"type\":\"uint128\"},{\"internalType\":\"address\",\"name\":\"collateralType\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mintUsd\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CannotScaleEmptyMapping\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"collateralValue\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"debt\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"currentCRatio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cratio\",\"type\":\"uint256\"}],\"name\":\"IneligibleForLiquidation\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientMappedAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MustBeVaultLiquidated\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OverflowInt128ToUint128\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint128\",\"name\":\"accountId\",\"type\":\"uint128\"},{\"indexed\":true,\"internalType\":\"uint128\",\"name\":\"poolId\",\"type\":\"uint128\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collateralType\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"debtLiquidated\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralLiquidated\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountRewarded\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct ILiquidationModule.LiquidationData\",\"name\":\"liquidationData\",\"type\":\"tuple\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"liquidateAsAccountId\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"Liquidation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint128\",\"name\":\"poolId\",\"type\":\"uint128\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collateralType\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"debtLiquidated\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralLiquidated\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountRewarded\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct ILiquidationModule.LiquidationData\",\"name\":\"liquidationData\",\"type\":\"tuple\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"liquidateAsAccountId\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"VaultLiquidation\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"accountId\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"poolId\",\"type\":\"uint128\"},{\"internalType\":\"address\",\"name\":\"collateralType\",\"type\":\"address\"}],\"name\":\"isPositionLiquidatable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"poolId\",\"type\":\"uint128\"},{\"internalType\":\"address\",\"name\":\"collateralType\",\"type\":\"address\"}],\"name\":\"isVaultLiquidatable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"accountId\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"poolId\",\"type\":\"uint128\"},{\"internalType\":\"address\",\"name\":\"collateralType\",\"type\":\"address\"},{\"internalType\":\"uint128\",\"name\":\"liquidateAsAccountId\",\"type\":\"uint128\"}],\"name\":\"liquidate\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"debtLiquidated\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralLiquidated\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountRewarded\",\"type\":\"uint256\"}],\"internalType\":\"struct ILiquidationModule.LiquidationData\",\"name\":\"liquidationData\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"poolId\",\"type\":\"uint128\"},{\"internalType\":\"address\",\"name\":\"collateralType\",\"type\":\"address\"},{\"internalType\":\"uint128\",\"name\":\"liquidateAsAccountId\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"maxUsd\",\"type\":\"uint256\"}],\"name\":\"liquidateVault\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"debtLiquidated\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralLiquidated\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountRewarded\",\"type\":\"uint256\"}],\"internalType\":\"struct ILiquidationModule.LiquidationData\",\"name\":\"liquidationData\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"marketId\",\"type\":\"uint128\"},{\"internalType\":\"address\",\"name\":\"collateralType\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountToDeposit\",\"type\":\"uint256\"}],\"name\":\"InsufficientMarketCollateralDepositable\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"marketId\",\"type\":\"uint128\"},{\"internalType\":\"address\",\"name\":\"collateralType\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountToWithdraw\",\"type\":\"uint256\"}],\"name\":\"InsufficientMarketCollateralWithdrawable\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint128\",\"name\":\"marketId\",\"type\":\"uint128\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collateralType\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"MarketCollateralDeposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint128\",\"name\":\"marketId\",\"type\":\"uint128\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collateralType\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"MarketCollateralWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint128\",\"name\":\"marketId\",\"type\":\"uint128\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collateralType\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"systemAmount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"MaximumMarketCollateralConfigured\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"marketId\",\"type\":\"uint128\"},{\"internalType\":\"address\",\"name\":\"collateralType\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"configureMaximumMarketCollateral\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"marketId\",\"type\":\"uint128\"},{\"internalType\":\"address\",\"name\":\"collateralType\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"depositMarketCollateral\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"marketId\",\"type\":\"uint128\"},{\"internalType\":\"address\",\"name\":\"collateralType\",\"type\":\"address\"}],\"name\":\"getMarketCollateralAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"collateralAmountD18\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"marketId\",\"type\":\"uint128\"}],\"name\":\"getMarketCollateralValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"marketId\",\"type\":\"uint128\"},{\"internalType\":\"address\",\"name\":\"collateralType\",\"type\":\"address\"}],\"name\":\"getMaximumMarketCollateral\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"marketId\",\"type\":\"uint128\"},{\"internalType\":\"address\",\"name\":\"collateralType\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"withdrawMarketCollateral\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"market\",\"type\":\"address\"}],\"name\":\"IncorrectMarketInterface\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"marketId\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"NotEnoughLiquidity\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"market\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint128\",\"name\":\"marketId\",\"type\":\"uint128\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"MarketRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint128\",\"name\":\"marketId\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feeAmount\",\"type\":\"uint256\"}],\"name\":\"MarketSystemFeePaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint128\",\"name\":\"marketId\",\"type\":\"uint128\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"market\",\"type\":\"address\"}],\"name\":\"MarketUsdDeposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint128\",\"name\":\"marketId\",\"type\":\"uint128\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"market\",\"type\":\"address\"}],\"name\":\"MarketUsdWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint128\",\"name\":\"marketId\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minLiquidityRatio\",\"type\":\"uint256\"}],\"name\":\"SetMarketMinLiquidityRatio\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint128\",\"name\":\"marketId\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"minDelegateTime\",\"type\":\"uint32\"}],\"name\":\"SetMinDelegateTime\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"marketId\",\"type\":\"uint128\"},{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"depositMarketUsd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"feeAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"marketId\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"maxIter\",\"type\":\"uint256\"}],\"name\":\"distributeDebtToPools\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"marketId\",\"type\":\"uint128\"}],\"name\":\"getMarketCollateral\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"marketId\",\"type\":\"uint128\"}],\"name\":\"getMarketDebtPerShare\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getMarketFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"depositFeeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawFeeAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"marketId\",\"type\":\"uint128\"}],\"name\":\"getMarketMinDelegateTime\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"marketId\",\"type\":\"uint128\"}],\"name\":\"getMarketNetIssuance\",\"outputs\":[{\"internalType\":\"int128\",\"name\":\"\",\"type\":\"int128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"marketId\",\"type\":\"uint128\"}],\"name\":\"getMarketReportedDebt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"marketId\",\"type\":\"uint128\"}],\"name\":\"getMarketTotalDebt\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"marketId\",\"type\":\"uint128\"}],\"name\":\"getMinLiquidityRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOracleManager\",\"outputs\":[{\"internalType\":\"contract IOracleManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUsdToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"marketId\",\"type\":\"uint128\"}],\"name\":\"getWithdrawableMarketUsd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"marketId\",\"type\":\"uint128\"}],\"name\":\"isMarketCapacityLocked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"market\",\"type\":\"address\"}],\"name\":\"registerMarket\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"marketId\",\"type\":\"uint128\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"marketId\",\"type\":\"uint128\"},{\"internalType\":\"uint32\",\"name\":\"minDelegateTime\",\"type\":\"uint32\"}],\"name\":\"setMarketMinDelegateTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"marketId\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"minLiquidityRatio\",\"type\":\"uint256\"}],\"name\":\"setMinLiquidityRatio\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"marketId\",\"type\":\"uint128\"},{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawMarketUsd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"feeAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"data\",\"type\":\"bytes[]\"}],\"name\":\"multicall\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"results\",\"type\":\"bytes[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"}],\"name\":\"PoolApprovedAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"}],\"name\":\"PoolApprovedRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"}],\"name\":\"PreferredPoolSet\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"poolId\",\"type\":\"uint128\"}],\"name\":\"addApprovedPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getApprovedPools\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPreferredPool\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"poolId\",\"type\":\"uint128\"}],\"name\":\"removeApprovedPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"poolId\",\"type\":\"uint128\"}],\"name\":\"setPreferredPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"}],\"name\":\"CapacityLocked\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"poolId\",\"type\":\"uint128\"},{\"internalType\":\"uint32\",\"name\":\"timeRemaining\",\"type\":\"uint32\"}],\"name\":\"MinDelegationTimeoutPending\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"poolId\",\"type\":\"uint128\"}],\"name\":\"PoolAlreadyExists\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint128\",\"name\":\"poolId\",\"type\":\"uint128\"},{\"components\":[{\"internalType\":\"uint128\",\"name\":\"marketId\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"weightD18\",\"type\":\"uint128\"},{\"internalType\":\"int128\",\"name\":\"maxDebtShareValueD18\",\"type\":\"int128\"}],\"indexed\":false,\"internalType\":\"struct MarketConfiguration.Data[]\",\"name\":\"markets\",\"type\":\"tuple[]\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"PoolConfigurationSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint128\",\"name\":\"poolId\",\"type\":\"uint128\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"PoolCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint128\",\"name\":\"poolId\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"PoolNameUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint128\",\"name\":\"poolId\",\"type\":\"uint128\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"PoolNominationRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint128\",\"name\":\"poolId\",\"type\":\"uint128\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"PoolNominationRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint128\",\"name\":\"poolId\",\"type\":\"uint128\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"nominatedOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"PoolOwnerNominated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint128\",\"name\":\"poolId\",\"type\":\"uint128\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"PoolOwnershipAccepted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minLiquidityRatio\",\"type\":\"uint256\"}],\"name\":\"SetMinLiquidityRatio\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"poolId\",\"type\":\"uint128\"}],\"name\":\"acceptPoolOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"requestedPoolId\",\"type\":\"uint128\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"createPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMinLiquidityRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"poolId\",\"type\":\"uint128\"}],\"name\":\"getNominatedPoolOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"poolId\",\"type\":\"uint128\"}],\"name\":\"getPoolConfiguration\",\"outputs\":[{\"components\":[{\"internalType\":\"uint128\",\"name\":\"marketId\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"weightD18\",\"type\":\"uint128\"},{\"internalType\":\"int128\",\"name\":\"maxDebtShareValueD18\",\"type\":\"int128\"}],\"internalType\":\"struct MarketConfiguration.Data[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"poolId\",\"type\":\"uint128\"}],\"name\":\"getPoolName\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"poolName\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"poolId\",\"type\":\"uint128\"}],\"name\":\"getPoolOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nominatedOwner\",\"type\":\"address\"},{\"internalType\":\"uint128\",\"name\":\"poolId\",\"type\":\"uint128\"}],\"name\":\"nominatePoolOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"poolId\",\"type\":\"uint128\"}],\"name\":\"renouncePoolNomination\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"poolId\",\"type\":\"uint128\"}],\"name\":\"revokePoolNomination\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minLiquidityRatio\",\"type\":\"uint256\"}],\"name\":\"setMinLiquidityRatio\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"poolId\",\"type\":\"uint128\"},{\"components\":[{\"internalType\":\"uint128\",\"name\":\"marketId\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"weightD18\",\"type\":\"uint128\"},{\"internalType\":\"int128\",\"name\":\"maxDebtShareValueD18\",\"type\":\"int128\"}],\"internalType\":\"struct MarketConfiguration.Data[]\",\"name\":\"newMarketConfigurations\",\"type\":\"tuple[]\"}],\"name\":\"setPoolConfiguration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"poolId\",\"type\":\"uint128\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"name\":\"setPoolName\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"OverflowUint256ToUint32\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OverflowUint32ToInt32\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OverflowUint64ToInt64\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RewardDistributorNotFound\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"distributor\",\"type\":\"address\"}],\"name\":\"RewardUnavailable\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint128\",\"name\":\"accountId\",\"type\":\"uint128\"},{\"indexed\":true,\"internalType\":\"uint128\",\"name\":\"poolId\",\"type\":\"uint128\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collateralType\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"distributor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RewardsClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint128\",\"name\":\"poolId\",\"type\":\"uint128\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collateralType\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"distributor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"}],\"name\":\"RewardsDistributed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint128\",\"name\":\"poolId\",\"type\":\"uint128\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collateralType\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"distributor\",\"type\":\"address\"}],\"name\":\"RewardsDistributorRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint128\",\"name\":\"poolId\",\"type\":\"uint128\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collateralType\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"distributor\",\"type\":\"address\"}],\"name\":\"RewardsDistributorRemoved\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"accountId\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"poolId\",\"type\":\"uint128\"},{\"internalType\":\"address\",\"name\":\"collateralType\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"distributor\",\"type\":\"address\"}],\"name\":\"claimRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"poolId\",\"type\":\"uint128\"},{\"internalType\":\"address\",\"name\":\"collateralType\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"start\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"duration\",\"type\":\"uint32\"}],\"name\":\"distributeRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"poolId\",\"type\":\"uint128\"},{\"internalType\":\"address\",\"name\":\"collateralType\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"distributor\",\"type\":\"address\"}],\"name\":\"getRewardRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"poolId\",\"type\":\"uint128\"},{\"internalType\":\"address\",\"name\":\"collateralType\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"distributor\",\"type\":\"address\"}],\"name\":\"registerRewardsDistributor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"poolId\",\"type\":\"uint128\"},{\"internalType\":\"address\",\"name\":\"collateralType\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"distributor\",\"type\":\"address\"}],\"name\":\"removeRewardsDistributor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"poolId\",\"type\":\"uint128\"},{\"internalType\":\"address\",\"name\":\"collateralType\",\"type\":\"address\"},{\"internalType\":\"uint128\",\"name\":\"accountId\",\"type\":\"uint128\"}],\"name\":\"updateRewards\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"oracleManagerAddress\",\"type\":\"address\"}],\"name\":\"configureOracleManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"k\",\"type\":\"bytes32\"}],\"name\":\"getConfig\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"v\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ccipSend\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ccipReceive\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ccipTokenPool\",\"type\":\"address\"}],\"name\":\"registerCcip\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"k\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"v\",\"type\":\"bytes32\"}],\"name\":\"setConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minDelegation\",\"type\":\"uint256\"}],\"name\":\"InsufficientDelegation\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidCollateralAmount\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"leverage\",\"type\":\"uint256\"}],\"name\":\"InvalidLeverage\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint128\",\"name\":\"accountId\",\"type\":\"uint128\"},{\"indexed\":true,\"internalType\":\"uint128\",\"name\":\"poolId\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"collateralType\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"leverage\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"DelegationUpdated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"accountId\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"poolId\",\"type\":\"uint128\"},{\"internalType\":\"address\",\"name\":\"collateralType\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"newCollateralAmountD18\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"leverage\",\"type\":\"uint256\"}],\"name\":\"delegateCollateral\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"accountId\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"poolId\",\"type\":\"uint128\"},{\"internalType\":\"address\",\"name\":\"collateralType\",\"type\":\"address\"}],\"name\":\"getPosition\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralValue\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"debt\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"collateralizationRatio\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"accountId\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"poolId\",\"type\":\"uint128\"},{\"internalType\":\"address\",\"name\":\"collateralType\",\"type\":\"address\"}],\"name\":\"getPositionCollateral\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"accountId\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"poolId\",\"type\":\"uint128\"},{\"internalType\":\"address\",\"name\":\"collateralType\",\"type\":\"address\"}],\"name\":\"getPositionCollateralRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"accountId\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"poolId\",\"type\":\"uint128\"},{\"internalType\":\"address\",\"name\":\"collateralType\",\"type\":\"address\"}],\"name\":\"getPositionDebt\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"poolId\",\"type\":\"uint128\"},{\"internalType\":\"address\",\"name\":\"collateralType\",\"type\":\"address\"}],\"name\":\"getVaultCollateral\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"poolId\",\"type\":\"uint128\"},{\"internalType\":\"address\",\"name\":\"collateralType\",\"type\":\"address\"}],\"name\":\"getVaultCollateralRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"poolId\",\"type\":\"uint128\"},{\"internalType\":\"address\",\"name\":\"collateralType\",\"type\":\"address\"}],\"name\":\"getVaultDebt\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]\n*/\n"
    },
    "contracts/interfaces/ITreasuryMarket.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.11 <0.9.0;\n\nimport \"./external/IV3CoreProxy.sol\";\n\n/**\n * @title Synthetix V3 Market allowing for a trusted entity to manage excess liquidity allocated to a liquidity pool.\n */\ninterface ITreasuryMarket {\n    struct DepositRewardConfiguration {\n        address token;\n        uint32 power;\n        uint32 duration;\n        uint128 percent;\n        bytes32 valueRatioOracle;\n        uint128 penaltyStart;\n        uint128 penaltyEnd;\n    }\n\n    struct LoanInfo {\n        uint64 startTime;\n        uint32 power;\n        uint32 duration;\n        uint128 loanAmount;\n    }\n\n    struct AuxTokenInfo {\n        uint128 amount;\n        uint64 lastUpdated;\n        uint32 timeInsufficient;\n        uint32 epoch;\n    }\n\n    struct AuxTokenRequiredRatio {\n        uint128 timestamp;\n        uint128 ratio;\n    }\n\n    //function v3System() external view returns (IV3CoreProxy);\n\n    /**\n     * @notice Emitted when a new target cratio has been set\n     */\n    event TargetCRatioSet(uint256 newCRatio);\n\n    /**\n     * @notice Emitted after an account has been registered into the treasury\n     */\n    event AccountSaddled(uint128 indexed accountId, uint256 collateralAmount, uint256 debtAssigned);\n\n    /**\n     * @notice Emitted when the artificial debt of the vault is modified to match the current c-ratio\n     */\n    event Rebalanced(int256 previousVaultDebt, int256 newVaultDebt);\n\n    /**\n     * @notice Emitted if an account was migrated but its c-ratio was insufficient for assigning debt in v3\n     */\n    event AccountUnsaddled(\n        uint128 indexed accountId,\n        uint256 collateralAmount,\n        uint256 debtUnassigned\n    );\n\n    /**\n     * @notice Emitted when a user's registered loan amount (which they must repay in full to withdraw their staked tokens) has been modified\n     */\n    event LoanAdjusted(\n        uint128 indexed accountId,\n        uint256 newLoanedAmount,\n        uint256 previousLoanedAmount\n    );\n\n    event AuxTokenDepositChanged(\n        uint128 indexed accountId,\n        uint256 newAuxTokenDeposit,\n        uint256 oldAuxTokenDeposit\n    );\n\n    /**\n     * @notice Emitted when a user received a reward for depositing and saddling into the treasury market\n     */\n    event DepositRewardIssued(\n        uint128 indexed accountId,\n        address indexed rewardToken,\n        LoanInfo depositedRewardData\n    );\n\n    /**\n     *\n     */\n    event DepositRewardRedeemed(\n        uint128 indexed accountId,\n        address indexed rewardToken,\n        uint256 rewardRedeemed,\n        uint256 penaltyPaid\n    );\n\n    /**\n     * @notice Emitted after a call to `updateAuxToken`\n     */\n    event UpdateAuxTokenRequirement(uint256 timestamp, uint256 requiredRatio);\n\n    /**\n     * @notice Emitted after a call to `treasuryMint`, where the owner has pulled funds from the market into the configured treasury address\n     */\n    event TreasuryMinted(uint256 amount);\n\n    /**\n     * @notice Emitted after a call to `setDebtDecayFunction`, where the settings for new and existing issued loans may be modified by the owner.\n     */\n    event DebtDecayUpdated(uint32 power, uint32 duration, uint128 startPenalty, uint128 endPenalty);\n\n    // copied from v3 core system for event recognition purposes\n    event MarketRegistered(\n        address indexed market,\n        uint128 indexed marketId,\n        address indexed sender\n    );\n\n    /**\n     * @notice\n     */\n    event TreasuryBurned(uint256 amount);\n\n    /**\n     * @notice Emitted when `registerMarket` is called, but the market has already been registered.\n     */\n    error MarketAlreadyRegistered(uint128 marketId);\n\n    /**\n     * @notice Emitted when a user is unable to continue because their cratio is below the minimum required to fund the treasury\n     */\n    error InsufficientCRatio(uint128 accountId, uint256 currentDebt, uint256 targetDebt);\n\n    /**\n     * @notice Emitted when the current operation cannot be completed because a loan is taken out on the account, and must be repaid in full\n     */\n    error OutstandingLoan(uint128 accountId, uint256 outstandingLoanAmount);\n\n    /**\n     * @notice Emitted when there is not enough clearable debt to allow the user that is unsaddling to exit\n     */\n    error InsufficientExcessDebt(int256 neededToRepay, int256 ableToRepay);\n\n    /**\n     * @notice Emitted when there is not enough deposited reward funds to cover the user's deposit in the contract\n     */\n    error InsufficientAvailableReward(\n        address rewardToken,\n        uint256 rewardedAmount,\n        uint256 availableToReward\n    );\n\n    /**\n     * @notice called by the owner to register this market with v3. This is an initialization call only.\n     */\n    function registerMarket() external returns (uint128 newMarketId);\n\n    /**\n     * @notice Called by any address to indicate that a user has increased their delegation in a pool and needs to have debt applied to their account\n     * @dev Unlike `unsaddle`, this function does not take ownership of the account token. This is because there is more than one way in which\n     * a user may become part of the pool (while there is only really one way in which a user may want to exit)\n     */\n    function saddle(uint128 accountId) external;\n\n    /**\n     * @dev Prior to calling this function, the account must have approved for transfer of the ERC721 account token to this address so that this market can repay the debt.\n     */\n    function unsaddle(uint128 accountId) external;\n\n    /**\n     * @dev Prior to calling this function, the account must have approved for transfer of the ERC721 account token to this address so that this market can repay the debt.\n     */\n    function adjustLoan(uint128 accountId, uint256 amount) external;\n\n    /**\n     * @dev Used by the treasury to deposit a token to be used for a rewards configuration. The deposited tokens can also be minted from\n     */\n    function fundForDepositReward(address token, uint256 amount) external returns (uint256);\n\n    /**\n     * @dev Used by the treasury to remove a token from a deposit rewards configuration.\n     */\n    function removeFromDepositReward(address token, uint256 amount) external returns (uint256);\n\n    /**\n     * @notice Called by the owner to mint available sUSD to the treasury.\n     */\n    function mintTreasury(uint256 amount) external;\n\n    /**\n     * @notice Called by the owner to burn sUSD into the market from the configured treasury\n     * @dev Before calling this function, ensure that the treasury has `approve`d transfer of at least `amount` sUSD to this address.\n     */\n    function burnTreasury(uint256 amount) external;\n\n    /**\n     * @notice Adjust the market's reported debt such that the c-ratio of the vault matches that of the configured targetCRatio, if possible\n     * @dev this function's implementation is automtaically called by other functions, such as `unsaddle`, `mintTreasury`, `burnTreasury`\n     */\n    function rebalance() external;\n\n    /**\n     * @notice Called by owner to change the c-ratio which will be rebalanced to for the vault.\n     */\n    function setTargetCRatio(uint256 ratio) external;\n\n    /**\n     * @notice Retrieves the current amount of loan remaining for the given accountId\n     * @param accountId The account to retrieve current debt for\n     */\n    function loanedAmount(uint128 accountId) external view returns (uint256);\n\n    /**\n     * @notice Retrieves the current amount of reward that the user would keep if they chose to withdraw immediately (not accounting for penalty)\n     * @param accountId The account to retrieve current debt for\n     */\n    function depositRewardAvailable(\n        uint128 accountId,\n        address rewardTokenAddress\n    ) external view returns (uint256);\n\n    /**\n     * @notice Returns the amount of penalty which must be repaid upon early repayment. This amount is on top of the amount of the principal repaid.\n     * @param accountId The account for which the repayment penalty is being calculated.\n     * @param targetDebt The target amount of debt to calculate the repayment penalty for.\n     * @return The calculated penalty amount.\n     */\n    function repaymentPenalty(\n        uint128 accountId,\n        uint256 targetDebt\n    ) external view returns (uint256);\n\n    /**\n     * @notice Calculates the penalty amount for early withdrawal. This penalty is added on top of the accrued rewards amount.\n     * @param accountId The account for which the deposit reward penalty is being calculated.\n     * @param depositRewardToken The token in which the deposit reward is denominated.\n     * @return The calculated penalty amount that is applied on top of accrued rewards.\n     */\n    function depositRewardPenalty(\n        uint128 accountId,\n        address depositRewardToken\n    ) external view returns (uint256);\n\n    /**\n     * @notice Called by the owner to change the parameters for new loans, and to modify the penalty payment in the case of early withdrawal during\n     * repayment plan\n     * @param power the curve of the debt repayment. for example, `1` is linear, `2` is quadratic, `3` is cubic, and etc. Only whole numbers supported. Up to 100\n     * @param time The number of seconds a loan should be active for. After `time` seconds have passed, the loan is fully repaid.\n     * @param startPenalty The percentage of paid debt which is returned on penalty upon early repayment. Applies at loan repayment time t=0 This value is linearly combined with the `endPenalty` to adjust teh resulting repayment amount.\n     * @param endPenalty The percentage of paid debt which is returned on penalty upon early repayment. Applies at loan repayment time t=time (the lengt hof the loan). Once the end of the loan has been reached, there is no penalty to be paid because the loan has been fully erased.\n     */\n    function setDebtDecayFunction(\n        uint32 power,\n        uint32 time,\n        uint128 startPenalty,\n        uint128 endPenalty\n    ) external;\n\n    /**\n     * @notice Called by the owner to set rewards distributed to new saddlers. Completely replaces any existing reward configurations already set\n     * @param newDrcs The reward configurations that should be set\n     */\n    function setDepositRewardConfigurations(DepositRewardConfiguration[] memory newDrcs) external;\n\n    /**\n     * @notice Called by the owner to require an auxillery token to be deposited in a configured rewards distribution contract, without which loan will not be automatically repaid\n     * @param newAuxTokenRewardsAddress How many aux tokens are required\n     * @param requiredRatio The ratio of tokens needed in the reward contract before the loan can be automtaically repaid\n     * @param resetTime The amount of time to comply before the account's jubilee is reset to the starting point\n     */\n    function updateAuxToken(\n        address newAuxTokenRewardsAddress,\n        uint256 requiredRatio,\n        uint256 resetTime\n    ) external returns (uint256);\n\n    /**\n     * @notice Called by the staking rewards contract to indicate that a staking operation has occured, and a change should be observed.\n     * @param accountId the account that performed an operation on the staking contract\n     */\n    function reportAuxToken(uint128 accountId) external;\n}\n"
    },
    "contracts/interfaces/ITreasuryStakingRewards.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.11 <0.9.0;\n\n// https://docs.synthetix.io/contracts/source/interfaces/istakingrewards\ninterface ITreasuryStakingRewards {\n    function balanceOf(uint128 accountId) external view returns (uint256);\n    function totalDeposited() external view returns (uint256);\n    function deposit(uint128 accountId, uint256 amount) external;\n}\n"
    },
    "contracts/TreasuryMarket.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.11 <0.9.0;\n\nimport {SafeCastU256} from \"@synthetixio/core-contracts/contracts/utils/SafeCast.sol\";\nimport {ParameterError} from \"@synthetixio/core-contracts/contracts/errors/ParameterError.sol\";\nimport {AccessError} from \"@synthetixio/core-contracts/contracts/errors/AccessError.sol\";\nimport \"@synthetixio/main/contracts/interfaces/external/IMarket.sol\";\n\nimport {UUPSImplementation} from \"@synthetixio/core-contracts/contracts/proxy/UUPSImplementation.sol\";\n\nimport \"./interfaces/ITreasuryMarket.sol\";\nimport \"./interfaces/ITreasuryStakingRewards.sol\";\n\nimport \"./interfaces/external/IOracleManagerProxy.sol\";\n\nimport \"@synthetixio/core-contracts/contracts/utils/ERC2771Context.sol\";\nimport \"@synthetixio/core-contracts/contracts/ownership/Ownable.sol\";\nimport \"@synthetixio/core-contracts/contracts/interfaces/IERC20.sol\";\nimport \"@synthetixio/core-contracts/contracts/interfaces/IERC721.sol\";\nimport \"@synthetixio/core-contracts/contracts/interfaces/IERC721Receiver.sol\";\n\nimport \"@synthetixio/core-contracts/contracts/utils/DecimalMath.sol\";\n\n/* solhint-disable numcast/safe-cast */\n\n/**\n * @notice A Synthetix V3 market to allocate delegated collateral towards a treasury. The treasury can then freely allocate and spend the USD tokens\n * mintable via the market.\n * The market effectively takes control of ownership of the debt of the pool, and becomes responsible for ensuring its success.\n * A loan mechanism is included which allows for existing users to migrate onto this pool without having to repay their debt.\n * This debt can be decayed over time via polynomial function.\n */\ncontract TreasuryMarket is ITreasuryMarket, Ownable, UUPSImplementation, IMarket, IERC721Receiver {\n    using SafeCastU256 for uint256;\n    using SafeCastI256 for int256;\n    using DecimalMath for uint256;\n\n    address public immutable treasury;\n    uint128 public immutable poolId;\n    address public immutable collateralToken;\n    IV3CoreProxy private immutable v3System;\n    IOracleManagerProxy private immutable oracleManager;\n\n    int256 public artificialDebt;\n\n    uint128 public marketId;\n\n    uint256 public targetCratio;\n\n    uint32 private debtDecayPower;\n    uint32 private debtDecayTime;\n\n    uint128 private debtDecayPenaltyStart;\n    uint128 private debtDecayPenaltyEnd;\n\n    uint256 lockedCollateral;\n\n    uint256 public totalSaddledCollateral;\n\n    mapping(uint128 => uint256) public saddledCollateral;\n    mapping(uint128 => LoanInfo) public loans;\n\n    mapping(address => uint256) public availableDepositRewards;\n\n    DepositRewardConfiguration[] public depositRewardConfigurations;\n\n    mapping(uint128 => mapping(address => LoanInfo)) public depositRewards;\n\n    ITreasuryStakingRewards private auxTokenRewardsAddress;\n    AuxTokenRequiredRatio[] private auxTokenRequiredRatios;\n    mapping(uint128 => AuxTokenInfo) private auxTokenInfo;\n    uint256 private auxResetTime;\n\n    // solhint-disable-next-line no-empty-blocks\n    constructor(\n        IV3CoreProxy v3SystemAddress,\n        IOracleManagerProxy oracleManagerAddress,\n        address treasuryAddress,\n        uint128 v3PoolId,\n        address collateralTokenAddress\n    ) Ownable(ERC2771Context._msgSender()) {\n        treasury = treasuryAddress;\n        v3System = v3SystemAddress;\n        oracleManager = oracleManagerAddress;\n        poolId = v3PoolId;\n\n        collateralToken = collateralTokenAddress;\n    }\n\n    /**\n     * @inheritdoc ITreasuryMarket\n     */\n    function registerMarket() external override onlyOwner returns (uint128 newMarketId) {\n        if (marketId != 0) {\n            revert MarketAlreadyRegistered(marketId);\n        }\n\n        newMarketId = v3System.registerMarket(address(this));\n        marketId = newMarketId;\n\n        // while we are here, also set the approval that we need for the core sysetm to pull USD from us\n        IERC20(v3System.getUsdToken()).approve(address(v3System), type(uint256).max);\n\n        // by default we set target c-ratio to 200%\n        targetCratio = 2 ether;\n\n        lockedCollateral = uint256(type(int256).max);\n    }\n\n    /**\n     * @inheritdoc IMarket\n     */\n    function reportedDebt(uint128 requestedMarketId) external view override returns (uint256 debt) {\n        if (requestedMarketId != marketId) {\n            return 0;\n        }\n\n        uint256 depositedDebt = v3System.getMarketCollateralValue(marketId);\n        int256 totalDebt = artificialDebt + int256(depositedDebt);\n\n        if (totalDebt < 0) {\n            // from a logic perspective, this branch should not be possible. But we dont want a revert if somehow this was negative.\n            return 0;\n        }\n\n        return uint256(totalDebt);\n    }\n\n    /**\n     * @inheritdoc IMarket\n     */\n    function name(uint128) external pure override returns (string memory) {\n        return \"Treasury Market\";\n    }\n\n    /**\n     * @inheritdoc IMarket\n     */\n    function minimumCredit(\n        uint128 /* requestedMarketId*/\n    ) external view override returns (uint256 lockedAmount) {\n        // we lock collateral here because it prevents any withdrawal of delegated collateral from the pool other than through `unsaddle`.\n        return lockedCollateral;\n    }\n\n    function setTargetCRatio(uint256 ratio) external override onlyOwner {\n        if (ratio <= v3System.getCollateralConfiguration(collateralToken).liquidationRatioD18) {\n            revert ParameterError.InvalidParameter(\"\", \"\");\n        }\n\n        targetCratio = ratio;\n        emit TargetCRatioSet(ratio);\n\n        _rebalance();\n    }\n\n    function saddle(uint128 accountId) external override {\n        // get current position information\n        (uint256 accountCollateral, uint256 accountCollateralValue, int256 accountDebt, ) = v3System\n            .getPosition(accountId, poolId, collateralToken);\n\n        if (accountCollateral == 0) {\n            revert ParameterError.InvalidParameter(\"accountId\", \"not delegated to pool\");\n        }\n\n        // get the actual collateralization of the pool now\n        (, uint256 vaultCollateralValue) = v3System.getVaultCollateral(poolId, collateralToken);\n        int256 vaultDebtValue = v3System.getVaultDebt(poolId, collateralToken);\n\n        uint256 newlySaddledValue = accountCollateralValue -\n            (saddledCollateral[accountId] * accountCollateralValue) /\n            accountCollateral;\n\n        // debt can only be added once an account joins the pool for the first time\n        int256 newlySaddledDebt = saddledCollateral[accountId] > 0 ? int256(0) : accountDebt;\n\n        // we want this newly added user to match the current collateralization status of the pool\n        int256 targetDebt = vaultDebtValue;\n        if (totalSaddledCollateral == 0) {\n            // if there is no artificial debt, it means that this is the first user and we should create a bunch\n            // to bring to low cratio\n            targetDebt = vaultCollateralValue.divDecimal(targetCratio).toInt();\n        } else if (vaultCollateralValue > accountCollateralValue) {\n            // we calculate what the c-ratio of the pool should have been prior to when the account added onto the pool\n            // this will allow for the correct debt to be set on this account to \"equalize\" with the other accounts\n            targetDebt =\n                (accountCollateralValue.toInt() * (vaultDebtValue - newlySaddledDebt)) /\n                (vaultCollateralValue - newlySaddledValue).toInt();\n        }\n\n        // cannot saddle account if its c-ratio is too low\n        // if an account has added additional collateral and their c-ratio is still too low to saddle, then its not harmful because they\n        // will simply have higher c-ratio than the rest of the system in this edge case.\n        if (accountDebt > targetDebt) {\n            revert InsufficientCRatio(accountId, accountDebt.toUint(), targetDebt.toUint());\n        }\n\n        uint256 debtIncrease = uint256(targetDebt - accountDebt);\n\n        artificialDebt += int256(debtIncrease);\n        v3System.associateDebt(marketId, poolId, collateralToken, accountId, debtIncrease);\n\n        // if a user has not been saddled before, any existing account debt becomes a loan on the user\n        if (saddledCollateral[accountId] == 0) {\n            if (accountDebt > 0) {\n                loans[accountId] = LoanInfo(\n                    uint64(block.timestamp),\n                    debtDecayPower,\n                    debtDecayTime,\n                    accountDebt.toUint().to128()\n                );\n                emit LoanAdjusted(accountId, accountDebt.toUint(), 0);\n            } else {\n                // this depositor is eligible for possible rewards\n                //DepositRewardConfiguration[] memory drc = depositRewardConfigurations;\n                for (uint256 i = 0; i < depositRewardConfigurations.length; i++) {\n                    DepositRewardConfiguration memory config = depositRewardConfigurations[i];\n                    uint256 rewardAmount = accountCollateral\n                        .mulDecimal(oracleManager.process(config.valueRatioOracle).price.toUint())\n                        .mulDecimal(config.percent);\n\n                    // stack was too deep to set this as a local variable. annoying.\n                    depositRewards[accountId][config.token] = LoanInfo(\n                        uint64(block.timestamp),\n                        config.power,\n                        config.duration,\n                        uint128(rewardAmount)\n                    );\n\n                    emit DepositRewardIssued(\n                        accountId,\n                        config.token,\n                        LoanInfo(\n                            uint64(block.timestamp),\n                            config.power,\n                            config.duration,\n                            uint128(rewardAmount)\n                        )\n                    );\n                }\n            }\n        }\n\n        totalSaddledCollateral += accountCollateral - saddledCollateral[accountId];\n        saddledCollateral[accountId] = accountCollateral;\n\n        emit AccountSaddled(accountId, accountCollateral, debtIncrease);\n    }\n\n    function unsaddle(uint128 accountId) external override {\n        if (saddledCollateral[accountId] == 0) {\n            revert ParameterError.InvalidParameter(\"accountId\", \"not saddled\");\n        }\n\n        address sender = ERC2771Context._msgSender();\n        IERC721 accountToken = IERC721(v3System.getAccountTokenAddress());\n        if (sender != accountToken.ownerOf(accountId)) {\n            revert AccessError.Unauthorized(sender);\n        }\n\n        uint256 currentLoan = _loanedAmount(\n            loans[accountId],\n            block.timestamp,\n            _loanActiveTime(\n                loans[accountId],\n                auxTokenInfo[accountId],\n                block.timestamp,\n                _loanLastUpdateTime(loans[accountId], auxTokenInfo[accountId])\n            )\n        );\n        if (currentLoan > 0) {\n            revert OutstandingLoan(accountId, currentLoan);\n        }\n\n        // transfer the account token from the user so that we can undelegate them and repay their debt\n        accountToken.safeTransferFrom(ERC2771Context._msgSender(), address(this), accountId);\n\n        // get current position information\n        (uint256 accountCollateral, , int256 accountDebt, ) = v3System.getPosition(\n            accountId,\n            poolId,\n            collateralToken\n        );\n\n        if (accountDebt > 0) {\n            (uint256 vaultCollateral, ) = v3System.getVaultCollateral(poolId, collateralToken);\n\n            if (accountCollateral == vaultCollateral) {\n                revert ParameterError.InvalidParameter(\n                    \"accountCollateral\",\n                    \"no surplus collateral to fund exit\"\n                );\n            }\n\n            uint256 neededToRepay = uint256(accountDebt);\n\n            if (int256(neededToRepay) > artificialDebt) {\n                revert InsufficientExcessDebt(int256(neededToRepay), artificialDebt);\n            }\n\n            artificialDebt -= int256(neededToRepay);\n            v3System.withdrawMarketUsd(marketId, address(this), neededToRepay);\n            v3System.deposit(accountId, v3System.getUsdToken(), neededToRepay);\n            v3System.burnUsd(accountId, poolId, collateralToken, neededToRepay);\n\n            auxTokenInfo[accountId] = AuxTokenInfo(0, 0, 0, 0);\n\n            emit AccountUnsaddled(accountId, accountCollateral, neededToRepay);\n        }\n\n        totalSaddledCollateral -= saddledCollateral[accountId];\n        saddledCollateral[accountId] = 0;\n\n        // undelegate collateral automatically for the user because they should no longer be part of this pool anyway now that they have been unsaddled\n        // before undelegating the collateral we have to unlock the minimumCredit because this is the only time undelegation should be possible.\n        lockedCollateral = 0;\n        v3System.delegateCollateral(accountId, poolId, collateralToken, 0, 1 ether);\n        lockedCollateral = uint256(type(int256).max);\n\n        _rebalance();\n\n        // distribute any deposit rewards to the user's account\n        uint256 timestamp = block.timestamp;\n        for (uint256 i = 0; i < depositRewardConfigurations.length; i++) {\n            DepositRewardConfiguration memory config = depositRewardConfigurations[i];\n            LoanInfo memory userDepositReward = depositRewards[accountId][config.token];\n            if (userDepositReward.loanAmount > 0) {\n                uint256 penaltyPaid = _repaymentPenalty(\n                    userDepositReward,\n                    0,\n                    _currentPenaltyRate(\n                        userDepositReward,\n                        config.penaltyStart,\n                        config.penaltyEnd,\n                        timestamp - userDepositReward.startTime\n                    ),\n                    timestamp,\n                    timestamp - userDepositReward.startTime\n                );\n\n                uint256 receivedAmount = userDepositReward.loanAmount -\n                    _loanedAmount(\n                        userDepositReward,\n                        timestamp,\n                        timestamp - userDepositReward.startTime\n                    ) -\n                    penaltyPaid;\n\n                if (receivedAmount > 0) {\n                    if (receivedAmount > availableDepositRewards[config.token]) {\n                        revert InsufficientAvailableReward(\n                            config.token,\n                            receivedAmount,\n                            availableDepositRewards[config.token]\n                        );\n                    }\n\n                    availableDepositRewards[config.token] -= receivedAmount;\n\n                    v3System.withdrawMarketCollateral(marketId, config.token, receivedAmount);\n                    v3System.deposit(accountId, config.token, receivedAmount);\n\n                    emit DepositRewardRedeemed(\n                        accountId,\n                        config.token,\n                        receivedAmount,\n                        penaltyPaid\n                    );\n                }\n            }\n        }\n\n        // return the account token to the user. we use the \"unsafe\" call here because the account is being returned to the same address\n        // it came from, so its probably ok and the account will be able to handle receipt of the NFT.\n        accountToken.transferFrom(address(this), sender, accountId);\n    }\n\n    function reportAuxToken(uint128 accountId) external {\n        if (saddledCollateral[accountId] == 0 || loans[accountId].loanAmount == 0) {\n            return;\n        }\n\n        uint256 auxTokenAmount = auxTokenRewardsAddress.balanceOf(accountId);\n\n        uint256 curAuxTokenDeposit = auxTokenInfo[accountId].amount;\n        uint256 loanLastUpdate = _loanLastUpdateTime(loans[accountId], auxTokenInfo[accountId]);\n\n        // update aux token deposit amount\n        auxTokenInfo[accountId].amount = auxTokenAmount.to128();\n\n        // update freeze status\n        if (\n            auxTokenRequiredRatios.length != 0 &&\n            curAuxTokenDeposit <\n            uint256(loans[accountId].loanAmount).mulDecimal(\n                auxTokenRequiredRatios[auxTokenRequiredRatios.length - 1].ratio\n            )\n        ) {\n            // if their loan hasnt been repaid by reset time, it gets completely reset\n\n            //emit UpdateAuxTokenRequirement(auxTokenRequiredRatios[firstInsufficientIdx].timestamp, 0);\n            emit UpdateAuxTokenRequirement(loanLastUpdate, block.timestamp);\n            if (block.timestamp - loanLastUpdate > auxResetTime) {\n                auxTokenInfo[accountId].timeInsufficient = (block.timestamp -\n                    loans[accountId].startTime).to32();\n            } else {\n                auxTokenInfo[accountId].timeInsufficient = (auxTokenInfo[accountId]\n                    .timeInsufficient +\n                    block.timestamp -\n                    loanLastUpdate).to32();\n            }\n        }\n\n        auxTokenInfo[accountId].lastUpdated = uint64(block.timestamp);\n        auxTokenInfo[accountId].epoch = uint32(auxTokenRequiredRatios.length);\n\n        emit AuxTokenDepositChanged(accountId, auxTokenAmount, curAuxTokenDeposit);\n    }\n\n    function repaymentPenalty(\n        uint128 accountId,\n        uint256 targetLoan\n    ) external view override returns (uint256) {\n        LoanInfo memory loan = loans[accountId];\n        AuxTokenInfo memory ati = auxTokenInfo[accountId];\n        uint256 timestamp = block.timestamp;\n        uint256 loanActiveTime = _loanActiveTime(\n            loan,\n            ati,\n            timestamp,\n            _loanLastUpdateTime(loan, ati)\n        );\n        return\n            _repaymentPenalty(\n                loan,\n                targetLoan,\n                _currentPenaltyRate(\n                    loan,\n                    debtDecayPenaltyStart,\n                    debtDecayPenaltyEnd,\n                    loanActiveTime\n                ),\n                timestamp,\n                loanActiveTime\n            );\n    }\n\n    function depositRewardPenalty(\n        uint128 accountId,\n        address depositRewardToken\n    ) external view override returns (uint256) {\n        DepositRewardConfiguration memory config;\n        bool configFound = false;\n        for (uint256 i = 0; i < depositRewardConfigurations.length; i++) {\n            if (depositRewardConfigurations[i].token == depositRewardToken) {\n                config = depositRewardConfigurations[i];\n                configFound = true;\n                break;\n            }\n        }\n        if (!configFound) {\n            return 0;\n        }\n        LoanInfo memory userDepositReward = depositRewards[accountId][config.token];\n        uint256 timestamp = block.timestamp;\n        return\n            _repaymentPenalty(\n                userDepositReward,\n                0,\n                _currentPenaltyRate(\n                    userDepositReward,\n                    config.penaltyStart,\n                    config.penaltyEnd,\n                    timestamp - userDepositReward.startTime\n                ),\n                timestamp,\n                timestamp - userDepositReward.startTime\n            );\n    }\n\n    function adjustLoan(uint128 accountId, uint256 amount) external override {\n        address sender = ERC2771Context._msgSender();\n        if (sender != IERC721(v3System.getAccountTokenAddress()).ownerOf(accountId)) {\n            revert AccessError.Unauthorized(ERC2771Context._msgSender());\n        }\n\n        LoanInfo memory loan = loans[accountId];\n        AuxTokenInfo memory ati = auxTokenInfo[accountId];\n        uint256 timestamp = block.timestamp;\n        uint256 currentLoan = _loanedAmount(\n            loan,\n            timestamp,\n            _loanActiveTime(loan, ati, block.timestamp, _loanLastUpdateTime(loan, ati))\n        );\n\n        if (amount > currentLoan) {\n            revert ParameterError.InvalidParameter(\"amount\", \"must be less than current loan\");\n        } else if (amount < currentLoan) {\n            uint256 loanActiveTime = _loanActiveTime(\n                loan,\n                ati,\n                timestamp,\n                _loanLastUpdateTime(loan, ati)\n            );\n\n            uint256 penaltyAmount = _repaymentPenalty(\n                loan,\n                amount,\n                _currentPenaltyRate(\n                    loan,\n                    debtDecayPenaltyStart,\n                    debtDecayPenaltyEnd,\n                    loanActiveTime\n                ),\n                timestamp,\n                loanActiveTime\n            );\n            // apply a penalty on whatever is repaid\n\n            v3System.depositMarketUsd(marketId, sender, currentLoan - amount + penaltyAmount);\n            _rebalance();\n        } else {\n            return; // nothing to do\n        }\n\n        // fractionally modify the original loan amount--this will continue the repayment schedule where the user left off without resetting it\n        loans[accountId].loanAmount = ((loans[accountId].loanAmount * amount) / currentLoan)\n            .to128();\n\n        emit LoanAdjusted(accountId, amount, currentLoan);\n    }\n\n    function loanedAmount(uint128 accountId) external view override returns (uint256) {\n        return\n            _loanedAmount(\n                loans[accountId],\n                block.timestamp,\n                _loanActiveTime(\n                    loans[accountId],\n                    auxTokenInfo[accountId],\n                    block.timestamp,\n                    _loanLastUpdateTime(loans[accountId], auxTokenInfo[accountId])\n                )\n            );\n    }\n\n    function depositRewardAvailable(\n        uint128 accountId,\n        address rewardTokenAddress\n    ) external view override returns (uint256) {\n        return\n            depositRewards[accountId][rewardTokenAddress].loanAmount -\n            _loanedAmount(\n                depositRewards[accountId][rewardTokenAddress],\n                block.timestamp,\n                block.timestamp - depositRewards[accountId][rewardTokenAddress].startTime\n            );\n    }\n\n    function setDebtDecayFunction(\n        uint32 power,\n        uint32 time,\n        uint128 startPenalty,\n        uint128 endPenalty\n    ) external override onlyOwner {\n        if (power > 100 || startPenalty > 1 ether || endPenalty > startPenalty) {\n            revert ParameterError.InvalidParameter(\"\", \"\");\n        }\n        debtDecayPower = power;\n        debtDecayTime = time;\n        debtDecayPenaltyStart = startPenalty;\n        debtDecayPenaltyEnd = endPenalty;\n\n        emit DebtDecayUpdated(power, time, startPenalty, endPenalty);\n    }\n\n    function setDepositRewardConfigurations(\n        DepositRewardConfiguration[] memory newDrcs\n    ) external override onlyOwner {\n        address previousDrc = address(0);\n\n        DepositRewardConfiguration[] memory oldDrcs = depositRewardConfigurations;\n\n        uint256 j;\n        for (uint256 i = 0; i < newDrcs.length; i++) {\n            if (newDrcs[i].token <= previousDrc) {\n                revert ParameterError.InvalidParameter(\"\", \"\");\n            }\n            previousDrc = newDrcs[i].token;\n\n            // detect tokens that are being removed\n            while (j < oldDrcs.length && newDrcs[i].token > oldDrcs[j].token) {\n                // removing a reward token from the market\n                // verify that this token is not having any available rewards\n                if (availableDepositRewards[oldDrcs[j].token] > 0) {\n                    revert ParameterError.InvalidParameter(\n                        \"newDrcs\",\n                        \"removes existing reward token\"\n                    );\n                }\n\n                j++;\n            }\n\n            if (\n                j < depositRewardConfigurations.length &&\n                newDrcs[i].token == depositRewardConfigurations[j].token\n            ) {\n                j++;\n            }\n\n            if (depositRewardConfigurations.length <= i) {\n                depositRewardConfigurations.push();\n            }\n            depositRewardConfigurations[i] = newDrcs[i];\n\n            // ensure that the v3 core system can pull funds from us\n            IERC20(newDrcs[i].token).approve(address(v3System), type(uint256).max);\n        }\n\n        for (; j < oldDrcs.length; j++) {\n            // removing a reward token from the market\n            // verify that this token is not having any available rewards\n            if (availableDepositRewards[oldDrcs[j].token] > 0) {\n                revert ParameterError.InvalidParameter(\"newDrcs\", \"removes existing reward token\");\n            }\n        }\n\n        uint256 popped = depositRewardConfigurations.length - newDrcs.length;\n        for (uint256 i = 0; i < popped; i++) {\n            depositRewardConfigurations.pop();\n        }\n    }\n\n    function rebalance() external override {\n        _rebalance();\n    }\n\n    function fundForDepositReward(\n        address token,\n        uint256 amount\n    ) external override returns (uint256) {\n        IERC20(token).transferFrom(ERC2771Context._msgSender(), address(this), amount);\n        v3System.depositMarketCollateral(marketId, token, amount);\n        availableDepositRewards[token] += amount;\n\n        return availableDepositRewards[token];\n    }\n\n    function removeFromDepositReward(\n        address token,\n        uint256 amount\n    ) external override onlyTreasury returns (uint256) {\n        if (availableDepositRewards[token] < amount) {\n            revert ParameterError.InvalidParameter(\"amount\", \"greater than available rewards\");\n        }\n        v3System.withdrawMarketCollateral(marketId, token, amount);\n        IERC20(token).transfer(ERC2771Context._msgSender(), amount);\n\n        availableDepositRewards[token] -= amount;\n\n        return availableDepositRewards[token];\n    }\n\n    function updateAuxToken(\n        address newAuxTokenRewardsAddress,\n        uint256 requiredRatio,\n        uint256 resetTime\n    ) external override onlyOwner returns (uint256) {\n        auxTokenRewardsAddress = ITreasuryStakingRewards(newAuxTokenRewardsAddress);\n        auxTokenRequiredRatios.push(\n            AuxTokenRequiredRatio(uint128(block.timestamp), requiredRatio.to128())\n        );\n\n        auxResetTime = resetTime;\n\n        emit UpdateAuxTokenRequirement(block.timestamp, requiredRatio);\n    }\n\n    function mintTreasury(uint256 amount) external override onlyTreasury {\n        if (amount > uint256(artificialDebt)) {\n            revert InsufficientExcessDebt(int256(amount), artificialDebt);\n        }\n\n        v3System.withdrawMarketUsd(marketId, treasury, amount);\n        emit TreasuryMinted(amount);\n        _rebalance();\n    }\n\n    function burnTreasury(uint256 amount) external override onlyTreasury {\n        v3System.depositMarketUsd(marketId, treasury, amount);\n        emit TreasuryBurned(amount);\n        _rebalance();\n    }\n\n    /**\n     * @inheritdoc IERC165\n     */\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public view virtual override(IERC165) returns (bool) {\n        return true;\n        /*interfaceId == type(IMarket).interfaceId ||\n            interfaceId == type(IERC721Receiver).interfaceId ||\n            interfaceId == this.supportsInterface.selector;*/\n    }\n\n    function upgradeTo(address to) external onlyOwner {\n        _upgradeTo(to);\n    }\n\n    /**\n     * @inheritdoc IERC721Receiver\n     * @dev This function is required so that self transfer in `unsaddle` works as expected.\n     */\n    function onERC721Received(\n        address,\n        /*operator*/\n        address,\n        /*from*/\n        uint256,\n        /*tokenId*/\n        bytes memory /*data*/\n    ) external pure override returns (bytes4) {\n        return IERC721Receiver.onERC721Received.selector;\n    }\n\n    function _rebalance() internal {\n        if (totalSaddledCollateral == 0) {\n            return;\n        }\n\n        (, uint256 vaultCollateralValue) = v3System.getVaultCollateral(poolId, collateralToken);\n        int256 vaultDebtValue = v3System.getVaultDebt(poolId, collateralToken);\n\n        int256 targetDebt = vaultCollateralValue.divDecimal(targetCratio).toInt();\n\n        if (artificialDebt > vaultDebtValue - targetDebt) {\n            artificialDebt += targetDebt - vaultDebtValue;\n        } else {\n            // set the artificial debt to the lowest valid value\n            targetDebt = vaultDebtValue - artificialDebt;\n            artificialDebt = 0;\n        }\n\n        emit Rebalanced(vaultDebtValue, targetDebt);\n    }\n\n    function _decimalPow(uint256 base, uint256 exp) internal pure returns (uint256) {\n        uint256 cur = 1e18;\n        for (uint256 i = 0; i < exp; i++) {\n            cur = cur.mulDecimal(base);\n        }\n\n        return cur;\n    }\n\n    function _loanedAmount(\n        LoanInfo memory loan,\n        uint256 timestamp,\n        uint256 loanActiveTime\n    ) internal pure returns (uint256) {\n        if (loan.power == 0 || timestamp <= loan.startTime) {\n            return loan.loanAmount;\n        } else if (loanActiveTime >= loan.duration) {\n            return 0;\n        }\n\n        // this function is a polynomial decay\n        // model if `power` is 2 and `duration` is 365 https://www.wolframalpha.com/input?i=graph+1-%28x%2F365%29%5E2+from+0+to+365\n        return\n            loan.loanAmount -\n            uint256(loan.loanAmount).mulDecimal(\n                _decimalPow(loanActiveTime.divDecimal(loan.duration), loan.power)\n            );\n    }\n\n    function _loanActiveTime(\n        LoanInfo memory loan,\n        AuxTokenInfo memory ati,\n        uint256 timestamp,\n        uint256 auxLastUpdated\n    ) internal view returns (uint256) {\n        uint256 curAuxTokenDeposit = ati.amount;\n        bool currentlySufficient = auxTokenRequiredRatios.length > 0\n            ? curAuxTokenDeposit >=\n                uint256(loan.loanAmount).mulDecimal(\n                    auxTokenRequiredRatios[auxTokenRequiredRatios.length - 1].ratio\n                )\n            : true;\n\n        // if the loan has not been active for longer than the reset time, the loan should be reset back to the beginning\n        if (!currentlySufficient && timestamp - auxLastUpdated > auxResetTime) {\n            return 0;\n        }\n\n        uint256 subs = (currentlySufficient ? 0 : timestamp - auxLastUpdated) +\n            ati.timeInsufficient +\n            loan.startTime;\n\n        if (timestamp <= subs) {\n            return 0;\n        }\n\n        return timestamp - subs;\n    }\n\n    function _loanLastUpdateTime(\n        LoanInfo memory loan,\n        AuxTokenInfo memory ati\n    ) internal view returns (uint256) {\n        uint256 firstInsufficientIdx = ati.epoch;\n        for (; firstInsufficientIdx < auxTokenRequiredRatios.length; firstInsufficientIdx++) {\n            if (\n                ati.amount <\n                uint256(loan.loanAmount).mulDecimal(\n                    auxTokenRequiredRatios[firstInsufficientIdx].ratio\n                )\n            ) {\n                break;\n            }\n        }\n        return\n            firstInsufficientIdx < auxTokenRequiredRatios.length\n                ? auxTokenRequiredRatios[firstInsufficientIdx].timestamp\n                : ati.lastUpdated;\n    }\n\n    function _repaymentPenalty(\n        LoanInfo memory loan,\n        uint256 targetLoan,\n        uint256 currentPenalty,\n        uint256 timestamp,\n        uint256 loanActiveTime\n    ) internal pure returns (uint256) {\n        uint256 currentLoan = _loanedAmount(loan, timestamp, loanActiveTime);\n        if (targetLoan >= currentLoan || currentPenalty == 0) {\n            return 0;\n        }\n\n        uint256 loanCompletionPercentage = loan.duration > 0\n            ? loanActiveTime.divDecimal(loan.duration)\n            : 1 ether;\n\n        // the penalty subtracts a certain percentage from what has been decayed. for example, assuming 25% penalty:\n        // 1. starting with a $1000 loan over 40 days\n        // 2. 16 days in, it decays to a $600 loan\n        // 3. At 16 days in, user chooses to repay half. so $300 of the loan should remain\n        // 4. The penalty is 25% at time of repayment, so 25% $400 is $100, so this plus the amount of the principal\n        // to repay ($300) for a total of $400 is paid in total to repay $300\n        if (loanCompletionPercentage < 1 ether) {\n            return\n                (loan.loanAmount - currentLoan).mulDecimal(currentPenalty).mulDecimal(\n                    1 ether - targetLoan.divDecimal(currentLoan)\n                );\n        }\n    }\n\n    function _currentPenaltyRate(\n        LoanInfo memory loan,\n        uint256 penaltyStart,\n        uint256 penaltyEnd,\n        uint256 loanActiveTime\n    ) internal pure returns (uint256) {\n        uint256 loanCompletionPercentage = loan.duration > 0\n            ? loanActiveTime.divDecimal(loan.duration)\n            : 0;\n\n        if (loanCompletionPercentage >= 1 ether) {\n            return penaltyEnd;\n        }\n\n        return\n            uint256(penaltyStart).mulDecimal(1 ether - loanCompletionPercentage) +\n            uint256(penaltyEnd).mulDecimal(loanCompletionPercentage);\n    }\n\n    modifier onlyTreasury() {\n        // solhint-disable-next-line meta-transactions/no-msg-sender\n        if (msg.sender != treasury) {\n            // solhint-disable-next-line meta-transactions/no-msg-sender\n            revert AccessError.Unauthorized(msg.sender);\n        }\n\n        _;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}