{{
  "language": "Solidity",
  "sources": {
    "src/MaseerOne.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Copyright (c) 2025 Maseer LTD\n//\n// This file is subject to the Business Source License 1.1.\n// You may not use this file except in compliance with the License.\n//\n// You may obtain a copy of the License at:\n// https://github.com/Maseer-LTD/maseer-one/blob/master/LICENSE\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\npragma solidity ^0.8.28;\n\nimport {MaseerToken} from \"./MaseerToken.sol\";\n\ninterface Gem {\n    function transfer(address usr, uint256 wad) external returns (bool);\n    function transferFrom(address src, address dst, uint256 wad) external returns (bool);\n    function balanceOf(address account) external view returns (uint256);\n}\n\ninterface Cop {\n    function pass(address usr) external view returns (bool);\n}\n\ninterface Pip {\n    function read() external view returns (uint256);\n}\n\ninterface Act {\n    function mintable() external view returns (bool);\n    function burnable() external view returns (bool);\n    function cooldown() external view returns (uint256);\n    function capacity() external view returns (uint256);\n    function mintcost(uint256) external view returns (uint256);\n    function burncost(uint256) external view returns (uint256);\n    function terms() external view returns (string memory);\n}\n\ninterface Adm {\n    function issuer(address usr) external view returns (bool);\n}\n\n// ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::\n// :==============================================================:\n// :==============================================================:\n// :==============================================================:\n// :==============================================================:\n// :==============================================================:\n// :============@@@@@@@@@@@=@@@@@@==@@@@@@========================:\n// :===========@@.........@@@.....@@@....@========================:\n// :===========@........@@@.....@@@....@@@========================:\n// :===========@......@@@.....@@@.....@@@=========================:\n// :===========@....@@@:....@@@.....@@@===========================:\n// :===========@..:@@@....@@@-....@@@=============================:\n// :===========@:@@@....@@@@....@@@===============================:\n// :===========@@@....@@@@....@@@=================================:\n// :===========@.....@@@....@@@===================================:\n// :===========@...@@@....:@@@====================================:\n// :===========@:@@@.....@@@====@@@@@@@@@@====@@@@@@@@@===========:\n// :===========@@@.....@@@======@........@+==@@.......@===========:\n// :===========@:....@@@========@........@@==@........@===========:\n// :===========@...@@@==========@.........@=@@........@===========:\n// :===========@.@@@============@.........@@@.........@===========:\n// :===========@@@==============@..........@..........@===========:\n// :============================@..........#..........@===========:\n// :============================@.....................@===========:\n// :============================@.....................@===========:\n// :============================@......@.......@......@===========:\n// :============================@......@@......@......@===========:\n// :============================@......@@.....@@......@===========:\n// :============================*@@@@@@*#@@@@@#*@@@@@@*===========:\n// :==============================================================:\n// :==============================================================:\n// :==============================================================:\n// :==============================================================:\n// :==============================================================:\n// ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::\ncontract MaseerOne is MaseerToken {\n\n    address immutable public gem;  // Purchase token\n    address immutable public pip;  // Oracle price feed\n    address immutable public act;  // Market timing feed\n    address immutable public adm;  // Issuer control\n    address immutable public cop;  // Compliance feed\n    address immutable public flo;  // Output conduit\n\n    uint256                         public totalPending;\n    uint256                         public redemptionCount;\n    mapping (uint256 => Redemption) public redemptions;\n\n    struct Redemption {\n        uint256 amount;\n        address redeemer;\n        uint96  date;\n    }\n\n    event ContractCreated(\n        address indexed creator,\n        uint256 indexed price,\n        uint256 indexed amount\n    );\n    event ContractRedemption(\n        uint256 indexed id,\n        uint256 indexed date,\n        address indexed redeemer,\n        uint256         amount\n    );\n    event ClaimProcessed(\n        uint256 indexed id,\n        address indexed claimer,\n        uint256 indexed amount\n    );\n    event Settled(\n        address indexed conduit,\n        uint256 indexed amount\n    );\n    event Issued(\n        address indexed issuer,\n        uint256 indexed amount\n    );\n    event Smelted(\n        address indexed smelter,\n        uint256 indexed amount\n    );\n\n    error NotAuthorized(address usr);\n    error TransferToContract();\n    error TransferToZeroAddress();\n    error TransferFailed();\n    error MarketClosed();\n    error InvalidPrice();\n    error ExceedsCap();\n    error ClaimableAfter(uint256 time);\n    error NoPendingClaim();\n    error DustThreshold(uint256 min);\n\n    constructor(\n        address gem_,\n        address pip_,\n        address act_,\n        address adm_,\n        address cop_,\n        address flo_,\n        string memory name_,\n        string memory symbol_\n    ) MaseerToken(name_, symbol_) {\n        gem = gem_;\n        pip = pip_;\n        act = act_;\n        adm = adm_;\n        cop = cop_;\n        flo = flo_;\n    }\n\n    modifier pass(address usr_) {\n        if (!_canPass(usr_)) revert NotAuthorized(usr_);\n        _;\n    }\n\n    modifier mintlive() {\n        if (!mintable()) revert MarketClosed();\n        _;\n    }\n\n    modifier burnlive() {\n        if (!burnable()) revert MarketClosed();\n        _;\n    }\n\n    modifier issuer() {\n        if (!Adm(adm).issuer(msg.sender)) revert NotAuthorized(msg.sender);\n        _;\n    }\n\n    function mint(uint256 amt) external mintlive pass(msg.sender) returns (uint256 _out) {\n        // Oracle price check\n        uint256 _unit = _read();\n\n        // Revert if the price is zero\n        if (_unit == 0) revert InvalidPrice();\n\n        // Adjust the price for minting\n        _unit = _mintcost(_unit);\n\n        // Assert minimum purchase amount of one unit to avoid dust\n        if (amt < _unit) revert DustThreshold(_unit);\n\n        // Calculate the mint amount\n        _out = _wdiv(amt, _unit);\n\n        // Revert if the total supply after mint exceeds the cap\n        if (totalSupply + _out > _capacity()) revert ExceedsCap();\n\n        // Transfer tokens in\n        _safeTransferFrom(gem, msg.sender, address(this), amt);\n\n        // Mint the tokens\n        _mint(msg.sender, _out);\n\n        // Emit contract event\n        emit ContractCreated(msg.sender, _unit, _out);\n    }\n\n    function redeem(uint256 amt) external burnlive pass(msg.sender) returns (uint256 _id) {\n        // Assert minimum redemption amount of one token to avoid dust\n        if (amt < WAD) revert DustThreshold(WAD);\n\n        // Oracle price check\n        uint256 _unit = _read();\n\n        // Revert if the price is zero\n        if (_unit == 0) revert InvalidPrice();\n\n        // Adjust the price for redemption\n        _unit = _burncost(_unit);\n\n        // Calculate the redemption amount\n        uint256 _claim = _wmul(amt, _unit);\n\n        // Add to the total pending redemptions\n        totalPending += _claim;\n\n        // Assign a new redemption ID\n        _id = redemptionCount++;\n\n        // Calculate the redemption date\n        uint96 _time = uint96(block.timestamp + _cooldown());\n\n        // Store the redemption\n        redemptions[_id] = Redemption({\n            amount:   _claim,\n            redeemer: msg.sender,\n            date:     _time\n        });\n\n        // Burn the tokens\n        _burn(msg.sender, amt);\n\n        // Emit contract event\n        emit ContractRedemption(_id, _time, msg.sender, _claim);\n    }\n\n    function exit(uint256 id) external pass(msg.sender) returns (uint256 _out) {\n        Redemption storage _redemption = redemptions[id];\n\n        uint256 _time = _redemption.date;\n\n        // Check if the claim is past the redemption period\n        if (_time > block.timestamp) revert ClaimableAfter(_time);\n        if (_time == 0) revert NoPendingClaim();\n\n        uint256 _amt = _redemption.amount;\n        uint256 _bal = _gemBalance();\n        // User can claim the amount owed or current available balance\n        _out = (_amt < _bal) ? _amt : _bal;\n\n        // Decrement the total pending redemptions\n        // Decrement the user's pending redemptions\n        unchecked {\n            totalPending -= _out;\n            _redemption.amount -= _out;\n        }\n\n        // Transfer the tokens\n        _safeTransfer(gem, _redemption.redeemer, _out);\n\n        // Emit claim\n        emit ClaimProcessed(id, _redemption.redeemer, _out);\n    }\n\n    function settle() external pass(msg.sender) returns (uint256 _out) {\n        // Get the gem balance\n        uint256 _bal = _gemBalance();\n        uint256 _pnd = totalPending;\n\n        // Return 0 if the balance is reserved for pending claims\n        if (_bal <= _pnd) return 0;\n\n        // Calculate the balance after pending redemptions\n        unchecked {\n            _out = _bal - _pnd;\n        }\n\n        // Send the remaining balance to the output conduit\n        _safeTransfer(gem, flo, _out);\n\n        // Emit settle\n        emit Settled(flo, _out);\n    }\n\n    // Issuer function for minting assets or bridging\n    function issue(uint256 amt) external issuer pass(msg.sender) {\n        _mint(msg.sender, amt);\n\n        emit Issued(msg.sender, amt);\n    }\n\n    // Issuer smelting function to burn for a specific user\n    function smelt(address usr, uint256 amt) external issuer pass(msg.sender) {\n        _burn(usr, amt);\n\n        emit Smelted(usr, amt);\n    }\n\n    // User-level smelting function for burning tokens\n    function smelt(uint256 amt) external pass(msg.sender) {\n        _burn(msg.sender, amt);\n\n        emit Smelted(msg.sender, amt);\n    }\n\n    // View functions\n\n    function mintable() public view returns (bool) {\n        return Act(act).mintable();\n    }\n\n    function burnable() public view returns (bool) {\n        return Act(act).burnable();\n    }\n\n    function canPass(address usr) external view returns (bool) {\n        return _canPass(usr);\n    }\n\n    function cooldown() external view returns (uint256) {\n        return _cooldown();\n    }\n\n    function navprice() external view returns (uint256) {\n        return _read();\n    }\n\n    function mintcost() external view returns (uint256) {\n        return _mintcost(_read());\n    }\n\n    function burncost() external view returns (uint256) {\n        return _burncost(_read());\n    }\n\n    function capacity() external view returns (uint256) {\n        return _capacity();\n    }\n\n    function terms() external view returns (string memory) {\n        return Act(act).terms();\n    }\n\n    function redemptionAddr(uint256 id) external view returns (address) {\n        return redemptions[id].redeemer;\n    }\n\n    function redemptionDate(uint256 id) external view returns (uint256) {\n        return redemptions[id].date;\n    }\n\n    function redemptionAmount(uint256 id) external view returns (uint256) {\n        return redemptions[id].amount;\n    }\n\n    function unsettled() external view returns (uint256) {\n        uint256 _bal = _gemBalance();\n        return (_bal < totalPending) ? 0 : _bal - totalPending;\n    }\n\n    function obligated() external view returns (uint256) {\n        uint256 _bal = _gemBalance();\n        return (_bal > totalPending) ? 0 : totalPending - _bal;\n    }\n\n    // Token overrides for compliance\n\n    function approve(address usr) public override pass(msg.sender) pass(usr) returns (bool) {\n        return super.approve(usr);\n    }\n\n    function approve(address usr, uint256 wad) public override pass(msg.sender) pass(usr) returns (bool) {\n        return super.approve(usr, wad);\n    }\n\n    function transfer(address dst, uint256 wad) public override pass(msg.sender) pass(dst) returns (bool) {\n        if (dst == address(this)) revert TransferToContract();\n        return super.transfer(dst, wad);\n    }\n\n    function transferFrom(address src, address dst, uint256 wad) public override pass(msg.sender) pass(src) pass(dst) returns (bool) {\n        if (dst == address(this)) revert TransferToContract();\n        return super.transferFrom(src, dst, wad);\n    }\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8   v,\n        bytes32 r,\n        bytes32 s\n    ) public override pass(msg.sender) pass(owner) pass(spender) {\n        super.permit(owner, spender, value, deadline, v, r, s);\n    }\n\n    // Internal utility functions\n\n    function _canPass(address _usr) internal view returns (bool) {\n        return Cop(cop).pass(_usr);\n    }\n\n    function _cooldown() internal view returns (uint256) {\n        return Act(act).cooldown();\n    }\n\n    function _mintcost(uint256 _price) internal view returns (uint256) {\n        return Act(act).mintcost(_price);\n    }\n\n    function _burncost(uint256 _price) internal view returns (uint256) {\n        return Act(act).burncost(_price);\n    }\n\n    function _capacity() internal view returns (uint256) {\n        return Act(act).capacity();\n    }\n\n    function _read() internal view returns (uint256) {\n        return Pip(pip).read();\n    }\n\n    function _gemBalance() internal view returns (uint256) {\n        return Gem(gem).balanceOf(address(this));\n    }\n\n    function _wdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = (x * WAD) / y;\n    }\n\n    function _wmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = (x * y) / WAD;\n    }\n\n    function _safeTransfer(address _token, address _to, uint256 _amt) internal {\n        (bool success, bytes memory data) = _token.call(abi.encodeWithSelector(Gem.transfer.selector, _to, _amt));\n        if (!success || (data.length > 0 && abi.decode(data, (bool)) == false)) revert TransferFailed();\n    }\n\n    function _safeTransferFrom(address _token, address _from, address _to, uint256 _amt) internal {\n        (bool success, bytes memory data) = _token.call(abi.encodeWithSelector(Gem.transferFrom.selector, _from, _to, _amt));\n        if (!success || (data.length > 0 && abi.decode(data, (bool)) == false)) revert TransferFailed();\n    }\n}\n"
    },
    "src/MaseerToken.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Copyright (c) 2025 Maseer LTD\n//\n// This file is subject to the Business Source License 1.1.\n// You may not use this file except in compliance with the License.\n//\n// You may obtain a copy of the License at:\n// https://github.com/Maseer-LTD/maseer-one/blob/master/LICENSE\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\npragma solidity ^0.8.28;\n\nabstract contract MaseerToken {\n\n    // ERC-20\n    uint256                                           public totalSupply;\n    mapping (address => uint256)                      public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n    string                                            public name;\n    string                                            public symbol;\n    uint8                                    constant public decimals = 18; // standard token precision.\n\n    uint256                                  constant internal WAD = 1e18;\n\n    // EIP-2612\n    bytes32 immutable         internal INITIAL_DOMAIN_SEPARATOR;\n    uint256 immutable         internal INITIAL_CHAIN_ID;\n    mapping(address => uint256) public nonces;\n\n    constructor(string memory name_, string memory symbol_) {\n        name   = name_;\n        symbol = symbol_;\n\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = _computeDomainSeparator();\n    }\n\n    event Approval(address indexed src, address indexed usr, uint256 wad);\n    event Transfer(address indexed src, address indexed dst, uint256 wad);\n\n    error InvalidChain(uint256 expected, uint256 actual);\n    error PermitDeadlineExpired(uint256 deadline, uint256 actual);\n    error InvalidSigner(address recovered, address expected);\n\n    function approve(address usr) public virtual returns (bool) {\n        return approve(usr, type(uint256).max);\n    }\n\n    function approve(address usr, uint256 wad) public virtual returns (bool) {\n        allowance[msg.sender][usr] = wad;\n\n        emit Approval(msg.sender, usr, wad);\n\n        return true;\n    }\n\n    function transfer(address dst, uint256 wad) public virtual returns (bool) {\n        balanceOf[msg.sender] -= wad;\n\n        // Cannot overflow because balance\n        //   can't exceed totalSupply\n        unchecked {\n            balanceOf[dst] += wad;\n        }\n\n        emit Transfer(msg.sender, dst, wad);\n\n        return true;\n    }\n\n    function transferFrom(address src, address dst, uint256 wad)\n        public virtual\n        returns (bool)\n    {\n        uint256 _allowance = allowance[src][msg.sender];\n        if (_allowance != type(uint256).max) {\n            allowance[src][msg.sender] = _allowance - wad;\n        }\n\n        balanceOf[src] -= wad;\n        balanceOf[dst] += wad;\n\n        emit Transfer(src, dst, wad);\n\n        return true;\n    }\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8   v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        if (deadline < block.timestamp) revert PermitDeadlineExpired(deadline, block.timestamp);\n\n        // Unchecked because the owner's nonce is uint256 which cannot realistically overflow.\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n\n            if (recoveredAddress == address(0) || recoveredAddress != owner) revert InvalidSigner(recoveredAddress, owner);\n\n            allowance[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function _mint(address usr, uint256 wad) internal {\n        totalSupply += wad;\n        // Cannot overflow\n        unchecked {\n            balanceOf[usr] += wad;\n        }\n        emit Transfer(address(0), usr, wad);\n    }\n\n    function _burn(address usr, uint256 wad) internal {\n        balanceOf[usr] -= wad;\n        // Cannot overflow\n        unchecked {\n            totalSupply -= wad;\n        }\n        emit Transfer(usr, address(0), wad);\n    }\n\n    function DOMAIN_SEPARATOR() public view returns (bytes32) {\n        return (block.chainid == INITIAL_CHAIN_ID) ? INITIAL_DOMAIN_SEPARATOR : _computeDomainSeparator();\n    }\n\n    function _computeDomainSeparator() internal view returns (bytes32) {\n        return keccak256(abi.encode(\n            keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n            keccak256(bytes(name)),\n            keccak256(bytes(\"1\")),\n            block.chainid,\n            address(this)\n        ));\n    }\n}\n"
    }
  },
  "settings": {
    "remappings": [
      "forge-std/=lib/forge-std/src/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 21000
    },
    "metadata": {
      "useLiteralContent": false,
      "bytecodeHash": "ipfs",
      "appendCBOR": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "evmVersion": "cancun",
    "viaIR": false,
    "libraries": {}
  }
}}