{{
  "language": "Solidity",
  "sources": {
    "src/flat/MainnetTakerSubmittedFlat.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.25 >=0.6.2 >=0.8.25 ^0.8.0 ^0.8.25;\n\n// lib/forge-std/src/interfaces/IERC20.sol\n\n/// @dev Interface of the ERC20 standard as defined in the EIP.\n/// @dev This includes the optional name, symbol, and decimals metadata.\ninterface IERC20 {\n    /// @dev Emitted when `value` tokens are moved from one account (`from`) to another (`to`).\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /// @dev Emitted when the allowance of a `spender` for an `owner` is set, where `value`\n    /// is the new allowance.\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /// @notice Returns the amount of tokens in existence.\n    function totalSupply() external view returns (uint256);\n\n    /// @notice Returns the amount of tokens owned by `account`.\n    function balanceOf(address account) external view returns (uint256);\n\n    /// @notice Moves `amount` tokens from the caller's account to `to`.\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /// @notice Returns the remaining number of tokens that `spender` is allowed\n    /// to spend on behalf of `owner`\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /// @notice Sets `amount` as the allowance of `spender` over the caller's tokens.\n    /// @dev Be aware of front-running risks: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /// @notice Moves `amount` tokens from `from` to `to` using the allowance mechanism.\n    /// `amount` is then deducted from the caller's allowance.\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n\n    /// @notice Returns the name of the token.\n    function name() external view returns (string memory);\n\n    /// @notice Returns the symbol of the token.\n    function symbol() external view returns (string memory);\n\n    /// @notice Returns the decimals places of the token.\n    function decimals() external view returns (uint8);\n}\n\n// lib/permit2/src/interfaces/IEIP712.sol\n\ninterface IEIP712 {\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n\n// src/Context.sol\n\nabstract contract AbstractContext {\n    function _msgSender() internal view virtual returns (address);\n\n    function _msgData() internal view virtual returns (bytes calldata);\n\n    function _isForwarded() internal view virtual returns (bool);\n}\n\nabstract contract Context is AbstractContext {\n    function _msgSender() internal view virtual override returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual override returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _isForwarded() internal view virtual override returns (bool) {\n        return false;\n    }\n}\n\n// src/IERC721Owner.sol\n\ninterface IERC721Owner {\n    function ownerOf(uint256) external view returns (address);\n}\n\n// src/allowanceholder/IAllowanceHolder.sol\n\ninterface IAllowanceHolder {\n    /// @notice Executes against `target` with the `data` payload. Prior to execution, token permits\n    ///         are temporarily stored for the duration of the transaction. These permits can be\n    ///         consumed by the `operator` during the execution\n    /// @notice `operator` consumes the funds during its operations by calling back into\n    ///         `AllowanceHolder` with `transferFrom`, consuming a token permit.\n    /// @dev Neither `exec` nor `transferFrom` check that `token` contains code.\n    /// @dev msg.sender is forwarded to target appended to the msg data (similar to ERC-2771)\n    /// @param operator An address which is allowed to consume the token permits\n    /// @param token The ERC20 token the caller has authorised to be consumed\n    /// @param amount The quantity of `token` the caller has authorised to be consumed\n    /// @param target A contract to execute operations with `data`\n    /// @param data The data to forward to `target`\n    /// @return result The returndata from calling `target` with `data`\n    /// @notice If calling `target` with `data` reverts, the revert is propagated\n    function exec(address operator, address token, uint256 amount, address payable target, bytes calldata data)\n        external\n        payable\n        returns (bytes memory result);\n\n    /// @notice The counterpart to `exec` which allows for the consumption of token permits later\n    ///         during execution\n    /// @dev *DOES NOT* check that `token` contains code. This function vacuously succeeds if\n    ///      `token` is empty.\n    /// @dev can only be called by the `operator` previously registered in `exec`\n    /// @param token The ERC20 token to transfer\n    /// @param owner The owner of tokens to transfer\n    /// @param recipient The destination/beneficiary of the ERC20 `transferFrom`\n    /// @param amount The quantity of `token` to transfer`\n    /// @return true\n    function transferFrom(address token, address owner, address recipient, uint256 amount) external returns (bool);\n}\n\n// src/core/univ3forks/PancakeSwapV3.sol\n\naddress constant pancakeSwapV3Factory = 0x41ff9AA7e16B8B1a8a8dc4f0eFacd93D02d071c9;\nbytes32 constant pancakeSwapV3InitHash = 0x6ce8eb472fa82df5469c6ab6d485f17c3ad13c8cd7af59b3d4a8026c5ce0f7e2;\nuint8 constant pancakeSwapV3ForkId = 1;\n\ninterface IPancakeSwapV3Callback {\n    function pancakeV3SwapCallback(int256 amount0Delta, int256 amount1Delta, bytes calldata data) external;\n}\n\n// src/core/univ3forks/SolidlyV3.sol\n\naddress constant solidlyV3Factory = 0x70Fe4a44EA505cFa3A57b95cF2862D4fd5F0f687;\naddress constant solidlyV3SonicFactory = 0x777fAca731b17E8847eBF175c94DbE9d81A8f630;\nbytes32 constant solidlyV3InitHash = 0xe9b68c5f77858eecac2e651646e208175e9b1359d68d0e14fc69f8c54e5010bf;\nuint8 constant solidlyV3ForkId = 3;\n\ninterface ISolidlyV3Callback {\n    function solidlyV3SwapCallback(int256 amount0Delta, int256 amount1Delta, bytes calldata data) external;\n}\n\n// src/core/univ3forks/SushiswapV3.sol\n\naddress constant sushiswapV3MainnetFactory = 0xbACEB8eC6b9355Dfc0269C18bac9d6E2Bdc29C4F;\naddress constant sushiswapV3Factory = 0xc35DADB65012eC5796536bD9864eD8773aBc74C4; // Base, Linea\naddress constant sushiswapV3ArbitrumFactory = 0x1af415a1EbA07a4986a52B6f2e7dE7003D82231e;\n//address constant sushiswapV3AvalancheFactory = 0x3e603C14aF37EBdaD31709C4f848Fc6aD5BEc715;\n//address constant sushiswapV3BlastFactory = 0x7680D4B43f3d1d54d6cfEeB2169463bFa7a6cf0d;\n//address constant sushiswapV3BnbFactory = 0x126555dd55a39328F69400d6aE4F782Bd4C34ABb;\naddress constant sushiswapV3OptimismFactory = 0x9c6522117e2ed1fE5bdb72bb0eD5E3f2bdE7DBe0;\naddress constant sushiswapV3PolygonFactory = 0x917933899c6a5F8E37F31E19f92CdBFF7e8FF0e2;\naddress constant sushiswapV3ScrollFactory = 0x46B3fDF7b5CDe91Ac049936bF0bDb12c5d22202e;\naddress constant sushiswapV3GnosisFactory = 0xf78031CBCA409F2FB6876BDFDBc1b2df24cF9bEf;\n//bytes32 constant sushiswapV3BlastInitHash = 0x8e13daee7f5a62e37e71bf852bcd44e7d16b90617ed2b17c24c2ee62411c5bae;\nuint8 constant sushiswapV3ForkId = 2;\n\n// src/core/univ3forks/UniswapV3.sol\n\naddress constant uniswapV3MainnetFactory = 0x1F98431c8aD98523631AE4a59f267346ea31F984;\naddress constant uniswapV3SepoliaFactory = 0x0227628f3F023bb0B980b67D528571c95c6DaC1c;\naddress constant uniswapV3BaseFactory = 0x33128a8fC17869897dcE68Ed026d694621f6FDfD;\naddress constant uniswapV3BnbFactory = 0xdB1d10011AD0Ff90774D0C6Bb92e5C5c8b4461F7;\naddress constant uniswapV3AvalancheFactory = 0x740b1c1de25031C31FF4fC9A62f554A55cdC1baD;\naddress constant uniswapV3BlastFactory = 0x792edAdE80af5fC680d96a2eD80A44247D2Cf6Fd;\naddress constant uniswapV3ScrollFactory = 0x70C62C8b8e801124A4Aa81ce07b637A3e83cb919;\naddress constant uniswapV3LineaFactory = 0x31FAfd4889FA1269F7a13A66eE0fB458f27D72A9;\naddress constant uniswapV3MantleFactory = 0x0d922Fb1Bc191F64970ac40376643808b4B74Df9;\naddress constant uniswapV3TaikoFactory = 0x75FC67473A91335B5b8F8821277262a13B38c9b3;\naddress constant uniswapV3WorldChainFactory = 0x7a5028BDa40e7B173C278C5342087826455ea25a;\naddress constant uniswapV3GnosisFactory = 0xe32F7dD7e3f098D518ff19A22d5f028e076489B1;\naddress constant uniswapV3SonicFactory = 0xcb2436774C3e191c85056d248EF4260ce5f27A9D;\naddress constant uniswapV3InkFactory = 0x640887A9ba3A9C53Ed27D0F7e8246A4F933f3424;\naddress constant uniswapV3MonadTestnetFactory = 0x961235a9020B05C44DF1026D956D1F4D78014276;\naddress constant uniswapV3UnichainFactory = 0x1F98400000000000000000000000000000000003; // https://github.com/Uniswap/contracts/blob/main/deployments/130.md#fri-nov-08-2024\nbytes32 constant uniswapV3InitHash = 0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54;\nuint8 constant uniswapV3ForkId = 0;\n\ninterface IUniswapV3Callback {\n    function uniswapV3SwapCallback(int256 amount0Delta, int256 amount1Delta, bytes calldata data) external;\n}\n\n// src/deployer/DeployerAddress.sol\n\naddress constant DEPLOYER = 0x00000000000004533Fe15556B1E086BB1A72cEae;\n\n// src/utils/FastLogic.sol\n\nlibrary FastLogic {\n    function or(bool a, bool b) internal pure returns (bool r) {\n        assembly (\"memory-safe\") {\n            r := or(a, b)\n        }\n    }\n\n    function and(bool a, bool b) internal pure returns (bool r) {\n        assembly (\"memory-safe\") {\n            r := and(a, b)\n        }\n    }\n}\n\n// src/utils/FreeMemory.sol\n\nabstract contract FreeMemory {\n    modifier DANGEROUS_freeMemory() {\n        uint256 freeMemPtr;\n        assembly (\"memory-safe\") {\n            freeMemPtr := mload(0x40)\n        }\n        _;\n        assembly (\"memory-safe\") {\n            mstore(0x40, freeMemPtr)\n        }\n    }\n}\n\n// src/utils/Panic.sol\n\nlibrary Panic {\n    function panic(uint256 code) internal pure {\n        assembly (\"memory-safe\") {\n            mstore(0x00, 0x4e487b71) // selector for `Panic(uint256)`\n            mstore(0x20, code)\n            revert(0x1c, 0x24)\n        }\n    }\n\n    // https://docs.soliditylang.org/en/latest/control-structures.html#panic-via-assert-and-error-via-require\n    uint8 internal constant GENERIC = 0x00;\n    uint8 internal constant ASSERT_FAIL = 0x01;\n    uint8 internal constant ARITHMETIC_OVERFLOW = 0x11;\n    uint8 internal constant DIVISION_BY_ZERO = 0x12;\n    uint8 internal constant ENUM_CAST = 0x21;\n    uint8 internal constant CORRUPT_STORAGE_ARRAY = 0x22;\n    uint8 internal constant POP_EMPTY_ARRAY = 0x31;\n    uint8 internal constant ARRAY_OUT_OF_BOUNDS = 0x32;\n    uint8 internal constant OUT_OF_MEMORY = 0x41;\n    uint8 internal constant ZERO_FUNCTION_POINTER = 0x51;\n}\n\n// src/utils/Revert.sol\n\nlibrary Revert {\n    function _revert(bytes memory reason) internal pure {\n        assembly (\"memory-safe\") {\n            revert(add(reason, 0x20), mload(reason))\n        }\n    }\n\n    function maybeRevert(bool success, bytes memory reason) internal pure {\n        if (!success) {\n            _revert(reason);\n        }\n    }\n}\n\n// lib/forge-std/src/interfaces/IERC4626.sol\n\n/// @dev Interface of the ERC4626 \"Tokenized Vault Standard\", as defined in\n/// https://eips.ethereum.org/EIPS/eip-4626\ninterface IERC4626 is IERC20 {\n    event Deposit(address indexed sender, address indexed owner, uint256 assets, uint256 shares);\n\n    event Withdraw(\n        address indexed sender, address indexed receiver, address indexed owner, uint256 assets, uint256 shares\n    );\n\n    /// @notice Returns the address of the underlying token used for the Vault for accounting, depositing, and withdrawing.\n    /// @dev\n    /// - MUST be an ERC-20 token contract.\n    /// - MUST NOT revert.\n    function asset() external view returns (address assetTokenAddress);\n\n    /// @notice Returns the total amount of the underlying asset that is “managed” by Vault.\n    /// @dev\n    /// - SHOULD include any compounding that occurs from yield.\n    /// - MUST be inclusive of any fees that are charged against assets in the Vault.\n    /// - MUST NOT revert.\n    function totalAssets() external view returns (uint256 totalManagedAssets);\n\n    /// @notice Returns the amount of shares that the Vault would exchange for the amount of assets provided, in an ideal\n    /// scenario where all the conditions are met.\n    /// @dev\n    /// - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n    /// - MUST NOT show any variations depending on the caller.\n    /// - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n    /// - MUST NOT revert.\n    ///\n    /// NOTE: This calculation MAY NOT reflect the “per-user” price-per-share, and instead should reflect the\n    /// “average-user’s” price-per-share, meaning what the average user should expect to see when exchanging to and\n    /// from.\n    function convertToShares(uint256 assets) external view returns (uint256 shares);\n\n    /// @notice Returns the amount of assets that the Vault would exchange for the amount of shares provided, in an ideal\n    /// scenario where all the conditions are met.\n    /// @dev\n    /// - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n    /// - MUST NOT show any variations depending on the caller.\n    /// - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n    /// - MUST NOT revert.\n    ///\n    /// NOTE: This calculation MAY NOT reflect the “per-user” price-per-share, and instead should reflect the\n    /// “average-user’s” price-per-share, meaning what the average user should expect to see when exchanging to and\n    /// from.\n    function convertToAssets(uint256 shares) external view returns (uint256 assets);\n\n    /// @notice Returns the maximum amount of the underlying asset that can be deposited into the Vault for the receiver,\n    /// through a deposit call.\n    /// @dev\n    /// - MUST return a limited value if receiver is subject to some deposit limit.\n    /// - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of assets that may be deposited.\n    /// - MUST NOT revert.\n    function maxDeposit(address receiver) external view returns (uint256 maxAssets);\n\n    /// @notice Allows an on-chain or off-chain user to simulate the effects of their deposit at the current block, given\n    /// current on-chain conditions.\n    /// @dev\n    /// - MUST return as close to and no more than the exact amount of Vault shares that would be minted in a deposit\n    ///   call in the same transaction. I.e. deposit should return the same or more shares as previewDeposit if called\n    ///   in the same transaction.\n    /// - MUST NOT account for deposit limits like those returned from maxDeposit and should always act as though the\n    ///   deposit would be accepted, regardless if the user has enough tokens approved, etc.\n    /// - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n    /// - MUST NOT revert.\n    ///\n    /// NOTE: any unfavorable discrepancy between convertToShares and previewDeposit SHOULD be considered slippage in\n    /// share price or some other type of condition, meaning the depositor will lose assets by depositing.\n    function previewDeposit(uint256 assets) external view returns (uint256 shares);\n\n    /// @notice Mints shares Vault shares to receiver by depositing exactly amount of underlying tokens.\n    /// @dev\n    /// - MUST emit the Deposit event.\n    /// - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n    ///   deposit execution, and are accounted for during deposit.\n    /// - MUST revert if all of assets cannot be deposited (due to deposit limit being reached, slippage, the user not\n    ///   approving enough underlying tokens to the Vault contract, etc).\n    ///\n    /// NOTE: most implementations will require pre-approval of the Vault with the Vault’s underlying asset token.\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\n\n    /// @notice Returns the maximum amount of the Vault shares that can be minted for the receiver, through a mint call.\n    /// @dev\n    /// - MUST return a limited value if receiver is subject to some mint limit.\n    /// - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of shares that may be minted.\n    /// - MUST NOT revert.\n    function maxMint(address receiver) external view returns (uint256 maxShares);\n\n    /// @notice Allows an on-chain or off-chain user to simulate the effects of their mint at the current block, given\n    /// current on-chain conditions.\n    /// @dev\n    /// - MUST return as close to and no fewer than the exact amount of assets that would be deposited in a mint call\n    ///   in the same transaction. I.e. mint should return the same or fewer assets as previewMint if called in the\n    ///   same transaction.\n    /// - MUST NOT account for mint limits like those returned from maxMint and should always act as though the mint\n    ///   would be accepted, regardless if the user has enough tokens approved, etc.\n    /// - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n    /// - MUST NOT revert.\n    ///\n    /// NOTE: any unfavorable discrepancy between convertToAssets and previewMint SHOULD be considered slippage in\n    /// share price or some other type of condition, meaning the depositor will lose assets by minting.\n    function previewMint(uint256 shares) external view returns (uint256 assets);\n\n    /// @notice Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.\n    /// @dev\n    /// - MUST emit the Deposit event.\n    /// - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the mint\n    ///   execution, and are accounted for during mint.\n    /// - MUST revert if all of shares cannot be minted (due to deposit limit being reached, slippage, the user not\n    ///   approving enough underlying tokens to the Vault contract, etc).\n    ///\n    /// NOTE: most implementations will require pre-approval of the Vault with the Vault’s underlying asset token.\n    function mint(uint256 shares, address receiver) external returns (uint256 assets);\n\n    /// @notice Returns the maximum amount of the underlying asset that can be withdrawn from the owner balance in the\n    /// Vault, through a withdraw call.\n    /// @dev\n    /// - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n    /// - MUST NOT revert.\n    function maxWithdraw(address owner) external view returns (uint256 maxAssets);\n\n    /// @notice Allows an on-chain or off-chain user to simulate the effects of their withdrawal at the current block,\n    /// given current on-chain conditions.\n    /// @dev\n    /// - MUST return as close to and no fewer than the exact amount of Vault shares that would be burned in a withdraw\n    ///   call in the same transaction. I.e. withdraw should return the same or fewer shares as previewWithdraw if\n    ///   called\n    ///   in the same transaction.\n    /// - MUST NOT account for withdrawal limits like those returned from maxWithdraw and should always act as though\n    ///   the withdrawal would be accepted, regardless if the user has enough shares, etc.\n    /// - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n    /// - MUST NOT revert.\n    ///\n    /// NOTE: any unfavorable discrepancy between convertToShares and previewWithdraw SHOULD be considered slippage in\n    /// share price or some other type of condition, meaning the depositor will lose assets by depositing.\n    function previewWithdraw(uint256 assets) external view returns (uint256 shares);\n\n    /// @notice Burns shares from owner and sends exactly assets of underlying tokens to receiver.\n    /// @dev\n    /// - MUST emit the Withdraw event.\n    /// - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n    ///   withdraw execution, and are accounted for during withdraw.\n    /// - MUST revert if all of assets cannot be withdrawn (due to withdrawal limit being reached, slippage, the owner\n    ///   not having enough shares, etc).\n    ///\n    /// Note that some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n    /// Those methods should be performed separately.\n    function withdraw(uint256 assets, address receiver, address owner) external returns (uint256 shares);\n\n    /// @notice Returns the maximum amount of Vault shares that can be redeemed from the owner balance in the Vault,\n    /// through a redeem call.\n    /// @dev\n    /// - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n    /// - MUST return balanceOf(owner) if owner is not subject to any withdrawal limit or timelock.\n    /// - MUST NOT revert.\n    function maxRedeem(address owner) external view returns (uint256 maxShares);\n\n    /// @notice Allows an on-chain or off-chain user to simulate the effects of their redeemption at the current block,\n    /// given current on-chain conditions.\n    /// @dev\n    /// - MUST return as close to and no more than the exact amount of assets that would be withdrawn in a redeem call\n    ///   in the same transaction. I.e. redeem should return the same or more assets as previewRedeem if called in the\n    ///   same transaction.\n    /// - MUST NOT account for redemption limits like those returned from maxRedeem and should always act as though the\n    ///   redemption would be accepted, regardless if the user has enough shares, etc.\n    /// - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n    /// - MUST NOT revert.\n    ///\n    /// NOTE: any unfavorable discrepancy between convertToAssets and previewRedeem SHOULD be considered slippage in\n    /// share price or some other type of condition, meaning the depositor will lose assets by redeeming.\n    function previewRedeem(uint256 shares) external view returns (uint256 assets);\n\n    /// @notice Burns exactly shares from owner and sends assets of underlying tokens to receiver.\n    /// @dev\n    /// - MUST emit the Withdraw event.\n    /// - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n    ///   redeem execution, and are accounted for during redeem.\n    /// - MUST revert if all of shares cannot be redeemed (due to withdrawal limit being reached, slippage, the owner\n    ///   not having enough shares, etc).\n    ///\n    /// NOTE: some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n    /// Those methods should be performed separately.\n    function redeem(uint256 shares, address receiver, address owner) external returns (uint256 assets);\n}\n\n// lib/permit2/src/interfaces/ISignatureTransfer.sol\n\n/// @title SignatureTransfer\n/// @notice Handles ERC20 token transfers through signature based actions\n/// @dev Requires user's token approval on the Permit2 contract\ninterface ISignatureTransfer is IEIP712 {\n    /// @notice Thrown when the requested amount for a transfer is larger than the permissioned amount\n    /// @param maxAmount The maximum amount a spender can request to transfer\n    error InvalidAmount(uint256 maxAmount);\n\n    /// @notice Thrown when the number of tokens permissioned to a spender does not match the number of tokens being transferred\n    /// @dev If the spender does not need to transfer the number of tokens permitted, the spender can request amount 0 to be transferred\n    error LengthMismatch();\n\n    /// @notice Emits an event when the owner successfully invalidates an unordered nonce.\n    event UnorderedNonceInvalidation(address indexed owner, uint256 word, uint256 mask);\n\n    /// @notice The token and amount details for a transfer signed in the permit transfer signature\n    struct TokenPermissions {\n        // ERC20 token address\n        address token;\n        // the maximum amount that can be spent\n        uint256 amount;\n    }\n\n    /// @notice The signed permit message for a single token transfer\n    struct PermitTransferFrom {\n        TokenPermissions permitted;\n        // a unique value for every token owner's signature to prevent signature replays\n        uint256 nonce;\n        // deadline on the permit signature\n        uint256 deadline;\n    }\n\n    /// @notice Specifies the recipient address and amount for batched transfers.\n    /// @dev Recipients and amounts correspond to the index of the signed token permissions array.\n    /// @dev Reverts if the requested amount is greater than the permitted signed amount.\n    struct SignatureTransferDetails {\n        // recipient address\n        address to;\n        // spender requested amount\n        uint256 requestedAmount;\n    }\n\n    /// @notice Used to reconstruct the signed permit message for multiple token transfers\n    /// @dev Do not need to pass in spender address as it is required that it is msg.sender\n    /// @dev Note that a user still signs over a spender address\n    struct PermitBatchTransferFrom {\n        // the tokens and corresponding amounts permitted for a transfer\n        TokenPermissions[] permitted;\n        // a unique value for every token owner's signature to prevent signature replays\n        uint256 nonce;\n        // deadline on the permit signature\n        uint256 deadline;\n    }\n\n    /// @notice A map from token owner address and a caller specified word index to a bitmap. Used to set bits in the bitmap to prevent against signature replay protection\n    /// @dev Uses unordered nonces so that permit messages do not need to be spent in a certain order\n    /// @dev The mapping is indexed first by the token owner, then by an index specified in the nonce\n    /// @dev It returns a uint256 bitmap\n    /// @dev The index, or wordPosition is capped at type(uint248).max\n    function nonceBitmap(address, uint256) external view returns (uint256);\n\n    /// @notice Transfers a token using a signed permit message\n    /// @dev Reverts if the requested amount is greater than the permitted signed amount\n    /// @param permit The permit data signed over by the owner\n    /// @param owner The owner of the tokens to transfer\n    /// @param transferDetails The spender's requested transfer details for the permitted token\n    /// @param signature The signature to verify\n    function permitTransferFrom(\n        PermitTransferFrom memory permit,\n        SignatureTransferDetails calldata transferDetails,\n        address owner,\n        bytes calldata signature\n    ) external;\n\n    /// @notice Transfers a token using a signed permit message\n    /// @notice Includes extra data provided by the caller to verify signature over\n    /// @dev The witness type string must follow EIP712 ordering of nested structs and must include the TokenPermissions type definition\n    /// @dev Reverts if the requested amount is greater than the permitted signed amount\n    /// @param permit The permit data signed over by the owner\n    /// @param owner The owner of the tokens to transfer\n    /// @param transferDetails The spender's requested transfer details for the permitted token\n    /// @param witness Extra data to include when checking the user signature\n    /// @param witnessTypeString The EIP-712 type definition for remaining string stub of the typehash\n    /// @param signature The signature to verify\n    function permitWitnessTransferFrom(\n        PermitTransferFrom memory permit,\n        SignatureTransferDetails calldata transferDetails,\n        address owner,\n        bytes32 witness,\n        string calldata witnessTypeString,\n        bytes calldata signature\n    ) external;\n\n    /// @notice Transfers multiple tokens using a signed permit message\n    /// @param permit The permit data signed over by the owner\n    /// @param owner The owner of the tokens to transfer\n    /// @param transferDetails Specifies the recipient and requested amount for the token transfer\n    /// @param signature The signature to verify\n    function permitTransferFrom(\n        PermitBatchTransferFrom memory permit,\n        SignatureTransferDetails[] calldata transferDetails,\n        address owner,\n        bytes calldata signature\n    ) external;\n\n    /// @notice Transfers multiple tokens using a signed permit message\n    /// @dev The witness type string must follow EIP712 ordering of nested structs and must include the TokenPermissions type definition\n    /// @notice Includes extra data provided by the caller to verify signature over\n    /// @param permit The permit data signed over by the owner\n    /// @param owner The owner of the tokens to transfer\n    /// @param transferDetails Specifies the recipient and requested amount for the token transfer\n    /// @param witness Extra data to include when checking the user signature\n    /// @param witnessTypeString The EIP-712 type definition for remaining string stub of the typehash\n    /// @param signature The signature to verify\n    function permitWitnessTransferFrom(\n        PermitBatchTransferFrom memory permit,\n        SignatureTransferDetails[] calldata transferDetails,\n        address owner,\n        bytes32 witness,\n        string calldata witnessTypeString,\n        bytes calldata signature\n    ) external;\n\n    /// @notice Invalidates the bits specified in mask for the bitmap at the word position\n    /// @dev The wordPos is maxed at type(uint248).max\n    /// @param wordPos A number to index the nonceBitmap at\n    /// @param mask A bitmap masked against msg.sender's current bitmap at the word position\n    function invalidateUnorderedNonces(uint256 wordPos, uint256 mask) external;\n}\n\n// src/core/SettlerErrors.sol\n\n/// @notice Thrown when an offset is not the expected value\nerror InvalidOffset();\n\n/// @notice Thrown when a validating a target contract to avoid certain types of targets\nerror ConfusedDeputy();\n\n/// @notice Thrown when a target contract is invalid given the context\nerror InvalidTarget();\n\n/// @notice Thrown when validating the caller against the expected caller\nerror InvalidSender();\n\n/// @notice Thrown in cases when using a Trusted Forwarder / AllowanceHolder is not allowed\nerror ForwarderNotAllowed();\n\n/// @notice Thrown when a signature length is not the expected length\nerror InvalidSignatureLen();\n\n/// @notice Thrown when a slippage limit is exceeded\nerror TooMuchSlippage(IERC20 token, uint256 expected, uint256 actual);\n\nfunction revertTooMuchSlippage(IERC20 buyToken, uint256 expectedBuyAmount, uint256 actualBuyAmount) pure {\n    assembly (\"memory-safe\") {\n        mstore(0x54, actualBuyAmount)\n        mstore(0x34, expectedBuyAmount)\n        mstore(0x14, buyToken)\n        mstore(0x00, 0x97a6f3b9000000000000000000000000) // selector for `TooMuchSlippage(address,uint256,uint256)` with `buyToken`'s padding\n        revert(0x10, 0x64)\n    }\n}\n\n/// @notice Thrown when a byte array that is supposed to encode a function from ISettlerActions is\n///         not recognized in context.\nerror ActionInvalid(uint256 i, bytes4 action, bytes data);\n\nfunction revertActionInvalid(uint256 i, uint256 action, bytes calldata data) pure {\n    assembly (\"memory-safe\") {\n        let ptr := mload(0x40)\n        mstore(ptr, 0x3c74eed6) // selector for `ActionInvalid(uint256,bytes4,bytes)`\n        mstore(add(0x20, ptr), i)\n        mstore(add(0x40, ptr), shl(0xe0, action)) // align as `bytes4`\n        mstore(add(0x60, ptr), 0x60) // offset to the length slot of the dynamic value `data`\n        mstore(add(0x80, ptr), data.length)\n        calldatacopy(add(0xa0, ptr), data.offset, data.length)\n        revert(add(0x1c, ptr), add(0x84, data.length))\n    }\n}\n\n/// @notice Thrown when the encoded fork ID as part of UniswapV3 fork path is not on the list of\n///         recognized forks for this chain.\nerror UnknownForkId(uint8 forkId);\n\nfunction revertUnknownForkId(uint8 forkId) pure {\n    assembly (\"memory-safe\") {\n        mstore(0x00, 0xd3b1276d) // selector for `UnknownForkId(uint8)`\n        mstore(0x20, and(0xff, forkId))\n        revert(0x1c, 0x24)\n    }\n}\n\n/// @notice Thrown when an AllowanceHolder transfer's permit is past its deadline\nerror SignatureExpired(uint256 deadline);\n\n/// @notice An internal error that should never be thrown. Thrown when a callback reenters the\n///         entrypoint and attempts to clobber the existing callback.\nerror ReentrantCallback(uint256 callbackInt);\n\n/// @notice An internal error that should never be thrown. This error can only be thrown by\n///         non-metatx-supporting Settler instances. Thrown when a callback-requiring liquidity\n///         source is called, but Settler never receives the callback.\nerror CallbackNotSpent(uint256 callbackInt);\n\n/// @notice Thrown when a metatransaction has reentrancy.\nerror ReentrantMetatransaction(bytes32 oldWitness);\n\n/// @notice Thrown when any transaction has reentrancy, not just taker-submitted or metatransaction.\nerror ReentrantPayer(address oldPayer);\n\n/// @notice An internal error that should never be thrown. Thrown when a metatransaction fails to\n///         spend a coupon.\nerror WitnessNotSpent(bytes32 oldWitness);\n\n/// @notice An internal error that should never be thrown. Thrown when the payer is unset\n///         unexpectedly.\nerror PayerSpent();\n\nerror DeltaNotPositive(IERC20 token);\nerror DeltaNotNegative(IERC20 token);\nerror ZeroSellAmount(IERC20 token);\nerror ZeroBuyAmount(IERC20 buyToken);\nerror BoughtSellToken(IERC20 sellToken);\nerror TokenHashCollision(IERC20 token0, IERC20 token1);\nerror ZeroToken();\n\n/// @notice Thrown for liquidities that require a Newton-Raphson approximation to solve their\n///         constant function when Newton-Raphson fails to converge on the solution in a\n///         \"reasonable\" number of iterations.\nerror NotConverged();\n\n/// @notice Thrown when the encoded pool manager ID as part of PancakeSwap Infinity fill is not on\n///         the list of recognized pool managers.\nerror UnknownPoolManagerId(uint8 poolManagerId);\n\n// src/interfaces/ISettlerBase.sol\n\ninterface ISettlerBase {\n    struct AllowedSlippage {\n        address payable recipient;\n        IERC20 buyToken;\n        uint256 minAmountOut;\n    }\n}\n\n// src/utils/Ternary.sol\n\nlibrary Ternary {\n    function ternary(bool c, uint256 x, uint256 y) internal pure returns (uint256 r) {\n        assembly (\"memory-safe\") {\n            r := xor(y, mul(xor(x, y), c))\n        }\n    }\n\n    function ternary(bool c, int256 x, int256 y) internal pure returns (int256 r) {\n        assembly (\"memory-safe\") {\n            r := xor(y, mul(xor(x, y), c))\n        }\n    }\n\n    function maybeSwap(bool c, uint256 x, uint256 y) internal pure returns (uint256 a, uint256 b) {\n        assembly (\"memory-safe\") {\n            let t := mul(xor(x, y), c)\n            a := xor(x, t)\n            b := xor(y, t)\n        }\n    }\n\n    function maybeSwap(bool c, int256 x, int256 y) internal pure returns (int256 a, int256 b) {\n        assembly (\"memory-safe\") {\n            let t := mul(xor(x, y), c)\n            a := xor(x, t)\n            b := xor(y, t)\n        }\n    }\n\n    function maybeSwap(bool c, IERC20 x, IERC20 y) internal pure returns (IERC20 a, IERC20 b) {\n        (uint256 a_, uint256 b_) = maybeSwap(c, uint160(address(x)), uint160(address(y)));\n        a = IERC20(address(uint160(a_)));\n        b = IERC20(address(uint160(b_)));\n    }\n\n    function maybeSwap(bool c, address x, address y) internal pure returns (address a, address b) {\n        (uint256 a_, uint256 b_) = maybeSwap(c, uint160(x), uint160(y));\n        a = address(uint160(a_));\n        b = address(uint160(b_));\n    }\n}\n\n// src/utils/UnsafeMath.sol\n\nlibrary UnsafeMath {\n    function unsafeInc(uint256 x) internal pure returns (uint256) {\n        unchecked {\n            return x + 1;\n        }\n    }\n\n    function unsafeInc(uint256 x, bool b) internal pure returns (uint256) {\n        assembly (\"memory-safe\") {\n            x := add(x, b)\n        }\n        return x;\n    }\n\n    function unsafeInc(int256 x) internal pure returns (int256) {\n        unchecked {\n            return x + 1;\n        }\n    }\n\n    function unsafeDec(uint256 x) internal pure returns (uint256) {\n        unchecked {\n            return x - 1;\n        }\n    }\n\n    function unsafeDec(int256 x) internal pure returns (int256) {\n        unchecked {\n            return x - 1;\n        }\n    }\n\n    function unsafeNeg(int256 x) internal pure returns (int256) {\n        unchecked {\n            return -x;\n        }\n    }\n\n    function unsafeDiv(uint256 numerator, uint256 denominator) internal pure returns (uint256 quotient) {\n        assembly (\"memory-safe\") {\n            quotient := div(numerator, denominator)\n        }\n    }\n\n    function unsafeDiv(int256 numerator, int256 denominator) internal pure returns (int256 quotient) {\n        assembly (\"memory-safe\") {\n            quotient := sdiv(numerator, denominator)\n        }\n    }\n\n    function unsafeMod(uint256 numerator, uint256 denominator) internal pure returns (uint256 remainder) {\n        assembly (\"memory-safe\") {\n            remainder := mod(numerator, denominator)\n        }\n    }\n\n    function unsafeMod(int256 numerator, int256 denominator) internal pure returns (int256 remainder) {\n        assembly (\"memory-safe\") {\n            remainder := smod(numerator, denominator)\n        }\n    }\n\n    function unsafeMulMod(uint256 a, uint256 b, uint256 m) internal pure returns (uint256 r) {\n        assembly (\"memory-safe\") {\n            r := mulmod(a, b, m)\n        }\n    }\n\n    function unsafeAddMod(uint256 a, uint256 b, uint256 m) internal pure returns (uint256 r) {\n        assembly (\"memory-safe\") {\n            r := addmod(a, b, m)\n        }\n    }\n\n    function unsafeDivUp(uint256 n, uint256 d) internal pure returns (uint256 r) {\n        assembly (\"memory-safe\") {\n            r := add(gt(mod(n, d), 0x00), div(n, d))\n        }\n    }\n}\n\nlibrary Math_0 {\n    function inc(uint256 x, bool c) internal pure returns (uint256 r) {\n        assembly (\"memory-safe\") {\n            r := add(x, c)\n        }\n        if (r < x) {\n            Panic.panic(Panic.ARITHMETIC_OVERFLOW);\n        }\n    }\n\n    function dec(uint256 x, bool c) internal pure returns (uint256 r) {\n        assembly (\"memory-safe\") {\n            r := sub(x, c)\n        }\n        if (r > x) {\n            Panic.panic(Panic.ARITHMETIC_OVERFLOW);\n        }\n    }\n}\n\n// src/vendor/SafeTransferLib.sol\n\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\n/// @author Modified from Solady (https://github.com/vectorized/solady/blob/main/src/utils/SafeTransferLib.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\nlibrary SafeTransferLib {\n    /*//////////////////////////////////////////////////////////////\n                             ETH OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferETH(address payable to, uint256 amount) internal {\n        assembly (\"memory-safe\") {\n            // Transfer the ETH and revert if it fails.\n            if iszero(call(gas(), to, amount, 0x00, 0x00, 0x00, 0x00)) {\n                let ptr := mload(0x40)\n                returndatacopy(ptr, 0x00, returndatasize())\n                revert(ptr, returndatasize())\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ERC20 OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function fastBalanceOf(IERC20 token, address acct) internal view returns (uint256 r) {\n        assembly (\"memory-safe\") {\n            mstore(0x14, acct) // Store the `acct` argument.\n            mstore(0x00, 0x70a08231000000000000000000000000) // Selector for `balanceOf(address)`, with `acct`'s padding.\n\n            // Call and check for revert. Storing the selector with padding in\n            // memory at 0 results in a start of calldata at offset 16. Calldata\n            // is 36 bytes long (4 bytes selector, 32 bytes argument)\n            if iszero(staticcall(gas(), token, 0x10, 0x24, 0x00, 0x20)) {\n                let ptr := mload(0x40)\n                returndatacopy(ptr, 0x00, returndatasize())\n                revert(ptr, returndatasize())\n            }\n            // Check for short returndata and missing code\n            if iszero(lt(0x1f, returndatasize())) { revert(0x00, 0x00) }\n\n            r := mload(0x00)\n        }\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 amount) internal {\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40) // Cache the free memory pointer.\n\n            mstore(0x60, amount) // Store the `amount` argument.\n            mstore(0x40, to) // Store the `to` argument.\n            mstore(0x2c, shl(0x60, from)) // Store the `from` argument. (Clears `to`'s padding.)\n            mstore(0x0c, 0x23b872dd000000000000000000000000) // Selector for `transferFrom(address,address,uint256)`, with `from`'s padding.\n\n            // Calldata starts at offset 28 and is 100 bytes long (3 * 32 + 4).\n            // If there is returndata (optional) we copy the first 32 bytes into the first slot of memory.\n            if iszero(call(gas(), token, 0x00, 0x1c, 0x64, 0x00, 0x20)) {\n                returndatacopy(ptr, 0x00, returndatasize())\n                revert(ptr, returndatasize())\n            }\n            // We check that the call either returned exactly 1 [true] (can't just be non-zero\n            // data), or had no return data.\n            if iszero(or(and(eq(mload(0x00), 0x01), lt(0x1f, returndatasize())), iszero(returndatasize()))) {\n                mstore(0x00, 0x7939f424) // Selector for `TransferFromFailed()`\n                revert(0x1c, 0x04)\n            }\n\n            mstore(0x60, 0x00) // Restore the zero slot to zero.\n            mstore(0x40, ptr) // Restore the free memory pointer.\n        }\n    }\n\n    function safeTransfer(IERC20 token, address to, uint256 amount) internal {\n        assembly (\"memory-safe\") {\n            mstore(0x14, to) // Store the `to` argument.\n            mstore(0x34, amount) // Store the `amount` argument.\n            // Storing `amount` clobbers the upper bits of the free memory pointer, but those bits\n            // can never be set without running into an OOG, so it's safe. We'll restore them to\n            // zero at the end.\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // Selector for `transfer(address,uint256)`, with `to`'s padding.\n\n            // Calldata starts at offset 16 and is 68 bytes long (2 * 32 + 4).\n            // If there is returndata (optional) we copy the first 32 bytes into the first slot of memory.\n            if iszero(call(gas(), token, 0x00, 0x10, 0x44, 0x00, 0x20)) {\n                let ptr := and(0xffffffffffffffffffffffff, mload(0x40))\n                returndatacopy(ptr, 0x00, returndatasize())\n                revert(ptr, returndatasize())\n            }\n            // We check that the call either returned exactly 1 [true] (can't just be non-zero\n            // data), or had no return data.\n            if iszero(or(and(eq(mload(0x00), 0x01), lt(0x1f, returndatasize())), iszero(returndatasize()))) {\n                mstore(0x00, 0x90b8ec18) // Selector for `TransferFailed()`\n                revert(0x1c, 0x04)\n            }\n\n            mstore(0x34, 0x00) // Restore the part of the free memory pointer that was overwritten.\n        }\n    }\n\n    function safeApprove(IERC20 token, address to, uint256 amount) internal {\n        assembly (\"memory-safe\") {\n            mstore(0x14, to) // Store the `to` argument.\n            mstore(0x34, amount) // Store the `amount` argument.\n            // Storing `amount` clobbers the upper bits of the free memory pointer, but those bits\n            // can never be set without running into an OOG, so it's safe. We'll restore them to\n            // zero at the end.\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // Selector for `approve(address,uint256)`, with `to`'s padding.\n\n            // Calldata starts at offset 16 and is 68 bytes long (2 * 32 + 4).\n            // If there is returndata (optional) we copy the first 32 bytes into the first slot of memory.\n            if iszero(call(gas(), token, 0x00, 0x10, 0x44, 0x00, 0x20)) {\n                let ptr := and(0xffffffffffffffffffffffff, mload(0x40))\n                returndatacopy(ptr, 0x00, returndatasize())\n                revert(ptr, returndatasize())\n            }\n            // We check that the call either returned exactly 1 [true] (can't just be non-zero\n            // data), or had no return data.\n            if iszero(or(and(eq(mload(0x00), 0x01), lt(0x1f, returndatasize())), iszero(returndatasize()))) {\n                mstore(0x00, 0x3e3f8f73) // Selector for `ApproveFailed()`\n                revert(0x1c, 0x04)\n            }\n\n            mstore(0x34, 0x00) // Restore the part of the free memory pointer that was overwritten.\n        }\n    }\n\n    function safeApproveIfBelow(IERC20 token, address spender, uint256 amount) internal {\n        uint256 allowance = token.allowance(address(this), spender);\n        if (allowance < amount) {\n            if (allowance != 0) {\n                safeApprove(token, spender, 0);\n            }\n            safeApprove(token, spender, type(uint256).max);\n        }\n    }\n}\n\n// src/ISettlerActions.sol\n\ninterface ISettlerActions {\n    /// @dev Transfer funds from msg.sender Permit2.\n    function TRANSFER_FROM(address recipient, ISignatureTransfer.PermitTransferFrom memory permit, bytes memory sig)\n        external;\n\n    /// @dev Transfer funds from metatransaction requestor into the Settler contract using Permit2. Only for use in `Settler.executeMetaTxn` where the signature is provided as calldata\n    function METATXN_TRANSFER_FROM(address recipient, ISignatureTransfer.PermitTransferFrom memory permit) external;\n\n    /// @dev Settle an RfqOrder between maker and taker transfering funds directly between the parties\n    // Post-req: Payout if recipient != taker\n    function RFQ_VIP(\n        address recipient,\n        ISignatureTransfer.PermitTransferFrom memory makerPermit,\n        address maker,\n        bytes memory makerSig,\n        ISignatureTransfer.PermitTransferFrom memory takerPermit,\n        bytes memory takerSig\n    ) external;\n\n    /// @dev Settle an RfqOrder between maker and taker transfering funds directly between the parties for the entire amount\n    function METATXN_RFQ_VIP(\n        address recipient,\n        ISignatureTransfer.PermitTransferFrom memory makerPermit,\n        address maker,\n        bytes memory makerSig,\n        ISignatureTransfer.PermitTransferFrom memory takerPermit\n    ) external;\n\n    /// @dev Settle an RfqOrder between Maker and Settler. Transfering funds from the Settler contract to maker.\n    /// Retaining funds in the settler contract.\n    // Pre-req: Funded\n    // Post-req: Payout\n    function RFQ(\n        address recipient,\n        ISignatureTransfer.PermitTransferFrom memory permit,\n        address maker,\n        bytes memory makerSig,\n        address takerToken,\n        uint256 maxTakerAmount\n    ) external;\n\n    function UNISWAPV4(\n        address recipient,\n        address sellToken,\n        uint256 bps,\n        bool feeOnTransfer,\n        uint256 hashMul,\n        uint256 hashMod,\n        bytes memory fills,\n        uint256 amountOutMin\n    ) external;\n    function UNISWAPV4_VIP(\n        address recipient,\n        bool feeOnTransfer,\n        uint256 hashMul,\n        uint256 hashMod,\n        bytes memory fills,\n        ISignatureTransfer.PermitTransferFrom memory permit,\n        bytes memory sig,\n        uint256 amountOutMin\n    ) external;\n    function METATXN_UNISWAPV4_VIP(\n        address recipient,\n        bool feeOnTransfer,\n        uint256 hashMul,\n        uint256 hashMod,\n        bytes memory fills,\n        ISignatureTransfer.PermitTransferFrom memory permit,\n        uint256 amountOutMin\n    ) external;\n\n    function BALANCERV3(\n        address recipient,\n        address sellToken,\n        uint256 bps,\n        bool feeOnTransfer,\n        uint256 hashMul,\n        uint256 hashMod,\n        bytes memory fills,\n        uint256 amountOutMin\n    ) external;\n    function BALANCERV3_VIP(\n        address recipient,\n        bool feeOnTransfer,\n        uint256 hashMul,\n        uint256 hashMod,\n        bytes memory fills,\n        ISignatureTransfer.PermitTransferFrom memory permit,\n        bytes memory sig,\n        uint256 amountOutMin\n    ) external;\n    function METATXN_BALANCERV3_VIP(\n        address recipient,\n        bool feeOnTransfer,\n        uint256 hashMul,\n        uint256 hashMod,\n        bytes memory fills,\n        ISignatureTransfer.PermitTransferFrom memory permit,\n        uint256 amountOutMin\n    ) external;\n\n    function PANCAKE_INFINITY(\n        address recipient,\n        address sellToken,\n        uint256 bps,\n        bool feeOnTransfer,\n        uint256 hashMul,\n        uint256 hashMod,\n        bytes memory fills,\n        uint256 amountOutMin\n    ) external;\n    function PANCAKE_INFINITY_VIP(\n        address recipient,\n        bool feeOnTransfer,\n        uint256 hashMul,\n        uint256 hashMod,\n        bytes memory fills,\n        ISignatureTransfer.PermitTransferFrom memory permit,\n        bytes memory sig,\n        uint256 amountOutMin\n    ) external;\n    function METATXN_PANCAKE_INFINITY_VIP(\n        address recipient,\n        bool feeOnTransfer,\n        uint256 hashMul,\n        uint256 hashMod,\n        bytes memory fills,\n        ISignatureTransfer.PermitTransferFrom memory permit,\n        uint256 amountOutMin\n    ) external;\n\n    /// @dev Trades against UniswapV3 using the contracts balance for funding\n    // Pre-req: Funded\n    // Post-req: Payout\n    function UNISWAPV3(address recipient, uint256 bps, bytes memory path, uint256 amountOutMin) external;\n    /// @dev Trades against UniswapV3 using user funds via Permit2 for funding\n    function UNISWAPV3_VIP(\n        address recipient,\n        bytes memory path,\n        ISignatureTransfer.PermitTransferFrom memory permit,\n        bytes memory sig,\n        uint256 amountOutMin\n    ) external;\n    /// @dev Trades against UniswapV3 using user funds via Permit2 for funding. Metatransaction variant. Signature is over all actions.\n    function METATXN_UNISWAPV3_VIP(\n        address recipient,\n        bytes memory path,\n        ISignatureTransfer.PermitTransferFrom memory permit,\n        uint256 amountOutMin\n    ) external;\n\n    function MAKERPSM(address recipient, uint256 bps, bool buyGem, uint256 amountOutMin) external;\n\n    function CURVE_TRICRYPTO_VIP(\n        address recipient,\n        uint80 poolInfo,\n        ISignatureTransfer.PermitTransferFrom memory permit,\n        bytes memory sig,\n        uint256 minBuyAmount\n    ) external;\n    function METATXN_CURVE_TRICRYPTO_VIP(\n        address recipient,\n        uint80 poolInfo,\n        ISignatureTransfer.PermitTransferFrom memory permit,\n        uint256 minBuyAmount\n    ) external;\n\n    function DODOV1(address sellToken, uint256 bps, address pool, bool quoteForBase, uint256 minBuyAmount) external;\n    function DODOV2(\n        address recipient,\n        address sellToken,\n        uint256 bps,\n        address pool,\n        bool quoteForBase,\n        uint256 minBuyAmount\n    ) external;\n\n    function VELODROME(address recipient, uint256 bps, address pool, uint24 swapInfo, uint256 minBuyAmount) external;\n\n    /// @dev Trades against MaverickV2 using the contracts balance for funding\n    /// This action does not use the MaverickV2 callback, so it takes an arbitrary pool address to make calls against.\n    /// Passing `tokenAIn` as a parameter actually saves gas relative to introspecting the pool's `tokenA()` accessor.\n    function MAVERICKV2(\n        address recipient,\n        address sellToken,\n        uint256 bps,\n        address pool,\n        bool tokenAIn,\n        uint256 minBuyAmount\n    ) external;\n    /// @dev Trades against MaverickV2, spending the taker's coupon inside the callback\n    /// This action requires the use of the MaverickV2 callback, so we take the MaverickV2 CREATE2 salt as an argument to derive the pool address from the trusted factory and inithash.\n    /// @param salt is formed as `keccak256(abi.encode(feeAIn, feeBIn, tickSpacing, lookback, tokenA, tokenB, kinds, address(0)))`\n    function MAVERICKV2_VIP(\n        address recipient,\n        bytes32 salt,\n        bool tokenAIn,\n        ISignatureTransfer.PermitTransferFrom memory permit,\n        bytes memory sig,\n        uint256 minBuyAmount\n    ) external;\n    /// @dev Trades against MaverickV2, spending the taker's coupon inside the callback; metatransaction variant\n    function METATXN_MAVERICKV2_VIP(\n        address recipient,\n        bytes32 salt,\n        bool tokenAIn,\n        ISignatureTransfer.PermitTransferFrom memory permit,\n        uint256 minBuyAmount\n    ) external;\n\n    /// @dev Trades against UniswapV2 using the contracts balance for funding\n    /// @param swapInfo is encoded as the upper 16 bits as the fee of the pool in bps, the second\n    ///                 lowest bit as \"sell token has transfer fee\", and the lowest bit as the\n    ///                 \"token0 for token1\" flag.\n    function UNISWAPV2(\n        address recipient,\n        address sellToken,\n        uint256 bps,\n        address pool,\n        uint24 swapInfo,\n        uint256 amountOutMin\n    ) external;\n\n    function POSITIVE_SLIPPAGE(address payable recipient, address token, uint256 expectedAmount) external;\n\n    /// @dev Trades against a basic AMM which follows the approval, transferFrom(msg.sender) interaction\n    // Pre-req: Funded\n    // Post-req: Payout\n    function BASIC(address sellToken, uint256 bps, address pool, uint256 offset, bytes calldata data) external;\n\n    function EKUBO(\n        address recipient,\n        address sellToken,\n        uint256 bps,\n        bool feeOnTransfer,\n        uint256 hashMul,\n        uint256 hashMod,\n        bytes memory fills,\n        uint256 amountOutMin\n    ) external;\n    \n    function EKUBO_VIP(\n        address recipient,\n        bool feeOnTransfer,\n        uint256 hashMul,\n        uint256 hashMod,\n        bytes memory fills,\n        ISignatureTransfer.PermitTransferFrom memory permit,\n        bytes memory sig,\n        uint256 amountOutMin\n    ) external;\n\n    function METATXN_EKUBO_VIP(\n        address recipient,\n        bool feeOnTransfer,\n        uint256 hashMul,\n        uint256 hashMod,\n        bytes memory fills,\n        ISignatureTransfer.PermitTransferFrom memory permit,\n        uint256 amountOutMin\n    ) external;\n}\n\n// src/allowanceholder/AllowanceHolderContext.sol\n\nabstract contract AllowanceHolderContext is Context {\n    IAllowanceHolder internal constant _ALLOWANCE_HOLDER = IAllowanceHolder(0x0000000000001fF3684f28c67538d4D072C22734);\n\n    function _isForwarded() internal view virtual override returns (bool) {\n        return super._isForwarded() || super._msgSender() == address(_ALLOWANCE_HOLDER);\n    }\n\n    function _msgData() internal view virtual override returns (bytes calldata) {\n        if (super._msgSender() == address(_ALLOWANCE_HOLDER)) {\n            return msg.data[:msg.data.length - 20];\n        } else {\n            return msg.data;\n        }\n    }\n\n    function _msgSender() internal view virtual override returns (address sender) {\n        sender = super._msgSender();\n        if (sender == address(_ALLOWANCE_HOLDER)) {\n            // ERC-2771 like usage where the _trusted_ `AllowanceHolder` has appended the appropriate\n            // msg.sender to the msg data\n            bytes calldata data = super._msgData();\n            assembly (\"memory-safe\") {\n                sender := shr(0x60, calldataload(add(data.offset, sub(data.length, 0x14))))\n            }\n        }\n    }\n\n    // this is here to avoid foot-guns and make it very explicit that we intend\n    // to pass the confused deputy check in AllowanceHolder\n    function balanceOf(address) external pure {\n        assembly (\"memory-safe\") {\n            mstore8(0x00, 0x00)\n            return(0x00, 0x01)\n        }\n    }\n}\n\n// src/interfaces/ISettlerTakerSubmitted.sol\n\ninterface ISettlerTakerSubmitted is ISettlerBase {\n    function execute(AllowedSlippage calldata slippage, bytes[] calldata actions, bytes32 /* zid & affiliate */ )\n        external\n        payable\n        returns (bool);\n}\n\n// src/utils/512Math.sol\n\n/*\n\nWARNING *** WARNING *** WARNING *** WARNING *** WARNING *** WARNING *** WARNING\n  ***                                                                     ***\nWARNING                     This code is unaudited                      WARNING\n  ***                                                                     ***\nWARNING *** WARNING *** WARNING *** WARNING *** WARNING *** WARNING *** WARNING\n\n*/\n\n/// The type uint512 behaves as if it were declared as\n///     struct uint512 {\n///         uint256 hi;\n///         uint256 lo;\n///     }\n/// However, returning `memory` references from internal functions is impossible\n/// to do efficiently, especially when the functions are small and are called\n/// frequently. Therefore, we assume direct control over memory allocation using\n/// the functions `tmp()` and `alloc()` defined below. If you need to pass\n/// 512-bit integers between contracts (generally a bad idea), the struct\n/// `uint512_external` defined at the end of this file is provided for this\n/// purpose and has exactly the definition you'd expect (as well as convenient\n/// conversion functions).\n///\n/// MAKING A DECLARATION OF THE FOLLOWING FORM WILL CAUSE UNEXPECTED BEHAVIOR:\n///     uint512 x;\n/// INSTEAD OF DOING THAT, YOU MUST USE `alloc()`, LIKE THIS:\n///     uint512 x = alloc();\n/// IF YOU REALLY WANTED TO DO THAT (ADVANCED USAGE) THEN FOR CLARITY, WRITE THE\n/// FOLLOWING:\n///     uint512 x = tmp();\n///\n/// While user-defined arithmetic operations (i.e. +, -, *, %, /) are provided\n/// for `uint512`, they are not gas-optimal, full-featured, or composable. You\n/// will get a revert upon incorrect usage. Their primary usage is when a simple\n/// arithmetic operation needs to be performed followed by a comparison (e.g. <,\n/// >, ==, etc.) or conversion to a pair of `uint256`s (i.e. `.into()`). The use\n/// of the user-defined arithmetic operations is not composable with the usage\n/// of `tmp()`.\n///\n/// In general, correct usage of `uint512` requires always specifying the output\n/// location of each operation. For each `o*` operation (mnemonic:\n/// out-of-place), the first argument is the output location and the remaining\n/// arguments are the input. For each `i*` operation (mnemonic: in-place), the\n/// first argument is both input and output and the remaining arguments are\n/// purely input. For each `ir*` operation (mnemonic: in-place reverse; only for\n/// non-commutative operations), the semantics of the input arguments are\n/// flipped (i.e. `irsub(foo, bar)` is semantically equivalent to `foo = bar -\n/// foo`); the first argument is still the output location. Only `irsub`,\n/// `irmod`, `irdiv`, `irmodAlt`, and `irdivAlt` exist. Unless otherwise noted,\n/// the return value of each function is the output location. This supports\n/// chaining/pipeline/tacit-style programming.\n///\n/// All provided arithmetic operations behave as if they were inside an\n/// `unchecked` block. We assume that because you're reaching for 512-bit math,\n/// you have domain knowledge about the range of values that you will\n/// encounter. Overflow causes truncation, not a revert. Division or modulo by\n/// zero still causes a panic revert with code 18 (identical behavior to\n/// \"normal\" unchecked arithmetic).\n///\n/// Three additional arithmetic operations are provided, bare `sub`, `mod`, and\n/// `div`. These are provided for use when it is known that the result of the\n/// operation will fit into 256 bits. This fact is not checked, but more\n/// efficient algorithms are employed assuming this. The result is a `uint256`.\n///\n/// The operations `*mod` and `*div` with 512-bit denominator are `view` instead\n/// of `pure` because they make use of the MODEXP (5) precompile. Some EVM L2s\n/// and sidechains do not support MODEXP with 512-bit arguments. On those\n/// chains, the `*modAlt` and `*divAlt` functions are provided. These functions\n/// are truly `pure` and do not rely on MODEXP at all. The downside is that they\n/// consume slightly (really only *slightly*) more gas.\n///\n/// ## Full list of provided functions\n///\n/// Unless otherwise noted, all functions return `(uint512)`\n///\n/// ### Utility\n///\n/// * from(uint256)\n/// * from(uint256,uint256) -- The EVM is big-endian. The most-significant word is first.\n/// * from(uint512) -- performs a copy\n/// * into() returns (uint256,uint256) -- Again, the most-significant word is first.\n/// * toExternal(uint512) returns (uint512_external memory)\n///\n/// ### Comparison (all functions return `(bool)`)\n///\n/// * isZero(uint512)\n/// * isMax(uint512)\n/// * eq(uint512,uint256)\n/// * eq(uint512,uint512)\n/// * ne(uint512,uint256)\n/// * ne(uint512,uint512)\n/// * gt(uint512,uint256)\n/// * gt(uint512,uint512)\n/// * ge(uint512,uint256)\n/// * ge(uint512,uint512)\n/// * lt(uint512,uint256)\n/// * lt(uint512,uint512)\n/// * le(uint512,uint256)\n/// * le(uint512,uint512)\n///\n/// ### Addition\n///\n/// * oadd(uint512,uint256,uint256) -- iadd(uint256,uint256) is not provided for somewhat obvious reasons\n/// * oadd(uint512,uint512,uint256)\n/// * iadd(uint512,uint256)\n/// * oadd(uint512,uint512,uint512)\n/// * iadd(uint512,uint512)\n///\n/// ### Subtraction\n///\n/// * sub(uint512,uint256) returns (uint256)\n/// * sub(uint512,uint512) returns (uint256)\n/// * osub(uint512,uint512,uint256)\n/// * isub(uint512,uint256)\n/// * osub(uint512,uint512,uint512)\n/// * isub(uint512,uint512)\n/// * irsub(uint512,uint512)\n///\n/// ### Multiplication\n///\n/// * omul(uint512,uint256,uint256)\n/// * omul(uint512,uint512,uint256)\n/// * imul(uint512,uint256)\n/// * omul(uint512,uint512,uint512)\n/// * imul(uint512,uint512)\n///\n/// ### Modulo\n///\n/// * mod(uint512,uint256) returns (uint256) -- mod(uint512,uint512) is not provided for less obvious reasons\n/// * omod(uint512,uint512,uint512)\n/// * imod(uint512,uint512)\n/// * irmod(uint512,uint512)\n/// * omodAlt(uint512,uint512,uint512)\n/// * imodAlt(uint512,uint512)\n/// * irmodAlt(uint512,uint512)\n///\n/// ### Division\n///\n/// * div(uint512,uint256) returns (uint256)\n/// * div(uint512,uint512) returns (uint256)\n/// * odiv(uint512,uint512,uint256)\n/// * idiv(uint512,uint256)\n/// * odiv(uint512,uint512,uint512)\n/// * idiv(uint512,uint512)\n/// * irdiv(uint512,uint512)\n/// * divAlt(uint512,uint512) returns (uint256) -- divAlt(uint512,uint256) is not provided because div(uint512,uint256) is suitable for chains without MODEXP\n/// * odivAlt(uint512,uint512,uint512)\n/// * idivAlt(uint512,uint512)\n/// * irdivAlt(uint512,uint512)\ntype uint512 is bytes32;\n\nfunction alloc() pure returns (uint512 r) {\n    assembly (\"memory-safe\") {\n        r := mload(0x40)\n        mstore(0x40, add(0x40, r))\n    }\n}\n\nfunction tmp() pure returns (uint512 r) {}\n\nlibrary Lib512MathAccessors {\n    function from(uint512 r, uint256 x) internal pure returns (uint512 r_out) {\n        assembly (\"memory-safe\") {\n            mstore(r, 0x00)\n            mstore(add(0x20, r), x)\n            r_out := r\n        }\n    }\n\n    function from(uint512 r, uint256 x_hi, uint256 x_lo) internal pure returns (uint512 r_out) {\n        assembly (\"memory-safe\") {\n            mstore(r, x_hi)\n            mstore(add(0x20, r), x_lo)\n            r_out := r\n        }\n    }\n\n    function from(uint512 r, uint512 x) internal pure returns (uint512 r_out) {\n        assembly (\"memory-safe\") {\n            // Paradoxically, using `mload` and `mstore` here (instead of\n            // `mcopy`) produces more optimal code because it gives solc the\n            // opportunity to optimize-out the use of memory entirely, in\n            // typical usage. As a happy side effect, it also means that we\n            // don't have to deal with Cancun hardfork compatibility issues.\n            mstore(r, mload(x))\n            mstore(add(0x20, r), mload(add(0x20, x)))\n            r_out := r\n        }\n    }\n\n    function into(uint512 x) internal pure returns (uint256 r_hi, uint256 r_lo) {\n        assembly (\"memory-safe\") {\n            r_hi := mload(x)\n            r_lo := mload(add(0x20, x))\n        }\n    }\n}\n\nusing Lib512MathAccessors for uint512 global;\n\nlibrary Lib512MathComparisons {\n    function isZero(uint512 x) internal pure returns (bool r) {\n        (uint256 x_hi, uint256 x_lo) = x.into();\n        assembly (\"memory-safe\") {\n            r := iszero(or(x_hi, x_lo))\n        }\n    }\n\n    function isMax(uint512 x) internal pure returns (bool r) {\n        (uint256 x_hi, uint256 x_lo) = x.into();\n        assembly (\"memory-safe\") {\n            r := iszero(not(and(x_hi, x_lo)))\n        }\n    }\n\n    function eq(uint512 x, uint256 y) internal pure returns (bool r) {\n        (uint256 x_hi, uint256 x_lo) = x.into();\n        assembly (\"memory-safe\") {\n            r := and(iszero(x_hi), eq(x_lo, y))\n        }\n    }\n\n    function gt(uint512 x, uint256 y) internal pure returns (bool r) {\n        (uint256 x_hi, uint256 x_lo) = x.into();\n        assembly (\"memory-safe\") {\n            r := or(gt(x_hi, 0x00), gt(x_lo, y))\n        }\n    }\n\n    function lt(uint512 x, uint256 y) internal pure returns (bool r) {\n        (uint256 x_hi, uint256 x_lo) = x.into();\n        assembly (\"memory-safe\") {\n            r := and(iszero(x_hi), lt(x_lo, y))\n        }\n    }\n\n    function ne(uint512 x, uint256 y) internal pure returns (bool) {\n        return !eq(x, y);\n    }\n\n    function ge(uint512 x, uint256 y) internal pure returns (bool) {\n        return !lt(x, y);\n    }\n\n    function le(uint512 x, uint256 y) internal pure returns (bool) {\n        return !gt(x, y);\n    }\n\n    function eq(uint512 x, uint512 y) internal pure returns (bool r) {\n        (uint256 x_hi, uint256 x_lo) = x.into();\n        (uint256 y_hi, uint256 y_lo) = y.into();\n        assembly (\"memory-safe\") {\n            r := and(eq(x_hi, y_hi), eq(x_lo, y_lo))\n        }\n    }\n\n    function gt(uint512 x, uint512 y) internal pure returns (bool r) {\n        (uint256 x_hi, uint256 x_lo) = x.into();\n        (uint256 y_hi, uint256 y_lo) = y.into();\n        assembly (\"memory-safe\") {\n            r := or(gt(x_hi, y_hi), and(eq(x_hi, y_hi), gt(x_lo, y_lo)))\n        }\n    }\n\n    function lt(uint512 x, uint512 y) internal pure returns (bool r) {\n        (uint256 x_hi, uint256 x_lo) = x.into();\n        (uint256 y_hi, uint256 y_lo) = y.into();\n        assembly (\"memory-safe\") {\n            r := or(lt(x_hi, y_hi), and(eq(x_hi, y_hi), lt(x_lo, y_lo)))\n        }\n    }\n\n    function ne(uint512 x, uint512 y) internal pure returns (bool) {\n        return !eq(x, y);\n    }\n\n    function ge(uint512 x, uint512 y) internal pure returns (bool) {\n        return !lt(x, y);\n    }\n\n    function le(uint512 x, uint512 y) internal pure returns (bool) {\n        return !gt(x, y);\n    }\n}\n\nusing Lib512MathComparisons for uint512 global;\n\nfunction __eq(uint512 x, uint512 y) pure returns (bool) {\n    return x.eq(y);\n}\n\nfunction __gt(uint512 x, uint512 y) pure returns (bool) {\n    return x.gt(y);\n}\n\nfunction __lt(uint512 x, uint512 y) pure returns (bool r) {\n    return x.lt(y);\n}\n\nfunction __ne(uint512 x, uint512 y) pure returns (bool) {\n    return x.ne(y);\n}\n\nfunction __ge(uint512 x, uint512 y) pure returns (bool) {\n    return x.ge(y);\n}\n\nfunction __le(uint512 x, uint512 y) pure returns (bool) {\n    return x.le(y);\n}\n\nusing {__eq as ==, __gt as >, __lt as <, __ne as !=, __ge as >=, __le as <=} for uint512 global;\n\nlibrary Lib512MathArithmetic {\n    using UnsafeMath for uint256;\n\n    function oadd(uint512 r, uint256 x, uint256 y) internal pure returns (uint512) {\n        uint256 r_hi;\n        uint256 r_lo;\n        assembly (\"memory-safe\") {\n            r_lo := add(x, y)\n            // `lt(r_lo, x)` indicates overflow in the lower addition. We can\n            // add the bool directly to the integer to perform carry\n            r_hi := lt(r_lo, x)\n        }\n        return r.from(r_hi, r_lo);\n    }\n\n    function oadd(uint512 r, uint512 x, uint256 y) internal pure returns (uint512) {\n        (uint256 x_hi, uint256 x_lo) = x.into();\n        uint256 r_hi;\n        uint256 r_lo;\n        assembly (\"memory-safe\") {\n            r_lo := add(x_lo, y)\n            // `lt(r_lo, x_lo)` indicates overflow in the lower\n            // addition. Overflow in the high limb is simply ignored\n            r_hi := add(x_hi, lt(r_lo, x_lo))\n        }\n        return r.from(r_hi, r_lo);\n    }\n\n    function iadd(uint512 r, uint256 y) internal pure returns (uint512) {\n        return oadd(r, r, y);\n    }\n\n    function _add(uint256 x_hi, uint256 x_lo, uint256 y_hi, uint256 y_lo)\n        private\n        pure\n        returns (uint256 r_hi, uint256 r_lo)\n    {\n        assembly (\"memory-safe\") {\n            r_lo := add(x_lo, y_lo)\n            // `lt(r_lo, x_lo)` indicates overflow in the lower\n            // addition. Overflow in the high limb is simply ignored.\n            r_hi := add(add(x_hi, y_hi), lt(r_lo, x_lo))\n        }\n    }\n\n    function oadd(uint512 r, uint512 x, uint512 y) internal pure returns (uint512) {\n        (uint256 x_hi, uint256 x_lo) = x.into();\n        (uint256 y_hi, uint256 y_lo) = y.into();\n        (uint256 r_hi, uint256 r_lo) = _add(x_hi, x_lo, y_hi, y_lo);\n        return r.from(r_hi, r_lo);\n    }\n\n    function iadd(uint512 r, uint512 y) internal pure returns (uint512) {\n        return oadd(r, r, y);\n    }\n\n    function _sub(uint256 x_hi, uint256 x_lo, uint256 y) private pure returns (uint256 r_hi, uint256 r_lo) {\n        assembly (\"memory-safe\") {\n            r_lo := sub(x_lo, y)\n            // `gt(r_lo, x_lo)` indicates underflow in the lower subtraction. We\n            // can subtract the bool directly from the integer to perform carry.\n            r_hi := sub(x_hi, gt(r_lo, x_lo))\n        }\n    }\n\n    function osub(uint512 r, uint512 x, uint256 y) internal pure returns (uint512) {\n        (uint256 x_hi, uint256 x_lo) = x.into();\n        (uint256 r_hi, uint256 r_lo) = _sub(x_hi, x_lo, y);\n        return r.from(r_hi, r_lo);\n    }\n\n    function isub(uint512 r, uint256 y) internal pure returns (uint512) {\n        return osub(r, r, y);\n    }\n\n    function _sub(uint256 x_hi, uint256 x_lo, uint256 y_hi, uint256 y_lo)\n        private\n        pure\n        returns (uint256 r_hi, uint256 r_lo)\n    {\n        assembly (\"memory-safe\") {\n            r_lo := sub(x_lo, y_lo)\n            // `gt(r_lo, x_lo)` indicates underflow in the lower subtraction.\n            // Underflow in the high limb is simply ignored.\n            r_hi := sub(sub(x_hi, y_hi), gt(r_lo, x_lo))\n        }\n    }\n\n    function osub(uint512 r, uint512 x, uint512 y) internal pure returns (uint512) {\n        (uint256 x_hi, uint256 x_lo) = x.into();\n        (uint256 y_hi, uint256 y_lo) = y.into();\n        (uint256 r_hi, uint256 r_lo) = _sub(x_hi, x_lo, y_hi, y_lo);\n        return r.from(r_hi, r_lo);\n    }\n\n    function isub(uint512 r, uint512 y) internal pure returns (uint512) {\n        return osub(r, r, y);\n    }\n\n    function irsub(uint512 r, uint512 y) internal pure returns (uint512) {\n        return osub(r, y, r);\n    }\n\n    function sub(uint512 x, uint256 y) internal pure returns (uint256 r) {\n        assembly (\"memory-safe\") {\n            r := sub(mload(add(0x20, x)), y)\n        }\n    }\n\n    function sub(uint512 x, uint512 y) internal pure returns (uint256 r) {\n        assembly (\"memory-safe\") {\n            r := sub(mload(add(0x20, x)), mload(add(0x20, y)))\n        }\n    }\n\n    //// The technique implemented in the following functions for multiplication is\n    //// adapted from Remco Bloemen's work https://2π.com/17/full-mul/ .\n    //// The original code was released under the MIT license.\n\n    function _mul(uint256 x, uint256 y) private pure returns (uint256 r_hi, uint256 r_lo) {\n        assembly (\"memory-safe\") {\n            let mm := mulmod(x, y, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n            r_lo := mul(x, y)\n            r_hi := sub(sub(mm, r_lo), lt(mm, r_lo))\n        }\n    }\n\n    function omul(uint512 r, uint256 x, uint256 y) internal pure returns (uint512) {\n        (uint256 r_hi, uint256 r_lo) = _mul(x, y);\n        return r.from(r_hi, r_lo);\n    }\n\n    function _mul(uint256 x_hi, uint256 x_lo, uint256 y) private pure returns (uint256 r_hi, uint256 r_lo) {\n        assembly (\"memory-safe\") {\n            let mm := mulmod(x_lo, y, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n            r_lo := mul(x_lo, y)\n            r_hi := add(mul(x_hi, y), sub(sub(mm, r_lo), lt(mm, r_lo)))\n        }\n    }\n\n    function omul(uint512 r, uint512 x, uint256 y) internal pure returns (uint512) {\n        (uint256 x_hi, uint256 x_lo) = x.into();\n        (uint256 r_hi, uint256 r_lo) = _mul(x_hi, x_lo, y);\n        return r.from(r_hi, r_lo);\n    }\n\n    function imul(uint512 r, uint256 y) internal pure returns (uint512) {\n        return omul(r, r, y);\n    }\n\n    function _mul(uint256 x_hi, uint256 x_lo, uint256 y_hi, uint256 y_lo)\n        private\n        pure\n        returns (uint256 r_hi, uint256 r_lo)\n    {\n        assembly (\"memory-safe\") {\n            let mm := mulmod(x_lo, y_lo, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n            r_lo := mul(x_lo, y_lo)\n            r_hi := add(add(mul(x_hi, y_lo), mul(x_lo, y_hi)), sub(sub(mm, r_lo), lt(mm, r_lo)))\n        }\n    }\n\n    function omul(uint512 r, uint512 x, uint512 y) internal pure returns (uint512) {\n        (uint256 x_hi, uint256 x_lo) = x.into();\n        (uint256 y_hi, uint256 y_lo) = y.into();\n        (uint256 r_hi, uint256 r_lo) = _mul(x_hi, x_lo, y_hi, y_lo);\n        return r.from(r_hi, r_lo);\n    }\n\n    function imul(uint512 r, uint512 y) internal pure returns (uint512) {\n        return omul(r, r, y);\n    }\n\n    function mod(uint512 n, uint256 d) internal pure returns (uint256 r) {\n        if (d == 0) {\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n        (uint256 n_hi, uint256 n_lo) = n.into();\n        assembly (\"memory-safe\") {\n            r := mulmod(n_hi, sub(0x00, d), d)\n            r := addmod(n_lo, r, d)\n        }\n    }\n\n    function omod(uint512 r, uint512 x, uint512 y) internal view returns (uint512) {\n        (uint256 x_hi, uint256 x_lo) = x.into();\n        (uint256 y_hi, uint256 y_lo) = y.into();\n        assembly (\"memory-safe\") {\n            // We use the MODEXP (5) precompile with an exponent of 1. We encode\n            // the arguments to the precompile at the beginning of free memory\n            // without allocating. Arguments are encoded as:\n            //     [64 32 64 x_hi x_lo 1 y_hi y_lo]\n            let ptr := mload(0x40)\n            mstore(ptr, 0x40)\n            mstore(add(0x20, ptr), 0x20)\n            mstore(add(0x40, ptr), 0x40)\n            // See comment in `from` about why `mstore` is more efficient than `mcopy`\n            mstore(add(0x60, ptr), x_hi)\n            mstore(add(0x80, ptr), x_lo)\n            mstore(add(0xa0, ptr), 0x01)\n            mstore(add(0xc0, ptr), y_hi)\n            mstore(add(0xe0, ptr), y_lo)\n\n            // We write the result of MODEXP directly into the output space r.\n            pop(staticcall(gas(), 0x05, ptr, 0x100, r, 0x40))\n            // The MODEXP precompile can only fail due to out-of-gas. This call\n            // consumes only 200 gas, so if it failed, there is only 4 gas\n            // remaining in this context. Therefore, we will out-of-gas\n            // immediately when we attempt to read the result. We don't bother\n            // to check for failure.\n        }\n        return r;\n    }\n\n    function imod(uint512 r, uint512 y) internal view returns (uint512) {\n        return omod(r, r, y);\n    }\n\n    function irmod(uint512 r, uint512 y) internal view returns (uint512) {\n        return omod(r, y, r);\n    }\n\n    /// Multiply 512-bit [x_hi x_lo] by 256-bit [y] giving 768-bit [r_ex r_hi r_lo]\n    function _mul768(uint256 x_hi, uint256 x_lo, uint256 y)\n        private\n        pure\n        returns (uint256 r_ex, uint256 r_hi, uint256 r_lo)\n    {\n        assembly (\"memory-safe\") {\n            let mm0 := mulmod(x_lo, y, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n            r_lo := mul(x_lo, y)\n            let mm1 := mulmod(x_hi, y, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n            let r_partial := mul(x_hi, y)\n            r_ex := sub(sub(mm1, r_partial), lt(mm1, r_partial))\n\n            r_hi := add(r_partial, sub(sub(mm0, r_lo), lt(mm0, r_lo)))\n            // `lt(r_hi, r_partial)` indicates overflow in the addition to form\n            // `r_hi`. We can add the bool directly to the integer to perform\n            // carry.\n            r_ex := add(r_ex, lt(r_hi, r_partial))\n        }\n    }\n\n    //// The technique implemented in the following functions for division is\n    //// adapted from Remco Bloemen's work https://2π.com/21/muldiv/ .\n    //// The original code was released under the MIT license.\n\n    function _roundDown(uint256 x_hi, uint256 x_lo, uint256 d) private pure returns (uint256 r_hi, uint256 r_lo) {\n        assembly (\"memory-safe\") {\n            // Get the remainder [n_hi n_lo] % d (< 2²⁵⁶ - 1)\n            // 2**256 % d = -d % 2**256 % d -- https://2π.com/17/512-bit-division/\n            let rem := mulmod(x_hi, sub(0x00, d), d)\n            rem := addmod(x_lo, rem, d)\n\n            r_hi := sub(x_hi, gt(rem, x_lo))\n            r_lo := sub(x_lo, rem)\n        }\n    }\n\n    function _roundDown(uint256 x_hi, uint256 x_lo, uint256 d_hi, uint256 d_lo)\n        private\n        view\n        returns (uint256 r_hi, uint256 r_lo)\n    {\n        uint512 r;\n        assembly (\"memory-safe\") {\n            // We point `r` to the beginning of free memory WITHOUT allocating.\n            // This is not technically \"memory-safe\" because solc might use that\n            // memory for something in between the end of this assembly block\n            // and the beginning of the call to `into()`, but empirically and\n            // practically speaking that won't and doesn't happen. We save some\n            // gas by not bumping the free pointer.\n            r := mload(0x40)\n\n            // Get the remainder [x_hi x_lo] % [d_hi d_lo] (< 2⁵¹² - 1) We use\n            // the MODEXP (5) precompile with an exponent of 1. We encode the\n            // arguments to the precompile at the beginning of free memory\n            // without allocating. Conveniently, `r` already points to this\n            // region. Arguments are encoded as:\n            //     [64 32 64 x_hi x_lo 1 d_hi d_lo]\n            mstore(r, 0x40)\n            mstore(add(0x20, r), 0x20)\n            mstore(add(0x40, r), 0x40)\n            mstore(add(0x60, r), x_hi)\n            mstore(add(0x80, r), x_lo)\n            mstore(add(0xa0, r), 0x01)\n            mstore(add(0xc0, r), d_hi)\n            mstore(add(0xe0, r), d_lo)\n\n            // The MODEXP precompile can only fail due to out-of-gas. This call\n            // consumes only 200 gas, so if it failed, there is only 4 gas\n            // remaining in this context. Therefore, we will out-of-gas\n            // immediately when we attempt to read the result. We don't bother\n            // to check for failure.\n            pop(staticcall(gas(), 0x05, r, 0x100, r, 0x40))\n        }\n        (uint256 rem_hi, uint256 rem_lo) = r.into();\n        // Round down by subtracting the remainder from the numerator\n        (r_hi, r_lo) = _sub(x_hi, x_lo, rem_hi, rem_lo);\n    }\n\n    function _twos(uint256 x) private pure returns (uint256 twos, uint256 twosInv) {\n        assembly (\"memory-safe\") {\n            // Compute largest power of two divisor of `x`. `x` is nonzero, so\n            // this is always ≥ 1.\n            twos := and(sub(0x00, x), x)\n\n            // To shift up (bits from the high limb into the low limb) we need\n            // the inverse of `twos`. That is, 2²⁵⁶ / twos.\n            //     2**256 / twos = -twos % 2**256 / twos + 1 -- https://2π.com/17/512-bit-division/\n            // If `twos` is zero, then `twosInv` becomes one (not possible)\n            twosInv := add(div(sub(0x00, twos), twos), 0x01)\n        }\n    }\n\n    function _toOdd256(uint256 x_hi, uint256 x_lo, uint256 y) private pure returns (uint256 x_lo_out, uint256 y_out) {\n        // Factor powers of two out of `y` and apply the same shift to [x_hi\n        // x_lo]\n        (uint256 twos, uint256 twosInv) = _twos(y);\n\n        assembly (\"memory-safe\") {\n            // Divide `y` by the power of two\n            y_out := div(y, twos)\n\n            // Divide [x_hi x_lo] by the power of two\n            x_lo_out := or(div(x_lo, twos), mul(x_hi, twosInv))\n        }\n    }\n\n    function _toOdd256(uint256 x_hi, uint256 x_lo, uint256 y_hi, uint256 y_lo)\n        private\n        pure\n        returns (uint256 x_lo_out, uint256 y_lo_out)\n    {\n        // Factor powers of two out of `y_lo` and apply the same shift to `x_lo`\n        (uint256 twos, uint256 twosInv) = _twos(y_lo);\n\n        assembly (\"memory-safe\") {\n            // Divide [y_hi y_lo] by the power of two, returning only the low limb\n            y_lo_out := or(div(y_lo, twos), mul(y_hi, twosInv))\n\n            // Divide [x_hi x_lo] by the power of two, returning only the low limb\n            x_lo_out := or(div(x_lo, twos), mul(x_hi, twosInv))\n        }\n    }\n\n    function _toOdd512(uint256 x_hi, uint256 x_lo, uint256 y)\n        private\n        pure\n        returns (uint256 x_hi_out, uint256 x_lo_out, uint256 y_out)\n    {\n        // Factor powers of two out of `y` and apply the same shift to [x_hi\n        // x_lo]\n        (uint256 twos, uint256 twosInv) = _twos(y);\n\n        assembly (\"memory-safe\") {\n            // Divide `y` by the power of two\n            y_out := div(y, twos)\n\n            // Divide [x_hi x_lo] by the power of two\n            x_hi_out := div(x_hi, twos)\n            x_lo_out := or(div(x_lo, twos), mul(x_hi, twosInv))\n        }\n    }\n\n    function _toOdd512(uint256 x_hi, uint256 x_lo, uint256 y_hi, uint256 y_lo)\n        private\n        pure\n        returns (uint256 x_hi_out, uint256 x_lo_out, uint256 y_hi_out, uint256 y_lo_out)\n    {\n        // Factor powers of two out of [y_hi y_lo] and apply the same shift to\n        // [x_hi x_lo] and [y_hi y_lo]\n        (uint256 twos, uint256 twosInv) = _twos(y_lo);\n\n        assembly (\"memory-safe\") {\n            // Divide [y_hi y_lo] by the power of two\n            y_hi_out := div(y_hi, twos)\n            y_lo_out := or(div(y_lo, twos), mul(y_hi, twosInv))\n\n            // Divide [x_hi x_lo] by the power of two\n            x_hi_out := div(x_hi, twos)\n            x_lo_out := or(div(x_lo, twos), mul(x_hi, twosInv))\n        }\n    }\n\n    function _invert256(uint256 d) private pure returns (uint256 inv) {\n        assembly (\"memory-safe\") {\n            // Invert `d` mod 2²⁵⁶ -- https://2π.com/18/multiplitcative-inverses/\n            // `d` is an odd number (from _toOdd*). It has an inverse modulo\n            // 2²⁵⁶ such that d * inv ≡ 1 mod 2²⁵⁶.\n            // We use Newton-Raphson iterations compute inv. Thanks to Hensel's\n            // lifting lemma, this also works in modular arithmetic, doubling\n            // the correct bits in each step. The Newton-Raphson-Hensel step is:\n            //    inv_{n+1} = inv_n * (2 - d*inv_n) % 2**512\n\n            // To kick off Newton-Raphson-Hensel iterations, we start with a\n            // seed of the inverse that is correct correct for four bits.\n            //     d * inv ≡ 1 mod 2⁴\n            inv := xor(mul(0x03, d), 0x02)\n\n            // Each Newton-Raphson-Hensel step doubles the number of correct\n            // bits in `inv`. After 6 iterations, full convergence is\n            // guaranteed.\n            inv := mul(inv, sub(0x02, mul(d, inv))) // inverse mod 2⁸\n            inv := mul(inv, sub(0x02, mul(d, inv))) // inverse mod 2¹⁶\n            inv := mul(inv, sub(0x02, mul(d, inv))) // inverse mod 2³²\n            inv := mul(inv, sub(0x02, mul(d, inv))) // inverse mod 2⁶⁴\n            inv := mul(inv, sub(0x02, mul(d, inv))) // inverse mod 2¹²⁸\n            inv := mul(inv, sub(0x02, mul(d, inv))) // inverse mod 2²⁵⁶\n        }\n    }\n\n    function _invert512(uint256 d) private pure returns (uint256 inv_hi, uint256 inv_lo) {\n        // First, we get the inverse of `d` mod 2²⁵⁶\n        inv_lo = _invert256(d);\n\n        // To extend this to the inverse mod 2⁵¹², we perform a more elaborate\n        // 7th Newton-Raphson-Hensel iteration with 512 bits of precision.\n\n        // tmp = d * inv_lo % 2**512\n        (uint256 tmp_hi, uint256 tmp_lo) = _mul(d, inv_lo);\n        // tmp = 2 - tmp % 2**512\n        (tmp_hi, tmp_lo) = _sub(0, 2, tmp_hi, tmp_lo);\n\n        assembly (\"memory-safe\") {\n            // inv_hi = inv_lo * tmp / 2**256 % 2**256\n            let mm := mulmod(inv_lo, tmp_lo, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n            inv_hi := add(mul(inv_lo, tmp_hi), sub(sub(mm, inv_lo), lt(mm, inv_lo)))\n        }\n    }\n\n    function _invert512(uint256 d_hi, uint256 d_lo) private pure returns (uint256 inv_hi, uint256 inv_lo) {\n        // First, we get the inverse of `d` mod 2²⁵⁶\n        inv_lo = _invert256(d_lo);\n\n        // To extend this to the inverse mod 2⁵¹², we perform a more elaborate\n        // 7th Newton-Raphson-Hensel iteration with 512 bits of precision.\n\n        // tmp = d * inv_lo % 2**512\n        (uint256 tmp_hi, uint256 tmp_lo) = _mul(d_hi, d_lo, inv_lo);\n        // tmp = 2 - tmp % 2**512\n        (tmp_hi, tmp_lo) = _sub(0, 2, tmp_hi, tmp_lo);\n\n        assembly (\"memory-safe\") {\n            // inv_hi = inv_lo * tmp / 2**256 % 2**256\n            let mm := mulmod(inv_lo, tmp_lo, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n            inv_hi := add(mul(inv_lo, tmp_hi), sub(sub(mm, inv_lo), lt(mm, inv_lo)))\n        }\n    }\n\n    function div(uint512 n, uint256 d) internal pure returns (uint256) {\n        if (d == 0) {\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n\n        (uint256 n_hi, uint256 n_lo) = n.into();\n        if (n_hi == 0) {\n            return n_lo.unsafeDiv(d);\n        }\n\n        // Round the numerator down to a multiple of the denominator. This makes\n        // the division exact without affecting the result.\n        (n_hi, n_lo) = _roundDown(n_hi, n_lo, d);\n\n        // Make `d` odd so that it has a multiplicative inverse mod 2²⁵⁶\n        // After this we can discard `n_hi` because our result is only 256 bits\n        (n_lo, d) = _toOdd256(n_hi, n_lo, d);\n\n        // We perform division by multiplying by the multiplicative inverse of\n        // the denominator mod 2²⁵⁶. Since `d` is odd, this inverse\n        // exists. Compute that inverse\n        d = _invert256(d);\n\n        unchecked {\n            // Because the division is now exact (we rounded `n` down to a\n            // multiple of `d`), we perform it by multiplying with the modular\n            // inverse of the denominator. This is the correct result mod 2²⁵⁶.\n            return n_lo * d;\n        }\n    }\n\n    function _gt(uint256 x_hi, uint256 x_lo, uint256 y_hi, uint256 y_lo) private pure returns (bool r) {\n        assembly (\"memory-safe\") {\n            r := or(gt(x_hi, y_hi), and(eq(x_hi, y_hi), gt(x_lo, y_lo)))\n        }\n    }\n\n    function div(uint512 n, uint512 d) internal view returns (uint256) {\n        (uint256 d_hi, uint256 d_lo) = d.into();\n        if (d_hi == 0) {\n            return div(n, d_lo);\n        }\n        (uint256 n_hi, uint256 n_lo) = n.into();\n        if (d_lo == 0) {\n            return n_hi.unsafeDiv(d_hi);\n        }\n        if (_gt(d_hi, d_lo, n_hi, n_lo)) {\n            // TODO: this optimization may not be overall optimizing\n            return 0;\n        }\n\n        // Round the numerator down to a multiple of the denominator. This makes\n        // the division exact without affecting the result.\n        (n_hi, n_lo) = _roundDown(n_hi, n_lo, d_hi, d_lo);\n\n        // Make `d_lo` odd so that it has a multiplicative inverse mod 2²⁵⁶\n        // After this we can discard `n_hi` and `d_hi` because our result is\n        // only 256 bits\n        (n_lo, d_lo) = _toOdd256(n_hi, n_lo, d_hi, d_lo);\n\n        // We perform division by multiplying by the multiplicative inverse of\n        // the denominator mod 2²⁵⁶. Since `d_lo` is odd, this inverse\n        // exists. Compute that inverse\n        d_lo = _invert256(d_lo);\n\n        unchecked {\n            // Because the division is now exact (we rounded `n` down to a\n            // multiple of `d`), we perform it by multiplying with the modular\n            // inverse of the denominator. This is the correct result mod 2²⁵⁶.\n            return n_lo * d_lo;\n        }\n    }\n\n    function odiv(uint512 r, uint512 x, uint256 y) internal pure returns (uint512) {\n        if (y == 0) {\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n\n        (uint256 x_hi, uint256 x_lo) = x.into();\n        if (x_hi == 0) {\n            return r.from(0, x_lo.unsafeDiv(y));\n        }\n\n        // Round the numerator down to a multiple of the denominator. This makes\n        // the division exact without affecting the result.\n        (x_hi, x_lo) = _roundDown(x_hi, x_lo, y);\n\n        // Make `y` odd so that it has a multiplicative inverse mod 2⁵¹²\n        (x_hi, x_lo, y) = _toOdd512(x_hi, x_lo, y);\n\n        // We perform division by multiplying by the multiplicative inverse of\n        // the denominator mod 2⁵¹². Since `y` is odd, this inverse\n        // exists. Compute that inverse\n        (uint256 inv_hi, uint256 inv_lo) = _invert512(y);\n\n        // Because the division is now exact (we rounded `x` down to a multiple\n        // of `y`), we perform it by multiplying with the modular inverse of the\n        // denominator.\n        (uint256 r_hi, uint256 r_lo) = _mul(x_hi, x_lo, inv_hi, inv_lo);\n        return r.from(r_hi, r_lo);\n    }\n\n    function idiv(uint512 r, uint256 y) internal pure returns (uint512) {\n        return odiv(r, r, y);\n    }\n\n    function odiv(uint512 r, uint512 x, uint512 y) internal view returns (uint512) {\n        (uint256 y_hi, uint256 y_lo) = y.into();\n        if (y_hi == 0) {\n            return odiv(r, x, y_lo);\n        }\n        (uint256 x_hi, uint256 x_lo) = x.into();\n        if (y_lo == 0) {\n            return r.from(0, x_hi.unsafeDiv(y_hi));\n        }\n        if (_gt(y_hi, y_lo, x_hi, x_lo)) {\n            // TODO: this optimization may not be overall optimizing\n            return r.from(0, 0);\n        }\n\n        // Round the numerator down to a multiple of the denominator. This makes\n        // the division exact without affecting the result.\n        (x_hi, x_lo) = _roundDown(x_hi, x_lo, y_hi, y_lo);\n\n        // Make `y` odd so that it has a multiplicative inverse mod 2⁵¹²\n        (x_hi, x_lo, y_hi, y_lo) = _toOdd512(x_hi, x_lo, y_hi, y_lo);\n\n        // We perform division by multiplying by the multiplicative inverse of\n        // the denominator mod 2⁵¹². Since `y` is odd, this inverse\n        // exists. Compute that inverse\n        (y_hi, y_lo) = _invert512(y_hi, y_lo);\n\n        // Because the division is now exact (we rounded `x` down to a multiple\n        // of `y`), we perform it by multiplying with the modular inverse of the\n        // denominator.\n        (uint256 r_hi, uint256 r_lo) = _mul(x_hi, x_lo, y_hi, y_lo);\n        return r.from(r_hi, r_lo);\n    }\n\n    function idiv(uint512 r, uint512 y) internal view returns (uint512) {\n        return odiv(r, r, y);\n    }\n\n    function irdiv(uint512 r, uint512 y) internal view returns (uint512) {\n        return odiv(r, y, r);\n    }\n\n    function _gt(uint256 x_ex, uint256 x_hi, uint256 x_lo, uint256 y_ex, uint256 y_hi, uint256 y_lo)\n        private\n        pure\n        returns (bool r)\n    {\n        assembly (\"memory-safe\") {\n            r :=\n                or(\n                    or(gt(x_ex, y_ex), and(eq(x_ex, y_ex), gt(x_hi, y_hi))),\n                    and(and(eq(x_ex, y_ex), eq(x_hi, y_hi)), gt(x_lo, y_lo))\n                )\n        }\n    }\n\n    /// The technique implemented in the following helper function for Knuth\n    /// Algorithm D (a modification of the citation further below) is adapted\n    /// from ridiculous fish's (aka corydoras) work\n    /// https://ridiculousfish.com/blog/posts/labor-of-division-episode-iv.html\n    /// and\n    /// https://ridiculousfish.com/blog/posts/labor-of-division-episode-v.html .\n\n    function _correctQ(uint256 q, uint256 r, uint256 x_next, uint256 y_next, uint256 y_whole)\n        private\n        pure\n        returns (uint256 q_out)\n    {\n        assembly (\"memory-safe\") {\n            let c1 := mul(q, y_next)\n            let c2 := or(shl(0x80, r), x_next)\n            q_out := sub(q, shl(gt(sub(c1, c2), y_whole), gt(c1, c2)))\n        }\n    }\n\n    /// The technique implemented in the following function for division is\n    /// adapted from Donald Knuth, The Art of Computer Programming (TAOCP)\n    /// Volume 2, Section 4.3.1, Algorithm D.\n\n    function _algorithmD(uint256 x_hi, uint256 x_lo, uint256 y_hi, uint256 y_lo) private pure returns (uint256 q) {\n        // We treat `x` and `y` each as ≤4-limb bigints where each limb is half\n        // a machine word (128 bits). This lets us perform 2-limb ÷ 1-limb\n        // divisions as a single operation (`div`) as required by Algorithm\n        // D. It also simplifies/optimizes some of the multiplications.\n\n        if (y_hi >> 128 != 0) {\n            // y is 4 limbs, x is 4 limbs, q is 1 limb\n\n            // Normalize. Ensure the uppermost limb of y ≥ 2¹²⁷ (equivalently\n            // y_hi >= 2**255). This is step D1 of Algorithm D\n            // The author's copy of TAOCP (3rd edition) states to set `d = (2 **\n            // 128 - 1) // y_hi`, however this is incorrect. Setting `d` in this\n            // fashion may result in overflow in the subsequent `_mul`. Setting\n            // `d` as implemented below still satisfies the postcondition (`y_hi\n            // >> 128 >= 1 << 127`) but never results in overflow.\n            uint256 d = uint256(1 << 128).unsafeDiv((y_hi >> 128).unsafeInc());\n            uint256 x_ex;\n            (x_ex, x_hi, x_lo) = _mul768(x_hi, x_lo, d);\n            (y_hi, y_lo) = _mul(y_hi, y_lo, d);\n\n            // `n_approx` is the 2 most-significant limbs of x, after\n            // normalization\n            uint256 n_approx = (x_ex << 128) | (x_hi >> 128);\n            // `d_approx` is the most significant limb of y, after normalization\n            uint256 d_approx = y_hi >> 128;\n            // Normalization ensures that result of this division is an\n            // approximation of the most significant (and only) limb of the\n            // quotient and is too high by at most 3. This is the \"Calculate\n            // q-hat\" (D3) step of Algorithm D. (did you know that U+0302,\n            // COMBINING CIRCUMFLEX ACCENT cannot be combined with q? shameful)\n            q = n_approx.unsafeDiv(d_approx);\n            uint256 r_hat = n_approx.unsafeMod(d_approx);\n\n            // The process of `_correctQ` subtracts up to 2 from `q`, to make it\n            // more accurate. This is still part of the \"Calculate q-hat\" (D3)\n            // step of Algorithm D.\n            q = _correctQ(q, r_hat, x_hi & type(uint128).max, y_hi & type(uint128).max, y_hi);\n\n            // This final, low-probability, computationally-expensive correction\n            // conditionally subtracts 1 from `q` to make it exactly the\n            // most-significant limb of the quotient. This is the \"Multiply and\n            // subtract\" (D4), \"Test remainder\" (D5), and \"Add back\" (D6) steps\n            // of Algorithm D, with substantial shortcutting\n            {\n                (uint256 tmp_ex, uint256 tmp_hi, uint256 tmp_lo) = _mul768(y_hi, y_lo, q);\n                bool neg = _gt(tmp_ex, tmp_hi, tmp_lo, x_ex, x_hi, x_lo);\n                assembly (\"memory-safe\") {\n                    q := sub(q, neg)\n                }\n            }\n        } else {\n            // y is 3 limbs\n\n            // Normalize. Ensure the most significant limb of y ≥ 2¹²⁷ (step D1)\n            // See above comment about the error in TAOCP.\n            uint256 d = uint256(1 << 128).unsafeDiv(y_hi.unsafeInc());\n            (y_hi, y_lo) = _mul(y_hi, y_lo, d);\n            // `y_next` is the second-most-significant, nonzero, normalized limb\n            // of y\n            uint256 y_next = y_lo >> 128;\n            // `y_whole` is the 2 most-significant, nonzero, normalized limbs of\n            // y\n            uint256 y_whole = (y_hi << 128) | y_next;\n\n            if (x_hi >> 128 != 0) {\n                // x is 4 limbs, q is 2 limbs\n\n                // Finish normalizing (step D1)\n                uint256 x_ex;\n                (x_ex, x_hi, x_lo) = _mul768(x_hi, x_lo, d);\n\n                uint256 n_approx = (x_ex << 128) | (x_hi >> 128);\n                // As before, `q_hat` is the most significant limb of the\n                // quotient and too high by at most 3 (step D3)\n                uint256 q_hat = n_approx.unsafeDiv(y_hi);\n                uint256 r_hat = n_approx.unsafeMod(y_hi);\n\n                // Subtract up to 2 from `q_hat`, improving our estimate (step\n                // D3)\n                q_hat = _correctQ(q_hat, r_hat, x_hi & type(uint128).max, y_next, y_whole);\n                q = q_hat << 128;\n\n                {\n                    // \"Multiply and subtract\" (D4) step of Algorithm D\n                    (uint256 tmp_hi, uint256 tmp_lo) = _mul(y_hi, y_lo, q_hat);\n                    uint256 tmp_ex = tmp_hi >> 128;\n                    tmp_hi = (tmp_hi << 128) | (tmp_lo >> 128);\n                    tmp_lo <<= 128;\n\n                    // \"Test remainder\" (D5) step of Algorithm D\n                    bool neg = _gt(tmp_ex, tmp_hi, tmp_lo, x_ex, x_hi, x_lo);\n                    // Finish step D4\n                    (x_hi, x_lo) = _sub(x_hi, x_lo, tmp_hi, tmp_lo);\n\n                    // \"Add back\" (D6) step of Algorithm D\n                    if (neg) {\n                        // This branch is quite rare, so it's gas-advantageous\n                        // to actually branch and usually skip the costly `_add`\n                        unchecked {\n                            q -= 1 << 128;\n                        }\n                        (x_hi, x_lo) = _add(x_hi, x_lo, y_whole, y_lo << 128);\n                    }\n                }\n                // `x_ex` is now zero (implicitly)\n\n                // Run another loop (steps D3 through D6) of Algorithm D to get\n                // the lower limb of the quotient\n                q_hat = x_hi.unsafeDiv(y_hi);\n                r_hat = x_hi.unsafeMod(y_hi);\n\n                q_hat = _correctQ(q_hat, r_hat, x_lo >> 128, y_next, y_whole);\n\n                {\n                    (uint256 tmp_hi, uint256 tmp_lo) = _mul(y_hi, y_lo, q_hat);\n                    bool neg = _gt(tmp_hi, tmp_lo, x_hi, x_lo);\n                    assembly (\"memory-safe\") {\n                        q_hat := sub(q_hat, neg)\n                    }\n                }\n\n                q |= q_hat;\n            } else {\n                // x is 3 limbs, q is 1 limb\n\n                // Finish normalizing (step D1)\n                (x_hi, x_lo) = _mul(x_hi, x_lo, d);\n\n                // `q` is the most significant (and only) limb of the quotient\n                // and too high by at most 3 (step D3)\n                q = x_hi.unsafeDiv(y_hi);\n                uint256 r_hat = x_hi.unsafeMod(y_hi);\n\n                // Subtract up to 2 from `q`, improving our estimate (step D3)\n                q = _correctQ(q, r_hat, x_lo >> 128, y_next, y_whole);\n\n                // Subtract up to 1 from `q` to make it exact (steps D4 through\n                // D6)\n                {\n                    (uint256 tmp_hi, uint256 tmp_lo) = _mul(y_hi, y_lo, q);\n                    bool neg = _gt(tmp_hi, tmp_lo, x_hi, x_lo);\n                    assembly (\"memory-safe\") {\n                        q := sub(q, neg)\n                    }\n                }\n            }\n        }\n        // All other cases are handled by the checks that y ≥ 2²⁵⁶ (equivalently\n        // y_hi != 0) and that x ≥ y\n    }\n\n    /// Modified from Solady (https://github.com/Vectorized/solady/blob/a3d6a974f9c9f00dcd95b235619a209a63c61d94/src/utils/LibBit.sol#L33-L45)\n    /// The original code was released under the MIT license.\n    function _clzLower(uint256 x) private pure returns (uint256 r) {\n        assembly (\"memory-safe\") {\n            r := shl(0x06, lt(0xffffffffffffffff, x))\n            r := or(r, shl(0x05, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(0x04, lt(0xffff, shr(r, x))))\n            r := or(r, shl(0x03, lt(0xff, shr(r, x))))\n            // We use a 5-bit deBruijn Sequence to convert `x`'s 8\n            // most-significant bits into an index. We then index the lookup\n            // table (bytewise) by the deBruijn symbol to obtain the bitwise\n            // inverse of its logarithm.\n            r :=\n                xor(\n                    r,\n                    byte(\n                        and(0x1f, shr(shr(r, x), 0x8421084210842108cc6318c6db6d54be)),\n                        0x7879797a797d7a7b797d7c7d7a7b7c7e797a7d7a7c7c7b7e7a7a7c7b7f7f7f7f\n                    )\n                )\n        }\n    }\n\n    function _clzUpper(uint256 x) private pure returns (uint256) {\n        return _clzLower(x >> 128);\n    }\n\n    function _shl(uint256 x_hi, uint256 x_lo, uint256 s) private pure returns (uint256 r_hi, uint256 r_lo) {\n        assembly (\"memory-safe\") {\n            r_hi := or(shl(s, x_hi), shr(sub(0x100, s), x_lo))\n            r_lo := shl(s, x_lo)\n        }\n    }\n\n    function _shl768(uint256 x_hi, uint256 x_lo, uint256 s)\n        private\n        pure\n        returns (uint256 r_ex, uint256 r_hi, uint256 r_lo)\n    {\n        assembly (\"memory-safe\") {\n            let neg_s := sub(0x100, s)\n            r_ex := shr(neg_s, x_hi)\n            r_hi := or(shl(s, x_hi), shr(neg_s, x_lo))\n            r_lo := shl(s, x_lo)\n        }\n    }\n\n    function _shr(uint256 x_hi, uint256 x_lo, uint256 s) private pure returns (uint256 r_hi, uint256 r_lo) {\n        assembly (\"memory-safe\") {\n            r_hi := shr(s, x_hi)\n            r_lo := or(shl(sub(0x100, s), x_hi), shr(s, x_lo))\n        }\n    }\n\n    // This function is a different modification of Knuth's Algorithm D. In this\n    // case, we're only interested in the (normalized) remainder instead of the\n    // quotient. We also substitute the normalization by division for\n    // normalization by shifting because it makes un-normalization more\n    // gas-efficient.\n\n    function _algorithmDRemainder(uint256 x_hi, uint256 x_lo, uint256 y_hi, uint256 y_lo)\n        private\n        pure\n        returns (uint256, uint256)\n    {\n        // We treat `x` and `y` each as ≤4-limb bigints where each limb is half\n        // a machine word (128 bits). This lets us perform 2-limb ÷ 1-limb\n        // divisions as a single operation (`div`) as required by Algorithm D.\n\n        uint256 s;\n        if (y_hi >> 128 != 0) {\n            // y is 4 limbs, x is 4 limbs\n\n            // Normalize. Ensure the uppermost limb of y ≥ 2¹²⁷ (equivalently\n            // y_hi >= 2**255). This is step D1 of Algorithm D Unlike the\n            // preceeding implementation of Algorithm D, we use a binary shift\n            // instead of a multiply to normalize. This performs a costly \"count\n            // leading zeroes\" operation, but it lets us transform an\n            // even-more-costly division-by-inversion operation later into a\n            // simple shift. This still ultimately satisfies the postcondition\n            // (y_hi >> 128 >= 1 << 127) without overflowing.\n            s = _clzUpper(y_hi);\n            uint256 x_ex;\n            (x_ex, x_hi, x_lo) = _shl768(x_hi, x_lo, s);\n            (y_hi, y_lo) = _shl(y_hi, y_lo, s);\n\n            // `n_approx` is the 2 most-significant limbs of x, after\n            // normalization\n            uint256 n_approx = (x_ex << 128) | (x_hi >> 128); // TODO: this can probably be optimized (combined with `_shl`)\n            // `d_approx` is the most significant limb of y, after normalization\n            uint256 d_approx = y_hi >> 128; // TODO: this can probably be optimized (combined with `_shl`)\n            // Normalization ensures that result of this division is an\n            // approximation of the most significant (and only) limb of the\n            // quotient and is too high by at most 3. This is the \"Calculate\n            // q-hat\" (D3) step of Algorithm D. (did you know that U+0302,\n            // COMBINING CIRCUMFLEX ACCENT cannot be combined with q? shameful)\n            uint256 q_hat = n_approx.unsafeDiv(d_approx);\n            uint256 r_hat = n_approx.unsafeMod(d_approx);\n\n            // The process of `_correctQ` subtracts up to 2 from `q_hat`, to\n            // make it more accurate. This is still part of the \"Calculate\n            // q-hat\" (D3) step of Algorithm D.\n            q_hat = _correctQ(q_hat, r_hat, x_hi & type(uint128).max, y_hi & type(uint128).max, y_hi);\n\n            {\n                // This penultimate correction subtracts q-hat × y from x to\n                // obtain the normalized remainder. This is the \"Multiply and\n                // subtract\" (D4) and \"Test remainder\" (D5) steps of Algorithm\n                // D, with some shortcutting\n                (uint256 tmp_ex, uint256 tmp_hi, uint256 tmp_lo) = _mul768(y_hi, y_lo, q_hat);\n                bool neg = _gt(tmp_ex, tmp_hi, tmp_lo, x_ex, x_hi, x_lo);\n                (x_hi, x_lo) = _sub(x_hi, x_lo, tmp_hi, tmp_lo);\n                // `x_ex` is now implicitly zero (or signals a carry that we\n                // will clear in the next step)\n\n                // Because `q_hat` may be too high by 1, we have to detect\n                // underflow from the previous step and correct it. This is the\n                // \"Add back\" (D6) step of Algorithm D\n                if (neg) {\n                    (x_hi, x_lo) = _add(x_hi, x_lo, y_hi, y_lo);\n                }\n            }\n        } else {\n            // y is 3 limbs\n\n            // Normalize. Ensure the most significant limb of y ≥ 2¹²⁷ (step D1)\n            // See above comment about the use of a shift instead of division.\n            s = _clzLower(y_hi);\n            (y_hi, y_lo) = _shl(y_hi, y_lo, s);\n            // `y_next` is the second-most-significant, nonzero, normalized limb\n            // of y\n            uint256 y_next = y_lo >> 128; // TODO: this can probably be optimized (combined with `_shl`)\n            // `y_whole` is the 2 most-significant, nonzero, normalized limbs of\n            // y\n            uint256 y_whole = (y_hi << 128) | y_next; // TODO: this can probably be optimized (combined with `_shl`)\n\n            if (x_hi >> 128 != 0) {\n                // x is 4 limbs; we have to run 2 iterations of Algorithm D to\n                // fully divide out by y\n\n                // Finish normalizing (step D1)\n                uint256 x_ex;\n                (x_ex, x_hi, x_lo) = _shl768(x_hi, x_lo, s);\n\n                uint256 n_approx = (x_ex << 128) | (x_hi >> 128); // TODO: this can probably be optimized (combined with `_shl768`)\n                // As before, `q_hat` is the most significant limb of the\n                // quotient and too high by at most 3 (step D3)\n                uint256 q_hat = n_approx.unsafeDiv(y_hi);\n                uint256 r_hat = n_approx.unsafeMod(y_hi);\n\n                // Subtract up to 2 from `q_hat`, improving our estimate (step\n                // D3)\n                q_hat = _correctQ(q_hat, r_hat, x_hi & type(uint128).max, y_next, y_whole);\n\n                // Subtract up to 1 from q-hat to make it exactly the\n                // most-significant limb of the quotient and subtract q-hat × y\n                // from x to clear the most-significant limb of x.\n                {\n                    // \"Multiply and subtract\" (D4) step of Algorithm D\n                    (uint256 tmp_hi, uint256 tmp_lo) = _mul(y_hi, y_lo, q_hat);\n                    uint256 tmp_ex = tmp_hi >> 128;\n                    tmp_hi = (tmp_hi << 128) | (tmp_lo >> 128);\n                    tmp_lo <<= 128;\n\n                    // \"Test remainder\" (D5) step of Algorithm D\n                    bool neg = _gt(tmp_ex, tmp_hi, tmp_lo, x_ex, x_hi, x_lo);\n                    // Finish step D4\n                    (x_hi, x_lo) = _sub(x_hi, x_lo, tmp_hi, tmp_lo);\n\n                    // \"Add back\" (D6) step of Algorithm D. We implicitly\n                    // subtract 1 from `q_hat`, but elide explicitly\n                    // representing that because `q_hat` is no longer needed.\n                    if (neg) {\n                        // This branch is quite rare, so it's gas-advantageous\n                        // to actually branch and usually skip the costly `_add`\n                        (x_hi, x_lo) = _add(x_hi, x_lo, y_whole, y_lo << 128);\n                    }\n                }\n                // `x_ex` is now zero (implicitly)\n                // [x_hi x_lo] now represents the partial, normalized remainder.\n\n                // Run another loop (steps D3 through D6) of Algorithm D to get\n                // the lower limb of the quotient\n                // Step D3\n                q_hat = x_hi.unsafeDiv(y_hi);\n                r_hat = x_hi.unsafeMod(y_hi);\n\n                // Step D3\n                q_hat = _correctQ(q_hat, r_hat, x_lo >> 128, y_next, y_whole);\n\n                // Again, implicitly correct q-hat to make it exactly the\n                // least-significant limb of the quotient. Subtract q-hat × y\n                // from x to obtain the normalized remainder.\n                {\n                    // Steps D4 and D5\n                    (uint256 tmp_hi, uint256 tmp_lo) = _mul(y_hi, y_lo, q_hat);\n                    bool neg = _gt(tmp_hi, tmp_lo, x_hi, x_lo);\n                    (x_hi, x_lo) = _sub(x_hi, x_lo, tmp_hi, tmp_lo);\n\n                    // Step D6\n                    if (neg) {\n                        (x_hi, x_lo) = _add(x_hi, x_lo, y_hi, y_lo);\n                    }\n                }\n            } else {\n                // x is 3 limbs\n\n                // Finish normalizing (step D1)\n                (x_hi, x_lo) = _shl(x_hi, x_lo, s);\n\n                // `q_hat` is the most significant (and only) limb of the\n                // quotient and too high by at most 3 (step D3)\n                uint256 q_hat = x_hi.unsafeDiv(y_hi);\n                uint256 r_hat = x_hi.unsafeMod(y_hi);\n\n                // Subtract up to 2 from `q_hat`, improving our estimate (step\n                // D3)\n                q_hat = _correctQ(q_hat, r_hat, x_lo >> 128, y_next, y_whole);\n\n                // Make `q_hat` exact (implicitly) and subtract q-hat × y from x\n                // to obtain the normalized remainder. (steps D4 through D6)\n                {\n                    (uint256 tmp_hi, uint256 tmp_lo) = _mul(y_hi, y_lo, q_hat);\n                    bool neg = _gt(tmp_hi, tmp_lo, x_hi, x_lo);\n                    (x_hi, x_lo) = _sub(x_hi, x_lo, tmp_hi, tmp_lo);\n                    if (neg) {\n                        (x_hi, x_lo) = _add(x_hi, x_lo, y_hi, y_lo);\n                    }\n                }\n            }\n        }\n        // All other cases are handled by the checks that y ≥ 2²⁵⁶ (equivalently\n        // y_hi != 0) and that x ≥ y\n\n        // The second-most-significant limb of normalized x is now zero\n        // (equivalently x_hi < 2**128), but because the entire machine is not\n        // guaranteed to be cleared, we can't optimize any further.\n\n        // [x_hi x_lo] now represents remainder × 2ˢ (the normalized remainder);\n        // we shift right by `s` (un-normalize) to obtain the result.\n        return _shr(x_hi, x_lo, s);\n    }\n\n    function odivAlt(uint512 r, uint512 x, uint512 y) internal pure returns (uint512) {\n        (uint256 y_hi, uint256 y_lo) = y.into();\n        if (y_hi == 0) {\n            // This is the only case where we can have a 2-word quotient\n            return odiv(r, x, y_lo);\n        }\n        (uint256 x_hi, uint256 x_lo) = x.into();\n        if (y_lo == 0) {\n            uint256 r_lo = x_hi.unsafeDiv(y_hi);\n            return r.from(0, r_lo);\n        }\n        if (_gt(y_hi, y_lo, x_hi, x_lo)) {\n            return r.from(0, 0);\n        }\n\n        // At this point, we know that both `x` and `y` are fully represented by\n        // 2 words. There is no simpler representation for the problem. We must\n        // use Knuth's Algorithm D.\n        {\n            uint256 r_lo = _algorithmD(x_hi, x_lo, y_hi, y_lo);\n            return r.from(0, r_lo);\n        }\n    }\n\n    function idivAlt(uint512 r, uint512 y) internal pure returns (uint512) {\n        return odivAlt(r, r, y);\n    }\n\n    function irdivAlt(uint512 r, uint512 y) internal pure returns (uint512) {\n        return odivAlt(r, y, r);\n    }\n\n    function divAlt(uint512 x, uint512 y) internal pure returns (uint256) {\n        (uint256 y_hi, uint256 y_lo) = y.into();\n        if (y_hi == 0) {\n            return div(x, y_lo);\n        }\n        (uint256 x_hi, uint256 x_lo) = x.into();\n        if (y_lo == 0) {\n            return x_hi.unsafeDiv(y_hi);\n        }\n        if (_gt(y_hi, y_lo, x_hi, x_lo)) {\n            return 0;\n        }\n\n        // At this point, we know that both `x` and `y` are fully represented by\n        // 2 words. There is no simpler representation for the problem. We must\n        // use Knuth's Algorithm D.\n        return _algorithmD(x_hi, x_lo, y_hi, y_lo);\n    }\n\n    function omodAlt(uint512 r, uint512 x, uint512 y) internal pure returns (uint512) {\n        (uint256 y_hi, uint256 y_lo) = y.into();\n        if (y_hi == 0) {\n            uint256 r_lo = mod(x, y_lo);\n            return r.from(0, r_lo);\n        }\n        (uint256 x_hi, uint256 x_lo) = x.into();\n        if (y_lo == 0) {\n            uint256 r_hi = x_hi.unsafeMod(y_hi);\n            return r.from(r_hi, x_lo);\n        }\n        if (_gt(y_hi, y_lo, x_hi, x_lo)) {\n            return r.from(x_hi, x_lo);\n        }\n\n        // At this point, we know that both `x` and `y` are fully represented by\n        // 2 words. There is no simpler representation for the problem. We must\n        // use Knuth's Algorithm D.\n        {\n            (uint256 r_hi, uint256 r_lo) = _algorithmDRemainder(x_hi, x_lo, y_hi, y_lo);\n            return r.from(r_hi, r_lo);\n        }\n    }\n\n    function imodAlt(uint512 r, uint512 y) internal pure returns (uint512) {\n        return omodAlt(r, r, y);\n    }\n\n    function irmodAlt(uint512 r, uint512 y) internal pure returns (uint512) {\n        return omodAlt(r, y, r);\n    }\n}\n\nusing Lib512MathArithmetic for uint512 global;\n\nlibrary Lib512MathUserDefinedHelpers {\n    function checkNull(uint512 x, uint512 y) internal pure {\n        assembly (\"memory-safe\") {\n            if iszero(mul(x, y)) {\n                mstore(0x00, 0x4e487b71) // selector for `Panic(uint256)`\n                mstore(0x20, 0x01) // code for \"assertion failure\"\n            }\n        }\n    }\n\n    function smuggleToPure(function (uint512, uint512, uint512) internal view returns (uint512) f)\n        internal\n        pure\n        returns (function (uint512, uint512, uint512) internal pure returns (uint512) r)\n    {\n        assembly (\"memory-safe\") {\n            r := f\n        }\n    }\n\n    function omod(uint512 r, uint512 x, uint512 y) internal view returns (uint512) {\n        return r.omod(x, y);\n    }\n\n    function odiv(uint512 r, uint512 x, uint512 y) internal view returns (uint512) {\n        return r.odiv(x, y);\n    }\n}\n\nfunction __add(uint512 x, uint512 y) pure returns (uint512 r) {\n    Lib512MathUserDefinedHelpers.checkNull(x, y);\n    r.oadd(x, y);\n}\n\nfunction __sub(uint512 x, uint512 y) pure returns (uint512 r) {\n    Lib512MathUserDefinedHelpers.checkNull(x, y);\n    r.osub(x, y);\n}\n\nfunction __mul(uint512 x, uint512 y) pure returns (uint512 r) {\n    Lib512MathUserDefinedHelpers.checkNull(x, y);\n    r.omul(x, y);\n}\n\nfunction __mod(uint512 x, uint512 y) pure returns (uint512 r) {\n    Lib512MathUserDefinedHelpers.checkNull(x, y);\n    Lib512MathUserDefinedHelpers.smuggleToPure(Lib512MathUserDefinedHelpers.omod)(r, x, y);\n}\n\nfunction __div(uint512 x, uint512 y) pure returns (uint512 r) {\n    Lib512MathUserDefinedHelpers.checkNull(x, y);\n    Lib512MathUserDefinedHelpers.smuggleToPure(Lib512MathUserDefinedHelpers.odiv)(r, x, y);\n}\n\nusing {__add as +, __sub as -, __mul as *, __mod as %, __div as / } for uint512 global;\n\nstruct uint512_external {\n    uint256 hi;\n    uint256 lo;\n}\n\nlibrary Lib512MathExternal {\n    function from(uint512 r, uint512_external memory x) internal pure returns (uint512) {\n        assembly (\"memory-safe\") {\n            mstore(r, mload(x))\n            mstore(add(0x20, r), mload(add(0x20, x)))\n        }\n        return r;\n    }\n\n    function into(uint512_external memory x) internal pure returns (uint512 r) {\n        assembly (\"memory-safe\") {\n            r := x\n        }\n    }\n\n    function toExternal(uint512 x) internal pure returns (uint512_external memory r) {\n        assembly (\"memory-safe\") {\n            if iszero(eq(mload(0x40), add(0x40, r))) { revert(0x00, 0x00) }\n            mstore(0x40, r)\n            r := x\n        }\n    }\n}\n\nusing Lib512MathExternal for uint512 global;\nusing Lib512MathExternal for uint512_external global;\n\n// src/utils/AddressDerivation.sol\n\nlibrary AddressDerivation {\n    using UnsafeMath for uint256;\n\n    uint256 internal constant _SECP256K1_P = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F;\n    uint256 internal constant _SECP256K1_N = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141;\n    uint256 internal constant SECP256K1_GX = 0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798;\n    uint256 internal constant SECP256K1_GY = 0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8;\n\n    error InvalidCurve(uint256 x, uint256 y);\n\n    // keccak256(abi.encodePacked(ECMUL([x, y], k)))[12:]\n    function deriveEOA(uint256 x, uint256 y, uint256 k) internal pure returns (address) {\n        if (k == 0) {\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n        if (k >= _SECP256K1_N || x >= _SECP256K1_P || y >= _SECP256K1_P) {\n            Panic.panic(Panic.ARITHMETIC_OVERFLOW);\n        }\n\n        // +/-7 are neither square nor cube mod p, so we only have to check one\n        // coordinate against 0. if it is 0, then the other is too (the point at\n        // infinity) or the point is invalid\n        if (\n            x == 0\n                || y.unsafeMulMod(y, _SECP256K1_P)\n                    != x.unsafeMulMod(x, _SECP256K1_P).unsafeMulMod(x, _SECP256K1_P).unsafeAddMod(7, _SECP256K1_P)\n        ) {\n            revert InvalidCurve(x, y);\n        }\n\n        unchecked {\n            // https://ethresear.ch/t/you-can-kinda-abuse-ecrecover-to-do-ecmul-in-secp256k1-today/2384\n            return ecrecover(\n                bytes32(0), uint8(27 + (y & 1)), bytes32(x), bytes32(UnsafeMath.unsafeMulMod(x, k, _SECP256K1_N))\n            );\n        }\n    }\n\n    // keccak256(RLP([deployer, nonce]))[12:]\n    function deriveContract(address deployer, uint64 nonce) internal pure returns (address result) {\n        if (nonce == 0) {\n            assembly (\"memory-safe\") {\n                mstore(\n                    0x00,\n                    or(\n                        0xd694000000000000000000000000000000000000000080,\n                        shl(8, and(0xffffffffffffffffffffffffffffffffffffffff, deployer))\n                    )\n                )\n                result := keccak256(0x09, 0x17)\n            }\n        } else if (nonce < 0x80) {\n            assembly (\"memory-safe\") {\n                // we don't care about dirty bits in `deployer`; they'll be overwritten later\n                mstore(0x14, deployer)\n                mstore(0x00, 0xd694)\n                mstore8(0x34, nonce)\n                result := keccak256(0x1e, 0x17)\n            }\n        } else {\n            // compute ceil(log_256(nonce)) + 1\n            uint256 nonceLength = 8;\n            unchecked {\n                if ((uint256(nonce) >> 32) != 0) {\n                    nonceLength += 32;\n                    if (nonce == type(uint64).max) {\n                        Panic.panic(Panic.ARITHMETIC_OVERFLOW);\n                    }\n                }\n                if ((uint256(nonce) >> 8) >= (1 << nonceLength)) {\n                    nonceLength += 16;\n                }\n                if (uint256(nonce) >= (1 << nonceLength)) {\n                    nonceLength += 8;\n                }\n                // ceil\n                if ((uint256(nonce) << 8) >= (1 << nonceLength)) {\n                    nonceLength += 8;\n                }\n                // bytes, not bits\n                nonceLength >>= 3;\n            }\n            assembly (\"memory-safe\") {\n                // we don't care about dirty bits in `deployer` or `nonce`. they'll be overwritten later\n                mstore(nonceLength, nonce)\n                mstore8(0x20, add(0x7f, nonceLength))\n                mstore(0x00, deployer)\n                mstore8(0x0a, add(0xd5, nonceLength))\n                mstore8(0x0b, 0x94)\n                result := keccak256(0x0a, add(0x16, nonceLength))\n            }\n        }\n    }\n\n    // keccak256(abi.encodePacked(bytes1(0xff), deployer, salt, initHash))[12:]\n    function deriveDeterministicContract(address deployer, bytes32 salt, bytes32 initHash)\n        internal\n        pure\n        returns (address result)\n    {\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40)\n            // we don't care about dirty bits in `deployer`; they'll be overwritten later\n            mstore(ptr, deployer)\n            mstore8(add(ptr, 0x0b), 0xff)\n            mstore(add(ptr, 0x20), salt)\n            mstore(add(ptr, 0x40), initHash)\n            result := keccak256(add(ptr, 0x0b), 0x55)\n        }\n    }\n}\n\n// src/vendor/FullMath.sol\n\n/// @title Contains 512-bit math functions\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\n/// @dev Handles \"phantom overflow\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\n/// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\nlibrary FullMath {\n    using UnsafeMath for uint256;\n\n    /// @notice 512-bit multiply [prod1 prod0] = a * b\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return prod0 Least significant 256 bits of the product\n    /// @return prod1 Most significant 256 bits of the product\n    /// @return remainder Remainder of full-precision division\n    function _mulDivSetup(uint256 a, uint256 b, uint256 denominator)\n        private\n        pure\n        returns (uint256 prod0, uint256 prod1, uint256 remainder)\n    {\n        // Compute the product mod 2**256 and mod 2**256 - 1 then use the Chinese\n        // Remainder Theorem to reconstruct the 512 bit result. The result is stored\n        // in two 256 variables such that product = prod1 * 2**256 + prod0\n        assembly (\"memory-safe\") {\n            // Full-precision multiplication\n            {\n                let mm := mulmod(a, b, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n                prod0 := mul(a, b)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            remainder := mulmod(a, b, denominator)\n        }\n    }\n\n    /// @notice 512-bit by 256-bit division.\n    /// @param prod0 Least significant 256 bits of the product\n    /// @param prod1 Most significant 256 bits of the product\n    /// @param denominator The divisor\n    /// @param remainder Remainder of full-precision division\n    /// @return The 256-bit result\n    /// @dev Overflow and division by zero aren't checked and are GIGO errors\n    function _mulDivInvert(uint256 prod0, uint256 prod1, uint256 denominator, uint256 remainder)\n        private\n        pure\n        returns (uint256)\n    {\n        uint256 inv;\n        assembly (\"memory-safe\") {\n            // Make division exact by rounding [prod1 prod0] down to a multiple of\n            // denominator\n            // Subtract 256 bit number from 512 bit number\n            prod1 := sub(prod1, gt(remainder, prod0))\n            prod0 := sub(prod0, remainder)\n\n            // Factor powers of two out of denominator\n            {\n                // Compute largest power of two divisor of denominator.\n                // Always >= 1.\n                let twos := and(sub(0, denominator), denominator)\n\n                // Divide denominator by power of two\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by the factors of two\n                prod0 := div(prod0, twos)\n                // Shift in bits from prod1 into prod0. For this we need to flip `twos`\n                // such that it is 2**256 / twos.\n                // If twos is zero, then it becomes one\n                twos := add(div(sub(0, twos), twos), 1)\n                prod0 := or(prod0, mul(prod1, twos))\n            }\n\n            // Invert denominator mod 2**256\n            // Now that denominator is an odd number, it has an inverse modulo 2**256\n            // such that denominator * inv = 1 mod 2**256.\n            // Compute the inverse by starting with a seed that is correct correct for\n            // four bits. That is, denominator * inv = 1 mod 2**4\n            inv := xor(mul(3, denominator), 2)\n\n            // Now use Newton-Raphson iteration to improve the precision.\n            // Thanks to Hensel's lifting lemma, this also works in modular\n            // arithmetic, doubling the correct bits in each step.\n            inv := mul(inv, sub(2, mul(denominator, inv))) // inverse mod 2**8\n            inv := mul(inv, sub(2, mul(denominator, inv))) // inverse mod 2**16\n            inv := mul(inv, sub(2, mul(denominator, inv))) // inverse mod 2**32\n            inv := mul(inv, sub(2, mul(denominator, inv))) // inverse mod 2**64\n            inv := mul(inv, sub(2, mul(denominator, inv))) // inverse mod 2**128\n            inv := mul(inv, sub(2, mul(denominator, inv))) // inverse mod 2**256\n        }\n\n        // Because the division is now exact we can divide by multiplying with the\n        // modular inverse of denominator. This will give us the correct result\n        // modulo 2**256. Since the precoditions guarantee that the outcome is less\n        // than 2**256, this is the final result.  We don't need to compute the high\n        // bits of the result and prod1 is no longer required.\n        unchecked {\n            return prod0 * inv;\n        }\n    }\n\n    /// @notice Calculates a×b÷denominator with full precision then rounds towards 0. Throws if result overflows a uint256 or denominator == 0\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return The 256-bit result\n    function mulDiv(uint256 a, uint256 b, uint256 denominator) internal pure returns (uint256) {\n        (uint256 prod0, uint256 prod1, uint256 remainder) = _mulDivSetup(a, b, denominator);\n        // Make sure the result is less than 2**256.\n        // Also prevents denominator == 0\n        if (denominator <= prod1) {\n            Panic.panic(denominator == 0 ? Panic.DIVISION_BY_ZERO : Panic.ARITHMETIC_OVERFLOW);\n        }\n\n        // Handle non-overflow cases, 256 by 256 division\n        if (prod1 == 0) {\n            return prod0.unsafeDiv(denominator);\n        }\n        return _mulDivInvert(prod0, prod1, denominator, remainder);\n    }\n\n    /// @notice Calculates a×b÷denominator with full precision then rounds towards 0. Overflowing a uint256 or denominator == 0 are GIGO errors\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return The 256-bit result\n    function unsafeMulDiv(uint256 a, uint256 b, uint256 denominator) internal pure returns (uint256) {\n        (uint256 prod0, uint256 prod1, uint256 remainder) = _mulDivSetup(a, b, denominator);\n        // Overflow and zero-division checks are skipped\n        // Handle non-overflow cases, 256 by 256 division\n        if (prod1 == 0) {\n            return prod0.unsafeDiv(denominator);\n        }\n        return _mulDivInvert(prod0, prod1, denominator, remainder);\n    }\n\n    /// @notice Calculates a×b÷denominator with full precision then rounds towards 0. Overflowing a uint256 or denominator == 0 are GIGO errors\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @dev This is the branchless, straight line version of `unsafeMulDiv`. If we know that `prod1 != 0` this may be faster. Also this gives Solc a better chance to optimize.\n    /// @return The 256-bit result\n    function unsafeMulDivAlt(uint256 a, uint256 b, uint256 denominator) internal pure returns (uint256) {\n        (uint256 prod0, uint256 prod1, uint256 remainder) = _mulDivSetup(a, b, denominator);\n        return _mulDivInvert(prod0, prod1, denominator, remainder);\n    }\n}\n\n// src/core/Permit2PaymentAbstract.sol\n\nabstract contract Permit2PaymentAbstract is AbstractContext {\n    string internal constant TOKEN_PERMISSIONS_TYPE = \"TokenPermissions(address token,uint256 amount)\";\n\n    function _isRestrictedTarget(address) internal view virtual returns (bool);\n\n    function _operator() internal view virtual returns (address);\n\n    function _permitToSellAmountCalldata(ISignatureTransfer.PermitTransferFrom calldata permit)\n        internal\n        view\n        virtual\n        returns (uint256 sellAmount);\n\n    function _permitToSellAmount(ISignatureTransfer.PermitTransferFrom memory permit)\n        internal\n        view\n        virtual\n        returns (uint256 sellAmount);\n\n    function _permitToTransferDetails(ISignatureTransfer.PermitTransferFrom memory permit, address recipient)\n        internal\n        view\n        virtual\n        returns (ISignatureTransfer.SignatureTransferDetails memory transferDetails, uint256 sellAmount);\n\n    function _transferFromIKnowWhatImDoing(\n        ISignatureTransfer.PermitTransferFrom memory permit,\n        ISignatureTransfer.SignatureTransferDetails memory transferDetails,\n        address from,\n        bytes32 witness,\n        string memory witnessTypeString,\n        bytes memory sig,\n        bool isForwarded\n    ) internal virtual;\n\n    function _transferFromIKnowWhatImDoing(\n        ISignatureTransfer.PermitTransferFrom memory permit,\n        ISignatureTransfer.SignatureTransferDetails memory transferDetails,\n        address from,\n        bytes32 witness,\n        string memory witnessTypeString,\n        bytes memory sig\n    ) internal virtual;\n\n    function _transferFrom(\n        ISignatureTransfer.PermitTransferFrom memory permit,\n        ISignatureTransfer.SignatureTransferDetails memory transferDetails,\n        bytes memory sig,\n        bool isForwarded\n    ) internal virtual;\n\n    function _transferFrom(\n        ISignatureTransfer.PermitTransferFrom memory permit,\n        ISignatureTransfer.SignatureTransferDetails memory transferDetails,\n        bytes memory sig\n    ) internal virtual;\n\n    function _setOperatorAndCall(\n        address target,\n        bytes memory data,\n        uint32 selector,\n        function (bytes calldata) internal returns (bytes memory) callback\n    ) internal virtual returns (bytes memory);\n\n    modifier metaTx(address msgSender, bytes32 witness) virtual;\n\n    modifier takerSubmitted() virtual;\n\n    function _allowanceHolderTransferFrom(address token, address owner, address recipient, uint256 amount)\n        internal\n        virtual;\n}\n\n// src/core/FlashAccountingCommon.sol\n\nlibrary CreditDebt {\n    using UnsafeMath for int256;\n\n    function asCredit(int256 delta, NotePtr note) internal pure returns (uint256) {\n        if (delta < 0) {\n            assembly (\"memory-safe\") {\n                mstore(note, 0x4c085bf1) // selector for `DeltaNotPositive(address)`; clobbers `note.amount()`\n                revert(add(0x1c, note), 0x24)\n            }\n        }\n        return uint256(delta);\n    }\n\n    function asDebt(int256 delta, NotePtr note) internal pure returns (uint256) {\n        if (delta > 0) {\n            assembly (\"memory-safe\") {\n                mstore(note, 0x3351b260) // selector for `DeltaNotNegative(address)`; clobbers `note.amount()`\n                revert(add(0x1c, note), 0x24)\n            }\n        }\n        return uint256(delta.unsafeNeg());\n    }\n}\n\n/// This type is the same as `NotesLib.Note`, but as a user-defined value type to sidestep solc's\n/// awful memory handling.\ntype NotePtr is uint256;\n\n/// This library is a highly-optimized, in-memory, enumerable mapping from tokens to amounts. It\n/// consists of 2 components that must be kept synchronized. There is a `memory` array of `Note`\n/// (aka `Note[] memory`) that has up to `MAX_TOKENS` pre-allocated. And there is an implicit heap\n/// packed at the end of the array that stores the `Note`s. Each `Note` has a backpointer that knows\n/// its location in the `Notes[] memory`. While the length of the `Notes[]` array grows and shrinks\n/// as tokens are added and retired, heap objects are only cleared/deallocated when the context\n/// returns. Looking up the `Note` object corresponding to a token uses the perfect hash formed by\n/// `hashMul` and `hashMod`. Pay special attention to these parameters. See further below for\n/// recommendations on how to select values for them. A hash collision will result in a revert with\n/// signature `TokenHashCollision(address,address)`.\nlibrary NotesLib {\n    uint256 private constant _ADDRESS_MASK = 0x00ffffffffffffffffffffffffffffffffffffffff;\n\n    /// This is the maximum number of tokens that may be involved in an action. Increasing or\n    /// decreasing this value requires no other changes elsewhere in this file.\n    uint256 internal constant MAX_TOKENS = 8;\n\n    type NotePtrPtr is uint256;\n\n    struct Note {\n        uint256 amount;\n        IERC20 token;\n        NotePtrPtr backPtr;\n    }\n\n    function construct() internal pure returns (Note[] memory r) {\n        assembly (\"memory-safe\") {\n            r := mload(0x40)\n            // set the length of `r` to zero\n            mstore(r, 0x00)\n            // zeroize the heap\n            codecopy(add(add(0x20, shl(0x05, MAX_TOKENS)), r), codesize(), mul(0x60, MAX_TOKENS))\n            // allocate memory\n            mstore(0x40, add(add(0x20, shl(0x07, MAX_TOKENS)), r))\n        }\n    }\n\n    function amount(NotePtr note) internal pure returns (uint256 r) {\n        assembly (\"memory-safe\") {\n            r := mload(note)\n        }\n    }\n\n    function setAmount(NotePtr note, uint256 newAmount) internal pure {\n        assembly (\"memory-safe\") {\n            mstore(note, newAmount)\n        }\n    }\n\n    function token(NotePtr note) internal pure returns (IERC20 r) {\n        assembly (\"memory-safe\") {\n            r := mload(add(0x20, note))\n        }\n    }\n\n    function eq(Note memory x, Note memory y) internal pure returns (bool) {\n        NotePtr yp;\n        assembly (\"memory-safe\") {\n            yp := y\n        }\n        return eq(x, yp);\n    }\n\n    function eq(Note memory x, NotePtr y) internal pure returns (bool) {\n        NotePtr xp;\n        assembly (\"memory-safe\") {\n            xp := x\n        }\n        return eq(xp, y);\n    }\n\n    function eq(NotePtr x, NotePtr y) internal pure returns (bool r) {\n        assembly (\"memory-safe\") {\n            r := eq(x, y)\n        }\n    }\n\n    function unsafeGet(Note[] memory a, uint256 i) internal pure returns (IERC20 retToken, uint256 retAmount) {\n        assembly (\"memory-safe\") {\n            let x := mload(add(add(0x20, shl(0x05, i)), a))\n            retToken := mload(add(0x20, x))\n            retAmount := mload(x)\n        }\n    }\n\n    //// How to generate a perfect hash:\n    ////\n    //// The arguments `hashMul` and `hashMod` are required to form a perfect hash for a table with\n    //// size `NotesLib.MAX_TOKENS` when applied to all the tokens involved in fills. The hash\n    //// function is constructed as `uint256 hash = mulmod(uint256(uint160(address(token))),\n    //// hashMul, hashMod) % NotesLib.MAX_TOKENS`.\n    ////\n    //// The \"simple\" or \"obvious\" way to do this is to simply try random 128-bit numbers for both\n    //// `hashMul` and `hashMod` until you obtain a function that has no collisions when applied to\n    //// the tokens involved in fills. A substantially more optimized algorithm can be obtained by\n    //// selecting several (at least 10) prime values for `hashMod`, precomputing the limb moduluses\n    //// for each value, and then selecting randomly from among them. The author recommends using\n    //// the 10 largest 64-bit prime numbers: 2^64 - {59, 83, 95, 179, 189, 257, 279, 323, 353,\n    //// 363}. `hashMul` can then be selected randomly or via some other optimized method.\n    ////\n    //// Note that in spite of the fact that some AMMs represent Ether (or the native asset of the\n    //// chain) as `address(0)`, we represent Ether as `SettlerAbstract.ETH_ADDRESS` (the address of\n    //// all `e`s) for homogeneity with other parts of the codebase, and because the decision to\n    //// represent Ether as `address(0)` was stupid in the first place. `address(0)` represents the\n    //// absence of a thing, not a special case of the thing. It creates confusion with\n    //// uninitialized memory, storage, and variables.\n    function get(Note[] memory a, IERC20 newToken, uint256 hashMul, uint256 hashMod)\n        internal\n        pure\n        returns (NotePtr x)\n    {\n        assembly (\"memory-safe\") {\n            newToken := and(_ADDRESS_MASK, newToken)\n            x := add(add(0x20, shl(0x05, MAX_TOKENS)), a) // `x` now points at the first `Note` on the heap\n            x := add(mod(mulmod(newToken, hashMul, hashMod), mul(0x60, MAX_TOKENS)), x) // combine with token hash\n            // `x` now points at the exact `Note` object we want; let's check it to be sure, though\n            let x_token_ptr := add(0x20, x)\n\n            // check that we haven't encountered a hash collision. checking for a hash collision is\n            // equivalent to checking for array out-of-bounds or overflow.\n            {\n                let old_token := mload(x_token_ptr)\n                if mul(or(mload(add(0x40, x)), old_token), xor(old_token, newToken)) {\n                    mstore(0x00, 0x9a62e8b4) // selector for `TokenHashCollision(address,address)`\n                    mstore(0x20, old_token)\n                    mstore(0x40, newToken)\n                    revert(0x1c, 0x44)\n                }\n            }\n\n            // zero `newToken` is a footgun; check for it\n            if iszero(newToken) {\n                mstore(0x00, 0xad1991f5) // selector for `ZeroToken()`\n                revert(0x1c, 0x04)\n            }\n\n            // initialize the token (possibly redundant)\n            mstore(x_token_ptr, newToken)\n        }\n    }\n\n    function add(Note[] memory a, Note memory x) internal pure {\n        NotePtr xp;\n        assembly (\"memory-safe\") {\n            xp := x\n        }\n        return add(a, xp);\n    }\n\n    function add(Note[] memory a, NotePtr x) internal pure {\n        assembly (\"memory-safe\") {\n            let backptr_ptr := add(0x40, x)\n            let backptr := mload(backptr_ptr)\n            if iszero(backptr) {\n                let len := add(0x01, mload(a))\n                // We don't need to check for overflow or out-of-bounds access here; the checks in\n                // `get` above for token collision handle that for us. It's not possible to `get`\n                // more than `MAX_TOKENS` tokens\n                mstore(a, len)\n                backptr := add(shl(0x05, len), a)\n                mstore(backptr, x)\n                mstore(backptr_ptr, backptr)\n            }\n        }\n    }\n\n    function del(Note[] memory a, Note memory x) internal pure {\n        NotePtr xp;\n        assembly (\"memory-safe\") {\n            xp := x\n        }\n        return del(a, xp);\n    }\n\n    function del(Note[] memory a, NotePtr x) internal pure {\n        assembly (\"memory-safe\") {\n            let x_backptr_ptr := add(0x40, x)\n            let x_backptr := mload(x_backptr_ptr)\n            if x_backptr {\n                // Clear the backpointer in the referred-to `Note`\n                mstore(x_backptr_ptr, 0x00)\n                // We do not deallocate `x`\n\n                // Decrement the length of `a`\n                let len := mload(a)\n                mstore(a, sub(len, 0x01))\n\n                // Check if this is a \"swap and pop\" or just a \"pop\"\n                let end_ptr := add(shl(0x05, len), a)\n                if iszero(eq(end_ptr, x_backptr)) {\n                    // Overwrite the vacated indirection pointer `x_backptr` with the value at the end.\n                    let end := mload(end_ptr)\n                    mstore(x_backptr, end)\n\n                    // Fix up the backpointer in `end` to point to the new location of the indirection\n                    // pointer.\n                    let end_backptr_ptr := add(0x40, end)\n                    mstore(end_backptr_ptr, x_backptr)\n                }\n            }\n        }\n    }\n}\n\nusing NotesLib for NotePtr global;\n\n/// `State` behaves as if it were declared as:\n///     struct State {\n///         NotesLib.Note buy;\n///         NotesLib.Note sell;\n///         NotesLib.Note globalSell;\n///         uint256 globalSellAmount;\n///         uint256 _hashMul;\n///         uint256 _hashMod;\n///     }\n/// but we use a user-defined value type because solc generates very gas-inefficient boilerplate\n/// that allocates and zeroes a bunch of memory. Consequently, everything is written in assembly and\n/// accessors are provided for the relevant members.\ntype State is bytes32;\n\nlibrary StateLib {\n    using NotesLib for NotesLib.Note;\n    using NotesLib for NotesLib.Note[];\n\n    function construct(IERC20 token, uint256 hashMul, uint256 hashMod)\n        internal\n        pure\n        returns (State state, NotesLib.Note[] memory notes)\n    {\n        assembly (\"memory-safe\") {\n            // Allocate memory\n            state := mload(0x40)\n            mstore(0x40, add(0xc0, state))\n        }\n        // All the pointers in `state` are now pointing into unallocated memory\n        notes = NotesLib.construct();\n        // The pointers in `state` are now illegally aliasing elements in `notes`\n        NotePtr notePtr = notes.get(token, hashMul, hashMod);\n\n        // Here we actually set the pointers into a legal area of memory\n        setBuy(state, notePtr);\n        setSell(state, notePtr);\n        assembly (\"memory-safe\") {\n            // Set `state.globalSell`\n            mstore(add(0x40, state), notePtr)\n            // Set `state._hashMul`\n            mstore(add(0x80, state), hashMul)\n            // Set `state._hashMod`\n            mstore(add(0xa0, state), hashMod)\n        }\n    }\n\n    function buy(State state) internal pure returns (NotePtr note) {\n        assembly (\"memory-safe\") {\n            note := mload(state)\n        }\n    }\n\n    function sell(State state) internal pure returns (NotePtr note) {\n        assembly (\"memory-safe\") {\n            note := mload(add(0x20, state))\n        }\n    }\n\n    function globalSell(State state) internal pure returns (NotePtr note) {\n        assembly (\"memory-safe\") {\n            note := mload(add(0x40, state))\n        }\n    }\n\n    function globalSellAmount(State state) internal pure returns (uint256 r) {\n        assembly (\"memory-safe\") {\n            r := mload(add(0x60, state))\n        }\n    }\n\n    function setGlobalSellAmount(State state, uint256 newGlobalSellAmount) internal pure {\n        assembly (\"memory-safe\") {\n            mstore(add(0x60, state), newGlobalSellAmount)\n        }\n    }\n\n    function _hashMul(State state) private pure returns (uint256 r) {\n        assembly (\"memory-safe\") {\n            r := mload(add(0x80, state))\n        }\n    }\n\n    function _hashMod(State state) private pure returns (uint256 r) {\n        assembly (\"memory-safe\") {\n            r := mload(add(0xa0, state))\n        }\n    }\n\n    function checkZeroSellAmount(State state) internal pure {\n        NotePtr globalSell_ = state.globalSell();\n        if (globalSell_.amount() == 0) {\n            assembly (\"memory-safe\") {\n                mstore(globalSell_, 0xfb772a88) // selector for `ZeroSellAmount(address)`; clobbers `globalSell_.amount()`\n                revert(add(0x1c, globalSell_), 0x24)\n            }\n        }\n    }\n\n    function setSell(State state, NotePtr notePtr) internal pure {\n        assembly (\"memory-safe\") {\n            mstore(add(0x20, state), notePtr)\n        }\n    }\n\n    function setSell(State state, NotesLib.Note[] memory notes, IERC20 token) internal pure {\n        setSell(state, notes.get(token, _hashMul(state), _hashMod(state)));\n    }\n\n    function setBuy(State state, NotePtr notePtr) internal pure {\n        assembly (\"memory-safe\") {\n            mstore(state, notePtr)\n        }\n    }\n\n    function setBuy(State state, NotesLib.Note[] memory notes, IERC20 token) internal pure {\n        setBuy(state, notes.get(token, _hashMul(state), _hashMod(state)));\n    }\n}\n\nusing StateLib for State global;\n\nlibrary Encoder {\n    uint256 internal constant BASIS = 10_000;\n\n    function encode(\n        uint32 unlockSelector,\n        address recipient,\n        IERC20 sellToken,\n        uint256 bps,\n        bool feeOnTransfer,\n        uint256 hashMul,\n        uint256 hashMod,\n        bytes memory fills,\n        uint256 amountOutMin\n    ) internal view returns (bytes memory data) {\n        if (bps > BASIS) {\n            Panic.panic(Panic.ARITHMETIC_OVERFLOW);\n        }\n        if (amountOutMin > uint128(type(int128).max)) {\n            Panic.panic(Panic.ARITHMETIC_OVERFLOW);\n        }\n        hashMul *= 96;\n        hashMod *= 96;\n        if (hashMul > type(uint128).max) {\n            Panic.panic(Panic.ARITHMETIC_OVERFLOW);\n        }\n        if (hashMod > type(uint128).max) {\n            Panic.panic(Panic.ARITHMETIC_OVERFLOW);\n        }\n        assembly (\"memory-safe\") {\n            data := mload(0x40)\n\n            let pathLen := mload(fills)\n            mcopy(add(0xd3, data), add(0x20, fills), pathLen)\n\n            mstore(add(0xb3, data), bps)\n            mstore(add(0xb1, data), sellToken)\n            mstore(add(0x9d, data), address()) // payer\n            // feeOnTransfer (1 byte)\n\n            mstore(add(0x88, data), hashMod)\n            mstore(add(0x78, data), hashMul)\n            mstore(add(0x68, data), amountOutMin)\n            mstore(add(0x58, data), recipient)\n            mstore(add(0x44, data), add(0x6f, pathLen))\n            mstore(add(0x24, data), 0x20)\n            mstore(add(0x04, data), and(0xffffffff, unlockSelector))\n            mstore(data, add(0xb3, pathLen))\n            mstore8(add(0xa8, data), feeOnTransfer)\n\n            mstore(0x40, add(data, add(0xd3, pathLen)))\n        }\n    }\n\n    function encodeVIP(\n        uint32 unlockSelector,\n        address recipient,\n        bool feeOnTransfer,\n        uint256 hashMul,\n        uint256 hashMod,\n        bytes memory fills,\n        ISignatureTransfer.PermitTransferFrom memory permit,\n        bytes memory sig,\n        bool isForwarded,\n        uint256 amountOutMin\n    ) internal pure returns (bytes memory data) {\n        if (amountOutMin > uint128(type(int128).max)) {\n            Panic.panic(Panic.ARITHMETIC_OVERFLOW);\n        }\n        hashMul *= 96;\n        hashMod *= 96;\n        if (hashMul > type(uint128).max) {\n            Panic.panic(Panic.ARITHMETIC_OVERFLOW);\n        }\n        if (hashMod > type(uint128).max) {\n            Panic.panic(Panic.ARITHMETIC_OVERFLOW);\n        }\n        assembly (\"memory-safe\") {\n            data := mload(0x40)\n\n            let pathLen := mload(fills)\n            let sigLen := mload(sig)\n\n            {\n                let ptr := add(0x132, data)\n\n                // sig length as 3 bytes goes at the end of the callback\n                mstore(sub(add(sigLen, add(pathLen, ptr)), 0x1d), sigLen)\n\n                // fills go at the end of the header\n                mcopy(ptr, add(0x20, fills), pathLen)\n                ptr := add(pathLen, ptr)\n\n                // signature comes after the fills\n                mcopy(ptr, add(0x20, sig), sigLen)\n                ptr := add(sigLen, ptr)\n\n                mstore(0x40, add(0x03, ptr))\n            }\n\n            mstore8(add(0x131, data), isForwarded)\n            mcopy(add(0xf1, data), add(0x20, permit), 0x40)\n            mcopy(add(0xb1, data), mload(permit), 0x40) // aliases `payer` on purpose\n            mstore(add(0x9d, data), 0x00) // payer\n            // feeOnTransfer (1 byte)\n\n            mstore(add(0x88, data), hashMod)\n            mstore(add(0x78, data), hashMul)\n            mstore(add(0x68, data), amountOutMin)\n            mstore(add(0x58, data), recipient)\n            mstore(add(0x44, data), add(0xd1, add(pathLen, sigLen)))\n            mstore(add(0x24, data), 0x20)\n            mstore(add(0x04, data), and(0xffffffff, unlockSelector))\n            mstore(data, add(0x115, add(pathLen, sigLen)))\n\n            mstore8(add(0xa8, data), feeOnTransfer)\n        }\n    }\n}\n\nlibrary Decoder {\n    using SafeTransferLib for IERC20;\n    using UnsafeMath for uint256;\n    using NotesLib for NotesLib.Note;\n    using NotesLib for NotesLib.Note[];\n\n    uint256 internal constant BASIS = 10_000;\n    IERC20 internal constant ETH_ADDRESS = IERC20(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\n\n    /// Update `state` for the next fill packed in `data`. This also may allocate/append `Note`s\n    /// into `notes`. Returns the suffix of the bytes that are not consumed in the decoding\n    /// process. The first byte of `data` describes which of the compact representations for the hop\n    /// is used.\n    ///\n    ///   0 -> sell and buy tokens remain unchanged from the previous fill (pure multiplex)\n    ///   1 -> sell token remains unchanged from the previous fill, buy token is read from `data` (diamond multiplex)\n    ///   2 -> sell token becomes the buy token from the previous fill, new buy token is read from `data` (multihop)\n    ///   3 -> both sell and buy token are read from `data`\n    ///\n    /// This function is responsible for calling `NotesLib.get(Note[] memory, IERC20, uint256,\n    /// uint256)` (via `StateLib.setSell` and `StateLib.setBuy`), which maintains the `notes` array\n    /// and heap.\n    function updateState(State state, NotesLib.Note[] memory notes, bytes calldata data)\n        internal\n        pure\n        returns (bytes calldata)\n    {\n        bytes32 dataWord;\n        assembly (\"memory-safe\") {\n            dataWord := calldataload(data.offset)\n        }\n        uint256 dataConsumed = 1;\n\n        uint256 caseKey = uint256(dataWord) >> 248;\n        if (caseKey != 0) {\n            notes.add(state.buy());\n\n            if (caseKey > 1) {\n                if (state.sell().amount() == 0) {\n                    notes.del(state.sell());\n                }\n                if (caseKey == 2) {\n                    state.setSell(state.buy());\n                } else {\n                    assert(caseKey == 3);\n\n                    IERC20 sellToken = IERC20(address(uint160(uint256(dataWord) >> 88)));\n                    assembly (\"memory-safe\") {\n                        dataWord := calldataload(add(0x14, data.offset))\n                    }\n                    unchecked {\n                        dataConsumed += 20;\n                    }\n\n                    state.setSell(notes, sellToken);\n                }\n            }\n\n            IERC20 buyToken = IERC20(address(uint160(uint256(dataWord) >> 88)));\n            unchecked {\n                dataConsumed += 20;\n            }\n\n            state.setBuy(notes, buyToken);\n            if (state.buy().eq(state.globalSell())) {\n                assembly (\"memory-safe\") {\n                    let ptr := mload(add(0x40, state)) // dereference `state.globalSell`\n                    mstore(ptr, 0x784cb7b8) // selector for `BoughtSellToken(address)`; clobbers `state.globalSell.amount`\n                    revert(add(0x1c, ptr), 0x24)\n                }\n            }\n        }\n\n        assembly (\"memory-safe\") {\n            data.offset := add(dataConsumed, data.offset)\n            data.length := sub(data.length, dataConsumed)\n            // we don't check for array out-of-bounds here; we will check it later in `_getHookData`\n        }\n\n        return data;\n    }\n\n    function overflowCheck(bytes calldata data) internal pure {\n        if (data.length > 16777215) {\n            Panic.panic(Panic.ARRAY_OUT_OF_BOUNDS);\n        }\n    }\n\n    /// Decode an ABI-ish encoded `bytes` from `data`. It is \"-ish\" in the sense that the encoding\n    /// of the length doesn't take up an entire word. The length is encoded as only 3 bytes (2^24\n    /// bytes of calldata consumes ~67M gas, much more than the block limit). The payload is also\n    /// unpadded. The next fill's `bps` is encoded immediately after the `hookData` payload.\n    function decodeBytes(bytes calldata data) internal pure returns (bytes calldata retData, bytes calldata hookData) {\n        assembly (\"memory-safe\") {\n            hookData.length := shr(0xe8, calldataload(data.offset))\n            hookData.offset := add(0x03, data.offset)\n            let hop := add(0x03, hookData.length)\n\n            retData.offset := add(data.offset, hop)\n            retData.length := sub(data.length, hop)\n        }\n    }\n\n    function decodeHeader(bytes calldata data)\n        internal\n        pure\n        returns (\n            bytes calldata newData,\n            // These values are user-supplied\n            address recipient,\n            uint256 minBuyAmount,\n            uint256 hashMul,\n            uint256 hashMod,\n            bool feeOnTransfer,\n            // `payer` is special and is authenticated\n            address payer\n        )\n    {\n        // These values are user-supplied\n        assembly (\"memory-safe\") {\n            recipient := shr(0x60, calldataload(data.offset))\n            let packed := calldataload(add(0x14, data.offset))\n            minBuyAmount := shr(0x80, packed)\n            hashMul := and(0xffffffffffffffffffffffffffffffff, packed)\n            packed := calldataload(add(0x34, data.offset))\n            hashMod := shr(0x80, packed)\n            feeOnTransfer := iszero(iszero(and(0x1000000000000000000000000000000, packed)))\n\n            data.offset := add(0x45, data.offset)\n            data.length := sub(data.length, 0x45)\n            // we don't check for array out-of-bounds here; we will check it later in `initialize`\n        }\n\n        // `payer` is special and is authenticated\n        assembly (\"memory-safe\") {\n            payer := shr(0x60, calldataload(data.offset))\n\n            data.offset := add(0x14, data.offset)\n            data.length := sub(data.length, 0x14)\n            // we don't check for array out-of-bounds here; we will check it later in `initialize`\n        }\n\n        newData = data;\n    }\n\n    function initialize(bytes calldata data, uint256 hashMul, uint256 hashMod, address payer)\n        internal\n        view\n        returns (\n            bytes calldata newData,\n            State state,\n            NotesLib.Note[] memory notes,\n            ISignatureTransfer.PermitTransferFrom calldata permit,\n            bool isForwarded,\n            bytes calldata sig\n        )\n    {\n        {\n            IERC20 sellToken;\n            assembly (\"memory-safe\") {\n                sellToken := shr(0x60, calldataload(data.offset))\n            }\n            // We don't advance `data` here because there's a special interaction between `payer`\n            // (which is the 20 bytes in calldata immediately before `data`), `sellToken`, and\n            // `permit` that's handled below.\n            (state, notes) = StateLib.construct(sellToken, hashMul, hashMod);\n        }\n\n        // This assembly block is just here to appease the compiler. We only use `permit` and `sig`\n        // in the codepaths where they are set away from the values initialized here.\n        assembly (\"memory-safe\") {\n            permit := calldatasize()\n            sig.offset := calldatasize()\n            sig.length := 0x00\n        }\n\n        if (state.globalSell().token() == ETH_ADDRESS) {\n            assert(payer == address(this));\n\n            uint16 bps;\n            assembly (\"memory-safe\") {\n                // `data` hasn't been advanced from decoding `sellToken` above. so we have to\n                // implicitly advance it by 20 bytes to decode `bps` then advance by 22 bytes\n\n                bps := shr(0x50, calldataload(data.offset))\n\n                data.offset := add(0x16, data.offset)\n                data.length := sub(data.length, 0x16)\n                // We check for array out-of-bounds below\n            }\n\n            unchecked {\n                state.globalSell().setAmount((address(this).balance * bps).unsafeDiv(BASIS));\n            }\n        } else {\n            if (payer == address(this)) {\n                uint16 bps;\n                assembly (\"memory-safe\") {\n                    // `data` hasn't been advanced from decoding `sellToken` above. so we have to\n                    // implicitly advance it by 20 bytes to decode `bps` then advance by 22 bytes\n\n                    bps := shr(0x50, calldataload(data.offset))\n\n                    data.offset := add(0x16, data.offset)\n                    data.length := sub(data.length, 0x16)\n                    // We check for array out-of-bounds below\n                }\n\n                unchecked {\n                    NotePtr globalSell = state.globalSell();\n                    globalSell.setAmount(\n                        (globalSell.token().fastBalanceOf(address(this)) * bps).unsafeDiv(BASIS)\n                    );\n                }\n            } else {\n                assert(payer == address(0));\n\n                assembly (\"memory-safe\") {\n                    // this is super dirty, but it works because although `permit` is aliasing in\n                    // the middle of `payer`, because `payer` is all zeroes, it's treated as padding\n                    // for the first word of `permit`, which is the sell token\n                    permit := sub(data.offset, 0x0c)\n                    isForwarded := and(0x01, calldataload(add(0x55, data.offset)))\n\n                    // `sig` is packed at the end of `data`, in \"reverse ABI-ish encoded\" fashion\n                    sig.offset := sub(add(data.offset, data.length), 0x03)\n                    sig.length := shr(0xe8, calldataload(sig.offset))\n                    sig.offset := sub(sig.offset, sig.length)\n\n                    // Remove `permit` and `isForwarded` from the front of `data`\n                    data.offset := add(0x75, data.offset)\n                    if gt(data.offset, sig.offset) { revert(0x00, 0x00) }\n\n                    // Remove `sig` from the back of `data`\n                    data.length := sub(sub(data.length, 0x78), sig.length)\n                    // We check for array out-of-bounds below\n                }\n            }\n        }\n\n        Decoder.overflowCheck(data);\n        newData = data;\n    }\n}\n\nlibrary Take {\n    using UnsafeMath for uint256;\n    using NotesLib for NotesLib.Note;\n    using NotesLib for NotesLib.Note[];\n\n    function _callSelector(uint256 selector, IERC20 token, address to, uint256 amount) internal {\n        assembly (\"memory-safe\") {\n            token := shl(0x60, token)\n            if iszero(amount) {\n                mstore(0x20, token)\n                mstore(0x00, 0xcbf0dbf5000000000000000000000000) // selector for `ZeroBuyAmount(address)` with `token`'s padding\n                revert(0x10, 0x24)\n            }\n\n            // save the free memory pointer because we're about to clobber it\n            let ptr := mload(0x40)\n\n            mstore(0x60, amount)\n            mstore(0x40, to)\n            mstore(0x2c, mul(iszero(eq(0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee000000000000000000000000, token)), token)) // clears `to`'s padding\n            mstore(0x0c, shl(0x60, selector)) // clears `token`'s padding\n\n            if iszero(call(gas(), caller(), 0x00, 0x1c, 0x64, 0x00, 0x00)) {\n                returndatacopy(ptr, 0x00, returndatasize())\n                revert(ptr, returndatasize())\n            }\n\n            // restore clobbered slots\n            mstore(0x60, 0x00)\n            mstore(0x40, ptr)\n        }\n    }\n\n    /// `take` is responsible for removing the accumulated credit in each token from the vault. The\n    /// current `state.buy` is the global buy token. We return the settled amount of that token\n    /// (`buyAmount`), after checking it against the slippage limit (`minBuyAmount`). Each token\n    /// with credit causes a corresponding call to `msg.sender.<selector>(token, recipient,\n    /// amount)`.\n    function take(\n        State state,\n        NotesLib.Note[] memory notes,\n        uint32 selector,\n        address recipient,\n        uint256 minBuyAmount\n    ) internal returns (uint256 buyAmount) {\n        notes.del(state.buy());\n        if (state.sell().amount() == 0) {\n            notes.del(state.sell());\n        }\n\n        uint256 length = notes.length;\n        // `length` of zero implies that we fully liquidated the global sell token (there is no\n        // `amount` remaining) and that the only token in which we have credit is the global buy\n        // token. We're about to `take` that token below.\n        if (length != 0) {\n            {\n                NotesLib.Note memory firstNote = notes[0]; // out-of-bounds is impossible\n                if (!firstNote.eq(state.globalSell())) {\n                    // The global sell token being in a position other than the 1st would imply that\n                    // at some point we _bought_ that token. This is illegal and results in a revert\n                    // with reason `BoughtSellToken(address)`.\n                    _callSelector(selector, firstNote.token, address(this), firstNote.amount);\n                }\n            }\n            for (uint256 i = 1; i < length; i = i.unsafeInc()) {\n                (IERC20 token, uint256 amount) = notes.unsafeGet(i);\n                _callSelector(selector, token, address(this), amount);\n            }\n        }\n\n        // The final token to be bought is considered the global buy token. We bypass `notes` and\n        // read it directly from `state`. Check the slippage limit. Transfer to the recipient.\n        {\n            IERC20 buyToken = state.buy().token();\n            buyAmount = state.buy().amount();\n            if (buyAmount < minBuyAmount) {\n                revertTooMuchSlippage(buyToken, minBuyAmount, buyAmount);\n            }\n            _callSelector(selector, buyToken, recipient, buyAmount);\n        }\n    }\n}\n\n// src/SettlerAbstract.sol\n\nabstract contract SettlerAbstract is Permit2PaymentAbstract {\n    // Permit2 Witness for meta transactions\n    string internal constant SLIPPAGE_AND_ACTIONS_TYPE =\n        \"SlippageAndActions(address recipient,address buyToken,uint256 minAmountOut,bytes[] actions)\";\n    bytes32 internal constant SLIPPAGE_AND_ACTIONS_TYPEHASH =\n        0x615e8d716cef7295e75dd3f1f10d679914ad6d7759e8e9459f0109ef75241701;\n    // Permit2 Witness for intents\n    string internal constant SLIPPAGE_TYPE = \"Slippage(address recipient,address buyToken,uint256 minAmountOut)\";\n    bytes32 internal constant SLIPPAGE_TYPEHASH = 0xdc83993a2ffc65b01b71ed08790b6e39c5c55d76937b62a3b5085b02071f1259;\n\n    uint256 internal constant BASIS = 10_000;\n    IERC20 internal constant ETH_ADDRESS = IERC20(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\n\n    constructor() {\n        assert(SLIPPAGE_AND_ACTIONS_TYPEHASH == keccak256(bytes(SLIPPAGE_AND_ACTIONS_TYPE)));\n        assert(SLIPPAGE_TYPEHASH == keccak256(bytes(SLIPPAGE_TYPE)));\n    }\n\n    function _hasMetaTxn() internal pure virtual returns (bool);\n\n    function _tokenId() internal pure virtual returns (uint256);\n\n    function _dispatch(uint256 i, uint256 action, bytes calldata data) internal virtual returns (bool);\n\n    function _div512to256(uint512 n, uint512 d) internal view virtual returns (uint256);\n}\n\n// src/core/UniswapV4Types.sol\n\ntype IHooks is address;\n\n/// @dev Two `int128` values packed into a single `int256` where the upper 128 bits represent the amount0\n/// and the lower 128 bits represent the amount1.\ntype BalanceDelta is int256;\n\nusing BalanceDeltaLibrary for BalanceDelta global;\n\n/// @notice Library for getting the amount0 and amount1 deltas from the BalanceDelta type\nlibrary BalanceDeltaLibrary {\n    function amount0(BalanceDelta balanceDelta) internal pure returns (int128 _amount0) {\n        assembly (\"memory-safe\") {\n            _amount0 := sar(128, balanceDelta)\n        }\n    }\n\n    function amount1(BalanceDelta balanceDelta) internal pure returns (int128 _amount1) {\n        assembly (\"memory-safe\") {\n            _amount1 := signextend(15, balanceDelta)\n        }\n    }\n}\n\ninterface IPoolManager {\n    /// @notice All interactions on the contract that account deltas require unlocking. A caller that calls `unlock` must implement\n    /// `IUnlockCallback(msg.sender).unlockCallback(data)`, where they interact with the remaining functions on this contract.\n    /// @dev The only functions callable without an unlocking are `initialize` and `updateDynamicLPFee`\n    /// @param data Any data to pass to the callback, via `IUnlockCallback(msg.sender).unlockCallback(data)`\n    /// @return The data returned by the call to `IUnlockCallback(msg.sender).unlockCallback(data)`\n    function unlock(bytes calldata data) external returns (bytes memory);\n\n    /// @notice Returns the key for identifying a pool\n    struct PoolKey {\n        /// @notice The lower token of the pool, sorted numerically\n        IERC20 token0;\n        /// @notice The higher token of the pool, sorted numerically\n        IERC20 token1;\n        /// @notice The pool LP fee, capped at 1_000_000. If the highest bit is 1, the pool has a dynamic fee and must be exactly equal to 0x800000\n        uint24 fee;\n        /// @notice Ticks that involve positions must be a multiple of tick spacing\n        int24 tickSpacing;\n        /// @notice The hooks of the pool\n        IHooks hooks;\n    }\n\n    struct SwapParams {\n        /// Whether to swap token0 for token1 or vice versa\n        bool zeroForOne;\n        /// The desired input amount if negative (exactIn), or the desired output amount if positive (exactOut)\n        int256 amountSpecified;\n        /// The sqrt price at which, if reached, the swap will stop executing\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swap against the given pool\n    /// @param key The pool to swap in\n    /// @param params The parameters for swapping\n    /// @param hookData The data to pass through to the swap hooks\n    /// @return swapDelta The balance delta of the address swapping\n    /// @dev Swapping on low liquidity pools may cause unexpected swap amounts when liquidity available is less than amountSpecified.\n    /// Additionally note that if interacting with hooks that have the BEFORE_SWAP_RETURNS_DELTA_FLAG or AFTER_SWAP_RETURNS_DELTA_FLAG\n    /// the hook may alter the swap input/output. Integrators should perform checks on the returned swapDelta.\n    function swap(PoolKey memory key, SwapParams memory params, bytes calldata hookData)\n        external\n        returns (BalanceDelta swapDelta);\n\n    /// @notice Writes the current ERC20 balance of the specified token to transient storage\n    /// This is used to checkpoint balances for the manager and derive deltas for the caller.\n    /// @dev This MUST be called before any ERC20 tokens are sent into the contract, but can be skipped\n    /// for native tokens because the amount to settle is determined by the sent value.\n    /// However, if an ERC20 token has been synced and not settled, and the caller instead wants to settle\n    /// native funds, this function can be called with the native currency to then be able to settle the native currency\n    function sync(IERC20 token) external;\n\n    /// @notice Called by the user to net out some value owed to the user\n    /// @dev Can also be used as a mechanism for _free_ flash loans\n    /// @param token The token to withdraw from the pool manager\n    /// @param to The address to withdraw to\n    /// @param amount The amount of token to withdraw\n    function take(IERC20 token, address to, uint256 amount) external;\n\n    /// @notice Called by the user to pay what is owed\n    /// @return paid The amount of token settled\n    function settle() external payable returns (uint256 paid);\n}\n\n/// Solc emits code that is both gas inefficient and codesize bloated. By reimplementing these\n/// function calls in Yul, we obtain significant improvements. Solc also emits an EXTCODESIZE check\n/// when an external function doesn't return anything (`sync`). Obviously, we know that POOL_MANAGER\n/// has code, so this omits those checks. Also, for compatibility, these functions identify\n/// `SettlerAbstract.ETH_ADDRESS` (the address of all `e`s) and replace it with `address(0)`.\nlibrary UnsafePoolManager {\n    function unsafeSync(IPoolManager poolManager, IERC20 token) internal {\n        // It is the responsibility of the calling code to determine whether `token` is\n        // `ETH_ADDRESS` and substitute it with `IERC20(address(0))` appropriately. This delegation\n        // of responsibility is required because a call to `unsafeSync(0)` must be followed by a\n        // value-bearing call to `unsafeSettle` instead of using `IERC20.safeTransfer`\n        assembly (\"memory-safe\") {\n            mstore(0x14, token)\n            mstore(0x00, 0xa5841194000000000000000000000000) // selector for `sync(address)`\n            if iszero(call(gas(), poolManager, 0x00, 0x10, 0x24, 0x00, 0x00)) {\n                let ptr := mload(0x40)\n                returndatacopy(ptr, 0x00, returndatasize())\n                revert(ptr, returndatasize())\n            }\n        }\n    }\n\n    function unsafeSwap(\n        IPoolManager poolManager,\n        IPoolManager.PoolKey memory key,\n        IPoolManager.SwapParams memory params,\n        bytes calldata hookData\n    ) internal returns (BalanceDelta r) {\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40)\n            mstore(ptr, 0xf3cd914c) // selector for `swap((address,address,uint24,int24,address),(bool,int256,uint160),bytes)`\n            let token0 := mload(key)\n            token0 := mul(token0, iszero(eq(0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee, token0)))\n            mstore(add(0x20, ptr), token0)\n            mcopy(add(0x40, ptr), add(0x20, key), 0x80)\n            mcopy(add(0xc0, ptr), params, 0x60)\n            mstore(add(0x120, ptr), 0x120)\n            mstore(add(0x140, ptr), hookData.length)\n            calldatacopy(add(0x160, ptr), hookData.offset, hookData.length)\n            if iszero(call(gas(), poolManager, 0x00, add(0x1c, ptr), add(0x144, hookData.length), 0x00, 0x20)) {\n                returndatacopy(ptr, 0x00, returndatasize())\n                revert(ptr, returndatasize())\n            }\n            r := mload(0x00)\n        }\n    }\n\n    function unsafeSettle(IPoolManager poolManager, uint256 value) internal returns (uint256 r) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, 0x11da60b4) // selector for `settle()`\n            if iszero(call(gas(), poolManager, value, 0x1c, 0x04, 0x00, 0x20)) {\n                let ptr := mload(0x40)\n                returndatacopy(ptr, 0x00, returndatasize())\n                revert(ptr, returndatasize())\n            }\n            r := mload(0x00)\n        }\n    }\n\n    function unsafeSettle(IPoolManager poolManager) internal returns (uint256) {\n        return unsafeSettle(poolManager, 0);\n    }\n}\n\n/// @notice Interface for the callback executed when an address unlocks the pool manager\ninterface IUnlockCallback {\n    /// @notice Called by the pool manager on `msg.sender` when the manager is unlocked\n    /// @param data The data that was passed to the call to unlock\n    /// @return Any data that you want to be returned from the unlock call\n    function unlockCallback(bytes calldata data) external returns (bytes memory);\n}\n\n// src/core/UniswapV4Addresses.sol\n\nIPoolManager constant MAINNET_POOL_MANAGER = IPoolManager(0x000000000004444c5dc75cB358380D2e3dE08A90);\nIPoolManager constant ARBITRUM_POOL_MANAGER = IPoolManager(0x360E68faCcca8cA495c1B759Fd9EEe466db9FB32);\nIPoolManager constant AVALANCHE_POOL_MANAGER = IPoolManager(0x06380C0e0912312B5150364B9DC4542BA0DbBc85);\nIPoolManager constant BASE_POOL_MANAGER = IPoolManager(0x498581fF718922c3f8e6A244956aF099B2652b2b);\nIPoolManager constant BLAST_POOL_MANAGER = IPoolManager(0x1631559198A9e474033433b2958daBC135ab6446);\nIPoolManager constant BNB_POOL_MANAGER = IPoolManager(0x28e2Ea090877bF75740558f6BFB36A5ffeE9e9dF);\nIPoolManager constant OPTIMISM_POOL_MANAGER = IPoolManager(0x9a13F98Cb987694C9F086b1F5eB990EeA8264Ec3);\nIPoolManager constant POLYGON_POOL_MANAGER = IPoolManager(0x67366782805870060151383F4BbFF9daB53e5cD6);\nIPoolManager constant WORLDCHAIN_POOL_MANAGER = IPoolManager(0xb1860D529182ac3BC1F51Fa2ABd56662b7D13f33);\nIPoolManager constant INK_POOL_MANAGER = IPoolManager(0x360E68faCcca8cA495c1B759Fd9EEe466db9FB32);\nIPoolManager constant UNICHAIN_POOL_MANAGER = IPoolManager(0x1F98400000000000000000000000000000000004); // https://github.com/Uniswap/contracts/blob/main/deployments/130.md#wed-jan-22-2025\nIPoolManager constant SEPOLIA_POOL_MANAGER = IPoolManager(0xE03A1074c86CFeDd5C142C4F04F1a1536e203543);\n\n// src/core/DodoV1.sol\n\ninterface IDodoV1 {\n    function sellBaseToken(uint256 amount, uint256 minReceiveQuote, bytes calldata data) external returns (uint256);\n\n    function buyBaseToken(uint256 amount, uint256 maxPayQuote, bytes calldata data) external returns (uint256);\n\n    function _R_STATUS_() external view returns (uint8);\n\n    function _QUOTE_BALANCE_() external view returns (uint256);\n\n    function _BASE_BALANCE_() external view returns (uint256);\n\n    function _K_() external view returns (uint256);\n\n    function _MT_FEE_RATE_() external view returns (uint256);\n\n    function _LP_FEE_RATE_() external view returns (uint256);\n\n    function getExpectedTarget() external view returns (uint256 baseTarget, uint256 quoteTarget);\n\n    function getOraclePrice() external view returns (uint256);\n\n    function _BASE_TOKEN_() external view returns (IERC20);\n\n    function _QUOTE_TOKEN_() external view returns (IERC20);\n}\n\nlibrary FastDodoV1 {\n    function _callAddressUintEmptyBytesReturnUint(IDodoV1 dodo, uint256 sig, uint256 a, uint256 b)\n        private\n        returns (uint256 r)\n    {\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40)\n            mstore(ptr, sig)\n            mstore(add(0x20, ptr), a)\n            mstore(add(0x40, ptr), b)\n            mstore(add(0x60, ptr), 0x60)\n            mstore(add(0x80, ptr), 0x00)\n\n            if iszero(call(gas(), dodo, 0x00, add(0x1c, ptr), 0x84, 0x00, 0x20)) {\n                returndatacopy(ptr, 0x00, returndatasize())\n                revert(ptr, returndatasize())\n            }\n            if iszero(gt(returndatasize(), 0x1f)) { revert(0x00, 0x00) }\n\n            r := mload(0x00)\n        }\n    }\n\n    function fastSellBaseToken(IDodoV1 dodo, uint256 amount, uint256 minReceiveQuote) internal returns (uint256) {\n        return _callAddressUintEmptyBytesReturnUint(dodo, uint32(dodo.sellBaseToken.selector), amount, minReceiveQuote);\n    }\n\n    function fastBuyBaseToken(IDodoV1 dodo, uint256 amount, uint256 maxPayQuote) internal returns (uint256) {\n        return _callAddressUintEmptyBytesReturnUint(dodo, uint32(dodo.buyBaseToken.selector), amount, maxPayQuote);\n    }\n\n    function _get(IDodoV1 dodo, uint256 sig) private view returns (bytes32 r) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, sig)\n            if iszero(staticcall(gas(), dodo, 0x1c, 0x04, 0x00, 0x20)) {\n                let ptr := mload(0x40)\n                returndatacopy(ptr, 0x00, returndatasize())\n                revert(ptr, returndatasize())\n            }\n            if iszero(gt(returndatasize(), 0x1f)) { revert(0x00, 0x00) }\n\n            r := mload(0x00)\n        }\n    }\n\n    function fast_R_STATUS_(IDodoV1 dodo) internal view returns (uint8) {\n        uint256 result = uint256(_get(dodo, uint32(dodo._R_STATUS_.selector)));\n        require(result >> 8 == 0);\n        return uint8(result);\n    }\n\n    function fast_QUOTE_BALANCE_(IDodoV1 dodo) internal view returns (uint256) {\n        return uint256(_get(dodo, uint32(dodo._QUOTE_BALANCE_.selector)));\n    }\n\n    function fast_BASE_BALANCE_(IDodoV1 dodo) internal view returns (uint256) {\n        return uint256(_get(dodo, uint32(dodo._BASE_BALANCE_.selector)));\n    }\n\n    function fast_K_(IDodoV1 dodo) internal view returns (uint256) {\n        return uint256(_get(dodo, uint32(dodo._K_.selector)));\n    }\n\n    function fast_MT_FEE_RATE_(IDodoV1 dodo) internal view returns (uint256) {\n        return uint256(_get(dodo, uint32(dodo._MT_FEE_RATE_.selector)));\n    }\n\n    function fast_LP_FEE_RATE_(IDodoV1 dodo) internal view returns (uint256) {\n        return uint256(_get(dodo, uint32(dodo._LP_FEE_RATE_.selector)));\n    }\n\n    function fastGetExpectedTarget(IDodoV1 dodo) internal view returns (uint256 baseTarget, uint256 quoteTarget) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, 0xffa64225)\n            if iszero(staticcall(gas(), dodo, 0x1c, 0x04, 0x00, 0x40)) {\n                let ptr := mload(0x40)\n                returndatacopy(ptr, 0x00, returndatasize())\n                revert(ptr, returndatasize())\n            }\n            if iszero(gt(returndatasize(), 0x3f)) { revert(0x00, 0x00) }\n\n            baseTarget := mload(0x00)\n            quoteTarget := mload(0x20)\n        }\n    }\n\n    function fastGetOraclePrice(IDodoV1 dodo) internal view returns (uint256) {\n        return uint256(_get(dodo, uint32(dodo.getOraclePrice.selector)));\n    }\n\n    function fast_BASE_TOKEN_(IDodoV1 dodo) internal view returns (IERC20) {\n        uint256 result = uint256(_get(dodo, uint32(dodo._BASE_TOKEN_.selector)));\n        require(result >> 160 == 0);\n        return IERC20(address(uint160(result)));\n    }\n\n    function fast_QUOTE_TOKEN_(IDodoV1 dodo) internal view returns (IERC20) {\n        uint256 result = uint256(_get(dodo, uint32(dodo._QUOTE_TOKEN_.selector)));\n        require(result >> 160 == 0);\n        return IERC20(address(uint160(result)));\n    }\n}\n\nlibrary Math_1 {\n    using UnsafeMath for uint256;\n\n    function sqrt(uint256 x) internal pure returns (uint256 y) {\n        unchecked {\n            uint256 z = x / 2 + 1;\n            y = x;\n            while (z < y) {\n                y = z;\n                z = (x.unsafeDiv(z) + z) / 2;\n            }\n        }\n    }\n}\n\nlibrary DecimalMath {\n    using UnsafeMath for uint256;\n    using Math_1 for uint256;\n\n    uint256 constant ONE = 10 ** 18;\n\n    function mul(uint256 target, uint256 d) internal pure returns (uint256) {\n        unchecked {\n            return target * d / ONE;\n        }\n    }\n\n    function mulCeil(uint256 target, uint256 d) internal pure returns (uint256) {\n        unchecked {\n            return (target * d).unsafeDivUp(ONE);\n        }\n    }\n\n    function divFloor(uint256 target, uint256 d) internal pure returns (uint256) {\n        unchecked {\n            return (target * ONE).unsafeDiv(d);\n        }\n    }\n\n    function divCeil(uint256 target, uint256 d) internal pure returns (uint256) {\n        unchecked {\n            return (target * ONE).unsafeDivUp(d);\n        }\n    }\n}\n\nlibrary DodoMath {\n    using UnsafeMath for uint256;\n    using Math_1 for uint256;\n\n    /*\n        Integrate dodo curve fron V1 to V2\n        require V0>=V1>=V2>0\n        res = (1-k)i(V1-V2)+ikV0*V0(1/V2-1/V1)\n        let V1-V2=delta\n        res = i*delta*(1-k+k(V0^2/V1/V2))\n    */\n    function _GeneralIntegrate(uint256 V0, uint256 V1, uint256 V2, uint256 i, uint256 k)\n        internal\n        pure\n        returns (uint256)\n    {\n        unchecked {\n            uint256 fairAmount = DecimalMath.mul(i, V1 - V2); // i*delta\n            uint256 V0V0V1V2 = DecimalMath.divCeil((V0 * V0).unsafeDiv(V1), V2);\n            uint256 penalty = DecimalMath.mul(k, V0V0V1V2); // k(V0^2/V1/V2)\n            return DecimalMath.mul(fairAmount, DecimalMath.ONE - k + penalty);\n        }\n    }\n\n    /*\n        The same with integration expression above, we have:\n        i*deltaB = (Q2-Q1)*(1-k+kQ0^2/Q1/Q2)\n        Given Q1 and deltaB, solve Q2\n        This is a quadratic function and the standard version is\n        aQ2^2 + bQ2 + c = 0, where\n        a=1-k\n        -b=(1-k)Q1-kQ0^2/Q1+i*deltaB\n        c=-kQ0^2\n        and Q2=(-b+sqrt(b^2+4(1-k)kQ0^2))/2(1-k)\n        note: another root is negative, abondan\n        if deltaBSig=true, then Q2>Q1\n        if deltaBSig=false, then Q2<Q1\n    */\n    function _SolveQuadraticFunctionForTrade(uint256 Q0, uint256 Q1, uint256 ideltaB, bool deltaBSig, uint256 k)\n        internal\n        pure\n        returns (uint256)\n    {\n        unchecked {\n            // calculate -b value and sig\n            // -b = (1-k)Q1-kQ0^2/Q1+i*deltaB\n            uint256 kQ02Q1 = (DecimalMath.mul(k, Q0) * Q0).unsafeDiv(Q1); // kQ0^2/Q1\n            uint256 b = DecimalMath.mul(DecimalMath.ONE - k, Q1); // (1-k)Q1\n            bool minusbSig = true;\n            if (deltaBSig) {\n                b += ideltaB; // (1-k)Q1+i*deltaB\n            } else {\n                kQ02Q1 += ideltaB; // i*deltaB+kQ0^2/Q1\n            }\n            if (b >= kQ02Q1) {\n                b -= kQ02Q1;\n                minusbSig = true;\n            } else {\n                b = kQ02Q1 - b;\n                minusbSig = false;\n            }\n\n            // calculate sqrt\n            uint256 squareRoot = DecimalMath.mul((DecimalMath.ONE - k) * 4, DecimalMath.mul(k, Q0) * Q0); // 4(1-k)kQ0^2\n            squareRoot = (b * b + squareRoot).sqrt(); // sqrt(b*b+4(1-k)kQ0*Q0)\n\n            // final res\n            uint256 denominator = (DecimalMath.ONE - k) * 2; // 2(1-k)\n            uint256 numerator;\n            if (minusbSig) {\n                numerator = b + squareRoot;\n            } else {\n                numerator = squareRoot - b;\n            }\n\n            if (deltaBSig) {\n                return DecimalMath.divFloor(numerator, denominator);\n            } else {\n                return DecimalMath.divCeil(numerator, denominator);\n            }\n        }\n    }\n\n    /*\n        Start from the integration function\n        i*deltaB = (Q2-Q1)*(1-k+kQ0^2/Q1/Q2)\n        Assume Q2=Q0, Given Q1 and deltaB, solve Q0\n        let fairAmount = i*deltaB\n    */\n    function _SolveQuadraticFunctionForTarget(uint256 V1, uint256 k, uint256 fairAmount)\n        internal\n        pure\n        returns (uint256 V0)\n    {\n        unchecked {\n            // V0 = V1+V1*(sqrt-1)/2k\n            uint256 sqrt = DecimalMath.divCeil(DecimalMath.mul(k, fairAmount) * 4, V1);\n            sqrt = ((sqrt + DecimalMath.ONE) * DecimalMath.ONE).sqrt();\n            uint256 premium = DecimalMath.divCeil(sqrt - DecimalMath.ONE, k * 2);\n            // V0 is greater than or equal to V1 according to the solution\n            return DecimalMath.mul(V1, DecimalMath.ONE + premium);\n        }\n    }\n}\n\nabstract contract DodoSellHelper {\n    using Math_1 for uint256;\n    using FastDodoV1 for IDodoV1;\n\n    enum RStatus {\n        ONE,\n        ABOVE_ONE,\n        BELOW_ONE\n    }\n\n    struct DodoState {\n        uint256 oraclePrice;\n        uint256 K;\n        uint256 B;\n        uint256 Q;\n        uint256 baseTarget;\n        uint256 quoteTarget;\n        RStatus rStatus;\n    }\n\n    function dodoQuerySellQuoteToken(IDodoV1 dodo, uint256 amount) internal view returns (uint256) {\n        DodoState memory state;\n        (state.baseTarget, state.quoteTarget) = dodo.fastGetExpectedTarget();\n        state.rStatus = RStatus(dodo.fast_R_STATUS_());\n        state.oraclePrice = dodo.fastGetOraclePrice();\n        state.Q = dodo.fast_QUOTE_BALANCE_();\n        state.B = dodo.fast_BASE_BALANCE_();\n        state.K = dodo.fast_K_();\n\n        unchecked {\n            uint256 boughtAmount;\n            // Determine the status (RStatus) and calculate the amount based on the\n            // state\n            if (state.rStatus == RStatus.ONE) {\n                boughtAmount = _ROneSellQuoteToken(amount, state);\n            } else if (state.rStatus == RStatus.ABOVE_ONE) {\n                boughtAmount = _RAboveSellQuoteToken(amount, state);\n            } else {\n                uint256 backOneBase = state.B - state.baseTarget;\n                uint256 backOneQuote = state.quoteTarget - state.Q;\n                if (amount <= backOneQuote) {\n                    boughtAmount = _RBelowSellQuoteToken(amount, state);\n                } else {\n                    boughtAmount = backOneBase + _ROneSellQuoteToken(amount - backOneQuote, state);\n                }\n            }\n            // Calculate fees\n            return DecimalMath.divFloor(\n                boughtAmount, DecimalMath.ONE + dodo.fast_MT_FEE_RATE_() + dodo.fast_LP_FEE_RATE_()\n            );\n        }\n    }\n\n    function _ROneSellQuoteToken(uint256 amount, DodoState memory state)\n        private\n        pure\n        returns (uint256 receiveBaseToken)\n    {\n        unchecked {\n            uint256 i = DecimalMath.divFloor(DecimalMath.ONE, state.oraclePrice);\n            uint256 B2 = DodoMath._SolveQuadraticFunctionForTrade(\n                state.baseTarget, state.baseTarget, DecimalMath.mul(i, amount), false, state.K\n            );\n            return state.baseTarget - B2;\n        }\n    }\n\n    function _RAboveSellQuoteToken(uint256 amount, DodoState memory state)\n        private\n        pure\n        returns (uint256 receieBaseToken)\n    {\n        unchecked {\n            uint256 i = DecimalMath.divFloor(DecimalMath.ONE, state.oraclePrice);\n            uint256 B2 = DodoMath._SolveQuadraticFunctionForTrade(\n                state.baseTarget, state.B, DecimalMath.mul(i, amount), false, state.K\n            );\n            return state.B - B2;\n        }\n    }\n\n    function _RBelowSellQuoteToken(uint256 amount, DodoState memory state)\n        private\n        pure\n        returns (uint256 receiveBaseToken)\n    {\n        unchecked {\n            uint256 Q1 = state.Q + amount;\n            uint256 i = DecimalMath.divFloor(DecimalMath.ONE, state.oraclePrice);\n            return DodoMath._GeneralIntegrate(state.quoteTarget, Q1, state.Q, i, state.K);\n        }\n    }\n}\n\nabstract contract DodoV1 is SettlerAbstract, DodoSellHelper {\n    using UnsafeMath for uint256;\n    using SafeTransferLib for IERC20;\n    using FastDodoV1 for IDodoV1;\n\n    function sellToDodoV1(IERC20 sellToken, uint256 bps, IDodoV1 dodo, bool quoteForBase, uint256 minBuyAmount)\n        internal\n    {\n        uint256 sellAmount;\n        unchecked {\n            sellAmount = (sellToken.fastBalanceOf(address(this)) * bps).unsafeDiv(BASIS);\n        }\n        sellToken.safeApproveIfBelow(address(dodo), sellAmount);\n        if (quoteForBase) {\n            uint256 buyAmount = dodoQuerySellQuoteToken(dodo, sellAmount);\n            if (buyAmount < minBuyAmount) {\n                revertTooMuchSlippage(dodo.fast_BASE_TOKEN_(), minBuyAmount, buyAmount);\n            }\n            dodo.fastBuyBaseToken(buyAmount, sellAmount);\n        } else {\n            dodo.fastSellBaseToken(sellAmount, minBuyAmount);\n        }\n    }\n}\n\n// src/core/DodoV2.sol\n\ninterface IDodoV2 {\n    function sellBase(address to) external returns (uint256 receiveQuoteAmount);\n    function sellQuote(address to) external returns (uint256 receiveBaseAmount);\n\n    function _BASE_TOKEN_() external view returns (IERC20);\n    function _QUOTE_TOKEN_() external view returns (IERC20);\n}\n\nlibrary FastDodoV2 {\n    function _callAddressReturnUint(IDodoV2 dodo, uint256 sig, address addr) private returns (uint256 r) {\n        assembly (\"memory-safe\") {\n            mstore(0x14, addr)\n            mstore(0x00, shl(0x60, sig))\n            if iszero(call(gas(), dodo, 0x00, 0x10, 0x24, 0x00, 0x20)) {\n                let ptr := mload(0x40)\n                returndatacopy(ptr, 0x00, returndatasize())\n                revert(ptr, returndatasize())\n            }\n            if iszero(gt(returndatasize(), 0x1f)) { revert(0x00, 0x00) }\n\n            r := mload(0x00)\n        }\n    }\n\n    function fastSellBase(IDodoV2 dodo, address to) internal returns (uint256 receiveQuoteAmount) {\n        return _callAddressReturnUint(dodo, uint32(dodo.sellBase.selector), to);\n    }\n\n    function fastSellQuote(IDodoV2 dodo, address to) internal returns (uint256 receiveBaseAmount) {\n        return _callAddressReturnUint(dodo, uint32(dodo.sellQuote.selector), to);\n    }\n\n    function _get(IDodoV2 dodo, uint256 sig) private view returns (bytes32 r) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, sig)\n            if iszero(staticcall(gas(), dodo, 0x1c, 0x04, 0x00, 0x20)) {\n                let ptr := mload(0x40)\n                returndatacopy(ptr, 0x00, returndatasize())\n                revert(ptr, returndatasize())\n            }\n            if iszero(gt(returndatasize(), 0x1f)) { revert(0x00, 0x00) }\n\n            r := mload(0x00)\n        }\n    }\n\n    function fast_BASE_TOKEN_(IDodoV2 dodo) internal view returns (IERC20) {\n        uint256 result = uint256(_get(dodo, uint32(dodo._BASE_TOKEN_.selector)));\n        require(result >> 160 == 0);\n        return IERC20(address(uint160(result)));\n    }\n\n    function fast_QUOTE_TOKEN_(IDodoV2 dodo) internal view returns (IERC20) {\n        uint256 result = uint256(_get(dodo, uint32(dodo._QUOTE_TOKEN_.selector)));\n        require(result >> 160 == 0);\n        return IERC20(address(uint160(result)));\n    }\n}\n\nabstract contract DodoV2 is SettlerAbstract {\n    using UnsafeMath for uint256;\n    using SafeTransferLib for IERC20;\n    using FastDodoV2 for IDodoV2;\n\n    function sellToDodoV2(\n        address recipient,\n        IERC20 sellToken,\n        uint256 bps,\n        IDodoV2 dodo,\n        bool quoteForBase,\n        uint256 minBuyAmount\n    ) internal returns (uint256 buyAmount) {\n        if (bps != 0) {\n            uint256 sellAmount;\n            unchecked {\n                sellAmount = (sellToken.fastBalanceOf(address(this)) * bps).unsafeDiv(BASIS);\n            }\n            sellToken.safeTransfer(address(dodo), sellAmount);\n        }\n        if (quoteForBase) {\n            buyAmount = dodo.fastSellQuote(recipient);\n            if (buyAmount < minBuyAmount) {\n                revertTooMuchSlippage(dodo.fast_BASE_TOKEN_(), minBuyAmount, buyAmount);\n            }\n        } else {\n            buyAmount = dodo.fastSellBase(recipient);\n            if (buyAmount < minBuyAmount) {\n                revertTooMuchSlippage(dodo.fast_QUOTE_TOKEN_(), minBuyAmount, buyAmount);\n            }\n        }\n    }\n}\n\n// src/core/MakerPSM.sol\n\ninterface IPSM {\n    /// @dev Get the fee for selling DAI to USDC in PSM\n    /// @return tout toll out [wad]\n    function tout() external view returns (uint256);\n\n    /// @dev Get the address of the underlying vault powering PSM\n    /// @return address of gemJoin contract\n    function gemJoin() external view returns (address);\n\n    /// @dev Sell USDC for DAI\n    /// @param usr The address of the account trading USDC for DAI.\n    /// @param gemAmt The amount of USDC to sell in USDC base units\n    /// @return daiOutWad The amount of Dai bought.\n    function sellGem(address usr, uint256 gemAmt) external returns (uint256 daiOutWad);\n\n    /// @dev Buy USDC for DAI\n    /// @param usr The address of the account trading DAI for USDC\n    /// @param gemAmt The amount of USDC to buy in USDC base units\n    /// @return daiInWad The amount of Dai required to sell.\n    function buyGem(address usr, uint256 gemAmt) external returns (uint256 daiInWad);\n}\n\nlibrary FastPSM {\n    function fastSellGem(IPSM psm, address usr, uint256 gemAmt) internal returns (uint256 daiOutWad) {\n        assembly (\"memory-safe\") {\n            mstore(0x34, gemAmt)\n            mstore(0x14, usr)\n            mstore(0x00, 0x95991276000000000000000000000000) // selector for `sellGem(address,uint256)` with `usr`'s padding\n\n            if iszero(call(gas(), psm, 0x00, 0x10, 0x44, 0x00, 0x20)) {\n                let ptr := and(0xffffffffffffffffffffffff, mload(0x40))\n                returndatacopy(ptr, 0x00, returndatasize())\n                revert(ptr, returndatasize())\n            }\n            if iszero(gt(returndatasize(), 0x1f)) { revert(0x00, 0x00) }\n\n            mstore(0x34, 0x00)\n            daiOutWad := mload(0x00)\n        }\n    }\n\n    function fastBuyGem(IPSM psm, address usr, uint256 gemAmt) internal returns (uint256 daiInWad) {\n        assembly (\"memory-safe\") {\n            mstore(0x34, gemAmt)\n            mstore(0x14, usr)\n            mstore(0x00, 0x8d7ef9bb000000000000000000000000) // selector for `buyGem(address,uint256)` with `usr`'s padding\n\n            if iszero(call(gas(), psm, 0x00, 0x10, 0x44, 0x00, 0x20)) {\n                let ptr := and(0xffffffffffffffffffffffff, mload(0x40))\n                returndatacopy(ptr, 0x00, returndatasize())\n                revert(ptr, returndatasize())\n            }\n            if iszero(gt(returndatasize(), 0x1f)) { revert(0x00, 0x00) }\n\n            mstore(0x34, 0x00)\n            daiInWad := mload(0x00)\n        }\n    }\n}\n\n// Maker units https://github.com/makerdao/dss/blob/master/DEVELOPING.md\n// wad: fixed point decimal with 18 decimals (for basic quantities, e.g. balances)\nuint256 constant WAD = 10 ** 18;\n\nIERC20 constant DAI = IERC20(0x6B175474E89094C44Da98b954EedeAC495271d0F);\nIERC20 constant USDC = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\nIPSM constant LitePSM = IPSM(0xf6e72Db5454dd049d0788e411b06CfAF16853042);\n\nabstract contract MakerPSM is SettlerAbstract {\n    using UnsafeMath for uint256;\n    using SafeTransferLib for IERC20;\n    using FastPSM for IPSM;\n\n    uint256 private immutable USDC_basis;\n\n    constructor() {\n        assert(block.chainid == 1 || block.chainid == 31337);\n        DAI.safeApprove(address(LitePSM), type(uint256).max);\n        // LitePSM is its own join\n        USDC.safeApprove(address(LitePSM), type(uint256).max);\n        USDC_basis = 10 ** USDC.decimals();\n    }\n\n    function sellToMakerPsm(address recipient, uint256 bps, bool buyGem, uint256 amountOutMin)\n        internal\n        returns (uint256 buyAmount)\n    {\n        if (buyGem) {\n            unchecked {\n                // phantom overflow can't happen here because DAI has decimals = 18\n                uint256 sellAmount = (DAI.fastBalanceOf(address(this)) * bps).unsafeDiv(BASIS);\n\n                uint256 feeDivisor = LitePSM.tout() + WAD; // eg. 1.001 * 10 ** 18 with 0.1% fee [tout is in wad];\n                // overflow can't happen at all because DAI is reasonable and PSM prohibits gemToken with decimals > 18\n                buyAmount = (sellAmount * USDC_basis).unsafeDiv(feeDivisor);\n                if (buyAmount < amountOutMin) {\n                    revertTooMuchSlippage(USDC, amountOutMin, buyAmount);\n                }\n\n                // DAI.safeApproveIfBelow(address(LitePSM), sellAmount);\n                LitePSM.fastBuyGem(recipient, buyAmount);\n            }\n        } else {\n            // phantom overflow can't happen here because PSM prohibits gemToken with decimals > 18\n            uint256 sellAmount;\n            unchecked {\n                sellAmount = (USDC.fastBalanceOf(address(this)) * bps).unsafeDiv(BASIS);\n            }\n            // USDC.safeApproveIfBelow(LitePSM.gemJoin(), sellAmount);\n            buyAmount = LitePSM.fastSellGem(recipient, sellAmount);\n            if (buyAmount < amountOutMin) {\n                revertTooMuchSlippage(DAI, amountOutMin, buyAmount);\n            }\n        }\n    }\n}\n\n// src/core/UniswapV2.sol\n\ninterface IUniV2Pair {\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n\n    function getReserves() external view returns (uint112, uint112, uint32);\n\n    function swap(uint256, uint256, address, bytes calldata) external;\n}\n\nabstract contract UniswapV2 is SettlerAbstract {\n    using SafeTransferLib for IERC20;\n\n    // bytes4(keccak256(\"getReserves()\"))\n    uint32 private constant UNI_PAIR_RESERVES_SELECTOR = 0x0902f1ac;\n    // bytes4(keccak256(\"swap(uint256,uint256,address,bytes)\"))\n    uint32 private constant UNI_PAIR_SWAP_SELECTOR = 0x022c0d9f;\n    // bytes4(keccak256(\"transfer(address,uint256)\"))\n    uint32 private constant ERC20_TRANSFER_SELECTOR = 0xa9059cbb;\n    // bytes4(keccak256(\"balanceOf(address)\"))\n    uint32 private constant ERC20_BALANCEOF_SELECTOR = 0x70a08231;\n\n    /// @dev Sell a token for another token using UniswapV2.\n    function sellToUniswapV2(\n        address recipient,\n        address sellToken,\n        uint256 bps,\n        address pool,\n        uint24 swapInfo,\n        uint256 minBuyAmount\n    ) internal {\n        // Preventing calls to Permit2 or AH is not explicitly required as neither of these contracts implement the `swap` nor `transfer` selector\n\n        // |7|6|5|4|3|2|1|0| - bit positions in swapInfo (uint8)\n        // |0|0|0|0|0|0|F|Z| - Z: zeroForOne flag, F: sellTokenHasFee flag\n        bool zeroForOne = (swapInfo & 1) == 1; // Extract the least significant bit (bit 0)\n        bool sellTokenHasFee = (swapInfo & 2) >> 1 == 1; // Extract the second least significant bit (bit 1) and shift it right\n        uint256 feeBps = swapInfo >> 8;\n\n        uint256 sellAmount;\n        uint256 buyAmount;\n        // If bps is zero we assume there are no funds within this contract, skip the updating sellAmount.\n        // This case occurs if the pool is being chained, in which the funds have been sent directly to the pool\n        if (bps != 0) {\n            // We don't care about phantom overflow here because reserves are\n            // limited to 112 bits. Any token balance that would overflow here would\n            // also break UniV2.\n            // It is *possible* to set `bps` above the basis and therefore\n            // cause an overflow on this multiplication. However, `bps` is\n            // passed as authenticated calldata, so this is a GIGO error that we\n            // do not attempt to fix.\n            unchecked {\n                sellAmount = IERC20(sellToken).fastBalanceOf(address(this)) * bps / BASIS;\n            }\n        }\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40)\n\n            // transfer sellAmount (a non zero amount) of sellToken to the pool\n            if sellAmount {\n                mstore(ptr, ERC20_TRANSFER_SELECTOR)\n                mstore(add(ptr, 0x20), pool)\n                mstore(add(ptr, 0x40), sellAmount)\n                // ...||ERC20_TRANSFER_SELECTOR|pool|sellAmount|\n                if iszero(call(gas(), sellToken, 0, add(ptr, 0x1c), 0x44, 0x00, 0x20)) { bubbleRevert(ptr) }\n                if iszero(or(iszero(returndatasize()), and(iszero(lt(returndatasize(), 0x20)), eq(mload(0x00), 1)))) {\n                    revert(0, 0)\n                }\n            }\n\n            // get pool reserves\n            let sellReserve\n            let buyReserve\n            mstore(0x00, UNI_PAIR_RESERVES_SELECTOR)\n            // ||UNI_PAIR_RESERVES_SELECTOR|\n            if iszero(staticcall(gas(), pool, 0x1c, 0x04, 0x00, 0x40)) { bubbleRevert(ptr) }\n            if lt(returndatasize(), 0x40) { revert(0, 0) }\n            {\n                let r := shl(5, zeroForOne)\n                buyReserve := mload(r)\n                sellReserve := mload(xor(0x20, r))\n            }\n\n            // Update the sell amount in the following cases:\n            //   the funds are in the pool already (flagged by sellAmount being 0)\n            //   the sell token has a fee (flagged by sellTokenHasFee)\n            if or(iszero(sellAmount), sellTokenHasFee) {\n                // retrieve the sellToken balance of the pool\n                mstore(0x00, ERC20_BALANCEOF_SELECTOR)\n                mstore(0x20, and(0xffffffffffffffffffffffffffffffffffffffff, pool))\n                // ||ERC20_BALANCEOF_SELECTOR|pool|\n                if iszero(staticcall(gas(), sellToken, 0x1c, 0x24, 0x00, 0x20)) { bubbleRevert(ptr) }\n                if lt(returndatasize(), 0x20) { revert(0, 0) }\n                let bal := mload(0x00)\n\n                // determine real sellAmount by comparing pool's sellToken balance to reserve amount\n                if lt(bal, sellReserve) {\n                    mstore(0x00, 0x4e487b71) // selector for `Panic(uint256)`\n                    mstore(0x20, 0x11) // panic code for arithmetic underflow\n                    revert(0x1c, 0x24)\n                }\n                sellAmount := sub(bal, sellReserve)\n            }\n\n            // compute buyAmount based on sellAmount and reserves\n            let sellAmountWithFee := mul(sellAmount, sub(10000, feeBps))\n            buyAmount := div(mul(sellAmountWithFee, buyReserve), add(sellAmountWithFee, mul(sellReserve, 10000)))\n            let swapCalldata := add(ptr, 0x1c)\n            // set up swap call selector and empty callback data\n            mstore(ptr, UNI_PAIR_SWAP_SELECTOR)\n            mstore(add(ptr, 0x80), 0x80) // offset to length of data\n            mstore(add(ptr, 0xa0), 0) // length of data\n\n            // set amount0Out and amount1Out\n            {\n                // If `zeroForOne`, offset is 0x24, else 0x04\n                let offset := add(0x04, shl(5, zeroForOne))\n                mstore(add(swapCalldata, offset), buyAmount)\n                mstore(add(swapCalldata, xor(0x20, offset)), 0)\n            }\n\n            mstore(add(swapCalldata, 0x44), and(0xffffffffffffffffffffffffffffffffffffffff, recipient))\n            // ...||UNI_PAIR_SWAP_SELECTOR|amount0Out|amount1Out|recipient|data|\n\n            // perform swap at the pool sending bought tokens to the recipient\n            if iszero(call(gas(), pool, 0, swapCalldata, 0xa4, 0, 0)) { bubbleRevert(swapCalldata) }\n\n            // revert with the return data from the most recent call\n            function bubbleRevert(p) {\n                returndatacopy(p, 0, returndatasize())\n                revert(p, returndatasize())\n            }\n        }\n        if (buyAmount < minBuyAmount) {\n            revertTooMuchSlippage(\n                IERC20(zeroForOne ? IUniV2Pair(pool).token1() : IUniV2Pair(pool).token0()), minBuyAmount, buyAmount\n            );\n        }\n    }\n}\n\n// src/core/MaverickV2.sol\n\n// Maverick AMM V2 is not open-source. The source code was disclosed to the\n// developers of 0x Settler confidentially and recompiled privately. The\n// deployed bytecode inithash matches the privately recompiled inithash.\nbytes32 constant maverickV2InitHash = 0xbb7b783eb4b8ca46925c5384a6b9919df57cb83da8f76e37291f58d0dd5c439a;\n\n// https://docs.mav.xyz/technical-reference/contract-addresses/v2-contract-addresses\n// For chains: mainnet, base, bnb, arbitrum, scroll, sepolia\naddress constant maverickV2Factory = 0x0A7e848Aca42d879EF06507Fca0E7b33A0a63c1e;\n\ninterface IMaverickV2Pool {\n    /**\n     * @notice Parameters for swap.\n     * @param amount Amount of the token that is either the input if exactOutput is false\n     * or the output if exactOutput is true.\n     * @param tokenAIn Boolean indicating whether tokenA is the input.\n     * @param exactOutput Boolean indicating whether the amount specified is\n     * the exact output amount (true).\n     * @param tickLimit The furthest tick a swap will execute in. If no limit\n     * is desired, value should be set to type(int32).max for a tokenAIn swap\n     * and type(int32).min for a swap where tokenB is the input.\n     */\n    struct SwapParams {\n        uint256 amount;\n        bool tokenAIn;\n        bool exactOutput;\n        int32 tickLimit;\n    }\n\n    /**\n     * @notice Swap tokenA/tokenB assets in the pool.  The swap user has two\n     * options for funding their swap.\n     * - The user can push the input token amount to the pool before calling\n     * the swap function. In order to avoid having the pool call the callback,\n     * the user should pass a zero-length `data` bytes object with the swap\n     * call.\n     * - The user can send the input token amount to the pool when the pool\n     * calls the `maverickV2SwapCallback` function on the calling contract.\n     * That callback has input parameters that specify the token address of the\n     * input token, the input and output amounts, and the bytes data sent to\n     * the swap function.\n     * @dev  If the users elects to do a callback-based swap, the output\n     * assets will be sent before the callback is called, allowing the user to\n     * execute flash swaps.  However, the pool does have reentrancy protection,\n     * so a swapper will not be able to interact with the same pool again\n     * while they are in the callback function.\n     * @param recipient The address to receive the output tokens.\n     * @param params Parameters containing the details of the swap\n     * @param data Bytes information that gets passed to the callback.\n     */\n    function swap(address recipient, SwapParams calldata params, bytes calldata data)\n        external\n        returns (uint256 amountIn, uint256 amountOut);\n\n    /**\n     * @notice Pool tokenA.  Address of tokenA is such that tokenA < tokenB.\n     */\n    function tokenA() external view returns (IERC20);\n\n    /**\n     * @notice Pool tokenB.\n     */\n    function tokenB() external view returns (IERC20);\n\n    /**\n     * @notice State of the pool.\n     * @param reserveA Pool tokenA balanceOf at end of last operation\n     * @param reserveB Pool tokenB balanceOf at end of last operation\n     * @param lastTwaD8 Value of log time weighted average price at last block.\n     * Value is 8-decimal scale and is in the fractional tick domain.  E.g. a\n     * value of 12.3e8 indicates the TWAP was 3/10ths of the way into the 12th\n     * tick.\n     * @param lastLogPriceD8 Value of log price at last block. Value is\n     * 8-decimal scale and is in the fractional tick domain.  E.g. a value of\n     * 12.3e8 indicates the price was 3/10ths of the way into the 12th tick.\n     * @param lastTimestamp Last block.timestamp value in seconds for latest\n     * swap transaction.\n     * @param activeTick Current tick position that contains the active bins.\n     * @param isLocked Pool isLocked, E.g., locked or unlocked; isLocked values\n     * defined in Pool.sol.\n     * @param binCounter Index of the last bin created.\n     * @param protocolFeeRatioD3 Ratio of the swap fee that is kept for the\n     * protocol.\n     */\n    struct State {\n        uint128 reserveA;\n        uint128 reserveB;\n        int64 lastTwaD8;\n        int64 lastLogPriceD8;\n        uint40 lastTimestamp;\n        int32 activeTick;\n        bool isLocked;\n        uint32 binCounter;\n        uint8 protocolFeeRatioD3;\n    }\n\n    /**\n     * @notice External function to get the state of the pool.\n     */\n    function getState() external view returns (State memory);\n}\n\ninterface IMaverickV2SwapCallback {\n    function maverickV2SwapCallback(IERC20 tokenIn, uint256 amountIn, uint256 amountOut, bytes calldata data)\n        external;\n}\n\nabstract contract MaverickV2 is SettlerAbstract {\n    using UnsafeMath for uint256;\n    using SafeTransferLib for IERC20;\n\n    function _encodeSwapCallback(ISignatureTransfer.PermitTransferFrom memory permit, bytes memory sig)\n        internal\n        view\n        returns (bytes memory result)\n    {\n        bool isForwarded = _isForwarded();\n        assembly (\"memory-safe\") {\n            result := mload(0x40)\n            mcopy(add(0x20, result), mload(permit), 0x40)\n            mcopy(add(0x60, result), add(0x20, permit), 0x40)\n            mstore8(add(0xa0, result), isForwarded)\n            let sigLength := mload(sig)\n            mcopy(add(0xa1, result), add(0x20, sig), sigLength)\n            mstore(result, add(0x81, sigLength))\n            mstore(0x40, add(sigLength, add(0xa1, result)))\n        }\n    }\n\n    function sellToMaverickV2VIP(\n        address recipient,\n        bytes32 salt,\n        bool tokenAIn,\n        ISignatureTransfer.PermitTransferFrom memory permit,\n        bytes memory sig,\n        uint256 minBuyAmount\n    ) internal returns (uint256 buyAmount) {\n        bytes memory swapCallbackData = _encodeSwapCallback(permit, sig);\n        address pool = AddressDerivation.deriveDeterministicContract(maverickV2Factory, salt, maverickV2InitHash);\n        (, buyAmount) = abi.decode(\n            _setOperatorAndCall(\n                pool,\n                abi.encodeCall(\n                    IMaverickV2Pool.swap,\n                    (\n                        recipient,\n                        IMaverickV2Pool.SwapParams({\n                            amount: _permitToSellAmount(permit),\n                            tokenAIn: tokenAIn,\n                            exactOutput: false,\n                            // TODO: actually set a tick limit so that we can partial fill\n                            tickLimit: tokenAIn ? type(int32).max : type(int32).min\n                        }),\n                        swapCallbackData\n                    )\n                ),\n                uint32(IMaverickV2SwapCallback.maverickV2SwapCallback.selector),\n                _maverickV2Callback\n            ),\n            (uint256, uint256)\n        );\n        if (buyAmount < minBuyAmount) {\n            IERC20 buyToken = tokenAIn ? IMaverickV2Pool(pool).tokenB() : IMaverickV2Pool(pool).tokenA();\n            revertTooMuchSlippage(buyToken, minBuyAmount, buyAmount);\n        }\n    }\n\n    function sellToMaverickV2(\n        address recipient,\n        IERC20 sellToken,\n        uint256 bps,\n        IMaverickV2Pool pool,\n        bool tokenAIn,\n        uint256 minBuyAmount\n    ) internal returns (uint256 buyAmount) {\n        uint256 sellAmount;\n        if (bps != 0) {\n            unchecked {\n                // We don't care about phantom overflow here because reserves\n                // are limited to 128 bits. Any token balance that would\n                // overflow here would also break MaverickV2.\n                sellAmount = (sellToken.fastBalanceOf(address(this)) * bps).unsafeDiv(BASIS);\n            }\n        }\n        if (sellAmount == 0) {\n            sellAmount = sellToken.fastBalanceOf(address(pool));\n            IMaverickV2Pool.State memory poolState = pool.getState();\n            unchecked {\n                sellAmount -= tokenAIn ? poolState.reserveA : poolState.reserveB;\n            }\n        } else {\n            sellToken.safeTransfer(address(pool), sellAmount);\n        }\n        (, buyAmount) = pool.swap(\n            recipient,\n            IMaverickV2Pool.SwapParams({\n                amount: sellAmount,\n                tokenAIn: tokenAIn,\n                exactOutput: false,\n                // TODO: actually set a tick limit so that we can partial fill\n                tickLimit: tokenAIn ? type(int32).max : type(int32).min\n            }),\n            new bytes(0)\n        );\n        if (buyAmount < minBuyAmount) {\n            revertTooMuchSlippage(tokenAIn ? pool.tokenB() : pool.tokenA(), minBuyAmount, buyAmount);\n        }\n    }\n\n    function _maverickV2Callback(bytes calldata data) private returns (bytes memory) {\n        require(data.length >= 0xa0);\n        IERC20 tokenIn;\n        uint256 amountIn;\n        assembly (\"memory-safe\") {\n            // we don't bother checking for dirty bits because we trust the\n            // initcode (by its hash) to produce well-behaved bytecode that\n            // produces strict ABI-encoded calldata\n            tokenIn := calldataload(data.offset)\n            amountIn := calldataload(add(0x20, data.offset))\n            // likewise, we don't bother to perform the indirection to find the\n            // nested data. we just index directly to it because we know that\n            // the pool follows strict ABI encoding\n            data.length := calldataload(add(0x80, data.offset))\n            data.offset := add(0xa0, data.offset)\n        }\n        maverickV2SwapCallback(\n            tokenIn,\n            amountIn,\n            // forgefmt: disable-next-line\n            0 /* we didn't bother loading `amountOut` because we don't use it */,\n            data\n        );\n        return new bytes(0);\n    }\n\n    // forgefmt: disable-next-line\n    function maverickV2SwapCallback(IERC20 tokenIn, uint256 amountIn, uint256 /* amountOut */, bytes calldata data)\n        private\n    {\n        ISignatureTransfer.PermitTransferFrom calldata permit;\n        bool isForwarded;\n        assembly (\"memory-safe\") {\n            permit := data.offset\n            isForwarded := and(0x01, calldataload(add(0x61, data.offset)))\n            data.offset := add(0x81, data.offset)\n            data.length := sub(data.length, 0x81)\n        }\n        assert(tokenIn == IERC20(permit.permitted.token));\n        ISignatureTransfer.SignatureTransferDetails memory transferDetails =\n            ISignatureTransfer.SignatureTransferDetails({to: msg.sender, requestedAmount: amountIn});\n        _transferFrom(permit, transferDetails, data, isForwarded);\n    }\n}\n\n// src/core/RfqOrderSettlement.sol\n\nabstract contract RfqOrderSettlement is SettlerAbstract {\n    using Ternary for bool;\n    using SafeTransferLib for IERC20;\n    using FullMath for uint256;\n\n    struct Consideration {\n        IERC20 token;\n        uint256 amount;\n        address counterparty;\n        bool partialFillAllowed;\n    }\n\n    string internal constant CONSIDERATION_TYPE =\n        \"Consideration(address token,uint256 amount,address counterparty,bool partialFillAllowed)\";\n    // `string.concat` isn't recognized by solc as compile-time constant, but `abi.encodePacked` is\n    string internal constant CONSIDERATION_WITNESS =\n        string(abi.encodePacked(\"Consideration consideration)\", CONSIDERATION_TYPE, TOKEN_PERMISSIONS_TYPE));\n    bytes32 internal constant CONSIDERATION_TYPEHASH =\n        0x7d806873084f389a66fd0315dead7adaad8ae6e8b6cf9fb0d3db61e5a91c3ffa;\n\n    string internal constant RFQ_ORDER_TYPE =\n        \"RfqOrder(Consideration makerConsideration,Consideration takerConsideration)\";\n    string internal constant RFQ_ORDER_TYPE_RECURSIVE = string(abi.encodePacked(RFQ_ORDER_TYPE, CONSIDERATION_TYPE));\n    bytes32 internal constant RFQ_ORDER_TYPEHASH = 0x49fa719b76f0f6b7e76be94b56c26671a548e1c712d5b13dc2874f70a7598276;\n\n    function _hashConsideration(Consideration memory consideration) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            let ptr := sub(consideration, 0x20)\n            let oldValue := mload(ptr)\n            mstore(ptr, CONSIDERATION_TYPEHASH)\n            result := keccak256(ptr, 0xa0)\n            mstore(ptr, oldValue)\n        }\n    }\n\n    function _logRfqOrder(bytes32 makerConsiderationHash, bytes32 takerConsiderationHash, uint128 makerFilledAmount)\n        private\n    {\n        assembly (\"memory-safe\") {\n            mstore(0x00, RFQ_ORDER_TYPEHASH)\n            mstore(0x20, makerConsiderationHash)\n            let ptr := mload(0x40)\n            mstore(0x40, takerConsiderationHash)\n            let orderHash := keccak256(0x00, 0x60)\n            mstore(0x40, ptr)\n            mstore(0x10, makerFilledAmount)\n            mstore(0x00, orderHash)\n            log0(0x00, 0x30)\n        }\n    }\n\n    constructor() {\n        assert(CONSIDERATION_TYPEHASH == keccak256(bytes(CONSIDERATION_TYPE)));\n        assert(RFQ_ORDER_TYPEHASH == keccak256(bytes(RFQ_ORDER_TYPE_RECURSIVE)));\n    }\n\n    /// @dev Settle an RfqOrder between maker and taker transfering funds directly between the counterparties. Either\n    ///      two Permit2 signatures are consumed, with the maker Permit2 containing a witness of the RfqOrder, or\n    ///      AllowanceHolder is supported for the taker payment. The Maker has signed the same order as the\n    ///      Taker. Submission may be directly by the taker or via a third party with the Taker signing a witness.\n    /// @dev if used, the taker's witness is not calculated nor verified here as calling function is trusted\n    function fillRfqOrderVIP(\n        address recipient,\n        ISignatureTransfer.PermitTransferFrom memory makerPermit,\n        address maker,\n        bytes memory makerSig,\n        ISignatureTransfer.PermitTransferFrom memory takerPermit,\n        bytes memory takerSig\n    ) internal {\n        if (!_hasMetaTxn()) {\n            assert(makerPermit.permitted.amount <= type(uint256).max - BASIS);\n        }\n        (ISignatureTransfer.SignatureTransferDetails memory makerTransferDetails, uint256 makerAmount) =\n            _permitToTransferDetails(makerPermit, recipient);\n        // In theory, the taker permit could invoke the balance-proportional sell amount logic. However,\n        // because we hash the sell amount computed here into the maker's consideration (witness) only a\n        // balance-proportional sell amount that corresponds exactly to the signed order would avoid a\n        // revert. In other words, no unexpected behavior is possible. It's pointless to prohibit the\n        // use of that logic.\n        (ISignatureTransfer.SignatureTransferDetails memory takerTransferDetails, uint256 takerAmount) =\n            _permitToTransferDetails(takerPermit, maker);\n\n        bytes32 witness = _hashConsideration(\n            Consideration({\n                token: IERC20(takerPermit.permitted.token),\n                amount: takerAmount,\n                counterparty: _msgSender(),\n                partialFillAllowed: false\n            })\n        );\n        _transferFrom(takerPermit, takerTransferDetails, takerSig);\n        _transferFromIKnowWhatImDoing(\n            makerPermit, makerTransferDetails, maker, witness, CONSIDERATION_WITNESS, makerSig, false\n        );\n\n        _logRfqOrder(\n            witness,\n            _hashConsideration(\n                Consideration({\n                    token: IERC20(makerPermit.permitted.token),\n                    amount: makerAmount,\n                    counterparty: maker,\n                    partialFillAllowed: false\n                })\n            ),\n            uint128(makerAmount)\n        );\n    }\n\n    /// @dev Settle an RfqOrder between maker and Settler retaining funds in this contract.\n    /// @dev pre-condition: msgSender has been authenticated against the requestor\n    /// One Permit2 signature is consumed, with the maker Permit2 containing a witness of the RfqOrder.\n    // In this variant, Maker pays recipient and Settler pays Maker\n    function fillRfqOrderSelfFunded(\n        address recipient,\n        ISignatureTransfer.PermitTransferFrom memory permit,\n        address maker,\n        bytes memory makerSig,\n        IERC20 takerToken,\n        uint256 maxTakerAmount\n    ) internal {\n        if (!_hasMetaTxn()) {\n            assert(permit.permitted.amount <= type(uint256).max - BASIS);\n        }\n        // Compute witnesses. These are based on the quoted maximum amounts. We will modify them\n        // later to adjust for the actual settled amount, which may be modified by encountered\n        // slippage.\n        (ISignatureTransfer.SignatureTransferDetails memory transferDetails, uint256 makerAmount) =\n            _permitToTransferDetails(permit, recipient);\n\n        bytes32 takerWitness = _hashConsideration(\n            Consideration({\n                token: IERC20(permit.permitted.token),\n                amount: makerAmount,\n                counterparty: maker,\n                partialFillAllowed: true\n            })\n        );\n        bytes32 makerWitness = _hashConsideration(\n            Consideration({\n                token: takerToken,\n                amount: maxTakerAmount,\n                counterparty: _msgSender(),\n                partialFillAllowed: true\n            })\n        );\n\n        // Now we adjust the transfer amounts to compensate for encountered slippage. Rounding is\n        // performed in the maker's favor.\n        uint256 takerAmount = takerToken.fastBalanceOf(address(this));\n        takerAmount = (takerAmount > maxTakerAmount).ternary(maxTakerAmount, takerAmount);\n        transferDetails.requestedAmount = makerAmount = makerAmount.unsafeMulDiv(takerAmount, maxTakerAmount);\n\n        // Now that we have all the relevant information, make the transfers and log the order.\n        takerToken.safeTransfer(maker, takerAmount);\n        _transferFromIKnowWhatImDoing(\n            permit, transferDetails, maker, makerWitness, CONSIDERATION_WITNESS, makerSig, false\n        );\n\n        _logRfqOrder(makerWitness, takerWitness, uint128(makerAmount));\n    }\n}\n\n// src/core/UniswapV3Fork.sol\n\ninterface IUniswapV3Pool {\n    /// @notice Swap token0 for token1, or token1 for token0\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback\n    /// @param recipient The address to receive the output of the swap\n    /// @param zeroForOne The direction of the swap, true for token0 to token1, false for token1 to token0\n    /// @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive),\n    /// or exact output (negative)\n    /// @param sqrtPriceLimitX96 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this\n    /// value after the swap. If one for zero, the price cannot be greater than this value after the swap\n    /// @param data Any data to be passed through to the callback\n    /// @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive\n    /// @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive\n    function swap(\n        address recipient,\n        bool zeroForOne,\n        int256 amountSpecified,\n        uint160 sqrtPriceLimitX96,\n        bytes calldata data\n    ) external returns (int256 amount0, int256 amount1);\n}\n\nabstract contract UniswapV3Fork is SettlerAbstract {\n    using UnsafeMath for uint256;\n    using UnsafeMath for int256;\n    using SafeTransferLib for IERC20;\n\n    /// @dev Minimum size of an encoded swap path:\n    ///      sizeof(address(inputToken) | uint8(forkId) | uint24(poolId) | address(outputToken))\n    uint256 private constant SINGLE_HOP_PATH_SIZE = 0x2c;\n    /// @dev How many bytes to skip ahead in an encoded path to start at the next hop:\n    ///      sizeof(address(inputToken) | uint8(forkId) | uint24(poolId))\n    uint256 private constant PATH_SKIP_HOP_SIZE = 0x18;\n    /// @dev The size of the swap callback prefix data before the Permit2 data.\n    uint256 private constant SWAP_CALLBACK_PREFIX_DATA_SIZE = 0x28;\n    /// @dev The offset from the pointer to the length of the swap callback prefix data to the start of the Permit2 data.\n    uint256 private constant SWAP_CALLBACK_PERMIT2DATA_OFFSET = 0x48;\n    uint256 private constant PERMIT_DATA_SIZE = 0x60;\n    uint256 private constant ISFORWARDED_DATA_SIZE = 0x01;\n    /// @dev Minimum tick price sqrt ratio.\n    uint160 private constant MIN_PRICE_SQRT_RATIO = 4295128739;\n    /// @dev Minimum tick price sqrt ratio.\n    uint160 private constant MAX_PRICE_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\n    /// @dev Mask of lower 20 bytes.\n    uint256 private constant ADDRESS_MASK = 0x00ffffffffffffffffffffffffffffffffffffffff;\n    /// @dev Mask of lower 3 bytes.\n    uint256 private constant UINT24_MASK = 0xffffff;\n\n    /// @dev Sell a token for another token directly against uniswap v3.\n    /// @param encodedPath Uniswap-encoded path.\n    /// @param bps proportion of current balance of the first token in the path to sell.\n    /// @param minBuyAmount Minimum amount of the last token in the path to buy.\n    /// @param recipient The recipient of the bought tokens.\n    /// @return buyAmount Amount of the last token in the path bought.\n    function sellToUniswapV3(address recipient, uint256 bps, bytes memory encodedPath, uint256 minBuyAmount)\n        internal\n        returns (uint256 buyAmount)\n    {\n        buyAmount = _uniV3ForkSwap(\n            recipient,\n            encodedPath,\n            // We don't care about phantom overflow here because reserves are\n            // limited to 128 bits. Any token balance that would overflow here\n            // would also break UniV3.\n            (IERC20(address(bytes20(encodedPath))).fastBalanceOf(address(this)) * bps).unsafeDiv(BASIS),\n            minBuyAmount,\n            address(this), // payer\n            new bytes(SWAP_CALLBACK_PREFIX_DATA_SIZE)\n        );\n    }\n\n    /// @dev Sell a token for another token directly against uniswap v3. Payment is using a Permit2 signature (or AllowanceHolder).\n    /// @param encodedPath Uniswap-encoded path.\n    /// @param minBuyAmount Minimum amount of the last token in the path to buy.\n    /// @param recipient The recipient of the bought tokens.\n    /// @param permit The PermitTransferFrom allowing this contract to spend the taker's tokens\n    /// @param sig The taker's signature for Permit2\n    /// @return buyAmount Amount of the last token in the path bought.\n    function sellToUniswapV3VIP(\n        address recipient,\n        bytes memory encodedPath,\n        ISignatureTransfer.PermitTransferFrom memory permit,\n        bytes memory sig,\n        uint256 minBuyAmount\n    ) internal returns (uint256 buyAmount) {\n        bytes memory swapCallbackData =\n            new bytes(SWAP_CALLBACK_PREFIX_DATA_SIZE + PERMIT_DATA_SIZE + ISFORWARDED_DATA_SIZE + sig.length);\n        _encodePermit2Data(swapCallbackData, permit, sig, _isForwarded());\n\n        buyAmount = _uniV3ForkSwap(\n            recipient,\n            encodedPath,\n            _permitToSellAmount(permit),\n            minBuyAmount,\n            address(0), // payer\n            swapCallbackData\n        );\n    }\n\n    // Executes successive swaps along an encoded uniswap path.\n    function _uniV3ForkSwap(\n        address recipient,\n        bytes memory encodedPath,\n        uint256 sellAmount,\n        uint256 minBuyAmount,\n        address payer,\n        bytes memory swapCallbackData\n    ) internal returns (uint256 buyAmount) {\n        if (sellAmount > uint256(type(int256).max)) {\n            Panic.panic(Panic.ARITHMETIC_OVERFLOW);\n        }\n\n        IERC20 outputToken;\n        while (true) {\n            bool isPathMultiHop = _isPathMultiHop(encodedPath);\n            bool zeroForOne;\n            IUniswapV3Pool pool;\n            uint32 callbackSelector;\n            {\n                (IERC20 token0, uint8 forkId, uint24 poolId, IERC20 token1) = _decodeFirstPoolInfoFromPath(encodedPath);\n                IERC20 sellToken = token0;\n                outputToken = token1;\n                if (!(zeroForOne = token0 < token1)) {\n                    (token0, token1) = (token1, token0);\n                }\n                address factory;\n                bytes32 initHash;\n                (factory, initHash, callbackSelector) = _uniV3ForkInfo(forkId);\n                pool = _toPool(factory, initHash, token0, token1, poolId);\n                _updateSwapCallbackData(swapCallbackData, sellToken, payer);\n            }\n\n            int256 amount0;\n            int256 amount1;\n            if (isPathMultiHop) {\n                uint256 freeMemPtr;\n                assembly (\"memory-safe\") {\n                    freeMemPtr := mload(0x40)\n                }\n                (amount0, amount1) = abi.decode(\n                    _setOperatorAndCall(\n                        address(pool),\n                        abi.encodeCall(\n                            pool.swap,\n                            (\n                                // Intermediate tokens go to this contract.\n                                address(this),\n                                zeroForOne,\n                                int256(sellAmount),\n                                zeroForOne ? MIN_PRICE_SQRT_RATIO + 1 : MAX_PRICE_SQRT_RATIO - 1,\n                                swapCallbackData\n                            )\n                        ),\n                        callbackSelector,\n                        _uniV3ForkCallback\n                    ),\n                    (int256, int256)\n                );\n                assembly (\"memory-safe\") {\n                    mstore(0x40, freeMemPtr)\n                }\n            } else {\n                (amount0, amount1) = abi.decode(\n                    _setOperatorAndCall(\n                        address(pool),\n                        abi.encodeCall(\n                            pool.swap,\n                            (\n                                recipient,\n                                zeroForOne,\n                                int256(sellAmount),\n                                zeroForOne ? MIN_PRICE_SQRT_RATIO + 1 : MAX_PRICE_SQRT_RATIO - 1,\n                                swapCallbackData\n                            )\n                        ),\n                        callbackSelector,\n                        _uniV3ForkCallback\n                    ),\n                    (int256, int256)\n                );\n            }\n\n            {\n                int256 _buyAmount = (zeroForOne ? amount1 : amount0).unsafeNeg();\n                if (_buyAmount < 0) {\n                    Panic.panic(Panic.ARITHMETIC_OVERFLOW);\n                }\n                buyAmount = uint256(_buyAmount);\n            }\n            if (!isPathMultiHop) {\n                // Done.\n                break;\n            }\n            // Continue with next hop.\n            payer = address(this); // Subsequent hops are paid for by us.\n            sellAmount = buyAmount;\n            // Skip to next hop along path.\n            encodedPath = _shiftHopFromPathInPlace(encodedPath);\n            assembly (\"memory-safe\") {\n                mstore(swapCallbackData, SWAP_CALLBACK_PREFIX_DATA_SIZE)\n            }\n        }\n        if (buyAmount < minBuyAmount) {\n            revertTooMuchSlippage(outputToken, minBuyAmount, buyAmount);\n        }\n    }\n\n    // Return whether or not an encoded uniswap path contains more than one hop.\n    function _isPathMultiHop(bytes memory encodedPath) private pure returns (bool) {\n        return encodedPath.length > SINGLE_HOP_PATH_SIZE;\n    }\n\n    function _decodeFirstPoolInfoFromPath(bytes memory encodedPath)\n        private\n        pure\n        returns (IERC20 inputToken, uint8 forkId, uint24 poolId, IERC20 outputToken)\n    {\n        if (encodedPath.length < SINGLE_HOP_PATH_SIZE) {\n            Panic.panic(Panic.ARRAY_OUT_OF_BOUNDS);\n        }\n        assembly (\"memory-safe\") {\n            // Solidity cleans dirty bits automatically\n            inputToken := mload(add(encodedPath, 0x14))\n            forkId := mload(add(encodedPath, 0x15))\n            poolId := mload(add(encodedPath, 0x18))\n            outputToken := mload(add(encodedPath, SINGLE_HOP_PATH_SIZE))\n        }\n    }\n\n    // Skip past the first hop of an encoded uniswap path in-place.\n    function _shiftHopFromPathInPlace(bytes memory encodedPath) private pure returns (bytes memory) {\n        if (encodedPath.length < PATH_SKIP_HOP_SIZE) {\n            Panic.panic(Panic.ARRAY_OUT_OF_BOUNDS);\n        }\n        assembly (\"memory-safe\") {\n            let length := sub(mload(encodedPath), PATH_SKIP_HOP_SIZE)\n            encodedPath := add(encodedPath, PATH_SKIP_HOP_SIZE)\n            mstore(encodedPath, length)\n        }\n        return encodedPath;\n    }\n\n    function _encodePermit2Data(\n        bytes memory swapCallbackData,\n        ISignatureTransfer.PermitTransferFrom memory permit,\n        bytes memory sig,\n        bool isForwarded\n    ) private pure {\n        assembly (\"memory-safe\") {\n            mstore(add(SWAP_CALLBACK_PERMIT2DATA_OFFSET, swapCallbackData), mload(add(0x20, mload(permit))))\n            mcopy(add(add(SWAP_CALLBACK_PERMIT2DATA_OFFSET, 0x20), swapCallbackData), add(0x20, permit), 0x40)\n            mstore8(add(add(SWAP_CALLBACK_PERMIT2DATA_OFFSET, PERMIT_DATA_SIZE), swapCallbackData), isForwarded)\n            mcopy(\n                add(\n                    add(add(SWAP_CALLBACK_PERMIT2DATA_OFFSET, PERMIT_DATA_SIZE), ISFORWARDED_DATA_SIZE),\n                    swapCallbackData\n                ),\n                add(0x20, sig),\n                mload(sig)\n            )\n        }\n    }\n\n    // Update `swapCallbackData` in place with new values.\n    function _updateSwapCallbackData(bytes memory swapCallbackData, IERC20 sellToken, address payer) private pure {\n        assembly (\"memory-safe\") {\n            let length := mload(swapCallbackData)\n            mstore(add(0x28, swapCallbackData), sellToken)\n            mstore(add(0x14, swapCallbackData), payer)\n            mstore(swapCallbackData, length)\n        }\n    }\n\n    // Compute the pool address given two tokens and a poolId.\n    function _toPool(address factory, bytes32 initHash, IERC20 token0, IERC20 token1, uint24 poolId)\n        private\n        pure\n        returns (IUniswapV3Pool)\n    {\n        // address(keccak256(abi.encodePacked(\n        //     hex\"ff\",\n        //     factory,\n        //     keccak256(abi.encode(token0, token1, poolId)),\n        //     initHash\n        // )))\n        bytes32 salt;\n        assembly (\"memory-safe\") {\n            token0 := and(ADDRESS_MASK, token0)\n            token1 := and(ADDRESS_MASK, token1)\n            poolId := and(UINT24_MASK, poolId)\n            let ptr := mload(0x40)\n            mstore(0x00, token0)\n            mstore(0x20, token1)\n            mstore(0x40, poolId)\n            salt := keccak256(0x00, sub(0x60, shl(0x05, iszero(poolId))))\n            mstore(0x40, ptr)\n        }\n        return IUniswapV3Pool(AddressDerivation.deriveDeterministicContract(factory, salt, initHash));\n    }\n\n    function _uniV3ForkInfo(uint8 forkId) internal view virtual returns (address, bytes32, uint32);\n\n    function _uniV3ForkCallback(bytes calldata data) private returns (bytes memory) {\n        require(data.length >= 0x80);\n        int256 amount0Delta;\n        int256 amount1Delta;\n        assembly (\"memory-safe\") {\n            amount0Delta := calldataload(data.offset)\n            amount1Delta := calldataload(add(0x20, data.offset))\n            data.offset := add(data.offset, calldataload(add(0x40, data.offset)))\n            data.length := calldataload(data.offset)\n            data.offset := add(0x20, data.offset)\n        }\n        uniswapV3SwapCallback(amount0Delta, amount1Delta, data);\n        return new bytes(0);\n    }\n\n    /// @dev The UniswapV3 pool swap callback which pays the funds requested\n    ///      by the caller/pool to the pool. Can only be called by a valid\n    ///      UniswapV3 pool.\n    /// @param amount0Delta Token0 amount owed.\n    /// @param amount1Delta Token1 amount owed.\n    /// @param data Arbitrary data forwarded from swap() caller. A packed encoding of: payer, sellToken, (optionally: permit[0x20:], isForwarded, sig)\n    function uniswapV3SwapCallback(int256 amount0Delta, int256 amount1Delta, bytes calldata data) private {\n        address payer;\n        assembly (\"memory-safe\") {\n            payer := shr(0x60, calldataload(data.offset))\n            data.length := sub(data.length, 0x14)\n            data.offset := add(0x14, data.offset)\n            // We don't check for underflow/array-out-of-bounds here because the trusted inithash\n            // ensures that `data` was passed unmodified from `_updateSwapCallbackData`. Therefore,\n            // it is at least 40 bytes long.\n        }\n        uint256 sellAmount = amount0Delta > 0 ? uint256(amount0Delta) : uint256(amount1Delta);\n        _pay(payer, sellAmount, data);\n    }\n\n    function _pay(address payer, uint256 amount, bytes calldata permit2Data) private {\n        if (payer == address(this)) {\n            IERC20 token;\n            assembly (\"memory-safe\") {\n                token := shr(0x60, calldataload(permit2Data.offset))\n            }\n            token.safeTransfer(msg.sender, amount);\n        } else {\n            assert(payer == address(0));\n            ISignatureTransfer.PermitTransferFrom calldata permit;\n            bool isForwarded;\n            bytes calldata sig;\n            assembly (\"memory-safe\") {\n                // this is super dirty, but it works because although `permit` is aliasing in the\n                // middle of `payer`, because `payer` is all zeroes, it's treated as padding for the\n                // first word of `permit`, which is the sell token\n                permit := sub(permit2Data.offset, 0x0c)\n                isForwarded := and(0x01, calldataload(add(0x55, permit2Data.offset)))\n                sig.offset := add(0x75, permit2Data.offset)\n                sig.length := sub(permit2Data.length, 0x75)\n            }\n            ISignatureTransfer.SignatureTransferDetails memory transferDetails =\n                ISignatureTransfer.SignatureTransferDetails({to: msg.sender, requestedAmount: amount});\n            _transferFrom(permit, transferDetails, sig, isForwarded);\n        }\n    }\n}\n\n// src/core/Basic.sol\n\nabstract contract Basic is SettlerAbstract {\n    using UnsafeMath for uint256;\n    using SafeTransferLib for IERC20;\n    using FullMath for uint256;\n    using Revert for bool;\n\n    /// @dev Sell to a pool with a generic approval, transferFrom interaction.\n    /// offset in the calldata is used to update the sellAmount given a proportion of the sellToken balance\n    function basicSellToPool(IERC20 sellToken, uint256 bps, address pool, uint256 offset, bytes memory data) internal {\n        if (_isRestrictedTarget(pool)) {\n            assembly (\"memory-safe\") {\n                mstore(0x00, 0xe758b8d5) // selector for `ConfusedDeputy()`\n                revert(0x1c, 0x04)\n            }\n        }\n\n        bool success;\n        bytes memory returnData;\n        uint256 value;\n        if (sellToken == ETH_ADDRESS) {\n            value = (address(this).balance * bps).unsafeDiv(BASIS);\n            if (data.length == 0) {\n                if (offset != 0) revert InvalidOffset();\n                (success, returnData) = payable(pool).call{value: value}(\"\");\n                success.maybeRevert(returnData);\n                return;\n            } else {\n                if ((offset += 32) > data.length) {\n                    Panic.panic(Panic.ARRAY_OUT_OF_BOUNDS);\n                }\n                assembly (\"memory-safe\") {\n                    mstore(add(data, offset), value)\n                }\n            }\n        } else if (address(sellToken) == address(0)) {\n            // TODO: check for zero `bps`\n            if (offset != 0) revert InvalidOffset();\n        } else {\n            uint256 amount = sellToken.fastBalanceOf(address(this)).mulDiv(bps, BASIS);\n            if ((offset += 32) > data.length) {\n                Panic.panic(Panic.ARRAY_OUT_OF_BOUNDS);\n            }\n            assembly (\"memory-safe\") {\n                mstore(add(data, offset), amount)\n            }\n            if (address(sellToken) != pool) {\n                sellToken.safeApproveIfBelow(pool, amount);\n            }\n        }\n        (success, returnData) = payable(pool).call{value: value}(data);\n        success.maybeRevert(returnData);\n        // forbid sending data to EOAs\n        if (returnData.length == 0 && pool.code.length == 0) revert InvalidTarget();\n    }\n}\n\n// src/core/Velodrome.sol\n\n//import {Panic} from \"../utils/Panic.sol\";\n\ninterface IVelodromePair {\n    function metadata()\n        external\n        view\n        returns (\n            uint256 basis0,\n            uint256 basis1,\n            uint256 reserve0,\n            uint256 reserve1,\n            bool stable,\n            IERC20 token0,\n            IERC20 token1\n        );\n    function swap(uint256 amount0Out, uint256 amount1Out, address to, bytes calldata data) external;\n}\n\nabstract contract Velodrome is SettlerAbstract {\n    using Math_0 for uint256;\n    using UnsafeMath for uint256;\n    using FastLogic for bool;\n    using FullMath for uint256;\n    using SafeTransferLib for IERC20;\n\n    // This is the basis used for token balances. The original token may have fewer decimals, in\n    // which case we scale up by the appropriate factor to give this basis.\n    uint256 internal constant _VELODROME_TOKEN_BASIS = 1 ether;\n\n    // When computing `k`, to minimize rounding error, we use a significantly larger basis. This\n    // also allows us to save work in the Newton-Raphson step because dividing a quantity with this\n    // basis by a quantity with `_VELODROME_TOKEN_BASIS` basis gives that same\n    // `_VELODROME_TOKEN_BASIS` basis. Convenient *and* accurate.\n    uint256 private constant _VELODROME_INTERNAL_BASIS = _VELODROME_TOKEN_BASIS * _VELODROME_TOKEN_BASIS;\n\n    uint256 private constant _VELODROME_INTERNAL_TO_TOKEN_RATIO = _VELODROME_INTERNAL_BASIS / _VELODROME_TOKEN_BASIS;\n\n    // When computing `d` we need to compute the cube of a token quantity and format the result with\n    // `_VELODROME_TOKEN_BASIS`. In order to avoid overflow, we must divide the squared token\n    // quantity by this before multiplying again by the token quantity. Setting this value as small\n    // as possible preserves precision. This gives a result in an awkward basis, but we'll correct\n    // that with `_VELODROME_CUBE_STEP_BASIS` after the cubing\n    uint256 private constant _VELODROME_SQUARE_STEP_BASIS = 216840435;\n\n    // After squaring a token quantity (in `_VELODROME_TOKEN_BASIS`), we need to multiply again by a\n    // token quantity and then divide out the awkward basis to get back to\n    // `_VELODROME_TOKEN_BASIS`. This constant is what gets us back to the original token quantity\n    // basis. `_VELODROME_TOKEN_BASIS * _VELODROME_TOKEN_BASIS / _VELODROME_SQUARE_STEP_BASIS *\n    // _VELODROME_TOKEN_BASIS / _VELODROME_CUBE_STEP_BASIS == _VELODROME_TOKEN_BASIS`\n    uint256 private constant _VELODROME_CUBE_STEP_BASIS = 4611686007731906643703237360;\n\n    // The maximum balance in the AMM's reference implementation of `k` is `b` such that `(b * b) /\n    // 1 ether * ((b * b) / 1 ether + (b * b) / 1 ether)` does not overflow. This that quantity,\n    // `b`. This is roughly 15.5 billion ether.\n    uint256 internal constant _VELODROME_MAX_BALANCE = 15511800964685064948225197537;\n\n    // This is the `k = x^3 * y + y^3 * x` constant function. Unlike the original formulation, the\n    // result has a basis of `_VELODROME_INTERNAL_BASIS` instead of `_VELODROME_TOKEN_BASIS`\n    function _k(uint256 x, uint256 y) private pure returns (uint256) {\n        unchecked {\n            return _k(x, y, x * x);\n        }\n    }\n\n    function _k(uint256 x, uint256 y, uint256 x_squared) private pure returns (uint256) {\n        unchecked {\n            return _k(x, y, x_squared, y * y);\n        }\n    }\n\n    function _k(uint256 x, uint256 y, uint256 x_squared, uint256 y_squared) private pure returns (uint256) {\n        unchecked {\n            return (x * y).unsafeMulDivAlt(x_squared + y_squared, _VELODROME_INTERNAL_BASIS);\n        }\n    }\n\n    function _k_compat(uint256 x, uint256 y) internal pure returns (uint256) {\n        unchecked {\n            return (x * y).unsafeMulDivAlt(x * x + y * y, _VELODROME_INTERNAL_BASIS * _VELODROME_TOKEN_BASIS);\n        }\n    }\n\n    function _k_compat(uint256 x, uint256 y, uint256 x_squared) private pure returns (uint256) {\n        unchecked {\n            return (x * y).unsafeMulDivAlt(x_squared + y * y, _VELODROME_INTERNAL_BASIS * _VELODROME_TOKEN_BASIS);\n        }\n    }\n\n    // For numerically approximating a solution to the `k = x^3 * y + y^3 * x` constant function\n    // using Newton-Raphson, this is `∂k/∂y = 3 * x * y^2 + x^3`. The result has a basis of\n    // `_VELODROME_TOKEN_BASIS`.\n    function _d(uint256 y, uint256 x) private pure returns (uint256) {\n        unchecked {\n            return _d(y, 3 * x, x * x / _VELODROME_SQUARE_STEP_BASIS * x);\n        }\n    }\n\n    function _d(uint256 y, uint256 three_x, uint256 x_cubed) private pure returns (uint256) {\n        unchecked {\n            return _d(y, three_x, x_cubed, y * y / _VELODROME_SQUARE_STEP_BASIS);\n        }\n    }\n\n    function _d(uint256, uint256 three_x, uint256 x_cubed, uint256 y_squared) private pure returns (uint256) {\n        unchecked {\n            return (y_squared * three_x + x_cubed) / _VELODROME_CUBE_STEP_BASIS;\n        }\n    }\n\n    // Using Newton-Raphson iterations, compute the smallest `new_y` such that `_k(x + dx, new_y) >=\n    // _k(x, y)`. As a function of `new_y`, we find the root of `_k(x + dx, new_y) - _k(x, y)`.\n    function _get_y(uint256 x, uint256 dx, uint256 y) internal pure returns (uint256) {\n        unchecked {\n            uint256 k_orig = _k(x, y);\n            // `k_orig` has a basis much greater than is actually required for correctness. To\n            // achieve wei-level accuracy, we perform our final comparisons agains `k_target`\n            // instead, which has the same precision as the AMM itself.\n            uint256 k_target = _k_compat(x, y);\n\n            // Now that we have `k` computed, we offset `x` to account for the sell amount and use\n            // the constant-product formula to compute an initial estimate for `y`.\n            x += dx;\n            y -= (dx * y).unsafeDiv(x);\n\n            // These intermediate values do not change throughout the Newton-Raphson iterations, so\n            // precomputing and caching them saves us gas.\n            uint256 three_x = 3 * x;\n            uint256 x_squared_raw = x * x;\n            uint256 x_cubed_raw = x_squared_raw / _VELODROME_SQUARE_STEP_BASIS * x;\n\n            for (uint256 i; i < 255; i++) {\n                uint256 y_squared_raw = y * y;\n                uint256 k = _k(x, y, x_squared_raw, y_squared_raw);\n                uint256 d = _d(y, three_x, x_cubed_raw, y_squared_raw / _VELODROME_SQUARE_STEP_BASIS);\n\n                // This would exactly solve *OUR* formulation of the `k=x^3*y+y^3*x` constant\n                // function. However, not only is it computationally and contract-size expensive, it\n                // also does not necessarily exactly satisfy the *REFERENCE* implementations of the\n                // same constant function (SolidlyV1, VelodromeV2). Therefore, it is commented out\n                // and the relevant condition is handled by the \"ordinary\" parts of the\n                // Newton-Raphson loop.\n                /* if (k / _VELODROME_INTERNAL_TO_TOKEN_RATIO == k_target) {\n                    uint256 hi = y;\n                    uint256 lo = y - 1;\n                    uint256 k_next = _k_compat(x, lo, x_squared_raw);\n                    while (k_next == k_target) {\n                        (hi, lo) = (lo, lo - (hi - lo) * 2);\n                        k_next = _k_compat(x, lo, x_squared_raw);\n                    }\n                    while (hi != lo) {\n                        uint256 mid = (hi - lo) / 2 + lo;\n                        k_next = _k_compat(x, mid, x_squared_raw);\n                        if (k_next == k_target) {\n                            hi = mid;\n                        } else {\n                            lo = mid + 1;\n                        }\n                    }\n                    return lo;\n                } else */ if (k < k_orig) {\n                    uint256 dy = (k_orig - k).unsafeDiv(d);\n                    // There are two cases where `dy == 0`\n                    // Case 1: The `y` is converged and we find the correct answer\n                    // Case 2: `_d(y, x)` is too large compare to `(k_orig - k)` and the rounding\n                    //         error screwed us.\n                    //         In this case, we need to increase `y` by 1\n                    if (dy == 0) {\n                        if (_k_compat(x, y + 1, x_squared_raw) >= k_target) {\n                            // If `_k(x, y + 1) >= k_orig`, then we are close to the correct answer.\n                            // There's no closer answer than `y + 1`\n                            return y + 1;\n                        }\n                        // `y + 1` does not give us the condition `k >= k_orig`, so we have to do at\n                        // least 1 more iteration to find a satisfactory `y` value. Setting `dy = y\n                        // / 2` also solves the problem where the constant-product estimate of `y`\n                        // is very bad and convergence is only linear.\n                        dy = y / 2;\n                    }\n                    y += dy;\n                    if (y > _VELODROME_MAX_BALANCE) {\n                        y = _VELODROME_MAX_BALANCE;\n                    }\n                } else {\n                    uint256 dy = (k - k_orig).unsafeDiv(d);\n                    if (dy == 0) {\n                        if (_k_compat(x, y - 1, x_squared_raw) < k_target) {\n                            // If `_k(x, y - 1) < k_orig`, then we are close to the correct answer.\n                            // There's no closer answer than `y`. We need to find `y` where `_k(x,\n                            // y) >= k_orig`. As a result, we can't return `y - 1` even it's closer\n                            // to the correct answer\n                            return y;\n                        }\n                        if (_k(x, y - 2, x_squared_raw) < k_orig) {\n                            // It may be the case that all 3 of `y`, `y - 1`, and `y - 2` give the\n                            // same value for `_k_compat`, but that `y - 2` gives a value for `_k`\n                            // that brackets `k_orig`. In this case, we would loop forever. This\n                            // branch causes us to bail out with the approximately correct value.\n                            return y - 1;\n                        }\n                        // It's possible that `y - 1` is the correct answer. To know that, we must\n                        // check that `y - 2` gives `k < k_orig`. We must do at least 1 more\n                        // iteration to determine this.\n                        dy = 2;\n                    }\n                    if (dy > y / 2) {\n                        dy = y / 2;\n                    }\n                    y -= dy;\n                }\n            }\n            assembly (\"memory-safe\") {\n                mstore(0x00, 0x481b61af) // selector for `NotConverged()`\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    function sellToVelodrome(address recipient, uint256 bps, IVelodromePair pair, uint24 swapInfo, uint256 minAmountOut)\n        internal\n    {\n        // Preventing calls to Permit2 or AH is not explicitly required as neither of these contracts implement the `swap` nor `transfer` selector\n\n        // |7|6|5|4|3|2|1|0| - bit positions in swapInfo (uint8)\n        // |0|0|0|0|0|0|F|Z| - Z: zeroForOne flag, F: sellTokenHasFee flag\n        bool zeroForOne = (swapInfo & 1) == 1; // Extract the least significant bit (bit 0)\n        bool sellTokenHasFee = (swapInfo & 2) >> 1 == 1; // Extract the second least significant bit (bit 1) and shift it right\n        uint256 feeBps = swapInfo >> 8;\n\n        (\n            uint256 sellBasis,\n            uint256 buyBasis,\n            uint256 sellReserve,\n            uint256 buyReserve,\n            bool stable,\n            IERC20 sellToken,\n            IERC20 buyToken\n        ) = pair.metadata();\n        assert(stable);\n        if (!zeroForOne) {\n            (sellBasis, buyBasis, sellReserve, buyReserve, sellToken, buyToken) =\n                (buyBasis, sellBasis, buyReserve, sellReserve, buyToken, sellToken);\n        }\n\n        uint256 buyAmount;\n        unchecked {\n            // Compute sell amount in native units\n            uint256 sellAmount;\n            if (bps != 0) {\n                // It must be possible to square the sell token balance of the pool, otherwise it\n                // will revert with an overflow. Therefore, it can't be so large that multiplying by\n                // a \"reasonable\" `bps` value could overflow. We don't care to protect against\n                // unreasonable `bps` values because that just means the taker is griefing themself.\n                sellAmount = (sellToken.fastBalanceOf(address(this)) * bps).unsafeDiv(BASIS);\n            }\n            if (sellAmount != 0) {\n                sellToken.safeTransfer(address(pair), sellAmount);\n            }\n            if ((sellAmount == 0).or(sellTokenHasFee)) {\n                sellAmount = sellToken.fastBalanceOf(address(pair)) - sellReserve;\n            }\n\n            // Convert reserves from native units to `_VELODROME_TOKEN_BASIS`\n            sellReserve = (sellReserve * _VELODROME_TOKEN_BASIS).unsafeDiv(sellBasis);\n            buyReserve = (buyReserve * _VELODROME_TOKEN_BASIS).unsafeDiv(buyBasis);\n\n            // This check is commented because values that are too large will\n            // result in reverts inside the pool anyways. We don't need to\n            // bother.\n            /*\n            // Check for overflow\n            if (buyReserve > _VELODROME_MAX_BALANCE) {\n                Panic.panic(Panic.ARITHMETIC_OVERFLOW);\n            }\n            if (sellReserve + (sellAmount * _VELODROME_TOKEN_BASIS).unsafeDiv(sellBasis) > _VELODROME_MAX_BALANCE) {\n                Panic.panic(Panic.ARITHMETIC_OVERFLOW);\n            }\n            */\n\n            // Apply the fee in native units\n            sellAmount -= sellAmount * feeBps / 10_000; // can't overflow\n            // Convert sell amount from native units to `_VELODROME_TOKEN_BASIS`\n            sellAmount = (sellAmount * _VELODROME_TOKEN_BASIS).unsafeDiv(sellBasis);\n\n            // Solve the constant function numerically to get `buyAmount` from `sellAmount`\n            buyAmount = buyReserve - _get_y(sellReserve, sellAmount, buyReserve);\n\n            // Convert `buyAmount` from `_VELODROME_TOKEN_BASIS` to native units\n            buyAmount = buyAmount * buyBasis / _VELODROME_TOKEN_BASIS;\n        }\n\n        // Compensate for rounding error in the reference implementation of the constant-function\n        buyAmount--;\n        buyAmount.dec((sellReserve < sellBasis).or(buyReserve < buyBasis));\n\n        // Check slippage\n        if (buyAmount < minAmountOut) {\n            revertTooMuchSlippage(sellToken, minAmountOut, buyAmount);\n        }\n\n        // Perform the swap\n        {\n            (uint256 buyAmount0, uint256 buyAmount1) = zeroForOne ? (uint256(0), buyAmount) : (buyAmount, uint256(0));\n            pair.swap(buyAmount0, buyAmount1, recipient, new bytes(0));\n        }\n    }\n}\n\n// src/core/BalancerV3.sol\n\ninterface IBalancerV3Vault {\n    /**\n     * @notice Creates a context for a sequence of operations (i.e., \"unlocks\" the Vault).\n     * @dev Performs a callback on msg.sender with arguments provided in `data`. The Callback is `transient`,\n     * meaning all balances for the caller have to be settled at the end.\n     *\n     * @param data Contains function signature and args to be passed to the msg.sender\n     * @return result Resulting data from the call\n     */\n    function unlock(bytes calldata data) external returns (bytes memory);\n\n    /**\n     * @notice Settles deltas for a token; must be successful for the current lock to be released.\n     * @dev Protects the caller against leftover dust in the Vault for the token being settled. The caller\n     * should know in advance how many tokens were paid to the Vault, so it can provide it as a hint to discard any\n     * excess in the Vault balance.\n     *\n     * If the given hint is equal to or higher than the difference in reserves, the difference in reserves is given as\n     * credit to the caller. If it's higher, the caller sent fewer tokens than expected, so settlement would fail.\n     *\n     * If the given hint is lower than the difference in reserves, the hint is given as credit to the caller.\n     * In this case, the excess would be absorbed by the Vault (and reflected correctly in the reserves), but would\n     * not affect settlement.\n     *\n     * The credit supplied by the Vault can be calculated as `min(reserveDifference, amountHint)`, where the reserve\n     * difference equals current balance of the token minus existing reserves of the token when the function is called.\n     *\n     * @param token Address of the token\n     * @param amountHint Amount paid as reported by the caller\n     * @return credit Credit received in return of the payment\n     */\n    function settle(IERC20 token, uint256 amountHint) external returns (uint256 credit);\n\n    /**\n     * @notice Sends tokens to a recipient.\n     * @dev There is no inverse operation for this function. Transfer funds to the Vault and call `settle` to cancel\n     * debts.\n     *\n     * @param token Address of the token\n     * @param to Recipient address\n     * @param amount Amount of tokens to send\n     */\n    function sendTo(IERC20 token, address to, uint256 amount) external;\n\n    enum SwapKind {\n        EXACT_IN,\n        EXACT_OUT\n    }\n\n    /**\n     * @notice Data passed into primary Vault `swap` operations.\n     * @param kind Type of swap (Exact In or Exact Out)\n     * @param pool The pool with the tokens being swapped\n     * @param tokenIn The token entering the Vault (balance increases)\n     * @param tokenOut The token leaving the Vault (balance decreases)\n     * @param amountGiven Amount specified for tokenIn or tokenOut (depending on the type of swap)\n     * @param limit Minimum or maximum value of the calculated amount (depending on the type of swap)\n     * @param userData Additional (optional) user data\n     */\n    struct VaultSwapParams {\n        SwapKind kind;\n        address pool;\n        IERC20 tokenIn;\n        IERC20 tokenOut;\n        uint256 amountGiven;\n        uint256 limit;\n        bytes userData;\n    }\n\n    /**\n     * @notice Swaps tokens based on provided parameters.\n     * @dev All parameters are given in raw token decimal encoding.\n     * @param vaultSwapParams Parameters for the swap (see above for struct definition)\n     * @return amountCalculated Calculated swap amount\n     * @return amountIn Amount of input tokens for the swap\n     * @return amountOut Amount of output tokens from the swap\n     */\n    function swap(VaultSwapParams memory vaultSwapParams)\n        external\n        returns (uint256 amountCalculated, uint256 amountIn, uint256 amountOut);\n\n    enum WrappingDirection {\n        WRAP,\n        UNWRAP\n    }\n\n    /**\n     * @notice Data for a wrap/unwrap operation.\n     * @param kind Type of swap (Exact In or Exact Out)\n     * @param direction Direction of the wrapping operation (Wrap or Unwrap)\n     * @param wrappedToken Wrapped token, compatible with interface ERC4626\n     * @param amountGiven Amount specified for tokenIn or tokenOut (depends on the type of swap and wrapping direction)\n     * @param limit Minimum or maximum amount specified for the other token (depends on the type of swap and wrapping\n     * direction)\n     */\n    struct BufferWrapOrUnwrapParams {\n        SwapKind kind;\n        WrappingDirection direction;\n        IERC4626 wrappedToken;\n        uint256 amountGiven;\n        uint256 limit;\n    }\n\n    /**\n     * @notice Wraps/unwraps tokens based on the parameters provided.\n     * @dev All parameters are given in raw token decimal encoding. It requires the buffer to be initialized,\n     * and uses the internal wrapped token buffer when it has enough liquidity to avoid external calls.\n     *\n     * @param params Parameters for the wrap/unwrap operation (see struct definition)\n     * @return amountCalculated Calculated swap amount\n     * @return amountIn Amount of input tokens for the swap\n     * @return amountOut Amount of output tokens from the swap\n     */\n    function erc4626BufferWrapOrUnwrap(BufferWrapOrUnwrapParams memory params)\n        external\n        returns (uint256 amountCalculated, uint256 amountIn, uint256 amountOut);\n}\n\nlibrary UnsafeVault {\n    function unsafeSettle(IBalancerV3Vault vault, IERC20 token, uint256 amount) internal returns (uint256 credit) {\n        assembly (\"memory-safe\") {\n            mstore(0x14, token)\n            mstore(0x34, amount) // clobbers the upper (always zero) bits of the free memory pointer\n            mstore(0x00, 0x15afd409000000000000000000000000) // selector for `settle(address,uint256)` with `token`'s padding\n\n            if iszero(call(gas(), vault, 0x00, 0x10, 0x44, 0x00, 0x20)) {\n                let ptr := and(0xffffffffffffffffffffffff, mload(0x40))\n                returndatacopy(ptr, 0x00, returndatasize())\n                revert(ptr, returndatasize())\n            }\n            credit := mload(0x00)\n\n            mstore(0x34, 0x00)\n        }\n    }\n\n    function unsafeSwap(IBalancerV3Vault vault, IBalancerV3Vault.VaultSwapParams memory params)\n        internal\n        returns (uint256 amountIn, uint256 amountOut)\n    {\n        assembly (\"memory-safe\") {\n            // `VaultSwapParams` is a dynamic type with exactly 1 sub-object, and that sub-object is\n            // dynamic (all the other members are value types). Therefore, the layout in calldata is\n            // nearly identical to the layout in memory, but there's an extra indirection offset\n            // that needs to be prepended. Also the pointer to `params.userData` needs to be\n            // transformed into an offset relative to the start of `params`.\n            // We know that it's safe to (temporarily) clobber the two words in memory immediately\n            // before `params` because they are user-allocated (they're part of `wrapParams`). If\n            // they were not user-allocated, this would be illegal as it could clobber a word that\n            // `solc` spilled from the stack into memory.\n\n            let ptr := mload(0x40)\n            let clobberedPtr0 := sub(params, 0x40)\n            let clobberedVal0 := mload(clobberedPtr0)\n            let clobberedPtr1 := sub(params, 0x20)\n            let clobberedVal1 := mload(clobberedPtr1)\n\n            mstore(clobberedPtr0, 0x2bfb780c) // selector for `swap((uint8,address,address,address,uint256,uint256,bytes))`\n            mstore(clobberedPtr1, 0x20) // indirection offset to the dynamic type `VaultSwapParams`\n\n            // Because we laid out `swapParams` as the last object in memory before\n            // `swapParam.userData`, the two objects are contiguous. Their encoding in calldata is\n            // exactly the same as their encoding in memory, but with pointers changed to offsets.\n            let userDataPtr := add(0xc0, params)\n            let userData := mload(userDataPtr)\n            let userDataLen := mload(userData)\n            // Convert the pointer `userData` into an offset relative to the start of its parent\n            // object (`params`), and replace it in memory to transform it to the calldata encoding\n            let len := sub(userData, params)\n            mstore(userDataPtr, len)\n            // Compute the length of the entire encoded object\n            len := add(0x20, add(userDataLen, len))\n            // The padding is a little wonky (we're not creating the Solidity-strict ABI encoding),\n            // but the Solidity ABIDecoder is relaxed enough that this doesn't matter.\n\n            // The length of the whole call's calldata is 36 bytes longer than the encoding of\n            // `params` in memory to account for the prepending of the selector (4 bytes) and the\n            // indirection offset (32 bytes)\n            if iszero(call(gas(), vault, 0x00, add(0x1c, clobberedPtr0), add(0x24, len), 0x00, 0x60)) {\n                returndatacopy(ptr, 0x00, returndatasize())\n                revert(ptr, returndatasize())\n            }\n            amountIn := mload(0x20)\n            amountOut := mload(0x40)\n\n            // mstore(userDataPtr, userData) // we don't need this because we're immediately going to deallocate\n            mstore(clobberedPtr0, clobberedVal0)\n            mstore(clobberedPtr1, clobberedVal1)\n            mstore(0x40, ptr)\n        }\n    }\n\n    function unsafeErc4626BufferWrapOrUnwrap(\n        IBalancerV3Vault vault,\n        IBalancerV3Vault.BufferWrapOrUnwrapParams memory params\n    ) internal returns (uint256 amountIn, uint256 amountOut) {\n        assembly (\"memory-safe\") {\n            // `BufferWrapOrUnwrapParams` is a static type and contains no sub-objects (all its\n            // members are value types), so the layout in calldata is just the layout in memory,\n            // without any indirection.\n            // We know that it's safe to (temporarily) clobber the word in memory immediately before\n            // `params` because it is user-allocated (it's part of the `Notes` heap). If it were not\n            // user-allocated, this would be illegal as it could clobber a word that `solc` spilled\n            // from the stack into memory.\n\n            let ptr := mload(0x40)\n            let clobberedPtr := sub(params, 0x20)\n            let clobberedVal := mload(clobberedPtr)\n            mstore(clobberedPtr, 0x43583be5) // selector for `erc4626BufferWrapOrUnwrap((uint8,uint8,address,uint256,uint256))`\n\n            if iszero(call(gas(), vault, 0x00, add(0x1c, clobberedPtr), 0xa4, 0x00, 0x60)) {\n                returndatacopy(ptr, 0x00, returndatasize())\n                revert(ptr, returndatasize())\n            }\n            amountIn := mload(0x20)\n            amountOut := mload(0x40)\n\n            mstore(clobberedPtr, clobberedVal)\n            mstore(0x40, ptr)\n        }\n    }\n}\n\nIBalancerV3Vault constant VAULT = IBalancerV3Vault(0xbA1333333333a1BA1108E8412f11850A5C319bA9);\n\nabstract contract BalancerV3 is SettlerAbstract, FreeMemory {\n    using SafeTransferLib for IERC20;\n    using UnsafeMath for uint256;\n    using NotesLib for NotesLib.Note[];\n\n    using UnsafeVault for IBalancerV3Vault;\n\n    constructor() {\n        assert(BASIS == Encoder.BASIS);\n        assert(BASIS == Decoder.BASIS);\n        assert(ETH_ADDRESS == Decoder.ETH_ADDRESS);\n    }\n\n    //// How to generate `fills` for BalancerV3:\n    ////\n    //// Linearize your DAG of fills by doing a topological sort on the tokens involved. Swapping\n    //// against a boosted pool (usually) creates 3 fills: wrap, swap, unwrap. The tokens involved\n    //// includes each ERC4626 tokenized vault token for any boosted pools. In the topological sort\n    //// of tokens, when there is a choice of the next token, break ties by preferring a token if it\n    //// is the lexicographically largest token that is bought among fills with sell token equal to\n    //// the previous token in the topological sort. Then sort the fills belonging to each sell\n    //// token by their buy token. This technique isn't *quite* optimal, but it's pretty close. The\n    //// buy token of the final fill is special-cased. It is the token that will be transferred to\n    //// `recipient` and have its slippage checked against `amountOutMin`. In the event that you are\n    //// encoding a series of fills with more than one output token, ensure that at least one of the\n    //// global buy token's fills is positioned appropriately.\n    ////\n    //// Now that you have a list of fills, encode each fill as follows.\n    //// First, decide if the fill is a swap or an ERC4626 wrap/unwrap.\n    //// Second, encode the `bps` for the fill as 2 bytes. Remember that this `bps` is relative to\n    //// the running balance at the moment that the fill is settled. If the fill is a wrap, set the\n    //// most significant bit of `bps`. If the fill is an unwrap, set the second most significant\n    //// bit of `bps`\n    //// Third, encode the packing key for that fill as 1 byte. The packing key byte depends on the\n    //// tokens involved in the previous fill. If the fill is a wrap, the buy token must be the\n    //// ERC4626 vault. If the fill is an unwrap, the sell token must be the ERC4626 vault. If the\n    //// fill is a swap against a boosted pool, both sell and buy tokens must be ERC4626 vaults. God\n    //// help you if you're dealing with a boosted pool where only some of the tokens involved are\n    //// ERC4626. The packing key for the first fill must be 1; i.e. encode only the buy token for\n    //// the first fill.\n    ////   0 -> sell and buy tokens remain unchanged from the previous fill (pure multiplex)\n    ////   1 -> sell token remains unchanged from the previous fill, buy token is encoded (diamond multiplex)\n    ////   2 -> sell token becomes the buy token from the previous fill, new buy token is encoded (multihop)\n    ////   3 -> both sell and buy token are encoded\n    //// Obviously, after encoding the packing key, you encode 0, 1, or 2 tokens (each as 20 bytes),\n    //// as appropriate.\n    //// If the fill is a wrap/unwrap, you're done. Move on to the next fill. If the fill is a swap,\n    //// the following fields are mandatory:\n    //// Fourth, encode the pool address as 20 bytes.\n    //// Fifth, encode the hook data for the fill. Encode the length of the hook data as 3 bytes,\n    //// then append the hook data itself.\n    ////\n    //// Repeat the process for each fill and concatenate the results without padding.\n\n    function sellToBalancerV3(\n        address recipient,\n        IERC20 sellToken,\n        uint256 bps,\n        bool feeOnTransfer,\n        uint256 hashMul,\n        uint256 hashMod,\n        bytes memory fills,\n        uint256 amountOutMin\n    ) internal returns (uint256 buyAmount) {\n        if (bps > BASIS) {\n            Panic.panic(Panic.ARITHMETIC_OVERFLOW);\n        }\n        bytes memory data = Encoder.encode(\n            uint32(IBalancerV3Vault.unlock.selector),\n            recipient,\n            sellToken,\n            bps,\n            feeOnTransfer,\n            hashMul,\n            hashMod,\n            fills,\n            amountOutMin\n        );\n        // If, for some insane reason, the first 4 bytes of `recipient` alias the selector for the\n        // only mutative function of Settler (`execute` or `executeMetaTxn`, as appropriate), then\n        // this call will revert. We will encounter a revert in the nested call to\n        // `execute`/`executeMetaTxn` because Settler is reentrancy-locked (this revert is\n        // bubbled). If, instead, it aliases a non-mutative function of Settler, we would encounter\n        // a revert inside `TransientStorage.checkSpentOperatorAndCallback` because the transient\n        // storage slot was not zeroed. This would happen by accident with negligible probability,\n        // and is merely annoying if it does happen.\n        bytes memory encodedBuyAmount =\n            _setOperatorAndCall(address(VAULT), data, uint32(uint256(uint160(recipient)) >> 128), _balV3Callback);\n        // buyAmount = abi.decode(abi.decode(encodedBuyAmount, (bytes)), (uint256));\n        assembly (\"memory-safe\") {\n            // We can skip all the checks performed by `abi.decode` because we know that this is the\n            // verbatim result from `balV3UnlockCallback` and that `balV3UnlockCallback` encoded the\n            // buy amount correctly.\n            buyAmount := mload(add(0x60, encodedBuyAmount))\n        }\n    }\n\n    function sellToBalancerV3VIP(\n        address recipient,\n        bool feeOnTransfer,\n        uint256 hashMul,\n        uint256 hashMod,\n        bytes memory fills,\n        ISignatureTransfer.PermitTransferFrom memory permit,\n        bytes memory sig,\n        uint256 amountOutMin\n    ) internal returns (uint256 buyAmount) {\n        bytes memory data = Encoder.encodeVIP(\n            uint32(IBalancerV3Vault.unlock.selector),\n            recipient,\n            feeOnTransfer,\n            hashMul,\n            hashMod,\n            fills,\n            permit,\n            sig,\n            _isForwarded(),\n            amountOutMin\n        );\n        // See comment in `sellToBalancerV3` about why `recipient` aliasing a valid selector is\n        // ultimately harmless.\n        bytes memory encodedBuyAmount =\n            _setOperatorAndCall(address(VAULT), data, uint32(uint256(uint160(recipient)) >> 128), _balV3Callback);\n        // buyAmount = abi.decode(abi.decode(encodedBuyAmount, (bytes)), (uint256));\n        assembly (\"memory-safe\") {\n            // We can skip all the checks performed by `abi.decode` because we know that this is the\n            // verbatim result from `balV3UnlockCallback` and that `balV3UnlockCallback` encoded the\n            // buy amount correctly.\n            buyAmount := mload(add(0x60, encodedBuyAmount))\n        }\n    }\n\n    function _balV3Callback(bytes calldata) private returns (bytes memory) {\n        // `VAULT` doesn't prepend a selector and ABIEncode the payload. It just echoes the decoded\n        // payload verbatim back to us. Therefore, we use `_msgData()` instead of the argument to\n        // this function because `_msgData()` still has the first 4 bytes of the payload attached.\n        return balV3UnlockCallback(_msgData());\n    }\n\n    function _setSwapParams(\n        IBalancerV3Vault.VaultSwapParams memory swapParams,\n        State state,\n        bytes calldata data\n    ) private pure returns (bytes calldata) {\n        assembly (\"memory-safe\") {\n            mstore(add(0x20, swapParams), shr(0x60, calldataload(data.offset)))\n            data.offset := add(0x14, data.offset)\n            data.length := sub(data.length, 0x14)\n            // we don't check for array out-of-bounds here; we will check it later in `Decoder.overflowCheck`\n        }\n        swapParams.tokenIn = state.sell().token();\n        swapParams.tokenOut = state.buy().token();\n        return data;\n    }\n\n    function _decodeUserdataAndSwap(\n        IBalancerV3Vault.VaultSwapParams memory swapParams,\n        State state,\n        bytes calldata data\n    ) private DANGEROUS_freeMemory returns (bytes calldata) {\n        (data, swapParams.userData) = Decoder.decodeBytes(data);\n        Decoder.overflowCheck(data);\n\n        (uint256 amountIn, uint256 amountOut) = IBalancerV3Vault(msg.sender).unsafeSwap(swapParams);\n        unchecked {\n            // `amountIn` is always exactly `swapParams.amountGiven`\n            NotePtr sell = state.sell();\n            sell.setAmount(sell.amount() - amountIn);\n        }\n        // `amountOut` can never get super close to `type(uint256).max` because `VAULT` does its\n        // internal calculations in fixnum with a basis of `1 ether`, giving us a headroom of ~60\n        // bits. However, `state.buy.amount` may be an agglomeration of values returned by ERC4626\n        // vaults, and there is no implicit restriction on those values.\n        NotePtr buy = state.buy();\n        buy.setAmount(buy.amount() + amountOut);\n        assembly (\"memory-safe\") {\n            mstore(add(0xc0, swapParams), 0x60)\n        }\n\n        return data;\n    }\n\n    function _erc4626WrapUnwrap(\n        IBalancerV3Vault.BufferWrapOrUnwrapParams memory wrapParams,\n        State state\n    ) private {\n        (uint256 amountIn, uint256 amountOut) = IBalancerV3Vault(msg.sender).unsafeErc4626BufferWrapOrUnwrap(wrapParams);\n        unchecked {\n            // `amountIn` is always exactly `wrapParams.amountGiven`\n            NotePtr sell = state.sell();\n            sell.setAmount(sell.amount() - amountIn);\n        }\n        // `amountOut` may depend on the behavior of the ERC4626 vault. We can make no assumptions\n        // about the reasonableness of the range of values that may be returned.\n        NotePtr buy = state.buy();\n        buy.setAmount(buy.amount() + amountOut);\n    }\n\n    function _balV3Pay(\n        IERC20 sellToken,\n        address payer,\n        uint256 sellAmount,\n        ISignatureTransfer.PermitTransferFrom calldata permit,\n        bool isForwarded,\n        bytes calldata sig\n    ) private returns (uint256) {\n        if (payer == address(this)) {\n            if (sellAmount != 0) {\n                sellToken.safeTransfer(msg.sender, sellAmount);\n            }\n        } else {\n            // assert(payer == address(0));\n            ISignatureTransfer.SignatureTransferDetails memory transferDetails =\n                ISignatureTransfer.SignatureTransferDetails({to: msg.sender, requestedAmount: sellAmount});\n            _transferFrom(permit, transferDetails, sig, isForwarded);\n        }\n        return IBalancerV3Vault(msg.sender).unsafeSettle(sellToken, sellAmount);\n    }\n\n    // the mandatory fields are\n    // 2 - sell bps\n    // 1 - pool key tokens case\n    uint256 private constant _HOP_DATA_LENGTH = 3;\n\n    function balV3UnlockCallback(bytes calldata data) private returns (bytes memory) {\n        address recipient;\n        uint256 minBuyAmount;\n        uint256 hashMul;\n        uint256 hashMod;\n        bool feeOnTransfer;\n        address payer;\n        (data, recipient, minBuyAmount, hashMul, hashMod, feeOnTransfer, payer) = Decoder.decodeHeader(data);\n\n        // Set up `state` and `notes`. The other values are ancillary and might be used when we need\n        // to settle global sell token debt at the end of swapping.\n        (\n            bytes calldata newData,\n            State state,\n            NotesLib.Note[] memory notes,\n            ISignatureTransfer.PermitTransferFrom calldata permit,\n            bool isForwarded,\n            bytes calldata sig\n        ) = Decoder.initialize(data, hashMul, hashMod, payer);\n        {\n            NotePtr globalSell = state.globalSell();\n            if (payer != address(this)) {\n                globalSell.setAmount(_permitToSellAmountCalldata(permit));\n            }\n            if (feeOnTransfer) {\n                globalSell.setAmount(\n                    _balV3Pay(globalSell.token(), payer, globalSell.amount(), permit, isForwarded, sig)\n                );\n            }\n            state.setGlobalSellAmount(globalSell.amount());\n        }\n        state.checkZeroSellAmount();\n        data = newData;\n\n        IBalancerV3Vault.BufferWrapOrUnwrapParams memory wrapParams;\n        /*\n        wrapParams.kind = IBalancerV3Vault.SwapKind.EXACT_IN;\n        wrapParams.limit = 0; // TODO: price limits for partial filling\n        */\n\n        // We position `swapParams` at the end of allocated memory so that when we `calldatacopy`\n        // the `userData`, it ends up contiguous\n        IBalancerV3Vault.VaultSwapParams memory swapParams;\n        /*\n        swapParams.kind = IBalancerV3Vault.SwapKind.EXACT_IN;\n        swapParams.limit = 0; // TODO: price limits for partial filling\n        */\n\n        while (data.length >= _HOP_DATA_LENGTH) {\n            uint16 bps;\n            assembly (\"memory-safe\") {\n                bps := shr(0xf0, calldataload(data.offset))\n\n                data.offset := add(0x02, data.offset)\n                data.length := sub(data.length, 0x02)\n                // we don't check for array out-of-bounds here; we will check it later in `Decoder.overflowCheck`\n            }\n\n            data = Decoder.updateState(state, notes, data);\n\n            if (bps & 0xc000 == 0) {\n                data = _setSwapParams(swapParams, state, data);\n                unchecked {\n                    swapParams.amountGiven = (state.sell().amount() * bps).unsafeDiv(BASIS);\n                }\n                data = _decodeUserdataAndSwap(swapParams, state, data);\n            } else {\n                Decoder.overflowCheck(data);\n\n                if (bps & 0x4000 == 0) {\n                    wrapParams.direction = IBalancerV3Vault.WrappingDirection.WRAP;\n                    wrapParams.wrappedToken = IERC4626(address(state.buy().token()));\n                } else {\n                    wrapParams.direction = IBalancerV3Vault.WrappingDirection.UNWRAP;\n                    wrapParams.wrappedToken = IERC4626(address(state.sell().token()));\n                }\n                bps &= 0x3fff;\n                unchecked {\n                    wrapParams.amountGiven = (state.sell().amount() * bps).unsafeDiv(BASIS);\n                }\n\n                _erc4626WrapUnwrap(wrapParams, state);\n            }\n        }\n\n        // `data` has been consumed. All that remains is to settle out the net result of all the\n        // swaps. Any credit in any token other than `state.buy.token` will be swept to\n        // Settler. `state.buy.token` will be sent to `recipient`.\n        {\n            NotePtr globalSell = state.globalSell();\n            (IERC20 globalSellToken, uint256 globalSellAmount) = (globalSell.token(), globalSell.amount());\n            uint256 globalBuyAmount =\n                Take.take(state, notes, uint32(IBalancerV3Vault.sendTo.selector), recipient, minBuyAmount);\n            if (feeOnTransfer) {\n                // We've already transferred the sell token to the vault and\n                // `settle`'d. `globalSellAmount` is the verbatim credit in that token stored by the\n                // vault. We only need to handle the case of incomplete filling.\n                if (globalSellAmount != 0) {\n                    Take._callSelector(\n                        uint32(IBalancerV3Vault.sendTo.selector),\n                        globalSellToken,\n                        payer == address(this) ? address(this) : _msgSender(),\n                        globalSellAmount\n                    );\n                }\n            } else {\n                // While `notes` records a credit value, the vault actually records a debt for the\n                // global sell token. We recover the exact amount of that debt and then pay it.\n                // `globalSellAmount` is _usually_ zero, but if it isn't it represents a partial\n                // fill. This subtraction recovers the actual debt recorded in the vault.\n                uint256 debt;\n                unchecked {\n                    debt = state.globalSellAmount() - globalSellAmount;\n                }\n                if (debt == 0) {\n                    assembly (\"memory-safe\") {\n                        mstore(0x14, globalSellToken)\n                        mstore(0x00, 0xfb772a88000000000000000000000000) // selector for `ZeroSellAmount(address)` with `globalSellToken`'s padding\n                        revert(0x10, 0x24)\n                    }\n                }\n                _balV3Pay(globalSellToken, payer, debt, permit, isForwarded, sig);\n            }\n\n            bytes memory returndata;\n            assembly (\"memory-safe\") {\n                returndata := mload(0x40)\n                mstore(returndata, 0x20)\n                mstore(add(0x20, returndata), globalBuyAmount)\n                mstore(0x40, add(0x40, returndata))\n            }\n            return returndata;\n        }\n    }\n}\n\n// src/core/Ekubo.sol\n\ntype Config is bytes32;\n\ntype SqrtRatio is uint96;\n\n// Each pool has its own state associated with this key\nstruct PoolKey {\n    address token0;\n    address token1;\n    Config config;\n}\n\ninterface IEkuboCore {\n    // The entrypoint for all operations on the core contract\n    function lock() external;\n\n    // Swap tokens\n    function swap_611415377(\n        PoolKey memory poolKey,\n        int128 amount,\n        bool isToken1,\n        SqrtRatio sqrtRatioLimit,\n        uint256 skipAhead\n    ) external payable returns (int128 delta0, int128 delta1);\n\n    // Pay for swapped tokens\n    function pay(address token) external returns (uint128 payment);\n\n    // Get swapped tokens\n    function withdraw(address token, address recipient, uint128 amount) external;\n}\n\nIEkuboCore constant CORE = IEkuboCore(0xe0e0e08A6A4b9Dc7bD67BCB7aadE5cF48157d444);\n\n/// @notice Interface for the callback executed when an address locks core\ninterface IEkuboCallbacks {\n    /// @notice Called by Core on `msg.sender` when a lock is acquired\n    /// @param id The id assigned to the action\n    /// @return Any data that you want to be returned from the lock call\n    function locked(uint256 id) external returns (bytes memory);\n\n    /// @notice Called by Core on `msg.sender` to collect assets\n    /// @param id The id assigned to the action\n    /// @param token The token to pay on\n    function payCallback(uint256 id, address token) external;\n}\n\nlibrary UnsafeEkuboCore {\n    /// The `amountSpecified` as well as both `delta`'s are `int256` for contract size savings. If\n    /// `amountSpecified` is not a clean, signed, 128-bit value, the call will revert inside the ABI\n    /// decoding in `CORE`. The `delta`'s are guaranteed clean by the returndata encoding of `CORE`,\n    /// but we keep them as `int256` so as not to duplicate any work.\n    ///\n    /// The `skipAhead` argument of the underlying `swap` function is hardcoded to zero.\n    function unsafeSwap(\n        IEkuboCore core,\n        PoolKey memory poolKey,\n        int256 amount,\n        bool isToken1,\n        SqrtRatio sqrtRatioLimit\n    ) internal returns (int256 delta0, int256 delta1) {\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40)\n\n            mstore(ptr, 0x00000000) // selector for `swap_611415377((address,address,bytes32),int128,bool,uint96,uint256)`\n            let poolKeyPtr := add(0x20, ptr)\n            mcopy(poolKeyPtr, poolKey, 0x60)\n            let token0 := mload(poolKeyPtr)\n            mstore(poolKeyPtr, mul(iszero(eq(0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee, token0)), token0))\n            // ABI decoding in Ekubo will check if amount fits in int128\n            mstore(add(0x80, ptr), amount)\n            mstore(add(0xa0, ptr), isToken1)\n            mstore(add(0xc0, ptr), and(0xffffffffffffffffffffffff, sqrtRatioLimit))\n            mstore(add(0xe0, ptr), 0x00)\n\n            if iszero(call(gas(), core, 0x00, add(0x1c, ptr), 0xe4, 0x00, 0x40)) {\n                returndatacopy(ptr, 0x00, returndatasize())\n                revert(ptr, returndatasize())\n            }\n            // Ekubo CORE returns data properly no need to mask\n            delta0 := mload(0x00)\n            delta1 := mload(0x20)\n        }\n    }\n}\n\nabstract contract Ekubo is SettlerAbstract {\n    using UnsafeMath for uint256;\n    using FullMath for uint256;\n    using UnsafeMath for int256;\n    using CreditDebt for int256;\n    using Ternary for bool;\n    using SafeTransferLib for IERC20;\n    using NotesLib for NotesLib.Note[];\n    using UnsafeEkuboCore for IEkuboCore;\n\n    constructor() {\n        assert(BASIS == Encoder.BASIS);\n        assert(BASIS == Decoder.BASIS);\n        assert(ETH_ADDRESS == Decoder.ETH_ADDRESS);\n    }\n\n    //// How to generate `fills` for Ekubo\n    ////\n    //// Linearize your DAG of fills by doing a topological sort on the tokens involved. In the\n    //// topological sort of tokens, when there is a choice of the next token, break ties by\n    //// preferring a token if it is the lexicographically largest token that is bought among fills\n    //// with sell token equal to the previous token in the topological sort. Then sort the fills\n    //// belonging to each sell token by their buy token. This technique isn't *quite* optimal, but\n    //// it's pretty close. The buy token of the final fill is special-cased. It is the token that\n    //// will be transferred to `recipient` and have its slippage checked against `amountOutMin`. In\n    //// the event that you are encoding a series of fills with more than one output token, ensure\n    //// that at least one of the global buy token's fills is positioned appropriately.\n    ////\n    //// Take care to note that while Ekube represents the native asset of the chain as\n    //// the address of all zeroes, Settler represents this as the address of all `e`s. You must use\n    //// Settler's representation. The conversion is performed by Settler before making calls to Ekubo\n    ////\n    //// Now that you have a list of fills, encode each fill as follows.\n    //// First encode the `bps` for the fill as 2 bytes. Remember that this `bps` is relative to the\n    //// running balance at the moment that the fill is settled.\n    //// Second, encode the packing key for that fill as 1 byte. The packing key byte depends on the\n    //// tokens involved in the previous fill. The packing key for the first fill must be 1;\n    //// i.e. encode only the buy token for the first fill.\n    ////   0 -> sell and buy tokens remain unchanged from the previous fill (pure multiplex)\n    ////   1 -> sell token remains unchanged from the previous fill, buy token is encoded (diamond multiplex)\n    ////   2 -> sell token becomes the buy token from the previous fill, new buy token is encoded (multihop)\n    ////   3 -> both sell and buy token are encoded\n    //// Obviously, after encoding the packing key, you encode 0, 1, or 2 tokens (each as 20 bytes),\n    //// as appropriate.\n    //// The remaining fields of the fill are mandatory.\n    //// Third, encode the config of the pool as 32 bytes. It contains pool parameters which are\n    //// 20 bytes extension address, 8 bytes fee, and 4 bytes tickSpacing.\n    ////\n    //// Repeat the process for each fill and concatenate the results without padding.\n\n    function sellToEkubo(\n        address recipient,\n        IERC20 sellToken,\n        uint256 bps,\n        bool feeOnTransfer,\n        uint256 hashMul,\n        uint256 hashMod,\n        bytes memory fills,\n        uint256 amountOutMin\n    ) internal returns (uint256 buyAmount) {\n        if (bps > BASIS) {\n            Panic.panic(Panic.ARITHMETIC_OVERFLOW);\n        }\n        bytes memory data = Encoder.encode(\n            uint32(IEkuboCore.lock.selector),\n            recipient,\n            sellToken,\n            bps,\n            feeOnTransfer,\n            hashMul,\n            hashMod,\n            fills,\n            amountOutMin\n        );\n        bytes memory encodedBuyAmount =\n            _setOperatorAndCall(address(CORE), data, uint32(IEkuboCallbacks.locked.selector), _ekuboLockCallback);\n        // buyAmount = abi.decode(abi.decode(encodedBuyAmount, (bytes)), (uint256));\n        assembly (\"memory-safe\") {\n            // We can skip all the checks performed by `abi.decode` because we know that this is the\n            // verbatim result from `locked` and that `locked` encoded the buy amount\n            // correctly.\n            buyAmount := mload(add(0x60, encodedBuyAmount))\n        }\n    }\n\n    function sellToEkuboVIP(\n        address recipient,\n        bool feeOnTransfer,\n        uint256 hashMul,\n        uint256 hashMod,\n        bytes memory fills,\n        ISignatureTransfer.PermitTransferFrom memory permit,\n        bytes memory sig,\n        uint256 amountOutMin\n    ) internal returns (uint256 buyAmount) {\n        bytes memory data = Encoder.encodeVIP(\n            uint32(IEkuboCore.lock.selector),\n            recipient,\n            feeOnTransfer,\n            hashMul,\n            hashMod,\n            fills,\n            permit,\n            sig,\n            _isForwarded(),\n            amountOutMin\n        );\n        bytes memory encodedBuyAmount =\n            _setOperatorAndCall(address(CORE), data, uint32(IEkuboCallbacks.locked.selector), _ekuboLockCallback);\n        // buyAmount = abi.decode(abi.decode(encodedBuyAmount, (bytes)), (uint256));\n        assembly (\"memory-safe\") {\n            // We can skip all the checks performed by `abi.decode` because we know that this is the\n            // verbatim result from `locked` and that `locked` encoded the buy amount\n            // correctly.\n            buyAmount := mload(add(0x60, encodedBuyAmount))\n        }\n    }\n\n    function _ekuboLockCallback(bytes calldata data) private returns (bytes memory) {\n        // We know that our calldata is well-formed. Therefore, the first slot is ekubo lock id,\n        // second slot is 0x20 and third is the length of the strict ABIEncoded payload\n        assembly (\"memory-safe\") {\n            data.length := calldataload(add(0x40, data.offset))\n            data.offset := add(0x60, data.offset)\n        }\n        return locked(data);\n    }\n\n    function _ekuboPay(\n        IERC20 sellToken,\n        address payer,\n        uint256 sellAmount,\n        ISignatureTransfer.PermitTransferFrom calldata permit,\n        bool isForwarded,\n        bytes calldata sig\n    ) private returns (uint256 payment) {\n        if (sellToken == ETH_ADDRESS) {\n            SafeTransferLib.safeTransferETH(payable(msg.sender), sellAmount);\n            return sellAmount;\n        } else {\n            // Encode the call plus the extra data that is going to be needed in the callback\n            bytes memory data;\n            assembly (\"memory-safe\") {\n                data := mload(0x40)\n\n                mstore(add(0x24, data), sellToken)\n                mstore(add(0x10, data), 0x0c11dedd000000000000000000000000) // selector for pay(address) with padding for token\n\n                mstore(add(0x44, data), sellAmount)\n                let size := 0x44\n\n                // if permit is needed add it to data\n                if iszero(eq(payer, address())) {\n                    // let's skip token and sell amount and reuse the values already in data\n                    calldatacopy(add(0x64, data), add(0x40, permit), 0x40)\n                    mstore(add(0xa4, data), isForwarded)\n                    mstore(add(0xc4, data), sig.length)\n                    calldatacopy(add(0xe4, data), sig.offset, sig.length)\n                    size := add(size, add(0x80, sig.length))\n                }\n\n                // update data length\n                mstore(data, size)\n\n                // update free memory pointer\n                mstore(0x40, add(data, add(0x20, size)))\n            }\n            bytes memory encodedPayedAmount =\n                _setOperatorAndCall(msg.sender, data, uint32(IEkuboCallbacks.payCallback.selector), payCallback);\n            assembly (\"memory-safe\") {\n                // We can skip all the checks performed by `abi.decode` because we know that this is the\n                // verbatim result from `payCallback` and that `payCallback` encoded the payment\n                // correctly.\n                payment := mload(add(0x60, encodedPayedAmount))\n            }\n        }\n    }\n\n    // the mandatory fields are\n    // 2 - sell bps\n    // 1 - pool key tokens case\n    // 32 - config (20 extension, 8 fee, 4 tickSpacing)\n    uint256 private constant _HOP_DATA_LENGTH = 35;\n\n    function locked(bytes calldata data) private returns (bytes memory) {\n        address recipient;\n        uint256 minBuyAmount;\n        uint256 hashMul;\n        uint256 hashMod;\n        bool feeOnTransfer;\n        address payer;\n        (data, recipient, minBuyAmount, hashMul, hashMod, feeOnTransfer, payer) = Decoder.decodeHeader(data);\n\n        // Set up `state` and `notes`. The other values are ancillary and might be used when we need\n        // to settle global sell token debt at the end of swapping.\n        (\n            bytes calldata newData,\n            State state,\n            NotesLib.Note[] memory notes,\n            ISignatureTransfer.PermitTransferFrom calldata permit,\n            bool isForwarded,\n            bytes calldata sig\n        ) = Decoder.initialize(data, hashMul, hashMod, payer);\n        {\n            NotePtr globalSell = state.globalSell();\n            if (payer != address(this)) {\n                globalSell.setAmount(_permitToSellAmountCalldata(permit));\n            }\n            if (feeOnTransfer) {\n                globalSell.setAmount(\n                    _ekuboPay(globalSell.token(), payer, globalSell.amount(), permit, isForwarded, sig)\n                );\n            }\n            if (globalSell.amount() >> 127 != 0) {\n                Panic.panic(Panic.ARITHMETIC_OVERFLOW);\n            }\n            state.setGlobalSellAmount(globalSell.amount());\n        }\n        state.checkZeroSellAmount();\n        data = newData;\n\n        PoolKey memory poolKey;\n\n        while (data.length >= _HOP_DATA_LENGTH) {\n            uint16 bps;\n            assembly (\"memory-safe\") {\n                bps := shr(0xf0, calldataload(data.offset))\n\n                data.offset := add(0x02, data.offset)\n                data.length := sub(data.length, 0x02)\n                // we don't check for array out-of-bounds here; we will check it later in `Decoder.overflowCheck`\n            }\n\n            data = Decoder.updateState(state, notes, data);\n            // It's not possible for `state.sell.amount` to even *approach* overflowing an `int256`,\n            // given that deltas are `int128`. If it overflows an `int128`, the ABI decoding in\n            // `CORE` will throw.\n            int256 amountSpecified;\n            unchecked {\n                amountSpecified = int256((state.sell().amount() * bps).unsafeDiv(BASIS));\n            }\n\n            bool isToken1;\n            {\n                (IERC20 sellToken, IERC20 buyToken) = (state.sell().token(), state.buy().token());\n                assembly (\"memory-safe\") {\n                    let sellTokenShifted := shl(0x60, sellToken)\n                    let buyTokenShifted := shl(0x60, buyToken)\n                    isToken1 :=\n                        or(\n                            eq(0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee000000000000000000000000, buyTokenShifted),\n                            and(iszero(eq(0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee000000000000000000000000, sellTokenShifted)), lt(buyTokenShifted, sellTokenShifted))\n                        )\n                }\n                (poolKey.token0, poolKey.token1) = isToken1.maybeSwap(address(sellToken), address(buyToken));\n            }\n\n            {\n                bytes32 config;\n                assembly (\"memory-safe\") {\n                    config := calldataload(data.offset)\n                    data.offset := add(0x20, data.offset)\n                    data.length := sub(data.length, 0x20)\n                    // we don't check for array out-of-bounds here; we will check it later in `Decoder.overflowCheck`\n                }\n                poolKey.config = Config.wrap(config);\n            }\n\n            Decoder.overflowCheck(data);\n\n            {\n                SqrtRatio sqrtRatio = SqrtRatio.wrap(\n                    uint96(isToken1.ternary(uint256(79227682466138141934206691491), uint256(4611797791050542631)))\n                );\n                (int256 delta0, int256 delta1) = IEkuboCore(msg.sender).unsafeSwap(\n                    poolKey, amountSpecified, isToken1, sqrtRatio\n                );\n                // Ekubo's sign convention here is backwards compared to UniV4/BalV3/PancakeInfinity\n                // `settledSellAmount` is positive, `settledBuyAmount` is negative. So the use of\n                // `asCredit` and `asDebt` below is misleading as they are actually debt and credit,\n                // respectively, in this context.\n                (int256 settledSellAmount, int256 settledBuyAmount) = isToken1.maybeSwap(delta0, delta1);\n\n                // We have to check for underflow in the sell amount (could create more debt than\n                // we're able to pay)\n                NotePtr sell = state.sell();\n                sell.setAmount(sell.amount() - settledSellAmount.asCredit(sell));\n\n                // We *DON'T* have to check for overflow in the buy amount because adding an\n                // `int128` to a `uint256`, even repeatedly cannot practically overflow.\n                unchecked {\n                    NotePtr buy = state.buy();\n                    buy.setAmount(buy.amount() + settledBuyAmount.asDebt(buy));\n                }\n            }\n        }\n\n        // `data` has been consumed. All that remains is to settle out the net result of all the\n        // swaps. Any credit in any token other than `state.buy.token` will be swept to\n        // Settler. `state.buy.token` will be sent to `recipient`.\n        {\n            NotePtr globalSell = state.globalSell();\n            (IERC20 globalSellToken, uint256 globalSellAmount) = (globalSell.token(), globalSell.amount());\n            uint256 globalBuyAmount =\n                Take.take(state, notes, uint32(IEkuboCore.withdraw.selector), recipient, minBuyAmount);\n            if (feeOnTransfer) {\n                // We've already transferred the sell token to the vault and\n                // `settle`'d. `globalSellAmount` is the verbatim credit in that token stored by the\n                // vault. We only need to handle the case of incomplete filling.\n                if (globalSellAmount != 0) {\n                    Take._callSelector(\n                        uint32(IEkuboCore.withdraw.selector),\n                        globalSellToken,\n                        (payer == address(this)) ? address(this) : _msgSender(),\n                        globalSellAmount\n                    );\n                }\n            } else {\n                // While `notes` records a credit value, the vault actually records a debt for the\n                // global sell token. We recover the exact amount of that debt and then pay it.\n                // `globalSellAmount` is _usually_ zero, but if it isn't it represents a partial\n                // fill. This subtraction recovers the actual debt recorded in the vault.\n                uint256 debt;\n                unchecked {\n                    debt = state.globalSellAmount() - globalSellAmount;\n                }\n                if (debt == 0) {\n                    assembly (\"memory-safe\") {\n                        mstore(0x14, globalSellToken)\n                        mstore(0x00, 0xfb772a88000000000000000000000000) // selector for `ZeroSellAmount(address)` with `globalSellToken`'s padding\n                        revert(0x10, 0x24)\n                    }\n                }\n                _ekuboPay(globalSellToken, payer, debt, permit, isForwarded, sig);\n            }\n\n            // return abi.encode(globalBuyAmount);\n            bytes memory returndata;\n            assembly (\"memory-safe\") {\n                returndata := mload(0x40)\n                mstore(returndata, 0x60)\n                mstore(add(0x20, returndata), 0x20)\n                mstore(add(0x40, returndata), 0x20)\n                mstore(add(0x60, returndata), globalBuyAmount)\n                mstore(0x40, add(0x80, returndata))\n            }\n            return returndata;\n        }\n    }\n\n    function payCallback(bytes calldata data) private returns (bytes memory returndata) {\n        IERC20 sellToken;\n        uint256 sellAmount;\n\n        ISignatureTransfer.PermitTransferFrom calldata permit;\n        bool isForwarded;\n        bytes calldata sig;\n\n        assembly (\"memory-safe\") {\n            // Initialize permit and sig to appease the compiler\n            permit := calldatasize()\n            sig.offset := calldatasize()\n            sig.length := 0x00\n\n            // first 2 slots in calldata are id and token\n            // id is not being used so can be skipped\n            sellToken := calldataload(add(0x20, data.offset))\n            // then extra data added in _ekuboPay\n            sellAmount := calldataload(add(0x40, data.offset))\n        }\n        if (0x60 < data.length) {\n            assembly (\"memory-safe\") {\n                // starts at the beginning of sellToken\n                permit := add(0x20, data.offset)\n                isForwarded := calldataload(add(0xa0, data.offset))\n\n                sig.offset := add(0xc0, data.offset)\n                sig.length := calldataload(sig.offset)\n                sig.offset := add(0x20, sig.offset)\n            }\n            ISignatureTransfer.SignatureTransferDetails memory transferDetails =\n                ISignatureTransfer.SignatureTransferDetails({to: msg.sender, requestedAmount: sellAmount});\n            _transferFrom(permit, transferDetails, sig, isForwarded);\n        } else {\n            sellToken.safeTransfer(msg.sender, sellAmount);\n        }\n        // return abi.encode(sellAmount);\n        assembly (\"memory-safe\") {\n            returndata := mload(0x40)\n            mstore(returndata, 0x60)\n            mstore(add(0x20, returndata), 0x20)\n            mstore(add(0x40, returndata), 0x20)\n            mstore(add(0x60, returndata), sellAmount)\n            mstore(0x40, add(0x80, returndata))\n        }\n    }\n}\n\n// src/core/UniswapV4.sol\n\nabstract contract UniswapV4 is SettlerAbstract {\n    using SafeTransferLib for IERC20;\n    using UnsafeMath for uint256;\n    using UnsafeMath for int256;\n    using Ternary for bool;\n    using CreditDebt for int256;\n    using UnsafePoolManager for IPoolManager;\n    using NotesLib for NotesLib.Note[];\n\n    constructor() {\n        assert(BASIS == Encoder.BASIS);\n        assert(BASIS == Decoder.BASIS);\n        assert(ETH_ADDRESS == Decoder.ETH_ADDRESS);\n    }\n\n    function _POOL_MANAGER() internal view virtual returns (IPoolManager);\n\n    //// These two functions are the entrypoints to this set of actions. Because UniV4 has a\n    //// mandatory callback, and the vast majority of the business logic has to be executed inside\n    //// the callback, they're pretty minimal. Both end up inside the last function in this file\n    //// `unlockCallback`, which is where most of the business logic lives. Primarily, these\n    //// functions are concerned with correctly encoding the argument to\n    //// `POOL_MANAGER.unlock(...)`. Pay special attention to the `payer` field, which is what\n    //// signals to the callback whether we should be spending a coupon.\n\n    //// How to generate `fills` for UniV4:\n    ////\n    //// Linearize your DAG of fills by doing a topological sort on the tokens involved. In the\n    //// topological sort of tokens, when there is a choice of the next token, break ties by\n    //// preferring a token if it is the lexicographically largest token that is bought among fills\n    //// with sell token equal to the previous token in the topological sort. Then sort the fills\n    //// belonging to each sell token by their buy token. This technique isn't *quite* optimal, but\n    //// it's pretty close. The buy token of the final fill is special-cased. It is the token that\n    //// will be transferred to `recipient` and have its slippage checked against `amountOutMin`. In\n    //// the event that you are encoding a series of fills with more than one output token, ensure\n    //// that at least one of the global buy token's fills is positioned appropriately.\n    ////\n    //// Now that you have a list of fills, encode each fill as follows.\n    //// First encode the `bps` for the fill as 2 bytes. Remember that this `bps` is relative to the\n    //// running balance at the moment that the fill is settled.\n    //// Second, encode the packing key for that fill as 1 byte. The packing key byte depends on the\n    //// tokens involved in the previous fill. The packing key for the first fill must be 1;\n    //// i.e. encode only the buy token for the first fill.\n    ////   0 -> sell and buy tokens remain unchanged from the previous fill (pure multiplex)\n    ////   1 -> sell token remains unchanged from the previous fill, buy token is encoded (diamond multiplex)\n    ////   2 -> sell token becomes the buy token from the previous fill, new buy token is encoded (multihop)\n    ////   3 -> both sell and buy token are encoded\n    //// Obviously, after encoding the packing key, you encode 0, 1, or 2 tokens (each as 20 bytes),\n    //// as appropriate.\n    //// The remaining fields of the fill are mandatory.\n    //// Third, encode the pool fee as 3 bytes, and the pool tick spacing as 3 bytes.\n    //// Fourth, encode the hook address as 20 bytes.\n    //// Fifth, encode the hook data for the fill. Encode the length of the hook data as 3 bytes,\n    //// then append the hook data itself.\n    ////\n    //// Repeat the process for each fill and concatenate the results without padding.\n\n    function sellToUniswapV4(\n        address recipient,\n        IERC20 sellToken,\n        uint256 bps,\n        bool feeOnTransfer,\n        uint256 hashMul,\n        uint256 hashMod,\n        bytes memory fills,\n        uint256 amountOutMin\n    ) internal returns (uint256 buyAmount) {\n        bytes memory data = Encoder.encode(\n            uint32(IPoolManager.unlock.selector),\n            recipient,\n            sellToken,\n            bps,\n            feeOnTransfer,\n            hashMul,\n            hashMod,\n            fills,\n            amountOutMin\n        );\n        bytes memory encodedBuyAmount = _setOperatorAndCall(\n            address(_POOL_MANAGER()), data, uint32(IUnlockCallback.unlockCallback.selector), _uniV4Callback\n        );\n        // buyAmount = abi.decode(abi.decode(encodedBuyAmount, (bytes)), (uint256));\n        assembly (\"memory-safe\") {\n            // We can skip all the checks performed by `abi.decode` because we know that this is the\n            // verbatim result from `unlockCallback` and that `unlockCallback` encoded the buy\n            // amount correctly.\n            buyAmount := mload(add(0x60, encodedBuyAmount))\n        }\n    }\n\n    function sellToUniswapV4VIP(\n        address recipient,\n        bool feeOnTransfer,\n        uint256 hashMul,\n        uint256 hashMod,\n        bytes memory fills,\n        ISignatureTransfer.PermitTransferFrom memory permit,\n        bytes memory sig,\n        uint256 amountOutMin\n    ) internal returns (uint256 buyAmount) {\n        bytes memory data = Encoder.encodeVIP(\n            uint32(IPoolManager.unlock.selector),\n            recipient,\n            feeOnTransfer,\n            hashMul,\n            hashMod,\n            fills,\n            permit,\n            sig,\n            _isForwarded(),\n            amountOutMin\n        );\n        bytes memory encodedBuyAmount = _setOperatorAndCall(\n            address(_POOL_MANAGER()), data, uint32(IUnlockCallback.unlockCallback.selector), _uniV4Callback\n        );\n        // buyAmount = abi.decode(abi.decode(encodedBuyAmount, (bytes)), (uint256));\n        assembly (\"memory-safe\") {\n            // We can skip all the checks performed by `abi.decode` because we know that this is the\n            // verbatim result from `unlockCallback` and that `unlockCallback` encoded the buy\n            // amount correctly.\n            buyAmount := mload(add(0x60, encodedBuyAmount))\n        }\n    }\n\n    function _uniV4Callback(bytes calldata data) private returns (bytes memory) {\n        // We know that our calldata is well-formed. Therefore, the first slot is 0x20 and the\n        // second slot is the length of the strict ABIEncoded payload\n        assembly (\"memory-safe\") {\n            data.length := calldataload(add(0x20, data.offset))\n            data.offset := add(0x40, data.offset)\n        }\n        return unlockCallback(data);\n    }\n\n    //// The following functions are the helper functions for `unlockCallback`. They abstract much\n    //// of the complexity of tracking which tokens need to be zeroed out at the end of the\n    //// callback.\n    ////\n    //// The two major pieces of state that are maintained through the callback are `Note[] memory\n    //// notes` and `State state`\n    ////\n    //// `notes` keeps track of the list of the tokens that have been touched throughout the\n    //// callback that have nonzero credit. At the end of the fills, all tokens with credit will be\n    //// swept back to Settler. These are the global buy token (against which slippage is checked)\n    //// and any other multiplex-out tokens. Only the global sell token is allowed to have debt, but\n    //// it is accounted slightly differently from the other tokens. The function `_take` is\n    //// responsible for iterating over the list of tokens and withdrawing any credit to the\n    //// appropriate recipient.\n    ////\n    //// `state` exists to reduce stack pressure and to simplify/gas-optimize the process of\n    //// swapping. By keeping track of the sell and buy token on each hop, we're able to compress\n    //// the representation of the fills required to satisfy the swap. Most often in a swap, the\n    //// tokens in adjacent fills are somewhat in common. By caching, we avoid having them appear\n    //// multiple times in the calldata.\n\n    // the mandatory fields are\n    // 2 - sell bps\n    // 1 - pool key tokens case\n    // 3 - pool fee\n    // 3 - pool tick spacing\n    // 20 - pool hooks\n    // 3 - hook data length\n    uint256 private constant _HOP_DATA_LENGTH = 32;\n\n    /// Decode a `PoolKey` from its packed representation in `bytes` and the token information in\n    /// `state`. Returns the `zeroForOne` flag and the suffix of the bytes that are not consumed in\n    /// the decoding process.\n    function _setPoolKey(IPoolManager.PoolKey memory key, State state, bytes calldata data)\n        private\n        pure\n        returns (bool, bytes calldata)\n    {\n        (IERC20 sellToken, IERC20 buyToken) = (state.sell().token(), state.buy().token());\n        bool zeroForOne;\n        assembly (\"memory-safe\") {\n            let sellTokenShifted := shl(0x60, sellToken)\n            let buyTokenShifted := shl(0x60, buyToken)\n            zeroForOne :=\n                or(\n                    eq(0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee000000000000000000000000, sellTokenShifted),\n                    and(iszero(eq(0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee000000000000000000000000, buyTokenShifted)), lt(sellTokenShifted, buyTokenShifted))\n                )\n        }\n        (key.token0, key.token1) = zeroForOne.maybeSwap(buyToken, sellToken);\n\n        uint256 packed;\n        assembly (\"memory-safe\") {\n            packed := shr(0x30, calldataload(data.offset))\n\n            data.offset := add(0x1a, data.offset)\n            data.length := sub(data.length, 0x1a)\n            // we don't check for array out-of-bounds here; we will check it later in `Decoder.overflowCheck`\n        }\n\n        key.fee = uint24(packed >> 184);\n        key.tickSpacing = int24(uint24(packed >> 160));\n        key.hooks = IHooks.wrap(address(uint160(packed)));\n\n        return (zeroForOne, data);\n    }\n\n    function _pay(\n        IERC20 sellToken,\n        address payer,\n        uint256 sellAmount,\n        ISignatureTransfer.PermitTransferFrom calldata permit,\n        bool isForwarded,\n        bytes calldata sig\n    ) private returns (uint256) {\n        IPoolManager(msg.sender).unsafeSync(sellToken);\n        if (payer == address(this)) {\n            sellToken.safeTransfer(msg.sender, sellAmount);\n        } else {\n            // assert(payer == address(0));\n            ISignatureTransfer.SignatureTransferDetails memory transferDetails =\n                ISignatureTransfer.SignatureTransferDetails({to: msg.sender, requestedAmount: sellAmount});\n            _transferFrom(permit, transferDetails, sig, isForwarded);\n        }\n        return IPoolManager(msg.sender).unsafeSettle();\n    }\n\n    function unlockCallback(bytes calldata data) private returns (bytes memory) {\n        address recipient;\n        uint256 minBuyAmount;\n        uint256 hashMul;\n        uint256 hashMod;\n        bool feeOnTransfer;\n        address payer;\n        (data, recipient, minBuyAmount, hashMul, hashMod, feeOnTransfer, payer) = Decoder.decodeHeader(data);\n\n        // Set up `state` and `notes`. The other values are ancillary and might be used when we need\n        // to settle global sell token debt at the end of swapping.\n        (\n            bytes calldata newData,\n            State state,\n            NotesLib.Note[] memory notes,\n            ISignatureTransfer.PermitTransferFrom calldata permit,\n            bool isForwarded,\n            bytes calldata sig\n        ) = Decoder.initialize(data, hashMul, hashMod, payer);\n        {\n            NotePtr globalSell = state.globalSell();\n            if (payer != address(this)) {\n                globalSell.setAmount(_permitToSellAmountCalldata(permit));\n            }\n            if (feeOnTransfer) {\n                globalSell.setAmount(\n                    _pay(globalSell.token(), payer, globalSell.amount(), permit, isForwarded, sig)\n                );\n            }\n            state.setGlobalSellAmount(globalSell.amount());\n        }\n        state.checkZeroSellAmount();\n        data = newData;\n\n        // Now that we've unpacked and decoded the header, we can begin decoding the array of swaps\n        // and executing them.\n        IPoolManager.PoolKey memory key;\n        IPoolManager.SwapParams memory params;\n        while (data.length >= _HOP_DATA_LENGTH) {\n            uint16 bps;\n            assembly (\"memory-safe\") {\n                bps := shr(0xf0, calldataload(data.offset))\n\n                data.offset := add(0x02, data.offset)\n                data.length := sub(data.length, 0x02)\n                // we don't check for array out-of-bounds here; we will check it later in `Decoder.overflowCheck`\n            }\n\n            data = Decoder.updateState(state, notes, data);\n            bool zeroForOne;\n            (zeroForOne, data) = _setPoolKey(key, state, data);\n            bytes calldata hookData;\n            (data, hookData) = Decoder.decodeBytes(data);\n            Decoder.overflowCheck(data);\n\n            params.zeroForOne = zeroForOne;\n            unchecked {\n                params.amountSpecified = int256((state.sell().amount() * bps).unsafeDiv(BASIS)).unsafeNeg();\n            }\n            // TODO: price limits\n            params.sqrtPriceLimitX96 = uint160(\n                zeroForOne.ternary(uint160(4295128740), uint160(1461446703485210103287273052203988822378723970341))\n            );\n\n            BalanceDelta delta = IPoolManager(msg.sender).unsafeSwap(key, params, hookData);\n            {\n                (int256 settledSellAmount, int256 settledBuyAmount) =\n                    zeroForOne.maybeSwap(delta.amount1(), delta.amount0());\n                // Some insane hooks may increase the sell amount; obviously this may result in\n                // unavoidable reverts in some cases. But we still need to make sure that we don't\n                // underflow to avoid wildly unexpected behavior. The pool manager enforces that the\n                // settled sell amount cannot be positive\n                NotePtr sell = state.sell();\n                sell.setAmount(sell.amount() - uint256(settledSellAmount.unsafeNeg()));\n                // If `state.buy.amount()` overflows an `int128`, we'll get a revert inside the pool\n                // manager later. We cannot overflow a `uint256`.\n                unchecked {\n                    NotePtr buy = state.buy();\n                    buy.setAmount(buy.amount() + settledBuyAmount.asCredit(buy));\n                }\n            }\n        }\n\n        // `data` has been consumed. All that remains is to settle out the net result of all the\n        // swaps. Any credit in any token other than `state.buy.token` will be swept to\n        // Settler. `state.buy.token` will be sent to `recipient`.\n        {\n            NotePtr globalSell = state.globalSell();\n            (IERC20 globalSellToken, uint256 globalSellAmount) = (globalSell.token(), globalSell.amount());\n            uint256 globalBuyAmount =\n                Take.take(state, notes, uint32(IPoolManager.take.selector), recipient, minBuyAmount);\n            if (feeOnTransfer) {\n                // We've already transferred the sell token to the pool manager and\n                // `settle`'d. `globalSellAmount` is the verbatim credit in that token stored by the\n                // pool manager. We only need to handle the case of incomplete filling.\n                if (globalSellAmount != 0) {\n                    Take._callSelector(\n                        uint32(IPoolManager.take.selector),\n                        globalSellToken,\n                        payer == address(this) ? address(this) : _msgSender(),\n                        globalSellAmount\n                    );\n                }\n            } else {\n                // While `notes` records a credit value, the pool manager actually records a debt\n                // for the global sell token. We recover the exact amount of that debt and then pay\n                // it.\n                // `globalSellAmount` is _usually_ zero, but if it isn't it represents a partial\n                // fill. This subtraction recovers the actual debt recorded in the pool manager.\n                uint256 debt;\n                unchecked {\n                    debt = state.globalSellAmount() - globalSellAmount;\n                }\n                if (debt == 0) {\n                    assembly (\"memory-safe\") {\n                        mstore(0x14, globalSellToken)\n                        mstore(0x00, 0xfb772a88000000000000000000000000) // selector for `ZeroSellAmount(address)` with `globalSellToken`'s padding\n                        revert(0x10, 0x24)\n                    }\n                }\n                if (globalSellToken == ETH_ADDRESS) {\n                    IPoolManager(msg.sender).unsafeSync(IERC20(address(0)));\n                    IPoolManager(msg.sender).unsafeSettle(debt);\n                } else {\n                    _pay(globalSellToken, payer, debt, permit, isForwarded, sig);\n                }\n            }\n\n            // return abi.encode(globalBuyAmount);\n            bytes memory returndata;\n            assembly (\"memory-safe\") {\n                returndata := mload(0x40)\n                mstore(returndata, 0x60)\n                mstore(add(0x20, returndata), 0x20)\n                mstore(add(0x40, returndata), 0x20)\n                mstore(add(0x60, returndata), globalBuyAmount)\n                mstore(0x40, add(0x80, returndata))\n            }\n            return returndata;\n        }\n    }\n\n    address public constant rebateClaimer = 0x352650Ac2653508d946c4912B07895B22edd84CD; // an EOA owned by Scott\n}\n\n// src/core/Permit2Payment.sol\n\nlibrary TransientStorage {\n    // bytes32((uint256(keccak256(\"operator slot\")) - 1) & type(uint128).max)\n    bytes32 private constant _OPERATOR_SLOT = 0x0000000000000000000000000000000007f49fa1cdccd5c65a7d4860ce3abbe9;\n    // bytes32((uint256(keccak256(\"witness slot\")) - 1) & type(uint128).max)\n    bytes32 private constant _WITNESS_SLOT = 0x00000000000000000000000000000000e44a235ac7aebfbc05485e093720deaa;\n    // bytes32((uint256(keccak256(\"payer slot\")) - 1) & type(uint128).max)\n    bytes32 private constant _PAYER_SLOT = 0x00000000000000000000000000000000c824a45acd1e9517bb0cb8d0d5cde893;\n\n    // We assume (and our CI enforces) that internal function pointers cannot be\n    // greater than 2 bytes. On chains not supporting the ViaIR pipeline, not\n    // supporting EOF, and where the Spurious Dragon size limit is not enforced,\n    // it might be possible to violate this assumption. However, our\n    // `foundry.toml` enforces the use of the IR pipeline, so the point is moot.\n    //\n    // `operator` must not be `address(0)`. This is not checked.\n    // `callback` must not be zero. This is checked in `_invokeCallback`.\n    function setOperatorAndCallback(\n        address operator,\n        uint32 selector,\n        function (bytes calldata) internal returns (bytes memory) callback\n    ) internal {\n        address currentSigner;\n        assembly (\"memory-safe\") {\n            currentSigner := tload(_PAYER_SLOT)\n        }\n        if (operator == currentSigner) {\n            assembly (\"memory-safe\") {\n                mstore(0x00, 0xe758b8d5) // selector for `ConfusedDeputy()`\n                revert(0x1c, 0x04)\n            }\n        }\n        uint256 callbackInt;\n        assembly (\"memory-safe\") {\n            callbackInt := tload(_OPERATOR_SLOT)\n        }\n        if (callbackInt != 0) {\n            // It should be impossible to reach this error because the first thing the fallback does\n            // is clear the operator. It's also not possible to reenter the entrypoint function\n            // because `_PAYER_SLOT` is an implicit reentrancy guard.\n            assembly (\"memory-safe\") {\n                mstore(0x00, 0xab7646c4) // selector for `ReentrantCallback(uint256)`\n                mstore(0x20, callbackInt)\n                revert(0x1c, 0x24)\n            }\n        }\n        assembly (\"memory-safe\") {\n            tstore(\n                _OPERATOR_SLOT,\n                or(\n                    shl(0xe0, selector),\n                    or(shl(0xa0, and(0xffff, callback)), and(0xffffffffffffffffffffffffffffffffffffffff, operator))\n                )\n            )\n        }\n    }\n\n    function checkSpentOperatorAndCallback() internal view {\n        uint256 callbackInt;\n        assembly (\"memory-safe\") {\n            callbackInt := tload(_OPERATOR_SLOT)\n        }\n        if (callbackInt != 0) {\n            assembly (\"memory-safe\") {\n                mstore(0x00, 0xd66fcc38) // selector for `CallbackNotSpent(uint256)`\n                mstore(0x20, callbackInt)\n                revert(0x1c, 0x24)\n            }\n        }\n    }\n\n    function getAndClearCallback()\n        internal\n        returns (function (bytes calldata) internal returns (bytes memory) callback)\n    {\n        assembly (\"memory-safe\") {\n            let slot := tload(_OPERATOR_SLOT)\n            if or(shr(0xe0, xor(calldataload(0), slot)), shl(0x60, xor(caller(), slot))) {\n                revert(0x00, 0x00)\n            }\n            callback := and(0xffff, shr(0xa0, slot))\n            tstore(_OPERATOR_SLOT, 0x00)\n        }\n    }\n\n    // `newWitness` must not be `bytes32(0)`. This is not checked.\n    function setWitness(bytes32 newWitness) internal {\n        bytes32 currentWitness;\n        assembly (\"memory-safe\") {\n            currentWitness := tload(_WITNESS_SLOT)\n        }\n        if (currentWitness != bytes32(0)) {\n            // It should be impossible to reach this error because the first thing a metatransaction\n            // does on entry is to spend the `witness` (either directly or via a callback)\n            assembly (\"memory-safe\") {\n                mstore(0x00, 0x9936cbab) // selector for `ReentrantMetatransaction(bytes32)`\n                mstore(0x20, currentWitness)\n                revert(0x1c, 0x24)\n            }\n        }\n        assembly (\"memory-safe\") {\n            tstore(_WITNESS_SLOT, newWitness)\n        }\n    }\n\n    function checkSpentWitness() internal view {\n        bytes32 currentWitness;\n        assembly (\"memory-safe\") {\n            currentWitness := tload(_WITNESS_SLOT)\n        }\n        if (currentWitness != bytes32(0)) {\n            assembly (\"memory-safe\") {\n                mstore(0x00, 0xe25527c2) // selector for `WitnessNotSpent(bytes32)`\n                mstore(0x20, currentWitness)\n                revert(0x1c, 0x24)\n            }\n        }\n    }\n\n    function getAndClearWitness() internal returns (bytes32 witness) {\n        assembly (\"memory-safe\") {\n            witness := tload(_WITNESS_SLOT)\n            tstore(_WITNESS_SLOT, 0x00)\n        }\n    }\n\n    function setPayer(address payer) internal {\n        if (payer == address(0)) {\n            assembly (\"memory-safe\") {\n                mstore(0x00, 0xe758b8d5) // selector for `ConfusedDeputy()`\n                revert(0x1c, 0x04)\n            }\n        }\n        address oldPayer;\n        assembly (\"memory-safe\") {\n            oldPayer := tload(_PAYER_SLOT)\n        }\n        if (oldPayer != address(0)) {\n            assembly (\"memory-safe\") {\n                mstore(0x14, oldPayer)\n                mstore(0x00, 0x7407c0f8000000000000000000000000) // selector for `ReentrantPayer(address)` with `oldPayer`'s padding\n                revert(0x10, 0x24)\n            }\n        }\n        assembly (\"memory-safe\") {\n            tstore(_PAYER_SLOT, and(0xffffffffffffffffffffffffffffffffffffffff, payer))\n        }\n    }\n\n    function getPayer() internal view returns (address payer) {\n        assembly (\"memory-safe\") {\n            payer := tload(_PAYER_SLOT)\n        }\n    }\n\n    function clearPayer(address expectedOldPayer) internal {\n        address oldPayer;\n        assembly (\"memory-safe\") {\n            oldPayer := tload(_PAYER_SLOT)\n        }\n        if (oldPayer != expectedOldPayer) {\n            assembly (\"memory-safe\") {\n                mstore(0x00, 0x5149e795) // selector for `PayerSpent()`\n                revert(0x1c, 0x04)\n            }\n        }\n        assembly (\"memory-safe\") {\n            tstore(_PAYER_SLOT, 0x00)\n        }\n    }\n}\n\nabstract contract Permit2PaymentBase is Context, SettlerAbstract {\n    using Revert for bool;\n\n    /// @dev Permit2 address\n    ISignatureTransfer internal constant _PERMIT2 = ISignatureTransfer(0x000000000022D473030F116dDEE9F6B43aC78BA3);\n\n    function _isRestrictedTarget(address target) internal pure virtual override returns (bool) {\n        return target == address(_PERMIT2);\n    }\n\n    function _operator() internal view virtual override returns (address) {\n        return super._msgSender();\n    }\n\n    function _msgSender() internal view virtual override(AbstractContext, Context) returns (address) {\n        return TransientStorage.getPayer();\n    }\n\n    /// @dev You must ensure that `target` is derived by hashing trusted initcode or another\n    ///      equivalent mechanism that guarantees \"reasonable\"ness. `target` must not be\n    ///      user-supplied or attacker-controlled. This is required for security and is not checked\n    ///      here. For example, it must not do something weird like modifying the spender (possibly\n    ///      setting it to itself). If the callback is expected to relay a\n    ///      `ISignatureTransfer.PermitTransferFrom` struct, then the computation of `target` using\n    ///      the trusted initcode (or equivalent) must ensure that that calldata is relayed\n    ///      unmodified. The library function `AddressDerivation.deriveDeterministicContract` is\n    ///      recommended.\n    function _setOperatorAndCall(\n        address payable target,\n        uint256 value,\n        bytes memory data,\n        uint32 selector,\n        function (bytes calldata) internal returns (bytes memory) callback\n    ) internal returns (bytes memory) {\n        TransientStorage.setOperatorAndCallback(target, selector, callback);\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        success.maybeRevert(returndata);\n        TransientStorage.checkSpentOperatorAndCallback();\n        return returndata;\n    }\n\n    function _setOperatorAndCall(\n        address target,\n        bytes memory data,\n        uint32 selector,\n        function (bytes calldata) internal returns (bytes memory) callback\n    ) internal override returns (bytes memory) {\n        return _setOperatorAndCall(payable(target), 0, data, selector, callback);\n    }\n\n    function _invokeCallback(bytes calldata data) internal returns (bytes memory) {\n        // Retrieve callback and perform call with untrusted calldata\n        return TransientStorage.getAndClearCallback()(data[4:]);\n    }\n}\n\nabstract contract Permit2Payment is Permit2PaymentBase {\n    fallback(bytes calldata) external virtual returns (bytes memory) {\n        return _invokeCallback(_msgData());\n    }\n\n    function _permitToTransferDetails(ISignatureTransfer.PermitTransferFrom memory permit, address recipient)\n        internal\n        view\n        override\n        returns (ISignatureTransfer.SignatureTransferDetails memory transferDetails, uint256 sellAmount)\n    {\n        transferDetails.to = recipient;\n        transferDetails.requestedAmount = sellAmount = _permitToSellAmount(permit);\n    }\n\n    // This function is provided *EXCLUSIVELY* for use here and in RfqOrderSettlement. Any other use\n    // of this function is forbidden. You must use the version that does *NOT* take a `from` or\n    // `witness` argument.\n    function _transferFromIKnowWhatImDoing(\n        ISignatureTransfer.PermitTransferFrom memory permit,\n        ISignatureTransfer.SignatureTransferDetails memory transferDetails,\n        address from,\n        bytes32 witness,\n        string memory witnessTypeString,\n        bytes memory sig,\n        bool isForwarded\n    ) internal override {\n        if (isForwarded) {\n            assembly (\"memory-safe\") {\n                mstore(0x00, 0x1c500e5c) // selector for `ForwarderNotAllowed()`\n                revert(0x1c, 0x04)\n            }\n        }\n\n        // This is effectively\n        /*\n        _PERMIT2.permitWitnessTransferFrom(permit, transferDetails, from, witness, witnessTypeString, sig);\n        */\n        // but it's written in assembly for contract size reasons. This produces a non-strict ABI\n        // encoding (https://docs.soliditylang.org/en/v0.8.25/abi-spec.html#strict-encoding-mode),\n        // but it's fine because Solidity's ABI *decoder* will handle anything that is validly\n        // encoded, strict or not.\n\n        // Solidity won't let us reference the constant `_PERMIT2` in assembly, but this compiles\n        // down to just a single PUSH opcode just before the CALL, with optimization turned on.\n        ISignatureTransfer __PERMIT2 = _PERMIT2;\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x137c29fe) // selector for `permitWitnessTransferFrom(((address,uint256),uint256,uint256),(address,uint256),address,bytes32,string,bytes)`\n\n            // The layout of nested structs in memory is different from that in calldata. We have to\n            // chase the pointer to `permit.permitted`.\n            mcopy(add(0x20, ptr), mload(permit), 0x40)\n            // The rest of the members of `permit` are laid out linearly,\n            mcopy(add(0x60, ptr), add(0x20, permit), 0x40)\n            // as are the members of `transferDetails.\n            mcopy(add(0xa0, ptr), transferDetails, 0x40)\n            // Because we're passing `from` on the stack, it must be cleaned.\n            mstore(add(0xe0, ptr), and(0xffffffffffffffffffffffffffffffffffffffff, from))\n            mstore(add(0x100, ptr), witness)\n            mstore(add(0x120, ptr), 0x140) // Offset to `witnessTypeString` (the end of of the non-dynamic types)\n            let witnessTypeStringLength := mload(witnessTypeString)\n            mstore(add(0x140, ptr), add(0x160, witnessTypeStringLength)) // Offset to `sig` (past the end of `witnessTypeString`)\n\n            // Now we encode the 2 dynamic objects, `witnessTypeString` and `sig`.\n            mcopy(add(0x160, ptr), witnessTypeString, add(0x20, witnessTypeStringLength))\n            let sigLength := mload(sig)\n            mcopy(add(0x180, add(ptr, witnessTypeStringLength)), sig, add(0x20, sigLength))\n\n            // We don't need to check that Permit2 has code, and it always signals failure by\n            // reverting.\n            if iszero(\n                call(\n                    gas(),\n                    __PERMIT2,\n                    0x00,\n                    add(0x1c, ptr),\n                    add(0x184, add(witnessTypeStringLength, sigLength)),\n                    0x00,\n                    0x00\n                )\n            ) {\n                returndatacopy(ptr, 0x00, returndatasize())\n                revert(ptr, returndatasize())\n            }\n        }\n    }\n\n    // See comment in above overload; don't use this function\n    function _transferFromIKnowWhatImDoing(\n        ISignatureTransfer.PermitTransferFrom memory permit,\n        ISignatureTransfer.SignatureTransferDetails memory transferDetails,\n        address from,\n        bytes32 witness,\n        string memory witnessTypeString,\n        bytes memory sig\n    ) internal override {\n        _transferFromIKnowWhatImDoing(permit, transferDetails, from, witness, witnessTypeString, sig, _isForwarded());\n    }\n\n    function _transferFrom(\n        ISignatureTransfer.PermitTransferFrom memory permit,\n        ISignatureTransfer.SignatureTransferDetails memory transferDetails,\n        bytes memory sig\n    ) internal override {\n        _transferFrom(permit, transferDetails, sig, _isForwarded());\n    }\n}\n\n// DANGER: the order of the base contracts here is very significant for the use of `super` below\n// (and in derived contracts). Do not change this order.\nabstract contract Permit2PaymentTakerSubmitted is AllowanceHolderContext, Permit2Payment {\n    using FullMath for uint256;\n    using SafeTransferLib for IERC20;\n\n    constructor() {\n        assert(!_hasMetaTxn());\n    }\n\n    function _permitToSellAmountCalldata(ISignatureTransfer.PermitTransferFrom calldata permit)\n        internal\n        view\n        override\n        returns (uint256 sellAmount)\n    {\n        sellAmount = permit.permitted.amount;\n        if (sellAmount > type(uint256).max - BASIS) {\n            unchecked {\n                sellAmount -= type(uint256).max - BASIS;\n            }\n            sellAmount = IERC20(permit.permitted.token).fastBalanceOf(_msgSender()).mulDiv(sellAmount, BASIS);\n        }\n    }\n\n    function _permitToSellAmount(ISignatureTransfer.PermitTransferFrom memory permit)\n        internal\n        view\n        override\n        returns (uint256 sellAmount)\n    {\n        sellAmount = permit.permitted.amount;\n        if (sellAmount > type(uint256).max - BASIS) {\n            unchecked {\n                sellAmount -= type(uint256).max - BASIS;\n            }\n            sellAmount = IERC20(permit.permitted.token).fastBalanceOf(_msgSender()).mulDiv(sellAmount, BASIS);\n        }\n    }\n\n    function _isRestrictedTarget(address target) internal pure virtual override returns (bool) {\n        return target == address(_ALLOWANCE_HOLDER) || super._isRestrictedTarget(target);\n    }\n\n    function _transferFrom(\n        ISignatureTransfer.PermitTransferFrom memory permit,\n        ISignatureTransfer.SignatureTransferDetails memory transferDetails,\n        bytes memory sig,\n        bool isForwarded\n    ) internal override {\n        if (isForwarded) {\n            if (sig.length != 0) {\n                assembly (\"memory-safe\") {\n                    mstore(0x00, 0xc321526c) // selector for `InvalidSignatureLen()`\n                    revert(0x1c, 0x04)\n                }\n            }\n            if (permit.nonce != 0) Panic.panic(Panic.ARITHMETIC_OVERFLOW);\n            if (block.timestamp > permit.deadline) {\n                assembly (\"memory-safe\") {\n                    mstore(0x00, 0xcd21db4f) // selector for `SignatureExpired(uint256)`\n                    mstore(0x20, mload(add(0x40, permit)))\n                    revert(0x1c, 0x24)\n                }\n            }\n            // we don't check `requestedAmount` because it's checked by AllowanceHolder itself\n            _allowanceHolderTransferFrom(\n                permit.permitted.token, _msgSender(), transferDetails.to, transferDetails.requestedAmount\n            );\n        } else {\n            // This is effectively\n            /*\n            _PERMIT2.permitTransferFrom(permit, transferDetails, _msgSender(), sig);\n            */\n            // but it's written in assembly for contract size reasons. This produces a non-strict\n            // ABI encoding\n            // (https://docs.soliditylang.org/en/v0.8.25/abi-spec.html#strict-encoding-mode), but\n            // it's fine because Solidity's ABI *decoder* will handle anything that is validly\n            // encoded, strict or not.\n\n            // Solidity won't let us reference the constant `_PERMIT2` in assembly, but this\n            // compiles down to just a single PUSH opcode just before the CALL, with optimization\n            // turned on.\n            ISignatureTransfer __PERMIT2 = _PERMIT2;\n            address from = _msgSender();\n            assembly (\"memory-safe\") {\n                let ptr := mload(0x40)\n                mstore(ptr, 0x30f28b7a) // selector for `permitTransferFrom(((address,uint256),uint256,uint256),(address,uint256),address,bytes)`\n\n                // The layout of nested structs in memory is different from that in calldata. We\n                // have to chase the pointer to `permit.permitted`.\n                mcopy(add(0x20, ptr), mload(permit), 0x40)\n                // The rest of the members of `permit` are laid out linearly,\n                mcopy(add(0x60, ptr), add(0x20, permit), 0x40)\n                // as are the members of `transferDetails.\n                mcopy(add(0xa0, ptr), transferDetails, 0x40)\n                // Because we're passing `from` on the stack, it must be cleaned.\n                mstore(add(0xe0, ptr), and(0xffffffffffffffffffffffffffffffffffffffff, from))\n                mstore(add(0x100, ptr), 0x100) // Offset to `sig` (the end of the non-dynamic types)\n\n                // Encode the dynamic object `sig`\n                let sigLength := mload(sig)\n                mcopy(add(0x120, ptr), sig, add(0x20, sigLength))\n\n                // We don't need to check that Permit2 has code, and it always signals failure by\n                // reverting.\n                if iszero(call(gas(), __PERMIT2, 0x00, add(0x1c, ptr), add(0x124, sigLength), 0x00, 0x00)) {\n                    returndatacopy(ptr, 0x00, returndatasize())\n                    revert(ptr, returndatasize())\n                }\n            }\n        }\n    }\n\n    function _allowanceHolderTransferFrom(address token, address owner, address recipient, uint256 amount)\n        internal\n        override\n    {\n        // `owner` is always `_msgSender()`\n        // This is effectively\n        /*\n        _ALLOWANCE_HOLDER.transferFrom(token, owner, recipient, amount);\n        */\n        // but it's written in assembly for contract size reasons.\n\n        // Solidity won't let us reference the constant `_ALLOWANCE_HOLDER` in assembly, but this\n        // compiles down to just a single PUSH opcode just before the CALL, with optimization turned\n        // on.\n        address __ALLOWANCE_HOLDER = address(_ALLOWANCE_HOLDER);\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40)\n            mstore(add(0x80, ptr), amount)\n            mstore(add(0x60, ptr), recipient)\n            mstore(add(0x4c, ptr), shl(0x60, owner)) // clears `recipient`'s padding\n            mstore(add(0x2c, ptr), shl(0x60, token)) // clears `owner`'s padding\n            mstore(add(0x0c, ptr), 0x15dacbea000000000000000000000000) // selector for `transferFrom(address,address,address,uint256)` with `token`'s padding\n\n            // Although `transferFrom` returns `bool`, we don't need to bother checking the return\n            // value because `AllowanceHolder` always either reverts or returns `true`. We also\n            // don't need to check that it has code.\n            if iszero(call(gas(), __ALLOWANCE_HOLDER, 0x00, add(0x1c, ptr), 0x84, 0x00, 0x00)) {\n                returndatacopy(ptr, 0x00, returndatasize())\n                revert(ptr, returndatasize())\n            }\n        }\n    }\n\n    modifier takerSubmitted() override {\n        address msgSender = _operator();\n        TransientStorage.setPayer(msgSender);\n        _;\n        TransientStorage.clearPayer(msgSender);\n    }\n\n    modifier metaTx(address, bytes32) override {\n        revert();\n        _;\n    }\n\n    // Solidity inheritance is stupid\n    function _isForwarded()\n        internal\n        view\n        virtual\n        override(AbstractContext, Context, AllowanceHolderContext)\n        returns (bool)\n    {\n        return super._isForwarded();\n    }\n\n    function _msgData()\n        internal\n        view\n        virtual\n        override(AbstractContext, Context, AllowanceHolderContext)\n        returns (bytes calldata)\n    {\n        return super._msgData();\n    }\n\n    function _msgSender()\n        internal\n        view\n        virtual\n        override(AllowanceHolderContext, Permit2PaymentBase)\n        returns (address)\n    {\n        return super._msgSender();\n    }\n}\n\n// DANGER: the order of the base contracts here is very significant for the use of `super` below\n// (and in derived contracts). Do not change this order.\nabstract contract Permit2PaymentMetaTxn is Context, Permit2Payment {\n    constructor() {\n        assert(_hasMetaTxn());\n    }\n\n    function _permitToSellAmountCalldata(ISignatureTransfer.PermitTransferFrom calldata permit)\n        internal\n        pure\n        override\n        returns (uint256)\n    {\n        return permit.permitted.amount;\n    }\n\n    function _permitToSellAmount(ISignatureTransfer.PermitTransferFrom memory permit)\n        internal\n        pure\n        virtual\n        override\n        returns (uint256)\n    {\n        return permit.permitted.amount;\n    }\n\n    function _witnessTypeSuffix() internal pure virtual returns (string memory) {\n        return string(\n            abi.encodePacked(\n                \"SlippageAndActions slippageAndActions)\", SLIPPAGE_AND_ACTIONS_TYPE, TOKEN_PERMISSIONS_TYPE\n            )\n        );\n    }\n\n    function _transferFrom(\n        ISignatureTransfer.PermitTransferFrom memory permit,\n        ISignatureTransfer.SignatureTransferDetails memory transferDetails,\n        bytes memory sig,\n        bool isForwarded // must be false\n    ) internal override {\n        bytes32 witness = TransientStorage.getAndClearWitness();\n        if (witness == bytes32(0)) {\n            assembly (\"memory-safe\") {\n                mstore(0x00, 0xe758b8d5) // selector for `ConfusedDeputy()`\n                revert(0x1c, 0x04)\n            }\n        }\n        _transferFromIKnowWhatImDoing(\n            permit, transferDetails, _msgSender(), witness, _witnessTypeSuffix(), sig, isForwarded\n        );\n    }\n\n    function _allowanceHolderTransferFrom(address, address, address, uint256) internal pure override {\n        assembly (\"memory-safe\") {\n            mstore(0x00, 0xe758b8d5) // selector for `ConfusedDeputy()`\n            revert(0x1c, 0x04)\n        }\n    }\n\n    modifier takerSubmitted() override {\n        revert();\n        _;\n    }\n\n    modifier metaTx(address msgSender, bytes32 witness) override {\n        if (_isForwarded()) {\n            assembly (\"memory-safe\") {\n                mstore(0x00, 0x1c500e5c) // selector for `ForwarderNotAllowed()`\n                revert(0x1c, 0x04)\n            }\n        }\n        TransientStorage.setWitness(witness);\n        TransientStorage.setPayer(msgSender);\n        _;\n        TransientStorage.clearPayer(msgSender);\n        // It should not be possible for this check to revert because the very first thing that a\n        // metatransaction does is spend the witness.\n        TransientStorage.checkSpentWitness();\n    }\n\n    // Solidity inheritance is stupid\n    function _msgSender() internal view virtual override(Context, Permit2PaymentBase) returns (address) {\n        return super._msgSender();\n    }\n}\n\nabstract contract Permit2PaymentIntent is Permit2PaymentMetaTxn {\n    function _witnessTypeSuffix() internal pure virtual override returns (string memory) {\n        return string(abi.encodePacked(\"Slippage slippage)\", SLIPPAGE_TYPE, TOKEN_PERMISSIONS_TYPE));\n    }\n}\n\n// src/SettlerBase.sol\n\n/// @dev This library's ABIDeocding is more lax than the Solidity ABIDecoder. This library omits index bounds/overflow\n/// checking when accessing calldata arrays for gas efficiency. It also omits checks against `calldatasize()`. This\n/// means that it is possible that `args` will run off the end of calldata and be implicitly padded with zeroes. That we\n/// don't check for overflow means that offsets can be negative. This can also result in `args` that alias other parts\n/// of calldata, or even the `actions` array itself.\nlibrary CalldataDecoder {\n    function decodeCall(bytes[] calldata data, uint256 i)\n        internal\n        pure\n        returns (uint256 selector, bytes calldata args)\n    {\n        assembly (\"memory-safe\") {\n            // initially, we set `args.offset` to the pointer to the length. this is 32 bytes before the actual start of data\n            args.offset :=\n                add(\n                    data.offset,\n                    // We allow the indirection/offset to `calls[i]` to be negative\n                    calldataload(\n                        add(shl(0x05, i), data.offset) // can't overflow; we assume `i` is in-bounds\n                    )\n                )\n            // now we load `args.length` and set `args.offset` to the start of data\n            args.length := calldataload(args.offset)\n            args.offset := add(0x20, args.offset)\n\n            // slice off the first 4 bytes of `args` as the selector\n            selector := shr(0xe0, calldataload(args.offset))\n            args.length := sub(args.length, 0x04)\n            args.offset := add(0x04, args.offset)\n        }\n    }\n}\n\nabstract contract SettlerBase is ISettlerBase, Basic, RfqOrderSettlement, UniswapV3Fork, UniswapV2, Velodrome {\n    using SafeTransferLib for IERC20;\n    using SafeTransferLib for address payable;\n\n    receive() external payable {}\n\n    event GitCommit(bytes20 indexed);\n\n    // When/if you change this, you must make corresponding changes to\n    // `sh/deploy_new_chain.sh` and 'sh/common_deploy_settler.sh' to set\n    // `constructor_args`.\n    constructor(bytes20 gitCommit) {\n        if (block.chainid != 31337) {\n            emit GitCommit(gitCommit);\n            assert(IERC721Owner(DEPLOYER).ownerOf(_tokenId()) == address(this));\n        } else {\n            assert(gitCommit == bytes20(0));\n        }\n    }\n\n    function _div512to256(uint512 n, uint512 d) internal view virtual override returns (uint256) {\n        return n.div(d);\n    }\n\n    function _mandatorySlippageCheck() internal pure virtual returns (bool) {\n        return false;\n    }\n\n    function _checkSlippageAndTransfer(AllowedSlippage calldata slippage) internal {\n        // This final slippage check effectively prohibits custody optimization on the\n        // final hop of every swap. This is gas-inefficient. This is on purpose. Because\n        // ISettlerActions.BASIC could interact with an intents-based settlement\n        // mechanism, we must ensure that the user's want token increase is coming\n        // directly from us instead of from some other form of exchange of value.\n        (address payable recipient, IERC20 buyToken, uint256 minAmountOut) =\n            (slippage.recipient, slippage.buyToken, slippage.minAmountOut);\n        if (_mandatorySlippageCheck()) {\n            require(minAmountOut != 0);\n        } else if (minAmountOut == 0 && address(buyToken) == address(0)) {\n            return;\n        }\n        if (buyToken == ETH_ADDRESS) {\n            uint256 amountOut = address(this).balance;\n            if (amountOut < minAmountOut) {\n                revertTooMuchSlippage(buyToken, minAmountOut, amountOut);\n            }\n            recipient.safeTransferETH(amountOut);\n        } else {\n            uint256 amountOut = buyToken.fastBalanceOf(address(this));\n            if (amountOut < minAmountOut) {\n                revertTooMuchSlippage(buyToken, minAmountOut, amountOut);\n            }\n            buyToken.safeTransfer(recipient, amountOut);\n        }\n    }\n\n    function _dispatch(uint256, uint256 action, bytes calldata data) internal virtual override returns (bool) {\n        //// NOTICE: This function has been largely copy/paste'd into\n        //// `src/chains/Mainnet/Common.sol:MainnetMixin._dispatch`. If you make changes here, you\n        //// need to make sure that corresponding changes are made to that function.\n\n        if (action == uint32(ISettlerActions.RFQ.selector)) {\n            (\n                address recipient,\n                ISignatureTransfer.PermitTransferFrom memory permit,\n                address maker,\n                bytes memory makerSig,\n                IERC20 takerToken,\n                uint256 maxTakerAmount\n            ) = abi.decode(data, (address, ISignatureTransfer.PermitTransferFrom, address, bytes, IERC20, uint256));\n\n            fillRfqOrderSelfFunded(recipient, permit, maker, makerSig, takerToken, maxTakerAmount);\n        } else if (action == uint32(ISettlerActions.UNISWAPV3.selector)) {\n            (address recipient, uint256 bps, bytes memory path, uint256 amountOutMin) =\n                abi.decode(data, (address, uint256, bytes, uint256));\n\n            sellToUniswapV3(recipient, bps, path, amountOutMin);\n        } else if (action == uint32(ISettlerActions.UNISWAPV2.selector)) {\n            (address recipient, address sellToken, uint256 bps, address pool, uint24 swapInfo, uint256 amountOutMin) =\n                abi.decode(data, (address, address, uint256, address, uint24, uint256));\n\n            sellToUniswapV2(recipient, sellToken, bps, pool, swapInfo, amountOutMin);\n        } else if (action == uint32(ISettlerActions.BASIC.selector)) {\n            (IERC20 sellToken, uint256 bps, address pool, uint256 offset, bytes memory _data) =\n                abi.decode(data, (IERC20, uint256, address, uint256, bytes));\n\n            basicSellToPool(sellToken, bps, pool, offset, _data);\n        } else if (action == uint32(ISettlerActions.VELODROME.selector)) {\n            (address recipient, uint256 bps, IVelodromePair pool, uint24 swapInfo, uint256 minAmountOut) =\n                abi.decode(data, (address, uint256, IVelodromePair, uint24, uint256));\n\n            sellToVelodrome(recipient, bps, pool, swapInfo, minAmountOut);\n        } else if (action == uint32(ISettlerActions.POSITIVE_SLIPPAGE.selector)) {\n            (address payable recipient, IERC20 token, uint256 expectedAmount) = abi.decode(data, (address, IERC20, uint256));\n            if (token == ETH_ADDRESS) {\n                uint256 balance = address(this).balance;\n                if (balance > expectedAmount) {\n                    unchecked {\n                        recipient.safeTransferETH(balance - expectedAmount);\n                    }\n                }\n            } else {\n                uint256 balance = token.fastBalanceOf(address(this));\n                if (balance > expectedAmount) {\n                    unchecked {\n                        token.safeTransfer(recipient, balance - expectedAmount);\n                    }\n                }\n            }\n        } else {\n            return false;\n        }\n        return true;\n    }\n}\n\n// src/Settler.sol\n\nabstract contract Settler is ISettlerTakerSubmitted, Permit2PaymentTakerSubmitted, SettlerBase {\n    using UnsafeMath for uint256;\n    using CalldataDecoder for bytes[];\n\n    function _tokenId() internal pure override returns (uint256) {\n        return 2;\n    }\n\n    function _hasMetaTxn() internal pure override returns (bool) {\n        return false;\n    }\n\n    function _dispatchVIP(uint256 action, bytes calldata data) internal virtual returns (bool) {\n        if (action == uint32(ISettlerActions.TRANSFER_FROM.selector)) {\n            (address recipient, ISignatureTransfer.PermitTransferFrom memory permit, bytes memory sig) =\n                abi.decode(data, (address, ISignatureTransfer.PermitTransferFrom, bytes));\n            (ISignatureTransfer.SignatureTransferDetails memory transferDetails,) =\n                _permitToTransferDetails(permit, recipient);\n            _transferFrom(permit, transferDetails, sig);\n        } /*\n        // RFQ_VIP is temporarily removed because Solver has no support for it\n        // When support for RFQ_VIP is reenabled, the tests\n        // testAllowanceHolder_rfq_VIP and testSettler_rfq should be reenabled\n        else if (action == uint32(ISettlerActions.RFQ_VIP.selector)) {\n            (\n                address recipient,\n                ISignatureTransfer.PermitTransferFrom memory makerPermit,\n                address maker,\n                bytes memory makerSig,\n                ISignatureTransfer.PermitTransferFrom memory takerPermit,\n                bytes memory takerSig\n            ) = abi.decode(\n                data,\n                (\n                    address,\n                    ISignatureTransfer.PermitTransferFrom,\n                    address,\n                    bytes,\n                    ISignatureTransfer.PermitTransferFrom,\n                    bytes\n                )\n            );\n            fillRfqOrderVIP(recipient, makerPermit, maker, makerSig, takerPermit, takerSig);\n        } */ else if (action == uint32(ISettlerActions.UNISWAPV3_VIP.selector)) {\n            (\n                address recipient,\n                bytes memory path,\n                ISignatureTransfer.PermitTransferFrom memory permit,\n                bytes memory sig,\n                uint256 amountOutMin\n            ) = abi.decode(data, (address, bytes, ISignatureTransfer.PermitTransferFrom, bytes, uint256));\n\n            sellToUniswapV3VIP(recipient, path, permit, sig, amountOutMin);\n        } else {\n            return false;\n        }\n        return true;\n    }\n\n    function execute(AllowedSlippage calldata slippage, bytes[] calldata actions, bytes32 /* zid & affiliate */ )\n        public\n        payable\n        override\n        takerSubmitted\n        returns (bool)\n    {\n        if (actions.length != 0) {\n            (uint256 action, bytes calldata data) = actions.decodeCall(0);\n            if (!_dispatchVIP(action, data)) {\n                if (!_dispatch(0, action, data)) {\n                    revertActionInvalid(0, action, data);\n                }\n            }\n        }\n\n        for (uint256 i = 1; i < actions.length; i = i.unsafeInc()) {\n            (uint256 action, bytes calldata data) = actions.decodeCall(i);\n            if (!_dispatch(i, action, data)) {\n                revertActionInvalid(i, action, data);\n            }\n        }\n\n        _checkSlippageAndTransfer(slippage);\n        return true;\n    }\n\n    // Solidity inheritance is stupid\n    function _msgSender()\n        internal\n        view\n        virtual\n        override(Permit2PaymentTakerSubmitted, AbstractContext)\n        returns (address)\n    {\n        return super._msgSender();\n    }\n\n    function _isRestrictedTarget(address target)\n        internal\n        pure\n        virtual\n        override(Permit2PaymentTakerSubmitted, Permit2PaymentAbstract)\n        returns (bool)\n    {\n        return super._isRestrictedTarget(target);\n    }\n}\n\n// src/chains/Mainnet/Common.sol\n\n// When these actions are reenabled, reenable the integration tests by setting `curveV2TricryptoPoolId()`\n// import {CurveTricrypto} from \"../../core/CurveTricrypto.sol\";\n\n// Solidity inheritance is stupid\n\nabstract contract MainnetMixin is\n    FreeMemory,\n    SettlerBase,\n    MakerPSM,\n    MaverickV2,\n    //CurveTricrypto,\n    DodoV1,\n    DodoV2,\n    UniswapV4,\n    BalancerV3,\n    Ekubo\n{\n    using SafeTransferLib for IERC20;\n    using SafeTransferLib for address payable;\n\n    constructor() {\n        assert(block.chainid == 1 || block.chainid == 31337);\n    }\n\n    function _dispatch(uint256, uint256 action, bytes calldata data)\n        internal\n        virtual\n        override(SettlerAbstract, SettlerBase)\n        DANGEROUS_freeMemory\n        returns (bool)\n    {\n        //// NOTICE: we re-implement the base `_dispatch` implementation here so that we can remove\n        //// the `VELODROME` action JUST on this chain because it does little-to-no volume.\n\n        if (action == uint32(ISettlerActions.RFQ.selector)) {\n            (\n                address recipient,\n                ISignatureTransfer.PermitTransferFrom memory permit,\n                address maker,\n                bytes memory makerSig,\n                IERC20 takerToken,\n                uint256 maxTakerAmount\n            ) = abi.decode(data, (address, ISignatureTransfer.PermitTransferFrom, address, bytes, IERC20, uint256));\n\n            fillRfqOrderSelfFunded(recipient, permit, maker, makerSig, takerToken, maxTakerAmount);\n        } else if (action == uint32(ISettlerActions.UNISWAPV3.selector)) {\n            (address recipient, uint256 bps, bytes memory path, uint256 amountOutMin) =\n                abi.decode(data, (address, uint256, bytes, uint256));\n\n            sellToUniswapV3(recipient, bps, path, amountOutMin);\n        } else if (action == uint32(ISettlerActions.UNISWAPV2.selector)) {\n            (address recipient, address sellToken, uint256 bps, address pool, uint24 swapInfo, uint256 amountOutMin) =\n                abi.decode(data, (address, address, uint256, address, uint24, uint256));\n\n            sellToUniswapV2(recipient, sellToken, bps, pool, swapInfo, amountOutMin);\n        } else if (action == uint32(ISettlerActions.BASIC.selector)) {\n            (IERC20 sellToken, uint256 bps, address pool, uint256 offset, bytes memory _data) =\n                abi.decode(data, (IERC20, uint256, address, uint256, bytes));\n\n            basicSellToPool(sellToken, bps, pool, offset, _data);\n        } /* `VELODROME` is removed */\n        else if (action == uint32(ISettlerActions.POSITIVE_SLIPPAGE.selector)) {\n            (address recipient, IERC20 token, uint256 expectedAmount) = abi.decode(data, (address, IERC20, uint256));\n            if (token == ETH_ADDRESS) {\n                uint256 balance = address(this).balance;\n                if (balance > expectedAmount) {\n                    unchecked {\n                        payable(recipient).safeTransferETH(balance - expectedAmount);\n                    }\n                }\n            } else {\n                uint256 balance = token.fastBalanceOf(address(this));\n                if (balance > expectedAmount) {\n                    unchecked {\n                        token.safeTransfer(recipient, balance - expectedAmount);\n                    }\n                }\n            }\n        } else if (action == uint32(ISettlerActions.UNISWAPV4.selector)) {\n            (\n                address recipient,\n                IERC20 sellToken,\n                uint256 bps,\n                bool feeOnTransfer,\n                uint256 hashMul,\n                uint256 hashMod,\n                bytes memory fills,\n                uint256 amountOutMin\n            ) = abi.decode(data, (address, IERC20, uint256, bool, uint256, uint256, bytes, uint256));\n\n            sellToUniswapV4(recipient, sellToken, bps, feeOnTransfer, hashMul, hashMod, fills, amountOutMin);\n        } else if (action == uint32(ISettlerActions.MAKERPSM.selector)) {\n            (address recipient, uint256 bps, bool buyGem, uint256 amountOutMin) =\n                abi.decode(data, (address, uint256, bool, uint256));\n\n            sellToMakerPsm(recipient, bps, buyGem, amountOutMin);\n        } else if (action == uint32(ISettlerActions.BALANCERV3.selector)) {\n            (\n                address recipient,\n                IERC20 sellToken,\n                uint256 bps,\n                bool feeOnTransfer,\n                uint256 hashMul,\n                uint256 hashMod,\n                bytes memory fills,\n                uint256 amountOutMin\n            ) = abi.decode(data, (address, IERC20, uint256, bool, uint256, uint256, bytes, uint256));\n\n            sellToBalancerV3(recipient, sellToken, bps, feeOnTransfer, hashMul, hashMod, fills, amountOutMin);\n        } else if (action == uint32(ISettlerActions.MAVERICKV2.selector)) {\n            (\n                address recipient,\n                IERC20 sellToken,\n                uint256 bps,\n                IMaverickV2Pool pool,\n                bool tokenAIn,\n                uint256 minBuyAmount\n            ) = abi.decode(data, (address, IERC20, uint256, IMaverickV2Pool, bool, uint256));\n\n            sellToMaverickV2(recipient, sellToken, bps, pool, tokenAIn, minBuyAmount);\n        } else if (action == uint32(ISettlerActions.EKUBO.selector)) {\n            (\n                address recipient,\n                IERC20 sellToken,\n                uint256 bps,\n                bool feeOnTransfer,\n                uint256 hashMul,\n                uint256 hashMod,\n                bytes memory fills,\n                uint256 amountOutMin\n            ) = abi.decode(data, (address, IERC20, uint256, bool, uint256, uint256, bytes, uint256));\n\n            sellToEkubo(recipient, sellToken, bps, feeOnTransfer, hashMul, hashMod, fills, amountOutMin);\n        } else if (action == uint32(ISettlerActions.DODOV2.selector)) {\n            (address recipient, IERC20 sellToken, uint256 bps, IDodoV2 dodo, bool quoteForBase, uint256 minBuyAmount) =\n                abi.decode(data, (address, IERC20, uint256, IDodoV2, bool, uint256));\n\n            sellToDodoV2(recipient, sellToken, bps, dodo, quoteForBase, minBuyAmount);\n        } else if (action == uint32(ISettlerActions.DODOV1.selector)) {\n            (IERC20 sellToken, uint256 bps, IDodoV1 dodo, bool quoteForBase, uint256 minBuyAmount) =\n                abi.decode(data, (IERC20, uint256, IDodoV1, bool, uint256));\n\n            sellToDodoV1(sellToken, bps, dodo, quoteForBase, minBuyAmount);\n        } else {\n            return false;\n        }\n        return true;\n    }\n\n    function _uniV3ForkInfo(uint8 forkId)\n        internal\n        pure\n        override\n        returns (address factory, bytes32 initHash, uint32 callbackSelector)\n    {\n        if (forkId == uniswapV3ForkId) {\n            factory = uniswapV3MainnetFactory;\n            initHash = uniswapV3InitHash;\n            callbackSelector = uint32(IUniswapV3Callback.uniswapV3SwapCallback.selector);\n        } else if (forkId == pancakeSwapV3ForkId) {\n            factory = pancakeSwapV3Factory;\n            initHash = pancakeSwapV3InitHash;\n            callbackSelector = uint32(IPancakeSwapV3Callback.pancakeV3SwapCallback.selector);\n        } else if (forkId == sushiswapV3ForkId) {\n            factory = sushiswapV3MainnetFactory;\n            initHash = uniswapV3InitHash;\n            callbackSelector = uint32(IUniswapV3Callback.uniswapV3SwapCallback.selector);\n        } else if (forkId == solidlyV3ForkId) {\n            factory = solidlyV3Factory;\n            initHash = solidlyV3InitHash;\n            callbackSelector = uint32(ISolidlyV3Callback.solidlyV3SwapCallback.selector);\n        } else {\n            revertUnknownForkId(forkId);\n        }\n    }\n\n    /*\n    function _curveFactory() internal pure override returns (address) {\n        return 0x0c0e5f2fF0ff18a3be9b835635039256dC4B4963;\n    }\n    */\n\n    function _POOL_MANAGER() internal pure override returns (IPoolManager) {\n        return MAINNET_POOL_MANAGER;\n    }\n}\n\n// src/chains/Mainnet/TakerSubmitted.sol\n\n// Solidity inheritance is stupid\n\n/// @custom:security-contact security@0x.org\ncontract MainnetSettler is Settler, MainnetMixin {\n    constructor(bytes20 gitCommit) SettlerBase(gitCommit) {}\n\n    function _dispatchVIP(uint256 action, bytes calldata data) internal override DANGEROUS_freeMemory returns (bool) {\n        if (super._dispatchVIP(action, data)) {\n            return true;\n        } else if (action == uint32(ISettlerActions.UNISWAPV4_VIP.selector)) {\n            (\n                address recipient,\n                bool feeOnTransfer,\n                uint256 hashMul,\n                uint256 hashMod,\n                bytes memory fills,\n                ISignatureTransfer.PermitTransferFrom memory permit,\n                bytes memory sig,\n                uint256 amountOutMin\n            ) = abi.decode(\n                data, (address, bool, uint256, uint256, bytes, ISignatureTransfer.PermitTransferFrom, bytes, uint256)\n            );\n\n            sellToUniswapV4VIP(recipient, feeOnTransfer, hashMul, hashMod, fills, permit, sig, amountOutMin);\n        } else if (action == uint32(ISettlerActions.BALANCERV3_VIP.selector)) {\n            (\n                address recipient,\n                bool feeOnTransfer,\n                uint256 hashMul,\n                uint256 hashMod,\n                bytes memory fills,\n                ISignatureTransfer.PermitTransferFrom memory permit,\n                bytes memory sig,\n                uint256 amountOutMin\n            ) = abi.decode(\n                data, (address, bool, uint256, uint256, bytes, ISignatureTransfer.PermitTransferFrom, bytes, uint256)\n            );\n\n            sellToBalancerV3VIP(recipient, feeOnTransfer, hashMul, hashMod, fills, permit, sig, amountOutMin);\n        } else if (action == uint32(ISettlerActions.MAVERICKV2_VIP.selector)) {\n            (\n                address recipient,\n                bytes32 salt,\n                bool tokenAIn,\n                ISignatureTransfer.PermitTransferFrom memory permit,\n                bytes memory sig,\n                uint256 minBuyAmount\n            ) = abi.decode(data, (address, bytes32, bool, ISignatureTransfer.PermitTransferFrom, bytes, uint256));\n\n            sellToMaverickV2VIP(recipient, salt, tokenAIn, permit, sig, minBuyAmount);\n        } else if (action == uint32(ISettlerActions.EKUBO_VIP.selector)) {\n            (\n                address recipient,\n                bool feeOnTransfer,\n                uint256 hashMul,\n                uint256 hashMod,\n                bytes memory fills,\n                ISignatureTransfer.PermitTransferFrom memory permit,\n                bytes memory sig,\n                uint256 amountOutMin\n            ) = abi.decode(\n                data, (address, bool, uint256, uint256, bytes, ISignatureTransfer.PermitTransferFrom, bytes, uint256)\n            );\n\n            sellToEkuboVIP(recipient, feeOnTransfer, hashMul, hashMod, fills, permit, sig, amountOutMin);\n        } /* else if (action == uint32(ISettlerActions.CURVE_TRICRYPTO_VIP.selector)) {\n            (\n                address recipient,\n                uint80 poolInfo,\n                ISignatureTransfer.PermitTransferFrom memory permit,\n                bytes memory sig,\n                uint256 minBuyAmount\n            ) = abi.decode(data, (address, uint80, ISignatureTransfer.PermitTransferFrom, bytes, uint256));\n            sellToCurveTricryptoVIP(recipient, poolInfo, permit, sig, minBuyAmount);\n        } */ else {\n            return false;\n        }\n        return true;\n    }\n\n    // Solidity inheritance is stupid\n    function _isRestrictedTarget(address target)\n        internal\n        pure\n        override(Settler, Permit2PaymentAbstract)\n        returns (bool)\n    {\n        return super._isRestrictedTarget(target);\n    }\n\n    function _dispatch(uint256 i, uint256 action, bytes calldata data)\n        internal\n        override(SettlerAbstract, SettlerBase, MainnetMixin)\n        returns (bool)\n    {\n        return super._dispatch(i, action, data);\n    }\n\n    function _msgSender() internal view override(Settler, AbstractContext) returns (address) {\n        return super._msgSender();\n    }\n}\n"
    }
  },
  "settings": {
    "remappings": [
      "@solmate/=lib/solmate/src/",
      "@permit2/=lib/permit2/src/",
      "@forge-std/=lib/forge-std/src/",
      "@forge-gas-snapshot/=lib/forge-gas-snapshot/src/",
      "@uniswapv4/=lib/v4-core/src/",
      "forge-std/src/=lib/forge-std/src/",
      "solmate/=lib/solmate/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 2000,
      "details": {
        "constantOptimizer": true,
        "yul": true
      }
    },
    "metadata": {
      "useLiteralContent": false,
      "bytecodeHash": "none",
      "appendCBOR": false
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "evmVersion": "cancun",
    "viaIR": true,
    "libraries": {}
  }
}}