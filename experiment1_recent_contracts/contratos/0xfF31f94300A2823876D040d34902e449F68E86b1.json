{{
  "language": "Vyper",
  "sources": {
    "src/interfaces/AggregatorV3Interface.vyi": {
      "content": "# @version 0.4.1\n\n\n# ============================================================================================\n# View functions\n# ============================================================================================\n\n\n@external\n@pure\ndef decimals() -> uint8:\n    \"\"\"\n    @notice Returns the number of decimals used by the price feed.\n    \"\"\"\n    ...\n\n\n@external\n@pure\ndef version() -> uint256:\n    \"\"\"\n    @notice Returns the version of the price feed.\n    \"\"\"\n    ...\n\n\n@external\n@pure\ndef description() -> String[18]:\n    \"\"\"\n    @notice Returns a description of the price feed.\n    \"\"\"\n    ...\n\n\n@external\n@view\ndef latestRoundData() -> (uint80, int256, uint256, uint256, uint80):\n    \"\"\"\n    @notice Returns the latest round data from the price feed\n    @return The round ID\n    @return The price of ASF in USD\n    @return The timestamp of the start of the round\n    @return The timestamp of the last update\n    @return The round ID in which the price was answered\n    \"\"\"\n    ...\n\n\n@external\n@view\ndef latestAnswer() -> int256:\n    \"\"\"\n    @notice Returns the latest price from the price feed\n    @return The price of ASF in USD\n    \"\"\"\n    ...\n",
      "sha256sum": "fc9a454d8233ea10a5f817da8b002b99f2f4c9e087af66a981d9fa5a8a18d0db"
    },
    "src/interfaces/IVEASF.vyi": {
      "content": "# @version 0.4.1\n\n\n@external\ndef lock(account: address, amount: uint256, weeks: uint256) -> bool:\n    ...\n",
      "sha256sum": "a160d9767d928262fa854365ffc3dfc172996903c0d8cf9fe8f6d78b613cbdd9"
    },
    "src/interfaces/IDASF.vyi": {
      "content": "# @version 0.4.1\n\n\n@external\ndef burn(owner: address, amount: uint256):\n    ...\n",
      "sha256sum": "667cdc2ed130df6b7c814c6850dc2a51df7b1c3c10f5b823f851e6a5aeefff4a"
    },
    "src/interfaces/IRedemption.vyi": {
      "content": "# @version 0.4.1\n\n\n# ============================================================================================\n# Events\n# ============================================================================================\n\n\nevent Redeem:\n    sender: address\n    recipient: indexed(address)\n    amount: uint256\n    coin_required: uint256\n    weeks: uint256\n\n\nevent SetPayee:\n    new_payee: address\n\n\nevent SetDiscount:\n    min_discount: uint256\n    max_discount: uint256\n\n\nevent SetMinLockWeeks:\n    min_lock_weeks: uint256\n\n\nevent SetPrivileged:\n    user: address\n    privileged: bool\n\n\nevent Killed:\n    balance: uint256\n\n\nevent Sweep:\n    token: address\n    amount: uint256\n\n\n# ============================================================================================\n# View functions\n# ============================================================================================\n\n\n@external\n@view\ndef coin_required(amount: uint256, weeks: uint256) -> uint256:\n    \"\"\"\n    @notice Estimate the required amount of USA.D to redeem the amount of dASF for ASF\n    @param amount Amount of dASF\n    @param weeks Number of weeks to lock the ASF for\n    @return Amount of USA.D required\n    \"\"\"\n    ...\n\n\n@external\n@view\ndef discount(weeks: uint256) -> uint256:\n    \"\"\"\n    @notice Get the discount for a given number of weeks\n    @param weeks Number of weeks to lock the ASF for\n    @return Discount in percentage (18 decimals)\n    \"\"\"\n    ...\n\n\n@external\n@view\ndef latest_price() -> uint256:\n    \"\"\"\n    @notice Get the latest price of ASF in USA.D\n    @return Price of ASF in USA.D (18 decimals)\n    \"\"\"\n    ...\n\n\n# ============================================================================================\n# Mutative functions\n# ============================================================================================\n\n\n@external\ndef redeem(\n    amount: uint256,\n    weeks: uint256,\n    max_coin_required: uint256 = max_value(uint256),\n    recipient: address = msg.sender,\n):\n    \"\"\"\n    @notice Redeem your dASF for ASF using a USA.D\n    @param amount amount of dASF to spend\n    @param weeks number of weeks to lock the ASF for\n    @param max_coin_required maximum amount of USA.d to pay\n    @param recipient of the exercised ASF\n    \"\"\"\n    ...\n\n\n# ============================================================================================\n# Privileged user functions\n# ============================================================================================\n\n\n@external\ndef privileged_redeem(amount: uint256, recipient: address = msg.sender):\n    \"\"\"\n    @notice Redeem your dASF for ASF for free\n    @param amount amount of dASF to spend\n    @param recipient of the exercised ASF\n    \"\"\"\n    ...\n\n\n# ============================================================================================\n# Owner functions\n# ============================================================================================\n\n\n@external\ndef set_payee(new_payee: address):\n    \"\"\"\n    @notice set the payee of the USA.D used for redemptions\n    @param new_payee the new payee\n    \"\"\"\n    ...\n\n\n@external\ndef set_discount(min_discount: uint256, max_discount: uint256):\n    \"\"\"\n    @notice set the min and max discount for redemptions\n    @param min_discount the minimum discount in percentage (18 decimals)\n    @param max_discount the maximum discount in percentage (18 decimals)\n    \"\"\"\n    ...\n\n\n@external\ndef set_min_lock_weeks(min_lock_weeks: uint256):\n    \"\"\"\n    @notice set the minimum lock weeks for redemptions\n    @param min_lock_weeks the minimum lock weeks\n    \"\"\"\n    ...\n\n\n@external\ndef set_privileged(user: address, privileged: bool):\n    \"\"\"\n    @notice set the privileged status of a user\n    @param user the user to set\n    @param privileged the privileged status\n    \"\"\"\n    ...\n\n\n@external\ndef kill():\n    \"\"\"\n    @dev stop the contract from being used and reclaim ASF\n    \"\"\"\n    ...\n\n\n@external\ndef sweep(token: address) -> uint256:\n    \"\"\"\n    @notice sweep any token other than ASF to the owner\n    @param token address of the token to sweep\n    @return amount of token swept\n    \"\"\"\n    ...\n",
      "sha256sum": "05f049413a445228b47c50665b43d4658681d6bde564f1c386af8e9a8d87e254"
    },
    "src/ownable_2step.vy": {
      "content": "# @version 0.4.1\n\n\"\"\"\n@title Ownable 2-step\n@license MIT\n@author yearn.finance, asymmetry.finance\n@notice ownable_2step.vy is a two-step ownable contract that allows for a two-step transfer of ownership\n\"\"\"\n\n\n# ============================================================================================\n# Events\n# ============================================================================================\n\n\nevent PendingOwnershipTransfer:\n    old_owner: address\n    new_owner: address\n\n\nevent OwnershipTransferred:\n    old_owner: address\n    new_owner: address\n\n\n# ============================================================================================\n# Storage\n# ============================================================================================\n\n\nowner: public(address)\npending_owner: public(address)\n\n\n# ============================================================================================\n# Constructor\n# ============================================================================================\n\n\n@deploy\ndef __init__(owner: address):\n    \"\"\"\n    @notice Initialize the contract\n    @dev Sets the deployer as the initial owner\n    @param owner The address of the initial owner\n    \"\"\"\n    assert owner != empty(address), \"!owner\"\n    self._transfer_ownership(owner)\n\n\n# ============================================================================================\n# Owner functions\n# ============================================================================================\n\n\n@external\ndef transfer_ownership(new_owner: address):\n    \"\"\"\n    @notice Starts the ownership transfer of the contract to a new account\n    @dev Only callable by the current `owner`\n    @dev Replaces the pending transfer if there is one\n    @param new_owner The address of the new owner\n    \"\"\"\n    self._check_owner()\n    self.pending_owner = new_owner\n    log PendingOwnershipTransfer(old_owner=self.owner, new_owner=new_owner)\n\n\n@external\ndef accept_ownership():\n    \"\"\"\n    @notice The new owner accepts the ownership transfer\n    @dev Only callable by the current `pending_owner`\n    \"\"\"\n    assert self.pending_owner == msg.sender, \"!new owner\"\n    self._transfer_ownership(msg.sender)\n\n\n# ============================================================================================\n# Internal functions\n# ============================================================================================\n\n\n@internal\ndef _check_owner():\n    assert msg.sender == self.owner, \"!owner\"\n\n\n@internal\ndef _transfer_ownership(new_owner: address):\n    self.pending_owner = empty(address)\n    old_owner: address = self.owner\n    self.owner = new_owner\n    log OwnershipTransferred(old_owner=old_owner, new_owner=new_owner)\n",
      "sha256sum": "05e5065b964a509481435b5aacb28d1df6d0785338b85550111f66f44c742825"
    },
    "src/redemption.vy": {
      "content": "# @version 0.4.1\n\n\"\"\"\n@title dASF Redemptions\n@license MIT\n@author yearn.finance, asymmetry.finance (johnnyonline)\n@notice\n    redemption.vy is used to redeem dASF for ASF using USA.d\n    ASF/USD price is fetched from Curve and Chainlink oracles\n    ASF is sold at a discounted rate, which is determined by the lock period\n\"\"\"\n\nfrom ethereum.ercs import IERC20\n\nfrom interfaces import AggregatorV3Interface\nfrom interfaces import IVEASF\nfrom interfaces import IDASF\nfrom interfaces import IRedemption\n\nimport ownable_2step as ownable\n\n\n# ============================================================================================\n# Modules\n# ============================================================================================\n\n\ninitializes: ownable\nexports: (\n    ownable.owner,\n    ownable.pending_owner,\n    ownable.transfer_ownership,\n    ownable.accept_ownership,\n)\n\n\n# ============================================================================================\n# Interfaces\n# ============================================================================================\n\n\nimplements: IRedemption\n\n\n# ============================================================================================\n# Constants\n# ============================================================================================\n\n\nWAD: constant(uint256) = 10**18\nMAX_WEEKS: constant(uint256) = 52\n\n\n# ============================================================================================\n# Immutable\n# ============================================================================================\n\n\nPRICE_FEED: public(immutable(AggregatorV3Interface))\nASF: public(immutable(IERC20))\nVEASF: public(immutable(IVEASF))\nDASF: public(immutable(IDASF))\nUSAD: public(immutable(IERC20))\n\n\n# ============================================================================================\n# Storage\n# ============================================================================================\n\n\nkilled: public(bool)\npayee: public(address)\nmin_discount: public(uint256)\nmax_discount: public(uint256)\nmin_lock_weeks: public(uint256)\nprivileged: public(HashMap[address, bool])\n\n\n# ============================================================================================\n# Constructor\n# ============================================================================================\n\n\n@deploy\ndef __init__(\n    owner: address,\n    payee: address,\n    price_feed: address,\n    asf: address,\n    veasf: address,\n    dasf: address,\n    usad: address,\n):\n    \"\"\"\n    @notice Initialize the contract\n    @param owner Address of the owner\n    @param payee Address of the payee\n    @param price_feed Address of the price feed\n    @param asf Address of the ASF token\n    @param veasf Address of the veASF token\n    @param dasf Address of the dASF token\n    @param usad Address of the USA.d token\n    \"\"\"\n    ownable.__init__(owner)\n    assert payee != empty(address), \"!payee\"\n\n    self.min_discount = 20 * 10**16  # 20%\n    self.max_discount = 80 * 10**16  # 80%\n    self.min_lock_weeks = 0\n\n    self.payee = payee\n\n    PRICE_FEED = AggregatorV3Interface(price_feed)\n    ASF = IERC20(asf)\n    VEASF = IVEASF(veasf)\n    DASF = IDASF(dasf)\n    USAD = IERC20(usad)\n\n    assert extcall ASF.approve(\n        veasf, max_value(uint256), default_return_value=True\n    )\n\n    log IRedemption.SetDiscount(\n        min_discount=self.min_discount, max_discount=self.max_discount\n    )\n    log IRedemption.SetMinLockWeeks(min_lock_weeks=self.min_lock_weeks)\n    log IRedemption.SetPayee(new_payee=payee)\n\n\n# ============================================================================================\n# View functions\n# ============================================================================================\n\n\n@external\n@view\ndef coin_required(amount: uint256, weeks: uint256 = MAX_WEEKS) -> uint256:\n    \"\"\"\n    @notice Estimate the required amount of USA.d to redeem the amount of dASF for ASF\n    @param amount Amount of dASF\n    @param weeks Number of weeks to lock the ASF for\n    @return Amount of USA.d required\n    \"\"\"\n    return self._coin_required(amount, weeks)\n\n\n@external\n@view\ndef discount(weeks: uint256) -> uint256:\n    \"\"\"\n    @notice Get the discount for a given number of weeks\n    @param weeks Number of weeks to lock the ASF for\n    @return Discount in percentage (18 decimals)\n    \"\"\"\n    return self._discount(weeks)\n\n\n@external\n@view\ndef latest_price() -> uint256:\n    \"\"\"\n    @notice Get the latest price of ASF in USA.d\n    @return Price of ASF in USA.d (18 decimals)\n    \"\"\"\n    return self._latest_price()\n\n\n# ============================================================================================\n# Mutative functions\n# ============================================================================================\n\n\n@external\ndef redeem(\n    amount: uint256,\n    weeks: uint256 = MAX_WEEKS,\n    max_coin_required: uint256 = max_value(uint256),\n    recipient: address = msg.sender,\n):\n    \"\"\"\n    @notice Redeem your dASF for ASF using a USA.d\n    @dev If locking, rounds down the amount of dASF to avoid overpaying\n    @param amount amount of dASF to spend\n    @param weeks number of weeks to lock the ASF for\n    @param max_coin_required maximum amount of USA.d to pay\n    @param recipient of the exercised ASF\n    \"\"\"\n    self._check_killed()\n    assert staticcall ASF.balanceOf(self) >= amount, \"!ASF\"\n\n    rounded_amount: uint256 = amount\n    if weeks > 0:\n        rounded_amount -= amount % WAD\n\n    coin_required: uint256 = self._coin_required(rounded_amount, weeks)\n    assert coin_required > 0, \"!coin\"\n    assert coin_required <= max_coin_required, \"slippage rekt you\"\n\n    extcall DASF.burn(msg.sender, rounded_amount)\n    assert extcall USAD.transferFrom(\n        msg.sender, self.payee, coin_required, default_return_value=True\n    )\n\n    if weeks == 0:\n        assert extcall ASF.transfer(\n            recipient, rounded_amount, default_return_value=True\n        )\n    else:\n        assert extcall VEASF.lock(\n            recipient, rounded_amount // WAD, weeks, default_return_value=True\n        )\n\n    log IRedemption.Redeem(\n        sender=msg.sender,\n        recipient=recipient,\n        amount=rounded_amount,\n        coin_required=coin_required,\n        weeks=weeks,\n    )\n\n\n# ============================================================================================\n# Privileged user functions\n# ============================================================================================\n\n\n@external\ndef privileged_redeem(amount: uint256, recipient: address = msg.sender):\n    \"\"\"\n    @notice Redeem your dASF for ASF for free\n    @dev Only callable by privileged users\n    @param amount amount of dASF to spend\n    @param recipient of the exercised ASF\n    \"\"\"\n    self._check_killed()\n    assert self.privileged[msg.sender], \"!privileged\"\n    assert staticcall ASF.balanceOf(self) >= amount, \"!ASF\"\n\n    extcall DASF.burn(msg.sender, amount)\n    assert extcall ASF.transfer(recipient, amount, default_return_value=True)\n\n    log IRedemption.Redeem(\n        sender=msg.sender,\n        recipient=recipient,\n        amount=amount,\n        coin_required=0,\n        weeks=0,\n    )\n\n\n# ============================================================================================\n# Owner functions\n# ============================================================================================\n\n\n@external\ndef set_payee(new_payee: address):\n    \"\"\"\n    @notice Set the payee of the USA.d used for redemptions\n    @dev Only callable by the owner\n    @param new_payee the new payee\n    \"\"\"\n    ownable._check_owner()\n    assert new_payee != empty(address), \"!payee\"\n\n    self.payee = new_payee\n\n    log IRedemption.SetPayee(new_payee=new_payee)\n\n\n@external\ndef set_discount(min_discount: uint256, max_discount: uint256):\n    \"\"\"\n    @notice Set the min and max discount for redemptions\n    @dev Only callable by the owner\n    @param min_discount the minimum discount in percentage (18 decimals)\n    @param max_discount the maximum discount in percentage (18 decimals)\n    \"\"\"\n    ownable._check_owner()\n    assert min_discount < max_discount, \"!min_discount\"\n    assert max_discount < WAD, \"!max_discount\"\n\n    self.min_discount = min_discount\n    self.max_discount = max_discount\n\n    log IRedemption.SetDiscount(\n        min_discount=min_discount, max_discount=max_discount\n    )\n\n\n@external\ndef set_min_lock_weeks(min_lock_weeks: uint256):\n    \"\"\"\n    @notice Set the minimum lock weeks for redemptions\n    @dev Only callable by the owner\n    @param min_lock_weeks the minimum lock weeks\n    \"\"\"\n    ownable._check_owner()\n    assert min_lock_weeks <= MAX_WEEKS, \"!min_lock_weeks\"\n\n    self.min_lock_weeks = min_lock_weeks\n\n    log IRedemption.SetMinLockWeeks(min_lock_weeks=min_lock_weeks)\n\n\n@external\ndef set_privileged(user: address, privileged: bool):\n    \"\"\"\n    @notice Set the privileged status of a user\n    @dev Only callable by the owner\n    @param user the user to set\n    @param privileged the privileged status\n    \"\"\"\n    ownable._check_owner()\n    self.privileged[user] = privileged\n\n    log IRedemption.SetPrivileged(user=user, privileged=privileged)\n\n\n@external\ndef kill():\n    \"\"\"\n    @notice Stop the contract from being used and reclaim ASF\n    @dev Only callable by the owner\n    \"\"\"\n    self._check_killed()\n    ownable._check_owner()\n\n    self.killed = True\n\n    balance: uint256 = staticcall ASF.balanceOf(self)\n    if balance > 0:\n        assert extcall ASF.transfer(\n            ownable.owner, balance, default_return_value=True\n        )\n\n    log IRedemption.Killed(balance=balance)\n\n\n@external\ndef sweep(token: address) -> uint256:\n    \"\"\"\n    @notice Sweep any token other than ASF to the owner\n    @dev Only callable by the owner\n    @param token address of the token to sweep\n    @return amount of token swept\n    \"\"\"\n    assert self.killed or token != ASF.address, \"!token\"\n    ownable._check_owner()\n\n    amount: uint256 = staticcall IERC20(token).balanceOf(self)\n    assert amount > 0, \"!balance\"\n\n    assert extcall IERC20(token).transfer(\n        ownable.owner, amount, default_return_value=True\n    )\n\n    log IRedemption.Sweep(token=token, amount=amount)\n\n    return amount\n\n\n# ============================================================================================\n# Internal functions\n# ============================================================================================\n\n\n@internal\n@view\ndef _coin_required(amount: uint256, weeks: uint256) -> uint256:\n    assert weeks >= self.min_lock_weeks, \"!weeks\"\n    return (\n        amount\n        * self._latest_price() // WAD\n        * (WAD - self._discount(weeks)) // WAD\n    )\n\n\n@internal\n@view\ndef _discount(weeks: uint256) -> uint256:\n    min_discount: uint256 = self.min_discount\n    max_discount: uint256 = self.max_discount\n    return min_discount + (\n        (max_discount - min_discount) * min(weeks, MAX_WEEKS) // MAX_WEEKS\n    )\n\n\n@internal\n@view\ndef _latest_price() -> uint256:\n    return convert(staticcall PRICE_FEED.latestAnswer(), uint256)\n\n\n@internal\ndef _check_killed():\n    assert self.killed == False, \"killed\"\n",
      "sha256sum": "b4a2a166f4f22c407d4d80e964353ac100618cc49fb2b8e75470b7b95c5f49b1"
    }
  },
  "settings": {
    "outputSelection": {
      "src/redemption.vy": [
        "evm.bytecode",
        "evm.deployedBytecode",
        "abi"
      ]
    },
    "search_paths": [
      "."
    ]
  },
  "compiler_version": "v0.4.1+commit.8a93dd27",
  "integrity": "0341017c159eaa2b23147c4d11c6bdcdaf01d87b8b0d20b6aedd054cf205094a"
}}