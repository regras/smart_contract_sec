{{
  "language": "Solidity",
  "sources": {
    "src/libraries/CurvePoolUtil.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.20;\n\nimport \"../interfaces/ICurvePool.sol\";\nimport \"../interfaces/ICurveNGPool.sol\";\nimport \"../interfaces/IStableSwapNG.sol\";\nimport \"../interfaces/IPrincipalToken.sol\";\nimport \"./RayMath.sol\";\nimport \"openzeppelin-math/Math.sol\";\n\n/**\n * @title CurvePoolUtil library\n * @author Spectra Finance\n * @notice Provides miscellaneous utils for computations related to Curve CryptoSwap pools.\n */\nlibrary CurvePoolUtil {\n    using Math for uint256;\n    using RayMath for uint256;\n\n    error SolutionNotFound();\n    error FailedToFetchExpectedLPTokenAmount();\n    error FailedToFetchExpectedCoinAmount();\n\n    /// @notice Decimal precision used internally in the Curve AMM\n    uint256 public constant CURVE_DECIMALS = 18;\n    /// @notice Base unit for Curve AMM calculations\n    uint256 public constant CURVE_UNIT = 1e18;\n    /// @notice Make rounding errors favoring other LPs a tiny bit\n    uint256 private constant APPROXIMATION_DECREMENT = 1;\n    /// @notice Maximal number of iterations in the binary search algorithm\n    uint256 private constant MAX_ITERATIONS_BINSEARCH = 255;\n\n    /**\n     * @notice Returns the expected LP token amount received for depositing given amounts of IBT and PT\n     * @notice Method to be used with legacy Curve Cryptoswap pools\n     * @param _curvePool The address of the Curve Pool in which liquidity will be deposited\n     * @param _amounts Array containing the amounts of IBT and PT to deposit in the Curve Pool\n     * @return minMintAmount The amount of expected LP tokens received for depositing the liquidity in the pool\n     */\n    function previewAddLiquidity(\n        address _curvePool,\n        uint256[2] memory _amounts\n    ) external view returns (uint256 minMintAmount) {\n        (bool success, bytes memory responseData) = _curvePool.staticcall(\n            abi.encodeCall(ICurvePool(address(0)).calc_token_amount, (_amounts))\n        );\n        if (!success) {\n            revert FailedToFetchExpectedLPTokenAmount();\n        }\n        minMintAmount = abi.decode(responseData, (uint256));\n    }\n\n    /**\n     * @notice Returns the expected LP token amount received for depositing given amounts of IBT and PT\n     * @notice Method to be used with legacy Curve Cryptoswap NG pools\n     * @param _curvePool The address of the Curve Pool in which liquidity will be deposited\n     * @param _amounts Array containing the amounts of IBT and PT to deposit in the Curve Pool\n     * @return minMintAmount The amount of expected LP tokens received for depositing the liquidity in the pool\n     */\n    function previewAddLiquidityNG(\n        address _curvePool,\n        uint256[2] memory _amounts\n    ) external view returns (uint256 minMintAmount) {\n        (bool success, bytes memory responseData) = _curvePool.staticcall(\n            abi.encodeCall(ICurveNGPool(address(0)).calc_token_amount, (_amounts, true))\n        );\n        if (!success) {\n            revert FailedToFetchExpectedLPTokenAmount();\n        }\n        minMintAmount = abi.decode(responseData, (uint256));\n    }\n\n    /**\n     * @notice Returns the expected LP token amount received for depositing given amounts of IBT and PT\n     * @notice Method to be used with StableSwap NG pools\n     * @param _curvePool The address of the Curve Pool in which liquidity will be deposited\n     * @param _amounts Array containing the amounts of IBT and PT to deposit in the Curve Pool\n     * @return minMintAmount The amount of expected LP tokens received for depositing the liquidity in the pool\n     */\n    function previewAddLiquiditySNG(\n        address _curvePool,\n        uint256[] memory _amounts\n    ) external view returns (uint256 minMintAmount) {\n        // @dev set the is_deposit to true\n        (bool success, bytes memory responseData) = _curvePool.staticcall(\n            abi.encodeCall(IStableSwapNG(address(0)).calc_token_amount, (_amounts, true))\n        );\n        if (!success) {\n            revert FailedToFetchExpectedLPTokenAmount();\n        }\n        minMintAmount = abi.decode(responseData, (uint256));\n    }\n\n    /**\n     * @notice Returns the IBT and PT amounts received for burning a given amount of LP tokens\n     * @notice Method to be used with legacy Curve Cryptoswap pools\n     * @param _curvePool The address of the curve pool\n     * @param _lpTokenAmount The amount of the lp token to burn\n     * @return minAmounts The expected respective amounts of IBT and PT withdrawn from the curve pool\n     */\n    function previewRemoveLiquidity(\n        address _curvePool,\n        uint256 _lpTokenAmount\n    ) external view returns (uint256[2] memory minAmounts) {\n        address lpToken = ICurvePool(_curvePool).token();\n        uint256 totalSupply = IERC20(lpToken).totalSupply();\n        (uint256 ibtBalance, uint256 ptBalance) = _getCurvePoolBalances(_curvePool);\n        // decrement following what Curve is doing\n        if (_lpTokenAmount > APPROXIMATION_DECREMENT && totalSupply != 0) {\n            _lpTokenAmount -= APPROXIMATION_DECREMENT;\n            minAmounts = [\n                (ibtBalance * _lpTokenAmount) / totalSupply,\n                (ptBalance * _lpTokenAmount) / totalSupply\n            ];\n        } else {\n            minAmounts = [uint256(0), uint256(0)];\n        }\n    }\n\n    /**\n     * @notice Returns the IBT and PT amounts received for burning a given amount of LP tokens\n     * @notice Method to be used with Curve Cryptoswap NG pools\n     * @param _curvePool The address of the curve pool\n     * @param _lpTokenAmount The amount of the lp token to burn\n     * @return minAmounts The expected respective amounts of IBT and PT withdrawn from the curve pool\n     */\n    function previewRemoveLiquidityNG(\n        address _curvePool,\n        uint256 _lpTokenAmount\n    ) external view returns (uint256[2] memory minAmounts) {\n        uint256 totalSupply = ICurveNGPool(_curvePool).totalSupply();\n        (uint256 ibtBalance, uint256 ptBalance) = _getCurvePoolBalances(_curvePool);\n        // reproduces Curve implementation\n        if (_lpTokenAmount == totalSupply) {\n            minAmounts = [ibtBalance, ptBalance];\n        } else if (_lpTokenAmount > APPROXIMATION_DECREMENT && totalSupply != 0) {\n            _lpTokenAmount -= APPROXIMATION_DECREMENT;\n            minAmounts = [\n                ibtBalance.mulDiv(_lpTokenAmount, totalSupply),\n                ptBalance.mulDiv(_lpTokenAmount, totalSupply)\n            ];\n        } else {\n            minAmounts = [uint256(0), uint256(0)];\n        }\n    }\n\n    /**\n     * @notice Returns the IBT and PT amounts received for burning a given amount of LP tokens\n     * @notice Method to be used with StableSwap NG pools\n     * @param _curvePool The address of the curve pool\n     * @param _lpTokenAmount The amount of the lp token to burn\n     * @return minAmounts The expected respective amounts of IBT and PT withdrawn from the curve pool\n     */\n    function previewRemoveLiquiditySNG(\n        address _curvePool,\n        uint256 _lpTokenAmount\n    ) external view returns (uint256[] memory) {\n        uint256 totalSupply = IERC20(_curvePool).totalSupply();\n        (uint256 ibtBalance, uint256 ptBalance) = _getCurvePoolBalances(_curvePool);\n        // decrement following what Curve is doing\n        uint256[] memory minAmounts = new uint256[](2);\n        if (_lpTokenAmount > APPROXIMATION_DECREMENT && totalSupply != 0) {\n            _lpTokenAmount -= APPROXIMATION_DECREMENT;\n            minAmounts[0] = (ibtBalance * _lpTokenAmount) / totalSupply;\n            minAmounts[1] = (ptBalance * _lpTokenAmount) / totalSupply;\n        } else {\n            minAmounts[0] = 0;\n            minAmounts[1] = 0;\n        }\n        return minAmounts;\n    }\n\n    /**\n     * @notice Returns the amount of coin i received for burning a given amount of LP tokens\n     * @notice Method to be used with legacy Curve CryptoSwap pools\n     * @param _curvePool The address of the curve pool\n     * @param _lpTokenAmount The amount of the LP tokens to burn\n     * @param _i The index of the unique coin to withdraw\n     * @return minAmount The expected amount of coin i withdrawn from the curve pool\n     */\n    function previewRemoveLiquidityOneCoin(\n        address _curvePool,\n        uint256 _lpTokenAmount,\n        uint256 _i\n    ) external view returns (uint256 minAmount) {\n        (bool success, bytes memory responseData) = _curvePool.staticcall(\n            abi.encodeCall(ICurvePool(address(0)).calc_withdraw_one_coin, (_lpTokenAmount, _i))\n        );\n        if (!success) {\n            revert FailedToFetchExpectedCoinAmount();\n        }\n        minAmount = abi.decode(responseData, (uint256));\n    }\n\n    /**\n     * @notice Returns the amount of coin i received for burning a given amount of LP tokens\n     * @notice Method to be used with Curve NG pools\n     * @param _curvePool The address of the curve pool\n     * @param _lpTokenAmount The amount of the LP tokens to burn\n     * @param _i The index of the unique coin to withdraw\n     * @return minAmount The expected amount of coin i withdrawn from the curve pool\n     */\n    function previewRemoveLiquidityOneCoinNG(\n        address _curvePool,\n        uint256 _lpTokenAmount,\n        uint256 _i\n    ) external view returns (uint256 minAmount) {\n        (bool success, bytes memory responseData) = _curvePool.staticcall(\n            abi.encodeCall(ICurveNGPool(address(0)).calc_withdraw_one_coin, (_lpTokenAmount, _i))\n        );\n        if (!success) {\n            revert FailedToFetchExpectedCoinAmount();\n        }\n        minAmount = abi.decode(responseData, (uint256));\n    }\n\n    /**\n     * @notice Returns the amount of coin i received for burning a given amount of LP tokens\n     * @notice Method to be used with StableSwap NG pools\n     * @param _curvePool The address of the curve pool\n     * @param _lpTokenAmount The amount of the LP tokens to burn\n     * @param _i The index of the unique coin to withdraw\n     * @return minAmount The expected amount of coin i withdrawn from the curve pool\n     */\n    function previewRemoveLiquidityOneCoinSNG(\n        address _curvePool,\n        uint256 _lpTokenAmount,\n        int128 _i\n    ) external view returns (uint256 minAmount) {\n        (bool success, bytes memory responseData) = _curvePool.staticcall(\n            abi.encodeCall(IStableSwapNG(address(0)).calc_withdraw_one_coin, (_lpTokenAmount, _i))\n        );\n        if (!success) {\n            revert FailedToFetchExpectedCoinAmount();\n        }\n        minAmount = abi.decode(responseData, (uint256));\n    }\n\n    /**\n     * @notice Return the amount of IBT to deposit in the curve pool, given the total amount of IBT available for deposit\n     * @param _amount The total amount of IBT available for deposit\n     * @param _curvePool The address of the pool to deposit the amounts\n     * @param _pt The address of the PT\n     * @return ibts The amount of IBT which will be deposited in the curve pool\n     */\n    function calcIBTsToTokenizeForCurvePool(\n        uint256 _amount,\n        address _curvePool,\n        address _pt\n    ) external view returns (uint256 ibts) {\n        (uint256 ibtBalance, uint256 ptBalance) = _getCurvePoolBalances(_curvePool);\n        uint256 ibtBalanceInPT = IPrincipalToken(_pt).previewDepositIBT(ibtBalance);\n        // Liquidity added in a ratio that (closely) matches the existing pool's ratio\n        ibts = _amount.mulDiv(ptBalance, ibtBalanceInPT + ptBalance);\n    }\n\n    /**\n     * @notice Return the amount of IBT to deposit in the curve pool given the proportion in which we want to deposit, given the total amount of IBT available for deposit\n     * @param _amount The total amount of IBT available for deposit\n     * @param _prop The proportion in which we want to make the deposit: _prop = nIBT / (nIBT + nPT)\n     * @param _pt The address of the PT\n     * @return ibts The amount of IBT which will be deposited in the curve pool\n     */\n    function calcIBTsToTokenizeForCurvePoolCustomProp(\n        uint256 _amount,\n        uint256 _prop,\n        address _pt\n    ) external view returns (uint256 ibts) {\n        uint256 rate = IPrincipalToken(_pt).previewDepositIBT(_amount).mulDiv(CURVE_UNIT, _amount);\n        ibts = _amount.mulDiv(CURVE_UNIT, CURVE_UNIT + _prop.mulDiv(rate, CURVE_UNIT));\n    }\n\n    /**\n     * @param _curvePool : PT/IBT curve pool\n     * @param _i token index\n     * @param _j token index\n     * @param _targetDy amount out desired\n     * @return dx The amount of token to provide in order to obtain _targetDy after swap\n     */\n    function getDx(\n        address _curvePool,\n        uint256 _i,\n        uint256 _j,\n        uint256 _targetDy\n    ) external view returns (uint256 dx) {\n        // Initial guesses\n        uint256 _minGuess = type(uint256).max;\n        uint256 _maxGuess = type(uint256).max;\n        uint256 _factor100;\n        uint256 _guess = ICurvePool(_curvePool).get_dy(_i, _j, _targetDy);\n\n        if (_guess > _targetDy) {\n            _maxGuess = _targetDy;\n            _factor100 = 10;\n        } else {\n            _minGuess = _targetDy;\n            _factor100 = 1000;\n        }\n        uint256 loops;\n        _guess = _targetDy;\n        while (!_dxSolved(_curvePool, _i, _j, _guess, _targetDy, _minGuess, _maxGuess)) {\n            loops++;\n\n            (_minGuess, _maxGuess, _guess) = _runLoop(\n                _minGuess,\n                _maxGuess,\n                _factor100,\n                _guess,\n                _targetDy,\n                _curvePool,\n                _i,\n                _j\n            );\n\n            if (loops >= MAX_ITERATIONS_BINSEARCH) {\n                revert SolutionNotFound();\n            }\n        }\n        dx = _guess;\n    }\n\n    /**\n     * @dev Runs bisection search\n     * @param _minGuess lower bound on searched value\n     * @param _maxGuess upper bound on searched value\n     * @param _factor100 search interval scaling factor\n     * @param _guess The previous guess for the `dx` value that is being refined through the search process\n     * @param _targetDy The target output of the `get_dy` function, which the search aims to achieve by adjusting `dx`.\n     * @param _curvePool PT/IBT curve pool\n     * @param _i token index, either 0 or 1\n     * @param _j token index, either 0 or 1, must be different than _i\n     * @return The lower bound on _guess, upper bound on _guess and next _guess\n     */\n    function _runLoop(\n        uint256 _minGuess,\n        uint256 _maxGuess,\n        uint256 _factor100,\n        uint256 _guess,\n        uint256 _targetDy,\n        address _curvePool,\n        uint256 _i,\n        uint256 _j\n    ) internal view returns (uint256, uint256, uint256) {\n        if (_minGuess == type(uint256).max || _maxGuess == type(uint256).max) {\n            _guess = (_guess * _factor100) / 100;\n        } else {\n            _guess = (_maxGuess + _minGuess) >> 1;\n        }\n        uint256 dy = ICurvePool(_curvePool).get_dy(_i, _j, _guess);\n        if (dy < _targetDy) {\n            _minGuess = _guess;\n        } else if (dy > _targetDy) {\n            _maxGuess = _guess;\n        }\n        return (_minGuess, _maxGuess, _guess);\n    }\n\n    /**\n     * @dev Returns true if algorithm converged\n     * @param _curvePool PT/IBT curve pool\n     * @param _i token index, either 0 or 1\n     * @param _j token index, either 0 or 1, must be different than _i\n     * @param _dx The current guess for the `dx` value that is being refined through the search process.\n     * @param _targetDy The target output of the `get_dy` function, which the search aims to achieve by adjusting `dx`.\n     * @param _minGuess lower bound on searched value\n     * @param _maxGuess upper bound on searched value\n     * @return true if the solution to the search problem was found, false otherwise\n     */\n    function _dxSolved(\n        address _curvePool,\n        uint256 _i,\n        uint256 _j,\n        uint256 _dx,\n        uint256 _targetDy,\n        uint256 _minGuess,\n        uint256 _maxGuess\n    ) internal view returns (bool) {\n        if (_minGuess == type(uint256).max || _maxGuess == type(uint256).max) {\n            return false;\n        }\n        uint256 dy = ICurvePool(_curvePool).get_dy(_i, _j, _dx);\n        if (dy == _targetDy) {\n            return true;\n        }\n        uint256 dy1 = ICurvePool(_curvePool).get_dy(_i, _j, _dx + 1);\n        if (dy < _targetDy && _targetDy < dy1) {\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * @notice Returns the balances of the two tokens in provided curve pool\n     * @param _curvePool address of the curve pool\n     * @return The IBT and PT balances of the curve pool\n     */\n    function _getCurvePoolBalances(address _curvePool) internal view returns (uint256, uint256) {\n        return (ICurvePool(_curvePool).balances(0), ICurvePool(_curvePool).balances(1));\n    }\n}\n"
    },
    "src/interfaces/ICurvePool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface for Curve CryptoSwap pool\n */\ninterface ICurvePool {\n    function coins(uint256 index) external view returns (address);\n\n    function balances(uint256 index) external view returns (uint256);\n\n    function A() external view returns (uint256);\n\n    function gamma() external view returns (uint256);\n\n    function D() external view returns (uint256);\n\n    function token() external view returns (address);\n\n    function price_scale() external view returns (uint256);\n\n    function future_A_gamma_time() external view returns (uint256);\n\n    function future_A_gamma() external view returns (uint256);\n\n    function initial_A_gamma_time() external view returns (uint256);\n\n    function initial_A_gamma() external view returns (uint256);\n\n    function fee_gamma() external view returns (uint256);\n\n    function mid_fee() external view returns (uint256);\n\n    function out_fee() external view returns (uint256);\n\n    function allowed_extra_profit() external view returns (uint256);\n\n    function adjustment_step() external view returns (uint256);\n\n    function admin_fee() external view returns (uint256);\n\n    function ma_half_time() external view returns (uint256);\n\n    function get_virtual_price() external view returns (uint256);\n\n    function fee() external view returns (uint256);\n\n    function get_dy(uint256 i, uint256 j, uint256 dx) external view returns (uint256);\n\n    function last_prices() external view returns (uint256);\n\n    function calc_token_amount(uint256[2] calldata amounts) external view returns (uint256);\n\n    function calc_withdraw_one_coin(\n        uint256 _token_amount,\n        uint256 i\n    ) external view returns (uint256);\n\n    function exchange(\n        uint256 i,\n        uint256 j,\n        uint256 dx,\n        uint256 min_dy,\n        bool use_eth,\n        address receiver\n    ) external returns (uint256);\n\n    function add_liquidity(\n        uint256[2] calldata amounts,\n        uint256 min_mint_amount\n    ) external returns (uint256);\n\n    function add_liquidity(\n        uint256[2] calldata amounts,\n        uint256 min_mint_amount,\n        bool use_eth,\n        address receiver\n    ) external returns (uint256);\n\n    function remove_liquidity(uint256 amount, uint256[2] calldata min_amounts) external;\n\n    function remove_liquidity(\n        uint256 amount,\n        uint256[2] calldata min_amounts,\n        bool use_eth,\n        address receiver\n    ) external;\n\n    function remove_liquidity_one_coin(\n        uint256 token_amount,\n        uint256 i,\n        uint256 min_amount\n    ) external;\n\n    function remove_liquidity_one_coin(\n        uint256 token_amount,\n        uint256 i,\n        uint256 min_amount,\n        bool use_eth,\n        address receiver\n    ) external;\n}\n"
    },
    "src/interfaces/ICurveNGPool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.20;\n\nimport {IERC20Metadata} from \"openzeppelin-contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\n/**\n * @dev Interface for Curve TwoCrypto-NG pool\n */\ninterface ICurveNGPool is IERC20Metadata {\n    function coins(uint256 index) external view returns (address);\n\n    function balances(uint256 index) external view returns (uint256);\n\n    function A() external view returns (uint256);\n\n    function gamma() external view returns (uint256);\n\n    function D() external view returns (uint256);\n\n    function token() external view returns (address);\n\n    function price_scale() external view returns (uint256);\n\n    function price_oracle() external view returns (uint256);\n\n    function future_A_gamma_time() external view returns (uint256);\n\n    function future_A_gamma() external view returns (uint256);\n\n    function initial_A_gamma_time() external view returns (uint256);\n\n    function initial_A_gamma() external view returns (uint256);\n\n    function fee_gamma() external view returns (uint256);\n\n    function mid_fee() external view returns (uint256);\n\n    function out_fee() external view returns (uint256);\n\n    function allowed_extra_profit() external view returns (uint256);\n\n    function adjustment_step() external view returns (uint256);\n\n    function admin_fee() external view returns (uint256);\n\n    function ma_time() external view returns (uint256);\n\n    function get_virtual_price() external view returns (uint256);\n\n    function fee() external view returns (uint256);\n\n    function get_dy(uint256 i, uint256 j, uint256 dx) external view returns (uint256);\n\n    function get_dx(uint256 i, uint256 j, uint256 dy) external view returns (uint256);\n\n    function last_prices() external view returns (uint256);\n\n    function calc_token_amount(\n        uint256[2] calldata amounts,\n        bool deposit\n    ) external view returns (uint256);\n\n    function calc_withdraw_one_coin(\n        uint256 _token_amount,\n        uint256 i\n    ) external view returns (uint256);\n\n    function exchange(uint256 i, uint256 j, uint256 dx, uint256 min_dy) external returns (uint256);\n\n    function exchange(\n        uint256 i,\n        uint256 j,\n        uint256 dx,\n        uint256 min_dy,\n        address receiver\n    ) external returns (uint256);\n\n    function add_liquidity(\n        uint256[2] calldata amounts,\n        uint256 min_mint_amount\n    ) external returns (uint256);\n\n    function add_liquidity(\n        uint256[2] calldata amounts,\n        uint256 min_mint_amount,\n        address receiver\n    ) external returns (uint256);\n\n    function remove_liquidity(uint256 amount, uint256[2] calldata min_amounts) external;\n\n    function remove_liquidity(\n        uint256 amount,\n        uint256[2] calldata min_amounts,\n        address receiver\n    ) external;\n\n    function remove_liquidity_one_coin(\n        uint256 token_amount,\n        uint256 i,\n        uint256 min_amount\n    ) external;\n\n    function remove_liquidity_one_coin(\n        uint256 token_amount,\n        uint256 i,\n        uint256 min_amount,\n        address receiver\n    ) external;\n}\n"
    },
    "src/interfaces/IStableSwapNG.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.4;\n\ninterface IStableSwapNG {\n    function A() external view returns (uint256);\n    function A_precise() external view returns (uint256);\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function D_ma_time() external view returns (uint256);\n    function D_oracle() external view returns (uint256);\n    function N_COINS() external view returns (uint256);\n    function add_liquidity(\n        uint256[] memory _amounts,\n        uint256 _min_mint_amount,\n        address _receiver\n    ) external returns (uint256);\n    function admin_balances(uint256 arg0) external view returns (uint256);\n    function admin_fee() external view returns (uint256);\n    function allowance(address arg0, address arg1) external view returns (uint256);\n    function approve(address _spender, uint256 _value) external returns (bool);\n    function balanceOf(address arg0) external view returns (uint256);\n    function balances(uint256 i) external view returns (uint256);\n    function calc_token_amount(\n        uint256[] memory _amounts,\n        bool _is_deposit\n    ) external view returns (uint256);\n    function calc_withdraw_one_coin(uint256 _burn_amount, int128 i) external view returns (uint256);\n    function coins(uint256 arg0) external view returns (address);\n    function decimals() external view returns (uint8);\n    function dynamic_fee(int128 i, int128 j) external view returns (uint256);\n    function ema_price(uint256 i) external view returns (uint256);\n    function exchange(int128 i, int128 j, uint256 _dx, uint256 _min_dy) external returns (uint256);\n    function exchange(\n        int128 i,\n        int128 j,\n        uint256 _dx,\n        uint256 _min_dy,\n        address _receiver\n    ) external returns (uint256);\n    function exchange_received(\n        int128 i,\n        int128 j,\n        uint256 _dx,\n        uint256 _min_dy\n    ) external returns (uint256);\n    function exchange_received(\n        int128 i,\n        int128 j,\n        uint256 _dx,\n        uint256 _min_dy,\n        address _receiver\n    ) external returns (uint256);\n    function fee() external view returns (uint256);\n    function future_A() external view returns (uint256);\n    function future_A_time() external view returns (uint256);\n    function get_balances() external view returns (uint256[] memory);\n    function get_dx(int128 i, int128 j, uint256 dy) external view returns (uint256);\n    function get_dy(int128 i, int128 j, uint256 dx) external view returns (uint256);\n    function get_p(uint256 i) external view returns (uint256);\n    function get_virtual_price() external view returns (uint256);\n    function initial_A() external view returns (uint256);\n    function initial_A_time() external view returns (uint256);\n    function last_price(uint256 i) external view returns (uint256);\n    function ma_exp_time() external view returns (uint256);\n    function ma_last_time() external view returns (uint256);\n    function name() external view returns (string memory);\n    function nonces(address arg0) external view returns (uint256);\n    function offpeg_fee_multiplier() external view returns (uint256);\n    function permit(\n        address _owner,\n        address _spender,\n        uint256 _value,\n        uint256 _deadline,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external returns (bool);\n    function price_oracle(uint256 i) external view returns (uint256);\n    function ramp_A(uint256 _future_A, uint256 _future_time) external;\n    function remove_liquidity(\n        uint256 _burn_amount,\n        uint256[] memory _min_amounts\n    ) external returns (uint256[] memory);\n    function remove_liquidity(\n        uint256 _burn_amount,\n        uint256[] memory _min_amounts,\n        address _receiver\n    ) external returns (uint256[] memory);\n    function remove_liquidity(\n        uint256 _burn_amount,\n        uint256[] memory _min_amounts,\n        address _receiver,\n        bool _claim_admin_fees\n    ) external returns (uint256[] memory);\n    function remove_liquidity_imbalance(\n        uint256[] memory _amounts,\n        uint256 _max_burn_amount\n    ) external returns (uint256);\n    function remove_liquidity_imbalance(\n        uint256[] memory _amounts,\n        uint256 _max_burn_amount,\n        address _receiver\n    ) external returns (uint256);\n    function remove_liquidity_one_coin(\n        uint256 _burn_amount,\n        int128 i,\n        uint256 _min_received\n    ) external returns (uint256);\n    function remove_liquidity_one_coin(\n        uint256 _burn_amount,\n        int128 i,\n        uint256 _min_received,\n        address _receiver\n    ) external returns (uint256);\n    function salt() external view returns (bytes32);\n    function set_ma_exp_time(uint256 _ma_exp_time, uint256 _D_ma_time) external;\n    function set_new_fee(uint256 _new_fee, uint256 _new_offpeg_fee_multiplier) external;\n    function stop_ramp_A() external;\n    function stored_rates() external view returns (uint256[] memory);\n    function symbol() external view returns (string memory);\n    function totalSupply() external view returns (uint256);\n    function transfer(address _to, uint256 _value) external returns (bool);\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\n    function version() external view returns (string memory);\n    function withdraw_admin_fees() external;\n}\n"
    },
    "src/interfaces/IPrincipalToken.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.20;\n\nimport \"openzeppelin-contracts/interfaces/IERC20.sol\";\nimport \"openzeppelin-contracts/interfaces/IERC20Metadata.sol\";\nimport \"openzeppelin-contracts/interfaces/IERC3156FlashLender.sol\";\n\ninterface IPrincipalToken is IERC20, IERC20Metadata, IERC3156FlashLender {\n    /* ERRORS\n     *****************************************************************************************************************/\n\n    error InvalidDecimals();\n    error BeaconNotSet();\n    error PTExpired();\n    error PTNotExpired();\n    error RateError();\n    error AddressError();\n    error UnauthorizedCaller();\n    error RatesAtExpiryAlreadyStored();\n    error ERC5143SlippageProtectionFailed();\n    error InsufficientBalance();\n    error FlashLoanExceedsMaxAmount();\n    error FlashLoanCallbackFailed();\n    error NoRewardsProxy();\n    error ClaimRewardsFailed();\n\n    /* Functions\n     *****************************************************************************************************************/\n\n    function initialize(address _ibt, uint256 _duration, address initialAuthority) external;\n\n    /**\n     * @notice Toggle Pause\n     * @dev Should only be called in extraordinary situations by the admin of the contract\n     */\n    function pause() external;\n\n    /**\n     * @notice Toggle UnPause\n     * @dev Should only be called in extraordinary situations by the admin of the contract\n     */\n    function unPause() external;\n\n    /**\n     * @notice Deposits amount of assets in the PT vault\n     * @param assets The amount of assets being deposited\n     * @param receiver The receiver address of the shares\n     * @return shares The amount of shares minted (same amount for PT & yt)\n     */\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\n\n    /**\n     * @notice Deposits amount of assets in the PT vault\n     * @param assets The amount of assets being deposited\n     * @param ptReceiver The receiver address of the PTs\n     * @param ytReceiver the receiver address of the YTs\n     * @return shares The amount of shares minted (same amount for PT & yt)\n     */\n    function deposit(\n        uint256 assets,\n        address ptReceiver,\n        address ytReceiver\n    ) external returns (uint256 shares);\n\n    /**\n     * @notice Deposits amount of assets with a lower bound on shares received\n     * @param assets The amount of assets being deposited\n     * @param ptReceiver The receiver address of the PTs\n     * @param ytReceiver The receiver address of the YTs\n     * @param minShares The minimum allowed shares from this deposit\n     * @return shares The amount of shares actually minted to the receiver\n     */\n    function deposit(\n        uint256 assets,\n        address ptReceiver,\n        address ytReceiver,\n        uint256 minShares\n    ) external returns (uint256 shares);\n\n    /**\n     * @notice Same as normal deposit but with IBTs\n     * @param ibts The amount of IBT being deposited\n     * @param receiver The receiver address of the shares\n     * @return shares The amount of shares minted to the receiver\n     */\n    function depositIBT(uint256 ibts, address receiver) external returns (uint256 shares);\n\n    /**\n     * @notice Same as normal deposit but with IBTs\n     * @param ibts The amount of IBT being deposited\n     * @param ptReceiver The receiver address of the PTs\n     * @param ytReceiver the receiver address of the YTs\n     * @return shares The amount of shares minted to the receiver\n     */\n    function depositIBT(\n        uint256 ibts,\n        address ptReceiver,\n        address ytReceiver\n    ) external returns (uint256 shares);\n\n    /**\n     * @notice Same as normal deposit but with IBTs\n     * @param ibts The amount of IBT being deposited\n     * @param ptReceiver The receiver address of the PTs\n     * @param ytReceiver The receiver address of the YTs\n     * @param minShares The minimum allowed shares from this deposit\n     * @return shares The amount of shares minted to the receiver\n     */\n    function depositIBT(\n        uint256 ibts,\n        address ptReceiver,\n        address ytReceiver,\n        uint256 minShares\n    ) external returns (uint256 shares);\n\n    /**\n     * @notice Burns owner's shares (PTs and YTs before expiry, PTs after expiry)\n     * and sends assets to receiver\n     * @param shares The amount of shares to burn\n     * @param receiver The address that will receive the assets\n     * @param owner The owner of the shares\n     * @return assets The actual amount of assets received for burning the shares\n     */\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) external returns (uint256 assets);\n\n    /**\n     * @notice Burns owner's shares (PTs and YTs before expiry, PTs after expiry)\n     * and sends assets to receiver\n     * @param shares The amount of shares to burn\n     * @param receiver The address that will receive the assets\n     * @param owner The owner of the shares\n     * @param minAssets The minimum assets that should be returned to user\n     * @return assets The actual amount of assets received for burning the shares\n     */\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner,\n        uint256 minAssets\n    ) external returns (uint256 assets);\n\n    /**\n     * @notice Burns owner's shares (PTs and YTs before expiry, PTs after expiry)\n     * and sends IBTs to receiver\n     * @param shares The amount of shares to burn\n     * @param receiver The address that will receive the IBTs\n     * @param owner The owner of the shares\n     * @return ibts The actual amount of IBT received for burning the shares\n     */\n    function redeemForIBT(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) external returns (uint256 ibts);\n\n    /**\n     * @notice Burns owner's shares (PTs and YTs before expiry, PTs after expiry)\n     * and sends IBTs to receiver\n     * @param shares The amount of shares to burn\n     * @param receiver The address that will receive the IBTs\n     * @param owner The owner of the shares\n     * @param minIbts The minimum IBTs that should be returned to user\n     * @return ibts The actual amount of IBT received for burning the shares\n     */\n    function redeemForIBT(\n        uint256 shares,\n        address receiver,\n        address owner,\n        uint256 minIbts\n    ) external returns (uint256 ibts);\n\n    /**\n     * @notice Burns owner's shares (before expiry : PTs and YTs) and sends assets to receiver\n     * @param assets The amount of assets to be received\n     * @param receiver The address that will receive the assets\n     * @param owner The owner of the shares (PTs and YTs)\n     * @return shares The actual amount of shares burnt for receiving the assets\n     */\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) external returns (uint256 shares);\n\n    /**\n     * @notice Burns owner's shares (before expiry : PTs and YTs) and sends assets to receiver\n     * @param assets The amount of assets to be received\n     * @param receiver The address that will receive the assets\n     * @param owner The owner of the shares (PTs and YTs)\n     * @param maxShares The maximum shares allowed to be burnt\n     * @return shares The actual amount of shares burnt for receiving the assets\n     */\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner,\n        uint256 maxShares\n    ) external returns (uint256 shares);\n\n    /**\n     * @notice Burns owner's shares (before expiry : PTs and YTs) and sends IBTs to receiver\n     * @param ibts The amount of IBT to be received\n     * @param receiver The address that will receive the IBTs\n     * @param owner The owner of the shares (PTs and YTs)\n     * @return shares The actual amount of shares burnt for receiving the IBTs\n     */\n    function withdrawIBT(\n        uint256 ibts,\n        address receiver,\n        address owner\n    ) external returns (uint256 shares);\n\n    /**\n     * @notice Burns owner's shares (before expiry : PTs and YTs) and sends IBTs to receiver\n     * @param ibts The amount of IBT to be received\n     * @param receiver The address that will receive the IBTs\n     * @param owner The owner of the shares (PTs and YTs)\n     * @param maxShares The maximum shares allowed to be burnt\n     * @return shares The actual amount of shares burnt for receiving the IBTs\n     */\n    function withdrawIBT(\n        uint256 ibts,\n        address receiver,\n        address owner,\n        uint256 maxShares\n    ) external returns (uint256 shares);\n\n    /**\n     * @notice Updates _user's yield since last update\n     * @param _user The user whose yield will be updated\n     * @return updatedUserYieldInIBT The unclaimed yield of the user in IBT (not just the updated yield)\n     */\n    function updateYield(address _user) external returns (uint256 updatedUserYieldInIBT);\n\n    /**\n     * @notice Claims caller's unclaimed yield in asset\n     * @param _receiver The receiver of yield\n     * @param _minAssets The minimum amount of assets that should be received\n     * @return yieldInAsset The amount of yield claimed in asset\n     */\n    function claimYield(\n        address _receiver,\n        uint256 _minAssets\n    ) external returns (uint256 yieldInAsset);\n\n    /**\n     * @notice Claims caller's unclaimed yield in IBT\n     * @param _receiver The receiver of yield\n     * @param _minIBT The minimum amount of IBT that should be received\n     * @return yieldInIBT The amount of yield claimed in IBT\n     */\n    function claimYieldInIBT(\n        address _receiver,\n        uint256 _minIBT\n    ) external returns (uint256 yieldInIBT);\n\n    /**\n     * @notice Claims the collected ibt fees and redeems them to the fee collector\n     * @param _minAssets The minimum amount of assets that should be received\n     * @return assets The amount of assets sent to the fee collector\n     */\n    function claimFees(uint256 _minAssets) external returns (uint256 assets);\n\n    /**\n     * @notice Updates yield of both sender and receiver of YTs\n     * @param _from the sender of YTs\n     * @param _to the receiver of YTs\n     */\n    function beforeYtTransfer(address _from, address _to) external;\n\n    /**\n     * Call the claimRewards function of the rewards contract\n     * @param data The optional data to be passed to the rewards contract\n     */\n    function claimRewards(bytes memory data) external;\n\n    /* SETTERS\n     *****************************************************************************************************************/\n\n    /**\n     * @notice Stores PT and IBT rates at expiry. Ideally, it should be called the day of expiry\n     */\n    function storeRatesAtExpiry() external;\n\n    /** Set a new Rewards Proxy\n     * @param _rewardsProxy The address of the new reward proxy\n     */\n    function setRewardsProxy(address _rewardsProxy) external;\n\n    /* GETTERS\n     *****************************************************************************************************************/\n\n    /**\n     * @notice Returns the amount of shares minted for the theorical deposited amount of assets\n     * @param assets The amount of assets deposited\n     * @return The amount of shares minted\n     */\n    function previewDeposit(uint256 assets) external view returns (uint256);\n\n    /**\n     * @notice Returns the amount of shares minted for the theorical deposited amount of IBT\n     * @param ibts The amount of IBT deposited\n     * @return The amount of shares minted\n     */\n    function previewDepositIBT(uint256 ibts) external view returns (uint256);\n\n    /**\n     * @notice Returns the maximum amount of the underlying asset that can be deposited into the Vault for the receiver,\n     * through a deposit call.\n     * @param receiver The receiver of the shares\n     * @return The maximum amount of assets that can be deposited\n     */\n    function maxDeposit(address receiver) external view returns (uint256);\n\n    /**\n     * @notice Returns the theorical amount of shares that need to be burnt to receive assets of underlying\n     * @param assets The amount of assets to receive\n     * @return The amount of shares burnt\n     */\n    function previewWithdraw(uint256 assets) external view returns (uint256);\n\n    /**\n     * @notice Returns the theorical amount of shares that need to be burnt to receive amount of IBT\n     * @param ibts The amount of IBT to receive\n     * @return The amount of shares burnt\n     */\n    function previewWithdrawIBT(uint256 ibts) external view returns (uint256);\n\n    /**\n     * @notice Returns the maximum amount of the underlying asset that can be withdrawn from the owner balance in the\n     * Vault, through a withdraw call.\n     * @param owner The owner of the Vault shares\n     * @return The maximum amount of assets that can be withdrawn\n     */\n    function maxWithdraw(address owner) external view returns (uint256);\n\n    /**\n     * @notice Returns the maximum amount of the IBT that can be withdrawn from the owner balance in the\n     * Vault, through a withdraw call.\n     * @param owner The owner of the Vault shares\n     * @return The maximum amount of IBT that can be withdrawn\n     */\n    function maxWithdrawIBT(address owner) external view returns (uint256);\n\n    /**\n     * @notice Returns the amount of assets received for the theorical amount of burnt shares\n     * @param shares The amount of shares to burn\n     * @return The amount of assets received\n     */\n    function previewRedeem(uint256 shares) external view returns (uint256);\n\n    /**\n     * @notice Returns the amount of IBT received for the theorical amount of burnt shares\n     * @param shares The amount of shares to burn\n     * @return The amount of IBT received\n     */\n    function previewRedeemForIBT(uint256 shares) external view returns (uint256);\n\n    /**\n     * @notice Returns the maximum amount of Vault shares that can be redeemed by the owner\n     * @notice This function behaves differently before and after expiry. Before expiry an equal amount of PT and YT\n     * needs to be burnt, while after expiry only PTs are burnt.\n     * @param owner The owner of the shares\n     * @return The maximum amount of shares that can be redeemed\n     */\n    function maxRedeem(address owner) external view returns (uint256);\n\n    /**\n     * Returns the total amount of the underlying asset that is owned by the Vault in the form of IBT.\n     */\n    function totalAssets() external view returns (uint256);\n\n    /**\n     * @notice Converts an underlying amount in principal. Equivalent to ERC-4626's convertToShares method.\n     * @param underlyingAmount The amount of underlying (or assets) to convert\n     * @return The resulting amount of principal (or shares)\n     */\n    function convertToPrincipal(uint256 underlyingAmount) external view returns (uint256);\n\n    /**\n     * @notice Converts a principal amount in underlying. Equivalent to ERC-4626's convertToAssets method.\n     * @param principalAmount The amount of principal (or shares) to convert\n     * @return The resulting amount of underlying (or assets)\n     */\n    function convertToUnderlying(uint256 principalAmount) external view returns (uint256);\n\n    /**\n     * @notice Returns whether or not the contract is paused.\n     * @return true if the contract is paused, and false otherwise\n     */\n    function paused() external view returns (bool);\n\n    /**\n     * @notice Returns the unix timestamp (uint256) at which the PT contract expires\n     * @return The unix timestamp (uint256) when PTs become redeemable\n     */\n    function maturity() external view returns (uint256);\n\n    /**\n     * @notice Returns the duration of the PT contract\n     * @return The duration (in s) to expiry/maturity of the PT contract\n     */\n    function getDuration() external view returns (uint256);\n\n    /**\n     * @notice Returns the address of the underlying token (or asset). Equivalent to ERC-4626's asset method.\n     * @return The address of the underlying token (or asset)\n     */\n    function underlying() external view returns (address);\n\n    /**\n     * @notice Returns the IBT address of the PT contract\n     * @return ibt The address of the IBT\n     */\n    function getIBT() external view returns (address ibt);\n\n    /**\n     * @notice Returns the yt address of the PT contract\n     * @return yt The address of the yt\n     */\n    function getYT() external view returns (address yt);\n\n    /**\n     * @notice Returns the current ibtRate\n     * @return The current ibtRate\n     */\n    function getIBTRate() external view returns (uint256);\n\n    /**\n     * @notice Returns the current ptRate\n     * @return The current ptRate\n     */\n    function getPTRate() external view returns (uint256);\n\n    /**\n     * @notice Returns 1 unit of IBT\n     * @return The IBT unit\n     */\n    function getIBTUnit() external view returns (uint256);\n\n    /**\n     * @notice Get the unclaimed fees in IBT\n     * @return The unclaimed fees in IBT\n     */\n    function getUnclaimedFeesInIBT() external view returns (uint256);\n\n    /**\n     * @notice Get the total collected fees in IBT (claimed and unclaimed)\n     * @return The total fees in IBT\n     */\n    function getTotalFeesInIBT() external view returns (uint256);\n\n    /**\n     * @notice Get the tokenization fee of the PT\n     * @return The tokenization fee\n     */\n    function getTokenizationFee() external view returns (uint256);\n\n    /**\n     * @notice Get the current IBT yield of the user\n     * @param _user The address of the user to get the current yield from\n     * @return The yield of the user in IBT\n     */\n    function getCurrentYieldOfUserInIBT(address _user) external view returns (uint256);\n}\n"
    },
    "src/libraries/RayMath.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.20;\n\n/**\n * @title RayMath library\n * @author Spectra Finance\n * @notice Provides conversions for/to any decimal tokens to/from ray.\n * @dev Conversions from Ray are rounded down.\n */\nlibrary RayMath {\n    /// @dev 27 decimal unit\n    uint256 public constant RAY_UNIT = 1e27;\n    uint256 public constant RAY_DECIMALS = 27;\n\n    /**\n     * @dev Converts a value from Ray (27-decimal precision) to a representation with a specified number of decimals.\n     * @param _a The amount in Ray to be converted. Ray is a fixed-point representation with 27 decimals.\n     * @param _decimals The target decimal precision for the converted amount.\n     * @return b The amount converted from Ray to the specified decimal precision.\n     */\n    function fromRay(uint256 _a, uint256 _decimals) internal pure returns (uint256 b) {\n        uint256 decimals_ratio = 10 ** (RAY_DECIMALS - _decimals);\n        assembly {\n            b := div(_a, decimals_ratio)\n        }\n    }\n\n    /**\n     * @dev Converts a value from Ray (27-decimal precision) to a representation with a specified number of decimals.\n     * @param _a The amount in Ray to be converted. Ray is a fixed-point representation with 27 decimals.\n     * @param _decimals The target decimal precision for the converted amount.\n     * @param _roundUp If true, the function rounds up the result to the nearest integer value.\n     *                If false, it truncates (rounds down) to the nearest integer.\n     * @return b The amount converted from Ray to the specified decimal precision, rounded as specified.\n     */\n    function fromRay(\n        uint256 _a,\n        uint256 _decimals,\n        bool _roundUp\n    ) internal pure returns (uint256 b) {\n        uint256 decimals_ratio = 10 ** (RAY_DECIMALS - _decimals);\n        assembly {\n            b := div(_a, decimals_ratio)\n\n            if and(eq(_roundUp, 1), gt(mod(_a, decimals_ratio), 0)) {\n                b := add(b, 1)\n            }\n        }\n    }\n\n    /**\n     * @dev Converts a value with a specified number of decimals to Ray (27-decimal precision).\n     * @param _a The amount to be converted, specified in a decimal format.\n     * @param _decimals The number of decimals in the representation of 'a'.\n     * @return b The amount in Ray, converted from the specified decimal precision.\n     *           Ensures that the conversion maintains the value's integrity (no overflow).\n     */\n    function toRay(uint256 _a, uint256 _decimals) internal pure returns (uint256 b) {\n        uint256 decimals_ratio = 10 ** (RAY_DECIMALS - _decimals);\n        // to avoid overflow, b/decimals_ratio == _a\n        assembly {\n            b := mul(_a, decimals_ratio)\n\n            if iszero(eq(div(b, decimals_ratio), _a)) {\n                revert(0, 0)\n            }\n        }\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Muldiv operation overflow.\n     */\n    error MathOverflowedMulDiv();\n\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            return a / b;\n        }\n\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../token/ERC20/IERC20.sol\";\n"
    },
    "lib/openzeppelin-contracts/contracts/interfaces/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC20Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20Metadata} from \"../token/ERC20/extensions/IERC20Metadata.sol\";\n"
    },
    "lib/openzeppelin-contracts/contracts/interfaces/IERC3156FlashLender.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC3156FlashLender.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC3156FlashBorrower} from \"./IERC3156FlashBorrower.sol\";\n\n/**\n * @dev Interface of the ERC3156 FlashLender, as defined in\n * https://eips.ethereum.org/EIPS/eip-3156[ERC-3156].\n */\ninterface IERC3156FlashLender {\n    /**\n     * @dev The amount of currency available to be lended.\n     * @param token The loan currency.\n     * @return The amount of `token` that can be borrowed.\n     */\n    function maxFlashLoan(address token) external view returns (uint256);\n\n    /**\n     * @dev The fee to be charged for a given loan.\n     * @param token The loan currency.\n     * @param amount The amount of tokens lent.\n     * @return The amount of `token` to be charged for the loan, on top of the returned principal.\n     */\n    function flashFee(address token, uint256 amount) external view returns (uint256);\n\n    /**\n     * @dev Initiate a flash loan.\n     * @param receiver The receiver of the tokens in the loan, and the receiver of the callback.\n     * @param token The loan currency.\n     * @param amount The amount of tokens lent.\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\n     */\n    function flashLoan(\n        IERC3156FlashBorrower receiver,\n        address token,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (bool);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/interfaces/IERC3156FlashBorrower.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC3156FlashBorrower.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC3156 FlashBorrower, as defined in\n * https://eips.ethereum.org/EIPS/eip-3156[ERC-3156].\n */\ninterface IERC3156FlashBorrower {\n    /**\n     * @dev Receive a flash loan.\n     * @param initiator The initiator of the loan.\n     * @param token The loan currency.\n     * @param amount The amount of tokens lent.\n     * @param fee The additional amount of tokens to repay.\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\n     * @return The keccak256 hash of \"ERC3156FlashBorrower.onFlashLoan\"\n     */\n    function onFlashLoan(\n        address initiator,\n        address token,\n        uint256 amount,\n        uint256 fee,\n        bytes calldata data\n    ) external returns (bytes32);\n}\n"
    }
  },
  "settings": {
    "remappings": [
      "ds-test/=lib/forge-std/lib/ds-test/src/",
      "erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/",
      "forge-std/=lib/forge-std/src/",
      "openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/",
      "openzeppelin-contracts/=lib/openzeppelin-contracts/contracts/",
      "openzeppelin-erc20-basic/=lib/openzeppelin-contracts/contracts/token/ERC20/",
      "openzeppelin-erc20-extensions/=lib/openzeppelin-contracts-upgradeable/contracts/token/ERC20/extensions/",
      "openzeppelin-erc20/=lib/openzeppelin-contracts-upgradeable/contracts/token/ERC20/",
      "openzeppelin-math/=lib/openzeppelin-contracts/contracts/utils/math/",
      "openzeppelin-proxy/=lib/openzeppelin-contracts-upgradeable/contracts/proxy/utils/",
      "openzeppelin-utils/=lib/openzeppelin-contracts/contracts/utils/",
      "@openzeppelin/contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/",
      "@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "metadata": {
      "useLiteralContent": false,
      "bytecodeHash": "ipfs",
      "appendCBOR": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "evmVersion": "shanghai",
    "viaIR": false,
    "libraries": {
      "src/libraries/CurvePoolUtil.sol": {
        "CurvePoolUtil": "0x662DeB224Ce02060688701fCC8cE156BBca4bDD5"
      }
    }
  }
}}