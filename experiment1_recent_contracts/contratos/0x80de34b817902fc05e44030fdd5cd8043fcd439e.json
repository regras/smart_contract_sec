{{
  "language": "Solidity",
  "sources": {
    "src/SharesRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { Ownable2Step } from \"@openzeppelin/contracts/access/Ownable2Step.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport { IManager } from \"./interfaces/core/IManager.sol\";\nimport { ISharesRegistry } from \"./interfaces/core/ISharesRegistry.sol\";\nimport { IStablesManager } from \"./interfaces/core/IStablesManager.sol\";\nimport { IOracle } from \"./interfaces/oracle/IOracle.sol\";\n\n/**\n * @title SharesRegistry\n *\n * @notice Registers, manages and tracks assets used as collaterals within the Jigsaw Protocol.\n *\n * @author Hovooo (@hovooo), Cosmin Grigore (@gcosmintech).\n *\n * @custom:security-contact support@jigsaw.finance\n */\ncontract SharesRegistry is ISharesRegistry, Ownable2Step {\n    /**\n     * @notice Returns the token address for which this registry was created.\n     */\n    address public immutable override token;\n\n    /**\n     * @notice Returns holding's borrowed amount.\n     */\n    mapping(address holding => uint256 amount) public override borrowed;\n\n    /**\n     * @notice Returns holding's available collateral amount.\n     */\n    mapping(address holding => uint256 amount) public override collateral;\n\n    /**\n     * @notice Contract that contains the address of the Manager Contract.\n     */\n    IManager public override manager;\n\n    /**\n     * @notice Configuration parameters for the registry.\n     * @dev Stores collateralization rate, liquidation threshold, and liquidator bonus.\n     */\n    RegistryConfig private config;\n\n    /**\n     * @notice Minimal collateralization rate acceptable for registry to avoid computational errors.\n     * @dev 20e3 means 20% LTV.\n     */\n    uint16 private immutable minCR = 20e3;\n\n    /**\n     * @notice Maximum liquidation buffer acceptable for registry to avoid computational errors.\n     * @dev 20e3 means 20% buffer.\n     */\n    uint16 private immutable maxLiquidationBuffer = 20e3;\n\n    /**\n     * @notice Oracle contract associated with this share registry.\n     */\n    IOracle public override oracle;\n    address private _newOracle;\n    uint256 private _newOracleTimestamp;\n\n    /**\n     * @notice Extra oracle data if needed.\n     */\n    bytes public override oracleData;\n    bytes private _newOracleData;\n    uint256 private _newOracleDataTimestamp;\n\n    /**\n     * @notice Timelock amount in seconds for changing the oracle data.\n     */\n    uint256 public override timelockAmount = 1 hours;\n    uint256 private _oldTimelock;\n    uint256 private _newTimelock;\n    uint256 private _newTimelockTimestamp;\n\n    bool private _isOracleActiveChange = false;\n    bool private _isOracleDataActiveChange = false;\n    bool private _isTimelockActiveChange = false;\n\n    /**\n     * @notice Creates a SharesRegistry for a specific token.\n     *\n     * @param _initialOwner The initial owner of the contract.\n     * @param _manager Contract that holds all the necessary configs of the protocol.\n     * @param _token The address of the token contract, used as a collateral within this contract.\n     * @param _oracle The oracle used to retrieve price data for the `_token`.\n     * @param _oracleData Extra data for the oracle.\n     * @param _config Configuration parameters for the registry.\n     */\n    constructor(\n        address _initialOwner,\n        address _manager,\n        address _token,\n        address _oracle,\n        bytes memory _oracleData,\n        RegistryConfig memory _config\n    ) Ownable(_initialOwner) {\n        require(_manager != address(0), \"3065\");\n        require(_token != address(0), \"3001\");\n        require(_oracle != address(0), \"3034\");\n\n        token = _token;\n        oracle = IOracle(_oracle);\n        oracleData = _oracleData;\n        manager = IManager(_manager);\n\n        _updateConfig(_config);\n    }\n\n    // -- User specific methods --\n\n    /**\n     * @notice Updates `_holding`'s borrowed amount.\n     *\n     * @notice Requirements:\n     * - `msg.sender` must be the Stables Manager Contract.\n     * - `_newVal` must be greater than or equal to the minimum debt amount.\n     *\n     * @notice Effects:\n     * - Updates `borrowed` mapping.\n     *\n     * @notice Emits:\n     * - `BorrowedSet` indicating holding's borrowed amount update operation.\n     *\n     * @param _holding The address of the user's holding.\n     * @param _newVal The new borrowed amount.\n     */\n    function setBorrowed(address _holding, uint256 _newVal) external override onlyStableManager {\n        // Ensure the `holding` holds allowed minimum jUSD debt amount\n        require(_newVal == 0 || _newVal >= manager.minDebtAmount(), \"3102\");\n        // Emit event indicating successful update\n        emit BorrowedSet({ _holding: _holding, oldVal: borrowed[_holding], newVal: _newVal });\n        // Update the borrowed amount for the holding\n        borrowed[_holding] = _newVal;\n    }\n\n    /**\n     * @notice Registers collateral for user's `_holding`.\n     *\n     * @notice Requirements:\n     * - `msg.sender` must be the Stables Manager Contract.\n     *\n     * @notice Effects:\n     * - Updates `collateral` mapping.\n     *\n     * @notice Emits:\n     * - `CollateralAdded` event indicating collateral addition operation.\n     *\n     * @param _holding The address of the user's holding.\n     * @param _share The new collateral shares.\n     */\n    function registerCollateral(address _holding, uint256 _share) external override onlyStableManager {\n        collateral[_holding] += _share;\n        emit CollateralAdded({ user: _holding, share: _share });\n    }\n\n    /**\n     * @notice Registers a collateral removal operation for user's `_holding`.\n     *\n     * @notice Requirements:\n     * - `msg.sender` must be the Stables Manager Contract.\n     *\n     * @notice Effects:\n     * - Updates `collateral` mapping.\n     *\n     * @notice Emits:\n     * - `CollateralRemoved` event indicating collateral removal operation.\n     *\n     * @param _holding The address of the user's holding.\n     * @param _share The new collateral shares.\n     */\n    function unregisterCollateral(address _holding, uint256 _share) external override onlyStableManager {\n        if (_share > collateral[_holding]) {\n            _share = collateral[_holding];\n        }\n        collateral[_holding] = collateral[_holding] - _share;\n        emit CollateralRemoved(_holding, _share);\n    }\n\n    // -- Administration --\n\n    /**\n     * @notice Updates the registry configuration parameters.\n     *\n     * @notice Effects:\n     * - Updates `config` state variable.\n     *\n     * @notice Emits:\n     * - `ConfigUpdated` event indicating config update operation.\n     *\n     * @param _newConfig The new configuration parameters.\n     */\n    function updateConfig(\n        RegistryConfig memory _newConfig\n    ) external override onlyOwner {\n        _updateConfig(_newConfig);\n    }\n\n    /**\n     * @notice Requests a change for the oracle address.\n     *\n     * @notice Requirements:\n     * - Previous oracle change request must have expired or been accepted.\n     * - No timelock or oracle data change requests should be active.\n     * - `_oracle` must not be the zero address.\n     *\n     * @notice Effects:\n     * - Updates `_isOracleActiveChange` state variable.\n     * - Updates `_newOracle` state variable.\n     * - Updates `_newOracleTimestamp` state variable.\n     *\n     * @notice Emits:\n     * - `NewOracleRequested` event indicating new oracle request.\n     *\n     * @param _oracle The new oracle address.\n     */\n    function requestNewOracle(\n        address _oracle\n    ) external override onlyOwner {\n        if (_newOracleTimestamp + timelockAmount > block.timestamp) require(!_isOracleActiveChange, \"3093\");\n        require(!_isTimelockActiveChange, \"3095\");\n        require(_oracle != address(0), \"3000\");\n\n        _isOracleActiveChange = true;\n        _newOracle = _oracle;\n        _newOracleTimestamp = block.timestamp;\n        emit NewOracleRequested(_oracle);\n    }\n\n    /**\n     * @notice Updates the oracle.\n     *\n     * @notice Requirements:\n     * - Oracle change must have been requested and the timelock must have passed.\n     *\n     * @notice Effects:\n     * - Updates `oracle` state variable.\n     * - Updates `_isOracleActiveChange` state variable.\n     * - Updates `_newOracle` state variable.\n     * - Updates `_newOracleTimestamp` state variable.\n     *\n     * @notice Emits:\n     * - `OracleUpdated` event indicating oracle update.\n     */\n    function setOracle() external override onlyOwner {\n        require(_isOracleActiveChange, \"3094\");\n        require(_newOracleTimestamp + timelockAmount <= block.timestamp, \"3066\");\n\n        oracle = IOracle(_newOracle);\n        _isOracleActiveChange = false;\n        _newOracle = address(0);\n        _newOracleTimestamp = 0;\n        emit OracleUpdated();\n    }\n\n    /**\n     * @notice Requests a change for oracle data.\n     *\n     * @notice Requirements:\n     * - Previous oracle data change request must have expired or been accepted.\n     * - No timelock or oracle change requests should be active.\n     *\n     * @notice Effects:\n     * - Updates `_isOracleDataActiveChange` state variable.\n     * - Updates `_newOracleData` state variable.\n     * - Updates `_newOracleDataTimestamp` state variable.\n     *\n     * @notice Emits:\n     * - `NewOracleDataRequested` event indicating new oracle data request.\n     *\n     * @param _data The new oracle data.\n     */\n    function requestNewOracleData(\n        bytes calldata _data\n    ) external override onlyOwner {\n        if (_newOracleDataTimestamp + timelockAmount > block.timestamp) require(!_isOracleDataActiveChange, \"3096\");\n        require(!_isTimelockActiveChange, \"3095\");\n\n        _isOracleDataActiveChange = true;\n        _newOracleData = _data;\n        _newOracleDataTimestamp = block.timestamp;\n        emit NewOracleDataRequested(_newOracleData);\n    }\n\n    /**\n     * @notice Updates the oracle data.\n     *\n     * @notice Requirements:\n     * - Oracle data change must have been requested and the timelock must have passed.\n     *\n     * @notice Effects:\n     * - Updates `oracleData` state variable.\n     * - Updates `_isOracleDataActiveChange` state variable.\n     * - Updates `_newOracleData` state variable.\n     * - Updates `_newOracleDataTimestamp` state variable.\n     *\n     * @notice Emits:\n     * - `OracleDataUpdated` event indicating oracle data update.\n     */\n    function setOracleData() external override onlyOwner {\n        require(_isOracleDataActiveChange, \"3094\");\n        require(_newOracleDataTimestamp + timelockAmount <= block.timestamp, \"3066\");\n\n        oracleData = _newOracleData;\n        _isOracleDataActiveChange = false;\n        delete _newOracleData;\n        _newOracleDataTimestamp = 0;\n        emit OracleDataUpdated();\n    }\n\n    /**\n     * @notice Requests a timelock update.\n     *\n     * @notice Requirements:\n     * - `_newVal` must not be zero.\n     * - Previous timelock change request must have expired or been accepted.\n     * - No oracle or oracle data change requests should be active.\n     *\n     * @notice Effects:\n     * - Updates `_isTimelockActiveChange` state variable.\n     * - Updates `_oldTimelock` state variable.\n     * - Updates `_newTimelock` state variable.\n     * - Updates `_newTimelockTimestamp` state variable.\n     *\n     * @notice Emits:\n     * - `TimelockAmountUpdateRequested` event indicating timelock change request.\n     *\n     * @param _newVal The new value in seconds.\n     */\n    function requestTimelockAmountChange(\n        uint256 _newVal\n    ) external override onlyOwner {\n        if (_newTimelockTimestamp + _oldTimelock > block.timestamp) require(!_isTimelockActiveChange, \"3095\");\n        require(!_isOracleActiveChange, \"3093\");\n        require(!_isOracleDataActiveChange, \"3096\");\n        require(_newVal != 0, \"2001\");\n\n        _isTimelockActiveChange = true;\n        _oldTimelock = timelockAmount;\n        _newTimelock = _newVal;\n        _newTimelockTimestamp = block.timestamp;\n        emit TimelockAmountUpdateRequested(_oldTimelock, _newTimelock);\n    }\n\n    /**\n     * @notice Updates the timelock amount.\n     *\n     * @notice Requirements:\n     * - Timelock change must have been requested and the timelock must have passed.\n     * - The timelock for timelock change must have already expired.\n     *\n     * @notice Effects:\n     * - Updates `timelockAmount` state variable.\n     * - Updates `_oldTimelock` state variable.\n     * - Updates `_newTimelock` state variable.\n     * - Updates `_newTimelockTimestamp` state variable.\n     *\n     * @notice Emits:\n     * - `TimelockAmountUpdated` event indicating timelock amount change operation.\n     */\n    function acceptTimelockAmountChange() external override onlyOwner {\n        require(_isTimelockActiveChange, \"3094\");\n        require(_newTimelockTimestamp + _oldTimelock <= block.timestamp, \"3066\");\n\n        timelockAmount = _newTimelock;\n        emit TimelockAmountUpdated(_oldTimelock, _newTimelock);\n        _oldTimelock = 0;\n        _newTimelock = 0;\n        _newTimelockTimestamp = 0;\n\n        _isTimelockActiveChange = false;\n    }\n\n    // -- Getters --\n\n    /**\n     * @notice Returns the up to date exchange rate of the `token`.\n     *\n     * @notice Requirements:\n     * - Oracle must provide an updated rate.\n     *\n     * @return The updated exchange rate.\n     */\n    function getExchangeRate() external view override returns (uint256) {\n        (bool updated, uint256 rate) = oracle.peek(oracleData);\n        require(updated, \"3037\");\n        require(rate > 0, \"2100\");\n\n        return rate;\n    }\n\n    /**\n     * @notice Returns the configuration parameters for the registry.\n     * @return The RegistryConfig struct containing the parameters.\n     */\n    function getConfig() external view override returns (RegistryConfig memory) {\n        return config;\n    }\n\n    // -- Private methods --\n\n    /**\n     * @notice Updates the configuration parameters for the registry.\n     * @param _config The new configuration parameters.\n     */\n    function _updateConfig(\n        RegistryConfig memory _config\n    ) private {\n        uint256 precision = manager.PRECISION();\n\n        require(_config.collateralizationRate >= minCR && _config.collateralizationRate <= precision, \"3066\");\n        require(_config.liquidationBuffer <= maxLiquidationBuffer, \"3100\");\n\n        uint256 maxLiquidatorBonus = precision - _config.collateralizationRate - _config.liquidationBuffer;\n        require(_config.liquidatorBonus <= maxLiquidatorBonus, \"3101\");\n\n        emit ConfigUpdated(token, config, _config);\n        config = _config;\n    }\n\n    // -- Modifiers --\n\n    /**\n     * @notice Modifier to only allow access to a function by the Stables Manager Contract.\n     */\n    modifier onlyStableManager() {\n        require(msg.sender == manager.stablesManager(), \"1000\");\n        _;\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/access/Ownable2Step.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable2Step.sol)\n\npragma solidity ^0.8.20;\n\nimport {Ownable} from \"./Ownable.sol\";\n\n/**\n * @dev Contract module which provides access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is specified at deployment time in the constructor for `Ownable`. This\n * can later be changed with {transferOwnership} and {acceptOwnership}.\n *\n * This module is used through inheritance. It will make available all functions\n * from parent (Ownable).\n */\nabstract contract Ownable2Step is Ownable {\n    address private _pendingOwner;\n\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Returns the address of the pending owner.\n     */\n    function pendingOwner() public view virtual returns (address) {\n        return _pendingOwner;\n    }\n\n    /**\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\n        _pendingOwner = newOwner;\n        emit OwnershipTransferStarted(owner(), newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual override {\n        delete _pendingOwner;\n        super._transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev The new owner accepts the ownership transfer.\n     */\n    function acceptOwnership() public virtual {\n        address sender = _msgSender();\n        if (pendingOwner() != sender) {\n            revert OwnableUnauthorizedAccount(sender);\n        }\n        _transferOwnership(sender);\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "src/interfaces/core/IManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { IOracle } from \"../oracle/IOracle.sol\";\n\n/**\n * @title IManager.\n * @dev Interface for the Manager Contract.\n */\ninterface IManager {\n    // -- Events --\n\n    /**\n     * @notice Emitted when a new contract is whitelisted.\n     * @param contractAddress The address of the contract that is whitelisted.\n     */\n    event ContractWhitelisted(address indexed contractAddress);\n\n    /**\n     * @notice Emitted when a contract is removed from the whitelist.\n     * @param contractAddress The address of the contract that is removed from the whitelist.\n     */\n    event ContractBlacklisted(address indexed contractAddress);\n\n    /**\n     * @notice Emitted when a new token is whitelisted.\n     * @param token The address of the token that is whitelisted.\n     */\n    event TokenWhitelisted(address indexed token);\n\n    /**\n     * @notice Emitted when a new token is removed from the whitelist.\n     * @param token The address of the token that is removed from the whitelist.\n     */\n    event TokenRemoved(address indexed token);\n\n    /**\n     * @notice Emitted when a withdrawable token is added.\n     * @param token The address of the withdrawable token.\n     */\n    event WithdrawableTokenAdded(address indexed token);\n\n    /**\n     * @notice Emitted when a withdrawable token is removed.\n     * @param token The address of the withdrawable token.\n     */\n    event WithdrawableTokenRemoved(address indexed token);\n\n    /**\n     * @notice Emitted when invoker is updated.\n     * @param component The address of the invoker component.\n     * @param allowed Boolean indicating if the invoker is allowed or not.\n     */\n    event InvokerUpdated(address indexed component, bool allowed);\n\n    /**\n     * @notice Emitted when the holding manager is set.\n     * @param oldAddress The previous address of the holding manager.\n     * @param newAddress The new address of the holding manager.\n     */\n    event HoldingManagerUpdated(address indexed oldAddress, address indexed newAddress);\n\n    /**\n     * @notice Emitted when a new liquidation manager is requested.\n     * @param oldAddress The previous address of the liquidation manager.\n     * @param newAddress The new address of the liquidation manager.\n     */\n    event NewLiquidationManagerRequested(address indexed oldAddress, address indexed newAddress);\n\n    /**\n     * @notice Emitted when the liquidation manager is set.\n     * @param oldAddress The previous address of the liquidation manager.\n     * @param newAddress The new address of the liquidation manager.\n     */\n    event LiquidationManagerUpdated(address indexed oldAddress, address indexed newAddress);\n\n    /**\n     * @notice Emitted when the stablecoin manager is set.\n     * @param oldAddress The previous address of the stablecoin manager.\n     * @param newAddress The new address of the stablecoin manager.\n     */\n    event StablecoinManagerUpdated(address indexed oldAddress, address indexed newAddress);\n\n    /**\n     * @notice Emitted when the strategy manager is set.\n     * @param oldAddress The previous address of the strategy manager.\n     * @param newAddress The new address of the strategy manager.\n     */\n    event StrategyManagerUpdated(address indexed oldAddress, address indexed newAddress);\n\n    /**\n     * @notice Emitted when a new swap manager is requested.\n     * @param oldAddress The previous address of the swap manager.\n     * @param newAddress The new address of the swap manager.\n     */\n    event NewSwapManagerRequested(address indexed oldAddress, address indexed newAddress);\n\n    /**\n     * @notice Emitted when the swap manager is set.\n     * @param oldAddress The previous address of the swap manager.\n     * @param newAddress The new address of the swap manager.\n     */\n    event SwapManagerUpdated(address indexed oldAddress, address indexed newAddress);\n\n    /**\n     * @notice Emitted when the default fee is updated.\n     * @param oldFee The previous fee.\n     * @param newFee The new fee.\n     */\n    event PerformanceFeeUpdated(uint256 indexed oldFee, uint256 indexed newFee);\n\n    /**\n     * @notice Emitted when the withdraw fee is updated.\n     * @param oldFee The previous withdraw fee.\n     * @param newFee The new withdraw fee.\n     */\n    event WithdrawalFeeUpdated(uint256 indexed oldFee, uint256 indexed newFee);\n\n    /**\n     * @notice Emitted when the liquidator's bonus is updated.\n     * @param oldAmount The previous amount of the liquidator's bonus.\n     * @param newAmount The new amount of the liquidator's bonus.\n     */\n    event LiquidatorBonusUpdated(uint256 oldAmount, uint256 newAmount);\n\n    /**\n     * @notice Emitted when the fee address is changed.\n     * @param oldAddress The previous fee address.\n     * @param newAddress The new fee address.\n     */\n    event FeeAddressUpdated(address indexed oldAddress, address indexed newAddress);\n\n    /**\n     * @notice Emitted when the receipt token factory is updated.\n     * @param oldAddress The previous address of the receipt token factory.\n     * @param newAddress The new address of the receipt token factory.\n     */\n    event ReceiptTokenFactoryUpdated(address indexed oldAddress, address indexed newAddress);\n\n    /**\n     * @notice Emitted when the liquidity gauge factory is updated.\n     * @param oldAddress The previous address of the liquidity gauge factory.\n     * @param newAddress The new address of the liquidity gauge factory.\n     */\n    event LiquidityGaugeFactoryUpdated(address indexed oldAddress, address indexed newAddress);\n\n    /**\n     * @notice Emitted when new oracle is requested.\n     * @param newOracle The address of the new oracle.\n     */\n    event NewOracleRequested(address newOracle);\n\n    /**\n     * @notice Emitted when the oracle is updated.\n     * @param oldOracle The address of the old oracle.\n     * @param newOracle The address of the new oracle.\n     */\n    event OracleUpdated(address indexed oldOracle, address indexed newOracle);\n\n    /**\n     * @notice Emitted when oracle data is updated.\n     * @param oldData The address of the old oracle data.\n     * @param newData The address of the new oracle data.\n     */\n    event OracleDataUpdated(bytes indexed oldData, bytes indexed newData);\n\n    /**\n     * @notice Emitted when a new timelock amount is requested.\n     * @param oldVal The previous timelock amount.\n     * @param newVal The new timelock amount.\n     */\n    event TimelockAmountUpdateRequested(uint256 oldVal, uint256 newVal);\n\n    /**\n     * @notice Emitted when timelock amount is updated.\n     * @param oldVal The previous timelock amount.\n     * @param newVal The new timelock amount.\n     */\n    event TimelockAmountUpdated(uint256 oldVal, uint256 newVal);\n\n    // -- Mappings --\n\n    /**\n     * @notice Returns true/false for contracts' whitelist status.\n     * @param _contract The address of the contract.\n     */\n    function isContractWhitelisted(\n        address _contract\n    ) external view returns (bool);\n\n    /**\n     * @notice Returns true if token is whitelisted.\n     * @param _token The address of the token.\n     */\n    function isTokenWhitelisted(\n        address _token\n    ) external view returns (bool);\n\n    /**\n     * @notice Returns true if the token can be withdrawn from a holding.\n     * @param _token The address of the token.\n     */\n    function isTokenWithdrawable(\n        address _token\n    ) external view returns (bool);\n\n    /**\n     * @notice Returns true if caller is allowed invoker.\n     * @param _invoker The address of the invoker.\n     */\n    function allowedInvokers(\n        address _invoker\n    ) external view returns (bool);\n\n    // -- Essential tokens --\n\n    /**\n     * @notice WETH address.\n     */\n    function WETH() external view returns (address);\n\n    // -- Protocol's stablecoin oracle config --\n\n    /**\n     * @notice Oracle contract associated with protocol's stablecoin.\n     */\n    function jUsdOracle() external view returns (IOracle);\n\n    /**\n     * @notice Extra oracle data if needed.\n     */\n    function oracleData() external view returns (bytes calldata);\n\n    // -- Managers --\n\n    /**\n     * @notice Returns the address of the HoldingManager Contract.\n     */\n    function holdingManager() external view returns (address);\n\n    /**\n     * @notice Returns the address of the LiquidationManager Contract.\n     */\n    function liquidationManager() external view returns (address);\n\n    /**\n     * @notice Returns the address of the StablesManager Contract.\n     */\n    function stablesManager() external view returns (address);\n\n    /**\n     * @notice Returns the address of the StrategyManager Contract.\n     */\n    function strategyManager() external view returns (address);\n\n    /**\n     * @notice Returns the address of the SwapManager Contract.\n     */\n    function swapManager() external view returns (address);\n\n    // -- Fees --\n\n    /**\n     * @notice Returns the default performance fee.\n     * @dev Uses 2 decimal precision, where 1% is represented as 100.\n     */\n    function performanceFee() external view returns (uint256);\n\n    /**\n     * @notice Returns the maximum performance fee.\n     * @dev Uses 2 decimal precision, where 1% is represented as 100.\n     */\n    function MAX_PERFORMANCE_FEE() external view returns (uint256);\n\n    /**\n     * @notice Fee for withdrawing from a holding.\n     * @dev Uses 2 decimal precision, where 1% is represented as 100.\n     */\n    function withdrawalFee() external view returns (uint256);\n\n    /**\n     * @notice Returns the maximum withdrawal fee.\n     * @dev Uses 2 decimal precision, where 1% is represented as 100.\n     */\n    function MAX_WITHDRAWAL_FEE() external view returns (uint256);\n\n    /**\n     * @notice Returns the fee address, where all the fees are collected.\n     */\n    function feeAddress() external view returns (address);\n\n    // -- Factories --\n\n    /**\n     * @notice Returns the address of the ReceiptTokenFactory.\n     */\n    function receiptTokenFactory() external view returns (address);\n\n    // -- Utility values --\n\n    /**\n     * @notice Minimum allowed jUSD debt amount for a holding to ensure successful liquidation.\n     */\n    function minDebtAmount() external view returns (uint256);\n\n    /**\n     * @notice Returns the collateral rate precision.\n     * @dev Should be less than exchange rate precision due to optimization in math.\n     */\n    function PRECISION() external view returns (uint256);\n\n    /**\n     * @notice Returns the exchange rate precision.\n     */\n    function EXCHANGE_RATE_PRECISION() external view returns (uint256);\n\n    /**\n     * @notice Timelock amount in seconds for changing the oracle data.\n     */\n    function timelockAmount() external view returns (uint256);\n\n    /**\n     * @notice Returns the old timelock value for delayed timelock update.\n     */\n    function oldTimelock() external view returns (uint256);\n\n    /**\n     * @notice Returns the new timelock value for delayed timelock update.\n     */\n    function newTimelock() external view returns (uint256);\n\n    /**\n     * @notice Returns the timestamp when the new timelock was requested.\n     */\n    function newTimelockTimestamp() external view returns (uint256);\n\n    /**\n     * @notice Returns the new oracle address for delayed oracle update.\n     */\n    function newOracle() external view returns (address);\n\n    /**\n     * @notice Returns the timestamp when the new oracle was requested.\n     */\n    function newOracleTimestamp() external view returns (uint256);\n\n    /**\n     * @notice Returns the new swap manager address for delayed swap manager update.\n     */\n    function newSwapManager() external view returns (address);\n\n    /**\n     * @notice Returns the timestamp when the new swap manager was requested.\n     */\n    function newSwapManagerTimestamp() external view returns (uint256);\n\n    /**\n     * @notice Returns the new liquidation manager address for delayed liquidation manager update.\n     */\n    function newLiquidationManager() external view returns (address);\n\n    /**\n     * @notice Returns the timestamp when the new liquidation manager was requested.\n     */\n    function newLiquidationManagerTimestamp() external view returns (uint256);\n\n    // -- Setters --\n\n    /**\n     * @notice Whitelists a contract.\n     *\n     * @notice Requirements:\n     * - `_contract` must not be whitelisted.\n     *\n     * @notice Effects:\n     * - Updates the `isContractWhitelisted` mapping.\n     *\n     * @notice Emits:\n     * - `ContractWhitelisted` event indicating successful contract whitelist operation.\n     *\n     * @param _contract The address of the contract to be whitelisted.\n     */\n    function whitelistContract(\n        address _contract\n    ) external;\n\n    /**\n     * @notice Blacklists a contract.\n     *\n     * @notice Requirements:\n     * - `_contract` must be whitelisted.\n     *\n     * @notice Effects:\n     * - Updates the `isContractWhitelisted` mapping.\n     *\n     * @notice Emits:\n     * - `ContractBlacklisted` event indicating successful contract blacklist operation.\n     *\n     * @param _contract The address of the contract to be blacklisted.\n     */\n    function blacklistContract(\n        address _contract\n    ) external;\n\n    /**\n     * @notice Whitelists a token.\n     *\n     * @notice Requirements:\n     * - `_token` must not be whitelisted.\n     *\n     * @notice Effects:\n     * - Updates the `isTokenWhitelisted` mapping.\n     *\n     * @notice Emits:\n     * - `TokenWhitelisted` event indicating successful token whitelist operation.\n     *\n     * @param _token The address of the token to be whitelisted.\n     */\n    function whitelistToken(\n        address _token\n    ) external;\n\n    /**\n     * @notice Removes a token from whitelist.\n     *\n     * @notice Requirements:\n     * - `_token` must be whitelisted.\n     *\n     * @notice Effects:\n     * - Updates the `isTokenWhitelisted` mapping.\n     *\n     * @notice Emits:\n     * - `TokenRemoved` event indicating successful token removal operation.\n     *\n     * @param _token The address of the token to be whitelisted.\n     */\n    function removeToken(\n        address _token\n    ) external;\n\n    /**\n     * @notice Registers the `_token` as withdrawable.\n     *\n     * @notice Requirements:\n     * - `msg.sender` must be owner or `strategyManager`.\n     * - `_token` must not be withdrawable.\n     *\n     * @notice Effects:\n     * - Updates the `isTokenWithdrawable` mapping.\n     *\n     * @notice Emits:\n     * - `WithdrawableTokenAdded` event indicating successful withdrawable token addition operation.\n     *\n     * @param _token The address of the token to be added as withdrawable.\n     */\n    function addWithdrawableToken(\n        address _token\n    ) external;\n\n    /**\n     * @notice Unregisters the `_token` as withdrawable.\n     *\n     * @notice Requirements:\n     * - `_token` must be withdrawable.\n     *\n     * @notice Effects:\n     * - Updates the `isTokenWithdrawable` mapping.\n     *\n     * @notice Emits:\n     * - `WithdrawableTokenRemoved` event indicating successful withdrawable token removal operation.\n     *\n     * @param _token The address of the token to be removed as withdrawable.\n     */\n    function removeWithdrawableToken(\n        address _token\n    ) external;\n\n    /**\n     * @notice Sets invoker as allowed or forbidden.\n     *\n     * @notice Effects:\n     * - Updates the `allowedInvokers` mapping.\n     *\n     * @notice Emits:\n     * - `InvokerUpdated` event indicating successful invoker update operation.\n     *\n     * @param _component Invoker's address.\n     * @param _allowed True/false.\n     */\n    function updateInvoker(address _component, bool _allowed) external;\n\n    /**\n     * @notice Sets the Holding Manager Contract's address.\n     *\n     * @notice Requirements:\n     * - `_val` must be different from previous `holdingManager` address.\n     *\n     * @notice Effects:\n     * - Updates the `holdingManager` state variable.\n     *\n     * @notice Emits:\n     * - `HoldingManagerUpdated` event indicating the successful setting of the Holding Manager's address.\n     *\n     * @param _val The holding manager's address.\n     */\n    function setHoldingManager(\n        address _val\n    ) external;\n\n    /**\n     * @notice Sets the Liquidation Manager Contract's address.\n     *\n     * @notice Requirements:\n     * - Can only be called once.\n     * - `_val` must be non-zero address.\n     *\n     * @notice Effects:\n     * - Updates the `liquidationManager` state variable.\n     *\n     * @notice Emits:\n     * - `LiquidationManagerUpdated` event indicating the successful setting of the Liquidation Manager's address.\n     *\n     * @param _val The liquidation manager's address.\n     */\n    function setLiquidationManager(\n        address _val\n    ) external;\n\n    /**\n     * @notice Initiates the process to update the Liquidation Manager Contract's address.\n     *\n     * @notice Requirements:\n     * - `_val` must be non-zero address.\n     * - `_val` must be different from previous `liquidationManager` address.\n     *\n     * @notice Effects:\n     * - Updates the the `_newLiquidationManager` state variable.\n     * - Updates the the `_newLiquidationManagerTimestamp` state variable.\n     *\n     * @notice Emits:\n     * - `LiquidationManagerUpdateRequested` event indicating successful liquidation manager change request.\n     *\n     * @param _val The new liquidation manager's address.\n     */\n    function requestNewLiquidationManager(\n        address _val\n    ) external;\n\n    /**\n     * @notice Sets the Liquidation Manager Contract's address.\n     *\n     * @notice Requirements:\n     * - `_val` must be different from previous `liquidationManager` address.\n     * - Timelock must expire.\n     *\n     * @notice Effects:\n     * - Updates the `liquidationManager` state variable.\n     * - Updates the the `_newLiquidationManager` state variable.\n     * - Updates the the `_newLiquidationManagerTimestamp` state variable.\n     *\n     * @notice Emits:\n     * - `LiquidationManagerUpdated` event indicating the successful setting of the Liquidation Manager's address.\n     */\n    function acceptNewLiquidationManager() external;\n\n    /**\n     * @notice Sets the Stablecoin Manager Contract's address.\n     *\n     * @notice Requirements:\n     * - `_val` must be different from previous `stablesManager` address.\n     *\n     * @notice Effects:\n     * - Updates the `stablesManager` state variable.\n     *\n     * @notice Emits:\n     * - `StablecoinManagerUpdated` event indicating the successful setting of the Stablecoin Manager's address.\n     *\n     * @param _val The Stablecoin manager's address.\n     */\n    function setStablecoinManager(\n        address _val\n    ) external;\n\n    /**\n     * @notice Sets the Strategy Manager Contract's address.\n     *\n     * @notice Requirements:\n     * - `_val` must be different from previous `strategyManager` address.\n     *\n     * @notice Effects:\n     * - Updates the `strategyManager` state variable.\n     *\n     * @notice Emits:\n     * - `StrategyManagerUpdated` event indicating the successful setting of the Strategy Manager's address.\n     *\n     * @param _val The Strategy manager's address.\n     */\n    function setStrategyManager(\n        address _val\n    ) external;\n\n    /**\n     * @notice Sets the Swap Manager Contract's address.\n     *\n     * @notice Requirements:\n     * - Can only be called once.\n     * - `_val` must be non-zero address.\n     *\n     * @notice Effects:\n     * - Updates the `swapManager` state variable.\n     *\n     * @notice Emits:\n     * - `SwapManagerUpdated` event indicating the successful setting of the Swap Manager's address.\n     *\n     * @param _val The Swap manager's address.\n     */\n    function setSwapManager(\n        address _val\n    ) external;\n\n    /**\n     * @notice Initiates the process to update the Swap Manager Contract's address.\n     *\n     * @notice Requirements:\n     * - `_val` must be non-zero address.\n     * - `_val` must be different from previous `swapManager` address.\n     *\n     * @notice Effects:\n     * - Updates the the `_newSwapManager` state variable.\n     * - Updates the the `_newSwapManagerTimestamp` state variable.\n     *\n     * @notice Emits:\n     * - `NewSwapManagerRequested` event indicating successful swap manager change request.\n     *\n     * @param _val The new swap manager's address.\n     */\n    function requestNewSwapManager(\n        address _val\n    ) external;\n\n    /**\n     * @notice Updates the Swap Manager Contract    .\n     *\n     * @notice Requirements:\n     * - Timelock must expire.\n     *\n     * @notice Effects:\n     * - Updates the `swapManager` state variable.\n     * - Resets `_newSwapManager` to address(0).\n     * - Resets `_newSwapManagerTimestamp` to 0.\n     *\n     * @notice Emits:\n     * - `SwapManagerUpdated` event indicating the successful setting of the Swap Manager's address.\n     */\n    function acceptNewSwapManager() external;\n\n    /**\n     * @notice Sets the performance fee.\n     *\n     * @notice Requirements:\n     * - `_val` must be smaller than `FEE_FACTOR` to avoid wrong computations.\n     *\n     * @notice Effects:\n     * - Updates the `performanceFee` state variable.\n     *\n     * @notice Emits:\n     * - `PerformanceFeeUpdated` event indicating successful performance fee update operation.\n     *\n     * @dev `_val` uses 2 decimal precision, where 1% is represented as 100.\n     *\n     * @param _val The new performance fee value.\n     */\n    function setPerformanceFee(\n        uint256 _val\n    ) external;\n\n    /**\n     * @notice Sets the withdrawal fee.\n     *\n     * @notice Requirements:\n     * - `_val` must be smaller than `FEE_FACTOR` to avoid wrong computations.\n     *\n     * @notice Effects:\n     * - Updates the `withdrawalFee` state variable.\n     *\n     * @notice Emits:\n     * - `WithdrawalFeeUpdated` event indicating successful withdrawal fee update operation.\n     *\n     * @dev `_val` uses 2 decimal precision, where 1% is represented as 100.\n     *\n     * @param _val The new withdrawal fee value.\n     */\n    function setWithdrawalFee(\n        uint256 _val\n    ) external;\n\n    /**\n     * @notice Sets the global fee address.\n     *\n     * @notice Requirements:\n     * - `_val` must be different from previous `holdingManager` address.\n     *\n     * @notice Effects:\n     * - Updates the `feeAddress` state variable.\n     *\n     * @notice Emits:\n     * - `FeeAddressUpdated` event indicating successful setting of the global fee address.\n     *\n     * @param _val The new fee address.\n     */\n    function setFeeAddress(\n        address _val\n    ) external;\n\n    /**\n     * @notice Sets the receipt token factory's address.\n     *\n     * @notice Requirements:\n     * - `_val` must be different from previous `receiptTokenFactory` address.\n     *\n     * @notice Effects:\n     * - Updates the `receiptTokenFactory` state variable.\n     *\n     * @notice Emits:\n     * - `ReceiptTokenFactoryUpdated` event indicating successful setting of the `receiptTokenFactory` address.\n     *\n     * @param _factory Receipt token factory's address.\n     */\n    function setReceiptTokenFactory(\n        address _factory\n    ) external;\n\n    /**\n     * @notice Registers jUSD's oracle change request.\n     *\n     * @notice Requirements:\n     * - Contract must not be in active change.\n     *\n     * @notice Effects:\n     * - Updates the the `_isActiveChange` state variable.\n     * - Updates the the `_newOracle` state variable.\n     * - Updates the the `_newOracleTimestamp` state variable.\n     *\n     * @notice Emits:\n     * - `NewOracleRequested` event indicating successful jUSD's oracle change request.\n     *\n     * @param _oracle Liquidity gauge factory's address.\n     */\n    function requestNewJUsdOracle(\n        address _oracle\n    ) external;\n\n    /**\n     * @notice Updates jUSD's oracle.\n     *\n     * @notice Requirements:\n     * - Contract must be in active change.\n     * - Timelock must expire.\n     *\n     * @notice Effects:\n     * - Updates the the `jUsdOracle` state variable.\n     * - Updates the the `_isActiveChange` state variable.\n     * - Updates the the `_newOracle` state variable.\n     * - Updates the the `_newOracleTimestamp` state variable.\n     *\n     * @notice Emits:\n     * - `OracleUpdated` event indicating successful jUSD's oracle change.\n     */\n    function acceptNewJUsdOracle() external;\n\n    /**\n     * @notice Updates the jUSD's oracle data.\n     *\n     * @notice Requirements:\n     * - `_newOracleData` must be different from previous `oracleData`.\n     *\n     * @notice Effects:\n     * - Updates the `oracleData` state variable.\n     *\n     * @notice Emits:\n     * - `OracleDataUpdated` event indicating successful update of the oracle Data.\n     *\n     * @param _newOracleData New data used for jUSD's oracle data.\n     */\n    function setJUsdOracleData(\n        bytes calldata _newOracleData\n    ) external;\n\n    /**\n     * @notice Sets the minimum debt amount.\n     *\n     * @notice Requirements:\n     * - `_minDebtAmount` must be greater than zero.\n     * - `_minDebtAmount` must be different from previous `minDebtAmount`.\n     *\n     * @param _minDebtAmount The new minimum debt amount.\n     */\n    function setMinDebtAmount(\n        uint256 _minDebtAmount\n    ) external;\n\n    /**\n     * @notice Registers timelock change request.\n     *\n     * @notice Requirements:\n     * - `_oldTimelock` must be set zero.\n     * - `_newVal` must be greater than zero.\n     *\n     * @notice Effects:\n     * - Updates the the `_oldTimelock` state variable.\n     * - Updates the the `_newTimelock` state variable.\n     * - Updates the the `_newTimelockTimestamp` state variable.\n     *\n     * @notice Emits:\n     * - `TimelockAmountUpdateRequested` event indicating successful timelock change request.\n     *\n     * @param _newVal The new timelock value in seconds.\n     */\n    function requestNewTimelock(\n        uint256 _newVal\n    ) external;\n\n    /**\n     * @notice Updates the timelock amount.\n     *\n     * @notice Requirements:\n     * - Contract must be in active change.\n     * - `_newTimelock` must be greater than zero.\n     * - The old timelock must expire.\n     *\n     * @notice Effects:\n     * - Updates the the `timelockAmount` state variable.\n     * - Updates the the `_oldTimelock` state variable.\n     * - Updates the the `_newTimelock` state variable.\n     * - Updates the the `_newTimelockTimestamp` state variable.\n     *\n     * @notice Emits:\n     * - `TimelockAmountUpdated` event indicating successful timelock amount change.\n     */\n    function acceptNewTimelock() external;\n\n    // -- Getters --\n\n    /**\n     * @notice Returns the up to date exchange rate of the protocol's stablecoin jUSD.\n     *\n     * @notice Requirements:\n     * - Oracle must have updated rate.\n     * - Rate must be a non zero positive value.\n     *\n     * @return The current exchange rate.\n     */\n    function getJUsdExchangeRate() external view returns (uint256);\n}\n"
    },
    "src/interfaces/core/ISharesRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { IOracle } from \"../oracle/IOracle.sol\";\nimport { IManager } from \"./IManager.sol\";\n\n/**\n * @title ISharesRegistry\n * @dev Interface for the Shares Registry Contract.\n * @dev Based on MIM CauldraonV2 contract.\n */\ninterface ISharesRegistry {\n    /**\n     * @notice Configuration struct for registry parameters.\n     * @dev Used to store key parameters that control collateral and liquidation behavior.\n     *\n     * @param collateralizationRate The minimum collateral ratio required, expressed as a percentage with precision.\n     * @param liquidationBuffer Is a value, that represents the buffer between the collateralization rate and the\n     * liquidation threshold, upon which the liquidation is allowed.\n     * @param liquidatorBonus The bonus percentage given to liquidators as incentive, expressed with precision.\n     */\n    struct RegistryConfig {\n        uint256 collateralizationRate;\n        uint256 liquidationBuffer;\n        uint256 liquidatorBonus;\n    }\n\n    /**\n     * @notice Event emitted when borrowed amount is set.\n     * @param _holding The address of the holding.\n     * @param oldVal The old value.\n     * @param newVal The new value.\n     */\n    event BorrowedSet(address indexed _holding, uint256 oldVal, uint256 newVal);\n\n    /**\n     * @notice Event emitted when collateral is registered.\n     * @param user The address of the user.\n     * @param share The amount of shares.\n     */\n    event CollateralAdded(address indexed user, uint256 share);\n\n    /**\n     * @notice Event emitted when collateral was unregistered.\n     * @param user The address of the user.\n     * @param share The amount of shares.\n     */\n    event CollateralRemoved(address indexed user, uint256 share);\n\n    /**\n     * @notice Event emitted when the collateralization rate is updated.\n     * @param oldVal The old value.\n     * @param newVal The new value.\n     */\n    event CollateralizationRateUpdated(uint256 oldVal, uint256 newVal);\n\n    /**\n     * @notice Event emitted when a new oracle is requested.\n     * @param newOracle The new oracle address.\n     */\n    event NewOracleRequested(address newOracle);\n\n    /**\n     * @notice Event emitted when the oracle is updated.\n     */\n    event OracleUpdated();\n\n    /**\n     * @notice Event emitted when new oracle data is requested.\n     * @param newData The new data.\n     */\n    event NewOracleDataRequested(bytes newData);\n\n    /**\n     * @notice Event emitted when oracle data is updated.\n     */\n    event OracleDataUpdated();\n\n    /**\n     * @notice Event emitted when a new timelock amount is requested.\n     * @param oldVal The old value.\n     * @param newVal The new value.\n     */\n    event TimelockAmountUpdateRequested(uint256 oldVal, uint256 newVal);\n\n    /**\n     * @notice Event emitted when timelock amount is updated.\n     * @param oldVal The old value.\n     * @param newVal The new value.\n     */\n    event TimelockAmountUpdated(uint256 oldVal, uint256 newVal);\n\n    /**\n     * @notice Event emitted when the config is updated.\n     * @param token The token address.\n     * @param oldVal The old config.\n     * @param newVal The new config.\n     */\n    event ConfigUpdated(address indexed token, RegistryConfig oldVal, RegistryConfig newVal);\n\n    /**\n     * @notice Returns holding's borrowed amount.\n     * @param _holding The address of the holding.\n     * @return The borrowed amount.\n     */\n    function borrowed(\n        address _holding\n    ) external view returns (uint256);\n\n    /**\n     * @notice Returns holding's available collateral amount.\n     * @param _holding The address of the holding.\n     * @return The collateral amount.\n     */\n    function collateral(\n        address _holding\n    ) external view returns (uint256);\n\n    /**\n     * @notice Returns the token address for which this registry was created.\n     * @return The token address.\n     */\n    function token() external view returns (address);\n\n    /**\n     * @notice Contract that contains all the necessary configs of the protocol.\n     * @return The manager contract.\n     */\n    function manager() external view returns (IManager);\n\n    /**\n     * @notice Oracle contract associated with this share registry.\n     * @return The oracle contract.\n     */\n    function oracle() external view returns (IOracle);\n\n    /**\n     * @notice Extra oracle data if needed.\n     * @return The oracle data.\n     */\n    function oracleData() external view returns (bytes calldata);\n\n    /**\n     * @notice Current timelock amount.\n     * @return The timelock amount.\n     */\n    function timelockAmount() external view returns (uint256);\n\n    // -- User specific methods --\n\n    /**\n     * @notice Updates `_holding`'s borrowed amount.\n     *\n     * @notice Requirements:\n     * - `msg.sender` must be the Stables Manager Contract.\n     * - `_newVal` must be greater than or equal to the minimum debt amount.\n     *\n     * @notice Effects:\n     * - Updates `borrowed` mapping.\n     *\n     * @notice Emits:\n     * - `BorrowedSet` indicating holding's borrowed amount update operation.\n     *\n     * @param _holding The address of the user's holding.\n     * @param _newVal The new borrowed amount.\n     */\n    function setBorrowed(address _holding, uint256 _newVal) external;\n\n    /**\n     * @notice Registers collateral for user's `_holding`.\n     *\n     * @notice Requirements:\n     * - `msg.sender` must be the Stables Manager Contract.\n     *\n     * @notice Effects:\n     * - Updates `collateral` mapping.\n     *\n     * @notice Emits:\n     * - `CollateralAdded` event indicating collateral addition operation.\n     *\n     * @param _holding The address of the user's holding.\n     * @param _share The new collateral shares.\n     */\n    function registerCollateral(address _holding, uint256 _share) external;\n\n    /**\n     * @notice Registers a collateral removal operation for user's `_holding`.\n     *\n     * @notice Requirements:\n     * - `msg.sender` must be the Stables Manager Contract.\n     *\n     * @notice Effects:\n     * - Updates `collateral` mapping.\n     *\n     * @notice Emits:\n     * - `CollateralRemoved` event indicating collateral removal operation.\n     *\n     * @param _holding The address of the user's holding.\n     * @param _share The new collateral shares.\n     */\n    function unregisterCollateral(address _holding, uint256 _share) external;\n\n    // -- Administration --\n\n    /**\n     * @notice Updates the registry configuration parameters.\n     *\n     * @notice Effects:\n     * - Updates `config` state variable.\n     *\n     * @notice Emits:\n     * - `ConfigUpdated` event indicating config update operation.\n     *\n     * @param _newConfig The new configuration parameters.\n     */\n    function updateConfig(\n        RegistryConfig memory _newConfig\n    ) external;\n\n    /**\n     * @notice Requests a change for the oracle address.\n     *\n     * @notice Requirements:\n     * - Previous oracle change request must have expired or been accepted.\n     * - No timelock or oracle data change requests should be active.\n     * - `_oracle` must not be the zero address.\n     *\n     * @notice Effects:\n     * - Updates `_isOracleActiveChange` state variable.\n     * - Updates `_newOracle` state variable.\n     * - Updates `_newOracleTimestamp` state variable.\n     *\n     * @notice Emits:\n     * - `NewOracleRequested` event indicating new oracle request.\n     *\n     * @param _oracle The new oracle address.\n     */\n    function requestNewOracle(\n        address _oracle\n    ) external;\n\n    /**\n     * @notice Updates the oracle.\n     *\n     * @notice Requirements:\n     * - Oracle change must have been requested and the timelock must have passed.\n     *\n     * @notice Effects:\n     * - Updates `oracle` state variable.\n     * - Updates `_isOracleActiveChange` state variable.\n     * - Updates `_newOracle` state variable.\n     * - Updates `_newOracleTimestamp` state variable.\n     *\n     * @notice Emits:\n     * - `OracleUpdated` event indicating oracle update.\n     */\n    function setOracle() external;\n\n    /**\n     * @notice Requests a change for oracle data.\n     *\n     * @notice Requirements:\n     * - Previous oracle data change request must have expired or been accepted.\n     * - No timelock or oracle change requests should be active.\n     *\n     * @notice Effects:\n     * - Updates `_isOracleDataActiveChange` state variable.\n     * - Updates `_newOracleData` state variable.\n     * - Updates `_newOracleDataTimestamp` state variable.\n     *\n     * @notice Emits:\n     * - `NewOracleDataRequested` event indicating new oracle data request.\n     *\n     * @param _data The new oracle data.\n     */\n    function requestNewOracleData(\n        bytes calldata _data\n    ) external;\n\n    /**\n     * @notice Updates the oracle data.\n     *\n     * @notice Requirements:\n     * - Oracle data change must have been requested and the timelock must have passed.\n     *\n     * @notice Effects:\n     * - Updates `oracleData` state variable.\n     * - Updates `_isOracleDataActiveChange` state variable.\n     * - Updates `_newOracleData` state variable.\n     * - Updates `_newOracleDataTimestamp` state variable.\n     *\n     * @notice Emits:\n     * - `OracleDataUpdated` event indicating oracle data update.\n     */\n    function setOracleData() external;\n\n    /**\n     * @notice Requests a timelock update.\n     *\n     * @notice Requirements:\n     * - `_newVal` must not be zero.\n     * - Previous timelock change request must have expired or been accepted.\n     * - No oracle or oracle data change requests should be active.\n     *\n     * @notice Effects:\n     * - Updates `_isTimelockActiveChange` state variable.\n     * - Updates `_oldTimelock` state variable.\n     * - Updates `_newTimelock` state variable.\n     * - Updates `_newTimelockTimestamp` state variable.\n     *\n     * @notice Emits:\n     * - `TimelockAmountUpdateRequested` event indicating timelock change request.\n     *\n     * @param _newVal The new value in seconds.\n     */\n    function requestTimelockAmountChange(\n        uint256 _newVal\n    ) external;\n\n    /**\n     * @notice Updates the timelock amount.\n     *\n     * @notice Requirements:\n     * - Timelock change must have been requested and the timelock must have passed.\n     * - The timelock for timelock change must have already expired.\n     *\n     * @notice Effects:\n     * - Updates `timelockAmount` state variable.\n     * - Updates `_oldTimelock` state variable.\n     * - Updates `_newTimelock` state variable.\n     * - Updates `_newTimelockTimestamp` state variable.\n     *\n     * @notice Emits:\n     * - `TimelockAmountUpdated` event indicating timelock amount change operation.\n     */\n    function acceptTimelockAmountChange() external;\n\n    // -- Getters --\n\n    /**\n     * @notice Returns the up to date exchange rate of the `token`.\n     *\n     * @notice Requirements:\n     * - Oracle must provide an updated rate.\n     *\n     * @return The updated exchange rate.\n     */\n    function getExchangeRate() external view returns (uint256);\n\n    /**\n     * @notice Returns the configuration parameters for the registry.\n     * @return The RegistryConfig struct containing the parameters.\n     */\n    function getConfig() external view returns (RegistryConfig memory);\n}\n"
    },
    "src/interfaces/core/IStablesManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { IJigsawUSD } from \"../core/IJigsawUSD.sol\";\nimport { ISharesRegistry } from \"../core/ISharesRegistry.sol\";\nimport { IManager } from \"./IManager.sol\";\n\n/**\n * @title IStablesManager\n * @notice Interface for the Stables Manager.\n */\ninterface IStablesManager {\n    // -- Custom types --\n\n    /**\n     * @notice Structure to store state and deployment address for a share registry\n     */\n    struct ShareRegistryInfo {\n        bool active; // Flag indicating if the registry is active\n        address deployedAt; // Address where the registry is deployed\n    }\n\n    /**\n     * @notice Temporary struct used to store data during borrow operations to avoid stack too deep errors.\n     * @dev This struct helps organize variables used in the borrow function.\n     * @param registry The shares registry contract for the collateral token\n     * @param exchangeRatePrecision The precision used for exchange rate calculations\n     * @param amount The normalized amount (18 decimals) of collateral being borrowed against\n     * @param amountValue The USD value of the collateral amount\n     */\n    struct BorrowTempData {\n        ISharesRegistry registry;\n        uint256 exchangeRatePrecision;\n        uint256 amount;\n        uint256 amountValue;\n    }\n\n    // -- Events --\n\n    /**\n     * @notice Emitted when collateral is registered.\n     * @param holding The address of the holding.\n     * @param token The address of the token.\n     * @param amount The amount of collateral.\n     */\n    event AddedCollateral(address indexed holding, address indexed token, uint256 amount);\n\n    /**\n     * @notice Emitted when collateral is unregistered.\n     * @param holding The address of the holding.\n     * @param token The address of the token.\n     * @param amount The amount of collateral.\n     */\n    event RemovedCollateral(address indexed holding, address indexed token, uint256 amount);\n\n    /**\n     * @notice Emitted when a borrow action is performed.\n     * @param holding The address of the holding.\n     * @param jUsdMinted The amount of jUSD minted.\n     * @param mintToUser Boolean indicating if the amount is minted directly to the user.\n     */\n    event Borrowed(address indexed holding, uint256 jUsdMinted, bool mintToUser);\n\n    /**\n     * @notice Emitted when a repay action is performed.\n     * @param holding The address of the holding.\n     * @param amount The amount repaid.\n     * @param burnFrom The address to burn from.\n     */\n    event Repaid(address indexed holding, uint256 amount, address indexed burnFrom);\n\n    /**\n     * @notice Emitted when a registry is added.\n     * @param token The address of the token.\n     * @param registry The address of the registry.\n     */\n    event RegistryAdded(address indexed token, address indexed registry);\n\n    /**\n     * @notice Emitted when a registry is updated.\n     * @param token The address of the token.\n     * @param registry The address of the registry.\n     */\n    event RegistryUpdated(address indexed token, address indexed registry);\n\n    /**\n     * @notice Returns total borrowed jUSD amount using `token`.\n     * @param _token The address of the token.\n     * @return The total borrowed amount.\n     */\n    function totalBorrowed(\n        address _token\n    ) external view returns (uint256);\n\n    /**\n     * @notice Returns config info for each token.\n     * @param _token The address of the token to get registry info for.\n     * @return Boolean indicating if the registry is active and the address of the registry.\n     */\n    function shareRegistryInfo(\n        address _token\n    ) external view returns (bool, address);\n\n    /**\n     * @notice Returns protocol's stablecoin address.\n     * @return The address of the Jigsaw stablecoin.\n     */\n    function jUSD() external view returns (IJigsawUSD);\n\n    /**\n     * @notice Contract that contains all the necessary configs of the protocol.\n     * @return The manager contract.\n     */\n    function manager() external view returns (IManager);\n\n    // -- User specific methods --\n\n    /**\n     * @notice Registers new collateral.\n     *\n     * @dev The amount will be transformed to shares.\n     *\n     * @notice Requirements:\n     * - The caller must be allowed to perform this action directly. If user - use Holding Manager Contract.\n     * - The `_token` must be whitelisted.\n     * - The `_token`'s registry must be active.\n     *\n     * @notice Effects:\n     * - Adds collateral for the holding.\n     *\n     * @notice Emits:\n     * - `AddedCollateral` event indicating successful collateral addition operation.\n     *\n     * @param _holding The holding for which collateral is added.\n     * @param _token Collateral token.\n     * @param _amount Amount of tokens to be added as collateral.\n     */\n    function addCollateral(address _holding, address _token, uint256 _amount) external;\n\n    /**\n     * @notice Unregisters collateral.\n     *\n     * @notice Requirements:\n     * - The contract must not be paused.\n     * - The caller must be allowed to perform this action directly. If user - use Holding Manager Contract.\n     * - The token's registry must be active.\n     * - `_holding` must stay solvent after collateral removal.\n     *\n     * @notice Effects:\n     * - Removes collateral for the holding.\n     *\n     * @notice Emits:\n     * - `RemovedCollateral` event indicating successful collateral removal operation.\n     *\n     * @param _holding The holding for which collateral is removed.\n     * @param _token Collateral token.\n     * @param _amount Amount of collateral.\n     */\n    function removeCollateral(address _holding, address _token, uint256 _amount) external;\n\n    /**\n     * @notice Unregisters collateral.\n     *\n     * @notice Requirements:\n     * - The caller must be the LiquidationManager.\n     * - The token's registry must be active.\n     *\n     * @notice Effects:\n     * - Force removes collateral from the `_holding` in case of liquidation, without checking if user is solvent after\n     * collateral removal.\n     *\n     * @notice Emits:\n     * - `RemovedCollateral` event indicating successful collateral removal operation.\n     *\n     * @param _holding The holding for which collateral is added.\n     * @param _token Collateral token.\n     * @param _amount Amount of collateral.\n     */\n    function forceRemoveCollateral(address _holding, address _token, uint256 _amount) external;\n\n    /**\n     * @notice Mints stablecoin to the user.\n     *\n     * @notice Requirements:\n     * - The caller must be allowed to perform this action directly. If user - use Holding Manager Contract.\n     * - The token's registry must be active.\n     * - `_amount` must be greater than zero.\n     *\n     * @notice Effects:\n     * - Mints stablecoin based on the collateral amount.\n     * - Updates the total borrowed jUSD amount for `_token`, used for borrowing.\n     * - Updates `_holdings`'s borrowed amount in `token`'s registry contract.\n     * - Ensures the holding remains solvent.\n     *\n     * @notice Emits:\n     * - `Borrowed`.\n     *\n     * @param _holding The holding for which collateral is added.\n     * @param _token Collateral token.\n     * @param _amount The collateral amount equivalent for borrowed jUSD.\n     * @param _minJUsdAmountOut The minimum amount of jUSD that is expected to be received.\n     * @param _mintDirectlyToUser If true, mints to user instead of holding.\n     *\n     * @return jUsdMintAmount The amount of jUSD minted.\n     */\n    function borrow(\n        address _holding,\n        address _token,\n        uint256 _amount,\n        uint256 _minJUsdAmountOut,\n        bool _mintDirectlyToUser\n    ) external returns (uint256 jUsdMintAmount);\n\n    /**\n     * @notice Repays debt.\n     *\n     * @notice Requirements:\n     * - The caller must be allowed to perform this action directly. If user - use Holding Manager Contract.\n     * - The token's registry must be active.\n     * - The holding must have a positive borrowed amount.\n     * - `_amount` must not exceed `holding`'s borrowed amount.\n     * - `_amount` must be greater than zero.\n     * - `_burnFrom` must not be the zero address.\n     *\n     * @notice Effects:\n     * - Updates the total borrowed jUSD amount for `_token`, used for borrowing.\n     * - Updates `_holdings`'s borrowed amount in `token`'s registry contract.\n     * - Burns `_amount` jUSD tokens from `_burnFrom` address\n     *\n     * @notice Emits:\n     * - `Repaid` event indicating successful repay operation.\n     *\n     * @param _holding The holding for which repay is performed.\n     * @param _token Collateral token.\n     * @param _amount The repaid jUSD amount.\n     * @param _burnFrom The address to burn from.\n     */\n    function repay(address _holding, address _token, uint256 _amount, address _burnFrom) external;\n\n    // -- Administration --\n\n    /**\n     * @notice Triggers stopped state.\n     */\n    function pause() external;\n\n    /**\n     * @notice Returns to normal state.\n     */\n    function unpause() external;\n\n    // -- Getters --\n\n    /**\n     * @notice Returns true if user is solvent for the specified token.\n     *\n     * @dev The method reverts if block.timestamp - _maxTimeRange > exchangeRateUpdatedAt.\n     *\n     * @notice Requirements:\n     * - `_holding` must not be the zero address.\n     * - There must be registry for `_token`.\n     *\n     * @param _token The token for which the check is done.\n     * @param _holding The user address.\n     *\n     * @return flag indicating whether `holding` is solvent.\n     */\n    function isSolvent(address _token, address _holding) external view returns (bool);\n\n    /**\n     * @notice Checks if a holding can be liquidated for a specific token.\n     *\n     * @notice Requirements:\n     * - `_holding` must not be the zero address.\n     * - There must be registry for `_token`.\n     *\n     * @param _token The token for which the check is done.\n     * @param _holding The user address.\n     *\n     * @return flag indicating whether `holding` is liquidatable.\n     */\n    function isLiquidatable(address _token, address _holding) external view returns (bool);\n\n    /**\n     * @notice Computes the solvency ratio.\n     *\n     * @dev Solvency ratio is calculated based on the used collateral type, its collateralization and exchange rates,\n     * and `_holding`'s borrowed amount.\n     *\n     * @param _holding The holding address to check for.\n     * @param registry The Shares Registry Contract for the token.\n     * @param rate The rate to compute ratio for (either collateralization rate for `isSolvent` or liquidation\n     * threshold for `isLiquidatable`).\n     *\n     * @return The calculated solvency ratio.\n     */\n    function getRatio(address _holding, ISharesRegistry registry, uint256 rate) external view returns (uint256);\n}\n"
    },
    "src/interfaces/oracle/IOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ninterface IOracle {\n    // -- State variables --\n\n    /**\n     * @notice Returns the address of the token the oracle is for.\n     */\n    function underlying() external view returns (address);\n\n    // -- Functions --\n\n    /**\n     * @notice Returns a human readable name of the underlying of the oracle.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @notice Returns a human readable symbol of the underlying of the oracle.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @notice Check the last exchange rate without any state changes.\n     *\n     * @param data Implementation specific data that contains information and arguments to & about the oracle.\n     *\n     * @return success If no valid (recent) rate is available, returns false else true.\n     * @return rate The rate of the requested asset / pair / pool.\n     */\n    function peek(\n        bytes calldata data\n    ) external view returns (bool success, uint256 rate);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "src/interfaces/core/IJigsawUSD.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport { IManager } from \"./IManager.sol\";\n\n/**\n * @title IJigsawUSD\n * @dev Interface for the Jigsaw Stablecoin Contract.\n */\ninterface IJigsawUSD is IERC20 {\n    /**\n     * @notice event emitted when the mint limit is updated\n     */\n    event MintLimitUpdated(uint256 oldLimit, uint256 newLimit);\n\n    /**\n     * @notice Contract that contains all the necessary configs of the protocol.\n     * @return The manager contract.\n     */\n    function manager() external view returns (IManager);\n\n    /**\n     * @notice Returns the max mint limit.\n     */\n    function mintLimit() external view returns (uint256);\n\n    /**\n     * @notice Sets the maximum mintable amount.\n     *\n     * @notice Requirements:\n     * - Must be called by the contract owner.\n     *\n     * @notice Effects:\n     * - Updates the `mintLimit` state variable.\n     *\n     * @notice Emits:\n     * - `MintLimitUpdated` event indicating mint limit update operation.\n     * @param _limit The new mint limit.\n     */\n    function updateMintLimit(\n        uint256 _limit\n    ) external;\n\n    /**\n     * @notice Mints tokens.\n     *\n     * @notice Requirements:\n     * - Must be called by the Stables Manager Contract\n     *  .\n     * @notice Effects:\n     * - Mints the specified amount of tokens to the given address.\n     *\n     * @param _to Address of the user receiving minted tokens.\n     * @param _amount The amount to be minted.\n     */\n    function mint(address _to, uint256 _amount) external;\n\n    /**\n     * @notice Burns tokens from the `msg.sender`.\n     *\n     * @notice Requirements:\n     * - Must be called by the token holder.\n     *\n     * @notice Effects:\n     * - Burns the specified amount of tokens from the caller's balance.\n     *\n     * @param _amount The amount of tokens to be burnt.\n     */\n    function burn(\n        uint256 _amount\n    ) external;\n\n    /**\n     * @notice Burns tokens from an address.\n     *\n     * - Must be called by the Stables Manager Contract\n     *\n     * @notice Effects: Burns the specified amount of tokens from the specified address.\n     *\n     * @param _user The user to burn it from.\n     * @param _amount The amount of tokens to be burnt.\n     */\n    function burnFrom(address _user, uint256 _amount) external;\n}\n"
    }
  },
  "settings": {
    "remappings": [
      "@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/",
      "@openzeppelin/contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/",
      "ds-test/=lib/openzeppelin-contracts/lib/forge-std/lib/ds-test/src/",
      "erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/",
      "forge-std/=lib/forge-std/src/",
      "openzeppelin-contracts/=lib/openzeppelin-contracts/",
      "@uniswap/v3-core/=lib/v3-core/",
      "@uniswap/v3-periphery/=lib/v3-periphery/",
      "@pyth/=lib/pyth-sdk-solidity/",
      "openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/",
      "pyth-sdk-solidity/=lib/pyth-sdk-solidity/",
      "v3-core/=lib/v3-core/contracts/",
      "v3-periphery/=lib/v3-periphery/contracts/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 100000
    },
    "metadata": {
      "useLiteralContent": false,
      "bytecodeHash": "ipfs",
      "appendCBOR": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "evmVersion": "cancun",
    "viaIR": false,
    "libraries": {}
  }
}}