{{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/utils/cryptography/Hashes.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/cryptography/Hashes.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library of standard hash functions.\n *\n * _Available since v5.1._\n */\nlibrary Hashes {\n    /**\n     * @dev Commutative Keccak256 hash of a sorted pair of bytes32. Frequently used when working with merkle proofs.\n     *\n     * NOTE: Equivalent to the `standardNodeHash` in our https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\n     */\n    function commutativeKeccak256(bytes32 a, bytes32 b) internal pure returns (bytes32) {\n        return a < b ? _efficientKeccak256(a, b) : _efficientKeccak256(b, a);\n    }\n\n    /**\n     * @dev Implementation of keccak256(abi.encode(a, b)) that doesn't allocate or expand memory.\n     */\n    function _efficientKeccak256(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/cryptography/MerkleProof.sol)\n// This file was procedurally generated from scripts/generate/templates/MerkleProof.js.\n\npragma solidity ^0.8.20;\n\nimport {Hashes} from \"./Hashes.sol\";\n\n/**\n * @dev These functions deal with verification of Merkle Tree proofs.\n *\n * The tree and the proofs can be generated using our\n * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\n * You will find a quickstart guide in the readme.\n *\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\n * hashing, or use a hash function other than keccak256 for hashing leaves.\n * This is because the concatenation of a sorted pair of internal nodes in\n * the Merkle tree could be reinterpreted as a leaf value.\n * OpenZeppelin's JavaScript library generates Merkle trees that are safe\n * against this attack out of the box.\n *\n * IMPORTANT: Consider memory side-effects when using custom hashing functions\n * that access memory in an unsafe way.\n *\n * NOTE: This library supports proof verification for merkle trees built using\n * custom _commutative_ hashing functions (i.e. `H(a, b) == H(b, a)`). Proving\n * leaf inclusion in trees built using non-commutative hashing functions requires\n * additional logic that is not supported by this library.\n */\nlibrary MerkleProof {\n    /**\n     *@dev The multiproof provided is not valid.\n     */\n    error MerkleProofInvalidMultiproof();\n\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     *\n     * This version handles proofs in memory with the default hashing function.\n     */\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leaves & pre-images are assumed to be sorted.\n     *\n     * This version handles proofs in memory with the default hashing function.\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = Hashes.commutativeKeccak256(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     *\n     * This version handles proofs in memory with a custom hashing function.\n     */\n    function verify(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32 leaf,\n        function(bytes32, bytes32) view returns (bytes32) hasher\n    ) internal view returns (bool) {\n        return processProof(proof, leaf, hasher) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leaves & pre-images are assumed to be sorted.\n     *\n     * This version handles proofs in memory with a custom hashing function.\n     */\n    function processProof(\n        bytes32[] memory proof,\n        bytes32 leaf,\n        function(bytes32, bytes32) view returns (bytes32) hasher\n    ) internal view returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = hasher(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     *\n     * This version handles proofs in calldata with the default hashing function.\n     */\n    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leaves & pre-images are assumed to be sorted.\n     *\n     * This version handles proofs in calldata with the default hashing function.\n     */\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = Hashes.commutativeKeccak256(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     *\n     * This version handles proofs in calldata with a custom hashing function.\n     */\n    function verifyCalldata(\n        bytes32[] calldata proof,\n        bytes32 root,\n        bytes32 leaf,\n        function(bytes32, bytes32) view returns (bytes32) hasher\n    ) internal view returns (bool) {\n        return processProofCalldata(proof, leaf, hasher) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leaves & pre-images are assumed to be sorted.\n     *\n     * This version handles proofs in calldata with a custom hashing function.\n     */\n    function processProofCalldata(\n        bytes32[] calldata proof,\n        bytes32 leaf,\n        function(bytes32, bytes32) view returns (bytes32) hasher\n    ) internal view returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = hasher(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a Merkle tree defined by\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\n     *\n     * This version handles multiproofs in memory with the default hashing function.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * NOTE: Consider the case where `root == proof[0] && leaves.length == 0` as it will return `true`.\n     * The `leaves` must be validated independently. See {processMultiProof}.\n     */\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\n     * respectively.\n     *\n     * This version handles multiproofs in memory with the default hashing function.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\n     *\n     * NOTE: The _empty set_ (i.e. the case where `proof.length == 1 && leaves.length == 0`) is considered a no-op,\n     * and therefore a valid multiproof (i.e. it returns `proof[0]`). Consider disallowing this case if you're not\n     * validating the leaves elsewhere.\n     */\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the Merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofFlagsLen = proofFlags.length;\n\n        // Check proof validity.\n        if (leavesLen + proof.length != proofFlagsLen + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](proofFlagsLen);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < proofFlagsLen; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = Hashes.commutativeKeccak256(a, b);\n        }\n\n        if (proofFlagsLen > 0) {\n            if (proofPos != proof.length) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[proofFlagsLen - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a Merkle tree defined by\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\n     *\n     * This version handles multiproofs in memory with a custom hashing function.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * NOTE: Consider the case where `root == proof[0] && leaves.length == 0` as it will return `true`.\n     * The `leaves` must be validated independently. See {processMultiProof}.\n     */\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves,\n        function(bytes32, bytes32) view returns (bytes32) hasher\n    ) internal view returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves, hasher) == root;\n    }\n\n    /**\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\n     * respectively.\n     *\n     * This version handles multiproofs in memory with a custom hashing function.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\n     *\n     * NOTE: The _empty set_ (i.e. the case where `proof.length == 1 && leaves.length == 0`) is considered a no-op,\n     * and therefore a valid multiproof (i.e. it returns `proof[0]`). Consider disallowing this case if you're not\n     * validating the leaves elsewhere.\n     */\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves,\n        function(bytes32, bytes32) view returns (bytes32) hasher\n    ) internal view returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the Merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofFlagsLen = proofFlags.length;\n\n        // Check proof validity.\n        if (leavesLen + proof.length != proofFlagsLen + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](proofFlagsLen);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < proofFlagsLen; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = hasher(a, b);\n        }\n\n        if (proofFlagsLen > 0) {\n            if (proofPos != proof.length) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[proofFlagsLen - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a Merkle tree defined by\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\n     *\n     * This version handles multiproofs in calldata with the default hashing function.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * NOTE: Consider the case where `root == proof[0] && leaves.length == 0` as it will return `true`.\n     * The `leaves` must be validated independently. See {processMultiProofCalldata}.\n     */\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\n     * respectively.\n     *\n     * This version handles multiproofs in calldata with the default hashing function.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\n     *\n     * NOTE: The _empty set_ (i.e. the case where `proof.length == 1 && leaves.length == 0`) is considered a no-op,\n     * and therefore a valid multiproof (i.e. it returns `proof[0]`). Consider disallowing this case if you're not\n     * validating the leaves elsewhere.\n     */\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the Merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofFlagsLen = proofFlags.length;\n\n        // Check proof validity.\n        if (leavesLen + proof.length != proofFlagsLen + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](proofFlagsLen);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < proofFlagsLen; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = Hashes.commutativeKeccak256(a, b);\n        }\n\n        if (proofFlagsLen > 0) {\n            if (proofPos != proof.length) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[proofFlagsLen - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a Merkle tree defined by\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\n     *\n     * This version handles multiproofs in calldata with a custom hashing function.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * NOTE: Consider the case where `root == proof[0] && leaves.length == 0` as it will return `true`.\n     * The `leaves` must be validated independently. See {processMultiProofCalldata}.\n     */\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves,\n        function(bytes32, bytes32) view returns (bytes32) hasher\n    ) internal view returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves, hasher) == root;\n    }\n\n    /**\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\n     * respectively.\n     *\n     * This version handles multiproofs in calldata with a custom hashing function.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\n     *\n     * NOTE: The _empty set_ (i.e. the case where `proof.length == 1 && leaves.length == 0`) is considered a no-op,\n     * and therefore a valid multiproof (i.e. it returns `proof[0]`). Consider disallowing this case if you're not\n     * validating the leaves elsewhere.\n     */\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves,\n        function(bytes32, bytes32) view returns (bytes32) hasher\n    ) internal view returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the Merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofFlagsLen = proofFlags.length;\n\n        // Check proof validity.\n        if (leavesLen + proof.length != proofFlagsLen + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](proofFlagsLen);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < proofFlagsLen; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = hasher(a, b);\n        }\n\n        if (proofFlagsLen > 0) {\n            if (proofPos != proof.length) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[proofFlagsLen - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n}\n"
    },
    "@solidity-mmr/lib/StatelessMmr.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.17;\n\nimport \"./StatelessMmrHelpers.sol\";\n\n///    _____       _ _     _ _ _           __  __ __  __ _____\n///   / ____|     | (_)   | (_) |         |  \\/  |  \\/  |  __ \\\n///  | (___   ___ | |_  __| |_| |_ _   _  | \\  / | \\  / | |__) |\n///   \\___ \\ / _ \\| | |/ _` | | __| | | | | |\\/| | |\\/| |  _  /\n///   ____) | (_) | | | (_| | | |_| |_| | | |  | | |  | | | \\ \\\n///  |_____/ \\___/|_|_|\\__,_|_|\\__|\\__, | |_|  |_|_|  |_|_|  \\_\\\n///                                 __/ |\n///                                |___/\n\n///\n/// @title StatelessMmr -- A Solidity implementation of Merkle Mountain Range\n/// @author Herodotus Ltd\n/// @notice Library for appending bytes32 values (i.e., acting as an accumulator)\n///         and verifying Merkle inclusion proofs\n///\nlibrary StatelessMmr {\n    error InvalidProof();\n    error IndexOutOfBounds();\n    error InvalidRoot();\n    error InvalidPeaksArrayLength();\n\n    ///\n    /// @notice Append a new element to the MMR\n    /// @param elem Element to append\n    /// @param peaks The latest peaks\n    /// @param lastElementsCount The latest elements count\n    /// @param lastRoot  The latest root\n    /// @return The updated elements count and the new root hash of the tree\n    ///\n    function append(\n        bytes32 elem,\n        bytes32[] memory peaks,\n        uint lastElementsCount,\n        bytes32 lastRoot\n    ) internal pure returns (uint, bytes32) {\n        (uint updatedElementsCount, bytes32 newRoot, ) = doAppend(\n            elem,\n            peaks,\n            lastElementsCount,\n            lastRoot\n        );\n\n        return (updatedElementsCount, newRoot);\n    }\n\n    ///\n    /// Same as `append` but also returns the updated peaks\n    ///\n    function appendWithPeaksRetrieval(\n        bytes32 elem,\n        bytes32[] memory peaks,\n        uint lastElementsCount,\n        bytes32 lastRoot\n    ) internal pure returns (uint, bytes32, bytes32[] memory) {\n        (\n            uint updatedElementsCount,\n            bytes32 newRoot,\n            bytes32[] memory updatedPeaks\n        ) = doAppend(elem, peaks, lastElementsCount, lastRoot);\n\n        return (updatedElementsCount, newRoot, updatedPeaks);\n    }\n\n    ///\n    /// @param elems Elements to append (in order)\n    /// @param peaks The latest peaks\n    /// @param lastElementsCount The latest elements count\n    /// @param lastRoot The latest tree root hash\n    /// @return The newest elements count and the newest tree root hash\n    ///\n    function multiAppend(\n        bytes32[] memory elems,\n        bytes32[] memory peaks,\n        uint lastElementsCount,\n        bytes32 lastRoot\n    ) internal pure returns (uint, bytes32) {\n        uint elementsCount = lastElementsCount;\n        bytes32 root = lastRoot;\n        bytes32[] memory updatedPeaks = peaks;\n\n        for (uint i = 0; i < elems.length; ++i) {\n            (elementsCount, root, updatedPeaks) = appendWithPeaksRetrieval(\n                elems[i],\n                updatedPeaks,\n                elementsCount,\n                root\n            );\n        }\n        return (elementsCount, root);\n    }\n\n    ///\n    /// Same as `multiAppend` but also returns the updated peaks\n    ///\n    function multiAppendWithPeaksRetrieval(\n        bytes32[] memory elems,\n        bytes32[] memory peaks,\n        uint lastElementsCount,\n        bytes32 lastRoot\n    ) internal pure returns (uint, bytes32, bytes32[] memory) {\n        uint elementsCount = lastElementsCount;\n        bytes32 root = lastRoot;\n        bytes32[] memory updatedPeaks = peaks;\n\n        for (uint i = 0; i < elems.length; ++i) {\n            (elementsCount, root, updatedPeaks) = appendWithPeaksRetrieval(\n                elems[i],\n                updatedPeaks,\n                elementsCount,\n                root\n            );\n        }\n        return (elementsCount, root, updatedPeaks);\n    }\n\n    ///\n    /// @notice Efficient version of `multiAppend` that takes in all the precomputed peaks\n    /// @param elems Elements to append (in order)\n    /// @param allPeaks All the precomputed peaks computed off-chain (more gas efficient)\n    /// @param lastElementsCount The latest elements count\n    /// @param lastRoot The latest tree root hash\n    /// @return The newest elements count and the newest tree root hash\n    ///\n    function multiAppendWithPrecomputedPeaks(\n        bytes32[] memory elems,\n        bytes32[][] memory allPeaks,\n        uint lastElementsCount,\n        bytes32 lastRoot\n    ) internal pure returns (uint, bytes32) {\n        uint elementsCount = lastElementsCount;\n        bytes32 root = lastRoot;\n\n        for (uint i = 0; i < elems.length; ++i) {\n            (elementsCount, root) = append(\n                elems[i],\n                allPeaks[i],\n                elementsCount,\n                root\n            );\n        }\n        return (elementsCount, root);\n    }\n\n    ///\n    /// @notice Verify a Merkle inclusion proof\n    /// @dev Reverts if the proof is invalid\n    /// @param proof The Merkle inclusion proof\n    /// @param peaks The peaks at the time of inclusion\n    /// @param elementsCount The element count at the time of inclusion\n    /// @param root The tree root hash at the time of inclusion\n    ///\n    function verifyProof(\n        uint index,\n        bytes32 value,\n        bytes32[] memory proof,\n        bytes32[] memory peaks,\n        uint elementsCount,\n        bytes32 root\n    ) internal pure {\n        if (index > elementsCount) {\n            revert IndexOutOfBounds();\n        }\n        bytes32 computedRoot = computeRoot(peaks, bytes32(elementsCount));\n        if (computedRoot != root) {\n            revert InvalidRoot();\n        }\n\n        bytes32 topPeak = getProofTopPeak(0, value, index, proof);\n\n        bool isValid = StatelessMmrHelpers.arrayContains(topPeak, peaks);\n        if (!isValid) {\n            revert InvalidProof();\n        }\n    }\n\n    ///   _    _      _                   ______                _   _\n    ///  | |  | |    | |                 |  ____|              | | (_)\n    ///  | |__| | ___| |_ __   ___ _ __  | |__ _   _ _ __   ___| |_ _  ___  _ __  ___\n    ///  |  __  |/ _ \\ | '_ \\ / _ \\ '__| |  __| | | | '_ \\ / __| __| |/ _ \\| '_ \\/ __|\n    ///  | |  | |  __/ | |_) |  __/ |    | |  | |_| | | | | (__| |_| | (_) | | | \\__ \\\n    ///  |_|  |_|\\___|_| .__/ \\___|_|    |_|   \\__,_|_| |_|\\___|\\__|_|\\___/|_| |_|___/\n    ///                | |\n    ///                |_|\n\n    ///\n    /// @notice Computes the root hash of the given peaks and tree size\n    /// @param peaks Peaks to compute the root from\n    /// @param size Tree size to to compute the root from\n    /// @return The root hash of the following peaks and tree size\n    ///\n    function computeRoot(\n        bytes32[] memory peaks,\n        bytes32 size\n    ) internal pure returns (bytes32) {\n        bytes32 baggedPeaks = bagPeaks(peaks);\n        return keccak256(abi.encode(size, baggedPeaks));\n    }\n\n    ///\n    /// @notice Bag the peaks: recursively hashing peaks together to form a single hash\n    /// @param peaks The peaks to bag\n    /// @return The bagged peaks\n    ///\n    function bagPeaks(bytes32[] memory peaks) internal pure returns (bytes32) {\n        if (peaks.length < 1) {\n            revert InvalidPeaksArrayLength();\n        }\n        if (peaks.length == 1) {\n            return peaks[0];\n        }\n\n        uint len = peaks.length;\n        bytes32 root0 = keccak256(abi.encode(peaks[len - 2], peaks[len - 1]));\n        bytes32[] memory reversedPeaks = new bytes32[](len - 2);\n        for (uint i = 0; i < len - 2; i++) {\n            reversedPeaks[i] = peaks[len - 3 - i];\n        }\n\n        bytes32 bags = root0;\n        for (uint i = 0; i < reversedPeaks.length; i++) {\n            bags = keccak256(abi.encode(reversedPeaks[i], bags));\n        }\n        return bags;\n    }\n\n    function doAppend(\n        bytes32 elem,\n        bytes32[] memory peaks,\n        uint lastElementsCount,\n        bytes32 lastRoot\n    ) internal pure returns (uint, bytes32, bytes32[] memory) {\n        uint elementsCount = lastElementsCount + 1;\n        if (lastElementsCount == 0) {\n            bytes32 root0 = elem;\n            bytes32 firstRoot = keccak256(abi.encode(uint(1), root0));\n            bytes32[] memory newPeaks = new bytes32[](1);\n            newPeaks[0] = root0;\n            return (elementsCount, firstRoot, newPeaks);\n        }\n\n        uint leafCount = StatelessMmrHelpers.mmrSizeToLeafCount(\n            elementsCount - 1\n        );\n        uint numberOfPeaks = StatelessMmrHelpers.countOnes(leafCount);\n        if (peaks.length != numberOfPeaks) {\n            revert InvalidPeaksArrayLength();\n        }\n\n        bytes32 computedRoot = computeRoot(peaks, bytes32(lastElementsCount));\n        if (computedRoot != lastRoot) {\n            revert InvalidRoot();\n        }\n\n        bytes32[] memory appendPeaks = StatelessMmrHelpers.newArrWithElem(\n            peaks,\n            elem\n        );\n\n        uint appendNoMerges = StatelessMmrHelpers.leafCountToAppendNoMerges(leafCount);\n        bytes32[] memory updatedPeaks = appendPerformMerging(\n            appendPeaks,\n            appendNoMerges\n        );\n\n        uint updatedElementsCount = elementsCount + appendNoMerges;\n\n        bytes32 newRoot = computeRoot(\n            updatedPeaks,\n            bytes32(updatedElementsCount)\n        );\n        return (updatedElementsCount, newRoot, updatedPeaks);\n    }\n\n    function appendPerformMerging(\n        bytes32[] memory peaks,\n        uint noMerges\n    ) internal pure returns (bytes32[] memory) {\n        uint peaksLen = peaks.length;\n        bytes32 accHash = peaks[peaksLen - 1];\n        for (uint i = 0; i < noMerges; i++) {\n            bytes32 hash = peaks[peaksLen - i - 2];\n            accHash = keccak256(abi.encode(hash, accHash));\n        }\n        bytes32[] memory newPeaks = new bytes32[](peaksLen - noMerges);\n        for (uint i = 0; i < peaksLen - noMerges - 1; i++) {\n            newPeaks[i] = peaks[i];\n        }\n        newPeaks[peaksLen - noMerges - 1] = accHash;\n\n        return newPeaks;\n    }\n\n    function getProofTopPeak(\n        uint height,\n        bytes32 hash,\n        uint elementsCount,\n        bytes32[] memory proof\n    ) internal pure returns (bytes32) {\n        uint leafIndex = StatelessMmrHelpers.mmrIndexToLeafIndex(elementsCount);\n        for (uint i = 0; i < proof.length; ++i) {\n            bytes32 currentSibling = proof[i];\n\n            bool isRightChild = leafIndex % 2 == 1;\n            if (isRightChild) {\n                bytes32 hashed = keccak256(abi.encode(currentSibling, hash));\n                elementsCount += 1;\n\n                hash = hashed;\n            } else {\n                bytes32 hashed = keccak256(abi.encode(hash, currentSibling));\n                elementsCount += 2 << height;\n\n                hash = hashed;\n            }\n            ++height;\n            leafIndex /= 2;\n        }\n        return hash;\n    }\n}\n"
    },
    "@solidity-mmr/lib/StatelessMmrHelpers.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.17;\n\nlibrary StatelessMmrHelpers {\n    // Returns the height of a given `index`. The height of the root is 0\n    function getHeight(uint index) internal pure returns (uint) {\n        require(index >= 1, \"index must be at least 1\");\n\n        uint bits = bitLength(index);\n        uint ones = allOnes(bits);\n\n        if (index != ones) {\n            uint shifted = 1 << (bits - 1);\n            uint recHeight = getHeight(index - (shifted - 1));\n            return recHeight;\n        }\n\n        return bits - 1;\n    }\n\n    // Returns the number of bits in `num`\n    function bitLength(uint256 num) internal pure returns (uint256) {\n        require(num >= 0, \"num must be greater than or equal to zero\");\n\n        uint256 bitPosition = 0;\n        uint256 curN = 1;\n        while (num >= curN) {\n            bitPosition += 1;\n            curN <<= 1;\n        }\n        return bitPosition;\n    }\n\n    // Returns a number having all its bits set to 1 for a given `bitsLength`\n    function allOnes(uint256 bitsLength) internal pure returns (uint256) {\n        require(bitsLength >= 0, \"bitsLength must be greater or equal to zero\");\n        return (1 << bitsLength) - 1;\n    }\n\n    // Returns a number of ones in bit representation of a number\n    function countOnes(uint256 num) internal pure returns (uint256) {\n        uint256 count = 0;\n        for (; num > 0; count++) {\n            num = num & (num - 1);\n        }\n        return count;\n    }\n\n    // Returns the sibling offset from `height`\n    function siblingOffset(uint256 height) internal pure returns (uint256) {\n        return (2 << height) - 1;\n    }\n\n    // Returns the parent offset from `height`\n    function parentOffset(uint256 height) internal pure returns (uint256) {\n        return 2 << height;\n    }\n\n    // Returns number of leaves for a given mmr size\n    function mmrSizeToLeafCount(uint256 mmrSize) internal pure returns (uint256) {\n        uint256 leafCount = 0;\n        uint256 mountainLeafCount = 1 << bitLength(mmrSize);\n        for(; mountainLeafCount > 0; mountainLeafCount /= 2) {\n            uint256 mountainSize = 2 * mountainLeafCount - 1;\n            if (mountainSize <= mmrSize) {\n                leafCount += mountainLeafCount;\n                mmrSize -= mountainSize;\n            }\n        }\n        require(mmrSize == 0, \"mmrSize can't be associated with a valid MMR size\");\n        return leafCount;\n    }\n\n    // Returns leaf index (0-based) for a given mmr (element) index\n    function mmrIndexToLeafIndex(uint256 mmrIndex) internal pure returns (uint256) {\n        return mmrSizeToLeafCount(mmrIndex - 1);\n    }\n\n    function leafCountToAppendNoMerges(uint256 leafCount) internal pure returns (uint256) {\n        uint256 count = 0;\n        while(leafCount > 0 && (leafCount & 1) == 1) {\n            count += 1;\n            leafCount /= 2;\n        }\n        return count;\n    }\n\n    // Creates a new array from source and returns a new one containing all previous elements + `elem`\n    function newArrWithElem(\n        bytes32[] memory sourceArr,\n        bytes32 elem\n    ) internal pure returns (bytes32[] memory) {\n        bytes32[] memory outputArray = new bytes32[](sourceArr.length + 1);\n        uint i = 0;\n        for (; i < sourceArr.length; i++) {\n            outputArray[i] = sourceArr[i];\n        }\n        outputArray[i] = elem;\n        return outputArray;\n    }\n\n    // Returns true if `elem` is in `arr`\n    function arrayContains(\n        bytes32 elem,\n        bytes32[] memory arr\n    ) internal pure returns (bool) {\n        for (uint i = 0; i < arr.length; ++i) {\n            if (arr[i] == elem) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n"
    },
    "forge-std/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\nlibrary console {\n    address constant CONSOLE_ADDRESS =\n        0x000000000000000000636F6e736F6c652e6c6f67;\n\n    function _sendLogPayloadImplementation(bytes memory payload) internal view {\n        address consoleAddress = CONSOLE_ADDRESS;\n        /// @solidity memory-safe-assembly\n        assembly {\n            pop(\n                staticcall(\n                    gas(),\n                    consoleAddress,\n                    add(payload, 32),\n                    mload(payload),\n                    0,\n                    0\n                )\n            )\n        }\n    }\n\n    function _castToPure(\n      function(bytes memory) internal view fnIn\n    ) internal pure returns (function(bytes memory) pure fnOut) {\n        assembly {\n            fnOut := fnIn\n        }\n    }\n\n    function _sendLogPayload(bytes memory payload) internal pure {\n        _castToPure(_sendLogPayloadImplementation)(payload);\n    }\n\n    function log() internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log()\"));\n    }\n\n    function logInt(int256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n    }\n\n    function logUint(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function logString(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function logBool(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function logAddress(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function logBytes(bytes memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n    }\n\n    function logBytes1(bytes1 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n    }\n\n    function logBytes2(bytes2 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n    }\n\n    function logBytes3(bytes3 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n    }\n\n    function logBytes4(bytes4 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n    }\n\n    function logBytes5(bytes5 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n    }\n\n    function logBytes6(bytes6 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n    }\n\n    function logBytes7(bytes7 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n    }\n\n    function logBytes8(bytes8 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n    }\n\n    function logBytes9(bytes9 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n    }\n\n    function logBytes10(bytes10 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n    }\n\n    function logBytes11(bytes11 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n    }\n\n    function logBytes12(bytes12 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n    }\n\n    function logBytes13(bytes13 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n    }\n\n    function logBytes14(bytes14 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n    }\n\n    function logBytes15(bytes15 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n    }\n\n    function logBytes16(bytes16 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n    }\n\n    function logBytes17(bytes17 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n    }\n\n    function logBytes18(bytes18 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n    }\n\n    function logBytes19(bytes19 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n    }\n\n    function logBytes20(bytes20 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n    }\n\n    function logBytes21(bytes21 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n    }\n\n    function logBytes22(bytes22 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n    }\n\n    function logBytes23(bytes23 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n    }\n\n    function logBytes24(bytes24 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n    }\n\n    function logBytes25(bytes25 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n    }\n\n    function logBytes26(bytes26 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n    }\n\n    function logBytes27(bytes27 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n    }\n\n    function logBytes28(bytes28 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n    }\n\n    function logBytes29(bytes29 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n    }\n\n    function logBytes30(bytes30 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n    }\n\n    function logBytes31(bytes31 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n    }\n\n    function logBytes32(bytes32 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n    }\n\n    function log(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function log(int256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n    }\n\n    function log(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function log(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function log(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function log(uint256 p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n    }\n\n    function log(uint256 p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n    }\n\n    function log(uint256 p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n    }\n\n    function log(uint256 p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n    }\n\n    function log(string memory p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n    }\n\n    function log(string memory p0, int256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,int256)\", p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n    }\n\n    function log(bool p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n    }\n\n    function log(bool p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n    }\n\n    function log(address p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n    }\n\n    function log(address p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n    }\n\n    function log(address p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n    }\n}\n"
    },
    "src/interfaces/external/IAggregatorsFactory.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.4;\n\ninterface IAggregatorsFactory {\n    error AccessControlBadConfirmation();\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n    error ERC1167FailedCreateClone();\n\n    event AggregatorCreation(address aggregator, uint256 newAggregatorId, uint256 detachedFromAggregatorId);\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n    event Upgrade(address oldTemplate, address newTemplate);\n    event UpgradeProposal(address newTemplate);\n\n    function DEFAULT_ADMIN_ROLE() external view returns (bytes32);\n\n    function DELAY() external view returns (uint256);\n\n    function KECCAK_MMR_INITIAL_ROOT() external view returns (bytes32);\n\n    function OPERATOR_ROLE() external view returns (bytes32);\n\n    function POSEIDON_MMR_INITIAL_ROOT() external view returns (bytes32);\n\n    function aggregatorsById(uint256) external view returns (address);\n\n    function aggregatorsCount() external view returns (uint256);\n\n    function createAggregator(uint256 aggregatorId) external returns (address);\n\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    function grantRole(bytes32 role, address account) external;\n\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    function proposeUpgrade(address newTemplate) external;\n\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n\n    function revokeRole(bytes32 role, address account) external;\n\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n\n    function template() external view returns (address);\n\n    function upgrade(uint256 updateId) external;\n\n    function upgrades(uint256) external view returns (uint256 timestamp, address newTemplate);\n\n    function upgradesCount() external view returns (uint256);\n}\n"
    },
    "src/interfaces/external/IFactsRegistry.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.27;\n\ninterface IFactsRegistry {\n    function isValid(bytes32 fact) external view returns (bool);\n}\n"
    },
    "src/interfaces/external/IStarknet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IStarknet {\n    function stateBlockNumber() external view returns (int256);\n\n    function stateBlockHash() external view returns (uint256);\n}\n"
    },
    "src/interfaces/ILibSatellite.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.27;\n\n/// @notice This is IMMUTABLE! without re-deploying the whole Satellite Diamond!\ninterface ILibSatellite {\n    // ========================= Types ========================= //\n\n    struct Module {\n        address moduleAddress;\n        bytes4[] functionSelectors;\n    }\n\n    struct ModuleAddressAndPosition {\n        address moduleAddress;\n        uint96 functionSelectorPosition; // position in moduleFunctionSelectors.functionSelectors array\n    }\n\n    struct ModuleFunctionSelectors {\n        bytes4[] functionSelectors;\n        uint256 moduleAddressPosition; // position of moduleAddress in moduleAddresses array\n    }\n\n    /// @dev Add=0, Replace=1, Remove=2\n    enum ModuleMaintenanceAction {\n        Add,\n        Replace,\n        Remove\n    }\n\n    struct ModuleMaintenance {\n        address moduleAddress;\n        ModuleMaintenanceAction action;\n        bytes4[] functionSelectors;\n    }\n\n    /// @notice This struct represents a Merkle Mountain Range accumulating provably valid block hashes\n    /// @dev each MMR is mapped to a unique ID also referred to as mmrId\n    struct MmrInfo {\n        /// @notice isSiblingSynced informs if the MMR has it's siblings (MMRs with different hash functions) and has to be grown in sync with them - used when growing off-chain and growing multiple hash functions at once, for example, this could be a keccak MMR sibling synced to a poseidon MMR\n        bool isSiblingSynced;\n        /// @notice latestSize represents the latest size of the MMR\n        uint256 latestSize;\n        /// @notice mmrSizeToRoot maps the  MMR size => the MMR root, that way we have automatic versioning\n        mapping(uint256 => bytes32) mmrSizeToRoot;\n    }\n\n    struct SatelliteConnection {\n        /// @notice satelliteAddress is the address of the satellite deployed on the destination chain\n        /// @dev it is uint256 because Starknet addresses must fit\n        uint256 satelliteAddress;\n        /// @notice inboxAddress is the address of the contract that sends messages from our chain to the chain of the satellite\n        address inboxAddress;\n        /// @notice sendMessageSelector is the selector of the satellite's function that sends message to the destination chain\n        bytes4 sendMessageSelector;\n    }\n\n    struct SatelliteStorage {\n        // ========================= Diamond-related storage ========================= //\n\n        /// @dev maps function selector to the module address and the position of the selector in the moduleFunctionSelectors.selectors array\n        mapping(bytes4 => ModuleAddressAndPosition) selectorToModuleAndPosition;\n        /// @dev maps module addresses to function selectors\n        mapping(address => ModuleFunctionSelectors) moduleFunctionSelectors;\n        /// @dev module addresses\n        address[] moduleAddresses;\n        /// @dev owner of the contract\n        address contractOwner;\n        //\n        // ========================= Core Satellite storage ========================= //\n\n        /// @dev mapping of ChainId => MMR ID => hashing function => MMR info\n        /// @dev hashingFunction is a 32 byte keccak hash of the hashing function name, eg: keccak256(\"keccak256\"), keccak256(\"poseidon\")\n        mapping(uint256 => mapping(uint256 => mapping(bytes32 => MmrInfo))) mmrs;\n        /// @notice mapping of ChainId => hashing function => block number => block parent hash\n        mapping(uint256 => mapping(bytes32 => mapping(uint256 => bytes32))) receivedParentHashes;\n        //\n        // ======================= Satellite Registry storage ======================= //\n\n        /// @dev mapping of ChainId => SatelliteConnection struct\n        mapping(uint256 => SatelliteConnection) satelliteConnectionRegistry;\n        /// @dev set of (aliased) addresses of satellites that can send messages to our chain\n        mapping(address => bool) senderSatellites;\n    }\n\n    // ========================= Errors ========================= //\n\n    /// @notice Error indicating the caller must be a satellite module\n    error MustBeSatelliteModule();\n    /// @notice Error indicating the caller must be the contract owner\n    error MustBeContractOwner();\n    /// @notice Error indicating the module maintenance action is incorrect\n    error IncorrectModuleMaintenanceAction(ModuleMaintenanceAction action);\n    /// @notice Error indicating there are no selectors in the module to maintenance\n    error NoSelectorsInModuleToMaintenance();\n    /// @notice Error indicating the module address is zero\n    error AddModuleAddressZero();\n    /// @notice Error indicating the function already exists\n    error AddFunctionAlreadyExists(bytes4 selector);\n    /// @notice Error indicating the function already exists\n    error ReplaceFunctionWithSameFunction(bytes4 selector);\n    /// @notice Error indicating the function does not exist\n    error RemoveFunctionDoesNotExist();\n    /// @notice Error indicating the function is immutable and cannot be removed\n    error RemoveImmutableFunction();\n    /// @notice Error indicating the init address is zero but calldata is not empty\n    error InitAddressZeroButCalldataNotEmpty();\n    /// @notice Error indicating the calldata is empty but init is not address(0)\n    error CalldataEmptyButInitNotEmpty();\n    /// @notice Error indicating the init function reverted\n    error InitFunctionReverted(string errors);\n    /// @notice Error indicating the address has no code\n    error AddressHasNoCode(string details);\n\n    // ========================= Events ========================= //\n\n    /// @notice Event emitted when satellite maintenance occurs\n    event SatelliteMaintenance(ModuleMaintenance[] _satelliteMaintenance, address _init, bytes _calldata);\n    /// @notice Event emitted when ownership is transferred\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n}\n"
    },
    "src/interfaces/ISatellite.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.27;\n\nimport {ILibSatellite} from \"./ILibSatellite.sol\";\nimport {IOwnershipModule} from \"./modules/IOwnershipModule.sol\";\nimport {ISatelliteConnectionRegistryModule} from \"./modules/ISatelliteConnectionRegistryModule.sol\";\nimport {IMmrCoreModule} from \"./modules/IMmrCoreModule.sol\";\nimport {ISatelliteInspectorModule} from \"./modules/ISatelliteInspectorModule.sol\";\nimport {ISatelliteMaintenanceModule} from \"./modules/ISatelliteMaintenanceModule.sol\";\nimport {IEvmSharpMmrGrowingModule} from \"./modules/growing/IEvmSharpMmrGrowingModule.sol\";\nimport {IStarknetSharpMmrGrowingModule} from \"./modules/growing/IStarknetSharpMmrGrowingModule.sol\";\nimport {IEvmFactRegistryModule} from \"./modules/IEvmFactRegistryModule.sol\";\nimport {INativeParentHashFetcherModule} from \"./modules/parent-hash-fetching/INativeParentHashFetcherModule.sol\";\nimport {IStarknetParentHashFetcherModule} from \"./modules/parent-hash-fetching/IStarknetParentHashFetcherModule.sol\";\nimport {IReceiverModule} from \"./modules/messaging/receiver/IReceiverModule.sol\";\nimport {IEvmOnChainGrowingModule} from \"./modules/growing/IEvmOnChainGrowingModule.sol\";\nimport {IDataProcessorModule} from \"./modules/IDataProcessorModule.sol\";\nimport {IUniversalSenderModule} from \"./modules/messaging/sender/IUniversalSenderModule.sol\";\nimport {IL1ToArbitrumSenderModule} from \"./modules/messaging/sender/IL1ToArbitrumSenderModule.sol\";\nimport {IL1ToOptimismSenderModule} from \"./modules/messaging/sender/IL1ToOptimismSenderModule.sol\";\nimport {IArbitrumToApeChainSenderModule} from \"./modules/messaging/sender/IArbitrumToApeChainSenderModule.sol\";\nimport {IL1ToStarknetSenderModule} from \"./modules/messaging/sender/IL1ToStarknetSenderModule.sol\";\nimport {ILegacyContractsInteractionModule} from \"./modules/growing/ILegacyContractsInteractionModule.sol\";\nimport {IArbitrumParentHashFetcherModule} from \"./modules/parent-hash-fetching/IArbitrumParentHashFetcherModule.sol\";\n\ninterface ISatellite is\n    ILibSatellite,\n    IOwnershipModule,\n    ISatelliteConnectionRegistryModule,\n    IMmrCoreModule,\n    ISatelliteInspectorModule,\n    ISatelliteMaintenanceModule,\n    IEvmSharpMmrGrowingModule,\n    IEvmFactRegistryModule,\n    INativeParentHashFetcherModule,\n    IEvmOnChainGrowingModule,\n    IStarknetSharpMmrGrowingModule,\n    IReceiverModule,\n    IUniversalSenderModule,\n    IL1ToArbitrumSenderModule,\n    IL1ToOptimismSenderModule,\n    IStarknetParentHashFetcherModule,\n    IArbitrumParentHashFetcherModule,\n    IDataProcessorModule,\n    IArbitrumToApeChainSenderModule,\n    IL1ToStarknetSenderModule,\n    ILegacyContractsInteractionModule\n{}\n"
    },
    "src/interfaces/modules/common/IFactsRegistryCommon.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.27;\n\ninterface IFactsRegistryCommon {\n    error InvalidFact();\n}\n"
    },
    "src/interfaces/modules/common/ISharpMmrGrowingCommon.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.27;\n\nimport {IFactsRegistryCommon} from \"./IFactsRegistryCommon.sol\";\n\ninterface ISharpMmrGrowingCommon is IFactsRegistryCommon {\n    // Custom errors for better error handling and clarity\n    error NotEnoughJobs();\n    error UnknownParentHash();\n    error AggregationError(string message); // Generic error with a message\n    error AggregationBlockMismatch(string message);\n    error GenesisBlockReached();\n}\n"
    },
    "src/interfaces/modules/growing/IEvmOnChainGrowingModule.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.27;\n\nimport {Lib_RLPReader as RLPReader} from \"src/libraries/external/optimism/rlp/Lib_RLPReader.sol\";\nimport {StatelessMmr} from \"@solidity-mmr/lib/StatelessMmr.sol\";\n\ninterface IEvmOnChainGrowingModule {\n    // ========================= Types ========================= //\n\n    struct MMRGrowResult {\n        uint256 firstAppendedBlock;\n        uint256 lastAppendedBlock;\n        uint256 newMMRSize;\n        bytes32 newMMRRoot;\n    }\n\n    // ========================= Functions ========================= //\n\n    function onchainEvmAppendBlocksBatch(\n        uint256 accumulatedChainId,\n        uint256 mmrId,\n        bool processFromReceivedBlockHash,\n        bytes calldata ctx,\n        bytes[] calldata headersSerialized\n    ) external;\n}\n"
    },
    "src/interfaces/modules/growing/IEvmSharpMmrGrowingModule.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.27;\n\nimport {Uint256Splitter} from \"src/libraries/internal/Uint256Splitter.sol\";\nimport {IFactsRegistry} from \"src/interfaces/external/IFactsRegistry.sol\";\nimport {ISharpMmrGrowingCommon} from \"src/interfaces/modules/common/ISharpMmrGrowingCommon.sol\";\n\ninterface IEvmSharpMmrGrowingModule is ISharpMmrGrowingCommon {\n    // Representation of the Cairo program's output (raw unpacked)\n    struct EvmJobOutput {\n        uint256 fromBlockNumberHigh;\n        uint256 toBlockNumberLow;\n        bytes32 blockNPlusOneParentHashLow;\n        bytes32 blockNPlusOneParentHashHigh;\n        bytes32 blockNMinusRPlusOneParentHashLow;\n        bytes32 blockNMinusRPlusOneParentHashHigh;\n        bytes32 mmrPreviousRootPoseidon;\n        bytes32 mmrPreviousRootKeccakLow;\n        bytes32 mmrPreviousRootKeccakHigh;\n        uint256 mmrPreviousSize;\n        bytes32 mmrNewRootPoseidon;\n        bytes32 mmrNewRootKeccakLow;\n        bytes32 mmrNewRootKeccakHigh;\n        uint256 mmrNewSize;\n    }\n\n    // Packed representation of the Cairo program's output (for gas efficiency)\n    struct JobOutputPacked {\n        uint256 blockNumbersPacked;\n        bytes32 blockNPlusOneParentHash;\n        bytes32 blockNMinusRPlusOneParentHash;\n        bytes32 mmrPreviousRootPoseidon;\n        bytes32 mmrPreviousRootKeccak;\n        bytes32 mmrNewRootPoseidon;\n        bytes32 mmrNewRootKeccak;\n        uint256 mmrSizesPacked;\n    }\n\n    struct EvmSharpMmrGrowingModuleStorage {\n        IFactsRegistry factsRegistry;\n        uint256 aggregatedChainId;\n        // Cairo program hash calculated with Poseidon (i.e., the off-chain block headers accumulator program)\n        uint256 programHash;\n    }\n\n    function initEvmSharpMmrGrowingModule() external;\n\n    function setEvmSharpMmrGrowingModuleProgramHash(uint256 programHash) external;\n\n    function setEvmSharpMmrGrowingModuleFactsRegistry(address factsRegistry) external;\n\n    function getEvmSharpMmrGrowingModuleProgramHash() external view returns (uint256);\n\n    function getEvmSharpMmrGrowingModuleFactsRegistry() external view returns (address);\n\n    function createEvmSharpMmr(uint256 newMmrId, uint256 originalMmrId, uint256 mmrSize) external;\n\n    function aggregateEvmSharpJobs(uint256 mmrId, JobOutputPacked[] calldata outputs) external;\n}\n"
    },
    "src/interfaces/modules/growing/ILegacyContractsInteractionModule.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.27;\n\nimport {IAggregatorsFactory} from \"src/interfaces/external/IAggregatorsFactory.sol\";\nimport {RootForHashingFunction} from \"src/interfaces/modules/IMmrCoreModule.sol\";\n\ninterface ILegacyContractsInteractionModule {\n    function initLegacyContractsInteractionModule(IAggregatorsFactory aggregatorsFactory) external;\n    function loadLegacyEvmAggregatorMmr(uint256 legacyMmrId, uint256 newMmrId) external;\n\n    struct LegacyContractsInteractionModuleStorage {\n        IAggregatorsFactory aggregatorsFactory;\n        uint256 aggregatedChainId;\n    }\n\n    event LegacyEvmAggregatorMmrLoadedV2(\n        RootForHashingFunction[] rootsForHashingFunctions,\n        uint256 size,\n        uint256 newMmrId,\n        uint256 legacyMmrId,\n        uint256 aggregatedChainId,\n        address sharpFactsAggregatorAddress\n    );\n}\n"
    },
    "src/interfaces/modules/growing/IStarknetSharpMmrGrowingModule.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.27;\n\nimport {Uint256Splitter} from \"src/libraries/internal/Uint256Splitter.sol\";\nimport {IFactsRegistry} from \"src/interfaces/external/IFactsRegistry.sol\";\nimport {ISharpMmrGrowingCommon} from \"src/interfaces/modules/common/ISharpMmrGrowingCommon.sol\";\n\ninterface IStarknetSharpMmrGrowingModule is ISharpMmrGrowingCommon {\n    // Representation of the Cairo program's output\n    struct StarknetJobOutput {\n        uint256 fromBlockNumberHigh;\n        uint256 toBlockNumberLow;\n        bytes32 blockNPlusOneParentHash;\n        bytes32 blockNMinusRPlusOneParentHash;\n        bytes32 mmrPreviousRootPoseidon;\n        uint256 mmrPreviousSize;\n        bytes32 mmrNewRootPoseidon;\n        uint256 mmrNewSize;\n    }\n\n    struct StarknetSharpMmrGrowingModuleStorage {\n        IFactsRegistry factsRegistry;\n        // Either Starknet or Starknet Sepolia chain ID\n        uint256 aggregatedChainId;\n        // Cairo program hash calculated with Poseidon (i.e., the off-chain block headers accumulator program)\n        uint256 programHash;\n    }\n\n    function initStarknetSharpMmrGrowingModule(uint256 starknetChainId) external;\n\n    function setStarknetSharpMmrGrowingModuleFactsRegistry(address factsRegistry) external;\n\n    function setStarknetSharpMmrGrowingModuleProgramHash(uint256 programHash) external;\n\n    function getStarknetSharpMmrGrowingModuleFactsRegistry() external view returns (address);\n\n    function getStarknetSharpMmrGrowingModuleProgramHash() external view returns (uint256);\n\n    function createStarknetSharpMmr(uint256 newMmrId, uint256 originalMmrId, uint256 mmrSize) external;\n\n    function aggregateStarknetSharpJobs(uint256 mmrId, StarknetJobOutput[] calldata outputs) external;\n}\n"
    },
    "src/interfaces/modules/IDataProcessorModule.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.20;\n\nimport {IFactsRegistry} from \"src/interfaces/external/IFactsRegistry.sol\";\nimport {ModuleTask} from \"src/libraries/internal/data-processor/ModuleCodecs.sol\";\nimport {IFactsRegistryCommon} from \"src/interfaces/modules/common/IFactsRegistryCommon.sol\";\n\ninterface IDataProcessorModule is IFactsRegistryCommon {\n    /// @notice The status of a task\n    enum TaskStatus {\n        NONE,\n        SCHEDULED,\n        FINALIZED\n    }\n\n    /// @notice The struct representing a task result\n    struct TaskResult {\n        TaskStatus status;\n        bytes32 result;\n    }\n\n    /// @notice Storage structure for the module\n    struct DataProcessorModuleStorage {\n        IFactsRegistry factsRegistry;\n        mapping(bytes32 => TaskResult) cachedTasksResult;\n        mapping(bytes32 => bool) authorizedProgramHashes;\n    }\n\n    struct MmrData {\n        uint256 chainId;\n        uint256 mmrId;\n        uint256 mmrSize;\n    }\n\n    /// @param mmrData For each used MMR, its chain ID, ID and size\n    /// @param taskResultLow The low part of the task result\n    /// @param taskResultHigh The high part of the task result\n    /// @param taskHashLow The low part of the task hash\n    /// @param taskHashHigh The high part of the task hash\n    /// @param programHash The program hash that was used to compute the task\n    struct TaskData {\n        MmrData[] mmrData;\n        uint256 taskResultLow;\n        uint256 taskResultHigh;\n        uint256 taskHashLow;\n        uint256 taskHashHigh;\n        bytes32 programHash;\n    }\n\n    /// @notice emitted when a task already stored\n    event TaskAlreadyStored(bytes32 result);\n\n    /// @notice emitted when a new module task is scheduled\n    event ModuleTaskScheduled(ModuleTask moduleTask);\n\n    /// Task is already registered\n    error DoubleRegistration();\n    /// Element is not in the batch\n    error NotInBatch();\n    /// Task is not finalized\n    error NotFinalized();\n    /// Unauthorized or inactive program hash\n    error UnauthorizedProgramHash();\n    /// Invalid MMR root\n    error InvalidMmrRoot();\n    /// Task is already finalized\n    error TaskAlreadyFinalized();\n\n    /// @notice Emitted when a task is finalized\n    event TaskFinalized(bytes32 taskHash, bytes32 taskResult);\n\n    /// @notice Emitted when a program hash is enabled\n    event ProgramHashEnabled(bytes32 enabledProgramHash);\n\n    /// @notice Emitted when some program hashes are disabled\n    event ProgramHashesDisabled(bytes32[] disabledProgramHashes);\n\n    /// @notice Set the program hash for the HDP program\n    function setDataProcessorProgramHash(bytes32 programHash) external;\n\n    /// @notice Disable some program hashes\n    function disableProgramHashes(bytes32[] calldata programHashes) external;\n\n    /// @notice Set the facts registry contract\n    function setDataProcessorFactsRegistry(IFactsRegistry factsRegistry) external;\n\n    /// @notice Requests the execution of a task with a module\n    /// @param moduleTask module task\n    function requestDataProcessorExecutionOfTask(ModuleTask calldata moduleTask) external;\n\n    /// @notice Authenticates the execution of a task is finalized\n    ///         by verifying the locally computed fact with the FactsRegistry\n    /// @param taskData The task data\n    function authenticateDataProcessorTaskExecution(TaskData calldata taskData) external;\n\n    /// @notice Returns address of the facts registry\n    function getDataProcessorFactsRegistry() external view returns (address);\n\n    /// @notice Returns the result of a finalized task\n    function getDataProcessorFinalizedTaskResult(bytes32 taskCommitment) external view returns (bytes32);\n\n    /// @notice Returns the status of a task\n    function getDataProcessorTaskStatus(bytes32 taskCommitment) external view returns (TaskStatus);\n\n    /// @notice Checks if a program hash is currently authorized\n    function isProgramHashAuthorized(bytes32 programHash) external view returns (bool);\n}\n"
    },
    "src/interfaces/modules/IEvmFactRegistryModule.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.27;\n\ninterface IEvmFactRegistryModule {\n    struct BlockHeaderProof {\n        uint256 treeId;\n        uint128 mmrTreeSize;\n        uint256 blockNumber;\n        uint256 blockProofLeafIndex;\n        bytes32[] mmrPeaks;\n        bytes32[] mmrElementInclusionProof;\n        bytes provenBlockHeader;\n    }\n\n    enum AccountField {\n        NONCE,\n        BALANCE,\n        STORAGE_ROOT,\n        CODE_HASH\n    }\n\n    struct StorageSlot {\n        bytes32 value;\n        bool exists;\n    }\n\n    struct Account {\n        /// @dev Bitmask of saved fields (4 bits)\n        uint8 savedFields;\n        mapping(AccountField => bytes32) fields;\n    }\n\n    struct EvmFactRegistryModuleStorage {\n        /// @dev chain_id => address => block_number => Account\n        mapping(uint256 => mapping(address => mapping(uint256 => Account))) accountField;\n        /// @dev chain_id => address => block_number => slot => value\n        mapping(uint256 => mapping(address => mapping(uint256 => mapping(bytes32 => StorageSlot)))) accountStorageSlotValues;\n        /// @dev chain_id => timestamp => block_number + 1 (0 means no data)\n        mapping(uint256 => mapping(uint256 => uint256)) timestampToBlockNumber;\n    }\n\n    // ===================== Functions for End Users ===================== //\n\n    /// @notice Returns nonce, balance, storage root or code hash of a given account, at a given block number and chainId\n    function accountField(uint256 chainId, address account, uint256 blockNumber, AccountField field) external view returns (bytes32);\n\n    /// @notice Returns value of a given storage slot of a given account, at a given block number and chainId\n    function storageSlot(uint256 chainId, address account, uint256 blockNumber, bytes32 slot) external view returns (bytes32);\n\n    /// @notice Returns block number of the closest block with timestamp less than or equal to the given timestamp\n    function timestamp(uint256 chainId, uint256 timestamp) external view returns (uint256);\n\n    // ========================= Core Functions ========================= //\n\n    /// @notice Stores account fields after verifying the headerProof against saved MMRs\n    /// @param chainId Chain ID where the account lives\n    /// @param account Address of the account\n    /// @param headerProof Header proof of the block that contains the account\n    /// @param accountTrieProof MPT proof for the account (has to hash to the state root)\n    function proveAccount(uint256 chainId, address account, uint8 accountFieldsToSave, BlockHeaderProof calldata headerProof, bytes calldata accountTrieProof) external;\n\n    /// @notice Stores storage slot value after verifying the storageSlotTrieProof against saved MMRs\n    /// @notice Account's storage root has to be proven before calling this function\n    /// @param chainId Chain ID where the queried block lives\n    /// @param account Address of the account that contains the storage slot\n    /// @param blockNumber Block number at which the storage slot is stored\n    /// @param slot Index of the storage slot\n    /// @param storageSlotTrieProof MPT proof for the storage slot (has to hash to the storage root)\n    function proveStorage(uint256 chainId, address account, uint256 blockNumber, bytes32 slot, bytes calldata storageSlotTrieProof) external;\n\n    /// @notice Stores closest timestamp to a block after verifying header proofs of two consecutive blocks,\n    /// @notice where the first block is the closest block with timestamp less than or equal to the given timestamp\n    /// @param chainId Chain ID where the queried block lives\n    /// @param timestamp Timestamp for which you are looking for the closest block\n    /// @param headerProof Header proof of the block that is the answer for the given timestamp\n    /// @param headerProofNext Header proof of the next block\n    function proveTimestamp(uint256 chainId, uint256 timestamp, BlockHeaderProof calldata headerProof, BlockHeaderProof calldata headerProofNext) external;\n\n    // ========================= View functions ========================= //\n\n    /// @notice Verifies the headerProof against saved MMRs\n    /// @param chainId Chain ID where the account lives\n    /// @param account Address of the account\n    /// @param headerProof Header proof of the block that contains the account\n    /// @param accountTrieProof MPT proof for the account (has to hash to the state root)\n    /// @return nonce\n    /// @return accountBalance\n    /// @return codeHash\n    /// @return storageRoot\n    function verifyAccount(\n        uint256 chainId,\n        address account,\n        BlockHeaderProof calldata headerProof,\n        bytes calldata accountTrieProof\n    ) external view returns (uint256 nonce, uint256 accountBalance, bytes32 codeHash, bytes32 storageRoot);\n\n    /// @notice Verifies the storageSlotTrieProof against saved MMRs\n    /// @notice Account's storage root has to be proven before calling this function\n    /// @param chainId Chain ID where the queried block lives\n    /// @param account Address of the account that contains the storage slot\n    /// @param blockNumber Block number at which the storage slot is stored\n    /// @param slot Index of the storage slot\n    /// @param storageSlotTrieProof MPT proof for the storage slot (has to hash to the storage root)\n    /// @return slotValue Value of the storage slot\n    function verifyStorage(uint256 chainId, address account, uint256 blockNumber, bytes32 slot, bytes calldata storageSlotTrieProof) external view returns (bytes32 slotValue);\n\n    /// @notice Verifies header proofs of two consecutive blocks, where the first block is the closest block with timestamp less than or equal to the given timestamp\n    /// @param chainId Chain ID where the queried block lives\n    /// @param timestamp Timestamp for which you are looking for the closest block\n    /// @param headerProof Header proof of the block that is the answer for the given timestamp\n    /// @param headerProofNext Header proof of the next block\n    /// @return blockNumber Block number of the closest block with timestamp that is less than or equal to the given timestamp\n    function verifyTimestamp(uint256 chainId, uint256 timestamp, BlockHeaderProof calldata headerProof, BlockHeaderProof calldata headerProofNext) external view returns (uint256);\n\n    // ========================= Events ========================= //\n\n    /// @notice Emitted when account fields are proven\n    event ProvenAccount(uint256 chainId, address account, uint256 blockNumber, uint8 savedFields, uint256 nonce, uint256 balance, bytes32 codeHash, bytes32 storageHash);\n\n    /// @notice Emitted when storage slot value is proven\n    event ProvenStorage(uint256 chainId, address account, uint256 blockNumber, bytes32 slot, bytes32 slotValue);\n\n    /// @notice Emitted when timestamp is proven\n    event ProvenTimestamp(uint256 chainId, uint256 timestamp, uint256 blockNumber);\n}\n"
    },
    "src/interfaces/modules/IMmrCoreModule.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.27;\n\nimport {Lib_RLPReader as RLPReader} from \"src/libraries/external/optimism/rlp/Lib_RLPReader.sol\";\nimport {StatelessMmr} from \"@solidity-mmr/lib/StatelessMmr.sol\";\n\nstruct RootForHashingFunction {\n    bytes32 root;\n    bytes32 hashingFunction;\n}\n\nenum GrownBy {\n    /// @dev GrownBy.EVM_ON_CHAIN_GROWER - appended by EvmOnChainGrowingModule\n    EVM_ON_CHAIN_GROWER,\n    /// @dev GrownBy.EVM_SHARP_GROWER - appended by EvmSharpGrowingModule\n    EVM_SHARP_GROWER,\n    /// @dev GrownBy.STARKNET_SHARP_GROWER - appended by StarknetSharpMmrGrowingModule\n    STARKNET_SHARP_GROWER\n}\n\nenum CreatedFrom {\n    FOREIGN,\n    DOMESTIC\n}\n\ninterface IMmrCoreModule {\n    // ========================= Other Satellite Modules Only Functions ========================= //\n\n    /// @notice Receiving a recent parent hash obtained on-chain directly on this chain or sent in a message from another one (eg. L1 -> L2)\n    /// @dev saves the parent hash of the block number (from a given chain) in the contract storage\n    function _receiveParentHash(uint256 chainId, bytes32 hashingFunction, uint256 blockNumber, bytes32 parentHash) external;\n\n    /// @notice Creates a new branch from message sent from satellite on another chain\n    /// @param newMmrId the ID of the MMR to create\n    /// @param rootsForHashingFunctions the roots of the MMR -> ABI encoded hashing function => MMR root\n    /// @param mmrSize the size of the MMR\n    /// @param accumulatedChainId the ID of the chain that the MMR accumulates (where block is?)\n    /// @param originChainId the ID of the chain from which the new MMR will be created (who is sending msg?)\n    /// @param originalMmrId the ID of the MMR from which the new MMR will be created\n    /// @param isSiblingSynced whether the MMR is sibling synced\n    function _createMmrFromForeign(\n        uint256 newMmrId,\n        RootForHashingFunction[] calldata rootsForHashingFunctions,\n        uint256 mmrSize,\n        uint256 accumulatedChainId,\n        uint256 originChainId,\n        uint256 originalMmrId,\n        bool isSiblingSynced\n    ) external;\n\n    // ========================= Core Functions ========================= //\n\n    /// @notice Creates a new MMR that is a clone of an already existing MMR or an empty MMR if originalMmrId is 0 (in that case mmrSize is ignored)\n    /// @param newMmrId the ID of the new MMR\n    /// @param originalMmrId the ID of the MMR from which the new MMR will be created - if 0 it means an empty MMR will be created\n    /// @param accumulatedChainId the ID of the chain that the MMR accumulates\n    /// @param mmrSize size at which the MMR will be copied\n    /// @param hashingFunctions the hashing functions used in the MMR - if more than one, the MMR will be sibling synced and require being a satellite module to call\n    function createMmrFromDomestic(uint256 newMmrId, uint256 originalMmrId, uint256 accumulatedChainId, uint256 mmrSize, bytes32[] calldata hashingFunctions) external;\n\n    // ========================= View functions ========================= //\n\n    function POSEIDON_HASHING_FUNCTION() external view returns (bytes32);\n\n    function KECCAK_HASHING_FUNCTION() external view returns (bytes32);\n\n    function POSEIDON_MMR_INITIAL_ROOT() external view returns (bytes32);\n\n    function KECCAK_MMR_INITIAL_ROOT() external view returns (bytes32);\n\n    function getMmrRoot(uint256 mmrId, uint256 mmrSize, uint256 accumulatedChainId, bytes32 hashingFunction) external view returns (bytes32);\n\n    function getLatestMmrRoot(uint256 mmrId, uint256 accumulatedChainId, bytes32 hashingFunction) external view returns (bytes32);\n\n    function getLatestMmrSize(uint256 mmrId, uint256 accumulatedChainId, bytes32 hashingFunction) external view returns (uint256);\n\n    function getReceivedParentHash(uint256 chainId, bytes32 hashingFunction, uint256 blockNumber) external view returns (bytes32);\n\n    // ========================= Events ========================= //\n\n    /// @notice emitted when a block hash is received\n    /// @param chainId the ID of the chain that the block hash is from\n    /// @param blockNumber the block number\n    /// @param parentHash the parent hash of the block number\n    /// @param hashingFunction the hashing function use to hash the block, e.g. Keccak on Ethereum and Poseidon on Starknet\n    /// @dev hashingFunction is a 32 byte keccak hash of the hashing function name, eg: keccak256(\"keccak256\"), keccak256(\"poseidon\")\n    event ReceivedParentHash(uint256 chainId, uint256 blockNumber, bytes32 parentHash, bytes32 hashingFunction);\n\n    /// @notice emitted when a new MMR is created from a domestic or foreign source\n    /// @notice - foreign source - sent from another chain, or off-chain computation proven on-chain\n    /// @notice - domestic source - created from another MMR on the same chain, or a standalone new empty MMR\n    /// @param newMmrId the ID of the new MMR\n    /// @param mmrSize the size of the MMR\n    /// @param accumulatedChainId the ID of the chain that the MMR accumulates\n    /// @param originalMmrId the ID of the MMR from which the new MMR is created - if 0, it means an new empty MMR was created\n    /// @param rootsForHashingFunctions list of pairs (mmrRoot, hashingFunction) representing mmr roots for each hashing function\n    /// @dev every hashingFunction should occur at most once in the list\n    /// @dev hashingFunction is a 32 byte keccak hash of the hashing function name, eg: keccak256(\"keccak256\"), keccak256(\"poseidon\")\n    /// @param originChainId the ID of the chain from which the new MMR comes from\n    /// @dev if originChainId equal to accumulatedChainId, it means the MMR is created from domestic source, otherwise it is created from foreign source\n    /// @param createdFrom enum representing the source of the MMR creation - DOMESTIC or FOREIGN\n    event CreatedMmr(\n        uint256 newMmrId,\n        uint256 mmrSize,\n        uint256 accumulatedChainId,\n        uint256 originalMmrId,\n        RootForHashingFunction[] rootsForHashingFunctions,\n        uint256 originChainId,\n        CreatedFrom createdFrom\n    );\n\n    /// @notice emitted when a batch of blocks is appended to the MMR\n    /// @param firstAppendedBlock the block number of the first block appended\n    /// @param lastAppendedBlock the block number of the last block appended\n    /// @param rootsForHashingFunctions list of pairs (mmrRoot, hashingFunction) representing mmr roots for each hashing function\n    /// @dev every hashingFunction should occur at most once in the list\n    /// @param mmrSize the size of the MMR after the batch of blocks is appended\n    /// @param mmrId the ID of the MMR that was grown\n    /// @param accumulatedChainId the ID of the chain that the MMR accumulates\n    /// @param grownBy enum representing which growing module appended blocks to MMR\n    event GrownMmr(\n        uint256 firstAppendedBlock,\n        uint256 lastAppendedBlock,\n        RootForHashingFunction[] rootsForHashingFunctions,\n        uint256 mmrSize,\n        uint256 mmrId,\n        uint256 accumulatedChainId,\n        GrownBy grownBy\n    );\n}\n"
    },
    "src/interfaces/modules/IOwnershipModule.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.27;\n\n/// @title ERC-173 Contract Ownership Standard\n///  Note: the ERC-165 identifier for this interface is 0x7f5828d0\n/* is ERC165 */\ninterface IOwnershipModule {\n    /// @notice Get the address of the owner\n    /// @return owner_ The address of the owner.\n    function owner() external view returns (address owner_);\n\n    /// @notice Set the address of the new owner of the contract\n    /// @dev Set _newOwner to address(0) to renounce any ownership.\n    /// @param _newOwner The address of the new owner of the contract\n    function transferOwnership(address _newOwner) external;\n}\n"
    },
    "src/interfaces/modules/ISatelliteConnectionRegistryModule.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.27;\n\nimport {ILibSatellite} from \"src/interfaces/ILibSatellite.sol\";\n\ninterface ISatelliteConnectionRegistryModule {\n    /// @param chainId - chain id of other side of the connection\n    /// @param satellite - address of the satellite deployed on `chainId`\n    /// @param inbox - address of the contract deployed on our chain responsible for sending message to `chainId`\n    /// @dev message can be sent to `chainId` if and only if `inbox` is set to non-zero address\n    /// @param senderSatelliteAlias - (aliased) address of the satellite deployed on `chainId` that sends message to our chain\n    /// @dev message can be received from `chainId` if and only if `senderSatelliteAlias` is set to non-zero address\n    /// @param sendMessageSelector - selector of the function responsible for sending message to `chainId`, this function should be part of `messaging/sender/*.sol`\n    function registerSatelliteConnection(uint256 chainId, uint256 satellite, address inbox, address senderSatelliteAlias, bytes4 sendMessageSelector) external;\n\n    /// @param chainId - chain id of other side of the connection\n    /// @param senderSatelliteAlias - (aliased) address of the satellite deployed on `chainId` that sends message to our chain\n    /// @dev `senderSatelliteAlias` should be the same as the one used when registering the connection\n    function removeSatelliteConnection(uint256 chainId, address senderSatelliteAlias) external;\n\n    /// @param chainId - chain id of other side of the connection\n    /// @return SatelliteConnection struct, which contains the satellite address, inbox address, and sendMessageSelector\n    function getSatelliteConnection(uint256 chainId) external view returns (ILibSatellite.SatelliteConnection memory);\n}\n"
    },
    "src/interfaces/modules/ISatelliteInspectorModule.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.27;\n\nimport {ILibSatellite} from \"src/interfaces/ILibSatellite.sol\";\n\ninterface ISatelliteInspectorModule {\n    /// @notice Gets all module addresses and their four byte function selectors.\n    /// @return modules_ Modules\n    function modules() external view returns (ILibSatellite.Module[] memory modules_);\n\n    /// @notice Gets all the function selectors supported by a specific module.\n    /// @param _module The module address.\n    /// @return moduleFunctionSelectors_\n    function moduleFunctionSelectors(address _module) external view returns (bytes4[] memory moduleFunctionSelectors_);\n\n    /// @notice Get all the module addresses used by a satellite.\n    /// @return moduleAddresses_\n    function moduleAddresses() external view returns (address[] memory moduleAddresses_);\n\n    /// @notice Gets the module that supports the given selector.\n    /// @dev If module is not found return address(0).\n    /// @param _functionSelector The function selector.\n    /// @return moduleAddress_ The module address.\n    function moduleAddress(bytes4 _functionSelector) external view returns (address moduleAddress_);\n\n    // Facet versions for compatibility\n\n    function facets() external view returns (ILibSatellite.Module[] memory facets_);\n    function facetFunctionSelectors(address _facet) external view returns (bytes4[] memory facetFunctionSelectors_);\n    function facetAddresses() external view returns (address[] memory facetAddresses_);\n    function facetAddress(bytes4 _functionSelector) external view returns (address facetAddress_);\n}\n"
    },
    "src/interfaces/modules/ISatelliteMaintenanceModule.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.27;\n\nimport {ILibSatellite} from \"src/interfaces/ILibSatellite.sol\";\n\ninterface ISatelliteMaintenanceModule {\n    /// @notice Add/replace/remove any number of functions and optionally exemaintenancee\n    ///         a function with delegatecall\n    /// @param _satelliteMaintenance Contains the module addresses and function selectors\n    /// @param _init The address of the contract or module to exemaintenancee _calldata\n    /// @param _calldata A function call, including function selector and arguments\n    ///                  _calldata is exemaintenanceed with delegatecall on _init\n    function satelliteMaintenance(ILibSatellite.ModuleMaintenance[] calldata _satelliteMaintenance, address _init, bytes calldata _calldata) external;\n}\n"
    },
    "src/interfaces/modules/messaging/receiver/IReceiverModule.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.27;\n\nimport {RootForHashingFunction} from \"src/interfaces/modules/IMmrCoreModule.sol\";\n\n/// @notice Receives messages from satellites deployed on other chains\ninterface IReceiverModule {\n    function receiveParentHash(uint256 chainId, bytes32 hashingFunction, uint256 blockNumber, bytes32 parentHash) external;\n\n    function receiveMmr(\n        uint256 newMmrId,\n        RootForHashingFunction[] calldata rootsForHashingFunctions,\n        uint256 mmrSize,\n        uint256 accumulatedChainId,\n        uint256 originChainId,\n        uint256 originalMmrId,\n        bool isSiblingSynced\n    ) external;\n}\n"
    },
    "src/interfaces/modules/messaging/sender/IArbitrumToApeChainSenderModule.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.27;\n\ninterface IArbitrumToApeChainSenderModule {\n    /// @notice Storage structure for the module\n    struct ArbitrumToApeChainSenderModuleStorage {\n        address apeChainTokenAddress;\n    }\n\n    /// @notice Set the address of the ApeChain token\n    /// @param tokenAddress the address of the native token in https://docs.apechain.com/contracts/Testnet/contract-information#chaininfo\n    function setApeChainTokenAddress(address tokenAddress) external;\n\n    /// @notice Send message from Arbitrum to ApeChain\n    /// @param satelliteAddress the address of the satellite on ApeChain\n    /// @param inboxAddress the address of the ApeChain Inbox\n    /// @dev inboxAddress - Inbox in https://docs.apechain.com/contracts/Testnet/contract-information#corecontracts\n    function sendMessageArbitrumToApeChain(uint256 satelliteAddress, address inboxAddress, bytes memory _data, bytes memory _xDomainMsgGasData) external payable;\n}\n"
    },
    "src/interfaces/modules/messaging/sender/IL1ToArbitrumSenderModule.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.27;\n\ninterface IL1ToArbitrumSenderModule {\n    /// @notice Send message from L1 to Arbitrum\n    /// @param satelliteAddress the address of the satellite on Arbitrum\n    /// @param inboxAddress the address of the Arbitrum Inbox\n    /// @dev inboxAddress - Delayed Inbox in https://docs.arbitrum.io/build-decentralized-apps/reference/contract-addresses\n    function sendMessageL1ToArbitrum(uint256 satelliteAddress, address inboxAddress, bytes memory _data, bytes memory _xDomainMsgGasData) external payable;\n}\n"
    },
    "src/interfaces/modules/messaging/sender/IL1ToOptimismSenderModule.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.27;\n\ninterface IL1ToOptimismSenderModule {\n    /// @notice Send message from L1 to Arbitrum\n    /// @param satelliteAddress the address of the satellite on Arbitrum\n    /// @param inboxAddress the address of the Arbitrum Inbox\n    /// @dev inboxAddress - L1CrossDomainMessengerProxy in https://docs.optimism.io/chain/addresses\n    function sendMessageL1ToOptimism(uint256 satelliteAddress, address inboxAddress, bytes memory _data, bytes memory _xDomainMsgGasData) external payable;\n}\n"
    },
    "src/interfaces/modules/messaging/sender/IL1ToStarknetSenderModule.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.27;\n\ninterface IL1ToStarknetSenderModule {\n    /// @notice Send message from L1 to Starknet\n    /// @param satelliteAddress the address of the satellite on Starknet\n    /// @param inboxAddress the address of the Starknet Core\n    function sendMessageL1ToStarknet(uint256 satelliteAddress, address inboxAddress, bytes memory _data, bytes memory _xDomainMsgGasData) external payable;\n}\n"
    },
    "src/interfaces/modules/messaging/sender/IUniversalSenderModule.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.27;\n\n/// @notice Interface for the sender module that can send messages to any chain registered in Satellite Connection Registry\ninterface IUniversalSenderModule {\n    /// @notice Send parent hash that was registered on our chain to the destination chain\n    /// @param destinationChainId the chain ID of the destination chain\n    /// @param accumulatedChainId the chain ID of the block that is being sent\n    /// @param hashingFunction the hashing function used to hash the parent hash\n    /// @param blockNumber the block number being sent\n    /// @param _xDomainMsgGasData the gas data for the cross-domain message, depends on the destination chain\n    function sendParentHash(\n        uint256 destinationChainId,\n        uint256 accumulatedChainId,\n        bytes32 hashingFunction,\n        uint256 blockNumber,\n        bytes calldata _xDomainMsgGasData\n    ) external payable;\n\n    /// @notice Send MMR that was registered on our chain to the destination chain\n    /// @param destinationChainId the chain ID of the destination chain\n    /// @param accumulatedChainId the chain ID of the block that is being sent\n    /// @param originalMmrId the ID of the original MMR\n    /// @param newMmrId the ID of the new MMR\n    /// @param hashingFunctions the hashing functions used to hash the MMR\n    /// @param isSiblingSyncedForSending if true, MMR will be required to be sibling synced and all hashing functions must be sent;\n    ///                                  if false, MMRs will be sent with sibling synced set to false (all hashing functions will be sent)\n    /// @param _xDomainMsgGasData the gas data for the cross-domain message, depends on the destination chain\n    function sendMmr(\n        uint256 destinationChainId,\n        uint256 accumulatedChainId,\n        uint256 originalMmrId,\n        uint256 newMmrId,\n        bytes32[] calldata hashingFunctions,\n        bool isSiblingSyncedForSending,\n        bytes calldata _xDomainMsgGasData\n    ) external payable;\n}\n"
    },
    "src/interfaces/modules/parent-hash-fetching/IArbitrumParentHashFetcherModule.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.27;\n\ninterface IERC20Outbox {\n    function roots(bytes32 input) external view returns (bytes32);\n}\n\n/// @notice Module that fetches the parent hash of blocks from Arbitrum\n/// @dev It needs to be deployed on the chain that Arbitrum settles on (L1)\ninterface IArbitrumParentHashFetcherModule {\n    struct ArbitrumParentHashFetcherModuleStorage {\n        IERC20Outbox outboxContract;\n        // Chain ID of blocks being fetched\n        uint256 chainId;\n    }\n\n    function initArbitrumParentHashFetcherModule(address outboxAddress, uint256 chainId) external;\n\n    function arbitrumFetchParentHash(bytes32 rootHash, bytes memory blockHeader) external;\n}\n"
    },
    "src/interfaces/modules/parent-hash-fetching/INativeParentHashFetcherModule.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.27;\n\n/// @notice Module that fetches the parent hash of blocks from the chain it's deployed on\ninterface INativeParentHashFetcherModule {\n    /// @notice Fetches the parent hash of a given block\n    function nativeFetchParentHash(uint256 blockNumber) external;\n}\n"
    },
    "src/interfaces/modules/parent-hash-fetching/IStarknetParentHashFetcherModule.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.27;\n\nimport {IStarknet} from \"src/interfaces/external/IStarknet.sol\";\n\n/// @notice Module that fetches the parent hash of blocks from Starknet\n/// @dev It needs to be deployed on the chain that Starknet settles on (L1)\ninterface IStarknetParentHashFetcherModule {\n    struct StarknetParentHashFetcherModuleStorage {\n        IStarknet starknetContract;\n        // Either Starknet or Starknet Sepolia chain ID\n        uint256 chainId;\n    }\n\n    function initStarknetParentHashFetcherModule(IStarknet starknetContract, uint256 chainId) external;\n\n    /// @notice Fetches the parent hash of the latest block\n    function starknetFetchParentHash() external;\n}\n"
    },
    "src/libraries/AccessController.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.20;\n\nimport {LibSatellite} from \"src/libraries/LibSatellite.sol\";\n\nabstract contract AccessController {\n    modifier onlyModule() {\n        LibSatellite.enforceIsSatelliteModule();\n        _;\n    }\n\n    modifier onlyOwner() {\n        LibSatellite.enforceIsContractOwner();\n        _;\n    }\n}\n"
    },
    "src/libraries/external/optimism/rlp/Lib_RLPReader.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >0.5.0;\n\n/**\n * @title Lib_RLPReader\n * @dev Adapted from \"RLPReader\" by Hamdi Allam (hamdi.allam97@gmail.com).\n */\nlibrary Lib_RLPReader {\n    /**\n     *\n     * Constants *\n     *\n     */\n    uint256 internal constant MAX_LIST_LENGTH = 32;\n\n    /**\n     *\n     * Enums *\n     *\n     */\n    enum RLPItemType {\n        DATA_ITEM,\n        LIST_ITEM\n    }\n\n    /**\n     *\n     * Structs *\n     *\n     */\n    struct RLPItem {\n        uint256 length;\n        uint256 ptr;\n    }\n\n    /**\n     *\n     * Internal Functions *\n     *\n     */\n\n    /**\n     * Converts bytes to a reference to memory position and length.\n     * @param _in Input bytes to convert.\n     * @return Output memory reference.\n     */\n    function toRLPItem(bytes memory _in) internal pure returns (RLPItem memory) {\n        uint256 ptr;\n        assembly {\n            ptr := add(_in, 32)\n        }\n\n        return RLPItem({length: _in.length, ptr: ptr});\n    }\n\n    /**\n     * Reads an RLP list value into a list of RLP items.\n     * @param _in RLP list value.\n     * @return Decoded RLP list items.\n     */\n    function readList(RLPItem memory _in) internal pure returns (RLPItem[] memory) {\n        (uint256 listOffset, , RLPItemType itemType) = _decodeLength(_in);\n\n        require(itemType == RLPItemType.LIST_ITEM, \"Invalid RLP list value.\");\n\n        // Solidity in-memory arrays can't be increased in size, but *can* be decreased in size by\n        // writing to the length. Since we can't know the number of RLP items without looping over\n        // the entire input, we'd have to loop twice to accurately size this array. It's easier to\n        // simply set a reasonable maximum list length and decrease the size before we finish.\n        RLPItem[] memory out = new RLPItem[](MAX_LIST_LENGTH);\n\n        uint256 itemCount = 0;\n        uint256 offset = listOffset;\n        while (offset < _in.length) {\n            require(itemCount < MAX_LIST_LENGTH, \"Provided RLP list exceeds max list length.\");\n\n            (uint256 itemOffset, uint256 itemLength, ) = _decodeLength(RLPItem({length: _in.length - offset, ptr: _in.ptr + offset}));\n\n            out[itemCount] = RLPItem({length: itemLength + itemOffset, ptr: _in.ptr + offset});\n\n            itemCount += 1;\n            offset += itemOffset + itemLength;\n        }\n\n        // Decrease the array size to match the actual item count.\n        assembly {\n            mstore(out, itemCount)\n        }\n\n        return out;\n    }\n\n    /**\n     * Reads an RLP list value into a list of RLP items.\n     * @param _in RLP list value.\n     * @return Decoded RLP list items.\n     */\n    function readList(bytes memory _in) internal pure returns (RLPItem[] memory) {\n        return readList(toRLPItem(_in));\n    }\n\n    /**\n     * Reads an RLP bytes value into bytes.\n     * @param _in RLP bytes value.\n     * @return Decoded bytes.\n     */\n    function readBytes(RLPItem memory _in) internal pure returns (bytes memory) {\n        (uint256 itemOffset, uint256 itemLength, RLPItemType itemType) = _decodeLength(_in);\n\n        require(itemType == RLPItemType.DATA_ITEM, \"Invalid RLP bytes value.\");\n\n        return _copy(_in.ptr, itemOffset, itemLength);\n    }\n\n    /**\n     * Reads an RLP bytes value into bytes.\n     * @param _in RLP bytes value.\n     * @return Decoded bytes.\n     */\n    function readBytes(bytes memory _in) internal pure returns (bytes memory) {\n        return readBytes(toRLPItem(_in));\n    }\n\n    /**\n     * Reads an RLP string value into a string.\n     * @param _in RLP string value.\n     * @return Decoded string.\n     */\n    function readString(RLPItem memory _in) internal pure returns (string memory) {\n        return string(readBytes(_in));\n    }\n\n    /**\n     * Reads an RLP string value into a string.\n     * @param _in RLP string value.\n     * @return Decoded string.\n     */\n    function readString(bytes memory _in) internal pure returns (string memory) {\n        return readString(toRLPItem(_in));\n    }\n\n    /**\n     * Reads an RLP bytes32 value into a bytes32.\n     * @param _in RLP bytes32 value.\n     * @return Decoded bytes32.\n     */\n    function readBytes32(RLPItem memory _in) internal pure returns (bytes32) {\n        require(_in.length <= 33, \"Invalid RLP bytes32 value.\");\n\n        (uint256 itemOffset, uint256 itemLength, RLPItemType itemType) = _decodeLength(_in);\n\n        require(itemType == RLPItemType.DATA_ITEM, \"Invalid RLP bytes32 value.\");\n\n        uint256 ptr = _in.ptr + itemOffset;\n        bytes32 out;\n        assembly {\n            out := mload(ptr)\n\n            // Shift the bytes over to match the item size.\n            if lt(itemLength, 32) {\n                out := div(out, exp(256, sub(32, itemLength)))\n            }\n        }\n\n        return out;\n    }\n\n    /**\n     * Reads an RLP bytes32 value into a bytes32.\n     * @param _in RLP bytes32 value.\n     * @return Decoded bytes32.\n     */\n    function readBytes32(bytes memory _in) internal pure returns (bytes32) {\n        return readBytes32(toRLPItem(_in));\n    }\n\n    /**\n     * Reads an RLP uint256 value into a uint256.\n     * @param _in RLP uint256 value.\n     * @return Decoded uint256.\n     */\n    function readUint256(RLPItem memory _in) internal pure returns (uint256) {\n        return uint256(readBytes32(_in));\n    }\n\n    /**\n     * Reads an RLP uint256 value into a uint256.\n     * @param _in RLP uint256 value.\n     * @return Decoded uint256.\n     */\n    function readUint256(bytes memory _in) internal pure returns (uint256) {\n        return readUint256(toRLPItem(_in));\n    }\n\n    /**\n     * Reads an RLP bool value into a bool.\n     * @param _in RLP bool value.\n     * @return Decoded bool.\n     */\n    function readBool(RLPItem memory _in) internal pure returns (bool) {\n        require(_in.length == 1, \"Invalid RLP boolean value.\");\n\n        uint256 ptr = _in.ptr;\n        uint256 out;\n        assembly {\n            out := byte(0, mload(ptr))\n        }\n\n        require(out == 0 || out == 1, \"Lib_RLPReader: Invalid RLP boolean value, must be 0 or 1\");\n\n        return out != 0;\n    }\n\n    /**\n     * Reads an RLP bool value into a bool.\n     * @param _in RLP bool value.\n     * @return Decoded bool.\n     */\n    function readBool(bytes memory _in) internal pure returns (bool) {\n        return readBool(toRLPItem(_in));\n    }\n\n    /**\n     * Reads an RLP address value into a address.\n     * @param _in RLP address value.\n     * @return Decoded address.\n     */\n    function readAddress(RLPItem memory _in) internal pure returns (address) {\n        if (_in.length == 1) {\n            return address(0);\n        }\n\n        require(_in.length == 21, \"Invalid RLP address value.\");\n\n        return address(uint160(readUint256(_in)));\n    }\n\n    /**\n     * Reads an RLP address value into a address.\n     * @param _in RLP address value.\n     * @return Decoded address.\n     */\n    function readAddress(bytes memory _in) internal pure returns (address) {\n        return readAddress(toRLPItem(_in));\n    }\n\n    /**\n     * Reads the raw bytes of an RLP item.\n     * @param _in RLP item to read.\n     * @return Raw RLP bytes.\n     */\n    function readRawBytes(RLPItem memory _in) internal pure returns (bytes memory) {\n        return _copy(_in);\n    }\n\n    /**\n     *\n     * Private Functions *\n     *\n     */\n\n    /**\n     * Decodes the length of an RLP item.\n     * @param _in RLP item to decode.\n     * @return Offset of the encoded data.\n     * @return Length of the encoded data.\n     * @return RLP item type (LIST_ITEM or DATA_ITEM).\n     */\n    function _decodeLength(RLPItem memory _in) private pure returns (uint256, uint256, RLPItemType) {\n        unchecked {\n            require(_in.length > 0, \"RLP item cannot be null.\");\n\n            uint256 ptr = _in.ptr;\n            uint256 prefix;\n            assembly {\n                prefix := byte(0, mload(ptr))\n            }\n\n            if (prefix <= 0x7f) {\n                // Single byte.\n\n                return (0, 1, RLPItemType.DATA_ITEM);\n            } else if (prefix <= 0xb7) {\n                // Short string.\n\n                uint256 strLen = prefix - 0x80;\n\n                require(_in.length > strLen, \"Invalid RLP short string.\");\n\n                return (1, strLen, RLPItemType.DATA_ITEM);\n            } else if (prefix <= 0xbf) {\n                // Long string.\n                uint256 lenOfStrLen = prefix - 0xb7;\n\n                require(_in.length > lenOfStrLen, \"Invalid RLP long string length.\");\n\n                uint256 strLen;\n                assembly {\n                    // Pick out the string length.\n                    strLen := div(mload(add(ptr, 1)), exp(256, sub(32, lenOfStrLen)))\n                }\n\n                require(_in.length > lenOfStrLen + strLen, \"Invalid RLP long string.\");\n\n                return (1 + lenOfStrLen, strLen, RLPItemType.DATA_ITEM);\n            } else if (prefix <= 0xf7) {\n                // Short list.\n                uint256 listLen = prefix - 0xc0;\n\n                require(_in.length > listLen, \"Invalid RLP short list.\");\n\n                return (1, listLen, RLPItemType.LIST_ITEM);\n            } else {\n                // Long list.\n                uint256 lenOfListLen = prefix - 0xf7;\n\n                require(_in.length > lenOfListLen, \"Invalid RLP long list length.\");\n\n                uint256 listLen;\n                assembly {\n                    // Pick out the list length.\n                    listLen := div(mload(add(ptr, 1)), exp(256, sub(32, lenOfListLen)))\n                }\n\n                require(_in.length > lenOfListLen + listLen, \"Invalid RLP long list.\");\n\n                return (1 + lenOfListLen, listLen, RLPItemType.LIST_ITEM);\n            }\n        }\n    }\n\n    /**\n     * Copies the bytes from a memory location.\n     * @param _src Pointer to the location to read from.\n     * @param _offset Offset to start reading from.\n     * @param _length Number of bytes to read.\n     * @return Copied bytes.\n     */\n    function _copy(uint256 _src, uint256 _offset, uint256 _length) private pure returns (bytes memory) {\n        unchecked {\n            bytes memory out = new bytes(_length);\n            if (out.length == 0) {\n                return out;\n            }\n\n            uint256 src = _src + _offset;\n            uint256 dest;\n            assembly {\n                dest := add(out, 32)\n            }\n\n            // Copy over as many complete words as we can.\n            for (uint256 i = 0; i < _length / 32; i++) {\n                assembly {\n                    mstore(dest, mload(src))\n                }\n\n                src += 32;\n                dest += 32;\n            }\n\n            // Pick out the remaining bytes.\n            uint256 mask = 256 ** (32 - (_length % 32)) - 1;\n            assembly {\n                mstore(dest, or(and(mload(src), not(mask)), and(mload(dest), mask)))\n            }\n\n            return out;\n        }\n    }\n\n    /**\n     * Copies an RLP item into bytes.\n     * @param _in RLP item to copy.\n     * @return Copied bytes.\n     */\n    function _copy(RLPItem memory _in) private pure returns (bytes memory) {\n        return _copy(_in.ptr, 0, _in.length);\n    }\n}\n"
    },
    "src/libraries/internal/data-processor/ModuleCodecs.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.20;\n\nimport {TaskCode} from \"./Task.sol\";\n\n/// @dev A module task.\n/// @param programHash The program hash of the module.\n/// @param inputs The inputs to the module.\nstruct ModuleTask {\n    bytes32 programHash;\n    bytes32[] inputs;\n}\n\n/// @notice Codecs for ModuleTask.\n/// @dev Represent module with a program hash and inputs.\nlibrary ModuleCodecs {\n    /// @dev Get the commitment of a Module.\n    /// @param module The Module to commit.\n    function commit(ModuleTask memory module) internal pure returns (bytes32) {\n        return keccak256(abi.encode(module.programHash, module.inputs));\n    }\n}\n"
    },
    "src/libraries/internal/data-processor/Task.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.20;\n\n/// @notice Task type.\nenum TaskCode {\n    // Datalake,\n    Module\n}\n"
    },
    "src/libraries/internal/Uint256Splitter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.27;\n\nlibrary Uint256Splitter {\n    uint256 constant _MASK = type(uint128).max;\n\n    /// @notice Splits a uint256 into two uint128s (low, high) represented as uint256s.\n    /// @param a The uint256 to split.\n    function split128(uint256 a) internal pure returns (uint256 lower, uint256 upper) {\n        return (a & _MASK, a >> 128);\n    }\n\n    /// @notice Merges two uint128s (low, high) into one uint256.\n    /// @param lower The lower uint256. The caller is required to pass a value that is less than 2^128 - 1.\n    /// @param upper The upper uint256.\n    function merge128(uint256 lower, uint256 upper) internal pure returns (uint256 a) {\n        require(lower <= _MASK, \"Uint256Splitter: lower exceeds uint128\");\n        // return (upper << 128) | lower;\n        assembly {\n            a := or(shl(128, upper), lower)\n        }\n    }\n}\n"
    },
    "src/libraries/LibSatellite.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.27;\n\nimport {console} from \"forge-std/console.sol\";\nimport {ISatellite} from \"src/interfaces/ISatellite.sol\";\nimport {ILibSatellite} from \"src/interfaces/ILibSatellite.sol\";\n\nlibrary LibSatellite {\n    // ========================= Constants ========================= //\n    /// @notice non existent MMR size\n    uint256 constant NO_MMR_SIZE = 0;\n    /// @notice non existent MMR root\n    bytes32 constant NO_MMR_ROOT = 0;\n    /// @notice non existent MMR id\n    uint256 constant EMPTY_MMR_ID = 0;\n    /// @notice empty MMR size\n    uint256 constant EMPTY_MMR_SIZE = 1;\n    /// @notice diamond storage position\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\"diamond.standard.satellite.storage\");\n\n    function satelliteStorage() internal pure returns (ILibSatellite.SatelliteStorage storage s) {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        assembly {\n            s.slot := position\n        }\n    }\n\n    function setContractOwner(address _newOwner) internal {\n        ILibSatellite.SatelliteStorage storage s = satelliteStorage();\n        address previousOwner = s.contractOwner;\n        s.contractOwner = _newOwner;\n        emit ILibSatellite.OwnershipTransferred(previousOwner, _newOwner);\n    }\n\n    function contractOwner() internal view returns (address contractOwner_) {\n        contractOwner_ = satelliteStorage().contractOwner;\n    }\n\n    function enforceIsContractOwner() internal view {\n        if (msg.sender != satelliteStorage().contractOwner) {\n            revert ILibSatellite.MustBeContractOwner();\n        }\n    }\n\n    function enforceIsSatelliteModule() internal view {\n        if (msg.sender != address(this)) {\n            revert ILibSatellite.MustBeSatelliteModule();\n        }\n    }\n\n    modifier onlySatelliteModule() {\n        enforceIsSatelliteModule();\n        _;\n    }\n\n    event SatelliteMaintenance(ILibSatellite.ModuleMaintenance[] _satelliteMaintenance, address _init, bytes _calldata);\n\n    function satelliteMaintenance(ILibSatellite.ModuleMaintenance[] memory _satelliteMaintenance, address _init, bytes memory _calldata) internal {\n        for (uint256 moduleIndex; moduleIndex < _satelliteMaintenance.length; moduleIndex++) {\n            ILibSatellite.ModuleMaintenance memory moduleMaintenance = _satelliteMaintenance[moduleIndex];\n            ILibSatellite.ModuleMaintenanceAction action = moduleMaintenance.action;\n            if (action == ILibSatellite.ModuleMaintenanceAction.Add) {\n                addFunctions(moduleMaintenance.moduleAddress, moduleMaintenance.functionSelectors);\n            } else if (action == ILibSatellite.ModuleMaintenanceAction.Replace) {\n                replaceFunctions(moduleMaintenance.moduleAddress, moduleMaintenance.functionSelectors);\n            } else if (action == ILibSatellite.ModuleMaintenanceAction.Remove) {\n                removeFunctions(moduleMaintenance.moduleAddress, moduleMaintenance.functionSelectors);\n            } else {\n                revert ILibSatellite.IncorrectModuleMaintenanceAction(action);\n            }\n        }\n        emit SatelliteMaintenance(_satelliteMaintenance, _init, _calldata);\n        initializeSatelliteMaintenance(_init, _calldata);\n    }\n\n    function addFunctions(address _moduleAddress, bytes4[] memory _functionSelectors) internal {\n        if (_functionSelectors.length == 0) {\n            revert ILibSatellite.NoSelectorsInModuleToMaintenance();\n        }\n        if (_moduleAddress == address(0)) {\n            revert ILibSatellite.AddModuleAddressZero();\n        }\n\n        ILibSatellite.SatelliteStorage storage s = satelliteStorage();\n        uint96 selectorPosition = uint96(s.moduleFunctionSelectors[_moduleAddress].functionSelectors.length);\n        /// @dev add new module address if it does not exist\n        if (selectorPosition == 0) {\n            addModule(s, _moduleAddress);\n        }\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldModuleAddress = s.selectorToModuleAndPosition[selector].moduleAddress;\n            if (oldModuleAddress != address(0)) {\n                revert ILibSatellite.AddFunctionAlreadyExists(selector);\n            }\n            addFunction(s, selector, selectorPosition, _moduleAddress);\n            selectorPosition++;\n        }\n    }\n\n    function replaceFunctions(address _moduleAddress, bytes4[] memory _functionSelectors) internal {\n        if (_functionSelectors.length == 0) {\n            revert ILibSatellite.NoSelectorsInModuleToMaintenance();\n        }\n        if (_moduleAddress == address(0)) {\n            revert ILibSatellite.AddModuleAddressZero();\n        }\n\n        ILibSatellite.SatelliteStorage storage s = satelliteStorage();\n        uint96 selectorPosition = uint96(s.moduleFunctionSelectors[_moduleAddress].functionSelectors.length);\n        /// @dev add new module address if it does not exist\n        if (selectorPosition == 0) {\n            addModule(s, _moduleAddress);\n        }\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldModuleAddress = s.selectorToModuleAndPosition[selector].moduleAddress;\n            if (oldModuleAddress == _moduleAddress) {\n                revert ILibSatellite.ReplaceFunctionWithSameFunction(selector);\n            }\n            removeFunction(s, oldModuleAddress, selector);\n            addFunction(s, selector, selectorPosition, _moduleAddress);\n            selectorPosition++;\n        }\n    }\n\n    function removeFunctions(address _moduleAddress, bytes4[] memory _functionSelectors) internal {\n        if (_functionSelectors.length == 0) {\n            revert ILibSatellite.NoSelectorsInModuleToMaintenance();\n        }\n        // TODO: remove this if statement\n        if (_moduleAddress == address(0)) {\n            revert ILibSatellite.AddModuleAddressZero();\n        }\n\n        ILibSatellite.SatelliteStorage storage s = satelliteStorage();\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldModuleAddress = s.selectorToModuleAndPosition[selector].moduleAddress;\n            removeFunction(s, oldModuleAddress, selector);\n        }\n    }\n\n    function addModule(ILibSatellite.SatelliteStorage storage s, address _moduleAddress) internal {\n        enforceHasContractCode(_moduleAddress, \"New module has no code\");\n        s.moduleFunctionSelectors[_moduleAddress].moduleAddressPosition = s.moduleAddresses.length;\n        s.moduleAddresses.push(_moduleAddress);\n    }\n\n    function addFunction(ILibSatellite.SatelliteStorage storage s, bytes4 _selector, uint96 _selectorPosition, address _moduleAddress) internal {\n        s.selectorToModuleAndPosition[_selector].functionSelectorPosition = _selectorPosition;\n        s.moduleFunctionSelectors[_moduleAddress].functionSelectors.push(_selector);\n        s.selectorToModuleAndPosition[_selector].moduleAddress = _moduleAddress;\n    }\n\n    function removeFunction(ILibSatellite.SatelliteStorage storage s, address _moduleAddress, bytes4 _selector) internal {\n        if (_moduleAddress == address(0)) {\n            revert ILibSatellite.RemoveFunctionDoesNotExist();\n        }\n        if (_moduleAddress == address(this)) {\n            revert ILibSatellite.RemoveImmutableFunction();\n        }\n\n        uint256 selectorPosition = s.selectorToModuleAndPosition[_selector].functionSelectorPosition;\n        uint256 lastSelectorPosition = s.moduleFunctionSelectors[_moduleAddress].functionSelectors.length - 1;\n        if (selectorPosition != lastSelectorPosition) {\n            bytes4 lastSelector = s.moduleFunctionSelectors[_moduleAddress].functionSelectors[lastSelectorPosition];\n            s.moduleFunctionSelectors[_moduleAddress].functionSelectors[selectorPosition] = lastSelector;\n            s.selectorToModuleAndPosition[lastSelector].functionSelectorPosition = uint96(selectorPosition);\n        }\n        s.moduleFunctionSelectors[_moduleAddress].functionSelectors.pop();\n        delete s.selectorToModuleAndPosition[_selector];\n\n        /// @dev if no more selectors for module address then delete the module address\n        if (lastSelectorPosition == 0) {\n            uint256 lastModuleAddressPosition = s.moduleAddresses.length - 1;\n            uint256 moduleAddressPosition = s.moduleFunctionSelectors[_moduleAddress].moduleAddressPosition;\n            if (moduleAddressPosition != lastModuleAddressPosition) {\n                address lastModuleAddress = s.moduleAddresses[lastModuleAddressPosition];\n                s.moduleAddresses[moduleAddressPosition] = lastModuleAddress;\n                s.moduleFunctionSelectors[lastModuleAddress].moduleAddressPosition = moduleAddressPosition;\n            }\n            s.moduleAddresses.pop();\n            delete s.moduleFunctionSelectors[_moduleAddress].moduleAddressPosition;\n        }\n    }\n\n    function initializeSatelliteMaintenance(address _init, bytes memory _calldata) internal {\n        if (_init == address(0)) {\n            if (_calldata.length != 0) {\n                revert ILibSatellite.InitAddressZeroButCalldataNotEmpty();\n            }\n        } else {\n            if (_calldata.length == 0) {\n                revert ILibSatellite.CalldataEmptyButInitNotEmpty();\n            }\n\n            if (_init != address(this)) {\n                enforceHasContractCode(_init, \"_init address has no code\");\n            }\n            (bool success, bytes memory error) = _init.delegatecall(_calldata);\n            if (!success) {\n                if (error.length > 0) {\n                    revert ILibSatellite.InitFunctionReverted(string(error));\n                } else {\n                    revert ILibSatellite.InitFunctionReverted(\"Init function reverted\");\n                }\n            }\n        }\n    }\n\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\n        uint256 contractSize;\n        assembly {\n            contractSize := extcodesize(_contract)\n        }\n        if (contractSize == 0) {\n            revert ILibSatellite.AddressHasNoCode(_errorMessage);\n        }\n    }\n}\n"
    },
    "src/modules/DataProcessorModule.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.20;\n\nimport {MerkleProof} from \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport {IFactsRegistry} from \"src/interfaces/external/IFactsRegistry.sol\";\nimport {ISatellite} from \"src/interfaces/ISatellite.sol\";\nimport {LibSatellite} from \"src/libraries/LibSatellite.sol\";\nimport {ModuleTask, ModuleCodecs} from \"src/libraries/internal/data-processor/ModuleCodecs.sol\";\nimport {IDataProcessorModule} from \"src/interfaces/modules/IDataProcessorModule.sol\";\nimport {AccessController} from \"src/libraries/AccessController.sol\";\n\n/// @title DataProcessorModule\n/// @author Herodotus Dev Ltd\n/// @notice A contract to store the execution results of HDP tasks\ncontract DataProcessorModule is IDataProcessorModule, AccessController {\n    // ========================= Types ========================= //\n\n    using MerkleProof for bytes32[];\n    using ModuleCodecs for ModuleTask;\n\n    // ========================= Constants ========================= //\n\n    bytes32 constant POSEIDON_HASHING_FUNCTION = keccak256(\"poseidon\");\n\n    // ========================= Satellite Module Storage ========================= //\n\n    bytes32 constant MODULE_STORAGE_POSITION = keccak256(\"diamond.standard.satellite.module.storage.data-processor\");\n\n    function moduleStorage() internal pure returns (DataProcessorModuleStorage storage s) {\n        bytes32 position = MODULE_STORAGE_POSITION;\n        assembly {\n            s.slot := position\n        }\n    }\n\n    // ========================= Owner-only Functions ========================= //\n\n    /// @inheritdoc IDataProcessorModule\n    function setDataProcessorProgramHash(bytes32 programHash) external onlyOwner {\n        DataProcessorModuleStorage storage ms = moduleStorage();\n        ms.authorizedProgramHashes[programHash] = true;\n        emit ProgramHashEnabled(programHash);\n    }\n\n    /// @inheritdoc IDataProcessorModule\n    function disableProgramHashes(bytes32[] calldata programHashes) external onlyOwner {\n        DataProcessorModuleStorage storage ms = moduleStorage();\n\n        for (uint256 i = 0; i < programHashes.length; i++) {\n            ms.authorizedProgramHashes[programHashes[i]] = false;\n        }\n        emit ProgramHashesDisabled(programHashes);\n    }\n\n    /// @inheritdoc IDataProcessorModule\n    function setDataProcessorFactsRegistry(IFactsRegistry factsRegistry) external onlyOwner {\n        DataProcessorModuleStorage storage ms = moduleStorage();\n        ms.factsRegistry = factsRegistry;\n    }\n\n    // ========================= Core Functions ========================= //\n\n    /// @inheritdoc IDataProcessorModule\n    function requestDataProcessorExecutionOfTask(ModuleTask calldata moduleTask) external {\n        DataProcessorModuleStorage storage ms = moduleStorage();\n        bytes32 taskCommitment = moduleTask.commit();\n\n        if (ms.cachedTasksResult[taskCommitment].status == TaskStatus.FINALIZED) {\n            emit TaskAlreadyStored(taskCommitment);\n        } else {\n            // Ensure task is not already scheduled\n            if (ms.cachedTasksResult[taskCommitment].status != TaskStatus.NONE) {\n                revert DoubleRegistration();\n            }\n\n            // Store the task result\n            ms.cachedTasksResult[taskCommitment] = TaskResult({status: TaskStatus.SCHEDULED, result: \"\"});\n\n            emit ModuleTaskScheduled(moduleTask);\n        }\n    }\n\n    /// @inheritdoc IDataProcessorModule\n    function authenticateDataProcessorTaskExecution(TaskData calldata taskData) external {\n        DataProcessorModuleStorage storage ms = moduleStorage();\n\n        bytes32 taskHash = bytes32((taskData.taskHashHigh << 128) | taskData.taskHashLow);\n\n        if (ms.cachedTasksResult[taskHash].status == TaskStatus.FINALIZED) {\n            revert TaskAlreadyFinalized();\n        }\n\n        if (!isProgramHashAuthorized(taskData.programHash)) {\n            revert UnauthorizedProgramHash();\n        }\n\n        // Initialize an array of uint256 to store the program output\n        uint256[] memory programOutput = new uint256[](4 + taskData.mmrData.length * 4);\n\n        // Assign values to the program output array\n        // This needs to be compatible with cairo program\n        // https://github.com/HerodotusDev/hdp-cairo/blob/main/src/utils/utils.cairo#L27-L48\n        programOutput[0] = taskData.taskHashLow;\n        programOutput[1] = taskData.taskHashHigh;\n        programOutput[2] = taskData.taskResultLow;\n        programOutput[3] = taskData.taskResultHigh;\n\n        for (uint8 i = 0; i < taskData.mmrData.length; i++) {\n            MmrData memory mmr = taskData.mmrData[i];\n            bytes32 usedMmrRoot = loadMmrRoot(mmr.mmrId, mmr.mmrSize, mmr.chainId);\n            if (usedMmrRoot == bytes32(0)) {\n                revert InvalidMmrRoot();\n            }\n            programOutput[4 + i * 4] = mmr.mmrId;\n            programOutput[4 + i * 4 + 1] = mmr.mmrSize;\n            programOutput[4 + i * 4 + 2] = mmr.chainId;\n            programOutput[4 + i * 4 + 3] = uint256(usedMmrRoot);\n        }\n\n        // Compute program output hash\n        bytes32 programOutputHash = keccak256(abi.encodePacked(programOutput));\n\n        // Compute GPS fact hash\n        bytes32 gpsFactHash = keccak256(abi.encode(taskData.programHash, programOutputHash));\n\n        // Ensure GPS fact is registered\n        if (!ms.factsRegistry.isValid(gpsFactHash)) {\n            revert InvalidFact();\n        }\n\n        bytes32 taskResult = bytes32((taskData.taskResultHigh << 128) | taskData.taskResultLow);\n\n        // Store the task result\n        ms.cachedTasksResult[taskHash] = TaskResult({status: TaskStatus.FINALIZED, result: taskResult});\n        emit TaskFinalized(taskHash, taskResult);\n    }\n\n    // ========================= View Functions ========================= //\n\n    /// @inheritdoc IDataProcessorModule\n    function getDataProcessorFactsRegistry() external view returns (address) {\n        DataProcessorModuleStorage storage ms = moduleStorage();\n        return address(ms.factsRegistry);\n    }\n\n    /// @inheritdoc IDataProcessorModule\n    function getDataProcessorFinalizedTaskResult(bytes32 taskCommitment) external view returns (bytes32) {\n        DataProcessorModuleStorage storage ms = moduleStorage();\n        // Ensure task is finalized\n        if (ms.cachedTasksResult[taskCommitment].status != TaskStatus.FINALIZED) {\n            revert NotFinalized();\n        }\n        return ms.cachedTasksResult[taskCommitment].result;\n    }\n\n    /// @inheritdoc IDataProcessorModule\n    function getDataProcessorTaskStatus(bytes32 taskCommitment) external view returns (TaskStatus) {\n        DataProcessorModuleStorage storage ms = moduleStorage();\n        return ms.cachedTasksResult[taskCommitment].status;\n    }\n\n    /// @inheritdoc IDataProcessorModule\n    function isProgramHashAuthorized(bytes32 programHash) public view returns (bool) {\n        DataProcessorModuleStorage storage ms = moduleStorage();\n        return ms.authorizedProgramHashes[programHash];\n    }\n\n    // ========================= Internal Functions ========================= //\n\n    /// @notice Load MMR root from cache with given mmrId and mmrSize\n    function loadMmrRoot(uint256 mmrId, uint256 mmrSize, uint256 chainId) internal view returns (bytes32) {\n        ISatellite.SatelliteStorage storage s = LibSatellite.satelliteStorage();\n        return s.mmrs[chainId][mmrId][POSEIDON_HASHING_FUNCTION].mmrSizeToRoot[mmrSize];\n    }\n\n    /// @notice Returns the leaf of standard merkle tree\n    function standardEvmHDPLeafHash(bytes32 value) internal pure returns (bytes32) {\n        bytes32 firstHash = keccak256(abi.encode(value));\n        bytes32 leaf = keccak256(abi.encode(firstHash));\n        return leaf;\n    }\n}\n"
    }
  },
  "settings": {
    "viaIR": true,
    "optimizer": {
      "enabled": true,
      "runs": 200,
      "details": {
        "yulDetails": {
          "optimizerSteps": "u"
        }
      }
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  }
}}