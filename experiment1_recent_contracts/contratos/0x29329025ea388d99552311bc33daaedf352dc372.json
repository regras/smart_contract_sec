{{
  "language": "Solidity",
  "sources": {
    "src/books/SubscriptionBook.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.28;\n\nimport {SafeERC20Upgradeable} from\n    \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {IERC20Upgradeable} from \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\nimport {SafeCast} from \"openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport {SortedLinkedList} from \"src/lib/SortedLinkedList.sol\";\n\nimport {ISubscriptionBook} from \"src/interfaces/ISubscriptionBook.sol\";\nimport {ISettlementToken} from \"src/interfaces/ISettlementToken.sol\";\nimport {ISecurityToken} from \"src/interfaces/ISecurityToken.sol\";\nimport {IRoleRegistry} from \"src/interfaces/IRoleRegistry.sol\";\nimport {IInvestorRegistry} from \"src/interfaces/IInvestorRegistry.sol\";\nimport {IDealerRegistry} from \"src/interfaces/IDealerRegistry.sol\";\nimport {IInstrumentRegistry} from \"src/interfaces/IInstrumentRegistry.sol\";\nimport {IOperationsEngine} from \"src/interfaces/IOperationsEngine.sol\";\nimport {OrderDetails, Context} from \"src/interfaces/IOrderPipeline.sol\";\nimport {OPERATIONS} from \"src/interfaces/operations/IOperationModule.sol\";\n\nimport \"src/utils/Constant.sol\";\n\nimport {OrderPipeline} from \"src/OrderPipeline.sol\";\nimport {PermissionedContract} from \"src/PermissionedContract.sol\";\n\n/**\n * @title SubscriptionBook\n * @author Libre\n * @notice This contract manages subscription orders for financial instruments, providing functionalities for order creation,\n *         settlement, cancellation, and instant settlement. It enforces business rules and ensures compliance with subscription policies.\n * @dev Utilizes `OrderPipeline` for shared order management functionalities and interacts with contracts like\n *      `ISettlementToken`, `ISecurityToken`, and `IOperationsEngine`.\n */\ncontract SubscriptionBook is OrderPipeline, ISubscriptionBook {\n    using SortedLinkedList for SortedLinkedList.List;\n    using SafeERC20Upgradeable for ISettlementToken;\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @notice Initializes the SubscriptionBook contract with necessary dependencies.\n     * @param _instrumentId The ID of the instrument associated with this subscription.\n     * @param _settlementToken Address of the settlement token used for subscriptions.\n     * @param _operationsEngine Address of the operations engine for processing business rules.\n     * @param _securityToken Address of the security token contract.\n     * @param _treasury Address of the treasury wallet.\n     * @param _roleRegistry Address of the role registry for access control.\n     * @param _investorRegistry Address of the investor registry.\n     * @param _dealerRegistry Address of the dealer registry.\n     * @param _instrumentRegistry Address of the instrument registry for managing instrument data.\n     */\n    function initialize(\n        bytes32 _instrumentId,\n        ISettlementToken _settlementToken,\n        IOperationsEngine _operationsEngine,\n        ISecurityToken _securityToken,\n        address _treasury,\n        address _policyViewer,\n        IRoleRegistry _roleRegistry,\n        IInvestorRegistry _investorRegistry,\n        IDealerRegistry _dealerRegistry,\n        IInstrumentRegistry _instrumentRegistry\n    ) external initializer {\n        OrderPipelineStorage storage ops = _getOrderPipelineStorage();\n        ops.securityToken = _securityToken;\n        ops.instrumentId = _instrumentId;\n        ops.instrumentRegistry = _instrumentRegistry;\n        ops.operationsEngine = _operationsEngine;\n        ops.investorRegistry = _investorRegistry;\n        ops.dealerRegistry = _dealerRegistry;\n        ops.settlementToken = _settlementToken;\n        ops.treasury = _treasury;\n        ops.policyViewer = _policyViewer;\n\n        ops.currentPeriod = 1;\n\n        PermissionedContractStorage storage pcs = _getPermissionedContractStorage();\n        pcs.roleRegistry = _roleRegistry;\n    }\n\n    function investorCreateOrder(OrderProofData calldata _proof) external returns (uint256 orderId) {\n        OrderPipelineStorage storage ops = _getOrderPipelineStorage();\n        Context memory ctx = _getContext(ops);\n        _checkInstrumentNotPaused(ctx.instrumentRegistry, ctx.instrumentId);\n\n        {\n            (, orderId) = _beforeOrderCheck(ctx, ops, _proof, msg.sender, msg.sender, false);\n\n            bytes memory data = abi.encode(_proof.journal.investorId, _proof.journal.amount);\n            bytes memory result = ctx.operationsEngine.check(OPERATIONS.CREATE_SUBSCRIPTION, ctx.instrumentId, data);\n\n            (bool checkSuccess, string memory errorMsg) = abi.decode(result, (bool, string));\n            require(checkSuccess, errorMsg);\n\n            ctx.operationsEngine.track(OPERATIONS.CREATE_SUBSCRIPTION, ctx.instrumentId, data);\n        }\n\n        _createOrder(\n            ctx,\n            ops,\n            _proof.journal.investorId,\n            _proof.journal.amount,\n            msg.sender,\n            msg.sender,\n            orderId,\n            OPERATIONS.SUBSCRIPTION_EXECUTION_DATE_CALCULATION,\n            IERC20Upgradeable(address(ctx.settlementToken))\n        );\n\n        _afterOrderCheck(ctx, ops, orderId);\n\n        return orderId;\n    }\n\n    function dealerCreateOrder(OrderProofData calldata _proof, address _investorWallet, address _beneficiaryWallet)\n        external\n        returns (uint256 orderId)\n    {\n        OrderPipelineStorage storage ops = _getOrderPipelineStorage();\n        Context memory ctx = _getContext(ops);\n        _checkInstrumentNotPaused(ctx.instrumentRegistry, ctx.instrumentId);\n\n        address sender;\n        (sender, orderId) = _beforeOrderCheck(ctx, ops, _proof, _investorWallet, _beneficiaryWallet, true);\n\n        {\n            bytes memory data = abi.encode(_proof.journal.investorId, _proof.journal.amount);\n            bytes memory result =\n                ctx.operationsEngine.check(OPERATIONS.ADVISED_CREATE_SUBSCRIPTION, ctx.instrumentId, data);\n            (bool checkSuccess, string memory errorMsg) = abi.decode(result, (bool, string));\n            require(checkSuccess, errorMsg);\n\n            ctx.operationsEngine.track(OPERATIONS.ADVISED_CREATE_SUBSCRIPTION, ctx.instrumentId, data);\n        }\n\n        _createOrder(\n            ctx,\n            ops,\n            _proof.journal.investorId,\n            _proof.journal.amount,\n            _beneficiaryWallet,\n            sender,\n            orderId,\n            OPERATIONS.SUBSCRIPTION_EXECUTION_DATE_CALCULATION,\n            IERC20Upgradeable(address(ctx.settlementToken))\n        );\n        _afterOrderCheck(ctx, ops, orderId);\n\n        return orderId;\n    }\n\n    function settleOrders(uint256 _lastOrderId, uint256 _percentageToSettle, bytes32 _role) external {\n        OrderPipelineStorage storage ops = _getOrderPipelineStorage();\n        Context memory ctx = _getContext(ops);\n\n        if (ctx.instrumentRegistry.getBool(ctx.instrumentId, INSTRUMENT_CLOSED)) {\n            revert IOrderPipeline_InstrumentClosed();\n        }\n\n        _checkRoleHasAccess(_role);\n\n        uint256[] memory allOrders = _beforeSettleOrders(ctx, ops, _percentageToSettle, _lastOrderId, true);\n\n        uint256 settledAmount = _processSettlements(ctx, ops, allOrders, _lastOrderId, _percentageToSettle);\n\n        ctx.operationsEngine.track(OPERATIONS.SETTLE_SUBSCRIPTIONS, ctx.instrumentId, abi.encode(settledAmount));\n    }\n\n    function getSubscriptionAmount(uint256 _orderId) external view returns (uint256 _amount) {\n        OrderPipelineStorage storage ops = _getOrderPipelineStorage();\n\n        _amount = ops.orders[_orderId].amount;\n    }\n\n    function adminCancelOrder(uint256 _orderId, bytes32 _role) public override {\n        OrderPipelineStorage storage ops = _getOrderPipelineStorage();\n        Context memory ctx = _getContext(ops);\n        OrderDetails storage order = ops.orders[_orderId];\n\n        // tracking just the unsettled amount (order.amount - order.settledAmount)\n        bytes memory data = abi.encode(order.investorId, order.amount - order.settledAmount);\n        ctx.operationsEngine.track(OPERATIONS.SUBSCRIPTION_CANCELLATION, ctx.instrumentId, data);\n\n        super.adminCancelOrder(_orderId, _role);\n    }\n\n    function _processSettlements(\n        Context memory _ctx,\n        OrderPipelineStorage storage _ops,\n        uint256[] memory _allOrders,\n        uint256 _lastOrderId,\n        uint256 _percentageToSettle\n    ) internal returns (uint256 settledAmount) {\n        uint256 nav = _ctx.instrumentRegistry.getUint(_ctx.instrumentId, AUDITED_NAV_PER_SHARE);\n        uint256 decimals = 10 ** _ctx.securityToken.decimals();\n\n        (uint256 totalToSettle, OrderDetails[] memory ordersToSettle) =\n            _getTotalToSettle(_ctx, _ops, _allOrders, _lastOrderId, _percentageToSettle, nav);\n\n        uint256 nextOrderId;\n\n        for (uint256 i;; ++i) {\n            OrderDetails memory order = ordersToSettle[i];\n\n            // Calculate the amount of SET to be settled for this order\n            uint256 toSettle = _checkSettleOrder(_ctx, _allOrders[i], order);\n\n            // Determine the amount to settle by taking the minimum of:\n            // - `totalToSettle`: The maximum settlement amount for all orders.\n            // - `toSettle`: The allowed amount for this specific order, as checked by external modules.\n            // - `percentageToSettle`: The requested settlement percentage of the remaining unsettled amount.\n            // Note: remaining (un settled) amount is (_order.amount - _order.settledAmount)\n            // Ensures that the final settlement amount does not exceed the order's allowed or available limits.\n            {\n                uint256 allowedAmountByPercentage = (order.amount - order.settledAmount) * _percentageToSettle / 100_00;\n                uint256 minimumAmount = toSettle < allowedAmountByPercentage ? toSettle : allowedAmountByPercentage;\n                toSettle = totalToSettle < minimumAmount ? totalToSettle : minimumAmount;\n            }\n\n            if (toSettle != 0) {\n                _ops.orders[_allOrders[i]].settledAmount += SafeCast.toUint128(toSettle);\n                _ops.settledAmount += toSettle;\n                totalToSettle -= toSettle;\n                settledAmount += toSettle;\n\n                // cache nextOrderId if this iteration will break the loop\n                if (_allOrders[i] == _lastOrderId || totalToSettle == 0) {\n                    nextOrderId = _ops.ordersList.getNext(_allOrders[i]);\n                }\n\n                _partialSettlement(\n                    _ctx,\n                    _ops,\n                    _allOrders[i],\n                    order.investorId,\n                    toSettle,\n                    order.executionTimestamp,\n                    order.beneficiary,\n                    nav,\n                    decimals\n                );\n            }\n            if (_allOrders[i] == _lastOrderId || totalToSettle == 0) {\n                // update storage nextOrderToSettle using cached value\n                _ops.nextOrderToSettle = nextOrderId;\n                break;\n            }\n        }\n    }\n\n    function _getTotalToSettle(\n        Context memory _ctx,\n        OrderPipelineStorage storage _ops,\n        uint256[] memory _allOrders,\n        uint256 _lastOrderId,\n        uint256 _percentageToSettle,\n        uint256 _nav\n    ) internal returns (uint256 totalToSettle, OrderDetails[] memory ordersToSettle) {\n        IOperationsEngine operationsEngine = _ctx.operationsEngine;\n\n        ordersToSettle = new OrderDetails[](_allOrders.length);\n        uint256 aggregate;\n        for (uint256 i; i < _allOrders.length; ++i) {\n            ordersToSettle[i] = _ops.orders[_allOrders[i]];\n            aggregate +=\n                (ordersToSettle[i].amount - ordersToSettle[i].settledAmount) * _percentageToSettle / PERCENTAGE_BASE;\n        }\n\n        bytes memory result = operationsEngine.check(\n            OPERATIONS.SETTLE_SUBSCRIPTIONS,\n            _ctx.instrumentId,\n            abi.encode(_ops.settledAmount, _lastOrderId, aggregate, _percentageToSettle, _nav)\n        );\n        string memory errorMsg;\n        (totalToSettle, errorMsg) = abi.decode(result, (uint256, string));\n        require(totalToSettle != 0, errorMsg);\n    }\n\n    /**\n     * @dev Performs pre-order checks to validate investor and subscription data.\n     * @param _ctx The context of the order pipeline.\n     * @param _ops The Order Pipeline Storage.\n     * @param _proof The proof containing investor and subscription data.\n     * @param _investorWallet The wallet address of the investor.\n     * @param _beneficiaryWallet The address that will benefit from the subscription.\n     * @param _isFromDealer Indicates whether the order is created by a dealer on behalf of an investor.\n     * @return sender The address initiating the transaction.\n     * @return orderId The generated order ID.\n     */\n    function _beforeOrderCheck(\n        Context memory _ctx,\n        OrderPipelineStorage storage _ops,\n        OrderProofData calldata _proof,\n        address _investorWallet,\n        address _beneficiaryWallet,\n        bool _isFromDealer\n    ) internal returns (address sender, uint256 orderId) {\n        if (_proof.journal.policyViewer != _ops.policyViewer) {\n            revert IOrderPipeline_PolicyViewerProofMismatch();\n        }\n\n        if (_proof.journal.instrumentId != _ctx.instrumentId) {\n            revert IOrderPipeline_InstrumentIdProofMismatch();\n        }\n\n        if (!_isFromDealer && _proof.journal.investorId != _ctx.investorRegistry.getIdFromWallet(msg.sender)) {\n            revert IOrderPipeline_InvestorIdProofMismatch();\n        }\n\n        _ctx.investorRegistry.checkCredentialInstrument(_proof.journal.investorId, _ctx.instrumentId);\n        _ctx.investorRegistry.checkSubscription(_proof);\n\n        (sender, orderId) = super._beforeOrderCheck(\n            _ctx,\n            _ops,\n            _proof.journal.amount,\n            _proof.journal.investorId,\n            _investorWallet,\n            _beneficiaryWallet,\n            _isFromDealer\n        );\n\n        if (_ctx.settlementToken.balanceOf(sender) < _proof.journal.amount) {\n            revert IOrderPipeline_InsufficientAmount();\n        }\n\n        return (sender, orderId);\n    }\n\n    function _sendReceivedToken(Context memory _ctx, address _receiver, uint256 _amount) internal override {\n        uint256 beforeTransferBalance = _ctx.settlementToken.balanceOf(_receiver);\n        _ctx.settlementToken.safeTransfer(_receiver, _amount);\n        if (_ctx.settlementToken.balanceOf(_receiver) != beforeTransferBalance + _amount) {\n            revert IOrderPipeline_SettlementTokenTransferFailed();\n        }\n    }\n\n    /**\n     * @notice Instant settlement of an order when the all the 4 phases are executed in the same transaction.\n     * @param _ctx The context of the order pipeline.\n     * @param _ops The Order Pipeline Storage.\n     * @param _orderId Id of the order to settle\n     */\n    function _instantSettlement(Context memory _ctx, OrderPipelineStorage storage _ops, uint256 _orderId)\n        internal\n        override\n    {\n        OrderDetails memory order = _ops.orders[_orderId];\n\n        _beforeSettlementUpdates(_ctx, _ops, true);\n\n        _ops.orders[_orderId].settledAmount += order.amount;\n        _ops.settledAmount += order.amount;\n        _partialSettlement(\n            _ctx,\n            _ops,\n            _orderId,\n            order.investorId,\n            order.amount,\n            order.executionTimestamp,\n            order.beneficiary,\n            _ctx.instrumentRegistry.getUint(_ctx.instrumentId, AUDITED_NAV_PER_SHARE),\n            10 ** _ctx.securityToken.decimals()\n        );\n    }\n\n    /**\n     * @dev Handles the partial settlement of a subscription order.\n     * Mints security tokens for the beneficiary and deducts the settled amount.\n     * @param _ctx The context of the order pipeline.\n     * @param _ops The storage struct containing pipeline data.\n     * @param _orderId The ID of the order being settled.\n     * @param _investorId The ID of the investor associated with the order.\n     * @param _amountToSettle The amount to be settled in the current transaction.\n     * @param _beneficiaryWallet The address receiving the security tokens.\n     * @param _nav The Net Asset Value per share used for calculations.\n     * @param _decimals The decimal precision of the security token.\n     */\n    function _partialSettlement(\n        Context memory _ctx,\n        OrderPipelineStorage storage _ops,\n        uint256 _orderId,\n        bytes32 _investorId,\n        uint256 _amountToSettle,\n        uint256 _executionTimestamp,\n        address _beneficiaryWallet,\n        uint256 _nav,\n        uint256 _decimals\n    ) internal {\n        if (_amountToSettle != 0) {\n            _ctx.settlementToken.burn(address(this), _amountToSettle, SETTLEMENT_TOKEN_BURNER_ROLE);\n        }\n\n        uint256 amountToIssue = (_amountToSettle * _decimals) / _nav;\n        if (amountToIssue != 0) {\n            _ctx.securityToken.issue(_beneficiaryWallet, amountToIssue);\n        } else {\n            revert ISubscriptionBook_AmountToIssueIsZero();\n        }\n\n        _updateOrder(_ops, _orderId, _ops.orders[_orderId].amount == (_ops.orders[_orderId].settledAmount));\n\n        bytes memory data = abi.encode(_investorId, _amountToSettle, amountToIssue, _executionTimestamp);\n        _ctx.operationsEngine.track(OPERATIONS.SETTLE_SUBSCRIPTION_PER_ORDER, _ctx.instrumentId, data);\n\n        emit OrderSettled(_orderId, _amountToSettle);\n    }\n\n    /**\n     * @notice Calculates the amount that can be settled for an order.\n     * @dev Fetches allowed settlement from external modules, applies percentage-based limit,\n     *      and returns the minimum of all constraints.\n     * @param _ctx The context of the order pipeline.\n     * @param _order The order details.\n     * @return allowedToSettle The final calculated amount to settle for the given order.\n     */\n    function _checkSettleOrder(Context memory _ctx, uint256 _orderId, OrderDetails memory _order)\n        internal\n        returns (uint256 allowedToSettle)\n    {\n        // get allowed settlement amount from external modules for this specific order\n        // Even if we can settle the whole order or the remaining amount in the order\n        // the check module may return the allowed amount which may be less than the remaining amount\n        // check the amount that can be settled after fetching some modules.\n        // note: (_order.amount - _order.settledAmount) is the remaining amount to be settled (unsettledAmount)\n        bytes memory perOrderResult = _ctx.operationsEngine.check(\n            OPERATIONS.SETTLE_SUBSCRIPTION_PER_ORDER,\n            _ctx.instrumentId,\n            abi.encode(_order.executionTimestamp, 0, _order.amount - _order.settledAmount, 0, 0, _order.investorId) // 0 is for the check to work\n        );\n\n        // decode the response from external checks\n        string memory errorMsg;\n        (allowedToSettle, errorMsg) = abi.decode(perOrderResult, (uint256, string));\n        if (allowedToSettle == 0) {\n            emit OrderSettlementSkipped(_orderId, errorMsg);\n        }\n    }\n}\n"
    },
    "lib/openzeppelin-contracts-upgradeable/contracts/token/ERC20/utils/SafeERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.19;\n\nimport \"../IERC20Upgradeable.sol\";\nimport \"../extensions/IERC20PermitUpgradeable.sol\";\nimport \"../../../utils/AddressUpgradeable.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20Upgradeable {\n    using AddressUpgradeable for address;\n\n    /**\n     * @dev An operation with an ERC20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20Upgradeable token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20Upgradeable token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20Upgradeable token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Compatible with tokens that require the approval to be set to\n     * 0 before setting it to a non-zero value.\n     */\n    function forceApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20PermitUpgradeable token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        if (nonceAfter != nonceBefore + 1) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20Upgradeable token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}\n"
    },
    "lib/openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.19;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.19;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value > type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value > type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value > type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value > type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value > type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value > type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value > type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value > type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value > type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value > type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value > type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value > type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value > type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value > type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value > type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value > type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value > type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value > type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value > type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value > type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value > type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value > type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value > type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value > type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value > type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value > type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value > type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value > type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value > type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value > type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value > type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     *\n     * _Available since v3.0._\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value < 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     *\n     * _Available since v3.0._\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value > uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n}\n"
    },
    "src/lib/SortedLinkedList.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.28;\n\nlibrary SortedLinkedList {\n    /**\n     * @dev Pointers to the prev and next nodes in the list.\n     */\n    struct Node {\n        uint256 prev;\n        uint256 next;\n    }\n\n    struct List {\n        uint256 begin; // The first id in the list.\n        uint256 end; // The last id in the list.\n        uint256 size; // The total amount of ids in the list.\n        // Mapping of nodes ids to their prev and next nodes.\n        mapping(uint256 nodeId => Node node) nodes;\n    }\n\n    error SortedLinked_ListIDNotInList();\n    error SortedLinked_ListIDAlreadyInList();\n    error SortedLinked_ListInvalidRange();\n    error SortedLinked_ListInvalidId();\n\n    /**\n     * @notice Insert a node into the list while maintaining an ascending order for _l.nodes.\n     * @param _l The sorted linked list to instert the node in\n     * @param _id The ID of the node to insert.\n     */\n    function insert(List storage _l, uint256 _id) public {\n        if (_id == 0) {\n            revert SortedLinked_ListInvalidId();\n        }\n        uint256 begin = _l.begin;\n        uint256 end = _l.end;\n        uint256 size = _l.size;\n        if (size == 0) {\n            _l.begin = _id;\n            _l.end = _id;\n        } else if (_id > end) {\n            _l.nodes[end].next = _id;\n            _l.nodes[_id].prev = end;\n            _l.end = _id;\n        } else if (_id < begin) {\n            _l.nodes[begin].prev = _id;\n            _l.nodes[_id].next = begin;\n            _l.begin = _id;\n        } else {\n            uint256 current = begin;\n            for (uint256 i; i < size; ++i) {\n                if (_id < current) {\n                    uint256 prev = _l.nodes[current].prev;\n                    _l.nodes[prev].next = _id;\n                    _l.nodes[_id].prev = prev;\n                    _l.nodes[current].prev = _id;\n                    _l.nodes[_id].next = current;\n                    break;\n                }\n                if (_id == current) {\n                    revert SortedLinked_ListIDAlreadyInList();\n                }\n                current = _l.nodes[current].next;\n            }\n        }\n        ++_l.size;\n    }\n\n    /**\n     * @notice Remove a node from the list.\n     * @param _l The sorted linked list to remove a node from\n     * @param _id The ID to remove.\n     */\n    function erase(List storage _l, uint256 _id) public {\n        uint256 begin = _l.begin;\n        uint256 end = _l.end;\n        uint256 size = _l.size;\n        if (_id < begin || _id > end || size == 0 || ((size == 1) && (_id != begin))) {\n            revert SortedLinked_ListIDNotInList();\n        }\n        if (size == 1) {\n            delete _l.begin;\n            delete _l.end;\n        } else if (_id == begin) {\n            uint256 next = _l.nodes[_id].next;\n            _l.begin = next;\n            delete _l.nodes[next].prev;\n        } else if (_id == end) {\n            uint256 prev = _l.nodes[_id].prev;\n            _l.end = prev;\n            delete _l.nodes[prev].next;\n        } else {\n            uint256 next = _l.nodes[_id].next;\n            if (next == 0) {\n                // no way 0 is next if node is on the list\n                // and it is not the end one\n                revert SortedLinked_ListIDNotInList();\n            }\n\n            uint256 prev = _l.nodes[_id].prev;\n            _l.nodes[prev].next = next;\n            _l.nodes[next].prev = prev;\n        }\n        delete _l.nodes[_id];\n        _l.size--;\n    }\n\n    /**\n     * @return An array of all ids of the nodes in the sorted list.\n     * @param _l The sorted linked list to get the ids from\n     */\n    function getNodesId(List storage _l) public view returns (uint256[] memory) {\n        uint256 size = _l.size;\n        if (size == 0) return new uint256[](0);\n        uint256[] memory result = new uint256[](size);\n        uint256 current = _l.begin;\n        uint256 i;\n        while (i < size) {\n            result[i] = current;\n            current = _l.nodes[current].next;\n            ++i;\n        }\n        return result;\n    }\n\n    /**\n     * @notice An array of all ids of the nodes in the sorted list in range [_from, _to]\n     * @param _l The sorted linked list to get the ids from\n     * @param _from The ID to begin from.\n     * @param _to The ID to end.\n     */\n    function getNodesIdInRange(List storage _l, uint256 _from, uint256 _to)\n        public\n        view\n        returns (uint256[] memory allOrderIds)\n    {\n        if (_to != 0) {\n            if (\n                (_from > _to) || (_from != _l.begin && _l.nodes[_from].prev == 0)\n                    || (_to != _l.end && _l.nodes[_to].next == 0)\n            ) {\n                revert SortedLinked_ListInvalidRange();\n            }\n\n            allOrderIds = new uint256[](_l.size);\n            uint256 i;\n\n            while (_from != 0 && _from <= _to) {\n                allOrderIds[i] = _from;\n                _from = _l.nodes[_from].next;\n                ++i;\n            }\n\n            // resize the array dynamically using Yul\n            assembly {\n                mstore(allOrderIds, i)\n            }\n        }\n    }\n\n    /**\n     * @notice Return the next of a node\n     * @param _l The sorted linked list where the node belongs to\n     * @param _id The ID of the node to get the next of\n     * @dev Next is returned for any node existent or not. If the node\n     * requested is the end of the list 0 is returned\n     */\n    function getNext(List storage _l, uint256 _id) internal view returns (uint256) {\n        return _l.nodes[_id].next;\n    }\n}\n"
    },
    "src/interfaces/ISubscriptionBook.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {IERC20} from \"openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\nimport {IInvestorRegistry} from \"src/interfaces/IInvestorRegistry.sol\";\nimport {IDealerRegistry} from \"src/interfaces/IDealerRegistry.sol\";\nimport {IFundRegistry} from \"src/interfaces/IFundRegistry.sol\";\nimport {IInstrumentRegistry} from \"src/interfaces/IInstrumentRegistry.sol\";\nimport {IRoleRegistry} from \"src/interfaces/IRoleRegistry.sol\";\nimport {IOperationsEngine} from \"src/interfaces/IOperationsEngine.sol\";\nimport {IOperationsEngine} from \"src/interfaces/IOperationsEngine.sol\";\nimport {ISecurityToken} from \"src/interfaces/ISecurityToken.sol\";\nimport {ISettlementToken} from \"src/interfaces/ISettlementToken.sol\";\nimport {IOrderPipeline} from \"src/interfaces/IOrderPipeline.sol\";\n\n/**\n * @title ISubscriptionBook\n * @author Libre\n * @notice Interface for managing subscription books, including initialization, subscription tracking, and investor information.\n * @dev Extends the `IOrderPipeline` interface for managing order pipelines.\n */\ninterface ISubscriptionBook is IOrderPipeline {\n    /**\n     * @dev Revert when the amount to issue is zero\n     */\n    error ISubscriptionBook_AmountToIssueIsZero();\n\n    /**\n     * @notice Initializes the subscription\n     * @param _instrumentId Id of the instrument the subscription is associated to\n     * @param _settlementToken Address of the settlement token\n     * @param _operationsEngine Address of the operations engine\n     * @param _securityToken Address of the instrument's security token\n     * @param _treasury Address of the instrument's treasury\n     * @param _policyViewer Address of the instrument's policy viewer\n     * @param _roleRegistry Address of the role registry\n     * @param _investorRegistry Address of the investor registry\n     * @param _dealerRegistry Address of the dealer registry\n     * @param _instrumentRegistry Address of the instrument registry\n     */\n    function initialize(\n        bytes32 _instrumentId,\n        ISettlementToken _settlementToken,\n        IOperationsEngine _operationsEngine,\n        ISecurityToken _securityToken,\n        address _treasury,\n        address _policyViewer,\n        IRoleRegistry _roleRegistry,\n        IInvestorRegistry _investorRegistry,\n        IDealerRegistry _dealerRegistry,\n        IInstrumentRegistry _instrumentRegistry\n    ) external;\n\n    /**\n     * @notice Gets the subscription amount of an order\n     * @param _orderId ID of the order\n     * @return amount_ Amount of the subscription\n     */\n    function getSubscriptionAmount(uint256 _orderId) external view returns (uint256 amount_);\n}\n"
    },
    "src/interfaces/ISettlementToken.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {IERC20MetadataUpgradeable} from\n    \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\n\n/**\n * @title ISettlementToken\n * @author Libre\n * @notice Interface for settlement tokens, providing minting and burning capabilities with role-based access control.\n * @dev This interface extends the `IERC20MetadataUpgradeable` for ERC20 token standard compliance.\n */\ninterface ISettlementToken is IERC20MetadataUpgradeable {\n    /**\n     * @notice Thrown when a transfer operation is not allowed due to insufficient permissions or other restrictions.\n     */\n    error ISettlementToken_TransferNotAllowed();\n\n    /**\n     * @notice Thrown when a token is paused.\n     */\n    error ISettlementToken_TokenPaused();\n\n    /**\n     * @notice Emitted when the name and symbol of the settlement token are updated.\n     * @param _name The new name of the token.\n     * @param _symbol The new symbol of the token.\n     */\n    event NameAndSymbolChanged(string _name, string _symbol);\n\n    /**\n     * @notice Issue tokens to an address\n     * @param _account Address to mint to\n     * @param _amount Amount issued\n     * @param _role Role of the minter\n     */\n    function mint(address _account, uint256 _amount, bytes32 _role) external;\n\n    /**\n     * @notice Burn tokens from an address\n     * @param _account Address to burn from\n     * @param _amount Amount burned\n     * @param _role Role of the burner\n     */\n    function burn(address _account, uint256 _amount, bytes32 _role) external;\n\n    /**\n     * @notice Burn all tokens from an address\n     * @param _account Address to burn from\n     * @param _role Role of the burner\n     */\n    function burnAll(address _account, bytes32 _role) external;\n}\n"
    },
    "src/interfaces/ISecurityToken.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {IERC20MetadataUpgradeable} from\n    \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\n\nimport {IInstrumentRegistry} from \"src/interfaces/IInstrumentRegistry.sol\";\nimport {IInvestorRegistry} from \"src/interfaces/IInvestorRegistry.sol\";\nimport {IOperationsEngine} from \"src/interfaces/IOperationsEngine.sol\";\nimport {IRoleRegistry} from \"src/interfaces/IRoleRegistry.sol\";\n\n/**\n * @title ISecurityToken\n * @author Libre\n * @notice Interface for managing a security token associated with an instrument.\n * Provides functions for issuing, burning, and transferring tokens, as well as retrieving investor and holder information.\n * @dev This interface extends the `IERC20MetadataUpgradeable` for ERC20 token standard compliance.\n */\ninterface ISecurityToken is IERC20MetadataUpgradeable {\n    /**\n     * @notice Thrown when a non-subscription book contract attempts to issue tokens.\n     */\n    error ISecurityToken_OnlySubscriptionBookCanIssueTokens();\n\n    /**\n     * @notice Thrown when a non-redemption book contract attempts to burn tokens.\n     */\n    error ISecurityToken_OnlyRedemptionBookCanBurnTokens();\n\n    /**\n     * @notice Thrown when a non-redemption book or core gateway contract attempts to perform a forced transfer.\n     */\n    error ISecurityToken_OnlyRedemptionBookOrGatewayCanForceTransfer();\n\n    /**\n     * @notice Thrown when attempting to transfer zero tokens, which is not allowed.\n     */\n    error ISecurityToken_ZeroValueTransfersNotAllowed();\n\n    /**\n     * @notice Thrown when the instrument is paused.\n     */\n    error ISecurityToken_InstrumentPaused();\n\n    /**\n     * @notice Thrown when from address for transfer is zero\n     */\n    error ISecurityToken_InvalidSender();\n\n    /**\n     * @notice Thrown when to address for transfer is zero\n     */\n    error ISecurityToken_InvalidReceiver();\n\n    /**\n     * @notice Emitted when the name and symbol of the security token are updated.\n     * @param _name The new name of the token.\n     * @param _symbol The new symbol of the token.\n     */\n    event NameAndSymbolChanged(string _name, string _symbol);\n\n    /**\n     * @notice Issue tokens to an address\n     * @param _holder Address of the receiver\n     * @param _amount Amount issued\n     */\n    function issue(address _holder, uint256 _amount) external;\n\n    /**\n     * @notice Burn tokens from the caller\n     * @param _amount Amount burned\n     */\n    function burn(uint256 _amount) external;\n\n    /**\n     * @notice Initializes the security token\n     * @param _instrumentId Id of the instrument the security token is associated to\n     * @param _name Name of the token\n     * @param _symbol Symbol of the token\n     * @param _operationsEngine Address of the instrument's operations engine\n     * @param _subscriptionBook Address of the instrument's subscription book\n     * @param _redemptionBook Address of the instrument's redemption book\n     * @param _instrumentRegistry Address of the instrument registry\n     * @param _investorRegistry Address of the investor registry\n     * @param _roleRegistry Address of the role registry\n     */\n    function initialize(\n        bytes32 _instrumentId,\n        string memory _name,\n        string memory _symbol,\n        IOperationsEngine _operationsEngine,\n        address _subscriptionBook,\n        address _redemptionBook,\n        IInstrumentRegistry _instrumentRegistry,\n        IInvestorRegistry _investorRegistry,\n        IRoleRegistry _roleRegistry\n    ) external;\n\n    /**\n     * @notice Forced transfer execution\n     * @dev Only callable by redemption book or by Libre Admin in case of blacklisted wallets\n     * @param _from Address from where assets are transferred\n     * @param _to Address where tokens were sent\n     * @param _amount Amount of tokens sent\n     * @param _role Role required to make the transfer\n     */\n    function forceTransfer(address _from, address _to, uint256 _amount, bytes32 _role) external;\n\n    /**\n     * @notice Changes the name and symbol of the token\n     * @param _name New name\n     * @param _symbol New symbol\n     * @param _role Role required to make the change\n     */\n    function changeNameAndSymbol(string calldata _name, string calldata _symbol, bytes32 _role) external;\n\n    /**\n     * @notice Gets the aggregate balance of an investor\n     * @param _investorId Investor to get the balance of\n     * @return Balance value\n     */\n    function getInvestorBalance(bytes32 _investorId) external view returns (uint256);\n\n    /**\n     * @notice Gets the ID of the Instrument this token is associated to\n     * @return Instrument ID\n     */\n    function getInstrumentId() external view returns (bytes32);\n\n    /**\n     * @notice Get the number of holders of the token\n     * @return Amount of holders\n     * @dev Only valid investors are counted\n     */\n    function getHolders() external view returns (uint256);\n}\n"
    },
    "src/interfaces/IRoleRegistry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {IAccessControlUpgradeable} from\n    \"openzeppelin-contracts-upgradeable/contracts/access/IAccessControlUpgradeable.sol\";\n\n/**\n * @title Roles Registry\n * @author Libre\n * @notice Store all the roles of the system as well as the permissions a user get by having each role.\n * @dev It is meant to be used for roles access validation in all the components of the system.\n */\ninterface IRoleRegistry is IAccessControlUpgradeable {\n    /**\n     * @notice Thrown when attempting to create a role that already exists.\n     */\n    error IRoleRegistry_RoleAlreadyExists();\n\n    /**\n     * @notice Thrown when attempting to grant a role that does not exist.\n     */\n    error IRoleRegistry_RoleDoesNotExist();\n\n    /**\n     * @notice Thrown when attempting to use a blacklisted wallet.\n     */\n    error IRoleRegistry_WalletBlacklisted();\n\n    /**\n     * @notice Used when a new role is created\n     * @param _role Parent role\n     * @param _subRole Newly created Role\n     */\n    event RoleCreated(bytes32 _role, bytes32 _subRole);\n\n    /**\n     * @notice Used when a contract manager is set\n     * @param _contract Contract managed\n     * @param _roleManager New contract manager role\n     */\n    event ContractManagerAdded(address _contract, bytes32 _roleManager);\n\n    /**\n     * @notice Used when a wallet is blacklisted\n     * @param _wallet Wallet blacklisted\n     */\n    event WalletBlacklisted(address _wallet);\n\n    /**\n     * @notice Used when a contract function access is granted\n     * @param _contract Contract managed\n     * @param _selector Selector of the funtion which access is modified\n     * @param _role Role getting access gratend\n     */\n    event AccessGranted(address _contract, bytes4 _selector, bytes32 _role);\n\n    /**\n     * @notice Used when a contract function access is revoked\n     * @param _contract Contract managed\n     * @param _selector Selector of the funtion which access is modified\n     * @param _role Role which access is revoked\n     */\n    event RevokedAccess(address _contract, bytes4 _selector, bytes32 _role);\n\n    /**\n     * @notice Used when a contract access is reset\n     * @param _contract Contract managed\n     * @param _timestamp Time when the reset is executed\n     */\n    event ResetedAccess(address _contract, uint256 _timestamp);\n\n    /**\n     * @notice Function to create subroles\n     * @param _role New role to create\n     * @param _adminRole Parent role of the newly created role\n     * @dev Caller needs to has role _adminRole\n     */\n    function createRole(bytes32 _role, bytes32 _adminRole) external;\n\n    /**\n     * @notice Set the role going to manage permissions in a specific contract\n     * @param _contract Address of the contract to where permissions are needed to be managed\n     * @param _roleManager Role in charge of managing the permissions\n     */\n    function setContractManager(address _contract, bytes32 _roleManager) external;\n\n    /**\n     * @notice Get the role that manages permissions in a specific contract\n     * @param _contract Address of the contract\n     */\n    function getContractManager(address _contract) external view returns (bytes32);\n\n    /**\n     * @notice Grant a role the right access a functionality of a contract\n     * @param _contract Contract where the access is granted\n     * @param _selector Functionality granted access for\n     * @param _role Role getting the access\n     */\n    function grantAccess(address _contract, bytes4 _selector, bytes32 _role) external;\n\n    /**\n     * @notice Prevent a role for having access to a functionality of a contract\n     * @param _contract Contract where the access is revoked\n     * @param _selector Functionality revoked access for\n     * @param _role Role losing the access\n     */\n    function revokeAccess(address _contract, bytes4 _selector, bytes32 _role) external;\n\n    /**\n     * @notice Revoke access to a functionality of a contract for all roles\n     * @param _contract Contract where the access is reset\n     * @param _selector Functionality reset access for\n     * @dev Cleans all the previously granted roles\n     */\n    function resetAccess(address _contract, bytes4 _selector) external;\n\n    /**\n     * @notice Blacklists a wallet.\n     * @param _wallet The wallet to blacklist.\n     */\n    function blacklistWallet(address _wallet) external;\n\n    /**\n     * @notice Check access of a role to a contract functionality\n     * @param _contract Contract where accessed\n     * @param _selector Functionality accessed\n     * @param _requestor Address attempting to access\n     * @param _role Role of the address attempting to access\n     */\n    function hasAccess(address _contract, bytes4 _selector, address _requestor, bytes32 _role)\n        external\n        view\n        returns (bool);\n\n    /**\n     * @notice Checks if a wallet is blacklisted.\n     * @param _wallet The wallet to check.\n     * @return Boolean indicating whether the wallet is blacklisted.\n     */\n    function isBlacklisted(address _wallet) external view returns (bool);\n}\n"
    },
    "src/interfaces/IInvestorRegistry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {IERC20MetadataUpgradeable} from\n    \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\n\nimport {IEAS, AttestationRequestData} from \"eas-contracts/IEAS.sol\";\nimport {IRiscZeroVerifier} from \"risc0/IRiscZeroVerifier.sol\";\n\nimport {IBaseRegistry} from \"src/interfaces/IBaseRegistry.sol\";\nimport {IRoleRegistry} from \"src/interfaces/IRoleRegistry.sol\";\nimport {IInstrumentRegistry} from \"src/interfaces/IInstrumentRegistry.sol\";\nimport {IDealerRegistry} from \"src/interfaces/IDealerRegistry.sol\";\nimport {IOperationsEngine} from \"src/interfaces/IOperationsEngine.sol\";\nimport {IUserRegistry} from \"src/interfaces/IUserRegistry.sol\";\nimport {IGatewayManager} from \"src/interfaces/IGatewayManager.sol\";\nimport {IEternalRegistryStorage} from \"src/interfaces/IEternalRegistryStorage.sol\";\nimport {OrderProofData, SteelProofData, CredentialProofData} from \"src/utils/Types.sol\";\nimport {IRiscZeroVerifier} from \"risc0/IRiscZeroVerifier.sol\";\n\n/**\n * @title IInvestorRegistry\n * @author Libre\n * @notice Interface for managing investors, including adding new investors, managing credentials, and verifying subscriptions.\n * It integrates with Ethereum Attestation Service (EAS) and zk-verifiers to ensure security and compliance.\n */\ninterface IInvestorRegistry is IBaseRegistry, IUserRegistry {\n    /// @notice Thrown when an operation is not permitted due to insufficient privileges.\n    error IInvestorRegistry_OperationNotPermitted();\n\n    /// @notice Thrown when the sender is not the dealer associated with the specified investor.\n    error IInvestorRegistry_NotInvestorsDealer();\n\n    /// @notice Thrown when the caller is not the Operations Engine.\n    error IInvestorRegistry_NotOperationsEngine();\n\n    /// @notice Thrown when the caller is not the Jurisdiction Registry.\n    error IInvestorRegistry_NotJurisdictionRegistry();\n\n    /// @notice Thrown when attempting to add an investor who is already registered.\n    error IInvestorRegistry_AlreadyAnInvestor();\n\n    /// @notice Thrown when the sender does not have the Contract Manager role.\n    error IInvestorRegistry_NoContractManagerRole();\n\n    /// @notice Thrown when the Resolver Verifier address is empty or invalid.\n    error IInvestorRegistry_EmptyResolverVerifier();\n\n    /// @notice Thrown when the provided zk program image IDs are empty.\n    error IInvestorRegistry_EmptyImageIDs();\n\n    /// @notice Thrown when the sender does not have the Attester role.\n    error IInvestorRegistry_NoAttesterRole();\n\n    /// @notice Thrown when attempting to access a schema that has not been set.\n    error IInvestorRegistry_SchemaNotSet();\n\n    /// @notice Thrown when attempting to access a credential that does not exist.\n    error IInvestorRegistry_NonExistingCredential();\n\n    /// @notice Thrown when the credential is found to be invalid or revoked.\n    error IInvestorRegistry_CredentialInvalid();\n\n    /// @notice Thrown when the Investor Id doesn't match with the attestation's investor Id.\n    error IInvestorRegistry_MismatchInvestorId();\n\n    /// @notice Thrown when a credential does not grant access to the specified instrument.\n    error IInvestorRegistry_InstrumentCredentialInvalid();\n\n    /// @notice Thrown when attempting to revoke access to instruments that are not part of the credential.\n    error IInvestorRegistry_InstrumentsToRevokeNotInCredential();\n\n    /// @notice Thrown when there is a mismatch in the policy viewer proof.\n    error IInvestorRegistry_PolicyViewerProofMismatch();\n\n    /// @notice Thrown when an invalid dealer ID is provided.\n    error IInvestorRegistry_InvalidDealerId();\n\n    // Events\n    /**\n     * @notice Emitted when a new investor is added to the registry.\n     * @param investorId The unique identifier of the new investor.\n     * @param wallet The initial wallet address associated with the investor.\n     */\n    event NewInvestorAdded(bytes32 investorId, address wallet);\n\n    /**\n     * @notice Emitted when a credential is set for an investor.\n     * @param investorId The unique identifier of the investor.\n     * @param instrumentIds The list of instrument IDs included in the credential.\n     */\n    event InvestorRegistryCredentialSet(bytes32 investorId, bytes32[] instrumentIds);\n\n    /**\n     * @notice Emitted when a credential is revoked for an investor.\n     * @param investorId The unique identifier of the investor.\n     * @param instrumentIds The list of instrument IDs that have been revoked.\n     */\n    event InvestorRegistryCredentialRevoked(bytes32 investorId, bytes32[] instrumentIds);\n\n    /**\n     * @notice Emitted when the Resolver Verifier is updated.\n     * @param resolverVerifierAddress The address of the new Resolver Verifier.\n     */\n    event InvestorRegistryResolverVerifierChanged(address resolverVerifierAddress);\n\n    /**\n     * @notice Emitted when the zk program image IDs are updated.\n     * @param credentialImageID The new image ID for the credential zk program.\n     * @param subscriptionImageID The new image ID for the subscription zk program.\n     */\n    event InvestorRegistryImageIDsChanged(bytes32 credentialImageID, bytes32 subscriptionImageID);\n\n    /**\n     * @notice Initialize the registry\n     * @param _roleRegistry Address of the Role Registry\n     * @param _instrumentRegistry Address of the Instrument Registry\n     * @param _dealerRegistry Address of the Dealer Registry\n     * @param _jurisdictionRegistry Address of the Jurisdiction Registry\n     * @param _operationsEngine Address of the Operations Engine\n     * @param _eas Address of the Ethereum Attestation Service contract\n     * @param _gatewayManager Address of the gateway manager contract\n     * @param _resolverVerifier Address of the Resolver Verifier\n     * @param _policyViewer Address of the Policy Viewer\n     */\n    function initialize(\n        IRoleRegistry _roleRegistry,\n        IInstrumentRegistry _instrumentRegistry,\n        IDealerRegistry _dealerRegistry,\n        IEternalRegistryStorage _jurisdictionRegistry,\n        IOperationsEngine _operationsEngine,\n        IEAS _eas,\n        IGatewayManager _gatewayManager,\n        address _resolverVerifier,\n        address _policyViewer\n    ) external;\n\n    /**\n     * @notice Adds a new investor to the registry\n     * @param _senderRole Role the sender claims to have\n     * @param _investorId ID of the investor\n     * @param _wallet Default address of the investor\n     * @param _dealerId ID of the dealer\n     */\n    function addInvestor(bytes32 _senderRole, bytes32 _investorId, address _wallet, bytes32 _dealerId) external;\n\n    /**\n     * @notice Checks a subscription is allowed into the instrument\n     * @param _proof proof data for zk verifier\n     */\n    function checkSubscription(OrderProofData calldata _proof) external view;\n\n    /**\n     * @notice Replaces the ResolverVerifier contract with a new version, renewing the schema in the process\n     * @param _resolverVerifier address of new resolverVerifier\n     */\n    function configureResolverVerifier(address _resolverVerifier) external;\n\n    /**\n     * @notice Changes the zk program image IDs to use with the verifier\n     * @param _credentialImageID new image ID for the credential zk program\n     * @param _subscriptionImageID new image ID for the subscription zk program\n     */\n    function configureImageIDs(bytes32 _credentialImageID, bytes32 _subscriptionImageID) external;\n\n    /**\n     * @notice Creates a new investor credential or updates an existing/revoked one\n     * @param _proof contains data for setting the credential, including the zk-proof to verify\n     * @dev When updating credential, seal should contain the proof for new instruments, while\n     * the journal should include existing ones to be kept, bridge new credential via gateway manager\n     */\n    function setCredential(CredentialProofData calldata _proof) external;\n\n    /**\n     * @notice Revokes an investor credential, or access to certain instruments, bridge revoked credential via gateway manager\n     * @param _investorId Id of the investor\n     * @param _instrumentIds Instruments to revoke access from (entire credential revoked if left empty)\n     */\n    function revokeCredential(bytes32 _investorId, bytes32[] calldata _instrumentIds) external;\n\n    /**\n     * @notice Checks if the investor has a valid credential\n     * @param _investorId Id of the investor\n     */\n    function checkCredential(bytes32 _investorId) external view;\n\n    /**\n     * @notice Checks if the investor has a valid credential granting access to the instrument\n     * @param _investorId Id of the investor\n     * @param _instrumentId Id of the instrument\n     */\n    function checkCredentialInstrument(bytes32 _investorId, bytes32 _instrumentId) external view;\n\n    /**\n     * @notice Get dealer id of an investor\n     * @param _investorId The ID of the investor\n     * @return dealerId_ Id of the dealer associated to the investor\n     */\n    function getDealer(bytes32 _investorId) external view returns (bytes32 dealerId_);\n\n    /**\n     * Used by the ResolverVerifier to fetch the proof data for the current attestation\n     * @return Proof Data\n     */\n    function getTempSteelProofData() external view returns (SteelProofData memory);\n}\n"
    },
    "src/interfaces/IDealerRegistry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {IBaseRegistry} from \"src/interfaces/IBaseRegistry.sol\";\nimport {IRoleRegistry} from \"src/interfaces/IRoleRegistry.sol\";\nimport {IInvestorRegistry} from \"src/interfaces/IInvestorRegistry.sol\";\nimport {IUserRegistry} from \"src/interfaces/IUserRegistry.sol\";\nimport {IOperationsEngine} from \"src/interfaces/IOperationsEngine.sol\";\nimport {IInstrumentRegistry} from \"src/interfaces/IInstrumentRegistry.sol\";\n\n/**\n * @title IDealerRegistry\n * @notice Interface for managing dealers within the registry, including adding new dealers,\n * allowing dealers for specific instruments, and checking dealer permissions.\n * @dev Extends both `IBaseRegistry` and `IUserRegistry` for core registry and user management functionality.\n */\ninterface IDealerRegistry is IBaseRegistry, IUserRegistry {\n    /**\n     * @notice Thrown when attempting to add a dealer who is already registered.\n     */\n    error IDealerRegistry_AlreadyADealer();\n\n    /**\n     * @notice Thrown when invalid input parameters are provided.\n     */\n    error IDealerRegistry_InvalidInput();\n\n    /**\n     * @notice Thrown when the specified instrument does not exist in the registry.\n     */\n    error IDealerRegistry_NonExistingInstrument();\n\n    /**\n     * @notice Thrown when the dealer is not allowed for the specified instrument.\n     */\n    error IDealerRegistry_DealerNotAllowed();\n\n    /**\n     * @notice Emited when a new dealer is added\n     * @param dealerId Id of the new dealer\n     * @param wallet Initial wallet of the dealer\n     */\n    event NewDealerAdded(bytes32 dealerId, address wallet);\n\n    /**\n     * @notice Emited when an dealer's allowed status is updated\n     * @param dealerId Id of the dealer updated\n     * @param allowed Y/N if dealer is allowed for the instrument\n     */\n    event dealerAllowedUpdated(bytes32 dealerId, bytes32 instrumentId, bool allowed);\n\n    /**\n     * @notice Initialize the registry\n     * @param _roleRegistry Address of the role registry\n     */\n    function initialize(\n        IRoleRegistry _roleRegistry,\n        IOperationsEngine _operationsEngine,\n        IInvestorRegistry _investorRegistry,\n        IInstrumentRegistry _instrumentRegistry\n    ) external;\n\n    /**\n     * @notice Adds a new dealer to the registry\n     * @param _senderRole Role of the sender which allows the operation execution\n     * @param _dealerId ID of the dealer\n     * @param _wallet Wallet of the dealer\n     */\n    function addDealer(bytes32 _senderRole, bytes32 _dealerId, address _wallet) external;\n\n    /**\n     * @notice Allows a dealer for a specific instrument\n     * @param _senderRole Role of the sender which allows the operation execution\n     * @param _dealerId ID of the dealer\n     * @param _instrumentId ID of the instrument\n     * @param _allowed Y/N if dealer is allowed for the instrument\n     */\n    function allowDealer(bytes32 _senderRole, bytes32 _dealerId, bytes32 _instrumentId, bool _allowed) external;\n\n    /**\n     * @notice Returns if the dealer is allowed for a specific instrument\n     * @param _dealerId ID of the dealer\n     * @param _instrumentId ID of the instrument\n     * @return Bool indicating if dealer if allowed\n     */\n    function isDealerAllowed(bytes32 _dealerId, bytes32 _instrumentId) external view returns (bool);\n\n    /**\n     * @notice Reverts if the dealer is not allowed for a specific instrument\n     * @param _dealerId ID of the dealer\n     * @param _instrumentId ID of the instrument\n     */\n    function checkDealerAllowed(bytes32 _dealerId, bytes32 _instrumentId) external view;\n}\n"
    },
    "src/interfaces/IInstrumentRegistry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {IERC20Metadata} from \"openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport {IBaseRegistry} from \"src/interfaces/IBaseRegistry.sol\";\nimport {IDealerRegistry} from \"src/interfaces/IDealerRegistry.sol\";\nimport {IFundRegistry} from \"src/interfaces/IFundRegistry.sol\";\nimport {IRoleRegistry} from \"src/interfaces/IRoleRegistry.sol\";\nimport {IInvestorRegistry} from \"src/interfaces/IInvestorRegistry.sol\";\nimport {IOperationsEngine} from \"src/interfaces/IOperationsEngine.sol\";\nimport {IEternalRegistryStorage} from \"src/interfaces/IEternalRegistryStorage.sol\";\n\n/**\n * @title IInstrumentRegistry\n * @author Libre\n * @notice Interface for managing instruments within a fund registry system.\n * Provides functionalities to initialize, add, and manage instruments, track their subscription and redemption periods,\n * update Net Asset Value (NAV) per share, and manage investor access.\n */\ninterface IInstrumentRegistry is IBaseRegistry {\n    /**\n     * @notice Thrown when attempting to add an instrument that already exists in the registry.\n     */\n    error IInstrumentRegistry_InstrumentAlreadyExists();\n\n    /**\n     * @notice Thrown when the specified instrument does not exist in the registry.\n     */\n    error IInstrumentRegistry_InstrumentDoesNotExist();\n\n    /**\n     * @notice Thrown when attempting to initialize an instrument that has already been initialized.\n     */\n    error IInstrumentRegistry_InstrumentAlreadyInitialized();\n\n    /**\n     * @notice Emited when a new instrument is added\n     * @param fundId Id of the fund where the instrument is added\n     * @param instrumentId Id of the new instrument\n     */\n    event NewFundInstrumentAdded(bytes32 indexed fundId, bytes32 indexed instrumentId);\n\n    /**\n     * @notice Emited when an instrument is initialized\n     * @param instrumentId Id of the new instrument\n     * @param settlementToken Address of the settlement token of the instrument\n     * @param securityToken Address of the deployed security token\n     * @param subscriptionBook Address of the deployed subscription book\n     * @param redemptionBook Address of the deployed redemption book\n     */\n    event FundInstrumentInitialized(\n        bytes32 indexed instrumentId,\n        address settlementToken,\n        address securityToken,\n        address subscriptionBook,\n        address redemptionBook\n    );\n\n    /**\n     * @notice Emited when an instrument is closed\n     * @param instrumentId Id of the instrument\n     */\n    event InstrumentClosed(bytes32 indexed instrumentId);\n\n    /**\n     * @notice Emited when an instrument is paused\n     * @param instrumentId Id of the instrument\n     * @param paused Y/N value indicating if the instrument is paused or not\n     */\n    event InstrumentPaused(bytes32 indexed instrumentId, bool paused);\n\n    /**\n     * @notice Emited when an investor's allowlist status is updated for an instrument\n     * @param instrumentId Id of the instrument\n     * @param investorId Id of the investor\n     * @param allowed Y/N value indicating if the investor is allowed or not\n     */\n    event InvestorAllowedUpdated(bytes32 indexed instrumentId, bytes32 indexed investorId, bool allowed);\n\n    /**\n     * @notice Initialize the registry\n     * @param _roleRegistry Address of the Role Registry\n     * @param _investorRegistry Address of the Investor Registry\n     * @param _dealerRegistry Address of the Dealer Registry\n     * @param _fundRegistry Address of the Fund Registry\n     * @param _jurisdictionRegistry Address of the Jurisdiction Registry\n     * @param _operationsEngine Address of the Rules Engine\n     */\n    function initialize(\n        IRoleRegistry _roleRegistry,\n        IInvestorRegistry _investorRegistry,\n        IDealerRegistry _dealerRegistry,\n        IFundRegistry _fundRegistry,\n        IEternalRegistryStorage _jurisdictionRegistry,\n        IOperationsEngine _operationsEngine\n    ) external;\n\n    /**\n     * @notice Adds a new fund instrument to the registry\n     * @dev _senderRole is ignored if the caller if the Fund Admin of the instrument\n     * @param _senderRole Role of the sender which allow the operation execution\n     * @param _instrumentId the instrument ID\n     * @param _fundId the fund ID\n     */\n    function addFundInstrument(bytes32 _senderRole, bytes32 _instrumentId, bytes32 _fundId) external;\n\n    /**\n     * @notice Adds a new instrument to the registry\n     * @dev _senderRole is ignored if the caller if the Fund Admin of the instrument\n     * @param _senderRole Role of the sender which allow the operation execution\n     * @param _instrumentId the instrument ID\n     * @param _settlementToken settlement token address\n     * @param _name the instrument token name\n     * @param _symbol the instrument token symbol\n     * @param _subscriptionBookImp The implementation of subscription book to be cloned\n     * @param _redemptionBookImp The implementation of redemption book to be cloned\n     * @param _stTokenImpl The implementation of security token implementation to be cloned\n     * @param _treasury The address of instrument treasury\n     * @param _policyViewerAddress The address of instrument policy viewer\n     */\n    function initializeFundInstrument(\n        bytes32 _senderRole,\n        bytes32 _fundId,\n        bytes32 _instrumentId,\n        address _settlementToken,\n        string memory _name,\n        string memory _symbol,\n        address _subscriptionBookImp,\n        address _redemptionBookImp,\n        address _stTokenImpl,\n        address _treasury,\n        address _policyViewerAddress\n    ) external;\n\n    /**\n     * @notice Close a fund instrument\n     * @param _senderRole Role of the sender which allow the operation execution\n     * @param _instrumentId The ID of the instrument\n     */\n    function closeFundInstrument(bytes32 _senderRole, bytes32 _instrumentId) external;\n\n    /**\n     * @notice Return the number of the current subscription period or\n     * 0 in case subscription is not started or infinite if subscriptions are done\n     * @dev Infinite is represented by type(uint256).max;\n     * @param _instrumentId Id of the instrument\n     * @return The current period of the subscription, the start & the end of it\n     */\n    function currentSubscriptionPeriod(bytes32 _instrumentId) external view returns (uint256, uint256, uint256);\n\n    /**\n     * @notice Return the number of the current redemption period or\n     * 0 in case redemption is not started or infinite if redemptions are done\n     * @param _instrumentId Id of the instrument\n     * @return The current period of the redemption, the start & the end of it\n     */\n    function currentRedemptionPeriod(bytes32 _instrumentId) external view returns (uint256, uint256, uint256);\n\n    /**\n     * @notice Sets a new value for the audited NAV per share of a fund\n     * @param _senderRole Role of the sender which allow the operation execution\n     * @param _instrumentId ID of the fund\n     * @param _newNavPerShare new value of the nav\n     * @dev Expressed with 6 decimals as it is in settlement tokens units\n     */\n    function updateAuditedNavPerShare(bytes32 _senderRole, bytes32 _instrumentId, uint256 _newNavPerShare) external;\n\n    /**\n     * @notice Allow investor for a specific instrument\n     * @param _instrumentId The ID of the instrument\n     * @param _investorId Id of the investor\n     * @param _allowed Y/N value indicating if the investor is allowed or not\n     * @param _senderRole Role of the sender\n     */\n    function allowInvestor(bytes32 _instrumentId, bytes32 _investorId, bool _allowed, bytes32 _senderRole) external;\n}\n"
    },
    "src/interfaces/IOperationsEngine.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {IInvestorRegistry} from \"src/interfaces/IInvestorRegistry.sol\";\nimport {IFundRegistry} from \"src/interfaces/IFundRegistry.sol\";\nimport {IDealerRegistry} from \"src/interfaces/IDealerRegistry.sol\";\nimport {IInstrumentRegistry} from \"src/interfaces/IInstrumentRegistry.sol\";\nimport {IRoleRegistry} from \"src/interfaces/IRoleRegistry.sol\";\nimport {IEternalRegistryStorage} from \"src/interfaces/IEternalRegistryStorage.sol\";\nimport {OPERATIONS} from \"./operations/IOperationModule.sol\";\n\n/**\n * @title Operations Engine Interface\n * @author Libre\n * @notice Defines the interface for managing modules, operations, and dependencies in the system.\n * @dev Includes error definitions, events, and function signatures for interacting with the operations engine.\n */\ninterface IOperationsEngine {\n    // Enums\n    /**\n     * @notice Defines the type of ID for the module check, modules are either tracking ones or check ones.\n     */\n    enum IdType {\n        NULL,\n        INSTRUMENT_CHECK,\n        FEE,\n        TRACKING\n    }\n\n    /**\n     * @notice Defines the type of check a module performs.\n     */\n    enum CHECK_TYPE {\n        BOOLEAN,\n        NUMERIC_MIN,\n        NUMERIC_MAX\n    }\n\n    // Errors\n    /**\n     * @dev Revert when the tracking module reverts for any reason\n     */\n    error IOperationsEngine_TrackingModuleFailure();\n\n    /**\n     * @dev Revert when the fee module reverts for any reason\n     */\n    error IOperationsEngine_FeeModuleFailure();\n\n    /**\n     * @dev Revert when the module address provided is invalid.\n     */\n    error IOperationsEngine_InvalidModuleAddress();\n\n    /**\n     * @dev Revert when the module is not of the Libre type.\n     */\n    error IOperationsEngine_ModuleIsNotLibreType();\n\n    /**\n     * @dev Revert when a lending module cannot be disabled.\n     */\n    error IOperationsEngine_LendingModuleDisable();\n\n    /**\n     * @dev Revert when dependencies required for an operation are missing.\n     */\n    error IOperationsEngine_MissingDependencies();\n\n    /**\n     * @dev Revert when an invalid check type is used.\n     */\n    error IOperationsEngine_InvalidCheckType();\n\n    /**\n     * @dev Revert when the caller is not authorized to perform the action.\n     */\n    error IOperationsEngine_CallerNotAuthorized();\n\n    /**\n     * @dev Revert when adding a module that is already been added.\n     */\n    error IOperationsEngine_ModuleAlreadyAdded();\n\n    /**\n     * @dev Revert when module already enabled for the same instrument.\n     */\n    error IOperationsEngine_ModuleAlreadyEnabled();\n\n    /**\n     * @dev Revert when a module to be disabled for an instrument is not enabled\n     */\n    error IOperationsEngine_ModuleNotEnabled();\n\n    // Events\n    /**\n     * @notice Emitted when a module is added to the available modules library.\n     * @param moduleAddress Address of the module that was added.\n     */\n    event ModuleAdded(address indexed moduleAddress);\n\n    /**\n     * @notice Emitted when a module is removed from the available modules library.\n     * @param moduleAddress Address of the module that was removed.\n     */\n    event ModuleRemoved(address indexed moduleAddress);\n\n    /**\n     * @notice Emitted when a module is enabled for a specific instrument.\n     * @param moduleAddress Address of the module that was enabled.\n     * @param instrumentId Id of the instrument for which the module was enabled.\n     */\n    event ModuleEnabled(address indexed moduleAddress, bytes32 instrumentId);\n\n    /**\n     * @notice Emitted when a module is disabled for a specific instrument.\n     * @param moduleAddress Address of the module that was disabled.\n     * @param instrumentId Id of the instrument for which the module was disabled.\n     */\n    event ModuleDisabled(address indexed moduleAddress, bytes32 instrumentId);\n\n    /**\n     * @dev Event emitted when a fee is applied.\n     * @param instrumentId The ID of the instrument.\n     * @param orderId The ID of the order.\n     * @param feeModule The address of the fee module.\n     * @param feeAmount The amount of the fee applied.\n     */\n    event FeeApplied(bytes32 indexed instrumentId, uint256 orderId, address feeModule, uint256 feeAmount);\n\n    //functions\n\n    /**\n     * @notice Initializes the Rules Engine with necessary registries.\n     * @param _investorRegistry Address of the Investor Registry.\n     * @param _dealerRegistry Address of the Dealer Registry.\n     * @param _fundRegistry Address of the Fund Registry.\n     * @param _instrumentRegistry Address of the Instrument Registry.\n     * @param _roleRegistry Address of the Role Registry.\n     * @param _jurisdictionRegistry Address of the Jurisdiction Registry.\n     */\n    function initialize(\n        IInvestorRegistry _investorRegistry,\n        IDealerRegistry _dealerRegistry,\n        IFundRegistry _fundRegistry,\n        IInstrumentRegistry _instrumentRegistry,\n        IRoleRegistry _roleRegistry,\n        IEternalRegistryStorage _jurisdictionRegistry\n    ) external;\n\n    /**\n     * @notice Gets the addresses for registered check modules implementing the given operation.\n     * @param _id Id of the dealer or instrument the modules belong to.\n     * @param _operation Operation implemented in modules.\n     * @return An array of addresses of modules implementing the given operation.\n     */\n    function getCheckModules(bytes32 _id, OPERATIONS _operation) external view returns (address[] memory);\n\n    /**\n     * @notice Gets the addresses for registered fee modules implementing the given operation.\n     * @param _id Id of the dealer or instrument the modules belong to.\n     * @param _operation Operation implemented in modules.\n     * @return An array of addresses of modules implementing the given operation.\n     */\n    function getFeeModules(bytes32 _id, OPERATIONS _operation) external view returns (address[] memory);\n\n    /**\n     * @notice Gets the addresses for registered tracking modules implementing the given operation.\n     * @param _id Id of the dealer or instrument the modules belong to.\n     * @param _operation Operation implemented in modules.\n     * @return An array of addresses of modules implementing the given operation.\n     */\n    function getTrackingModules(bytes32 _id, OPERATIONS _operation) external view returns (address[] memory);\n\n    /**\n     * @notice Adds a module to the available modules library.\n     * @param _moduleAddress Address of the module to add.\n     * @param _role Role required to add the module.\n     * @param _idType Type of the module.\n     */\n    function addModule(address _moduleAddress, bytes32 _role, IdType _idType) external;\n\n    /**\n     * @notice Removes a module from the available modules library.\n     * @param _moduleAddress Address of the module to remove.\n     * @param _role Role required to remove the module.\n     */\n    function removeModule(address _moduleAddress, bytes32 _role) external;\n\n    /**\n     * @notice Enables a module for a specific instrument.\n     * @param _moduleAddress Address of the module to enable.\n     * @param _instrumentId Id of the instrument.\n     * @param _role Role required to enable the module.\n     */\n    function enableModule(address _moduleAddress, bytes32 _instrumentId, bytes32 _role) external;\n\n    /**\n     * @notice Disables a module for a specific instrument.\n     * @param _moduleAddress Address of the module to disable.\n     * @param _instrumentId Id of the instrument.\n     * @param _role Role required to disable the module.\n     * @dev Lending modules cannot be disabled, because at least one module must be enabled at all times.\n     * Instead, the lending module can be replaced with another lending module by enabling the new module.\n     */\n    function disableModule(address _moduleAddress, bytes32 _instrumentId, bytes32 _role) external;\n\n    /**\n     * @notice Checks if a module is available in the available modules library.\n     * @param _moduleAddress Address of the module to check.\n     * @return True if the module is available, false otherwise.\n     */\n    function isAvailableModule(address _moduleAddress) external view returns (bool);\n\n    /**\n     * @notice Checks if a module is enabled for a specific instrument.\n     * @param _id Id of the instrument.\n     * @param _moduleName Hash of the abi.encodePacked of the module name\n     * @return True if the module is enabled, false otherwise.\n     */\n    function hasModuleEnabled(bytes32 _id, bytes32 _moduleName) external view returns (bool);\n\n    /**\n     * @notice Function to be delegatecalled by the registry to perform the check\n     * @param _operation The operation to be checked\n     * @param _id The id of the operation\n     * @param _data Arbitrary data that can be used by the module to perform the check\n     * @return result memory Result of the check\n     */\n    function check(OPERATIONS _operation, bytes32 _id, bytes calldata _data) external returns (bytes memory result);\n\n    /**\n     * @notice Tracks the operation\n     * @param _operation The operation to track\n     * @param _id The id of the instrument or investor\n     * @param _data The data to track\n     * @return True if the tracking was successful, false otherwise\n     */\n    function track(OPERATIONS _operation, bytes32 _id, bytes memory _data) external returns (bool);\n\n    /**\n     * @notice Calculates the total fee amount to be deducted for a given operation and instrument.\n     * @dev Loops through all enabled fee modules for the given operation and instrument, calls them with the input data,\n     *      and sums up the returned fee amounts. Also emits `FeeApplied` events for each individual module fee.\n     *\n     * @param _operation The operation type (e.g., SETTLE_SUBSCRIPTION_PER_ORDER).\n     * @param _id The instrument ID for which the fees are being calculated.\n     * @param _data ABI-encoded parameters required for fee calculation. Must encode the following values in order:\n     *        - `uint256 _orderId`: Unique identifier of the order\n     *        - `bytes32 _investorId`: The ID of the investor associated with the order\n     *        - `uint256 _amountToSettle`: The current amount to be settled\n     *\n     * @return totalFee The total fee amount to be deducted across all enabled fee modules.\n     */\n    function calculateFees(OPERATIONS _operation, bytes32 _id, bytes memory _data)\n        external\n        returns (uint256 totalFee);\n}\n"
    },
    "src/interfaces/IOrderPipeline.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {ISecurityToken} from \"./ISecurityToken.sol\";\nimport {ISettlementToken} from \"./ISettlementToken.sol\";\nimport {IInstrumentRegistry} from \"./IInstrumentRegistry.sol\";\nimport {IInvestorRegistry} from \"./IInvestorRegistry.sol\";\nimport {IDealerRegistry} from \"./IDealerRegistry.sol\";\nimport {IOperationsEngine} from \"./IOperationsEngine.sol\";\n\nstruct OrderDetails {\n    uint128 settledAmount; // The amount of tokens already settled.\n    uint128 amount; // The amount involved in the order.\n    uint32 timestamp; // The timestamp when the order was created or last updated.\n    uint32 executionTimestamp; // The timestamp of the order's execution.\n    address beneficiary; // The address that will benefit from the order.\n    address sender; // The address that initiated the order.\n    bytes32 investorId; // The unique ID of the investor associated with the order.\n}\n\n/**\n * @dev Context struct to hold frequently accessed storage variables in memory\n * to avoid repeated SLOADs across SubscriptionBook and RedemptionBook.\n * This struct is used to optimize gas usage by caching storage variables that are accessed multiple times\n * within a single transaction. Variables that are only used once should be accessed directly from storage\n * to avoid unnecessary memory operations.\n */\nstruct Context {\n    bytes32 instrumentId;\n    IOperationsEngine operationsEngine;\n    IInstrumentRegistry instrumentRegistry;\n    IInvestorRegistry investorRegistry;\n    ISettlementToken settlementToken;\n    ISecurityToken securityToken;\n}\n\n/**\n * @title Order Pipeline Interface\n * @author Libre\n * @notice Interface for managing order-related operations in the system.\n * @dev Defines errors, events, and function signatures for order processing.\n */\ninterface IOrderPipeline {\n    // Errors\n    /**\n     * @dev Revert when an unauthorized action is attempted.\n     */\n    error IOrderPipeline_Unauthorized();\n\n    /**\n     * @dev Revert when the beneficiary is not the expected investor.\n     */\n    error IOrderPipeline_BeneficiaryIsNotInvestor();\n\n    /**\n     * @dev Revert when the provided amount is insufficient.\n     */\n    error IOrderPipeline_InsufficientAmount();\n\n    /**\n     * @dev Revert when the instrument is already closed.\n     */\n    error IOrderPipeline_InstrumentClosed();\n\n    /**\n     * @dev Revert when the order with the given ID is not found.\n     */\n    error IOrderPipeline_OrderNotFound();\n\n    /**\n     * @dev Revert when the provided percentage is invalid.\n     */\n    error IOrderPipeline_PercentageNotApt();\n\n    /**\n     * @dev Revert when the order cannot be locked.\n     */\n    error IOrderPipeline_OrderCannotBeLocked();\n\n    /**\n     * @dev Revert when the wrong investor is referenced.\n     */\n    error IOrderPipeline_WrongInvestor();\n\n    /**\n     * @dev Revert when no investor wallets are available.\n     */\n    error IOrderPipeline_NoInvestorWallets();\n\n    /**\n     * @dev Revert when the order is not locked.\n     */\n    error IOrderPipeline_OrderNotLocked();\n\n    /**\n     * @dev Revert when the order is already settled in the current round.\n     */\n    error IOrderPipeline_OrderAlreadySettledInCurrentRound();\n\n    /**\n     * @dev Revert when the order cannot be confirmed.\n     */\n    error IOrderPipeline_OrderCannotBeConfirmed();\n\n    /**\n     * @dev Revert when the settlement token transfer fails.\n     */\n    error IOrderPipeline_SettlementTokenTransferFailed();\n\n    /**\n     * @dev Revert when the security token transfer fails.\n     */\n    error IOrderPipeline_SecurityTokenTransferFailed();\n\n    /**\n     * @dev Revert when settlement is already executed.\n     */\n    error IOrderPipeline_SettlementAlreadyExecuted();\n\n    /**\n     * @dev Revert when there is a mismatch in the instrument ID proof.\n     */\n    error IOrderPipeline_InstrumentIdProofMismatch();\n\n    /**\n     * @dev Revert when there is a mismatch in the investor ID proof.\n     */\n    error IOrderPipeline_InvestorIdProofMismatch();\n\n    /**\n     * @dev Revert when there is a mismatch in the policy viewer proof.\n     */\n    error IOrderPipeline_PolicyViewerProofMismatch();\n\n    /**\n     * @dev Revert when the wallet used in the order details is blacklisted.\n     */\n    error IOrderPipeline_WalletBlacklisted();\n\n    /**\n     * @dev Revert if the period is decreasing\n     */\n    error IOrderPipeline_PeriodDecreasing();\n\n    /**\n     * @dev Revert when the instrument is paused.\n     */\n    error IOrderPipeline_InstrumentPaused();\n\n    /**\n     * @notice Used when orders are cancelled\n     * @param orderId Id of the cancelled order\n     * @param amount Numeric value to identify the cancelled order amount\n     */\n    event OrderCancelled(uint256 orderId, uint256 amount);\n\n    /**\n     * @notice Used when orders are settled\n     * @param orderId Id of the settled order\n     * @param amount Amount settled\n     */\n    event OrderSettled(uint256 orderId, uint256 amount);\n\n    /// @dev Emitted when an order is created.\n    event OrderCreated(uint256 orderId, bytes32 investorId, uint256 amount, address initiator);\n\n    /**\n     * @notice Emitted when an order is skipped during settlement.\n     * @param orderId The ID of the skipped order.\n     * @param errorMsg The error message explaining why the order was skipped.\n     */\n    event OrderSettlementSkipped(uint256 orderId, string errorMsg);\n\n    /**\n     * @notice Settles a batch of orders for the current period.\n     * @param _lastOrderId The ID of the last order in the settlement batch.\n     * @param _percentageToSettle The percentage of each order amount to settle.\n     */\n    function settleOrders(uint256 _lastOrderId, uint256 _percentageToSettle, bytes32 _role) external;\n\n    /**\n     * @notice Retrieves the total number of orders created.\n     * @return The total count of orders.\n     */\n    function getTotalOrdersCount() external view returns (uint256);\n\n    /**\n     * @notice Retrieves the next order ID to be settled.\n     * @return The next order ID for settlement.\n     */\n    function getNextOrderToSettle() external view returns (uint256);\n\n    /**\n     * @notice Retrieves the list of all active order IDs.\n     * @return An array containing all active order IDs.\n     */\n    function getActiveOrderIds() external view returns (uint256[] memory);\n\n    /**\n     * @notice Get all details of an order\n     * @return Order details\n     */\n    function getOrder(uint256 _orderId) external view returns (OrderDetails memory);\n}\n"
    },
    "src/interfaces/operations/IOperationModule.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {IInvestorRegistry} from \"src/interfaces/IInvestorRegistry.sol\";\nimport {IFundRegistry} from \"src/interfaces/IFundRegistry.sol\";\nimport {IDealerRegistry} from \"src/interfaces/IDealerRegistry.sol\";\nimport {IInstrumentRegistry} from \"src/interfaces/IInstrumentRegistry.sol\";\nimport {IEternalRegistryStorage} from \"src/interfaces/IEternalRegistryStorage.sol\";\nimport {IRoleRegistry} from \"src/interfaces/IRoleRegistry.sol\";\n\nenum OPERATIONS {\n    // Transfer specific operations:\n    TRANSFER,\n    FORCED_TRANSFER,\n    RECEIVE,\n    SEND,\n    CLAWBACK,\n    // Subscription specific operations:\n    ADVISED_CREATE_SUBSCRIPTION,\n    CREATE_SUBSCRIPTION,\n    SUBSCRIPTION_EXECUTION_DATE_CALCULATION,\n    SETTLE_SUBSCRIPTIONS,\n    SETTLE_SUBSCRIPTION_PER_ORDER,\n    SUBSCRIPTION_CANCELLATION,\n    // Redemption specific operations:\n    ADVISED_CREATE_REDEMPTION,\n    CREATE_REDEMPTION,\n    REDEMPTION_EXECUTION_DATE_CALCULATION,\n    REDEMPTION_CANCELLATION,\n    SETTLE_REDEMPTIONS,\n    SETTLE_REDEMPTION_PER_ORDER,\n    FORCED_REDEMPTION,\n    REDEMPTION_FEE,\n    // Secondary Market specific operations:\n    FILL,\n    ORDER,\n    TRADE,\n    // NAV operations:\n    UPDATE_AUDITED_NAV_PER_SHARE\n}\n\ninterface IOperationModule {\n    /**\n     * @return The list of operations associated with a module\n     * @dev It should contains all the Operation ids of all\n     * the IOperations it implements\n     */\n    function getOperations() external pure returns (OPERATIONS[] memory);\n\n    /**\n     * @return Returns the name of the module\n     */\n    function name() external pure returns (string memory);\n\n    /**\n     * @return Returns the hash of the module name\n     */\n    function nameHash() external pure returns (bytes32);\n}\n"
    },
    "src/utils/Constant.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.28;\n\nimport \"src/utils/JurisdictionEncodings.sol\";\nimport \"src/utils/Types.sol\";\n\n// General Config\nbytes32 constant TIMEZONE = keccak256(\"TIMEZONE\");\nbytes32 constant MAX_TIMEZONE = keccak256(\"MAX_TIMEZONE\");\n\n// Chain/Gateway Config\nuint16 constant NATIVE_CHAIN_SELECTOR = 101;\n\n// NAV\nbytes32 constant AUDITED_NAV_PER_SHARE = keccak256(\"AUDITED_NAV_PER_SHARE\");\nbytes32 constant INSTRUMENT_ALLOWED_ADDRESSES = keccak256(\"INSTRUMENT_ALLOWED_ADDRESSES\");\n\n// Volatility\nbytes32 constant ANNUALIZED_VOLATILITY = keccak256(\"ANNUALIZED_VOLATILITY\");\n\n// Subscription Config\nbytes32 constant SUBSCRIPTION_PHASES = keccak256(\"SUBSCRIPTION_PHASES\");\nbytes32 constant SUBSCRIPTION_START = keccak256(\"SUBSCRIPTION_START\");\nbytes32 constant SUBSCRIPTION_END = keccak256(\"SUBSCRIPTION_END\");\nbytes32 constant SUBSCRIPTION_FREQUENCY = keccak256(\"SUBSCRIPTION_FREQUENCY\");\nbytes32 constant SUBSCRIPTION_FREQUENCY_TIME_UNIT = keccak256(\"SUBSCRIPTION_FREQUENCY_TIME_UNIT\");\n\n// Redemption Config\nbytes32 constant REDEMPTION_START = keccak256(\"REDEMPTION_START\");\nbytes32 constant REDEMPTION_END = keccak256(\"REDEMPTION_END\");\nbytes32 constant REDEMPTION_FREQUENCY = keccak256(\"REDEMPTION_FREQUENCY\");\nbytes32 constant REDEMPTION_FREQUENCY_TIME_UNIT = keccak256(\"REDEMPTION_FREQUENCY_TIME_UNIT\");\n\n// Fund data\nbytes32 constant FUND_ID = keccak256(\"FUND_ID\");\nbytes32 constant DISCLOSURE_DOCUMENTS = keccak256(\"DISCLOSURE_DOCUMENTS\");\nbytes32 constant LISTED_ON_REGULATED_VENUE = keccak256(\"LISTED_ON_REGULATED_VENUE\");\nbytes32 constant LOCAL_AIFM = keccak256(\"LOCAL_AIFM\");\nbytes32 constant NON_EU_AIFM = keccak256(\"NON_EU_AIFM\");\n\n// Fund Instruments data\nbytes32 constant INSTRUMENT_TOKEN = keccak256(\"INSTRUMENT_TOKEN\");\nbytes32 constant LOCAL_INVESTOR_MINIMUM_HOLDING = keccak256(\"LOCAL_INVESTOR_MINIMUM_HOLDING\");\nbytes32 constant AGGREGATED_MINIMUM_REDEMPTION_VALUE = keccak256(\"AGGREGATED_MINIMUM_REDEMPTION_VALUE\");\nbytes32 constant AGGREGATED_MINIMUM_SUBSEQUENT_SUBSCRIPTION = keccak256(\"AGGREGATED_MINIMUM_SUBSEQUENT_SUBSCRIPTION\");\nbytes32 constant INVESTOR_MINIMUM_INITIAL_SUBSCRIPTION = keccak256(\"INVESTOR_MINIMUM_INITIAL_SUBSCRIPTION\");\nbytes32 constant INVESTOR_MINIMUM_SUBSEQUENT_SUBSCRIPTION = keccak256(\"INVESTOR_MINIMUM_SUBSEQUENT_SUBSCRIPTION\");\nbytes32 constant REDEMPTION_BOOK = keccak256(\"REDEMPTION_BOOK\");\nbytes32 constant SUBSCRIPTION_BOOK = keccak256(\"SUBSCRIPTION_BOOK\");\n\n// Subscription Cutoff\nbytes32 constant SUBSCRIPTION_CUT_OFF_CALENDAR_DAYS = keccak256(\"SUBSCRIPTION_CUT_OFF_CALENDAR_DAYS\");\nbytes32 constant SUBSCRIPTION_CUT_OFF_BUSINESS_DAYS = keccak256(\"SUBSCRIPTION_CUT_OFF_BUSINESS_DAYS\");\nbytes32 constant SUBSCRIPTION_CUT_OFF_TIME = keccak256(\"SUBSCRIPTION_CUT_OFF_TIME\");\nbytes32 constant SUBSCRIPTION_CUT_OFF_PERIOD = keccak256(\"SUBSCRIPTION_CUT_OFF_PERIOD\");\n\nbytes32 constant LOCAL_AGGREGATE_MINIMUM_HOLDING = keccak256(\"LOCAL_AGGREGATE_MINIMUM_HOLDING\");\nbytes32 constant SUBSCRIPTION_SIZE_MULTIPLE = keccak256(\"SUBSCRIPTION_SIZE_MULTIPLE\");\nbytes32 constant GLOBAL_AGGREGATE_MINIMUM_BREACH = keccak256(\"GLOBAL_AGGREGATE_MINIMUM_BREACH\");\nbytes32 constant FORCED_REDEMPTION_TOP_UP_PERIOD = keccak256(\"FORCED_REDEMPTION_TOP_UP_PERIOD\");\nbytes32 constant FORCED_REDEMPTION_TOP_UP_PERIOD_UNIT = keccak256(\"FORCED_REDEMPTION_TOP_UP_PERIOD_UNIT\");\nbytes32 constant REDEMPTION_VOLUME_LIMIT = keccak256(\"REDEMPTION_VOLUME_LIMIT\");\nbytes32 constant REDEMPTION_VOLUME_LIMIT_PER_INVESTOR = keccak256(\"REDEMPTION_VOLUME_LIMIT_PER_INVESTOR\");\nbytes32 constant REDEMPTION_VOLUME_LIMIT_PER_INVESTOR_FEE = keccak256(\"REDEMPTION_VOLUME_LIMIT_PER_INVESTOR_FEE\");\nbytes32 constant REDEMPTION_LOOKBACK_PERIOD = keccak256(\"REDEMPTION_LOOKBACK_PERIOD\");\nbytes32 constant REDEMPTION_LOOKBACK_PERIOD_UNIT = keccak256(\"REDEMPTION_LOOKBACK_PERIOD_UNIT\");\nbytes32 constant GATE_CRITERIA_1 = keccak256(\"GATE_CRITERIA_1\");\nbytes32 constant REDEMPTION_NOTICE_PERIOD = keccak256(\"REDEMPTION_NOTICE_PERIOD\");\nbytes32 constant REDEMPTION_NOTICE_PERIOD_UNIT = keccak256(\"REDEMPTION_NOTICE_PERIOD_UNIT\");\nbytes32 constant REDEMPTION_CUT_OFF_PERIOD = keccak256(\"REDEMPTION_CUT_OFF_PERIOD\");\n// Calendar\nbytes32 constant BUSINESS_DAY_BITMAP_PART_1 = keccak256(\"BUSINESS_DAY_BITMAP_PART_1\");\nbytes32 constant BUSINESS_DAY_BITMAP_PART_2 = keccak256(\"BUSINESS_DAY_BITMAP_PART_2\");\n\n// Redemption Cutoff\nbytes32 constant REDEMPTION_CUT_OFF_CALENDAR_DAYS = keccak256(\"REDEMPTION_CUT_OFF_CALENDAR_DAYS\");\nbytes32 constant REDEMPTION_CUT_OFF_BUSINESS_DAYS = keccak256(\"REDEMPTION_CUT_OFF_BUSINESS_DAYS\");\nbytes32 constant REDEMPTION_CUT_OFF_TIME = keccak256(\"REDEMPTION_CUT_OFF_TIME\");\n\n// Execution Date\nbytes32 constant SUBSCRIPTION_NOTICE_PERIOD_CALENDAR_MONTHS = keccak256(\"SUBSCRIPTION_NOTICE_PERIOD_CALENDAR_MONTHS\");\nbytes32 constant SUBSCRIPTION_NOTICE_PERIOD_CALENDAR_DAYS = keccak256(\"SUBSCRIPTION_NOTICE_PERIOD_CALENDAR_DAYS\");\nbytes32 constant SUBSCRIPTION_NOTICE_PERIOD_BUSINESS_DAYS = keccak256(\"SUBSCRIPTION_NOTICE_PERIOD_BUSINESS_DAYS\");\nbytes32 constant SUBSCRIPTION_CUTOFF_TIME = keccak256(\"SUBSCRIPTION_CUTOFF_TIME\");\nbytes32 constant WAIVE_SUBSCRIPTION_NOTICE_PERIOD = keccak256(\"WAIVE_SUBSCRIPTION_NOTICE_PERIOD\");\nbytes32 constant SUBSCRIPTION_PREADJUSTMENT_DEALING_DAY_OF_MONTH =\n    keccak256(\"SUBSCRIPTION_PREADJUSTMENT_DEALING_DAY_OF_MONTH\");\nbytes32 constant REDEMPTION_NOTICE_PERIOD_CALENDAR_MONTHS = keccak256(\"REDEMPTION_NOTICE_PERIOD_CALENDAR_MONTHS\");\nbytes32 constant REDEMPTION_NOTICE_PERIOD_CALENDAR_DAYS = keccak256(\"REDEMPTION_NOTICE_PERIOD_CALENDAR_DAYS\");\nbytes32 constant REDEMPTION_NOTICE_PERIOD_BUSINESS_DAYS = keccak256(\"REDEMPTION_NOTICE_PERIOD_BUSINESS_DAYS\");\nbytes32 constant REDEMPTION_CUTOFF_TIME = keccak256(\"REDEMPTION_CUTOFF_TIME\");\nbytes32 constant WAIVE_REDEMPTION_NOTICE_PERIOD = keccak256(\"WAIVE_REDEMPTION_NOTICE_PERIOD\");\nbytes32 constant REDEMPTION_PREADJUSTMENT_DEALING_DAY_OF_MONTH =\n    keccak256(\"REDEMPTION_PREADJUSTMENT_DEALING_DAY_OF_MONTH\");\n\n// Redemption Holding Intervals\nbytes32 constant REDEMPTION_FIRST_UNLOCK_PERIOD = keccak256(\"REDEMPTION_FIRST_UNLOCK_PERIOD\");\nbytes32 constant REDEMPTION_SECOND_UNLOCK_PERIOD = keccak256(\"REDEMPTION_SECOND_UNLOCK_PERIOD\");\n\nbytes32 constant CUMULATIVE_REDEMPTION_PERIOD = keccak256(\"CUMULATIVE_REDEMPTION_PERIOD\");\nbytes32 constant CUMULATIVE_REDEMPTION_PERIOD_UNIT = keccak256(\"CUMULATIVE_REDEMPTION_PERIOD_UNIT\");\nbytes32 constant CUMULATIVE_REDEMPTION_LIMIT_FEE = keccak256(\"CUMULATIVE_REDEMPTION_LIMIT_FEE\");\nbytes32 constant CUMULATIVE_REDEMPTION_LIMIT_ALLOWANCE = keccak256(\"CUMULATIVE_REDEMPTION_LIMIT_ALLOWANCE\");\nbytes32 constant CUMULATIVE_REDEMPTION_LIMIT_PER_INVESTOR_ALLOWANCE =\n    keccak256(\"CUMULATIVE_REDEMPTION_LIMIT_PER_INVESTOR_ALLOWANCE\");\nbytes32 constant CUMULATIVE_REDEMPTION_LIMIT_PER_INVESTOR_FEE =\n    keccak256(\"CUMULATIVE_REDEMPTION_LIMIT_PER_INVESTOR_FEE\");\nbytes32 constant INITIAL_REDEMPTION_RESTRICTED_PERIOD = keccak256(\"INITIAL_REDEMPTION_RESTRICTED_PERIOD\");\nbytes32 constant INITIAL_SUBSCRIPTION_RESTRICTED_PERIOD = keccak256(\"INITIAL_SUBSCRIPTION_RESTRICTED_PERIOD\");\nbytes32 constant INITIAL_SUBSCRIPTION_RESTRICTED_PERIOD_UNIT = keccak256(\"INITIAL_SUBSCRIPTION_RESTRICTED_PERIOD_UNIT\");\nbytes32 constant INITIAL_SUBSCRIPTION_RESTRICTED_PERIOD_ALLOWANCE =\n    keccak256(\"INITIAL_SUBSCRIPTION_RESTRICTED_PERIOD_ALLOWANCE\");\nbytes32 constant INITIAL_SUBSCRIPTION_RESTRICTED_PERIOD_FEE = keccak256(\"INITIAL_SUBSCRIPTION_RESTRICTED_PERIOD_FEE\");\nbytes32 constant INITIAL_REDEMPTION_RESTRICTED_PERIOD_ALLOWANCE =\n    keccak256(\"INITIAL_REDEMPTION_RESTRICTED_PERIOD_ALLOWANCE\");\nbytes32 constant POST_SUBSCRIPTION_RESTRICTED_PERIOD_ALLOWANCE =\n    keccak256(\"POST_SUBSCRIPTION_RESTRICTED_PERIOD_ALLOWANCE\");\nbytes32 constant POST_SUBSCRIPTION_RESTRICTED_PERIOD_FEE = keccak256(\"POST_SUBSCRIPTION_RESTRICTED_PERIOD_FEE\");\nbytes32 constant INITIAL_REDEMPTION_RESTRICTED_PERIOD_FEE = keccak256(\"INITIAL_REDEMPTION_RESTRICTED_PERIOD_FEE\");\nbytes32 constant POST_REDEMPTION_RESTRICTED_PERIOD_ALLOWANCE = keccak256(\"POST_REDEMPTION_RESTRICTED_PERIOD_ALLOWANCE\");\nbytes32 constant POST_REDEMPTION_RESTRICTED_PERIOD_FEE = keccak256(\"POST_REDEMPTION_RESTRICTED_PERIOD_FEE\");\nbytes32 constant GLOBAL_AGGREGATE_MINIMUM_HOLDING = keccak256(\"GLOBAL_AGGREGATE_MINIMUM_HOLDING\");\nbytes32 constant BLOCKED = keccak256(\"BLOCKED\");\nbytes32 constant RESIDENCES_ALLOWED = keccak256(\"RESIDENCES_ALLOWED\");\nbytes32 constant NATIONALITIES_ALLOWED = keccak256(\"NATIONALITIES_ALLOWED\");\nbytes32 constant INVESTOR_TYPES_ALLOWED = keccak256(\"INVESTOR_TYPES_ALLOWED\");\nbytes32 constant ESTIMATED_REDEMPTION_FEE = keccak256(\"ESTIMATED_REDEMPTION_FEE\");\nbytes32 constant IS_INVESTOR_ALLOWED = keccak256(\"IS_INVESTOR_ALLOWED\");\nbytes32 constant HOLDING_FEE = keccak256(\"HOLDING_FEE\");\nbytes32 constant HOLDING_FEE_PERIOD = keccak256(\"HOLDING_FEE_PERIOD\");\nbytes32 constant HOLDING_FEE_PERIOD_UNIT = keccak256(\"HOLDING_FEE_PERIOD_UNIT\");\n\n// Investors data\nbytes32 constant INVESTOR_TYPE = keccak256(\"INVESTOR_TYPE\");\nbytes32 constant MAX_INVESTOR_TYPE = keccak256(\"MAX_INVESTOR_TYPE\");\nbytes32 constant NATIONALITIES = keccak256(\"NATIONALITIES\");\nbytes32 constant REVIEW_DATE = keccak256(\"REVIEW_DATE\");\nbytes32 constant KYC_PASSED = keccak256(\"KYC_PASSED\");\nbytes32 constant AML_PASSED = keccak256(\"AML_PASSED\");\nbytes32 constant SANCTIONS_PASSED = keccak256(\"SANCTIONS_PASSED\");\nbytes32 constant SELF_CERTIFICATION = keccak256(\"SELF_CERTIFICATION\");\nbytes32 constant FITNESS_TEST = keccak256(\"FITNESS_TEST\");\nbytes32 constant FROZEN = keccak256(\"FROZEN\");\nbytes32 constant USA_STATE = keccak256(\"USA_STATE\");\nbytes32 constant ALLOWED_TO_INTERACT_DAY = keccak256(\"ALLOWED_TO_INTERACT_DAY\");\nbytes32 constant DEALER = keccak256(\"DEALER\");\nbytes32 constant REVERSE_ENQUIRY = keccak256(\"REVERSE_ENQUIRY\");\n\n// Jurisdictions data\nbytes32 constant JURISDICTION_ALLOWED = keccak256(\"JURISDICTION_ALLOWED\");\nbytes32 constant INVESTOR_ALLOWLISTED_REQUIRED = keccak256(\"INVESTOR_ALLOWLISTED_REQUIRED\");\nbytes32 constant SELF_CERTIFICATION_REQUIRED = keccak256(\"SELF_CERTIFICATION_REQUIRED\");\nbytes32 constant FITNESS_TEST_REQUIRED = keccak256(\"FITNESS_TEST_REQUIRED\");\nbytes32 constant DISCLOSURE_DOCUMENTS_REQUIRED = keccak256(\"DISCLOSURE_DOCUMENTS_REQUIRED\");\nbytes32 constant LISTED_ON_REGULATED_VENUE_REQUIRED = keccak256(\"LISTED_ON_REGULATED_VENUE_REQUIRED\");\nbytes32 constant LOCAL_AIFM_REQUIRED = keccak256(\"LOCAL_AIFM_REQUIRED\");\nbytes32 constant NON_EU_AIFM_REQUIRED = keccak256(\"NON_EU_AIFM_REQUIRED\");\nbytes32 constant MINIMUM_INVESTMENT_REQUIRED = keccak256(\"MINIMUM_INVESTMENT_REQUIRED\");\nbytes32 constant MINIMUM_INVESTMENT = keccak256(\"MINIMUM_INVESTMENT\");\nbytes32 constant NO_MINIMUM_INVESTMENT_HOLDER_NUMBER = keccak256(\"NO_MINIMUM_INVESTMENT_HOLDER_NUMBER\");\n\n// Registries\nbytes32 constant GENERAL_DATA_ID = bytes32(0);\nbytes32 constant ETERNAL_STORAGE_SLOT = keccak256(\"ETERNAL_STORAGE_SLOT\");\nbytes32 constant BLACKLISTED_WALLET = keccak256(\"BLACKLISTED_WALLET\");\n\n// Tracking\nbytes32 constant CURRENT_SUBSCRIPTIONS_AMOUNT = keccak256(\"CURRENT_SUBSCRIPTIONS_AMOUNT\");\nbytes32 constant INVESTOR_SUBSCRIPTION_AMOUNT = keccak256(\"INVESTOR_SUBSCRIPTION_AMOUNT\");\nbytes32 constant CURRENT_REDEMPTIONS_AMOUNT = keccak256(\"CURRENT_REDEMPTIONS_AMOUNT\");\nbytes32 constant INVESTOR_REDEMPTION_AMOUNT = keccak256(\"INVESTOR_REDEMPTION_AMOUNT\");\nbytes32 constant REDEMPTION_RECORDS = keccak256(\"REDEMPTION_RECORDS\");\nbytes32 constant REDEMPTION_RECORDS_COUNT = keccak256(\"REDEMPTION_RECORDS_COUNT\");\nbytes32 constant REDEMPTION_RECORDS_AGGREGATE = keccak256(\"REDEMPTION_RECORDS_AGGREGATE\");\nbytes32 constant REDEMPTION_RECORDS_TIMESTAMP = keccak256(\"REDEMPTION_RECORDS_TIMESTAMP\");\nbytes32 constant HOLDING_FEE_EXEMPTION_CREDITS = keccak256(\"HOLDING_FEE_EXEMPTION_CREDITS\");\nbytes32 constant HOLDING_FEE_EXEMPTION_CREDITS_START = keccak256(\"HOLDING_FEE_EXEMPTION_CREDITS_START\");\nbytes32 constant HOLDING_FEE_EXEMPTION_CREDITS_COUNT = keccak256(\"HOLDING_FEE_EXEMPTION_CREDITS_COUNT\");\nbytes32 constant HOLDING_FEE_EXEMPTION_CREDITS_AMOUNT = keccak256(\"HOLDING_FEE_EXEMPTION_CREDITS_AMOUNT\");\nbytes32 constant HOLDING_FEE_EXEMPTION_CREDITS_TIMESTAMP = keccak256(\"HOLDING_FEE_EXEMPTION_CREDITS_TIMESTAMP\");\n\n// Tracking (Holding Intervals)\nbytes32 constant HOLDING_TIME_CREDITS = keccak256(\"HOLDING_TIME_CREDITS\");\nbytes32 constant HOLDING_TIME_CREDITS_START = keccak256(\"HOLDING_TIME_CREDITS_START\");\nbytes32 constant HOLDING_TIME_CREDITS_COUNT = keccak256(\"HOLDING_TIME_CREDITS_COUNT\");\nbytes32 constant HOLDING_TIME_CREDITS_TIMESTAMP = keccak256(\"HOLDING_TIME_CREDITS_TIMESTAMP\");\n\nbytes32 constant HOLDING_CREDITS_FIRST_PERIOD = keccak256(\"HOLDING_CREDITS_FIRST_PERIOD\"); // related to REDEMPTION_FIRST_UNLOCK_PERIOD\nbytes32 constant HOLDING_CREDITS_SECOND_PERIOD = keccak256(\"HOLDING_CREDITS_SECOND_PERIOD\"); // related to REDEMPTION_SECOND_UNLOCK_PERIOD\n\nbytes32 constant HOLDING_PERCENTAGE_FIRST_PERIOD = keccak256(\"HOLDING_PERCENTAGE_FIRST_PERIOD\");\nbytes32 constant HOLDING_PERCENTAGE_SECOND_PERIOD = keccak256(\"HOLDING_PERCENTAGE_SECOND_PERIOD\");\n\n// Tracking (NAV Track Module)\nbytes32 constant NAV_NUM_CHECKPOINTS = keccak256(\"NAV_NUM_CHECKPOINTS\");\nbytes32 constant NAV_CHECKPOINT = keccak256(\"NAV_CHECKPOINT\");\nbytes32 constant NAV_CHECKPOINT_TIMESTAMP = keccak256(\"NAV_CHECKPOINT_TIMESTAMP\");\n\n// Security Token Track (Per investor)\nbytes32 constant SECURITY_TOKEN_NUM_CHECKPOINTS = keccak256(\"SECURITY_TOKEN_NUM_CHECKPOINTS\");\nbytes32 constant SECURITY_TOKEN_CHECKPOINT_TIMESTAMP = keccak256(\"SECURITY_TOKEN_CHECKPOINT_TIMESTAMP\");\nbytes32 constant SECURITY_TOKEN_CHECKPOINTS = keccak256(\"SECURITY_TOKEN_CHECKPOINTS\");\n\n// Investor Registry\nbytes32 constant IS_INVESTOR = keccak256(\"IS_INVESTOR\");\nbytes32 constant LAST_OPERATION_TIMESTAMP = keccak256(\"LAST_OPERATION_TIMESTAMP\");\nbytes32 constant CREDENTIAL_ID = keccak256(\"CREDENTIAL_ID\");\nbytes32 constant INVESTOR_CROSS_CHAIN_ADDRESSES = keccak256(\"INVESTOR_CROSS_CHAIN_ADDRESSES\");\n\n// Instrument Registry\nbytes32 constant IS_INSTRUMENT = keccak256(\"IS_INSTRUMENT\");\nbytes32 constant TRADING_DAYS_IN_YEAR = keccak256(\"TRADING_DAYS_IN_YEAR\");\nbytes32 constant INSTRUMENT_INITIALIZED = keccak256(\"INSTRUMENT_INITIALIZED\");\nbytes32 constant INSTRUMENT_CLOSED = keccak256(\"INSTRUMENT_CLOSED\");\nbytes32 constant INSTANT_SETTLEMENT = keccak256(\"INSTANT_SETTLEMENT\");\nbytes32 constant CAN_TRANSFER_SETTLEMENT_TOKEN = keccak256(\"CAN_TRANSFER_SETTLEMENT_TOKEN\");\nbytes32 constant CAN_TRANSFER_SECURITY_TOKEN = keccak256(\"CAN_TRANSFER_SECURITY_TOKEN\");\nbytes32 constant INSTRUMENT_PAUSED = keccak256(\"INSTRUMENT_PAUSED\");\n\n// Dealer Registry\nbytes32 constant IS_DEALER = keccak256(\"IS_DEALER\");\n\n// Fund Registry\nbytes32 constant IS_FUND = keccak256(\"IS_FUND\");\nbytes32 constant DEFAULT_FUND_MODULES = keccak256(\"DEFAULT_FUND_MODULES\");\n\n// Roles\nbytes32 constant DEFAULT_ADMIN_ROLE = bytes32(0);\nbytes32 constant DEALER_MANAGER_ROLE = keccak256(\"DEALER_MANAGER_ROLE\");\nbytes32 constant LIBRE_DEALER_ROLE = keccak256(\"LIBRE_DEALER_ROLE\");\nbytes32 constant INSTRUMENT_MANAGER_ROLE = keccak256(\"INSTRUMENT_MANAGER_ROLE\");\nbytes32 constant SETTLEMENT_TOKEN_MINTER_ROLE = keccak256(\"SETTLEMENT_TOKEN_MINTER_ROLE\");\nbytes32 constant SETTLEMENT_TOKEN_BURNER_ROLE = keccak256(\"SETTLEMENT_TOKEN_BURNER_ROLE\");\nbytes32 constant RELAYER_ROLE = keccak256(\"RELAYER_ROLE\");\nbytes32 constant CONTRACT_MANAGER_ROLE = keccak256(\"CONTRACT_MANAGER_ROLE\");\nbytes32 constant REGISTRY_WRITER_ROLE_ADMIN = keccak256(\"REGISTRY_WRITER_ROLE_ADMIN\");\nbytes32 constant REGISTRY_WRITER_ROLE = keccak256(\"REGISTRY_WRITER_ROLE\");\nbytes32 constant ATTESTER_ROLE = keccak256(\"ATTESTER_ROLE\");\nbytes32 constant GATEWAY_MANAGER_ROLE = keccak256(\"GATEWAY_MANAGER_ROLE\");\nbytes32 constant CORE_GATEWAY_ROLE = keccak256(\"CORE_GATEWAY_ROLE\");\nbytes32 constant BRIDGE_ROLE = keccak256(\"BRIDGE_ROLE\");\nbytes32 constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n\n// Hash of module names\nbytes32 constant TRANSFER_MODULE = keccak256(\"TransferModule\");\nbytes32 constant DAILY_EXECUTION_CALCULATOR_MODULE = keccak256(\"DailyExecutionCalculatorModule\");\nbytes32 constant EXECUTION_DATE_ENFORCEMENT_MODULE = keccak256(\"ExecutionDateEnforcementModule\");\nbytes32 constant HALT_MODULE = keccak256(\"HaltModule\");\nbytes32 constant HOLDINGS_MODULE = keccak256(\"HoldingsModule\");\nbytes32 constant MONTHLY_EXECUTION_CALCULATOR_MODULE = keccak256(\"MonthlyExecutionCalculatorModule\");\nbytes32 constant FORCED_REDEMPTION_MODULE = keccak256(\"ForcedRedemptionModule\");\nbytes32 constant GATE_1_MODULE = keccak256(\"Gate1Module\");\nbytes32 constant HOLDING_INTERVALS_MODULE = keccak256(\"HoldingIntervalsModule\");\nbytes32 constant REDEMPTIONS_AGGREGATION_LIMIT_MODULE = keccak256(\"RedemptionsAggregationLimitModule\");\nbytes32 constant SUBSCRIPTIONS_AGGREGATION_LIMIT_MODULE = keccak256(\"SubscriptionsAggregationLimitModule\");\nbytes32 constant HOLDING_FEE_MODULE = keccak256(\"HoldingFeeModule\");\nbytes32 constant REDEMPTION_VOLUME_LIMIT_PER_INVESTOR_FEE_MODULE =\n    keccak256(\"RedemptionVolumeLimitPerInvestorFeeModule\");\nbytes32 constant INVESTOR_LAST_OPERATION_TRACKING_MODULE = keccak256(\"InvestorLastOperationTrackingModule\");\nbytes32 constant NAV_TRACKING_MODULE = keccak256(\"NAVTrackingModule\");\nbytes32 constant REDEMPTIONS_RECORDS_MODULE = keccak256(\"RedemptionsRecordsModule\");\nbytes32 constant REDEMPTIONS_TOTAL_AMOUNT_MODULE = keccak256(\"RedemptionsTotalAmountModule\");\nbytes32 constant SECURITY_TOKEN_TRACKING_MODULE = keccak256(\"SecurityTokenTrackingModule\");\nbytes32 constant SUBSCRIPTIONS_TOTAL_AMOUNT_MODULE = keccak256(\"SubscriptionsTotalAmountModule\");\nbytes32 constant HOLDING_FEE_EXEMPTION_MODULE = keccak256(\"HoldingFeeExemptionModule\");\nbytes32 constant HOLDING_INTERVALS_TRACKING_MODULE = keccak256(\"HoldingIntervalsTrackingModule\");\n\n// Percentage calculations\nuint256 constant PERCENTAGE_BASE = 100_00;\n"
    },
    "src/OrderPipeline.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.28;\n\nimport {IERC20Upgradeable} from \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable} from\n    \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {SafeCast} from \"openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport {SortedLinkedList} from \"src/lib/SortedLinkedList.sol\";\n\nimport {ISecurityToken} from \"src/interfaces/ISecurityToken.sol\";\nimport {ISettlementToken} from \"src/interfaces/ISettlementToken.sol\";\nimport {IOrderPipeline, OrderDetails, Context} from \"src/interfaces/IOrderPipeline.sol\";\nimport {IInstrumentRegistry} from \"src/interfaces/IInstrumentRegistry.sol\";\nimport {IInvestorRegistry} from \"src/interfaces/IInvestorRegistry.sol\";\nimport {IDealerRegistry} from \"src/interfaces/IDealerRegistry.sol\";\n\nimport {LibreUUPSUpgradeable} from \"src/utils/LibreUUPSUpgradeable.sol\";\nimport \"src/utils/Constant.sol\";\n\nimport {IOperationsEngine, OPERATIONS} from \"src/interfaces/IOperationsEngine.sol\";\n\nimport \"src/utils/Constant.sol\";\n\n/**\n * @title OrderPipeline\n * @author Libre\n * @notice This contract serves as the base for unified order pipeline management.\n * It provides methods for managing order lifecycle events such as creation, cancellation, and settlement.\n */\nabstract contract OrderPipeline is LibreUUPSUpgradeable, IOrderPipeline {\n    using SortedLinkedList for SortedLinkedList.List;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    // keccak256(abi.encode(uint256(keccak256(\"OrderPipeline.storage\")) - 1)) & ~bytes32(uint256(0xff));\n    bytes32 private constant ORDER_PIPELINE_STORAGE_SLOT =\n        0x110c926fa16509da894f0a2a08278b82b2a2f9ffc38d1ed1975f32ef34198800;\n\n    /// @custom:storage-location erc7201:OrderPipeline.storage\n    struct OrderPipelineStorage {\n        /// @notice The token used for settlement of orders.\n        ISettlementToken settlementToken;\n        /// @notice The security token associated with the instrument.\n        ISecurityToken securityToken;\n        /// @notice Registry for instrument details.\n        IInstrumentRegistry instrumentRegistry;\n        /// @notice Operations engine for executing modules on operations.\n        IOperationsEngine operationsEngine;\n        /// @notice Registry for investor information.\n        IInvestorRegistry investorRegistry;\n        /// @notice Registry for dealer information.\n        IDealerRegistry dealerRegistry;\n        /// @notice Address of the treasury.\n        address treasury;\n        /// @notice Address of the policy viewer.\n        address policyViewer;\n        /// @notice ID of the associated instrument.\n        bytes32 instrumentId;\n        /// @notice Current period of the pipeline.\n        uint256 currentPeriod; // should be initialized as 1 in the initialize function\n        /// @notice Counter for the number of orders created.\n        uint256 ordersCount;\n        /// @notice ID of the next order to be settled.\n        uint256 nextOrderToSettle;\n        /// @notice Total amount settled in the current period.\n        uint256 settledAmount;\n        /// @notice The orders mapping contains all the orders.\n        mapping(uint256 orderId => OrderDetails order) orders;\n        /// @notice Linked list containing all active orders.\n        SortedLinkedList.List ordersList;\n    }\n\n    /**\n     * @notice Retrieves order details by ID.\n     * @param _orderId The ID of the order.\n     * @return The details of the order.\n     */\n    function getOrder(uint256 _orderId) external view returns (OrderDetails memory) {\n        OrderPipelineStorage storage s = _getOrderPipelineStorage();\n        return s.orders[_orderId];\n    }\n\n    /**\n     * @notice Allows an admin to cancel an order.\n     * @param _orderId The ID of the order to cancel.\n     * @param _role The role of the admin performing the cancellation.\n     */\n    function adminCancelOrder(uint256 _orderId, bytes32 _role) public virtual {\n        OrderPipelineStorage storage ops = _getOrderPipelineStorage();\n        Context memory ctx = _getContext(ops);\n        _checkRoleHasAccess(_role);\n        OrderDetails memory order = ops.orders[_orderId];\n        if (order.sender == address(0)) {\n            revert IOrderPipeline_OrderNotFound();\n        }\n\n        uint256 amountLeft = order.amount - order.settledAmount;\n\n        _afterCancelOrderCheck(ctx, ops, _orderId, order, amountLeft);\n\n        _updateOrder(ops, _orderId, true);\n    }\n\n    /**\n     * @notice Retrieves the total number of orders created.\n     * @return The total count of orders.\n     */\n    function getTotalOrdersCount() public view returns (uint256) {\n        OrderPipelineStorage storage s = _getOrderPipelineStorage();\n        return s.ordersCount;\n    }\n\n    /**\n     * @notice Retrieves the next order ID to be settled.\n     * @return The next order ID for settlement.\n     */\n    function getNextOrderToSettle() public view returns (uint256) {\n        OrderPipelineStorage storage s = _getOrderPipelineStorage();\n        return s.nextOrderToSettle;\n    }\n\n    /**\n     * @notice Retrieves the total settled amount for the current period.\n     * @return The total settled amount.\n     */\n    function getTotalSettledAmount() public view returns (uint256) {\n        OrderPipelineStorage storage s = _getOrderPipelineStorage();\n        return s.settledAmount;\n    }\n\n    /**\n     * @notice Retrieves the list of all active order IDs.\n     * @return An array containing all active order IDs.\n     */\n    function getActiveOrderIds() public view returns (uint256[] memory) {\n        OrderPipelineStorage storage s = _getOrderPipelineStorage();\n        return s.ordersList.getNodesId();\n    }\n\n    /**\n     * @notice Retrieves the settlement token address used for orders.\n     * @return The address of the settlement token.\n     */\n    function getSettlementTokenAddress() public view returns (address) {\n        OrderPipelineStorage storage s = _getOrderPipelineStorage();\n        return address(s.settlementToken);\n    }\n\n    /**\n     * @notice Retrieves the current instrument ID.\n     * @return The ID of the instrument associated with the pipeline.\n     */\n    function getInstrumentId() public view returns (bytes32) {\n        OrderPipelineStorage storage s = _getOrderPipelineStorage();\n        return s.instrumentId;\n    }\n\n    /**\n     * @notice Creates a new order and transfers tokens.\n     * @dev Stores order details, validates token transfer, and emits an `OrderCreated` event.\n     * @param _ctx The context of the order pipeline.\n     * @param _ops The Order Pipeline Storage.\n     * @param _investorId Investor's unique identifier.\n     * @param _amount Amount of tokens to transfer.\n     * @param _beneficiaryWallet Address receiving the settlement.\n     * @param _sender Address initiating the order.\n     * @param _orderId Unique identifier of the order.\n     * @param _operation The operation to be tracked.\n     * @param _token The token to be transferred(settlement token for subscription\n     * and security token for redemption book)\n     */\n    function _createOrder(\n        Context memory _ctx,\n        OrderPipelineStorage storage _ops,\n        bytes32 _investorId,\n        uint256 _amount,\n        address _beneficiaryWallet,\n        address _sender,\n        uint256 _orderId,\n        OPERATIONS _operation,\n        IERC20Upgradeable _token\n    ) internal {\n        bytes memory result = _ctx.operationsEngine.check(\n            _operation,\n            _ctx.instrumentId,\n            abi.encode(block.timestamp, uint256(_investorId), block.timestamp, 0, 0) //default execution is current time\n        );\n        (uint256 executionTimestamp, string memory errorMsg) = abi.decode(result, (uint256, string));\n        require(executionTimestamp != 0, errorMsg);\n\n        _ops.orders[_orderId] = OrderDetails({\n            amount: SafeCast.toUint128(_amount),\n            beneficiary: _beneficiaryWallet,\n            investorId: _investorId,\n            sender: _sender,\n            timestamp: uint32(block.timestamp),\n            executionTimestamp: uint32(executionTimestamp),\n            settledAmount: 0\n        });\n\n        uint256 beforeTransferBalance = _token.balanceOf(address(this));\n        _token.safeTransferFrom(_sender, address(this), _amount);\n\n        if (_token.balanceOf(address(this)) != beforeTransferBalance + _amount) {\n            revert IOrderPipeline_InsufficientAmount();\n        }\n\n        emit OrderCreated(_orderId, _investorId, _amount, _sender);\n    }\n\n    /**\n     * @notice Pre-checks and processes order creation.\n     * @param _ctx The context of the order pipeline.\n     * @param _ops The Order Pipeline Storage.\n     * @param _amount The amount of the order.\n     * @param _investorId The ID of the investor.\n     * @param _investorWallet The wallet address of the investor.\n     * @param _beneficiaryWallet The beneficiary address for the order.\n     * @param _isFromDealer Whether the order is from a dealer.\n     * @return sender The address of the sender.\n     * @return orderId The ID of the created order.\n     */\n    function _beforeOrderCheck(\n        Context memory _ctx,\n        OrderPipelineStorage storage _ops,\n        uint256 _amount,\n        bytes32 _investorId,\n        address _investorWallet,\n        address _beneficiaryWallet,\n        bool _isFromDealer\n    ) internal virtual returns (address sender, uint256 orderId) {\n        if (_amount == 0) {\n            revert IOrderPipeline_InsufficientAmount();\n        }\n\n        if (_ops.instrumentRegistry.getBool(_ops.instrumentId, INSTRUMENT_CLOSED)) {\n            revert IOrderPipeline_InstrumentClosed();\n        }\n\n        if (_isFromDealer) {\n            _checkCorrectDealer(_ops, _investorId);\n            if (_ctx.investorRegistry.getIdFromWallet(_investorWallet) != _investorId) {\n                revert IOrderPipeline_WrongInvestor();\n            }\n            sender = msg.sender; // sender is the dealer\n        } else {\n            _checkCorrectInvestor(_ctx, _investorId);\n            sender = _investorWallet; // sender is the investor\n        }\n\n        if (_investorId != _ctx.investorRegistry.getIdFromWallet(_beneficiaryWallet)) {\n            revert IOrderPipeline_BeneficiaryIsNotInvestor();\n        }\n\n        orderId = ++_ops.ordersCount;\n        _ops.ordersList.insert(orderId);\n\n        return (sender, orderId);\n    }\n\n    /**\n     * @notice Executes post-order creation actions.\n     * @dev This hook is triggered after an order has passed all pre-checks and been created.\n     * @param _ctx The context of the order pipeline.\n     * @param _ops The Order Pipeline Storage.\n     * @param _orderId The ID of the newly created order.\n     */\n    function _afterOrderCheck(Context memory _ctx, OrderPipelineStorage storage _ops, uint256 _orderId) internal {\n        if (_ctx.instrumentRegistry.getBool(_ctx.instrumentId, INSTANT_SETTLEMENT)) {\n            _instantSettlement(_ctx, _ops, _orderId);\n        }\n    }\n\n    /**\n     * @notice Instant settlement of an order when the all the 4 phases are executed in the same transaction.\n     * @param _ctx The context of the order pipeline.\n     * @param _ops The Order Pipeline Storage.\n     * @param _orderId Id of the order to settle\n     */\n    function _instantSettlement(Context memory _ctx, OrderPipelineStorage storage _ops, uint256 _orderId)\n        internal\n        virtual;\n\n    /**\n     * @notice Processes the cancellation of an order.\n     * @param _ctx The context of the order pipeline.\n     * @param _ops The Order Pipeline Storage.\n     * @param _orderId The ID of the order to cancel.\n     * @param _amount The cancelled order amount .\n     */\n    function _afterCancelOrderCheck(\n        Context memory _ctx,\n        OrderPipelineStorage storage _ops,\n        uint256 _orderId,\n        OrderDetails memory _order,\n        uint256 _amount\n    ) internal virtual {\n        if (_amount != 0) {\n            _sendReceivedToken(_ctx, _order.sender, _amount);\n        }\n\n        if (_ops.nextOrderToSettle == _orderId) {\n            _ops.nextOrderToSettle = _ops.ordersList.getNext(_orderId);\n        }\n\n        emit OrderCancelled(_orderId, _order.amount);\n    }\n\n    /**\n     * @notice Updates an order's status and storage after settlement or cancellation.\n     * @param _ops The order pipeline storage.\n     * @param _orderId The ID of the order being updated.\n     * @param _isFullSettlement Whether the order was fully settled.\n     */\n    function _updateOrder(OrderPipelineStorage storage _ops, uint256 _orderId, bool _isFullSettlement) internal {\n        if (_isFullSettlement) {\n            _ops.ordersList.erase(_orderId);\n            delete _ops.orders[_orderId];\n        }\n    }\n\n    /**\n     * @notice Hook for custom settlement updates.\n     * @dev Updates the settlement period and resets state variables when a new period starts.\n     * @param _ctx The context of the order pipeline.\n     * @param _ops The Order Pipeline Storage.\n     * @param _isSubscription Whether the order is a subscription (true) or redemption (false)\n     * This ensures that all orders are settled correctly for the current period.\n     */\n    function _beforeSettlementUpdates(Context memory _ctx, OrderPipelineStorage storage _ops, bool _isSubscription)\n        internal\n    {\n        (uint256 period,,) = _isSubscription\n            ? _ctx.instrumentRegistry.currentSubscriptionPeriod(_ctx.instrumentId)\n            : _ctx.instrumentRegistry.currentRedemptionPeriod(_ctx.instrumentId);\n\n        if (period < _ops.currentPeriod) {\n            revert IOrderPipeline_PeriodDecreasing();\n        }\n\n        if (period != 0 && _ops.currentPeriod != period) {\n            _ops.currentPeriod = period;\n            _ops.settledAmount = 0;\n            _ops.nextOrderToSettle = 0;\n        }\n    }\n\n    /**\n     * @notice Sends tokens to the receiver.\n     * @param _ctx The context of the order pipeline.\n     * @param _receiver The address of the receiver.\n     * @param _amount The amount of tokens to send.\n     */\n    function _sendReceivedToken(Context memory _ctx, address _receiver, uint256 _amount) internal virtual;\n\n    /**\n     * @notice Prepares data for order settlement.\n     * @param _ctx The context of the order pipeline.\n     * @param _ops The Order Pipeline Storage.\n     * @param _percentageToSettle The percentage of the order to settle.\n     * @param _lastOrderId The ID of the last order in the settlement range.\n     * @param _isSubscription If the settlement is for subscriptions or not\n     * @return allOrders The list of orders to settle.\n     */\n    function _beforeSettleOrders(\n        Context memory _ctx,\n        OrderPipelineStorage storage _ops,\n        uint256 _percentageToSettle,\n        uint256 _lastOrderId,\n        bool _isSubscription\n    ) internal virtual returns (uint256[] memory allOrders) {\n        if (_percentageToSettle == 0 || _percentageToSettle > PERCENTAGE_BASE) {\n            revert IOrderPipeline_PercentageNotApt();\n        }\n\n        _beforeSettlementUpdates(_ctx, _ops, _isSubscription);\n\n        if (_lastOrderId < _ops.nextOrderToSettle) {\n            revert IOrderPipeline_OrderAlreadySettledInCurrentRound();\n        }\n\n        allOrders = _ops.ordersList.getNodesIdInRange(\n            _ops.nextOrderToSettle == 0 ? _ops.ordersList.begin : _ops.nextOrderToSettle, _lastOrderId\n        );\n    }\n\n    /**\n     * @notice Ensures that the caller is one of the wallets of the investor.\n     * @param _ctx The context of the order pipeline.\n     * @param _investor Id of the investor to verify\n     */\n    function _checkCorrectInvestor(Context memory _ctx, bytes32 _investor) internal view {\n        bytes32 investorId = _ctx.investorRegistry.getIdFromWallet(msg.sender);\n        if (investorId == bytes32(0) || _investor != investorId) {\n            revert IOrderPipeline_Unauthorized();\n        }\n    }\n\n    /**\n     * @notice Ensures that the caller is an authorized dealer for the investor.\n     * @param _ops The Order Pipeline Storage.\n     * @param _investorId The ID of the investor for which the dealer is verified.\n     */\n    function _checkCorrectDealer(OrderPipelineStorage storage _ops, bytes32 _investorId) internal view {\n        bytes32 dealerId = _ops.dealerRegistry.getIdFromWallet(msg.sender);\n        if (dealerId == bytes32(0) || _ops.investorRegistry.getDealer(_investorId) != dealerId) {\n            revert IOrderPipeline_Unauthorized();\n        }\n    }\n\n    /**\n     * @notice Checks if the instrument is not paused.\n     */\n    function _checkInstrumentNotPaused(IInstrumentRegistry _instrumentRegistry, bytes32 _instrumentId) internal view {\n        if (_instrumentRegistry.getBool(_instrumentId, INSTRUMENT_PAUSED)) {\n            revert IOrderPipeline_InstrumentPaused();\n        }\n    }\n\n    function _getContext(OrderPipelineStorage storage _ops) internal view returns (Context memory ctx) {\n        ctx = Context({\n            instrumentId: _ops.instrumentId,\n            operationsEngine: _ops.operationsEngine,\n            instrumentRegistry: _ops.instrumentRegistry,\n            investorRegistry: _ops.investorRegistry,\n            settlementToken: _ops.settlementToken,\n            securityToken: _ops.securityToken\n        });\n    }\n\n    /**\n     * @dev Retrieves the storage structure for the contract.\n     * @return store The storage object for the order pipeline.\n     */\n    function _getOrderPipelineStorage() internal pure returns (OrderPipelineStorage storage store) {\n        assembly {\n            store.slot := ORDER_PIPELINE_STORAGE_SLOT\n        }\n    }\n}\n"
    },
    "src/PermissionedContract.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.28;\n\nimport {IRoleRegistry} from \"src/interfaces/IRoleRegistry.sol\";\n\n/**\n * @title PermissionedContract\n * @author Libre\n * @notice Base contract for managing access control via roles.\n * @dev Provides shared functionality for role-based access control across contracts.\n */\nabstract contract PermissionedContract {\n    /// @custom:storage-location erc7201:PermissionedContract.storage\n    struct PermissionedContractStorage {\n        IRoleRegistry roleRegistry;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"PermissionedContract.storage\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant PERMISSIONED_CONTRACT_STORAGE_SLOT =\n        0x5a84e274199d81bb7497e94f6b60cc9eba947b73ccf3412997ff6bcdecf19d00;\n\n    error PermissionedContract_AccessDenied();\n\n    function _roleRegistry() internal view returns (IRoleRegistry) {\n        PermissionedContractStorage storage s = _getPermissionedContractStorage();\n        return s.roleRegistry;\n    }\n\n    /**\n     * @notice Verify that the user can execute the operation\n     * using the role specified\n     * @param _role Role the caller wants to use\n     */\n    function _roleHasAccess(bytes32 _role) internal view returns (bool) {\n        return _roleRegistry().hasAccess(address(this), msg.sig, msg.sender, _role);\n    }\n\n    /**\n     * @notice Check that the user can execute the operation\n     * using the role specified\n     * @param _role Role the caller wants to use\n     */\n    function _checkRoleHasAccess(bytes32 _role) internal view {\n        if (!_roleHasAccess(_role)) {\n            revert PermissionedContract_AccessDenied();\n        }\n    }\n\n    /**\n     * @notice Retrieves the storage for the Permissioned Contract.\n     * @dev This function uses inline assembly to access the storage slot defined by `PERMISSIONED_CONTRACT_STORAGE_SLOT`.\n     *      It allows access to the `PermissionedContractStorage` structure, enabling the management of permissioned contract data.\n     * @return s The `PermissionedContractStorage` structure located at the specified storage slot.\n     */\n    function _getPermissionedContractStorage() internal pure returns (PermissionedContractStorage storage s) {\n        assembly {\n            s.slot := PERMISSIONED_CONTRACT_STORAGE_SLOT\n        }\n    }\n}\n"
    },
    "lib/openzeppelin-contracts-upgradeable/contracts/token/ERC20/extensions/IERC20PermitUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.19;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20PermitUpgradeable {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "lib/openzeppelin-contracts-upgradeable/contracts/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.19;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, defaultRevert);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with a\n     * `customRevert` function as a fallback when `target` reverts.\n     *\n     * Requirements:\n     *\n     * - `customRevert` must be a reverting function.\n     *\n     * _Available since v5.0._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        function() internal view customRevert\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, customRevert);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, defaultRevert);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with a `customRevert` function as a fallback revert reason when `target` reverts.\n     *\n     * Requirements:\n     *\n     * - `customRevert` must be a reverting function.\n     *\n     * _Available since v5.0._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        function() internal view customRevert\n    ) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, customRevert);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, defaultRevert);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        function() internal view customRevert\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, customRevert);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, defaultRevert);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        function() internal view customRevert\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, customRevert);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided `customRevert`) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v5.0._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        function() internal view customRevert\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check if target is a contract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                if (target.code.length == 0) {\n                    revert AddressEmptyCode(target);\n                }\n            }\n            return returndata;\n        } else {\n            _revert(returndata, customRevert);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or with a default revert error.\n     *\n     * _Available since v5.0._\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal view returns (bytes memory) {\n        return verifyCallResult(success, returndata, defaultRevert);\n    }\n\n    /**\n     * @dev Same as {xref-Address-verifyCallResult-bool-bytes-}[`verifyCallResult`], but with a\n     * `customRevert` function as a fallback when `success` is `false`.\n     *\n     * Requirements:\n     *\n     * - `customRevert` must be a reverting function.\n     *\n     * _Available since v5.0._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        function() internal view customRevert\n    ) internal view returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, customRevert);\n        }\n    }\n\n    /**\n     * @dev Default reverting function when no `customRevert` is provided in a function call.\n     */\n    function defaultRevert() internal pure {\n        revert FailedInnerCall();\n    }\n\n    function _revert(bytes memory returndata, function() internal view customRevert) private view {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            customRevert();\n            revert FailedInnerCall();\n        }\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.19;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "src/interfaces/IFundRegistry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {IBaseRegistry} from \"src/interfaces/IBaseRegistry.sol\";\nimport {IRoleRegistry} from \"src/interfaces/IRoleRegistry.sol\";\nimport {IOperationsEngine} from \"src/interfaces/IOperationsEngine.sol\";\n\n/**\n * @title IFundRegistry\n * @author Libre\n * @notice Interface for managing and storing information related to funds within a registry.\n * Provides functionality to initialize the registry, add new funds, and emit events for key actions.\n */\ninterface IFundRegistry is IBaseRegistry {\n    /// @notice Error raised when attempting to register a fund that is already registered.\n    error IFundRegistry_AlreadyRegistered();\n\n    /**\n     * @notice Emited when a new Fund is added\n     * @param fundId Id of the new fund\n     */\n    event NewFundAdded(bytes32 indexed fundId);\n\n    /**\n     * @notice Initialize the registry\n     * @param _roleRegistry Address of the role registry\n     */\n    function initialize(IRoleRegistry _roleRegistry, IOperationsEngine _operationsEngine) external;\n\n    /**\n     * @notice Adds a new fund to the registry\n     * @param _senderRole Role of the sender which allow the operation execution\n     * @param _fundId The ID of the fund\n     */\n    function addNewFund(bytes32 _senderRole, bytes32 _fundId) external;\n}\n"
    },
    "lib/openzeppelin-contracts-upgradeable/contracts/token/ERC20/extensions/IERC20MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.19;\n\nimport \"../IERC20Upgradeable.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "lib/openzeppelin-contracts-upgradeable/contracts/access/IAccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.19;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControlUpgradeable {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n"
    },
    "lib/eas-contracts/contracts/IEAS.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { ISchemaRegistry } from \"./ISchemaRegistry.sol\";\nimport { ISemver } from \"./ISemver.sol\";\nimport { Attestation, Signature } from \"./Common.sol\";\n\n/// @notice A struct representing the arguments of the attestation request.\nstruct AttestationRequestData {\n    address recipient; // The recipient of the attestation.\n    uint64 expirationTime; // The time when the attestation expires (Unix timestamp).\n    bool revocable; // Whether the attestation is revocable.\n    bytes32 refUID; // The UID of the related attestation.\n    bytes data; // Custom attestation data.\n    uint256 value; // An explicit ETH amount to send to the resolver. This is important to prevent accidental user errors.\n}\n\n/// @notice A struct representing the full arguments of the attestation request.\nstruct AttestationRequest {\n    bytes32 schema; // The unique identifier of the schema.\n    AttestationRequestData data; // The arguments of the attestation request.\n}\n\n/// @notice A struct representing the full arguments of the full delegated attestation request.\nstruct DelegatedAttestationRequest {\n    bytes32 schema; // The unique identifier of the schema.\n    AttestationRequestData data; // The arguments of the attestation request.\n    Signature signature; // The ECDSA signature data.\n    address attester; // The attesting account.\n    uint64 deadline; // The deadline of the signature/request.\n}\n\n/// @notice A struct representing the full arguments of the multi attestation request.\nstruct MultiAttestationRequest {\n    bytes32 schema; // The unique identifier of the schema.\n    AttestationRequestData[] data; // The arguments of the attestation request.\n}\n\n/// @notice A struct representing the full arguments of the delegated multi attestation request.\nstruct MultiDelegatedAttestationRequest {\n    bytes32 schema; // The unique identifier of the schema.\n    AttestationRequestData[] data; // The arguments of the attestation requests.\n    Signature[] signatures; // The ECDSA signatures data. Please note that the signatures are assumed to be signed with increasing nonces.\n    address attester; // The attesting account.\n    uint64 deadline; // The deadline of the signature/request.\n}\n\n/// @notice A struct representing the arguments of the revocation request.\nstruct RevocationRequestData {\n    bytes32 uid; // The UID of the attestation to revoke.\n    uint256 value; // An explicit ETH amount to send to the resolver. This is important to prevent accidental user errors.\n}\n\n/// @notice A struct representing the full arguments of the revocation request.\nstruct RevocationRequest {\n    bytes32 schema; // The unique identifier of the schema.\n    RevocationRequestData data; // The arguments of the revocation request.\n}\n\n/// @notice A struct representing the arguments of the full delegated revocation request.\nstruct DelegatedRevocationRequest {\n    bytes32 schema; // The unique identifier of the schema.\n    RevocationRequestData data; // The arguments of the revocation request.\n    Signature signature; // The ECDSA signature data.\n    address revoker; // The revoking account.\n    uint64 deadline; // The deadline of the signature/request.\n}\n\n/// @notice A struct representing the full arguments of the multi revocation request.\nstruct MultiRevocationRequest {\n    bytes32 schema; // The unique identifier of the schema.\n    RevocationRequestData[] data; // The arguments of the revocation request.\n}\n\n/// @notice A struct representing the full arguments of the delegated multi revocation request.\nstruct MultiDelegatedRevocationRequest {\n    bytes32 schema; // The unique identifier of the schema.\n    RevocationRequestData[] data; // The arguments of the revocation requests.\n    Signature[] signatures; // The ECDSA signatures data. Please note that the signatures are assumed to be signed with increasing nonces.\n    address revoker; // The revoking account.\n    uint64 deadline; // The deadline of the signature/request.\n}\n\n/// @title IEAS\n/// @notice EAS - Ethereum Attestation Service interface.\ninterface IEAS is ISemver {\n    /// @notice Emitted when an attestation has been made.\n    /// @param recipient The recipient of the attestation.\n    /// @param attester The attesting account.\n    /// @param uid The UID of the new attestation.\n    /// @param schemaUID The UID of the schema.\n    event Attested(address indexed recipient, address indexed attester, bytes32 uid, bytes32 indexed schemaUID);\n\n    /// @notice Emitted when an attestation has been revoked.\n    /// @param recipient The recipient of the attestation.\n    /// @param attester The attesting account.\n    /// @param schemaUID The UID of the schema.\n    /// @param uid The UID the revoked attestation.\n    event Revoked(address indexed recipient, address indexed attester, bytes32 uid, bytes32 indexed schemaUID);\n\n    /// @notice Emitted when a data has been timestamped.\n    /// @param data The data.\n    /// @param timestamp The timestamp.\n    event Timestamped(bytes32 indexed data, uint64 indexed timestamp);\n\n    /// @notice Emitted when a data has been revoked.\n    /// @param revoker The address of the revoker.\n    /// @param data The data.\n    /// @param timestamp The timestamp.\n    event RevokedOffchain(address indexed revoker, bytes32 indexed data, uint64 indexed timestamp);\n\n    /// @notice Returns the address of the global schema registry.\n    /// @return The address of the global schema registry.\n    function getSchemaRegistry() external view returns (ISchemaRegistry);\n\n    /// @notice Attests to a specific schema.\n    /// @param request The arguments of the attestation request.\n    /// @return The UID of the new attestation.\n    ///\n    /// Example:\n    ///     attest({\n    ///         schema: \"0facc36681cbe2456019c1b0d1e7bedd6d1d40f6f324bf3dd3a4cef2999200a0\",\n    ///         data: {\n    ///             recipient: \"0xdEADBeAFdeAdbEafdeadbeafDeAdbEAFdeadbeaf\",\n    ///             expirationTime: 0,\n    ///             revocable: true,\n    ///             refUID: \"0x0000000000000000000000000000000000000000000000000000000000000000\",\n    ///             data: \"0xF00D\",\n    ///             value: 0\n    ///         }\n    ///     })\n    function attest(AttestationRequest calldata request) external payable returns (bytes32);\n\n    /// @notice Attests to a specific schema via the provided ECDSA signature.\n    /// @param delegatedRequest The arguments of the delegated attestation request.\n    /// @return The UID of the new attestation.\n    ///\n    /// Example:\n    ///     attestByDelegation({\n    ///         schema: '0x8e72f5bc0a8d4be6aa98360baa889040c50a0e51f32dbf0baa5199bd93472ebc',\n    ///         data: {\n    ///             recipient: '0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266',\n    ///             expirationTime: 1673891048,\n    ///             revocable: true,\n    ///             refUID: '0x0000000000000000000000000000000000000000000000000000000000000000',\n    ///             data: '0x1234',\n    ///             value: 0\n    ///         },\n    ///         signature: {\n    ///             v: 28,\n    ///             r: '0x148c...b25b',\n    ///             s: '0x5a72...be22'\n    ///         },\n    ///         attester: '0xc5E8740aD971409492b1A63Db8d83025e0Fc427e',\n    ///         deadline: 1673891048\n    ///     })\n    function attestByDelegation(\n        DelegatedAttestationRequest calldata delegatedRequest\n    ) external payable returns (bytes32);\n\n    /// @notice Attests to multiple schemas.\n    /// @param multiRequests The arguments of the multi attestation requests. The requests should be grouped by distinct\n    ///     schema ids to benefit from the best batching optimization.\n    /// @return The UIDs of the new attestations.\n    ///\n    /// Example:\n    ///     multiAttest([{\n    ///         schema: '0x33e9094830a5cba5554d1954310e4fbed2ef5f859ec1404619adea4207f391fd',\n    ///         data: [{\n    ///             recipient: '0xdEADBeAFdeAdbEafdeadbeafDeAdbEAFdeadbeaf',\n    ///             expirationTime: 1673891048,\n    ///             revocable: true,\n    ///             refUID: '0x0000000000000000000000000000000000000000000000000000000000000000',\n    ///             data: '0x1234',\n    ///             value: 1000\n    ///         },\n    ///         {\n    ///             recipient: '0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266',\n    ///             expirationTime: 0,\n    ///             revocable: false,\n    ///             refUID: '0x480df4a039efc31b11bfdf491b383ca138b6bde160988222a2a3509c02cee174',\n    ///             data: '0x00',\n    ///             value: 0\n    ///         }],\n    ///     },\n    ///     {\n    ///         schema: '0x5ac273ce41e3c8bfa383efe7c03e54c5f0bff29c9f11ef6ffa930fc84ca32425',\n    ///         data: [{\n    ///             recipient: '0xdEADBeAFdeAdbEafdeadbeafDeAdbEAFdeadbeaf',\n    ///             expirationTime: 0,\n    ///             revocable: true,\n    ///             refUID: '0x75bf2ed8dca25a8190c50c52db136664de25b2449535839008ccfdab469b214f',\n    ///             data: '0x12345678',\n    ///             value: 0\n    ///         },\n    ///     }])\n    function multiAttest(MultiAttestationRequest[] calldata multiRequests) external payable returns (bytes32[] memory);\n\n    /// @notice Attests to multiple schemas using via provided ECDSA signatures.\n    /// @param multiDelegatedRequests The arguments of the delegated multi attestation requests. The requests should be\n    ///     grouped by distinct schema ids to benefit from the best batching optimization.\n    /// @return The UIDs of the new attestations.\n    ///\n    /// Example:\n    ///     multiAttestByDelegation([{\n    ///         schema: '0x8e72f5bc0a8d4be6aa98360baa889040c50a0e51f32dbf0baa5199bd93472ebc',\n    ///         data: [{\n    ///             recipient: '0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266',\n    ///             expirationTime: 1673891048,\n    ///             revocable: true,\n    ///             refUID: '0x0000000000000000000000000000000000000000000000000000000000000000',\n    ///             data: '0x1234',\n    ///             value: 0\n    ///         },\n    ///         {\n    ///             recipient: '0xdEADBeAFdeAdbEafdeadbeafDeAdbEAFdeadbeaf',\n    ///             expirationTime: 0,\n    ///             revocable: false,\n    ///             refUID: '0x0000000000000000000000000000000000000000000000000000000000000000',\n    ///             data: '0x00',\n    ///             value: 0\n    ///         }],\n    ///         signatures: [{\n    ///             v: 28,\n    ///             r: '0x148c...b25b',\n    ///             s: '0x5a72...be22'\n    ///         },\n    ///         {\n    ///             v: 28,\n    ///             r: '0x487s...67bb',\n    ///             s: '0x12ad...2366'\n    ///         }],\n    ///         attester: '0x1D86495b2A7B524D747d2839b3C645Bed32e8CF4',\n    ///         deadline: 1673891048\n    ///     }])\n    function multiAttestByDelegation(\n        MultiDelegatedAttestationRequest[] calldata multiDelegatedRequests\n    ) external payable returns (bytes32[] memory);\n\n    /// @notice Revokes an existing attestation to a specific schema.\n    /// @param request The arguments of the revocation request.\n    ///\n    /// Example:\n    ///     revoke({\n    ///         schema: '0x8e72f5bc0a8d4be6aa98360baa889040c50a0e51f32dbf0baa5199bd93472ebc',\n    ///         data: {\n    ///             uid: '0x101032e487642ee04ee17049f99a70590c735b8614079fc9275f9dd57c00966d',\n    ///             value: 0\n    ///         }\n    ///     })\n    function revoke(RevocationRequest calldata request) external payable;\n\n    /// @notice Revokes an existing attestation to a specific schema via the provided ECDSA signature.\n    /// @param delegatedRequest The arguments of the delegated revocation request.\n    ///\n    /// Example:\n    ///     revokeByDelegation({\n    ///         schema: '0x8e72f5bc0a8d4be6aa98360baa889040c50a0e51f32dbf0baa5199bd93472ebc',\n    ///         data: {\n    ///             uid: '0xcbbc12102578c642a0f7b34fe7111e41afa25683b6cd7b5a14caf90fa14d24ba',\n    ///             value: 0\n    ///         },\n    ///         signature: {\n    ///             v: 27,\n    ///             r: '0xb593...7142',\n    ///             s: '0x0f5b...2cce'\n    ///         },\n    ///         revoker: '0x244934dd3e31bE2c81f84ECf0b3E6329F5381992',\n    ///         deadline: 1673891048\n    ///     })\n    function revokeByDelegation(DelegatedRevocationRequest calldata delegatedRequest) external payable;\n\n    /// @notice Revokes existing attestations to multiple schemas.\n    /// @param multiRequests The arguments of the multi revocation requests. The requests should be grouped by distinct\n    ///     schema ids to benefit from the best batching optimization.\n    ///\n    /// Example:\n    ///     multiRevoke([{\n    ///         schema: '0x8e72f5bc0a8d4be6aa98360baa889040c50a0e51f32dbf0baa5199bd93472ebc',\n    ///         data: [{\n    ///             uid: '0x211296a1ca0d7f9f2cfebf0daaa575bea9b20e968d81aef4e743d699c6ac4b25',\n    ///             value: 1000\n    ///         },\n    ///         {\n    ///             uid: '0xe160ac1bd3606a287b4d53d5d1d6da5895f65b4b4bab6d93aaf5046e48167ade',\n    ///             value: 0\n    ///         }],\n    ///     },\n    ///     {\n    ///         schema: '0x5ac273ce41e3c8bfa383efe7c03e54c5f0bff29c9f11ef6ffa930fc84ca32425',\n    ///         data: [{\n    ///             uid: '0x053d42abce1fd7c8fcddfae21845ad34dae287b2c326220b03ba241bc5a8f019',\n    ///             value: 0\n    ///         },\n    ///     }])\n    function multiRevoke(MultiRevocationRequest[] calldata multiRequests) external payable;\n\n    /// @notice Revokes existing attestations to multiple schemas via provided ECDSA signatures.\n    /// @param multiDelegatedRequests The arguments of the delegated multi revocation attestation requests. The requests\n    ///     should be grouped by distinct schema ids to benefit from the best batching optimization.\n    ///\n    /// Example:\n    ///     multiRevokeByDelegation([{\n    ///         schema: '0x8e72f5bc0a8d4be6aa98360baa889040c50a0e51f32dbf0baa5199bd93472ebc',\n    ///         data: [{\n    ///             uid: '0x211296a1ca0d7f9f2cfebf0daaa575bea9b20e968d81aef4e743d699c6ac4b25',\n    ///             value: 1000\n    ///         },\n    ///         {\n    ///             uid: '0xe160ac1bd3606a287b4d53d5d1d6da5895f65b4b4bab6d93aaf5046e48167ade',\n    ///             value: 0\n    ///         }],\n    ///         signatures: [{\n    ///             v: 28,\n    ///             r: '0x148c...b25b',\n    ///             s: '0x5a72...be22'\n    ///         },\n    ///         {\n    ///             v: 28,\n    ///             r: '0x487s...67bb',\n    ///             s: '0x12ad...2366'\n    ///         }],\n    ///         revoker: '0x244934dd3e31bE2c81f84ECf0b3E6329F5381992',\n    ///         deadline: 1673891048\n    ///     }])\n    function multiRevokeByDelegation(\n        MultiDelegatedRevocationRequest[] calldata multiDelegatedRequests\n    ) external payable;\n\n    /// @notice Timestamps the specified bytes32 data.\n    /// @param data The data to timestamp.\n    /// @return The timestamp the data was timestamped with.\n    function timestamp(bytes32 data) external returns (uint64);\n\n    /// @notice Timestamps the specified multiple bytes32 data.\n    /// @param data The data to timestamp.\n    /// @return The timestamp the data was timestamped with.\n    function multiTimestamp(bytes32[] calldata data) external returns (uint64);\n\n    /// @notice Revokes the specified bytes32 data.\n    /// @param data The data to timestamp.\n    /// @return The timestamp the data was revoked with.\n    function revokeOffchain(bytes32 data) external returns (uint64);\n\n    /// @notice Revokes the specified multiple bytes32 data.\n    /// @param data The data to timestamp.\n    /// @return The timestamp the data was revoked with.\n    function multiRevokeOffchain(bytes32[] calldata data) external returns (uint64);\n\n    /// @notice Returns an existing attestation by UID.\n    /// @param uid The UID of the attestation to retrieve.\n    /// @return The attestation data members.\n    function getAttestation(bytes32 uid) external view returns (Attestation memory);\n\n    /// @notice Checks whether an attestation exists.\n    /// @param uid The UID of the attestation to retrieve.\n    /// @return Whether an attestation exists.\n    function isAttestationValid(bytes32 uid) external view returns (bool);\n\n    /// @notice Returns the timestamp that the specified data was timestamped with.\n    /// @param data The data to query.\n    /// @return The timestamp the data was timestamped with.\n    function getTimestamp(bytes32 data) external view returns (uint64);\n\n    /// @notice Returns the timestamp that the specified data was timestamped with.\n    /// @param data The data to query.\n    /// @return The timestamp the data was timestamped with.\n    function getRevokeOffchain(address revoker, bytes32 data) external view returns (uint64);\n}\n"
    },
    "lib/risc0-ethereum/contracts/src/IRiscZeroVerifier.sol": {
      "content": "// Copyright 2024 RISC Zero, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n\npragma solidity ^0.8.9;\n\nimport {reverseByteOrderUint32} from \"./Util.sol\";\n\n/// @notice A receipt attesting to the execution of a guest program.\n/// @dev A receipt contains two parts: a seal and a claim. The seal is a zero-knowledge proof\n/// attesting to knowledge of a zkVM execution resulting in the claim. The claim is a set of public\n/// outputs for the execution. Crucially, the claim includes the journal and the image ID. The\n/// image ID identifies the program that was executed, and the journal is the public data written\n/// by the program. Note that this struct only contains the claim digest, as can be obtained with\n/// the `digest()` function on `ReceiptClaimLib`.\nstruct Receipt {\n    bytes seal;\n    bytes32 claimDigest;\n}\n\n/// @notice Public claims about a zkVM guest execution, such as the journal committed to by the guest.\n/// @dev Also includes important information such as the exit code and the starting and ending system\n/// state (i.e. the state of memory). `ReceiptClaim` is a \"Merkle-ized struct\" supporting\n/// partial openings of the underlying fields from a hash commitment to the full structure.\nstruct ReceiptClaim {\n    /// @notice Digest of the SystemState just before execution has begun.\n    bytes32 preStateDigest;\n    /// @notice Digest of the SystemState just after execution has completed.\n    bytes32 postStateDigest;\n    /// @notice The exit code for the execution.\n    ExitCode exitCode;\n    /// @notice A digest of the input to the guest.\n    /// @dev This field is currently unused and must be set to the zero digest.\n    bytes32 input;\n    /// @notice Digest of the Output of the guest, including the journal\n    /// and assumptions set during execution.\n    bytes32 output;\n}\n\nlibrary ReceiptClaimLib {\n    using OutputLib for Output;\n    using SystemStateLib for SystemState;\n\n    bytes32 constant TAG_DIGEST = sha256(\"risc0.ReceiptClaim\");\n\n    // Define a constant to ensure hashing is done at compile time. Can't use the\n    // SystemStateLib.digest method here because the Solidity compiler complains.\n    bytes32 constant SYSTEM_STATE_ZERO_DIGEST = 0xa3acc27117418996340b84e5a90f3ef4c49d22c79e44aad822ec9c313e1eb8e2;\n\n    /// @notice Construct a ReceiptClaim from the given imageId and journalDigest.\n    ///         Returned ReceiptClaim will represent a successful execution of the zkVM, running\n    ///         the program committed by imageId and resulting in the journal specified by\n    ///         journalDigest.\n    /// @param imageId The identifier for the guest program.\n    /// @param journalDigest The SHA-256 digest of the journal bytes.\n    /// @dev Input hash and postStateDigest are set to all-zeros (i.e. no committed input, or\n    ///      final memory state), the exit code is (Halted, 0), and there are no assumptions\n    ///      (i.e. the receipt is unconditional).\n    function ok(bytes32 imageId, bytes32 journalDigest) internal pure returns (ReceiptClaim memory) {\n        return ReceiptClaim(\n            imageId,\n            SYSTEM_STATE_ZERO_DIGEST,\n            ExitCode(SystemExitCode.Halted, 0),\n            bytes32(0),\n            Output(journalDigest, bytes32(0)).digest()\n        );\n    }\n\n    function digest(ReceiptClaim memory claim) internal pure returns (bytes32) {\n        return sha256(\n            abi.encodePacked(\n                TAG_DIGEST,\n                // down\n                claim.input,\n                claim.preStateDigest,\n                claim.postStateDigest,\n                claim.output,\n                // data\n                uint32(claim.exitCode.system) << 24,\n                uint32(claim.exitCode.user) << 24,\n                // down.length\n                uint16(4) << 8\n            )\n        );\n    }\n}\n\n/// @notice Commitment to the memory state and program counter (pc) of the zkVM.\n/// @dev The \"pre\" and \"post\" fields of the ReceiptClaim are digests of the system state at the\n///      start are stop of execution. Programs are loaded into the zkVM by creating a memory image\n///      of the loaded program, and creating a system state for initializing the zkVM. This is\n///      known as the \"image ID\".\nstruct SystemState {\n    /// @notice Program counter.\n    uint32 pc;\n    /// @notice Root hash of a merkle tree which confirms the integrity of the memory image.\n    bytes32 merkle_root;\n}\n\nlibrary SystemStateLib {\n    bytes32 constant TAG_DIGEST = sha256(\"risc0.SystemState\");\n\n    function digest(SystemState memory state) internal pure returns (bytes32) {\n        return sha256(\n            abi.encodePacked(\n                TAG_DIGEST,\n                // down\n                state.merkle_root,\n                // data\n                reverseByteOrderUint32(state.pc),\n                // down.length\n                uint16(1) << 8\n            )\n        );\n    }\n}\n\n/// @notice Exit condition indicated by the zkVM at the end of the guest execution.\n/// @dev Exit codes have a \"system\" part and a \"user\" part. Semantically, the system part is set to\n/// indicate the type of exit (e.g. halt, pause, or system split) and is directly controlled by the\n/// zkVM. The user part is an exit code, similar to exit codes used in Linux, chosen by the guest\n/// program to indicate additional information (e.g. 0 to indicate success or 1 to indicate an\n/// error).\nstruct ExitCode {\n    SystemExitCode system;\n    uint8 user;\n}\n\n/// @notice Exit condition indicated by the zkVM at the end of the execution covered by this proof.\n/// @dev\n/// `Halted` indicates normal termination of a program with an interior exit code returned from the\n/// guest program. A halted program cannot be resumed.\n///\n/// `Paused` indicates the execution ended in a paused state with an interior exit code set by the\n/// guest program. A paused program can be resumed such that execution picks up where it left\n/// of, with the same memory state.\n///\n/// `SystemSplit` indicates the execution ended on a host-initiated system split. System split is\n/// mechanism by which the host can temporarily stop execution of the execution ended in a system\n/// split has no output and no conclusions can be drawn about whether the program will eventually\n/// halt. System split is used in continuations to split execution into individually provable segments.\nenum SystemExitCode {\n    Halted,\n    Paused,\n    SystemSplit\n}\n\n/// @notice Output field in the `ReceiptClaim`, committing to a claimed journal and assumptions list.\nstruct Output {\n    /// @notice Digest of the journal committed to by the guest execution.\n    bytes32 journalDigest;\n    /// @notice Digest of the ordered list of `ReceiptClaim` digests corresponding to the\n    /// calls to `env::verify` and `env::verify_integrity`.\n    /// @dev Verifying the integrity of a `Receipt` corresponding to a `ReceiptClaim` with a\n    /// non-empty assumptions list does not guarantee unconditionally any of the claims over the\n    /// guest execution (i.e. if the assumptions list is non-empty, then the journal digest cannot\n    /// be trusted to correspond to a genuine execution). The claims can be checked by additional\n    /// verifying a `Receipt` for every digest in the assumptions list.\n    bytes32 assumptionsDigest;\n}\n\nlibrary OutputLib {\n    bytes32 constant TAG_DIGEST = sha256(\"risc0.Output\");\n\n    function digest(Output memory output) internal pure returns (bytes32) {\n        return sha256(\n            abi.encodePacked(\n                TAG_DIGEST,\n                // down\n                output.journalDigest,\n                output.assumptionsDigest,\n                // down.length\n                uint16(2) << 8\n            )\n        );\n    }\n}\n\n/// @notice Error raised when cryptographic verification of the zero-knowledge proof fails.\nerror VerificationFailed();\n\n/// @notice Verifier interface for RISC Zero receipts of execution.\ninterface IRiscZeroVerifier {\n    /// @notice Verify that the given seal is a valid RISC Zero proof of execution with the\n    ///     given image ID and journal digest. Reverts on failure.\n    /// @dev This method additionally ensures that the input hash is all-zeros (i.e. no\n    /// committed input), the exit code is (Halted, 0), and there are no assumptions (i.e. the\n    /// receipt is unconditional).\n    /// @param seal The encoded cryptographic proof (i.e. SNARK).\n    /// @param imageId The identifier for the guest program.\n    /// @param journalDigest The SHA-256 digest of the journal bytes.\n    function verify(bytes calldata seal, bytes32 imageId, bytes32 journalDigest) external view;\n\n    /// @notice Verify that the given receipt is a valid RISC Zero receipt, ensuring the `seal` is\n    /// valid a cryptographic proof of the execution with the given `claim`. Reverts on failure.\n    /// @param receipt The receipt to be verified.\n    function verifyIntegrity(Receipt calldata receipt) external view;\n}\n"
    },
    "src/interfaces/IBaseRegistry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {IEternalRegistryStorage} from \"src/interfaces/IEternalRegistryStorage.sol\";\n\n/**\n * @title IBaseRegistry\n * @notice Interface for the base registry, which provides functionality for tracking and retrieving data\n * specific to modules that interact with the registry.\n * @dev The tracked data can be queried via a delegatecall callback to the relevant module,\n * which implements the query logic.\n */\ninterface IBaseRegistry is IEternalRegistryStorage {\n    /**\n     * @notice Thrown when an unauthorized caller tries to access a restricted function or resource.\n     */\n    error IBaseRegistry_AccessDenied();\n\n    /**\n     * @notice Thrown when an action is attempted on a module that is not registered in the registry.\n     */\n    error IBaseRegistry_NotRegisteredModule();\n\n    /**\n     * @notice Thrown when an invalid or non-existent ID is provided for an operation.\n     */\n    error IBaseRegistry_NotAValidId();\n\n    /**\n     * @notice Thrown when the system fails to retrieve the tracked data for a specific operation or ID.\n     */\n    error IBaseRegistry_FailedToGetTrackedData();\n\n    /**\n     * @notice Get the tracked data of the registry\n     * @param _data Data to be used by the module to get the tracked data\n     * @return bytes memory of the tracked data\n     * @dev This function is used to get the tracked data from the registry\n     * by doing a delegatecall callback to the module requesting the data\n     * which can implement the query logic\n     */\n    function getTrackedData(bytes memory _data) external returns (bytes memory);\n}\n"
    },
    "src/interfaces/IUserRegistry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title IUserRegistry\n * @author Libre\n * @notice Interface for managing user wallets and their association with investor/dealer IDs.\n * @dev Provides functions for adding wallets, retrieving wallets, and mapping wallets to user IDs.\n */\ninterface IUserRegistry {\n    /**\n     * @notice Thrown when the wallet address being added is already associated with another user ID.\n     */\n    error IUserRegistry_WalletAlreadyClaimed();\n\n    /**\n     * @notice Thrown when the provided signature fails to verify ownership of the wallet address.\n     */\n    error IUserRegistry_WalletOwnershipVerificationFailure();\n\n    /**\n     * @notice Thrown when the provided wallet signature has expired.\n     */\n    error IUserRegistry_WalletSignatureExpired();\n\n    /**\n     * @notice Thrown when the provided wallet address to add is blacklisted.\n     */\n    error IUserRegistry_WalletBlacklisted();\n\n    /**\n     * @notice Emited when secondary wallet is removed\n     * @param wallet User wallet address\n     */\n    event WalletAdded(address indexed wallet);\n\n    /**\n     * @notice Emited when secondary wallet is removed\n     * @param wallet User wallet address\n     */\n    event WalletRemoved(address indexed wallet);\n\n    /**\n     * @notice Adds a new investor to the registry\n     * @param _userId The ID of the user.\n     * @param _wallet The wallet address to associate with the user ID.\n     * @param _role The role used by the caller.\n     */\n    function addWallet(bytes32 _userId, address _wallet, bytes32 _role) external;\n\n    /**\n     * @notice Removes a wallet from the registry\n     * @param _wallet The wallet address to remove.\n     * @param _role The role used by the caller.\n     * @return The user ID that the wallet was removed from\n     */\n    function removeWallet(address _wallet, bytes32 _role) external returns (bytes32);\n\n    /**\n     * @notice Get Investor/Dealer array of wallets\n     * @param _userId Investor/Dealer ID\n     */\n    function getWallets(bytes32 _userId) external view returns (address[] memory);\n\n    /**\n     * @notice Get Investor/Dealer ID\n     * @param _wallet Investor/Dealer address\n     */\n    function getIdFromWallet(address _wallet) external view returns (bytes32);\n}\n"
    },
    "src/interfaces/IGatewayManager.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {IInvestorRegistry} from \"src/interfaces/IInvestorRegistry.sol\";\nimport {IRoleRegistry} from \"src/interfaces/IRoleRegistry.sol\";\nimport {ILibreCoreGateway} from \"src/interfaces/ILibreCoreGateway.sol\";\nimport {IEAS} from \"eas-contracts/IEAS.sol\";\n\n/**\n * @title IGatewayManager Interface\n * @notice Interface for managing cross-chain addresses and investor chain preferences\n * @dev Coordinates with LibreCoreGateway for cross-chain operations\n */\ninterface IGatewayManager {\n    /**\n     * @notice Emitted when an investor's preferred chains are updated or set\n     * @param investorId The unique identifier of the investor\n     * @param chains Array of custom chain IDs that the investor prefers\n     * @param oldChains Previous array of chain IDs for the investor\n     */\n    event InvestorChainsUpdated(bytes32 investorId, uint16[] chains, uint16[] oldChains);\n\n    /**\n     * @notice Emitted when cross-chain addresses are updated for an investor\n     * @dev Each address change is encoded as: [1 byte action][2 bytes chainSelector][n bytes address]\n     * @param investorId The unique identifier of the investor\n     * @param addressChanges A list of concatenated bytes describing a change in multi-chain address\n     */\n    event InvestorAddressesUpdated(bytes32 investorId, bytes[] addressChanges);\n\n    /// @notice Thrown when an unsupported or invalid chain ID is provided\n    error GatewayManager_InvalidChain();\n\n    /// @notice Thrown when the investor ID doesn't exist or is invalid\n    error GatewayManager_InvalidInvestor();\n\n    /// @notice Thrown when input parameters are invalid or missing\n    error GatewayManager_InvalidInput();\n\n    /// @notice Thrown when a cross-chain address is already associated with another investor\n    error GatewayManager_AddressAlreadyUsed();\n\n    /**\n     * @notice Initializes the gateway manager\n     * @param _coreGateway Address of the LibreCoreGateway contract\n     * @param _eas Address of the Ethereum Attestation Service\n     * @param _investorRegistry Address of the InvestorRegistry contract\n     * @param _roleRegistry Address of the RoleRegistry contract\n     */\n    function initialize(\n        ILibreCoreGateway _coreGateway,\n        IEAS _eas,\n        IInvestorRegistry _investorRegistry,\n        IRoleRegistry _roleRegistry\n    ) external;\n\n    /**\n     * @notice Sets the preferred chains for an investor\n     * @param _senderRole Role of the transaction sender\n     * @param _investorId Unique identifier of the investor\n     * @param _chains Array of chain IDs to set as preferred\n     */\n    function setInvestorChains(bytes32 _senderRole, bytes32 _investorId, uint16[] calldata _chains) external;\n\n    /**\n     * @notice Updates investor's cross-chain addresses and propagates changes to other chains\n     * @dev Adds or removes addresses and bridges the updates to other chains\n     * @param _senderRole Role of the transaction sender\n     * @param _investorId Unique identifier of the investor\n     * @param _addressChanges A list of concatenated bytes describing a change in multi-chain address\n     */\n    function manageCrossChainAddresses(bytes32 _senderRole, bytes32 _investorId, bytes[] calldata _addressChanges)\n        external;\n\n    /**\n     * @notice Bridges a credential to all investor's preferred chains via core gateway.\n     * @param _attestationId The unique ID of the attestation to be bridged.\n     * @param _senderRole Role of the transaction sender.\n     * @param _chains Chains to bridge credential to (all investor chains if empty)\n     */\n    function bridgeCredential(bytes32 _attestationId, bytes32 _senderRole, uint16[] memory _chains) external;\n\n    /**\n     * @notice Validates if an address is a valid cross-chain address for an investor\n     * @param _investorId The investor ID to check\n     * @param _chainSelector The chain ID to check\n     * @param _address The address to validate\n     * @return bool True if the address is valid for the investor on the chain\n     */\n    function isValidCrossChainAddress(bytes32 _investorId, uint16 _chainSelector, bytes calldata _address)\n        external\n        view\n        returns (bool);\n\n    /**\n     * @notice Gets an investor's preferred chains\n     * @param _investorId The investor's unique identifier\n     * @return uint16[] Array of preferred chain IDs\n     */\n    function getInvestorChains(bytes32 _investorId) external view returns (uint16[] memory);\n\n    /**\n     * @notice Gets the owner of a cross-chain address\n     * @param _chainSelector The chain ID of the address\n     * @param _address The address to get the owner of\n     * @return bytes32 The owner of the address\n     */\n    function getAddressOwner(uint16 _chainSelector, bytes calldata _address) external view returns (bytes32);\n}\n"
    },
    "src/interfaces/IEternalRegistryStorage.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title IEternalRegistryStorage\n * @notice Interface for managing a flexible and extensible storage system, allowing various types of values to be\n * stored and retrieved for specific registry entries. Provides a robust and modular way to interact with registry data.\n * @dev Enables storage and retrieval of multiple data types (e.g., uint256, address, string, bool, bytes32) and\n * supports operations like batch updates, array manipulations, and role-based access control for data modifications.\n */\ninterface IEternalRegistryStorage {\n    /**\n     * @notice Thrown when attempting to modify a key that has been restricted.\n     */\n    error IEternalRegistryStorage_AttemptToSetARestrictedKey();\n\n    /**\n     * @notice Thrown when the length of the provided input arrays does not match.\n     */\n    error IEternalRegistryStorage_BatchLengthMismatch();\n\n    /**\n     * @notice Thrown when attempting to access an array index that is out of bounds.\n     */\n    error IEternalRegistryStorage_IndexShouldBeLessThanLengthOfTheArray();\n\n    /**\n     * @notice Emitted when a boolean value is added to the registry.\n     * @param id The identifier of the registry entry.\n     * @param key The key associated with the boolean value.\n     * @param value The boolean value added to the registry.\n     */\n    event AddedBool(bytes32 indexed id, bytes32 indexed key, bool value);\n\n    /**\n     * @notice Emitted when a uint256 value is added to the registry.\n     * @param id The identifier of the registry entry.\n     * @param key The key associated with the uint256 value.\n     * @param value The uint256 value added to the registry.\n     */\n    event AddedUint(bytes32 indexed id, bytes32 indexed key, uint256 value);\n\n    /**\n     * @notice Emitted when an address value is added to the registry.\n     * @param id The identifier of the registry entry.\n     * @param key The key associated with the address value.\n     * @param value The address value added to the registry.\n     */\n    event AddedAddress(bytes32 indexed id, bytes32 indexed key, address value);\n\n    /**\n     * @notice Emitted when a string value is added to the registry.\n     * @param id The identifier of the registry entry.\n     * @param key The key associated with the string value.\n     * @param value The string value added to the registry.\n     */\n    event AddedString(bytes32 indexed id, bytes32 indexed key, string value);\n\n    /**\n     * @notice Emitted when a bytes32 value is added to the registry.\n     * @param id The identifier of the registry entry.\n     * @param key The key associated with the bytes32 value.\n     * @param value The bytes32 value added to the registry.\n     */\n    event AddedBytes(bytes32 indexed id, bytes32 indexed key, bytes32 value);\n\n    /**\n     * @notice Emitted every time a key is restricted from being set\n     * for an specific entry\n     * @param _id Id of the entry where the key is restricted\n     * @param _key Key being restricted\n     */\n    event KeyRestricted(bytes32 indexed _id, bytes32 indexed _key);\n\n    /**\n     * @notice Get a boolean value from the storage\n     * @param _id Id of the registry entry to get the value from\n     * @param _key Key identifying the value to get\n     * @return bool value of the element associated to the key\n     * in the requested registry entry\n     */\n    function getBool(bytes32 _id, bytes32 _key) external view returns (bool);\n\n    /**\n     * @notice Get a uint256 value from the storage\n     * @param _id Id of the registry entry to get the value from\n     * @param _key Key identifying the value to get\n     * @return uint256 value of the element associated to the key\n     * in the requested registry entry\n     */\n    function getUint(bytes32 _id, bytes32 _key) external view returns (uint256);\n\n    /**\n     * @notice Get an address value from the storage\n     * @param _id Id of the registry entry to get the value from\n     * @param _key Key identifying the value to get\n     * @return address value of the element associated to the key\n     * in the requested registry entry\n     */\n    function getAddress(bytes32 _id, bytes32 _key) external view returns (address);\n\n    /**\n     * @notice Get a string value from the storage\n     * @param _id Id of the registry entry to get the value from\n     * @param _key Key identifying the value to get\n     * @return string value of the element associated to the key\n     * in the requested registry entry\n     */\n    function getString(bytes32 _id, bytes32 _key) external view returns (string memory);\n\n    /**\n     * @notice Get a bytes value from the storage\n     * @param _id Id of the registry entry to get the value from\n     * @param _key Key identifying the value to get\n     * @return bytes value of the element associated to the key\n     * in the requested registry entry\n     */\n    function getBytes(bytes32 _id, bytes32 _key) external view returns (bytes32);\n\n    /**\n     * @notice Set a boolean value on the storage\n     * @param _id Id of the registry entry to set the value on\n     * @param _key Key identifying the value to set\n     * @param _value Value to set\n     * @param _senderRole Role of the sender allowing the operation\n     */\n    function setBool(bytes32 _id, bytes32 _key, bool _value, bytes32 _senderRole) external;\n\n    /**\n     * @notice Set a uint256 value on the storage\n     * @param _id Id of the registry entry to set the value on\n     * @param _key Key identifying the value to set\n     * @param _value Value to set\n     * @param _senderRole Role of the sender allowing the operation\n     */\n    function setUint(bytes32 _id, bytes32 _key, uint256 _value, bytes32 _senderRole) external;\n\n    /**\n     * @notice Set an address value on the storage\n     * @param _id Id of the registry entry to set the value on\n     * @param _key Key identifying the value to set\n     * @param _value Value to set\n     * @param _senderRole Role of the sender allowing the operation\n     */\n    function setAddress(bytes32 _id, bytes32 _key, address _value, bytes32 _senderRole) external;\n\n    /**\n     * @notice Set a string value on the storage\n     * @param _id Id of the registry entry to set the value on\n     * @param _key Key identifying the value to set\n     * @param _value Value to set\n     * @param _senderRole Role of the sender allowing the operation\n     */\n    function setString(bytes32 _id, bytes32 _key, string calldata _value, bytes32 _senderRole) external;\n\n    /**\n     * @notice Set a bytes value on the storage\n     * @param _id Id of the registry entry to set the value on\n     * @param _key Key identifying the value to set\n     * @param _value Value to set\n     * @param _senderRole Role of the sender allowing the operation\n     */\n    function setBytes(bytes32 _id, bytes32 _key, bytes32 _value, bytes32 _senderRole) external;\n\n    /**\n     * @notice Set multiple values in one transaction\n     * @param _ids Ids associated to the values to set\n     * @param _keys Key associated to the values to set\n     * @param _boolValues Bool values to set\n     * @param _uintValues Uint256 values to set\n     * @param _addressValues Address values to set\n     * @param _stringValues String values to set\n     * @param _bytesValues Bytes32 values to set\n     * @param _senderRole Role of the sender allowing the operation\n     */\n    function setBatch(\n        bytes32[] memory _ids,\n        bytes32[] memory _keys,\n        bool[] memory _boolValues,\n        uint256[] memory _uintValues,\n        address[] memory _addressValues,\n        string[] memory _stringValues,\n        bytes32[] memory _bytesValues,\n        bytes32 _senderRole\n    ) external;\n\n    /**\n     * @notice Get multiple values in one transaction\n     * @param _ids Ids associated to the values to get\n     * @param _keys Keys associated to the values to get\n     * @param _boolCount Number of bool values to get\n     * @param _uintCount Number of uint256 values to get\n     * @param _addressCount Number of address values to get\n     * @param _stringCount Number of string values to get\n     * @param _bytesCount Number of bytes32 values to get\n     * @return _boolValues Bool values return array\n     * @return _uintValues Uint256 values return array\n     * @return _addressValues Address values return array\n     * @return _stringValues String values return array\n     * @return _bytesValues Bytes32 values return array\n     */\n    function getBatch(\n        bytes32[] memory _ids,\n        bytes32[] memory _keys,\n        uint256 _boolCount,\n        uint256 _uintCount,\n        uint256 _addressCount,\n        uint256 _stringCount,\n        uint256 _bytesCount\n    )\n        external\n        view\n        returns (\n            bool[] memory _boolValues,\n            uint256[] memory _uintValues,\n            address[] memory _addressValues,\n            string[] memory _stringValues,\n            bytes32[] memory _bytesValues\n        );\n}\n"
    },
    "src/utils/Types.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {Steel} from \"risc0/steel/Steel.sol\";\n\nstruct SteelProofData {\n    //Block hash commitment for Steel\n    Steel.Commitment commitment;\n    //Seal for Steel\n    bytes seal;\n}\n\nstruct CredentialProofData {\n    //Journal Data for Steel\n    CredentialJournal journal;\n    //Seal for Steel\n    bytes seal;\n}\n\n// @notice Journal that is committed to for Credentials\nstruct CredentialJournal {\n    //Block hash commitment for Steel\n    Steel.Commitment commitment;\n    //Id of the investor\n    bytes32 investorId;\n    //Credential expiry timestamp\n    uint64 expiryTimestamp;\n    //Ids of instruments the investor is registered for\n    bytes32[] instrumentIds;\n    //Access expiry timestamps for instruments the investor is registered for\n    uint64[] instrumentExpiryTimestamps;\n    address policyViewer;\n}\n\nstruct OrderProofData {\n    //Journal Data for Steel\n    OrderJournal journal;\n    //Seal for Steel\n    bytes seal;\n}\n\n// @notice Journal that is committed to for Orders\nstruct OrderJournal {\n    //Block hash commitment for Steel\n    Steel.Commitment commitment;\n    //Id of the investor\n    bytes32 investorId;\n    //Id of the instrument the investor is subscribing or redeeming to\n    bytes32 instrumentId;\n    //Amount the investor is subscribing or redeeming with\n    uint256 amount;\n    address policyViewer;\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.19;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "src/utils/JurisdictionEncodings.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n//The encodings used for jurisdictions are based and ordered after the ISO 3166 standard as of 2023/11/28\n//(https://en.wikipedia.org/wiki/List_of_ISO_3166_country_codes)\n//Any new additions after this date will be added at the end as to not modify existing encodings\n//allowed values are in the range of: 2^x, 0 ≤ x ≤ 255\nuint256 constant AF = 2 ** 0;\nuint256 constant AX = 2 ** 1;\nuint256 constant AL = 2 ** 2;\nuint256 constant DZ = 2 ** 3;\nuint256 constant AS = 2 ** 4;\nuint256 constant AD = 2 ** 5;\nuint256 constant AO = 2 ** 6;\nuint256 constant AI = 2 ** 7;\nuint256 constant AQ = 2 ** 8;\nuint256 constant AG = 2 ** 9;\nuint256 constant AR = 2 ** 10;\nuint256 constant AM = 2 ** 11;\nuint256 constant AW = 2 ** 12;\nuint256 constant AU = 2 ** 13;\nuint256 constant AT = 2 ** 14;\nuint256 constant AZ = 2 ** 15;\nuint256 constant BS = 2 ** 16;\nuint256 constant BH = 2 ** 17;\nuint256 constant BD = 2 ** 18;\nuint256 constant BB = 2 ** 19;\nuint256 constant BY = 2 ** 20;\nuint256 constant BE = 2 ** 21;\nuint256 constant BZ = 2 ** 22;\nuint256 constant BJ = 2 ** 23;\nuint256 constant BM = 2 ** 24;\nuint256 constant BT = 2 ** 25;\nuint256 constant BO = 2 ** 26;\nuint256 constant BQ = 2 ** 27;\nuint256 constant BA = 2 ** 28;\nuint256 constant BW = 2 ** 29;\nuint256 constant BV = 2 ** 30;\nuint256 constant BR = 2 ** 31;\nuint256 constant IO = 2 ** 32;\nuint256 constant BN = 2 ** 33;\nuint256 constant BG = 2 ** 34;\nuint256 constant BF = 2 ** 35;\nuint256 constant BI = 2 ** 36;\nuint256 constant CV = 2 ** 37;\nuint256 constant KH = 2 ** 38;\nuint256 constant CM = 2 ** 39;\nuint256 constant CA = 2 ** 40;\nuint256 constant KY = 2 ** 41;\nuint256 constant CF = 2 ** 42;\nuint256 constant TD = 2 ** 43;\nuint256 constant CL = 2 ** 44;\nuint256 constant CN = 2 ** 45;\nuint256 constant CX = 2 ** 46;\nuint256 constant CC = 2 ** 47;\nuint256 constant CO = 2 ** 48;\nuint256 constant KM = 2 ** 49;\nuint256 constant CD = 2 ** 50;\nuint256 constant CG = 2 ** 51;\nuint256 constant CK = 2 ** 52;\nuint256 constant CR = 2 ** 53;\nuint256 constant CI = 2 ** 54;\nuint256 constant HR = 2 ** 55;\nuint256 constant CU = 2 ** 56;\nuint256 constant CW = 2 ** 57;\nuint256 constant CY = 2 ** 58;\nuint256 constant CZ = 2 ** 59;\nuint256 constant DK = 2 ** 60;\nuint256 constant DJ = 2 ** 61;\nuint256 constant DM = 2 ** 62;\nuint256 constant DO = 2 ** 63;\nuint256 constant EC = 2 ** 64;\nuint256 constant EG = 2 ** 65;\nuint256 constant SV = 2 ** 66;\nuint256 constant GQ = 2 ** 67;\nuint256 constant ER = 2 ** 68;\nuint256 constant EE = 2 ** 69;\nuint256 constant SZ = 2 ** 70;\nuint256 constant ET = 2 ** 71;\nuint256 constant FK = 2 ** 72;\nuint256 constant FO = 2 ** 73;\nuint256 constant FJ = 2 ** 74;\nuint256 constant FI = 2 ** 75;\nuint256 constant FR = 2 ** 76;\nuint256 constant GF = 2 ** 77;\nuint256 constant PF = 2 ** 78;\nuint256 constant TF = 2 ** 79;\nuint256 constant GA = 2 ** 80;\nuint256 constant GM = 2 ** 81;\nuint256 constant GE = 2 ** 82;\nuint256 constant DE = 2 ** 83;\nuint256 constant GH = 2 ** 84;\nuint256 constant GI = 2 ** 85;\nuint256 constant GR = 2 ** 86;\nuint256 constant GL = 2 ** 87;\nuint256 constant GD = 2 ** 88;\nuint256 constant GP = 2 ** 89;\nuint256 constant GU = 2 ** 90;\nuint256 constant GT = 2 ** 91;\nuint256 constant GG = 2 ** 92;\nuint256 constant GN = 2 ** 93;\nuint256 constant GW = 2 ** 94;\nuint256 constant GY = 2 ** 95;\nuint256 constant HT = 2 ** 96;\nuint256 constant HM = 2 ** 97;\nuint256 constant VA = 2 ** 98;\nuint256 constant HN = 2 ** 99;\nuint256 constant HK = 2 ** 100;\nuint256 constant HU = 2 ** 101;\nuint256 constant IS = 2 ** 102;\nuint256 constant IN = 2 ** 103;\nuint256 constant ID = 2 ** 104;\nuint256 constant IR = 2 ** 105;\nuint256 constant IQ = 2 ** 106;\nuint256 constant IE = 2 ** 107;\nuint256 constant IM = 2 ** 108;\nuint256 constant IL = 2 ** 109;\nuint256 constant IT = 2 ** 110;\nuint256 constant JM = 2 ** 111;\nuint256 constant JP = 2 ** 112;\nuint256 constant JE = 2 ** 113;\nuint256 constant JO = 2 ** 114;\nuint256 constant KZ = 2 ** 115;\nuint256 constant KE = 2 ** 116;\nuint256 constant KI = 2 ** 117;\nuint256 constant KP = 2 ** 118;\nuint256 constant KR = 2 ** 119;\nuint256 constant KW = 2 ** 120;\nuint256 constant KG = 2 ** 121;\nuint256 constant LA = 2 ** 122;\nuint256 constant LV = 2 ** 123;\nuint256 constant LB = 2 ** 124;\nuint256 constant LS = 2 ** 125;\nuint256 constant LR = 2 ** 126;\nuint256 constant LY = 2 ** 127;\nuint256 constant LI = 2 ** 128;\nuint256 constant LT = 2 ** 129;\nuint256 constant LU = 2 ** 130;\nuint256 constant MO = 2 ** 131;\nuint256 constant MK = 2 ** 132;\nuint256 constant MG = 2 ** 133;\nuint256 constant MW = 2 ** 134;\nuint256 constant MY = 2 ** 135;\nuint256 constant MV = 2 ** 136;\nuint256 constant ML = 2 ** 137;\nuint256 constant MT = 2 ** 138;\nuint256 constant MH = 2 ** 139;\nuint256 constant MQ = 2 ** 140;\nuint256 constant MR = 2 ** 141;\nuint256 constant MU = 2 ** 142;\nuint256 constant YT = 2 ** 143;\nuint256 constant MX = 2 ** 144;\nuint256 constant FM = 2 ** 145;\nuint256 constant MD = 2 ** 146;\nuint256 constant MC = 2 ** 147;\nuint256 constant MN = 2 ** 148;\nuint256 constant ME = 2 ** 149;\nuint256 constant MS = 2 ** 150;\nuint256 constant MA = 2 ** 151;\nuint256 constant MZ = 2 ** 152;\nuint256 constant MM = 2 ** 153;\nuint256 constant NA = 2 ** 154;\nuint256 constant NR = 2 ** 155;\nuint256 constant NP = 2 ** 156;\nuint256 constant NL = 2 ** 157;\nuint256 constant NC = 2 ** 158;\nuint256 constant NZ = 2 ** 159;\nuint256 constant NI = 2 ** 160;\nuint256 constant NE = 2 ** 161;\nuint256 constant NG = 2 ** 162;\nuint256 constant NU = 2 ** 163;\nuint256 constant NF = 2 ** 164;\nuint256 constant MP = 2 ** 165;\nuint256 constant NO = 2 ** 166;\nuint256 constant OM = 2 ** 167;\nuint256 constant PK = 2 ** 168;\nuint256 constant PW = 2 ** 169;\nuint256 constant PS = 2 ** 170;\nuint256 constant PA = 2 ** 171;\nuint256 constant PG = 2 ** 172;\nuint256 constant PY = 2 ** 173;\nuint256 constant PE = 2 ** 174;\nuint256 constant PH = 2 ** 175;\nuint256 constant PN = 2 ** 176;\nuint256 constant PL = 2 ** 177;\nuint256 constant PT = 2 ** 178;\nuint256 constant PR = 2 ** 179;\nuint256 constant QA = 2 ** 180;\nuint256 constant RE = 2 ** 181;\nuint256 constant RO = 2 ** 182;\nuint256 constant RU = 2 ** 183;\nuint256 constant RW = 2 ** 184;\nuint256 constant BL = 2 ** 185;\nuint256 constant SH = 2 ** 186;\nuint256 constant KN = 2 ** 187;\nuint256 constant LC = 2 ** 188;\nuint256 constant MF = 2 ** 189;\nuint256 constant PM = 2 ** 190;\nuint256 constant VC = 2 ** 191;\nuint256 constant WS = 2 ** 192;\nuint256 constant SM = 2 ** 193;\nuint256 constant ST = 2 ** 194;\nuint256 constant SA = 2 ** 195;\nuint256 constant SN = 2 ** 196;\nuint256 constant RS = 2 ** 197;\nuint256 constant SC = 2 ** 198;\nuint256 constant SL = 2 ** 199;\nuint256 constant SG = 2 ** 200;\nuint256 constant SX = 2 ** 201;\nuint256 constant SK = 2 ** 202;\nuint256 constant SI = 2 ** 203;\nuint256 constant SB = 2 ** 204;\nuint256 constant SO = 2 ** 205;\nuint256 constant ZA = 2 ** 206;\nuint256 constant GS = 2 ** 207;\nuint256 constant SS = 2 ** 208;\nuint256 constant ES = 2 ** 209;\nuint256 constant LK = 2 ** 210;\nuint256 constant SD = 2 ** 211;\nuint256 constant SR = 2 ** 212;\nuint256 constant SJ = 2 ** 213;\nuint256 constant SE = 2 ** 214;\nuint256 constant CH = 2 ** 215;\nuint256 constant SY = 2 ** 216;\nuint256 constant TW = 2 ** 217;\nuint256 constant TJ = 2 ** 218;\nuint256 constant TZ = 2 ** 219;\nuint256 constant TH = 2 ** 220;\nuint256 constant TL = 2 ** 221;\nuint256 constant TG = 2 ** 222;\nuint256 constant TK = 2 ** 223;\nuint256 constant TO = 2 ** 224;\nuint256 constant TT = 2 ** 225;\nuint256 constant TN = 2 ** 226;\nuint256 constant TR = 2 ** 227;\nuint256 constant TM = 2 ** 228;\nuint256 constant TC = 2 ** 229;\nuint256 constant TV = 2 ** 230;\nuint256 constant UG = 2 ** 231;\nuint256 constant UA = 2 ** 232;\nuint256 constant AE = 2 ** 233;\nuint256 constant GB = 2 ** 234;\nuint256 constant UM = 2 ** 235;\nuint256 constant US = 2 ** 236;\nuint256 constant UY = 2 ** 237;\nuint256 constant UZ = 2 ** 238;\nuint256 constant VU = 2 ** 239;\nuint256 constant VE = 2 ** 240;\nuint256 constant VN = 2 ** 241;\nuint256 constant VG = 2 ** 242;\nuint256 constant VI = 2 ** 243;\nuint256 constant WF = 2 ** 244;\nuint256 constant EH = 2 ** 245;\nuint256 constant YE = 2 ** 246;\nuint256 constant ZM = 2 ** 247;\nuint256 constant ZW = 2 ** 248;\n//values 249-255 reserved for future additions\n"
    },
    "src/utils/LibreUUPSUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {ERC1967UtilsUpgradeable} from\n    \"openzeppelin-contracts-upgradeable/contracts/proxy/ERC1967/ERC1967UtilsUpgradeable.sol\";\nimport {UUPSUpgradeable} from \"openzeppelin-contracts-upgradeable/contracts/proxy/utils/UUPSUpgradeable.sol\";\n\nimport {PermissionedContract} from \"src/PermissionedContract.sol\";\n\n/**\n * @title LibreUUPSUpgradeable\n * @author Libre\n * @notice An extension of UUPSUpgradeable with role-based access control for upgrades.\n * @dev Integrates UUPSUpgradeable and PermissionedContract to provide secured upgrade functionalities.\n */\ncontract LibreUUPSUpgradeable is UUPSUpgradeable, PermissionedContract {\n    /// @dev Error thrown when a restricted function is called directly.\n    error LibreUUPSUpgradeable_WrongUpgradeToFunction();\n\n    /**\n     * @notice Retrieve the address of the current implementation.\n     * @return The address of the current implementation.\n     */\n    function getImplementation() external view returns (address) {\n        return ERC1967UtilsUpgradeable.getImplementation();\n    }\n\n    /**\n     * @notice Upgrade the contract to a new implementation with a specific role and optionally execute a call.\n     * @param _newImplementation The address of the new implementation contract.\n     * @param _role The role required to perform the upgrade.\n     * @param _data The data for the function call to execute after the upgrade.\n     */\n    function upgradeToWithRoleAndCall(address _newImplementation, bytes32 _role, bytes memory _data)\n        public\n        payable\n        virtual\n        onlyProxy\n    {\n        _checkRoleHasAccess(_role);\n        ERC1967UtilsUpgradeable.upgradeToAndCallUUPS(_newImplementation, _data, true);\n    }\n\n    /**\n     * @notice Override to prevent direct usage of the `upgradeToAndCall` function.\n     * @dev Always reverts with a custom error.\n     */\n    function upgradeToAndCall(address, bytes memory) public payable virtual override onlyProxy {\n        revert LibreUUPSUpgradeable_WrongUpgradeToFunction();\n    }\n\n    /**\n     * @notice Upgrade the contract to a new implementation with a specific role.\n     * @param _newImplementation The address of the new implementation contract.\n     * @param _role The role required to perform the upgrade.\n     */\n    function upgradeToWithRole(address _newImplementation, bytes32 _role) public virtual onlyProxy {\n        _checkRoleHasAccess(_role);\n        ERC1967UtilsUpgradeable.upgradeToAndCallUUPS(_newImplementation, new bytes(0), false);\n    }\n\n    /**\n     * @notice Override to prevent direct usage of the `upgradeTo` function.\n     * @dev Always reverts with a custom error.\n     */\n    function upgradeTo(address) public virtual override onlyProxy {\n        revert LibreUUPSUpgradeable_WrongUpgradeToFunction();\n    }\n\n    /**\n     * @notice Internal function to authorize an upgrade.\n     * @dev Can be overridden by derived contracts to implement custom logic.\n     * @notice param _newImplementation The address of the new implementation contract (not used).\n     */\n    function _authorizeUpgrade(address) internal view virtual override {}\n}\n"
    },
    "lib/eas-contracts/contracts/ISchemaRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { ISemver } from \"./ISemver.sol\";\n\nimport { ISchemaResolver } from \"./resolver/ISchemaResolver.sol\";\n\n/// @notice A struct representing a record for a submitted schema.\nstruct SchemaRecord {\n    bytes32 uid; // The unique identifier of the schema.\n    ISchemaResolver resolver; // Optional schema resolver.\n    bool revocable; // Whether the schema allows revocations explicitly.\n    string schema; // Custom specification of the schema (e.g., an ABI).\n}\n\n/// @title ISchemaRegistry\n/// @notice The interface of global attestation schemas for the Ethereum Attestation Service protocol.\ninterface ISchemaRegistry is ISemver {\n    /// @notice Emitted when a new schema has been registered\n    /// @param uid The schema UID.\n    /// @param registerer The address of the account used to register the schema.\n    /// @param schema The schema data.\n    event Registered(bytes32 indexed uid, address indexed registerer, SchemaRecord schema);\n\n    /// @notice Submits and reserves a new schema\n    /// @param schema The schema data schema.\n    /// @param resolver An optional schema resolver.\n    /// @param revocable Whether the schema allows revocations explicitly.\n    /// @return The UID of the new schema.\n    function register(string calldata schema, ISchemaResolver resolver, bool revocable) external returns (bytes32);\n\n    /// @notice Returns an existing schema by UID\n    /// @param uid The UID of the schema to retrieve.\n    /// @return The schema data members.\n    function getSchema(bytes32 uid) external view returns (SchemaRecord memory);\n}\n"
    },
    "lib/eas-contracts/contracts/ISemver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/// @title ISemver\n/// @notice A semver interface.\ninterface ISemver {\n    /// @notice Returns the full semver contract version.\n    /// @return Semver contract version as a string.\n    function version() external view returns (string memory);\n}\n"
    },
    "lib/eas-contracts/contracts/Common.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n// A representation of an empty/uninitialized UID.\nbytes32 constant EMPTY_UID = 0;\n\n// A zero expiration represents an non-expiring attestation.\nuint64 constant NO_EXPIRATION_TIME = 0;\n\nerror AccessDenied();\nerror DeadlineExpired();\nerror InvalidEAS();\nerror InvalidLength();\nerror InvalidSignature();\nerror NotFound();\n\n/// @notice A struct representing ECDSA signature data.\nstruct Signature {\n    uint8 v; // The recovery ID.\n    bytes32 r; // The x-coordinate of the nonce R.\n    bytes32 s; // The signature data.\n}\n\n/// @notice A struct representing a single attestation.\nstruct Attestation {\n    bytes32 uid; // A unique identifier of the attestation.\n    bytes32 schema; // The unique identifier of the schema.\n    uint64 time; // The time when the attestation was created (Unix timestamp).\n    uint64 expirationTime; // The time when the attestation expires (Unix timestamp).\n    uint64 revocationTime; // The time when the attestation was revoked (Unix timestamp).\n    bytes32 refUID; // The UID of the related attestation.\n    address recipient; // The recipient of the attestation.\n    address attester; // The attester/sender of the attestation.\n    bool revocable; // Whether the attestation is revocable.\n    bytes data; // Custom attestation data.\n}\n\n/// @notice A helper function to work with unchecked iterators in loops.\nfunction uncheckedInc(uint256 i) pure returns (uint256 j) {\n    unchecked {\n        j = i + 1;\n    }\n}\n"
    },
    "lib/risc0-ethereum/contracts/src/Util.sol": {
      "content": "// Copyright 2024 RISC Zero, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n\npragma solidity ^0.8.9;\n\n/// @notice reverse the byte order of the uint256 value.\n/// @dev Solidity uses a big-endian ABI encoding. Reversing the byte order before encoding\n/// ensure that the encoded value will be little-endian.\n/// Written by k06a. https://ethereum.stackexchange.com/a/83627\nfunction reverseByteOrderUint256(uint256 input) pure returns (uint256 v) {\n    v = input;\n\n    // swap bytes\n    v = ((v & 0xFF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00) >> 8)\n        | ((v & 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) << 8);\n\n    // swap 2-byte long pairs\n    v = ((v & 0xFFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000) >> 16)\n        | ((v & 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) << 16);\n\n    // swap 4-byte long pairs\n    v = ((v & 0xFFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000) >> 32)\n        | ((v & 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) << 32);\n\n    // swap 8-byte long pairs\n    v = ((v & 0xFFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF0000000000000000) >> 64)\n        | ((v & 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) << 64);\n\n    // swap 16-byte long pairs\n    v = (v >> 128) | (v << 128);\n}\n\n/// @notice reverse the byte order of the uint32 value.\n/// @dev Solidity uses a big-endian ABI encoding. Reversing the byte order before encoding\n/// ensure that the encoded value will be little-endian.\n/// Written by k06a. https://ethereum.stackexchange.com/a/83627\nfunction reverseByteOrderUint32(uint32 input) pure returns (uint32 v) {\n    v = input;\n\n    // swap bytes\n    v = ((v & 0xFF00FF00) >> 8) | ((v & 0x00FF00FF) << 8);\n\n    // swap 2-byte long pairs\n    v = (v >> 16) | (v << 16);\n}\n\n/// @notice reverse the byte order of the uint16 value.\n/// @dev Solidity uses a big-endian ABI encoding. Reversing the byte order before encoding\n/// ensure that the encoded value will be little-endian.\n/// Written by k06a. https://ethereum.stackexchange.com/a/83627\nfunction reverseByteOrderUint16(uint16 input) pure returns (uint16 v) {\n    v = input;\n\n    // swap bytes\n    v = (v >> 8) | ((v & 0x00FF) << 8);\n}\n"
    },
    "src/interfaces/ILibreCoreGateway.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {IInvestorRegistry} from \"src/interfaces/IInvestorRegistry.sol\";\nimport {IInstrumentRegistry} from \"src/interfaces/IInstrumentRegistry.sol\";\nimport {IRoleRegistry} from \"src/interfaces/IRoleRegistry.sol\";\nimport {IGatewayManager} from \"src/interfaces/IGatewayManager.sol\";\nimport {Attestation} from \"eas-contracts/IEAS.sol\";\n\n/**\n * @notice Structure representing token transfer details across chains\n * @dev Used for both locking and unlocking operations\n */\nstruct TokenTransfer {\n    uint16 chainSelector; // Unique 16-bit Custom Chain ID where the Token is transfered\n    bytes32 instrumentId; // Instrument ID associated with the security token\n    bytes32 investorId; // Investor ID associated with the sender\n    bytes receiver; // Recipient's address for minting/unlocking\n    uint256 amount; // Amount of the asset to transfer\n}\n\n/**\n * @notice Structure for managing investor addresses across specific chain\n * @dev Each address change is encoded as: [1 byte action][n bytes address]\n */\nstruct ChainInvestorAddresses {\n    // Unique investor ID\n    bytes32 investorId;\n    // Unique chain ID\n    uint16 chainSelector;\n    // Address size for that chain\n    uint8 addressSize;\n    // A list of concatenated bytes describing a change in addresses\n    // Format `addressChanges`` := bytes1 action ++ bytes accountAddress\n    // where `action`: 0b0 -> Add, 0b1 -> Remove\n    bytes[] addressChanges;\n}\n\n/// @notice Interface for the Libre Core Gateway.\ninterface ILibreCoreGateway {\n    // Events\n    /**\n     * @notice Emitted when tokens are locked on source chain\n     * @param encodedTransferDetails ABI-encoded TokenTransfer struct\n     */\n    event TokenLockedAndBridged(bytes encodedTransferDetails);\n\n    /**\n     * @notice Emitted when tokens are unlocked on destination chain\n     * @param encodedTransferDetails ABI-encoded TokenTransfer struct\n     */\n    event TokenUnlocked(bytes encodedTransferDetails);\n\n    /**\n     * @notice Emitted when a credential is bridged to other chains\n     * @param investorId Investor ID of the investor\n     * @param chainSelectors Array of investor preffered chains on which credential to be bridged\n     * @param credentialId Unique identifier of the bridged credential\n     */\n    event CredentialBridged(bytes32 investorId, uint16[] chainSelectors, bytes32 credentialId);\n\n    /**\n     * @notice Emitted when investor chain-specific addresses are bridged\n     * @param investorId Investor ID of the investor\n     * @param chainSelectors Array of investor preferred chains on which addresses updates to be bridged\n     * @param encodedChainInvestorAddresses ABI-encoded ChainInvestorAddresses struct\n     */\n    event ChainInvestorAddressesBridged(\n        bytes32 investorId, uint16[] chainSelectors, bytes encodedChainInvestorAddresses\n    );\n\n    /**\n     * @notice Emitted when chain support status is updated\n     * @param chainSelector Chain ID whose support status changed\n     * @param isSupported New support status\n     */\n    event ChainSupportUpdated(uint16 chainSelector, bool isSupported);\n\n    /**\n     * @notice Emitted when chain variable length address support status is updated\n     * @param _chainSelector Chain ID whose support status changed\n     * @param _isVariableLengthAddress New support status\n     */\n    event ChainVariableLengthAddressSupportUpdated(uint16 _chainSelector, bool _isVariableLengthAddress);\n\n    // Custom Errors\n    /// @notice Thrown when operation is attempted on an unsupported chain\n    /// @param chainSelector The unsupported chain ID\n    error CoreGateway_ChainNotSupported(uint16 chainSelector);\n\n    /// @notice Thrown when the chain selector (chain ID) not matches with Native chain ID for unlock requests\n    error CoreGateway_InvalidNativeChainSelector();\n\n    /// @notice Thrown when token address is not found or invalid\n    /// @param token The invalid token address\n    error CoreGateway_TokenAddressNotFound(address token);\n\n    /// @notice Thrown when attempting transfer with zero amount\n    error CoreGateway_ZeroAmount();\n\n    /// @notice Thrown when transfer validation fails\n    error CoreGateway_InvalidTransfer();\n\n    /// @notice Thrown when provided investor id is not found\n    error CoreGateway_InvalidInvestor();\n\n    /// @notice Thrown when wrong inputs are provided\n    error CoreGateway_InvalidInput();\n\n    /// @notice Thrown when credential to be bridged are not stored or mismatches with registry\n    error CoreGateway_InvalidCredential();\n\n    /// @notice Thrown when an attempted status update results in no actual change.\n    error CoreGateway_NoStatusChanged();\n\n    /**\n     * @notice Initializes the gateway contract\n     * @param _instrumentRegistry Address of the Instrument Registry\n     * @param _investorRegistry Address of the Investor Registry\n     * @param _gatewayManager Address of the Gateway Manager\n     * @param _roleRegistry Address of the Role Registry\n     * @param _nativeChainSelector Native Custom Chain ID\n     * @param _supportedChains Array of supported custom chain Ids\n     */\n    function initialize(\n        IInstrumentRegistry _instrumentRegistry,\n        IInvestorRegistry _investorRegistry,\n        IGatewayManager _gatewayManager,\n        IRoleRegistry _roleRegistry,\n        uint16 _nativeChainSelector,\n        uint16[] memory _supportedChains\n    ) external;\n\n    /**\n     * @notice Locks tokens for cross-chain transfer and emits event for minting\n     * @dev Validates investor credentials and cross-chain addresses before locking\n     * @param transferDetails The details of the token transfer.\n     */\n    function lockAndBridge(TokenTransfer calldata transferDetails) external;\n\n    /**\n     * @notice Unlocks tokens on the source chain\n     * @dev Called by bridge operators to release tokens to the recipient\n     * @param _senderRole The role of the caller\n     * @param encodedTransferDetails ABI-encoded transfer details.\n     */\n    function unlock(bytes32 _senderRole, bytes calldata encodedTransferDetails) external;\n\n    /**\n     * @notice Bridges a credential to one or more destination chains.\n     * @dev Perform below steps:\n     *      1. Verifies all destination chains are supported\n     *      2. Validates the attestation matches the stored credential for the investor\n     *      3. Emits CredentialBridged event for cross-chain communication\n     * @param _senderRole The role of the caller\n     * @param attestation The attestation details to bridge.\n     * @param destinationChainSelectors Array of destination chain IDs.\n     */\n    function bridgeCredential(\n        bytes32 _senderRole,\n        Attestation calldata attestation,\n        uint16[] calldata destinationChainSelectors\n    ) external;\n\n    /**\n     * @notice Bridges investor addresses updates.\n     * @dev Processes and broadcasts chain specific address changes across investor preferred chains\n     *         Emits `ChainInvestorAddressesBridged` event for each chain's address updates.\n     *\n     * @param _senderRole The role of the caller.\n     * @param _investorId The unique identifier of the investor whose addresses are being updated.\n     * @param _addressChanges ABI-encoded updates representing address changes per chain or context.\n     * @param chainSelectors Array of investor preferred chains on which addresses updates to be bridged\n     */\n    function bridgeInvestorAddresses(\n        bytes32 _senderRole,\n        bytes32 _investorId,\n        bytes[] calldata _addressChanges,\n        uint16[] calldata chainSelectors\n    ) external;\n\n    /**\n     * @notice Pauses all gateway operations\n     * @param _senderRole The role of the caller\n     */\n    function pause(bytes32 _senderRole) external;\n\n    /**\n     * @notice Unpauses gateway operations\n     * @param _senderRole The role of the caller\n     */\n    function unpause(bytes32 _senderRole) external;\n\n    /**\n     * @notice Enables or disables support for a specific chain.\n     * @param _senderRole The role of the caller\n     * @param chainSelector The Custom chain ID.\n     * @param isSupported Whether the chain is supported.\n     */\n    function setChainSupport(bytes32 _senderRole, uint16 chainSelector, bool isSupported) external;\n\n    /**\n     * @notice Enables or disables support for variable length addresses for a specific chain.\n     * @param _senderRole The role of the caller\n     * @param _chainSelector The Custom chain ID.\n     * @param _isVariableLengthAddress Whether variable length addresses for the chain are supported.\n     */\n    function setChainVariableLengthAddressSupport(\n        bytes32 _senderRole,\n        uint16 _chainSelector,\n        bool _isVariableLengthAddress\n    ) external;\n\n    /**\n     * @notice Retrieves the total amount of a specific instrument/token locked in the gateway.\n     * @param instrumentId The Instrument ID associated with the security token\n     * @return The total amount of the token locked in the gateway\n     */\n    function getLockedBalance(bytes32 instrumentId) external view returns (uint256);\n\n    /**\n     * @notice Checks if a chain is supported.\n     * @param chainSelector The ID of the chain to check.\n     * @return True if the chain is supported, false otherwise.\n     */\n    function isSupportedChain(uint16 chainSelector) external view returns (bool);\n\n    /**\n     * @notice Gets the list of supported chains\n     * @return uint16[] Array of supported chain IDs\n     */\n    function getSupportedChains() external view returns (uint16[] memory);\n}\n"
    },
    "lib/risc0-ethereum/contracts/src/steel/Steel.sol": {
      "content": "// Copyright 2024 RISC Zero, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n\npragma solidity ^0.8.9;\n\n/// @title Steel Library\n/// @notice This library provides a collection of utilities to work with Steel commitments in Solidity.\nlibrary Steel {\n    /// @notice Represents a commitment to a specific block in the blockchain.\n    /// @dev The `id` combines the version and the actual identifier of the claim, such as the block number.\n    /// @dev The `digest` represents the data being committed to, e.g. the hash of the execution block.\n    /// @dev The `configID` is the cryptographic digest of the network configuration.\n    struct Commitment {\n        uint256 id;\n        bytes32 digest;\n        bytes32 configID;\n    }\n\n    /// @notice The version of the Commitment is incorrect.\n    error InvalidCommitmentVersion();\n\n    /// @notice The Commitment is too old and can no longer be validated.\n    error CommitmentTooOld();\n\n    /// @notice Validates if the provided Commitment matches the block hash of the given block number.\n    /// @param commitment The Commitment struct to validate.\n    /// @return True if the commitment's block hash matches the block hash of the block number, false otherwise.\n    function validateCommitment(Commitment memory commitment) internal view returns (bool) {\n        (uint240 claimID, uint16 version) = Encoding.decodeVersionedID(commitment.id);\n        if (version == 0) {\n            return validateBlockCommitment(claimID, commitment.digest);\n        } else if (version == 1) {\n            return validateBeaconCommitment(claimID, commitment.digest);\n        } else {\n            revert InvalidCommitmentVersion();\n        }\n    }\n\n    /// @notice Validates if the provided block commitment matches the block hash of the given block number.\n    /// @param blockNumber The block number to compare against.\n    /// @param blockHash The block hash to validate.\n    /// @return True if the block's block hash matches the block hash, false otherwise.\n    function validateBlockCommitment(uint256 blockNumber, bytes32 blockHash) internal view returns (bool) {\n        if (block.number - blockNumber > 256) {\n            revert CommitmentTooOld();\n        }\n        return blockHash == blockhash(blockNumber);\n    }\n\n    /// @notice Validates if the provided beacon commitment matches the block root of the given timestamp.\n    /// @param timestamp The timestamp to compare against.\n    /// @param blockRoot The block root to validate.\n    /// @return True if the block's block root matches the block root, false otherwise.\n    function validateBeaconCommitment(uint256 timestamp, bytes32 blockRoot) internal view returns (bool) {\n        if (block.timestamp - timestamp > 12 * 8191) {\n            revert CommitmentTooOld();\n        }\n        return blockRoot == Beacon.parentBlockRoot(timestamp);\n    }\n}\n\n/// @title Beacon Library\nlibrary Beacon {\n    /// @notice The address of the Beacon roots contract.\n    /// @dev https://eips.ethereum.org/EIPS/eip-4788\n    address internal constant BEACON_ROOTS_ADDRESS = 0x000F3df6D732807Ef1319fB7B8bB8522d0Beac02;\n\n    /// @notice Find the root of the Beacon block corresponding to the parent of the execution block with the given timestamp.\n    /// @return root Returns the corresponding Beacon block root or null, if no such block exists.\n    function parentBlockRoot(uint256 timestamp) internal view returns (bytes32 root) {\n        (bool success, bytes memory result) = BEACON_ROOTS_ADDRESS.staticcall(abi.encode(timestamp));\n        if (success) {\n            return abi.decode(result, (bytes32));\n        }\n    }\n}\n\n/// @title Encoding Library\nlibrary Encoding {\n    /// @notice Encodes a version and ID into a single uint256 value.\n    /// @param id The base ID to be encoded, limited by 240 bits (or the maximum value of a uint240).\n    /// @param version The version number to be encoded, limited by 16 bits (or the maximum value of a uint16).\n    /// @return Returns a single uint256 value that contains both the `id` and the `version` encoded into it.\n    function encodeVersionedID(uint240 id, uint16 version) internal pure returns (uint256) {\n        uint256 encoded;\n        assembly {\n            encoded := or(shl(240, version), id)\n        }\n        return encoded;\n    }\n\n    /// @notice Decodes a version and ID from a single uint256 value.\n    /// @param id The single uint256 value to be decoded.\n    /// @return Returns two values: a uint240 for the original base ID and a uint16 for the version number encoded into it.\n    function decodeVersionedID(uint256 id) internal pure returns (uint240, uint16) {\n        uint240 decoded;\n        uint16 version;\n        assembly {\n            decoded := and(id, 0x0000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n            version := shr(240, id)\n        }\n        return (decoded, version);\n    }\n}\n"
    },
    "lib/openzeppelin-contracts-upgradeable/contracts/proxy/ERC1967/ERC1967UtilsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/ERC1967/ERC1967Utils.sol)\n\npragma solidity ^0.8.20;\n\nimport \"../beacon/IBeaconUpgradeable.sol\";\nimport \"../../interfaces/IERC1967Upgradeable.sol\";\nimport \"../../interfaces/draft-IERC1822Upgradeable.sol\";\nimport \"../../utils/AddressUpgradeable.sol\";\nimport \"../../utils/StorageSlotUpgradeable.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n */\nlibrary ERC1967UtilsUpgradeable {\n    // We re-declare ERC-1967 events here because they can't be used directly from IERC1967.\n    // This will be fixed in Solidity 0.8.21. At that point we should remove these events.\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Emitted when the beacon is changed.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev The `implementation` of the proxy is invalid.\n     */\n    error ERC1967InvalidImplementation(address implementation);\n\n    /**\n     * @dev The `admin` of the proxy is invalid.\n     */\n    error ERC1967InvalidAdmin(address admin);\n\n    /**\n     * @dev The `beacon` of the proxy is invalid.\n     */\n    error ERC1967InvalidBeacon(address beacon);\n\n    /**\n     * @dev The storage `slot` is unsupported as a UUID.\n     */\n    error ERC1967UnsupportedProxiableUUID(bytes32 slot);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function getImplementation() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        if (newImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(newImplementation);\n        }\n        StorageSlotUpgradeable.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {IERC1967-Upgraded} event.\n     */\n    function upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {IERC1967-Upgraded} event.\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\n        upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {IERC1967-Upgraded} event.\n     */\n    function upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822ProxiableUpgradeable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                if (slot != IMPLEMENTATION_SLOT) {\n                    revert ERC1967UnsupportedProxiableUUID(slot);\n                }\n            } catch {\n                // The implementation is not UUPS\n                revert ERC1967InvalidImplementation(newImplementation);\n            }\n            upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function getAdmin() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        if (newAdmin == address(0)) {\n            revert ERC1967InvalidAdmin(address(0));\n        }\n        StorageSlotUpgradeable.getAddressSlot(ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {IERC1967-AdminChanged} event.\n     */\n    function changeAdmin(address newAdmin) internal {\n        emit AdminChanged(getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1) and is validated in the constructor.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function getBeacon() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        if (newBeacon.code.length == 0) {\n            revert ERC1967InvalidBeacon(newBeacon);\n        }\n\n        address beaconImplementation = IBeaconUpgradeable(newBeacon).implementation();\n        if (beaconImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(beaconImplementation);\n        }\n\n        StorageSlotUpgradeable.getAddressSlot(BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits an {IERC1967-BeaconUpgraded} event.\n     */\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\n        }\n    }\n}\n"
    },
    "lib/openzeppelin-contracts-upgradeable/contracts/proxy/utils/UUPSUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/UUPSUpgradeable.sol)\n\npragma solidity ^0.8.19;\n\nimport \"../../interfaces/draft-IERC1822Upgradeable.sol\";\nimport \"../ERC1967/ERC1967UtilsUpgradeable.sol\";\nimport \"./Initializable.sol\";\n\n/**\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\n *\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\n * `UUPSUpgradeable` with a custom implementation of upgrades.\n *\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\n *\n * _Available since v4.1._\n */\nabstract contract UUPSUpgradeable is Initializable, IERC1822ProxiableUpgradeable {\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\n    address private immutable __self = address(this);\n\n    /**\n     * @dev The call is from an unauthorized context.\n     */\n    error UUPSUnauthorizedCallContext();\n\n    /**\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\n     * fail.\n     */\n    modifier onlyProxy() {\n        if (address(this) == __self) {\n            // Must be called through delegatecall\n            revert UUPSUnauthorizedCallContext();\n        }\n        if (ERC1967UtilsUpgradeable.getImplementation() != __self) {\n            // Must be called through an active proxy\n            revert UUPSUnauthorizedCallContext();\n        }\n        _;\n    }\n\n    /**\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\n     * callable on the implementing contract but not through proxies.\n     */\n    modifier notDelegated() {\n        if (address(this) != __self) {\n            // Must not be called through delegatecall\n            revert UUPSUnauthorizedCallContext();\n        }\n        _;\n    }\n\n    /**\n     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\n     * implementation. It is used to validate the implementation's compatibility when performing an upgrade.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\n     */\n    function proxiableUUID() external view virtual notDelegated returns (bytes32) {\n        return ERC1967UtilsUpgradeable.IMPLEMENTATION_SLOT;\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\n     */\n    function upgradeTo(address newImplementation) public virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        ERC1967UtilsUpgradeable.upgradeToAndCallUUPS(newImplementation, new bytes(0), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\n     * encoded in `data`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        ERC1967UtilsUpgradeable.upgradeToAndCallUUPS(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\n     * {upgradeTo} and {upgradeToAndCall}.\n     *\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\n     *\n     * ```solidity\n     * function _authorizeUpgrade(address) internal  onlyOwner {}\n     * ```\n     */\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "lib/eas-contracts/contracts/resolver/ISchemaResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { Attestation } from \"./../Common.sol\";\nimport { ISemver } from \"./../ISemver.sol\";\n\n/// @title ISchemaResolver\n/// @notice The interface of an optional schema resolver.\ninterface ISchemaResolver is ISemver {\n    /// @notice Checks if the resolver can be sent ETH.\n    /// @return Whether the resolver supports ETH transfers.\n    function isPayable() external pure returns (bool);\n\n    /// @notice Processes an attestation and verifies whether it's valid.\n    /// @param attestation The new attestation.\n    /// @return Whether the attestation is valid.\n    function attest(Attestation calldata attestation) external payable returns (bool);\n\n    /// @notice Processes multiple attestations and verifies whether they are valid.\n    /// @param attestations The new attestations.\n    /// @param values Explicit ETH amounts which were sent with each attestation.\n    /// @return Whether all the attestations are valid.\n    function multiAttest(\n        Attestation[] calldata attestations,\n        uint256[] calldata values\n    ) external payable returns (bool);\n\n    /// @notice Processes an attestation revocation and verifies if it can be revoked.\n    /// @param attestation The existing attestation to be revoked.\n    /// @return Whether the attestation can be revoked.\n    function revoke(Attestation calldata attestation) external payable returns (bool);\n\n    /// @notice Processes revocation of multiple attestation and verifies they can be revoked.\n    /// @param attestations The existing attestations to be revoked.\n    /// @param values Explicit ETH amounts which were sent with each revocation.\n    /// @return Whether the attestations can be revoked.\n    function multiRevoke(\n        Attestation[] calldata attestations,\n        uint256[] calldata values\n    ) external payable returns (bool);\n}\n"
    },
    "lib/openzeppelin-contracts-upgradeable/contracts/proxy/beacon/IBeaconUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.19;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeaconUpgradeable {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "lib/openzeppelin-contracts-upgradeable/contracts/interfaces/IERC1967Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC1967.sol)\n\npragma solidity ^0.8.19;\n\n/**\n * @dev ERC-1967: Proxy Storage Slots. This interface contains the events defined in the ERC.\n *\n * _Available since v4.8.3._\n */\ninterface IERC1967Upgradeable {\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Emitted when the beacon is changed.\n     */\n    event BeaconUpgraded(address indexed beacon);\n}\n"
    },
    "lib/openzeppelin-contracts-upgradeable/contracts/interfaces/draft-IERC1822Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.19;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822ProxiableUpgradeable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "lib/openzeppelin-contracts-upgradeable/contracts/utils/StorageSlotUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.19;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(newImplementation.code.length > 0);\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, `uint256`._\n * _Available since v4.9 for `string`, `bytes`._\n */\nlibrary StorageSlotUpgradeable {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}\n"
    },
    "lib/openzeppelin-contracts-upgradeable/contracts/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.19;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev The contract is already initialized.\n     */\n    error AlreadyInitialized();\n\n    /**\n     * @dev The contract is not initializing.\n     */\n    error NotInitializing();\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        if (!(isTopLevelCall && _initialized < 1) && !(address(this).code.length == 0 && _initialized == 1)) {\n            revert AlreadyInitialized();\n        }\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        if (_initializing || _initialized >= version) {\n            revert AlreadyInitialized();\n        }\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        if (!_initializing) {\n            revert NotInitializing();\n        }\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        if (_initializing) {\n            revert AlreadyInitialized();\n        }\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n"
    }
  },
  "settings": {
    "remappings": [
      "BokkyPooBahsDateTimeLibrary/=lib/BokkyPooBahsDateTimeLibrary/",
      "ds-test/=lib/forge-std/lib/ds-test/src/",
      "forge-std/=lib/forge-std/src/",
      "openzeppelin-contracts/=lib/openzeppelin-contracts/",
      "openzeppelin/=lib/openzeppelin-contracts/",
      "@openzeppelin/=lib/openzeppelin-contracts/",
      "openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/",
      "risc0/=lib/risc0-ethereum/contracts/src/",
      "eas-contracts/=lib/eas-contracts/contracts/",
      "safe-contracts/=lib/safe-contracts/contracts/",
      "erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/",
      "risc0-ethereum/=lib/risc0-ethereum/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "metadata": {
      "useLiteralContent": false,
      "bytecodeHash": "ipfs",
      "appendCBOR": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "evmVersion": "cancun",
    "viaIR": false,
    "libraries": {
      "src/lib/SortedLinkedList.sol": {
        "SortedLinkedList": "0x07B879C1bAaeeDe4dbC7383f6342556Ef144b27F"
      },
      "src/lib/TimeOperations.sol": {
        "TimeOperations": "0x852BE1E091189E68cD8721163286172d1e162a5a"
      },
      "src/utils/GatewayUtils.sol": {
        "GatewayUtils": "0xaB8b3a4CDdcf7B83C57880926Ba940F388897D11"
      }
    }
  }
}}