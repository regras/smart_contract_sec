{{
  "language": "Solidity",
  "sources": {
    "@morpho-blue/interfaces/IIrm.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\nimport {MarketParams, Market} from \"./IMorpho.sol\";\n\n/// @title IIrm\n/// @author Morpho Labs\n/// @custom:contact security@morpho.org\n/// @notice Interface that Interest Rate Models (IRMs) used by Morpho must implement.\ninterface IIrm {\n    /// @notice Returns the borrow rate per second (scaled by WAD) of the market `marketParams`.\n    /// @dev Assumes that `market` corresponds to `marketParams`.\n    function borrowRate(MarketParams memory marketParams, Market memory market) external returns (uint256);\n\n    /// @notice Returns the borrow rate per second (scaled by WAD) of the market `marketParams` without modifying any\n    /// storage.\n    /// @dev Assumes that `market` corresponds to `marketParams`.\n    function borrowRateView(MarketParams memory marketParams, Market memory market) external view returns (uint256);\n}\n"
    },
    "@morpho-blue/interfaces/IMorpho.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\ntype Id is bytes32;\n\nstruct MarketParams {\n    address loanToken;\n    address collateralToken;\n    address oracle;\n    address irm;\n    uint256 lltv;\n}\n\n/// @dev Warning: For `feeRecipient`, `supplyShares` does not contain the accrued shares since the last interest\n/// accrual.\nstruct Position {\n    uint256 supplyShares;\n    uint128 borrowShares;\n    uint128 collateral;\n}\n\n/// @dev Warning: `totalSupplyAssets` does not contain the accrued interest since the last interest accrual.\n/// @dev Warning: `totalBorrowAssets` does not contain the accrued interest since the last interest accrual.\n/// @dev Warning: `totalSupplyShares` does not contain the additional shares accrued by `feeRecipient` since the last\n/// interest accrual.\nstruct Market {\n    uint128 totalSupplyAssets;\n    uint128 totalSupplyShares;\n    uint128 totalBorrowAssets;\n    uint128 totalBorrowShares;\n    uint128 lastUpdate;\n    uint128 fee;\n}\n\nstruct Authorization {\n    address authorizer;\n    address authorized;\n    bool isAuthorized;\n    uint256 nonce;\n    uint256 deadline;\n}\n\nstruct Signature {\n    uint8 v;\n    bytes32 r;\n    bytes32 s;\n}\n\n/// @dev This interface is used for factorizing IMorphoStaticTyping and IMorpho.\n/// @dev Consider using the IMorpho interface instead of this one.\ninterface IMorphoBase {\n    /// @notice The EIP-712 domain separator.\n    /// @dev Warning: Every EIP-712 signed message based on this domain separator can be reused on chains sharing the\n    /// same chain id and on forks because the domain separator would be the same.\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    /// @notice The owner of the contract.\n    /// @dev It has the power to change the owner.\n    /// @dev It has the power to set fees on markets and set the fee recipient.\n    /// @dev It has the power to enable but not disable IRMs and LLTVs.\n    function owner() external view returns (address);\n\n    /// @notice The fee recipient of all markets.\n    /// @dev The recipient receives the fees of a given market through a supply position on that market.\n    function feeRecipient() external view returns (address);\n\n    /// @notice Whether the `irm` is enabled.\n    function isIrmEnabled(address irm) external view returns (bool);\n\n    /// @notice Whether the `lltv` is enabled.\n    function isLltvEnabled(uint256 lltv) external view returns (bool);\n\n    /// @notice Whether `authorized` is authorized to modify `authorizer`'s position on all markets.\n    /// @dev Anyone is authorized to modify their own positions, regardless of this variable.\n    function isAuthorized(address authorizer, address authorized) external view returns (bool);\n\n    /// @notice The `authorizer`'s current nonce. Used to prevent replay attacks with EIP-712 signatures.\n    function nonce(address authorizer) external view returns (uint256);\n\n    /// @notice Sets `newOwner` as `owner` of the contract.\n    /// @dev Warning: No two-step transfer ownership.\n    /// @dev Warning: The owner can be set to the zero address.\n    function setOwner(address newOwner) external;\n\n    /// @notice Enables `irm` as a possible IRM for market creation.\n    /// @dev Warning: It is not possible to disable an IRM.\n    function enableIrm(address irm) external;\n\n    /// @notice Enables `lltv` as a possible LLTV for market creation.\n    /// @dev Warning: It is not possible to disable a LLTV.\n    function enableLltv(uint256 lltv) external;\n\n    /// @notice Sets the `newFee` for the given market `marketParams`.\n    /// @param newFee The new fee, scaled by WAD.\n    /// @dev Warning: The recipient can be the zero address.\n    function setFee(MarketParams memory marketParams, uint256 newFee) external;\n\n    /// @notice Sets `newFeeRecipient` as `feeRecipient` of the fee.\n    /// @dev Warning: If the fee recipient is set to the zero address, fees will accrue there and will be lost.\n    /// @dev Modifying the fee recipient will allow the new recipient to claim any pending fees not yet accrued. To\n    /// ensure that the current recipient receives all due fees, accrue interest manually prior to making any changes.\n    function setFeeRecipient(address newFeeRecipient) external;\n\n    /// @notice Creates the market `marketParams`.\n    /// @dev Here is the list of assumptions on the market's dependencies (tokens, IRM and oracle) that guarantees\n    /// Morpho behaves as expected:\n    /// - The token should be ERC-20 compliant, except that it can omit return values on `transfer` and `transferFrom`.\n    /// - The token balance of Morpho should only decrease on `transfer` and `transferFrom`. In particular, tokens with\n    /// burn functions are not supported.\n    /// - The token should not re-enter Morpho on `transfer` nor `transferFrom`.\n    /// - The token balance of the sender (resp. receiver) should decrease (resp. increase) by exactly the given amount\n    /// on `transfer` and `transferFrom`. In particular, tokens with fees on transfer are not supported.\n    /// - The IRM should not re-enter Morpho.\n    /// - The oracle should return a price with the correct scaling.\n    /// @dev Here is a list of properties on the market's dependencies that could break Morpho's liveness properties\n    /// (funds could get stuck):\n    /// - The token can revert on `transfer` and `transferFrom` for a reason other than an approval or balance issue.\n    /// - A very high amount of assets (~1e35) supplied or borrowed can make the computation of `toSharesUp` and\n    /// `toSharesDown` overflow.\n    /// - The IRM can revert on `borrowRate`.\n    /// - A very high borrow rate returned by the IRM can make the computation of `interest` in `_accrueInterest`\n    /// overflow.\n    /// - The oracle can revert on `price`. Note that this can be used to prevent `borrow`, `withdrawCollateral` and\n    /// `liquidate` from being used under certain market conditions.\n    /// - A very high price returned by the oracle can make the computation of `maxBorrow` in `_isHealthy` overflow, or\n    /// the computation of `assetsRepaid` in `liquidate` overflow.\n    /// @dev The borrow share price of a market with less than 1e4 assets borrowed can be decreased by manipulations, to\n    /// the point where `totalBorrowShares` is very large and borrowing overflows.\n    function createMarket(MarketParams memory marketParams) external;\n\n    /// @notice Supplies `assets` or `shares` on behalf of `onBehalf`, optionally calling back the caller's\n    /// `onMorphoSupply` function with the given `data`.\n    /// @dev Either `assets` or `shares` should be zero. Most use cases should rely on `assets` as an input so the\n    /// caller is guaranteed to have `assets` tokens pulled from their balance, but the possibility to mint a specific\n    /// amount of shares is given for full compatibility and precision.\n    /// @dev Supplying a large amount can revert for overflow.\n    /// @dev Supplying an amount of shares may lead to supply more or fewer assets than expected due to slippage.\n    /// Consider using the `assets` parameter to avoid this.\n    /// @param marketParams The market to supply assets to.\n    /// @param assets The amount of assets to supply.\n    /// @param shares The amount of shares to mint.\n    /// @param onBehalf The address that will own the increased supply position.\n    /// @param data Arbitrary data to pass to the `onMorphoSupply` callback. Pass empty data if not needed.\n    /// @return assetsSupplied The amount of assets supplied.\n    /// @return sharesSupplied The amount of shares minted.\n    function supply(\n        MarketParams memory marketParams,\n        uint256 assets,\n        uint256 shares,\n        address onBehalf,\n        bytes memory data\n    ) external returns (uint256 assetsSupplied, uint256 sharesSupplied);\n\n    /// @notice Withdraws `assets` or `shares` on behalf of `onBehalf` and sends the assets to `receiver`.\n    /// @dev Either `assets` or `shares` should be zero. To withdraw max, pass the `shares`'s balance of `onBehalf`.\n    /// @dev `msg.sender` must be authorized to manage `onBehalf`'s positions.\n    /// @dev Withdrawing an amount corresponding to more shares than supplied will revert for underflow.\n    /// @dev It is advised to use the `shares` input when withdrawing the full position to avoid reverts due to\n    /// conversion roundings between shares and assets.\n    /// @param marketParams The market to withdraw assets from.\n    /// @param assets The amount of assets to withdraw.\n    /// @param shares The amount of shares to burn.\n    /// @param onBehalf The address of the owner of the supply position.\n    /// @param receiver The address that will receive the withdrawn assets.\n    /// @return assetsWithdrawn The amount of assets withdrawn.\n    /// @return sharesWithdrawn The amount of shares burned.\n    function withdraw(\n        MarketParams memory marketParams,\n        uint256 assets,\n        uint256 shares,\n        address onBehalf,\n        address receiver\n    ) external returns (uint256 assetsWithdrawn, uint256 sharesWithdrawn);\n\n    /// @notice Borrows `assets` or `shares` on behalf of `onBehalf` and sends the assets to `receiver`.\n    /// @dev Either `assets` or `shares` should be zero. Most use cases should rely on `assets` as an input so the\n    /// caller is guaranteed to borrow `assets` of tokens, but the possibility to mint a specific amount of shares is\n    /// given for full compatibility and precision.\n    /// @dev `msg.sender` must be authorized to manage `onBehalf`'s positions.\n    /// @dev Borrowing a large amount can revert for overflow.\n    /// @dev Borrowing an amount of shares may lead to borrow fewer assets than expected due to slippage.\n    /// Consider using the `assets` parameter to avoid this.\n    /// @param marketParams The market to borrow assets from.\n    /// @param assets The amount of assets to borrow.\n    /// @param shares The amount of shares to mint.\n    /// @param onBehalf The address that will own the increased borrow position.\n    /// @param receiver The address that will receive the borrowed assets.\n    /// @return assetsBorrowed The amount of assets borrowed.\n    /// @return sharesBorrowed The amount of shares minted.\n    function borrow(\n        MarketParams memory marketParams,\n        uint256 assets,\n        uint256 shares,\n        address onBehalf,\n        address receiver\n    ) external returns (uint256 assetsBorrowed, uint256 sharesBorrowed);\n\n    /// @notice Repays `assets` or `shares` on behalf of `onBehalf`, optionally calling back the caller's\n    /// `onMorphoRepay` function with the given `data`.\n    /// @dev Either `assets` or `shares` should be zero. To repay max, pass the `shares`'s balance of `onBehalf`.\n    /// @dev Repaying an amount corresponding to more shares than borrowed will revert for underflow.\n    /// @dev It is advised to use the `shares` input when repaying the full position to avoid reverts due to conversion\n    /// roundings between shares and assets.\n    /// @dev An attacker can front-run a repay with a small repay making the transaction revert for underflow.\n    /// @param marketParams The market to repay assets to.\n    /// @param assets The amount of assets to repay.\n    /// @param shares The amount of shares to burn.\n    /// @param onBehalf The address of the owner of the debt position.\n    /// @param data Arbitrary data to pass to the `onMorphoRepay` callback. Pass empty data if not needed.\n    /// @return assetsRepaid The amount of assets repaid.\n    /// @return sharesRepaid The amount of shares burned.\n    function repay(\n        MarketParams memory marketParams,\n        uint256 assets,\n        uint256 shares,\n        address onBehalf,\n        bytes memory data\n    ) external returns (uint256 assetsRepaid, uint256 sharesRepaid);\n\n    /// @notice Supplies `assets` of collateral on behalf of `onBehalf`, optionally calling back the caller's\n    /// `onMorphoSupplyCollateral` function with the given `data`.\n    /// @dev Interest are not accrued since it's not required and it saves gas.\n    /// @dev Supplying a large amount can revert for overflow.\n    /// @param marketParams The market to supply collateral to.\n    /// @param assets The amount of collateral to supply.\n    /// @param onBehalf The address that will own the increased collateral position.\n    /// @param data Arbitrary data to pass to the `onMorphoSupplyCollateral` callback. Pass empty data if not needed.\n    function supplyCollateral(MarketParams memory marketParams, uint256 assets, address onBehalf, bytes memory data)\n        external;\n\n    /// @notice Withdraws `assets` of collateral on behalf of `onBehalf` and sends the assets to `receiver`.\n    /// @dev `msg.sender` must be authorized to manage `onBehalf`'s positions.\n    /// @dev Withdrawing an amount corresponding to more collateral than supplied will revert for underflow.\n    /// @param marketParams The market to withdraw collateral from.\n    /// @param assets The amount of collateral to withdraw.\n    /// @param onBehalf The address of the owner of the collateral position.\n    /// @param receiver The address that will receive the collateral assets.\n    function withdrawCollateral(MarketParams memory marketParams, uint256 assets, address onBehalf, address receiver)\n        external;\n\n    /// @notice Liquidates the given `repaidShares` of debt asset or seize the given `seizedAssets` of collateral on the\n    /// given market `marketParams` of the given `borrower`'s position, optionally calling back the caller's\n    /// `onMorphoLiquidate` function with the given `data`.\n    /// @dev Either `seizedAssets` or `repaidShares` should be zero.\n    /// @dev Seizing more than the collateral balance will underflow and revert without any error message.\n    /// @dev Repaying more than the borrow balance will underflow and revert without any error message.\n    /// @dev An attacker can front-run a liquidation with a small repay making the transaction revert for underflow.\n    /// @param marketParams The market of the position.\n    /// @param borrower The owner of the position.\n    /// @param seizedAssets The amount of collateral to seize.\n    /// @param repaidShares The amount of shares to repay.\n    /// @param data Arbitrary data to pass to the `onMorphoLiquidate` callback. Pass empty data if not needed.\n    /// @return The amount of assets seized.\n    /// @return The amount of assets repaid.\n    function liquidate(\n        MarketParams memory marketParams,\n        address borrower,\n        uint256 seizedAssets,\n        uint256 repaidShares,\n        bytes memory data\n    ) external returns (uint256, uint256);\n\n    /// @notice Executes a flash loan.\n    /// @dev Flash loans have access to the whole balance of the contract (the liquidity and deposited collateral of all\n    /// markets combined, plus donations).\n    /// @dev Warning: Not ERC-3156 compliant but compatibility is easily reached:\n    /// - `flashFee` is zero.\n    /// - `maxFlashLoan` is the token's balance of this contract.\n    /// - The receiver of `assets` is the caller.\n    /// @param token The token to flash loan.\n    /// @param assets The amount of assets to flash loan.\n    /// @param data Arbitrary data to pass to the `onMorphoFlashLoan` callback.\n    function flashLoan(address token, uint256 assets, bytes calldata data) external;\n\n    /// @notice Sets the authorization for `authorized` to manage `msg.sender`'s positions.\n    /// @param authorized The authorized address.\n    /// @param newIsAuthorized The new authorization status.\n    function setAuthorization(address authorized, bool newIsAuthorized) external;\n\n    /// @notice Sets the authorization for `authorization.authorized` to manage `authorization.authorizer`'s positions.\n    /// @dev Warning: Reverts if the signature has already been submitted.\n    /// @dev The signature is malleable, but it has no impact on the security here.\n    /// @dev The nonce is passed as argument to be able to revert with a different error message.\n    /// @param authorization The `Authorization` struct.\n    /// @param signature The signature.\n    function setAuthorizationWithSig(Authorization calldata authorization, Signature calldata signature) external;\n\n    /// @notice Accrues interest for the given market `marketParams`.\n    function accrueInterest(MarketParams memory marketParams) external;\n\n    /// @notice Returns the data stored on the different `slots`.\n    function extSloads(bytes32[] memory slots) external view returns (bytes32[] memory);\n}\n\n/// @dev This interface is inherited by Morpho so that function signatures are checked by the compiler.\n/// @dev Consider using the IMorpho interface instead of this one.\ninterface IMorphoStaticTyping is IMorphoBase {\n    /// @notice The state of the position of `user` on the market corresponding to `id`.\n    /// @dev Warning: For `feeRecipient`, `supplyShares` does not contain the accrued shares since the last interest\n    /// accrual.\n    function position(Id id, address user)\n        external\n        view\n        returns (uint256 supplyShares, uint128 borrowShares, uint128 collateral);\n\n    /// @notice The state of the market corresponding to `id`.\n    /// @dev Warning: `totalSupplyAssets` does not contain the accrued interest since the last interest accrual.\n    /// @dev Warning: `totalBorrowAssets` does not contain the accrued interest since the last interest accrual.\n    /// @dev Warning: `totalSupplyShares` does not contain the accrued shares by `feeRecipient` since the last interest\n    /// accrual.\n    function market(Id id)\n        external\n        view\n        returns (\n            uint128 totalSupplyAssets,\n            uint128 totalSupplyShares,\n            uint128 totalBorrowAssets,\n            uint128 totalBorrowShares,\n            uint128 lastUpdate,\n            uint128 fee\n        );\n\n    /// @notice The market params corresponding to `id`.\n    /// @dev This mapping is not used in Morpho. It is there to enable reducing the cost associated to calldata on layer\n    /// 2s by creating a wrapper contract with functions that take `id` as input instead of `marketParams`.\n    function idToMarketParams(Id id)\n        external\n        view\n        returns (address loanToken, address collateralToken, address oracle, address irm, uint256 lltv);\n}\n\n/// @title IMorpho\n/// @author Morpho Labs\n/// @custom:contact security@morpho.org\n/// @dev Use this interface for Morpho to have access to all the functions with the appropriate function signatures.\ninterface IMorpho is IMorphoBase {\n    /// @notice The state of the position of `user` on the market corresponding to `id`.\n    /// @dev Warning: For `feeRecipient`, `p.supplyShares` does not contain the accrued shares since the last interest\n    /// accrual.\n    function position(Id id, address user) external view returns (Position memory p);\n\n    /// @notice The state of the market corresponding to `id`.\n    /// @dev Warning: `m.totalSupplyAssets` does not contain the accrued interest since the last interest accrual.\n    /// @dev Warning: `m.totalBorrowAssets` does not contain the accrued interest since the last interest accrual.\n    /// @dev Warning: `m.totalSupplyShares` does not contain the accrued shares by `feeRecipient` since the last\n    /// interest accrual.\n    function market(Id id) external view returns (Market memory m);\n\n    /// @notice The market params corresponding to `id`.\n    /// @dev This mapping is not used in Morpho. It is there to enable reducing the cost associated to calldata on layer\n    /// 2s by creating a wrapper contract with functions that take `id` as input instead of `marketParams`.\n    function idToMarketParams(Id id) external view returns (MarketParams memory);\n}\n"
    },
    "@morpho-blue/libraries/ErrorsLib.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\n/// @title ErrorsLib\n/// @author Morpho Labs\n/// @custom:contact security@morpho.org\n/// @notice Library exposing error messages.\nlibrary ErrorsLib {\n    /// @notice Thrown when the caller is not the owner.\n    string internal constant NOT_OWNER = \"not owner\";\n\n    /// @notice Thrown when the LLTV to enable exceeds the maximum LLTV.\n    string internal constant MAX_LLTV_EXCEEDED = \"max LLTV exceeded\";\n\n    /// @notice Thrown when the fee to set exceeds the maximum fee.\n    string internal constant MAX_FEE_EXCEEDED = \"max fee exceeded\";\n\n    /// @notice Thrown when the value is already set.\n    string internal constant ALREADY_SET = \"already set\";\n\n    /// @notice Thrown when the IRM is not enabled at market creation.\n    string internal constant IRM_NOT_ENABLED = \"IRM not enabled\";\n\n    /// @notice Thrown when the LLTV is not enabled at market creation.\n    string internal constant LLTV_NOT_ENABLED = \"LLTV not enabled\";\n\n    /// @notice Thrown when the market is already created.\n    string internal constant MARKET_ALREADY_CREATED = \"market already created\";\n\n    /// @notice Thrown when a token to transfer doesn't have code.\n    string internal constant NO_CODE = \"no code\";\n\n    /// @notice Thrown when the market is not created.\n    string internal constant MARKET_NOT_CREATED = \"market not created\";\n\n    /// @notice Thrown when not exactly one of the input amount is zero.\n    string internal constant INCONSISTENT_INPUT = \"inconsistent input\";\n\n    /// @notice Thrown when zero assets is passed as input.\n    string internal constant ZERO_ASSETS = \"zero assets\";\n\n    /// @notice Thrown when a zero address is passed as input.\n    string internal constant ZERO_ADDRESS = \"zero address\";\n\n    /// @notice Thrown when the caller is not authorized to conduct an action.\n    string internal constant UNAUTHORIZED = \"unauthorized\";\n\n    /// @notice Thrown when the collateral is insufficient to `borrow` or `withdrawCollateral`.\n    string internal constant INSUFFICIENT_COLLATERAL = \"insufficient collateral\";\n\n    /// @notice Thrown when the liquidity is insufficient to `withdraw` or `borrow`.\n    string internal constant INSUFFICIENT_LIQUIDITY = \"insufficient liquidity\";\n\n    /// @notice Thrown when the position to liquidate is healthy.\n    string internal constant HEALTHY_POSITION = \"position is healthy\";\n\n    /// @notice Thrown when the authorization signature is invalid.\n    string internal constant INVALID_SIGNATURE = \"invalid signature\";\n\n    /// @notice Thrown when the authorization signature is expired.\n    string internal constant SIGNATURE_EXPIRED = \"signature expired\";\n\n    /// @notice Thrown when the nonce is invalid.\n    string internal constant INVALID_NONCE = \"invalid nonce\";\n\n    /// @notice Thrown when a token transfer reverted.\n    string internal constant TRANSFER_REVERTED = \"transfer reverted\";\n\n    /// @notice Thrown when a token transfer returned false.\n    string internal constant TRANSFER_RETURNED_FALSE = \"transfer returned false\";\n\n    /// @notice Thrown when a token transferFrom reverted.\n    string internal constant TRANSFER_FROM_REVERTED = \"transferFrom reverted\";\n\n    /// @notice Thrown when a token transferFrom returned false\n    string internal constant TRANSFER_FROM_RETURNED_FALSE = \"transferFrom returned false\";\n\n    /// @notice Thrown when the maximum uint128 is exceeded.\n    string internal constant MAX_UINT128_EXCEEDED = \"max uint128 exceeded\";\n}\n"
    },
    "@morpho-blue/libraries/MarketParamsLib.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\nimport {Id, MarketParams} from \"../interfaces/IMorpho.sol\";\n\n/// @title MarketParamsLib\n/// @author Morpho Labs\n/// @custom:contact security@morpho.org\n/// @notice Library to convert a market to its id.\nlibrary MarketParamsLib {\n    /// @notice The length of the data used to compute the id of a market.\n    /// @dev The length is 5 * 32 because `MarketParams` has 5 variables of 32 bytes each.\n    uint256 internal constant MARKET_PARAMS_BYTES_LENGTH = 5 * 32;\n\n    /// @notice Returns the id of the market `marketParams`.\n    function id(MarketParams memory marketParams) internal pure returns (Id marketParamsId) {\n        assembly (\"memory-safe\") {\n            marketParamsId := keccak256(marketParams, MARKET_PARAMS_BYTES_LENGTH)\n        }\n    }\n}\n"
    },
    "@morpho-blue/libraries/MathLib.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\nuint256 constant WAD = 1e18;\n\n/// @title MathLib\n/// @author Morpho Labs\n/// @custom:contact security@morpho.org\n/// @notice Library to manage fixed-point arithmetic.\nlibrary MathLib {\n    /// @dev Returns (`x` * `y`) / `WAD` rounded down.\n    function wMulDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, y, WAD);\n    }\n\n    /// @dev Returns (`x` * `WAD`) / `y` rounded down.\n    function wDivDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, WAD, y);\n    }\n\n    /// @dev Returns (`x` * `WAD`) / `y` rounded up.\n    function wDivUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, WAD, y);\n    }\n\n    /// @dev Returns (`x` * `y`) / `d` rounded down.\n    function mulDivDown(uint256 x, uint256 y, uint256 d) internal pure returns (uint256) {\n        return (x * y) / d;\n    }\n\n    /// @dev Returns (`x` * `y`) / `d` rounded up.\n    function mulDivUp(uint256 x, uint256 y, uint256 d) internal pure returns (uint256) {\n        return (x * y + (d - 1)) / d;\n    }\n\n    /// @dev Returns the sum of the first three non-zero terms of a Taylor expansion of e^(nx) - 1, to approximate a\n    /// continuous compound interest rate.\n    function wTaylorCompounded(uint256 x, uint256 n) internal pure returns (uint256) {\n        uint256 firstTerm = x * n;\n        uint256 secondTerm = mulDivDown(firstTerm, firstTerm, 2 * WAD);\n        uint256 thirdTerm = mulDivDown(secondTerm, firstTerm, 3 * WAD);\n\n        return firstTerm + secondTerm + thirdTerm;\n    }\n}\n"
    },
    "@morpho-blue/libraries/periphery/MorphoBalancesLib.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\nimport {Id, MarketParams, Market, IMorpho} from \"../../interfaces/IMorpho.sol\";\nimport {IIrm} from \"../../interfaces/IIrm.sol\";\n\nimport {MathLib} from \"../MathLib.sol\";\nimport {UtilsLib} from \"../UtilsLib.sol\";\nimport {MorphoLib} from \"./MorphoLib.sol\";\nimport {SharesMathLib} from \"../SharesMathLib.sol\";\nimport {MarketParamsLib} from \"../MarketParamsLib.sol\";\n\n/// @title MorphoBalancesLib\n/// @author Morpho Labs\n/// @custom:contact security@morpho.org\n/// @notice Helper library exposing getters with the expected value after interest accrual.\n/// @dev This library is not used in Morpho itself and is intended to be used by integrators.\n/// @dev The getter to retrieve the expected total borrow shares is not exposed because interest accrual does not apply\n/// to it. The value can be queried directly on Morpho using `totalBorrowShares`.\nlibrary MorphoBalancesLib {\n    using MathLib for uint256;\n    using MathLib for uint128;\n    using UtilsLib for uint256;\n    using MorphoLib for IMorpho;\n    using SharesMathLib for uint256;\n    using MarketParamsLib for MarketParams;\n\n    /// @notice Returns the expected market balances of a market after having accrued interest.\n    /// @return The expected total supply assets.\n    /// @return The expected total supply shares.\n    /// @return The expected total borrow assets.\n    /// @return The expected total borrow shares.\n    function expectedMarketBalances(IMorpho morpho, MarketParams memory marketParams)\n        internal\n        view\n        returns (uint256, uint256, uint256, uint256)\n    {\n        Id id = marketParams.id();\n        Market memory market = morpho.market(id);\n\n        uint256 elapsed = block.timestamp - market.lastUpdate;\n\n        // Skipped if elapsed == 0 or totalBorrowAssets == 0 because interest would be null, or if irm == address(0).\n        if (elapsed != 0 && market.totalBorrowAssets != 0 && marketParams.irm != address(0)) {\n            uint256 borrowRate = IIrm(marketParams.irm).borrowRateView(marketParams, market);\n            uint256 interest = market.totalBorrowAssets.wMulDown(borrowRate.wTaylorCompounded(elapsed));\n            market.totalBorrowAssets += interest.toUint128();\n            market.totalSupplyAssets += interest.toUint128();\n\n            if (market.fee != 0) {\n                uint256 feeAmount = interest.wMulDown(market.fee);\n                // The fee amount is subtracted from the total supply in this calculation to compensate for the fact\n                // that total supply is already updated.\n                uint256 feeShares =\n                    feeAmount.toSharesDown(market.totalSupplyAssets - feeAmount, market.totalSupplyShares);\n                market.totalSupplyShares += feeShares.toUint128();\n            }\n        }\n\n        return (market.totalSupplyAssets, market.totalSupplyShares, market.totalBorrowAssets, market.totalBorrowShares);\n    }\n\n    /// @notice Returns the expected total supply assets of a market after having accrued interest.\n    function expectedTotalSupplyAssets(IMorpho morpho, MarketParams memory marketParams)\n        internal\n        view\n        returns (uint256 totalSupplyAssets)\n    {\n        (totalSupplyAssets,,,) = expectedMarketBalances(morpho, marketParams);\n    }\n\n    /// @notice Returns the expected total borrow assets of a market after having accrued interest.\n    function expectedTotalBorrowAssets(IMorpho morpho, MarketParams memory marketParams)\n        internal\n        view\n        returns (uint256 totalBorrowAssets)\n    {\n        (,, totalBorrowAssets,) = expectedMarketBalances(morpho, marketParams);\n    }\n\n    /// @notice Returns the expected total supply shares of a market after having accrued interest.\n    function expectedTotalSupplyShares(IMorpho morpho, MarketParams memory marketParams)\n        internal\n        view\n        returns (uint256 totalSupplyShares)\n    {\n        (, totalSupplyShares,,) = expectedMarketBalances(morpho, marketParams);\n    }\n\n    /// @notice Returns the expected supply assets balance of `user` on a market after having accrued interest.\n    /// @dev Warning: Wrong for `feeRecipient` because their supply shares increase is not taken into account.\n    /// @dev Warning: Withdrawing using the expected supply assets can lead to a revert due to conversion roundings from\n    /// assets to shares.\n    function expectedSupplyAssets(IMorpho morpho, MarketParams memory marketParams, address user)\n        internal\n        view\n        returns (uint256)\n    {\n        Id id = marketParams.id();\n        uint256 supplyShares = morpho.supplyShares(id, user);\n        (uint256 totalSupplyAssets, uint256 totalSupplyShares,,) = expectedMarketBalances(morpho, marketParams);\n\n        return supplyShares.toAssetsDown(totalSupplyAssets, totalSupplyShares);\n    }\n\n    /// @notice Returns the expected borrow assets balance of `user` on a market after having accrued interest.\n    /// @dev Warning: The expected balance is rounded up, so it may be greater than the market's expected total borrow\n    /// assets.\n    function expectedBorrowAssets(IMorpho morpho, MarketParams memory marketParams, address user)\n        internal\n        view\n        returns (uint256)\n    {\n        Id id = marketParams.id();\n        uint256 borrowShares = morpho.borrowShares(id, user);\n        (,, uint256 totalBorrowAssets, uint256 totalBorrowShares) = expectedMarketBalances(morpho, marketParams);\n\n        return borrowShares.toAssetsUp(totalBorrowAssets, totalBorrowShares);\n    }\n}\n"
    },
    "@morpho-blue/libraries/periphery/MorphoLib.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\nimport {IMorpho, Id} from \"../../interfaces/IMorpho.sol\";\nimport {MorphoStorageLib} from \"./MorphoStorageLib.sol\";\n\n/// @title MorphoLib\n/// @author Morpho Labs\n/// @custom:contact security@morpho.org\n/// @notice Helper library to access Morpho storage variables.\n/// @dev Warning: Supply and borrow getters may return outdated values that do not include accrued interest.\nlibrary MorphoLib {\n    function supplyShares(IMorpho morpho, Id id, address user) internal view returns (uint256) {\n        bytes32[] memory slot = _array(MorphoStorageLib.positionSupplySharesSlot(id, user));\n        return uint256(morpho.extSloads(slot)[0]);\n    }\n\n    function borrowShares(IMorpho morpho, Id id, address user) internal view returns (uint256) {\n        bytes32[] memory slot = _array(MorphoStorageLib.positionBorrowSharesAndCollateralSlot(id, user));\n        return uint128(uint256(morpho.extSloads(slot)[0]));\n    }\n\n    function collateral(IMorpho morpho, Id id, address user) internal view returns (uint256) {\n        bytes32[] memory slot = _array(MorphoStorageLib.positionBorrowSharesAndCollateralSlot(id, user));\n        return uint256(morpho.extSloads(slot)[0] >> 128);\n    }\n\n    function totalSupplyAssets(IMorpho morpho, Id id) internal view returns (uint256) {\n        bytes32[] memory slot = _array(MorphoStorageLib.marketTotalSupplyAssetsAndSharesSlot(id));\n        return uint128(uint256(morpho.extSloads(slot)[0]));\n    }\n\n    function totalSupplyShares(IMorpho morpho, Id id) internal view returns (uint256) {\n        bytes32[] memory slot = _array(MorphoStorageLib.marketTotalSupplyAssetsAndSharesSlot(id));\n        return uint256(morpho.extSloads(slot)[0] >> 128);\n    }\n\n    function totalBorrowAssets(IMorpho morpho, Id id) internal view returns (uint256) {\n        bytes32[] memory slot = _array(MorphoStorageLib.marketTotalBorrowAssetsAndSharesSlot(id));\n        return uint128(uint256(morpho.extSloads(slot)[0]));\n    }\n\n    function totalBorrowShares(IMorpho morpho, Id id) internal view returns (uint256) {\n        bytes32[] memory slot = _array(MorphoStorageLib.marketTotalBorrowAssetsAndSharesSlot(id));\n        return uint256(morpho.extSloads(slot)[0] >> 128);\n    }\n\n    function lastUpdate(IMorpho morpho, Id id) internal view returns (uint256) {\n        bytes32[] memory slot = _array(MorphoStorageLib.marketLastUpdateAndFeeSlot(id));\n        return uint128(uint256(morpho.extSloads(slot)[0]));\n    }\n\n    function fee(IMorpho morpho, Id id) internal view returns (uint256) {\n        bytes32[] memory slot = _array(MorphoStorageLib.marketLastUpdateAndFeeSlot(id));\n        return uint256(morpho.extSloads(slot)[0] >> 128);\n    }\n\n    function _array(bytes32 x) private pure returns (bytes32[] memory) {\n        bytes32[] memory res = new bytes32[](1);\n        res[0] = x;\n        return res;\n    }\n}\n"
    },
    "@morpho-blue/libraries/periphery/MorphoStorageLib.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\nimport {Id} from \"../../interfaces/IMorpho.sol\";\n\n/// @title MorphoStorageLib\n/// @author Morpho Labs\n/// @custom:contact security@morpho.org\n/// @notice Helper library exposing getters to access Morpho storage variables' slot.\n/// @dev This library is not used in Morpho itself and is intended to be used by integrators.\nlibrary MorphoStorageLib {\n    /* SLOTS */\n\n    uint256 internal constant OWNER_SLOT = 0;\n    uint256 internal constant FEE_RECIPIENT_SLOT = 1;\n    uint256 internal constant POSITION_SLOT = 2;\n    uint256 internal constant MARKET_SLOT = 3;\n    uint256 internal constant IS_IRM_ENABLED_SLOT = 4;\n    uint256 internal constant IS_LLTV_ENABLED_SLOT = 5;\n    uint256 internal constant IS_AUTHORIZED_SLOT = 6;\n    uint256 internal constant NONCE_SLOT = 7;\n    uint256 internal constant ID_TO_MARKET_PARAMS_SLOT = 8;\n\n    /* SLOT OFFSETS */\n\n    uint256 internal constant LOAN_TOKEN_OFFSET = 0;\n    uint256 internal constant COLLATERAL_TOKEN_OFFSET = 1;\n    uint256 internal constant ORACLE_OFFSET = 2;\n    uint256 internal constant IRM_OFFSET = 3;\n    uint256 internal constant LLTV_OFFSET = 4;\n\n    uint256 internal constant SUPPLY_SHARES_OFFSET = 0;\n    uint256 internal constant BORROW_SHARES_AND_COLLATERAL_OFFSET = 1;\n\n    uint256 internal constant TOTAL_SUPPLY_ASSETS_AND_SHARES_OFFSET = 0;\n    uint256 internal constant TOTAL_BORROW_ASSETS_AND_SHARES_OFFSET = 1;\n    uint256 internal constant LAST_UPDATE_AND_FEE_OFFSET = 2;\n\n    /* GETTERS */\n\n    function ownerSlot() internal pure returns (bytes32) {\n        return bytes32(OWNER_SLOT);\n    }\n\n    function feeRecipientSlot() internal pure returns (bytes32) {\n        return bytes32(FEE_RECIPIENT_SLOT);\n    }\n\n    function positionSupplySharesSlot(Id id, address user) internal pure returns (bytes32) {\n        return bytes32(\n            uint256(keccak256(abi.encode(user, keccak256(abi.encode(id, POSITION_SLOT))))) + SUPPLY_SHARES_OFFSET\n        );\n    }\n\n    function positionBorrowSharesAndCollateralSlot(Id id, address user) internal pure returns (bytes32) {\n        return bytes32(\n            uint256(keccak256(abi.encode(user, keccak256(abi.encode(id, POSITION_SLOT)))))\n                + BORROW_SHARES_AND_COLLATERAL_OFFSET\n        );\n    }\n\n    function marketTotalSupplyAssetsAndSharesSlot(Id id) internal pure returns (bytes32) {\n        return bytes32(uint256(keccak256(abi.encode(id, MARKET_SLOT))) + TOTAL_SUPPLY_ASSETS_AND_SHARES_OFFSET);\n    }\n\n    function marketTotalBorrowAssetsAndSharesSlot(Id id) internal pure returns (bytes32) {\n        return bytes32(uint256(keccak256(abi.encode(id, MARKET_SLOT))) + TOTAL_BORROW_ASSETS_AND_SHARES_OFFSET);\n    }\n\n    function marketLastUpdateAndFeeSlot(Id id) internal pure returns (bytes32) {\n        return bytes32(uint256(keccak256(abi.encode(id, MARKET_SLOT))) + LAST_UPDATE_AND_FEE_OFFSET);\n    }\n\n    function isIrmEnabledSlot(address irm) internal pure returns (bytes32) {\n        return keccak256(abi.encode(irm, IS_IRM_ENABLED_SLOT));\n    }\n\n    function isLltvEnabledSlot(uint256 lltv) internal pure returns (bytes32) {\n        return keccak256(abi.encode(lltv, IS_LLTV_ENABLED_SLOT));\n    }\n\n    function isAuthorizedSlot(address authorizer, address authorizee) internal pure returns (bytes32) {\n        return keccak256(abi.encode(authorizee, keccak256(abi.encode(authorizer, IS_AUTHORIZED_SLOT))));\n    }\n\n    function nonceSlot(address authorizer) internal pure returns (bytes32) {\n        return keccak256(abi.encode(authorizer, NONCE_SLOT));\n    }\n\n    function idToLoanTokenSlot(Id id) internal pure returns (bytes32) {\n        return bytes32(uint256(keccak256(abi.encode(id, ID_TO_MARKET_PARAMS_SLOT))) + LOAN_TOKEN_OFFSET);\n    }\n\n    function idToCollateralTokenSlot(Id id) internal pure returns (bytes32) {\n        return bytes32(uint256(keccak256(abi.encode(id, ID_TO_MARKET_PARAMS_SLOT))) + COLLATERAL_TOKEN_OFFSET);\n    }\n\n    function idToOracleSlot(Id id) internal pure returns (bytes32) {\n        return bytes32(uint256(keccak256(abi.encode(id, ID_TO_MARKET_PARAMS_SLOT))) + ORACLE_OFFSET);\n    }\n\n    function idToIrmSlot(Id id) internal pure returns (bytes32) {\n        return bytes32(uint256(keccak256(abi.encode(id, ID_TO_MARKET_PARAMS_SLOT))) + IRM_OFFSET);\n    }\n\n    function idToLltvSlot(Id id) internal pure returns (bytes32) {\n        return bytes32(uint256(keccak256(abi.encode(id, ID_TO_MARKET_PARAMS_SLOT))) + LLTV_OFFSET);\n    }\n}\n"
    },
    "@morpho-blue/libraries/SharesMathLib.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\nimport {MathLib} from \"./MathLib.sol\";\n\n/// @title SharesMathLib\n/// @author Morpho Labs\n/// @custom:contact security@morpho.org\n/// @notice Shares management library.\n/// @dev This implementation mitigates share price manipulations, using OpenZeppelin's method of virtual shares:\n/// https://docs.openzeppelin.com/contracts/4.x/erc4626#inflation-attack.\nlibrary SharesMathLib {\n    using MathLib for uint256;\n\n    /// @dev The number of virtual shares has been chosen low enough to prevent overflows, and high enough to ensure\n    /// high precision computations.\n    /// @dev Virtual shares can never be redeemed for the assets they are entitled to, but it is assumed the share price\n    /// stays low enough not to inflate these assets to a significant value.\n    /// @dev Warning: The assets to which virtual borrow shares are entitled behave like unrealizable bad debt.\n    uint256 internal constant VIRTUAL_SHARES = 1e6;\n\n    /// @dev A number of virtual assets of 1 enforces a conversion rate between shares and assets when a market is\n    /// empty.\n    uint256 internal constant VIRTUAL_ASSETS = 1;\n\n    /// @dev Calculates the value of `assets` quoted in shares, rounding down.\n    function toSharesDown(uint256 assets, uint256 totalAssets, uint256 totalShares) internal pure returns (uint256) {\n        return assets.mulDivDown(totalShares + VIRTUAL_SHARES, totalAssets + VIRTUAL_ASSETS);\n    }\n\n    /// @dev Calculates the value of `shares` quoted in assets, rounding down.\n    function toAssetsDown(uint256 shares, uint256 totalAssets, uint256 totalShares) internal pure returns (uint256) {\n        return shares.mulDivDown(totalAssets + VIRTUAL_ASSETS, totalShares + VIRTUAL_SHARES);\n    }\n\n    /// @dev Calculates the value of `assets` quoted in shares, rounding up.\n    function toSharesUp(uint256 assets, uint256 totalAssets, uint256 totalShares) internal pure returns (uint256) {\n        return assets.mulDivUp(totalShares + VIRTUAL_SHARES, totalAssets + VIRTUAL_ASSETS);\n    }\n\n    /// @dev Calculates the value of `shares` quoted in assets, rounding up.\n    function toAssetsUp(uint256 shares, uint256 totalAssets, uint256 totalShares) internal pure returns (uint256) {\n        return shares.mulDivUp(totalAssets + VIRTUAL_ASSETS, totalShares + VIRTUAL_SHARES);\n    }\n}\n"
    },
    "@morpho-blue/libraries/UtilsLib.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\nimport {ErrorsLib} from \"../libraries/ErrorsLib.sol\";\n\n/// @title UtilsLib\n/// @author Morpho Labs\n/// @custom:contact security@morpho.org\n/// @notice Library exposing helpers.\n/// @dev Inspired by https://github.com/morpho-org/morpho-utils.\nlibrary UtilsLib {\n    /// @dev Returns true if there is exactly one zero among `x` and `y`.\n    function exactlyOneZero(uint256 x, uint256 y) internal pure returns (bool z) {\n        assembly {\n            z := xor(iszero(x), iszero(y))\n        }\n    }\n\n    /// @dev Returns the min of `x` and `y`.\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        assembly {\n            z := xor(x, mul(xor(x, y), lt(y, x)))\n        }\n    }\n\n    /// @dev Returns `x` safely cast to uint128.\n    function toUint128(uint256 x) internal pure returns (uint128) {\n        require(x <= type(uint128).max, ErrorsLib.MAX_UINT128_EXCEEDED);\n        return uint128(x);\n    }\n\n    /// @dev Returns max(0, x - y).\n    function zeroFloorSub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        assembly {\n            z := mul(gt(x, y), sub(x, y))\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "src/interfaces/IStrategyBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.28;\r\n\r\nstruct Reward {\r\n    address token;\r\n    uint256 amount;\r\n}\r\n\r\ninterface IStrategyBase {\r\n    /**\r\n     * @dev Returns the address of the protocol.\r\n     * @param supplement Additional data required for the protocol address determination.\r\n     * @return The address of the protocol.\r\n     */\r\n    function protocol(bytes calldata supplement) external returns (address);\r\n    /**\r\n     * @dev Deposits the specified amount into the strategy.\r\n     * @param amount The amount to deposit.\r\n     * @param supplement Additional data required for the deposit.\r\n     */\r\n    function deposit(uint256 amount, bytes calldata supplement) external;\r\n\r\n    /**\r\n     * @dev Withdraws the specified amount from the strategy.\r\n     * @param amount The amount to withdraw.\r\n     * @param supplement Additional data required for the withdrawal.\r\n     * @return withdrawn The actual amount withdrawn.\r\n     */\r\n    function withdraw(uint256 amount, bytes calldata supplement) external returns (uint256 withdrawn);\r\n\r\n    /**\r\n     * @dev Withdraws all funds from strategy.\r\n     * @param supplement Additional data required for the withdrawal.\r\n     * @return withdrawn The actual amount withdrawn.\r\n     */\r\n    function withdrawAll(bytes calldata supplement) external returns (uint256 withdrawn);\r\n\r\n    /**\r\n     * @dev Returns the asset balance of the strategy for the specified vault.\r\n     * @param yelayLiteVault The address of the vault.\r\n     * @param supplement Additional data required for the balance calculation.\r\n     * @return The asset balance of the strategy.\r\n     */\r\n    function assetBalance(address yelayLiteVault, bytes calldata supplement) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Called when the strategy is added.\r\n     * @param supplement Additional data required for the addition.\r\n     */\r\n    function onAdd(bytes calldata supplement) external;\r\n\r\n    /**\r\n     * @dev Called when the strategy is removed.\r\n     * @param supplement Additional data required for the removal.\r\n     */\r\n    function onRemove(bytes calldata supplement) external;\r\n\r\n    /**\r\n     * @dev Returns the rewards available for the specified vault.\r\n     * @param yelayLiteVault The address of the vault.\r\n     * @param supplement Additional data required for the rewards calculation.\r\n     * @return rewards The rewards available for the vault.\r\n     */\r\n    function viewRewards(address yelayLiteVault, bytes calldata supplement)\r\n        external\r\n        view\r\n        returns (Reward[] memory rewards);\r\n\r\n    /**\r\n     * @dev Claims the rewards for the strategy.\r\n     * @param supplement Additional data required for claiming the rewards.\r\n     */\r\n    function claimRewards(bytes calldata supplement) external;\r\n}\r\n"
    },
    "src/strategies/MorphoBlueStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.28;\r\n\r\nimport {MorphoBalancesLib} from \"@morpho-blue/libraries/periphery/MorphoBalancesLib.sol\";\r\nimport {Id, IMorpho, MarketParams, Position} from \"@morpho-blue/interfaces/IMorpho.sol\";\r\n\r\nimport {IStrategyBase, Reward} from \"src/interfaces/IStrategyBase.sol\";\r\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\ncontract MorphoBlueStrategy is IStrategyBase {\r\n    IMorpho immutable morpho;\r\n\r\n    constructor(address morpho_) {\r\n        morpho = IMorpho(morpho_);\r\n    }\r\n\r\n    function _decodeSupplement(bytes calldata supplement) internal pure returns (Id id) {\r\n        return abi.decode(supplement, (Id));\r\n    }\r\n\r\n    function protocol(bytes calldata) external view returns (address) {\r\n        return address(morpho);\r\n    }\r\n\r\n    function deposit(uint256 amount, bytes calldata supplement) external {\r\n        Id id = _decodeSupplement(supplement);\r\n        MarketParams memory marketParams = morpho.idToMarketParams(id);\r\n        morpho.supply(marketParams, amount, 0, address(this), \"\");\r\n    }\r\n\r\n    function withdraw(uint256 amount, bytes calldata supplement) external returns (uint256 withdrawn) {\r\n        Id id = _decodeSupplement(supplement);\r\n        MarketParams memory marketParams = morpho.idToMarketParams(id);\r\n        (withdrawn,) = morpho.withdraw(marketParams, amount, 0, address(this), address(this));\r\n    }\r\n\r\n    function assetBalance(address yelayLiteVault, bytes calldata supplement) external view returns (uint256) {\r\n        Id id = _decodeSupplement(supplement);\r\n        MarketParams memory marketParams = morpho.idToMarketParams(id);\r\n        return MorphoBalancesLib.expectedSupplyAssets(morpho, marketParams, yelayLiteVault);\r\n    }\r\n\r\n    function withdrawAll(bytes calldata supplement) external returns (uint256 withdrawn) {\r\n        Id id = _decodeSupplement(supplement);\r\n        Position memory position = morpho.position(id, address(this));\r\n        (withdrawn,) =\r\n            morpho.withdraw(morpho.idToMarketParams(id), 0, position.supplyShares, address(this), address(this));\r\n    }\r\n\r\n    function onAdd(bytes calldata supplement) external {}\r\n    function onRemove(bytes calldata supplement) external {}\r\n    function viewRewards(address, bytes calldata) external view returns (Reward[] memory rewards) {}\r\n    function claimRewards(bytes calldata) external {}\r\n}\r\n"
    }
  },
  "settings": {
    "evmVersion": "cancun",
    "optimizer": {
      "enabled": true,
      "runs": 10000
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}