{{
  "language": "Solidity",
  "sources": {
    "src/router/Router.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.20;\n\nimport {Math} from \"openzeppelin-math/Math.sol\";\nimport {IERC3156FlashBorrower} from \"openzeppelin-contracts/interfaces/IERC3156FlashBorrower.sol\";\nimport {SafeERC20, IERC20} from \"openzeppelin-contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {AccessManagedUpgradeable} from \"openzeppelin-contracts-upgradeable/access/manager/AccessManagedUpgradeable.sol\";\nimport {PausableUpgradeable} from \"openzeppelin-contracts-upgradeable/utils/PausableUpgradeable.sol\";\nimport {RayMath} from \"../libraries/RayMath.sol\";\nimport {IRouter} from \"../interfaces/IRouter.sol\";\nimport {Dispatcher} from \"./Dispatcher.sol\";\n\n/**\n * @title Router contract\n * @author Spectra Finance\n * @notice Handles executions of complex sequences of actions in the Spectra protocol.\n */\ncontract Router is\n    Dispatcher,\n    AccessManagedUpgradeable,\n    PausableUpgradeable,\n    IRouter,\n    IERC3156FlashBorrower\n{\n    using SafeERC20 for IERC20;\n    using Math for uint256;\n\n    /** @dev Maximum amount of tokens for which balance can be tracked in _previewRate(). */\n    uint256 private constant MAX_INVOLVED_TOKENS = 30;\n\n    /** @dev Expected return value from borrowers onFlashLoan function. */\n    bytes32 private immutable ON_FLASH_LOAN = keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n    /* Events\n     *********************************************************************************************************/\n    event RouterUtilChange(address indexed previousRouterUtil, address indexed newRouterUtil);\n    event KyberRouterChange(address indexed previousKyberRouter, address indexed newKyberRouter);\n\n    /* Modifiers\n     *********************************************************************************************************/\n    modifier checkDeadline(uint256 deadline) {\n        if (block.timestamp > deadline) revert TransactionDeadlinePassed();\n        _;\n    }\n\n    /* Constructor\n     *********************************************************************************************************/\n    constructor(address _registry) Dispatcher(_registry) {\n        _disableInitializers(); // using this so that the deployed logic contract later cannot be initialized.\n    }\n\n    /* Initializer\n     *********************************************************************************************************/\n    function initialize(\n        address _routerUtil,\n        address _kyberRouter,\n        address _initialAuthority\n    ) external initializer {\n        __Dispatcher_init(_routerUtil, _kyberRouter);\n        __AccessManaged_init(_initialAuthority);\n    }\n\n    /* Setters\n     *********************************************************************************************************/\n\n    /**\n     * @inheritdoc IRouter\n     */\n    function pause() external override restricted {\n        _pause();\n    }\n\n    /**\n     * @inheritdoc IRouter\n     */\n    function unPause() external override restricted {\n        _unpause();\n    }\n\n    /**\n     * @inheritdoc IRouter\n     */\n    function setRouterUtil(address _routerUtil) external override restricted {\n        if (_routerUtil == address(0)) {\n            revert AddressError();\n        }\n        emit RouterUtilChange(routerUtil, _routerUtil);\n        routerUtil = _routerUtil;\n    }\n\n    /**\n     * @inheritdoc IRouter\n     */\n    function setKyberRouter(address _kyberRouter) external override restricted {\n        emit KyberRouterChange(kyberRouter, _kyberRouter);\n        kyberRouter = _kyberRouter;\n    }\n\n    /* Getters\n     *********************************************************************************************************/\n\n    /**\n     * @inheritdoc IRouter\n     */\n    function getRegistry() external view override returns (address) {\n        return registry;\n    }\n\n    /**\n     * @inheritdoc IRouter\n     */\n    function getRouterUtil() external view override returns (address) {\n        return routerUtil;\n    }\n\n    /**\n     * @inheritdoc IRouter\n     */\n    function getKyberRouter() external view override returns (address) {\n        return kyberRouter;\n    }\n\n    /* Executions\n     *********************************************************************************************************/\n\n    /**\n     * @inheritdoc IRouter\n     */\n    function execute(\n        bytes calldata _commands,\n        bytes[] calldata _inputs,\n        uint256 _deadline\n    ) external payable override checkDeadline(_deadline) {\n        execute(_commands, _inputs);\n    }\n\n    /**\n     * @inheritdoc IRouter\n     */\n    function execute(\n        bytes calldata _commands,\n        bytes[] calldata _inputs\n    ) public payable override whenNotPaused {\n        uint256 numCommands = _commands.length;\n        if (_inputs.length != numCommands) {\n            revert LengthMismatch();\n        }\n\n        // Relying on msg.sender is problematic as it changes during a flash loan.\n        // Thus, it's necessary to track who initiated the original Router execution.\n        bool topLevel;\n        if (msgSender == address(0)) {\n            msgSender = msg.sender;\n            topLevel = true;\n            msgValue = msg.value;\n        } else if (msg.sender != address(this)) {\n            revert UnauthorizedReentrantCall();\n        }\n        // loop through all given commands, execute them and pass along outputs as defined\n        for (uint256 commandIndex; commandIndex < numCommands; ) {\n            bytes1 command = _commands[commandIndex];\n\n            bytes calldata input = _inputs[commandIndex];\n\n            _dispatch(command, input);\n            unchecked {\n                commandIndex++;\n            }\n        }\n        if (topLevel) {\n            // top-level reset\n            msgSender = address(0);\n            msgValue = 0;\n        }\n    }\n\n    /* Previews\n     *********************************************************************************************************/\n\n    /**\n     * @dev Simulates the execution of a sequence of commands and returns the expected resulting rate\n     * @param _commands Encoded instructions passed to the dispatcher\n     * @param _inputs An array of byte strings containing ABI-encoded inputs for each command\n     * @param _spot If set to true, spot exchange rate is used for swaps. Additionally for all commands,\n     *              input amounts are disregarded, and one unit of the token of interest is used instead.\n     *              If set to false, the function includes price impact and curve pool fees for swaps.\n     * @return The preview rate value, which represents the amount of output token obtained at the end of execution\n     * for each wei of input token spent at the start of execution, multiplied by 1 ray unit.\n     */\n    function _previewRate(\n        bytes calldata _commands,\n        bytes[] calldata _inputs,\n        bool _spot\n    ) internal view whenNotPaused returns (uint256) {\n        uint256 numCommands = _commands.length;\n        if (_inputs.length != numCommands) {\n            revert LengthMismatch();\n        }\n\n        TokenBalance[] memory balances = new TokenBalance[](MAX_INVOLVED_TOKENS);\n        uint256 rate = RayMath.RAY_UNIT;\n\n        // loop through all given commands, execute them and pass along outputs as defined\n        for (uint256 commandIndex; commandIndex < numCommands; ) {\n            bytes1 command = _commands[commandIndex];\n            bytes calldata input = _inputs[commandIndex];\n\n            uint256 commandRate = _dispatchPreviewRate(command, input, _spot, balances);\n\n            if (commandRate != RayMath.RAY_UNIT) {\n                rate = rate.mulDiv(commandRate, RayMath.RAY_UNIT);\n            }\n\n            unchecked {\n                commandIndex++;\n            }\n        }\n        return rate;\n    }\n\n    /**\n     * @inheritdoc IRouter\n     */\n    function previewRate(\n        bytes calldata _commands,\n        bytes[] calldata _inputs\n    ) external view override returns (uint256) {\n        return _previewRate(_commands, _inputs, false);\n    }\n\n    /**\n     * @inheritdoc IRouter\n     */\n    function previewSpotRate(\n        bytes calldata _commands,\n        bytes[] calldata _inputs\n    ) external view override returns (uint256) {\n        return _previewRate(_commands, _inputs, true);\n    }\n\n    /* Flashloans\n     *********************************************************************************************************/\n\n    /**\n     * @inheritdoc IERC3156FlashBorrower\n     */\n    function onFlashLoan(\n        address /* initiator */,\n        address _token,\n        uint256 _amount,\n        uint256 _fee,\n        bytes calldata _data\n    ) external returns (bytes32) {\n        if (msgSender == address(0)) {\n            revert DirectOnFlashloanCall();\n        }\n        if (msg.sender != flashloanLender) {\n            revert UnauthorizedOnFlashloanCaller();\n        }\n        (bytes memory commands, bytes[] memory inputs) = abi.decode(_data, (bytes, bytes[]));\n        this.execute(commands, inputs); // https://ethereum.stackexchange.com/questions/103437/converting-bytes-memory-to-bytes-calldata\n        uint256 repayAmount = _amount + _fee;\n        uint256 allowance = IERC20(_token).allowance(address(this), msg.sender);\n        if (allowance < repayAmount) {\n            // Approve the lender to pull the funds if needed\n            IERC20(_token).forceApprove(msg.sender, repayAmount);\n        }\n        uint256 balance = IERC20(_token).balanceOf(address(this));\n        if (balance < repayAmount) {\n            // Collect remaining debt from the original sender if needed\n            IERC20(_token).safeTransferFrom(msgSender, address(this), repayAmount - balance);\n        }\n        return ON_FLASH_LOAN;\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Muldiv operation overflow.\n     */\n    error MathOverflowedMulDiv();\n\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            return a / b;\n        }\n\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/interfaces/IERC3156FlashBorrower.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC3156FlashBorrower.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC3156 FlashBorrower, as defined in\n * https://eips.ethereum.org/EIPS/eip-3156[ERC-3156].\n */\ninterface IERC3156FlashBorrower {\n    /**\n     * @dev Receive a flash loan.\n     * @param initiator The initiator of the loan.\n     * @param token The loan currency.\n     * @param amount The amount of tokens lent.\n     * @param fee The additional amount of tokens to repay.\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\n     * @return The keccak256 hash of \"ERC3156FlashBorrower.onFlashLoan\"\n     */\n    function onFlashLoan(\n        address initiator,\n        address token,\n        uint256 amount,\n        uint256 fee,\n        bytes calldata data\n    ) external returns (bytes32);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC20Permit} from \"../extensions/IERC20Permit.sol\";\nimport {Address} from \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev An operation with an ERC20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}\n"
    },
    "lib/openzeppelin-contracts-upgradeable/contracts/access/manager/AccessManagedUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/manager/AccessManaged.sol)\n\npragma solidity ^0.8.20;\n\nimport {IAuthority} from \"@openzeppelin/contracts/access/manager/IAuthority.sol\";\nimport {AuthorityUtils} from \"@openzeppelin/contracts/access/manager/AuthorityUtils.sol\";\nimport {IAccessManager} from \"@openzeppelin/contracts/access/manager/IAccessManager.sol\";\nimport {IAccessManaged} from \"@openzeppelin/contracts/access/manager/IAccessManaged.sol\";\nimport {ContextUpgradeable} from \"../../utils/ContextUpgradeable.sol\";\nimport {Initializable} from \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev This contract module makes available a {restricted} modifier. Functions decorated with this modifier will be\n * permissioned according to an \"authority\": a contract like {AccessManager} that follows the {IAuthority} interface,\n * implementing a policy that allows certain callers to access certain functions.\n *\n * IMPORTANT: The `restricted` modifier should never be used on `internal` functions, judiciously used in `public`\n * functions, and ideally only used in `external` functions. See {restricted}.\n */\nabstract contract AccessManagedUpgradeable is Initializable, ContextUpgradeable, IAccessManaged {\n    /// @custom:storage-location erc7201:openzeppelin.storage.AccessManaged\n    struct AccessManagedStorage {\n        address _authority;\n\n        bool _consumingSchedule;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.AccessManaged\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant AccessManagedStorageLocation = 0xf3177357ab46d8af007ab3fdb9af81da189e1068fefdc0073dca88a2cab40a00;\n\n    function _getAccessManagedStorage() private pure returns (AccessManagedStorage storage $) {\n        assembly {\n            $.slot := AccessManagedStorageLocation\n        }\n    }\n\n    /**\n     * @dev Initializes the contract connected to an initial authority.\n     */\n    function __AccessManaged_init(address initialAuthority) internal onlyInitializing {\n        __AccessManaged_init_unchained(initialAuthority);\n    }\n\n    function __AccessManaged_init_unchained(address initialAuthority) internal onlyInitializing {\n        _setAuthority(initialAuthority);\n    }\n\n    /**\n     * @dev Restricts access to a function as defined by the connected Authority for this contract and the\n     * caller and selector of the function that entered the contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * In general, this modifier should only be used on `external` functions. It is okay to use it on `public`\n     * functions that are used as external entry points and are not called internally. Unless you know what you're\n     * doing, it should never be used on `internal` functions. Failure to follow these rules can have critical security\n     * implications! This is because the permissions are determined by the function that entered the contract, i.e. the\n     * function at the bottom of the call stack, and not the function where the modifier is visible in the source code.\n     * ====\n     *\n     * [WARNING]\n     * ====\n     * Avoid adding this modifier to the https://docs.soliditylang.org/en/v0.8.20/contracts.html#receive-ether-function[`receive()`]\n     * function or the https://docs.soliditylang.org/en/v0.8.20/contracts.html#fallback-function[`fallback()`]. These\n     * functions are the only execution paths where a function selector cannot be unambiguosly determined from the calldata\n     * since the selector defaults to `0x00000000` in the `receive()` function and similarly in the `fallback()` function\n     * if no calldata is provided. (See {_checkCanCall}).\n     *\n     * The `receive()` function will always panic whereas the `fallback()` may panic depending on the calldata length.\n     * ====\n     */\n    modifier restricted() {\n        _checkCanCall(_msgSender(), _msgData());\n        _;\n    }\n\n    /// @inheritdoc IAccessManaged\n    function authority() public view virtual returns (address) {\n        AccessManagedStorage storage $ = _getAccessManagedStorage();\n        return $._authority;\n    }\n\n    /// @inheritdoc IAccessManaged\n    function setAuthority(address newAuthority) public virtual {\n        address caller = _msgSender();\n        if (caller != authority()) {\n            revert AccessManagedUnauthorized(caller);\n        }\n        if (newAuthority.code.length == 0) {\n            revert AccessManagedInvalidAuthority(newAuthority);\n        }\n        _setAuthority(newAuthority);\n    }\n\n    /// @inheritdoc IAccessManaged\n    function isConsumingScheduledOp() public view returns (bytes4) {\n        AccessManagedStorage storage $ = _getAccessManagedStorage();\n        return $._consumingSchedule ? this.isConsumingScheduledOp.selector : bytes4(0);\n    }\n\n    /**\n     * @dev Transfers control to a new authority. Internal function with no access restriction. Allows bypassing the\n     * permissions set by the current authority.\n     */\n    function _setAuthority(address newAuthority) internal virtual {\n        AccessManagedStorage storage $ = _getAccessManagedStorage();\n        $._authority = newAuthority;\n        emit AuthorityUpdated(newAuthority);\n    }\n\n    /**\n     * @dev Reverts if the caller is not allowed to call the function identified by a selector. Panics if the calldata\n     * is less than 4 bytes long.\n     */\n    function _checkCanCall(address caller, bytes calldata data) internal virtual {\n        AccessManagedStorage storage $ = _getAccessManagedStorage();\n        (bool immediate, uint32 delay) = AuthorityUtils.canCallWithDelay(\n            authority(),\n            caller,\n            address(this),\n            bytes4(data[0:4])\n        );\n        if (!immediate) {\n            if (delay > 0) {\n                $._consumingSchedule = true;\n                IAccessManager(authority()).consumeScheduledOp(caller, data);\n                $._consumingSchedule = false;\n            } else {\n                revert AccessManagedUnauthorized(caller);\n            }\n        }\n    }\n}\n"
    },
    "lib/openzeppelin-contracts-upgradeable/contracts/utils/PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Pausable.sol)\n\npragma solidity ^0.8.20;\n\nimport {ContextUpgradeable} from \"../utils/ContextUpgradeable.sol\";\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n    /// @custom:storage-location erc7201:openzeppelin.storage.Pausable\n    struct PausableStorage {\n        bool _paused;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Pausable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant PausableStorageLocation = 0xcd5ed15c6e187e77e9aee88184c21f4f2182ab5827cb3b7e07fbedcd63f03300;\n\n    function _getPausableStorage() private pure returns (PausableStorage storage $) {\n        assembly {\n            $.slot := PausableStorageLocation\n        }\n    }\n\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    /**\n     * @dev The operation failed because the contract is paused.\n     */\n    error EnforcedPause();\n\n    /**\n     * @dev The operation failed because the contract is not paused.\n     */\n    error ExpectedPause();\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        PausableStorage storage $ = _getPausableStorage();\n        return $._paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        if (paused()) {\n            revert EnforcedPause();\n        }\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        if (!paused()) {\n            revert ExpectedPause();\n        }\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "src/libraries/RayMath.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.20;\n\n/**\n * @title RayMath library\n * @author Spectra Finance\n * @notice Provides conversions for/to any decimal tokens to/from ray.\n * @dev Conversions from Ray are rounded down.\n */\nlibrary RayMath {\n    /// @dev 27 decimal unit\n    uint256 public constant RAY_UNIT = 1e27;\n    uint256 public constant RAY_DECIMALS = 27;\n\n    /**\n     * @dev Converts a value from Ray (27-decimal precision) to a representation with a specified number of decimals.\n     * @param _a The amount in Ray to be converted. Ray is a fixed-point representation with 27 decimals.\n     * @param _decimals The target decimal precision for the converted amount.\n     * @return b The amount converted from Ray to the specified decimal precision.\n     */\n    function fromRay(uint256 _a, uint256 _decimals) internal pure returns (uint256 b) {\n        uint256 decimals_ratio = 10 ** (RAY_DECIMALS - _decimals);\n        assembly {\n            b := div(_a, decimals_ratio)\n        }\n    }\n\n    /**\n     * @dev Converts a value from Ray (27-decimal precision) to a representation with a specified number of decimals.\n     * @param _a The amount in Ray to be converted. Ray is a fixed-point representation with 27 decimals.\n     * @param _decimals The target decimal precision for the converted amount.\n     * @param _roundUp If true, the function rounds up the result to the nearest integer value.\n     *                If false, it truncates (rounds down) to the nearest integer.\n     * @return b The amount converted from Ray to the specified decimal precision, rounded as specified.\n     */\n    function fromRay(\n        uint256 _a,\n        uint256 _decimals,\n        bool _roundUp\n    ) internal pure returns (uint256 b) {\n        uint256 decimals_ratio = 10 ** (RAY_DECIMALS - _decimals);\n        assembly {\n            b := div(_a, decimals_ratio)\n\n            if and(eq(_roundUp, 1), gt(mod(_a, decimals_ratio), 0)) {\n                b := add(b, 1)\n            }\n        }\n    }\n\n    /**\n     * @dev Converts a value with a specified number of decimals to Ray (27-decimal precision).\n     * @param _a The amount to be converted, specified in a decimal format.\n     * @param _decimals The number of decimals in the representation of 'a'.\n     * @return b The amount in Ray, converted from the specified decimal precision.\n     *           Ensures that the conversion maintains the value's integrity (no overflow).\n     */\n    function toRay(uint256 _a, uint256 _decimals) internal pure returns (uint256 b) {\n        uint256 decimals_ratio = 10 ** (RAY_DECIMALS - _decimals);\n        // to avoid overflow, b/decimals_ratio == _a\n        assembly {\n            b := mul(_a, decimals_ratio)\n\n            if iszero(eq(div(b, decimals_ratio), _a)) {\n                revert(0, 0)\n            }\n        }\n    }\n}\n"
    },
    "src/interfaces/IRouter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.20;\n\n// https://github.com/Uniswap/universal-router/blob/main/contracts/interfaces/IUniversalRouter.sol\n\ninterface IRouter {\n    /// @notice Thrown when executing commands with an expired deadline\n    error TransactionDeadlinePassed();\n\n    /// @notice Thrown when attempting to execute commands and an incorrect number of inputs are provided\n    error LengthMismatch();\n\n    /// @notice Thrown when onFlashloan() is called directly, rather than through a command execution\n    error DirectOnFlashloanCall();\n\n    /// @notice Thrown when onFlashloan() is called by an address other than flashloan lender\n    error UnauthorizedOnFlashloanCaller();\n\n    /// @notice Thrown when an address other than msgSender and Router reenters execute()\n    error UnauthorizedReentrantCall();\n\n    /**\n     * @notice Toggle Pause\n     * @dev Should only be called in extraordinary situations by the admin of the contract\n     * @dev See {PausableUpgradeable-_pause}\n     */\n    function pause() external;\n\n    /**\n     * @notice Toggle UnPause\n     * @dev Should only be called in extraordinary situations by the admin of the contract\n     * @dev See {PausableUpgradeable-_unpause}\n     */\n    function unPause() external;\n\n    /**\n     * @notice Getter for the registry\n     * @return The address of the registry\n     */\n    function getRegistry() external view returns (address);\n\n    /**\n     * @dev Getter for the router utility contract\n     * @return The address of the router utility contract\n     */\n    function getRouterUtil() external view returns (address);\n\n    /**\n     * @dev Getter for the Kyberswap Router\n     * @return The address of the Kyberswap Router\n     */\n    function getKyberRouter() external view returns (address);\n\n    /**\n     * @dev Setter for the router utility contract\n     * @param _routerUtil The new address of the router utility contract\n     */\n    function setRouterUtil(address _routerUtil) external;\n\n    /**\n     * @dev Setter for the Kyberswap Router\n     * @param _kyberRouter The new address of the Kyberswap Router\n     */\n    function setKyberRouter(address _kyberRouter) external;\n\n    /**\n     * @dev Executes encoded commands along with provided inputs\n     * Reverts if deadline has expired\n     * @param _commands A set of concatenated commands, each 1 byte in length\n     * @param _inputs An array of byte strings containing ABI-encoded inputs for each command\n     * @param _deadline The deadline by which the transaction must be executed\n     */\n    function execute(\n        bytes calldata _commands,\n        bytes[] calldata _inputs,\n        uint256 _deadline\n    ) external payable;\n\n    /**\n     * @dev Executes encoded commands along with provided inputs\n     * @param _commands A set of concatenated commands, each 1 byte in length\n     * @param _inputs An array of byte strings containing ABI-encoded inputs for each command\n     */\n    function execute(bytes calldata _commands, bytes[] calldata _inputs) external payable;\n\n    /**\n     * @dev Simulates encoded commands along with provided inputs and returns the resulting rate\n     * The rate is calculated as follows: rate = ray_unit * output_token_amount / input_token_amount\n     * @param _commands A set of concatenated commands, each 1 byte in length\n     * @param _inputs An array of byte strings containing ABI-encoded inputs for each command\n     * @return The preview rate value, which represents the amount of output token obtained at the end of execution\n     * for each wei of input token spent at the start of execution, multiplied by 1 ray unit.\n     */\n    function previewRate(\n        bytes calldata _commands,\n        bytes[] calldata _inputs\n    ) external view returns (uint256);\n\n    /**\n     * @dev Simulates encoded commands along with provided inputs and returns the resulting spot rate.\n     * As opposed to `previewRate`, spot exchange rates will be used for swaps. Additionally for all commands,\n     * input amounts are disregarded, and one unit of the token of interest is used instead.\n     * @param _commands A set of concatenated commands, each 1 byte in length\n     * @param _inputs An array of byte strings containing ABI-encoded inputs for each command\n     * @return The preview spot rate value, which represents the amount of output token obtained at the end of execution\n     * for each wei of input token spent at the start of execution, multiplied by 1 ray unit.\n     */\n\n    function previewSpotRate(\n        bytes calldata _commands,\n        bytes[] calldata _inputs\n    ) external view returns (uint256);\n}\n"
    },
    "src/router/Dispatcher.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.20;\n\nimport {Math} from \"openzeppelin-math/Math.sol\";\nimport {IERC20Permit} from \"openzeppelin-contracts/token/ERC20/extensions/IERC20Permit.sol\";\nimport {IERC3156FlashBorrower} from \"openzeppelin-contracts/interfaces/IERC3156FlashBorrower.sol\";\nimport {IERC3156FlashLender} from \"openzeppelin-contracts/interfaces/IERC3156FlashLender.sol\";\nimport {IERC4626} from \"openzeppelin-contracts/interfaces/IERC4626.sol\";\nimport {SafeERC20, IERC20} from \"openzeppelin-contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Initializable} from \"openzeppelin-contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {Commands} from \"./Commands.sol\";\nimport {Constants} from \"./Constants.sol\";\nimport {RayMath} from \"../libraries/RayMath.sol\";\nimport {CurvePoolUtil} from \"../libraries/CurvePoolUtil.sol\";\nimport {ICurvePool} from \"../interfaces/ICurvePool.sol\";\nimport {IStableSwapNG} from \"../interfaces/IStableSwapNG.sol\";\nimport {ICurveNGPool} from \"../interfaces/ICurveNGPool.sol\";\nimport {IPrincipalToken} from \"src/interfaces/IPrincipalToken.sol\";\nimport {IRegistry} from \"../interfaces/IRegistry.sol\";\nimport {ISpectra4626Wrapper} from \"../interfaces/ISpectra4626Wrapper.sol\";\nimport {RouterUtil} from \"./util/RouterUtil.sol\";\nimport {INATIVE} from \"../interfaces/INATIVE.sol\";\n\nabstract contract Dispatcher is Initializable {\n    using SafeERC20 for IERC20;\n    using Math for uint256;\n    using RayMath for uint256;\n\n    error InvalidCommandType(uint256 commandType);\n    error MinimumBalanceNotReached(\n        address token,\n        address owner,\n        uint256 minimumBalance,\n        uint256 actualBalance\n    );\n\n    error InvalidFlashloanLender(address lender);\n    error AddressError();\n    error AmountError();\n    error CallFailed();\n    error PermitFailed();\n    error MaxInvolvedTokensExceeded();\n    error BalanceUnderflow();\n    error KyberRouterNotSet();\n\n    // used for tracking balance changes in _previewRate\n    struct TokenBalance {\n        address token;\n        uint256 balance;\n    }\n\n    /** @dev registry of the protocol */\n    address internal immutable registry;\n    /** @dev used during a router execution to track the initiator of the execution */\n    address internal msgSender;\n    /** @dev used during a flashloan execution to track the lender address */\n    address internal flashloanLender;\n    /** @notice Router Util contract */\n    address internal routerUtil;\n    /** @notice Kyberswap Router */\n    address internal kyberRouter;\n    /** @dev used during a router execution to track the msg.value */\n    uint256 internal msgValue;\n\n    constructor(address _registry) {\n        if (_registry == address(0)) {\n            revert AddressError();\n        }\n        registry = _registry;\n    }\n\n    function __Dispatcher_init(\n        address _routerUtil,\n        address _kyberRouter\n    ) internal onlyInitializing {\n        if (_routerUtil == address(0)) {\n            revert AddressError();\n        }\n        routerUtil = _routerUtil;\n        kyberRouter = _kyberRouter;\n    }\n\n    receive() external payable {}\n\n    /**\n     * @dev Executes a single command along with its encoded input data\n     * @param _commandType The encoded representation of the command\n     * @param _inputs The encoded arguments for the specified command\n     */\n    function _dispatch(bytes1 _commandType, bytes calldata _inputs) internal {\n        uint256 command = uint8(_commandType & Commands.COMMAND_TYPE_MASK);\n\n        if (command == Commands.TRANSFER_FROM) {\n            (address token, uint256 value) = abi.decode(_inputs, (address, uint256));\n            IERC20(token).safeTransferFrom(msgSender, address(this), value);\n        } else if (command == Commands.TRANSFER_FROM_WITH_PERMIT) {\n            (address token, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) = abi\n                .decode(_inputs, (address, uint256, uint256, uint8, bytes32, bytes32));\n            try IERC20Permit(token).permit(msgSender, address(this), value, deadline, v, r, s) {\n                // Permit executed successfully, proceed\n            } catch {\n                // Check allowance to see if permit was already executed\n                uint256 allowance = IERC20(token).allowance(msgSender, address(this));\n                if (allowance < value) {\n                    revert PermitFailed();\n                }\n            }\n            IERC20(token).safeTransferFrom(msgSender, address(this), value);\n        } else if (command == Commands.TRANSFER) {\n            (address token, address recipient, uint256 value) = abi.decode(\n                _inputs,\n                (address, address, uint256)\n            );\n            recipient = _resolveAddress(recipient);\n            value = _resolveTokenValue(token, value);\n            if (value != 0) {\n                IERC20(token).safeTransfer(recipient, value);\n            }\n        } else if (\n            command == Commands.CURVE_SWAP ||\n            command == Commands.CURVE_NG_SWAP ||\n            command == Commands.CURVE_SWAP_SNG\n        ) {\n            (\n                address pool,\n                uint256 i,\n                uint256 j,\n                uint256 amountIn,\n                uint256 minAmountOut,\n                address recipient\n            ) = abi.decode(_inputs, (address, uint256, uint256, uint256, uint256, address));\n            // pool.coins(i) is the token to be swapped\n            address token = ICurvePool(pool).coins(i);\n            amountIn = _resolveTokenValue(token, amountIn);\n            recipient = _resolveAddress(recipient);\n            IERC20(token).forceApprove(pool, amountIn);\n            if (command == Commands.CURVE_SWAP) {\n                ICurvePool(pool).exchange(\n                    i,\n                    j,\n                    amountIn,\n                    minAmountOut,\n                    false, // Do not use ETH\n                    recipient\n                );\n            } else if (command == Commands.CURVE_NG_SWAP) {\n                ICurveNGPool(pool).exchange(i, j, amountIn, minAmountOut, recipient);\n            } else {\n                IStableSwapNG(pool).exchange(\n                    int128(int256(i)),\n                    int128(int256(j)),\n                    amountIn,\n                    minAmountOut,\n                    recipient\n                );\n            }\n            IERC20(token).forceApprove(pool, 0);\n        } else if (command == Commands.WRAP_VAULT_IN_4626_ADAPTER) {\n            (\n                address wrapper,\n                uint256 vaultShares,\n                address recipient,\n                uint256 minWrapperShares\n            ) = abi.decode(_inputs, (address, uint256, address, uint256));\n            address vault = ISpectra4626Wrapper(wrapper).vaultShare();\n            recipient = _resolveAddress(recipient);\n            vaultShares = _resolveTokenValue(vault, vaultShares);\n            IERC20(vault).forceApprove(wrapper, vaultShares);\n            ISpectra4626Wrapper(wrapper).wrap(vaultShares, recipient, minWrapperShares);\n            IERC20(vault).forceApprove(wrapper, 0);\n        } else if (command == Commands.UNWRAP_VAULT_FROM_4626_ADAPTER) {\n            (\n                address wrapper,\n                uint256 wrapperShares,\n                address recipient,\n                uint256 minVaultShares\n            ) = abi.decode(_inputs, (address, uint256, address, uint256));\n            recipient = _resolveAddress(recipient);\n            wrapperShares = _resolveTokenValue(wrapper, wrapperShares);\n            ISpectra4626Wrapper(wrapper).unwrap(\n                wrapperShares,\n                recipient,\n                address(this),\n                minVaultShares\n            );\n        } else if (command == Commands.DEPOSIT_ASSET_IN_IBT) {\n            (address ibt, uint256 assets, address recipient) = abi.decode(\n                _inputs,\n                (address, uint256, address)\n            );\n            address asset = IERC4626(ibt).asset();\n            assets = _resolveTokenValue(asset, assets);\n            recipient = _resolveAddress(recipient);\n            IERC20(asset).forceApprove(ibt, assets);\n            IERC4626(ibt).deposit(assets, recipient);\n            IERC20(asset).forceApprove(ibt, 0);\n        } else if (command == Commands.DEPOSIT_ASSET_IN_PT) {\n            (\n                address pt,\n                uint256 assets,\n                address ptRecipient,\n                address ytRecipient,\n                uint256 minShares\n            ) = abi.decode(_inputs, (address, uint256, address, address, uint256));\n            address asset = IPrincipalToken(pt).underlying();\n            assets = _resolveTokenValue(asset, assets);\n            ptRecipient = _resolveAddress(ptRecipient);\n            ytRecipient = _resolveAddress(ytRecipient);\n            bool isRegisteredPT = IRegistry(registry).isRegisteredPT(pt);\n            if (isRegisteredPT) {\n                _ensureApproved(asset, pt, assets);\n            } else {\n                IERC20(asset).forceApprove(pt, assets);\n            }\n            IPrincipalToken(pt).deposit(assets, ptRecipient, ytRecipient, minShares);\n            if (!isRegisteredPT) {\n                IERC20(asset).forceApprove(pt, 0);\n            }\n        } else if (command == Commands.DEPOSIT_IBT_IN_PT) {\n            (\n                address pt,\n                uint256 ibts,\n                address ptRecipient,\n                address ytRecipient,\n                uint256 minShares\n            ) = abi.decode(_inputs, (address, uint256, address, address, uint256));\n            address ibt = IPrincipalToken(pt).getIBT();\n            ibts = _resolveTokenValue(ibt, ibts);\n            ptRecipient = _resolveAddress(ptRecipient);\n            ytRecipient = _resolveAddress(ytRecipient);\n            bool isRegisteredPT = IRegistry(registry).isRegisteredPT(pt);\n            if (isRegisteredPT) {\n                _ensureApproved(ibt, pt, ibts);\n            } else {\n                IERC20(ibt).forceApprove(pt, ibts);\n            }\n            IPrincipalToken(pt).depositIBT(ibts, ptRecipient, ytRecipient, minShares);\n            if (!isRegisteredPT) {\n                IERC20(ibt).forceApprove(pt, 0);\n            }\n        } else if (command == Commands.REDEEM_IBT_FOR_ASSET) {\n            (address ibt, uint256 shares, address recipient) = abi.decode(\n                _inputs,\n                (address, uint256, address)\n            );\n            shares = _resolveTokenValue(ibt, shares);\n            recipient = _resolveAddress(recipient);\n            IERC4626(ibt).redeem(shares, recipient, address(this));\n        } else if (command == Commands.REDEEM_PT_FOR_ASSET || command == Commands.REDEEM_PT_FOR_IBT) {\n            (address pt, uint256 shares, address recipient, uint256 minOut) = abi.decode(\n                _inputs,\n                (address, uint256, address, uint256)\n            );\n            recipient = _resolveAddress(recipient);\n            shares = _resolveTokenValue(pt, shares);\n            uint256 redeemShares = block.timestamp < IPrincipalToken(pt).maturity()\n            ? Math.min(shares, IERC20(IPrincipalToken(pt).getYT()).balanceOf(address(this)))\n            : shares;\n            if (command == Commands.REDEEM_PT_FOR_ASSET) {\n                IPrincipalToken(pt).redeem(redeemShares, recipient, address(this), minOut);\n            } else {\n                IPrincipalToken(pt).redeemForIBT(redeemShares, recipient, address(this), minOut);\n            }\n        } else if (command == Commands.FLASH_LOAN) {\n            (address lender, address token, uint256 amount, bytes memory data) = abi.decode(\n                _inputs,\n                (address, address, uint256, bytes)\n            );\n            if (!IRegistry(registry).isRegisteredPT(lender)) {\n                revert InvalidFlashloanLender(lender);\n            }\n            flashloanLender = lender;\n            IERC3156FlashLender(lender).flashLoan(\n                IERC3156FlashBorrower(address(this)),\n                token,\n                amount,\n                data\n            );\n            flashloanLender = address(0);\n        } else if (\n            command == Commands.CURVE_SPLIT_IBT_LIQUIDITY ||\n            command == Commands.CURVE_NG_SPLIT_IBT_LIQUIDITY ||\n            command == Commands.CURVE_SPLIT_IBT_LIQUIDITY_SNG\n        ) {\n            (\n                address pool,\n                uint256 ibts,\n                address recipient,\n                address ytRecipient,\n                uint256 minPTShares\n            ) = abi.decode(_inputs, (address, uint256, address, address, uint256));\n            recipient = _resolveAddress(recipient);\n            ytRecipient = _resolveAddress(ytRecipient);\n            address ibt = ICurvePool(pool).coins(0);\n            address pt = ICurvePool(pool).coins(1);\n            ibts = _resolveTokenValue(ibt, ibts);\n            uint256 ibtToDepositInPT = CurvePoolUtil.calcIBTsToTokenizeForCurvePool(ibts, pool, pt);\n            if (ibtToDepositInPT != 0) {\n                bool isRegisteredPT = IRegistry(registry).isRegisteredPT(pt);\n                if (isRegisteredPT) {\n                    _ensureApproved(ibt, pt, ibtToDepositInPT);\n                } else {\n                    IERC20(ibt).forceApprove(pt, ibtToDepositInPT);\n                }\n                IPrincipalToken(pt).depositIBT(\n                    ibtToDepositInPT,\n                    recipient,\n                    ytRecipient,\n                    minPTShares\n                );\n                if (!isRegisteredPT) {\n                    IERC20(ibt).forceApprove(pt, 0);\n                }\n            }\n            if (recipient != address(this) && (ibts - ibtToDepositInPT) != 0) {\n                IERC20(ibt).safeTransfer(recipient, ibts - ibtToDepositInPT);\n            }\n        } else if (\n            command == Commands.CURVE_SPLIT_IBT_LIQUIDITY_CUSTOM_PROP ||\n            command == Commands.CURVE_SPLIT_IBT_LIQUIDITY_CUSTOM_PROP_NG ||\n            command == Commands.CURVE_SPLIT_IBT_LIQUIDITY_CUSTOM_PROP_SNG\n        ) {\n            (\n                address pool,\n                uint256 ibts,\n                uint256 prop,\n                address recipient,\n                address ytRecipient,\n                uint256 minPTShares\n            ) = abi.decode(_inputs, (address, uint256, uint256, address, address, uint256));\n            recipient = _resolveAddress(recipient);\n            ytRecipient = _resolveAddress(ytRecipient);\n            address ibt = ICurvePool(pool).coins(0);\n            address pt = ICurvePool(pool).coins(1);\n            ibts = _resolveTokenValue(ibt, ibts);\n            uint256 ibtToDepositInPT = CurvePoolUtil.calcIBTsToTokenizeForCurvePoolCustomProp(\n                ibts,\n                prop,\n                pt\n            );\n            if (ibtToDepositInPT != 0) {\n                bool isRegisteredPT = IRegistry(registry).isRegisteredPT(pt);\n                if (isRegisteredPT) {\n                    _ensureApproved(ibt, pt, ibtToDepositInPT);\n                } else {\n                    IERC20(ibt).forceApprove(pt, ibtToDepositInPT);\n                }\n                IPrincipalToken(pt).depositIBT(\n                    ibtToDepositInPT,\n                    recipient,\n                    ytRecipient,\n                    minPTShares\n                );\n                if (!isRegisteredPT) {\n                    IERC20(ibt).forceApprove(pt, 0);\n                }\n            }\n            if (recipient != address(this) && (ibts - ibtToDepositInPT) != 0) {\n                IERC20(ibt).safeTransfer(recipient, ibts - ibtToDepositInPT);\n            }\n        } else if (\n            command == Commands.CURVE_ADD_LIQUIDITY || command == Commands.CURVE_NG_ADD_LIQUIDITY\n        ) {\n            (\n                address pool,\n                uint256[2] memory amounts,\n                uint256 min_mint_amount,\n                address recipient\n            ) = abi.decode(_inputs, (address, uint256[2], uint256, address));\n            recipient = _resolveAddress(recipient);\n            address ibt = ICurvePool(pool).coins(0);\n            address pt = ICurvePool(pool).coins(1);\n            amounts[0] = _resolveTokenValue(ibt, amounts[0]);\n            amounts[1] = _resolveTokenValue(pt, amounts[1]);\n            IERC20(ibt).forceApprove(pool, amounts[0]);\n            IERC20(pt).forceApprove(pool, amounts[1]);\n            (command == Commands.CURVE_ADD_LIQUIDITY)\n                ? ICurvePool(pool).add_liquidity(amounts, min_mint_amount, false, recipient)\n                : ICurveNGPool(pool).add_liquidity(amounts, min_mint_amount, recipient);\n            IERC20(ibt).forceApprove(pool, 0);\n            IERC20(pt).forceApprove(pool, 0);\n        } else if (\n            command == Commands.CURVE_REMOVE_LIQUIDITY ||\n            command == Commands.CURVE_NG_REMOVE_LIQUIDITY\n        ) {\n            (address pool, uint256 lps, uint256[2] memory min_amounts, address recipient) = abi\n                .decode(_inputs, (address, uint256, uint256[2], address));\n            recipient = _resolveAddress(recipient);\n            address lpToken = (command == Commands.CURVE_REMOVE_LIQUIDITY)\n                ? ICurvePool(pool).token()\n                : pool;\n            lps = _resolveTokenValue(lpToken, lps);\n            (command == Commands.CURVE_REMOVE_LIQUIDITY)\n                ? ICurvePool(pool).remove_liquidity(lps, min_amounts, false, recipient)\n                : ICurveNGPool(pool).remove_liquidity(lps, min_amounts, recipient);\n        } else if (\n            command == Commands.CURVE_NG_REMOVE_LIQUIDITY_ONE_COIN ||\n            command == Commands.CURVE_REMOVE_LIQUIDITY_ONE_COIN\n        ) {\n            (address pool, uint256 lps, uint256 i, uint256 min_amount, address recipient) = abi\n                .decode(_inputs, (address, uint256, uint256, uint256, address));\n            recipient = _resolveAddress(recipient);\n            address lpToken = (command == Commands.CURVE_REMOVE_LIQUIDITY_ONE_COIN)\n                ? ICurvePool(pool).token()\n                : pool;\n            lps = _resolveTokenValue(lpToken, lps);\n            (command == Commands.CURVE_REMOVE_LIQUIDITY_ONE_COIN)\n                ? ICurvePool(pool).remove_liquidity_one_coin(lps, i, min_amount, false, recipient)\n                : ICurveNGPool(pool).remove_liquidity_one_coin(lps, i, min_amount, recipient);\n        } else if (command == Commands.KYBER_SWAP) {\n            if (kyberRouter == address(0)) {\n                revert KyberRouterNotSet();\n            }\n            (address tokenIn, uint256 amountIn, address tokenOut, , bytes memory targetData) = abi\n                .decode(_inputs, (address, uint256, address, uint256, bytes));\n            if (tokenOut == Constants.ETH) {\n                revert AddressError();\n            }\n            if (tokenIn == Constants.ETH) {\n                if (msgValue != amountIn) {\n                    revert AmountError();\n                }\n                (bool success, ) = kyberRouter.call{value: msgValue}(targetData);\n                if (!success) {\n                    revert CallFailed();\n                }\n            } else {\n                amountIn = _resolveTokenValue(tokenIn, amountIn);\n                IERC20(tokenIn).forceApprove(kyberRouter, amountIn);\n                (bool success, ) = kyberRouter.call(targetData);\n                if (!success) {\n                    revert CallFailed();\n                }\n                IERC20(tokenIn).forceApprove(kyberRouter, 0);\n            }\n        } else if (command == Commands.ASSERT_MIN_BALANCE) {\n            (address token, address owner, uint256 minValue) = abi.decode(\n                _inputs,\n                (address, address, uint256)\n            );\n            owner = _resolveAddress(owner);\n            uint256 balance = IERC20(token).balanceOf(owner);\n            if (balance < minValue) {\n                revert MinimumBalanceNotReached(token, owner, minValue, balance);\n            }\n        } else if (command == Commands.CURVE_ADD_LIQUIDITY_SNG) {\n            (\n                address pool,\n                uint256[] memory amounts,\n                uint256 min_mint_amount,\n                address recipient\n            ) = abi.decode(_inputs, (address, uint256[], uint256, address));\n\n            recipient = _resolveAddress(recipient);\n            address ibt = IStableSwapNG(pool).coins(0);\n            address pt = IStableSwapNG(pool).coins(1);\n            amounts[0] = _resolveTokenValue(ibt, amounts[0]);\n            amounts[1] = _resolveTokenValue(pt, amounts[1]);\n            IERC20(ibt).forceApprove(pool, amounts[0]);\n            IERC20(pt).forceApprove(pool, amounts[1]);\n            IStableSwapNG(pool).add_liquidity(amounts, min_mint_amount, recipient);\n            IERC20(ibt).forceApprove(pool, 0);\n            IERC20(pt).forceApprove(pool, 0);\n        } else if (command == Commands.CURVE_REMOVE_LIQUIDITY_SNG) {\n            (address pool, uint256 lps, uint256[] memory min_amounts, address recipient) = abi\n                .decode(_inputs, (address, uint256, uint256[], address));\n            recipient = _resolveAddress(recipient);\n            lps = _resolveTokenValue(pool, lps);\n            IStableSwapNG(pool).remove_liquidity(lps, min_amounts, recipient);\n        } else if (command == Commands.CURVE_REMOVE_LIQUIDITY_ONE_COIN_SNG) {\n            (address pool, uint256 lps, int128 i, uint256 min_amount, address recipient) = abi\n                .decode(_inputs, (address, uint256, int128, uint256, address));\n            recipient = _resolveAddress(recipient);\n            lps = _resolveTokenValue(pool, lps);\n            IStableSwapNG(pool).remove_liquidity_one_coin(lps, i, min_amount, recipient);\n        } else if (command == Commands.DEPOSIT_NATIVE_IN_WRAPPER) {\n            (address wrapper, uint256 amount) = abi.decode(_inputs, (address, uint256));\n            INATIVE(wrapper).deposit{value: amount}();\n        } else if (command == Commands.WITHDRAW_NATIVE_FROM_WRAPPER) {\n            (address wrapper, uint256 amount) = abi.decode(_inputs, (address, uint256));\n            INATIVE(wrapper).withdraw(amount);\n        } else if (command == Commands.TRANSFER_NATIVE) {\n            (address recipient, uint256 amount) = abi.decode(_inputs, (address, uint256));\n            (bool success, ) = payable(recipient).call{value: amount}(\"\");\n            if (!success) {\n                revert CallFailed();\n            }\n        } else {\n            revert InvalidCommandType(command);\n        }\n    }\n\n    /**\n     * @dev Returns either the input token value as is, or replaced with its corresponding behaviour in Constants.sol\n     * @param _token The address of the token\n     * @param _value The token amount\n     * @return The amount stored previously if current amount used for detecting contract balance, else current value\n     */\n    function _resolveTokenValue(address _token, uint256 _value) internal view returns (uint256) {\n        return\n            (_value == Constants.CONTRACT_BALANCE)\n                ? IERC20(_token).balanceOf(address(this))\n                : _value;\n    }\n\n    /**\n     * @dev Returns either the input address as is, or replaced with its corresponding behaviour in Constants.sol\n     * @param _input The input address\n     * @return The address corresponding to input\n     */\n    function _resolveAddress(address _input) internal view returns (address) {\n        if (_input == Constants.ADDRESS_THIS) {\n            return address(this);\n        } else if (_input == Constants.MSG_SENDER) {\n            return msgSender;\n        } else {\n            return _input;\n        }\n    }\n\n    /**\n     * @dev Checks the allowance of a token and approves the spender if necessary\n     * @param _token address of the token to be approved\n     * @param _spender address of the spender\n     * @param _value token amount\n     */\n    function _ensureApproved(address _token, address _spender, uint256 _value) internal {\n        uint256 allowance = IERC20(_token).allowance(address(this), _spender);\n        if (allowance < _value) {\n            // This approval will only be executed the first time to save gas for subsequent operations\n            IERC20(_token).forceApprove(_spender, type(uint256).max);\n        }\n    }\n\n    /**\n     * @dev Simulates the execution of a command and returns the expected resulting rate\n     * @param _commandType The encoded representation of the command\n     * @param _inputs The encoded arguments for the specified command\n     * @param _spot If set to true, spot exchange rate is used for swaps. Additionally for all commands,\n     *              input amounts are disregarded, and one unit of the token of interest is used instead.\n     *              If set to false, the function includes price impact and curve pool fees for swaps.\n     * @param _balances Array of balances to track balances changes during this preview\n     * @return The preview rate value, which represents the amount of output token obtained for each wei\n     * of input token, multiplied by 1 ray unit.\n     */\n    function _dispatchPreviewRate(\n        bytes1 _commandType,\n        bytes calldata _inputs,\n        bool _spot,\n        TokenBalance[] memory _balances\n    ) internal view returns (uint256) {\n        uint256 command = uint8(_commandType & Commands.COMMAND_TYPE_MASK);\n        if (command == Commands.TRANSFER_FROM || command == Commands.TRANSFER_FROM_WITH_PERMIT) {\n            if (!_spot) {\n                (address token, uint256 value) = abi.decode(_inputs, (address, uint256));\n                _increasePreviewTokenValue(value, token, _balances);\n            }\n            return RayMath.RAY_UNIT;\n        } else if (command == Commands.TRANSFER) {\n            if (!_spot) {\n                (address token, address recipient, uint256 value) = abi.decode(\n                    _inputs,\n                    (address, address, uint256)\n                );\n                recipient = _resolveAddress(recipient);\n                if (recipient != address(this)) {\n                    _decreasePreviewTokenValue(value, token, _balances);\n                }\n            }\n            return RayMath.RAY_UNIT;\n        } else if (\n            command == Commands.CURVE_SWAP ||\n            command == Commands.CURVE_NG_SWAP ||\n            command == Commands.CURVE_SWAP_SNG\n        ) {\n            (address pool, uint256 i, uint256 j, uint256 amountIn, , address recipient) = abi\n                .decode(_inputs, (address, uint256, uint256, uint256, uint256, address));\n            uint256 exchangeRate;\n            if (_spot) {\n                // rate : spotExchangeRate * (ibtUnit / curveUnit) * rayUnit / ibtUnit\n                uint256 rate = (command == Commands.CURVE_SWAP || command == Commands.CURVE_NG_SWAP)\n                    ? RouterUtil(routerUtil).spotExchangeRate(pool, i, j)\n                    : RouterUtil(routerUtil).spotExchangeRateSNG(\n                        pool,\n                        int128(int256(i)),\n                        int128(int256(j))\n                    );\n                exchangeRate = rate.toRay(CurvePoolUtil.CURVE_DECIMALS);\n            } else {\n                amountIn = _decreasePreviewTokenValue(\n                    amountIn,\n                    ICurvePool(pool).coins(i),\n                    _balances\n                );\n                uint256 dy;\n                if (command == Commands.CURVE_SWAP_SNG) {\n                    dy = IStableSwapNG(pool).get_dy(int128(int256(i)), int128(int256(j)), amountIn);\n                } else {\n                    dy = ICurvePool(pool).get_dy(i, j, amountIn);\n                }\n                recipient = _resolveAddress(recipient);\n                if (recipient == address(this)) {\n                    _increasePreviewTokenValue(dy, ICurvePool(pool).coins(j), _balances);\n                }\n                // rate : dy * rayUnit / amountIn\n                exchangeRate = dy.mulDiv(RayMath.RAY_UNIT, amountIn);\n            }\n            return exchangeRate;\n        } else if (command == Commands.WRAP_VAULT_IN_4626_ADAPTER) {\n            (address wrapper, uint256 vaultShares, address recipient) = abi.decode(\n                _inputs,\n                (address, uint256, address)\n            );\n            address vault = ISpectra4626Wrapper(wrapper).vaultShare();\n            if (_spot) {\n                vaultShares = RouterUtil(routerUtil).getUnit(vault);\n            } else {\n                vaultShares = _decreasePreviewTokenValue(vaultShares, vault, _balances);\n            }\n            uint256 _expectedWrapperShares = ISpectra4626Wrapper(wrapper).previewWrap(vaultShares);\n            recipient = _resolveAddress(recipient);\n            if (recipient == address(this)) {\n                _increasePreviewTokenValue(_expectedWrapperShares, wrapper, _balances);\n            }\n            // rate : expectedWrapperShares * rayUnit / vaultShares\n            return _expectedWrapperShares.mulDiv(RayMath.RAY_UNIT, vaultShares);\n        } else if (command == Commands.UNWRAP_VAULT_FROM_4626_ADAPTER) {\n            (address wrapper, uint256 wrapperShares, address recipient) = abi.decode(\n                _inputs,\n                (address, uint256, address)\n            );\n            if (_spot) {\n                wrapperShares = RouterUtil(routerUtil).getUnit(wrapper);\n            } else {\n                wrapperShares = _decreasePreviewTokenValue(wrapperShares, wrapper, _balances);\n            }\n            uint256 _expectedVaultShares = ISpectra4626Wrapper(wrapper).previewUnwrap(\n                wrapperShares\n            );\n            recipient = _resolveAddress(recipient);\n            if (recipient == address(this)) {\n                _increasePreviewTokenValue(\n                    _expectedVaultShares,\n                    ISpectra4626Wrapper(wrapper).vaultShare(),\n                    _balances\n                );\n            }\n            // rate : expectedVaultShares * rayUnit / wrapperShares\n            return _expectedVaultShares.mulDiv(RayMath.RAY_UNIT, wrapperShares);\n        } else if (command == Commands.DEPOSIT_ASSET_IN_IBT) {\n            (address ibt, uint256 assets, address recipient) = abi.decode(\n                _inputs,\n                (address, uint256, address)\n            );\n            address asset = IERC4626(ibt).asset();\n            if (_spot) {\n                assets = RouterUtil(routerUtil).getUnit(asset);\n            } else {\n                assets = _decreasePreviewTokenValue(assets, asset, _balances);\n            }\n            uint256 _expectedShares = IERC4626(ibt).previewDeposit(assets);\n            recipient = _resolveAddress(recipient);\n            if (recipient == address(this)) {\n                _increasePreviewTokenValue(_expectedShares, ibt, _balances);\n            }\n            // rate : shares * rayUnit / assets\n            return _expectedShares.mulDiv(RayMath.RAY_UNIT, assets);\n        } else if (command == Commands.DEPOSIT_ASSET_IN_PT) {\n            (address pt, uint256 assets, address ptRecipient, address ytRecipient) = abi.decode(\n                _inputs,\n                (address, uint256, address, address)\n            );\n            if (_spot) {\n                assets = RouterUtil(routerUtil).getPTUnderlyingUnit(pt);\n            } else {\n                assets = _decreasePreviewTokenValue(\n                    assets,\n                    IPrincipalToken(pt).underlying(),\n                    _balances\n                );\n            }\n            uint256 _expectedShares = IPrincipalToken(pt).previewDeposit(assets);\n            ptRecipient = _resolveAddress(ptRecipient);\n            if (ptRecipient == address(this)) {\n                _increasePreviewTokenValue(_expectedShares, pt, _balances);\n            }\n            ytRecipient = _resolveAddress(ytRecipient);\n            if (ytRecipient == address(this)) {\n                _increasePreviewTokenValue(_expectedShares, IPrincipalToken(pt).getYT(), _balances);\n            }\n            // rate : shares * rayUnit / assets\n            return _expectedShares.mulDiv(RayMath.RAY_UNIT, assets);\n        } else if (command == Commands.DEPOSIT_IBT_IN_PT) {\n            (address pt, uint256 ibts, address ptRecipient, address ytRecipient) = abi.decode(\n                _inputs,\n                (address, uint256, address, address)\n            );\n            if (_spot) {\n                ibts = RouterUtil(routerUtil).getUnit(pt);\n            } else {\n                ibts = _decreasePreviewTokenValue(ibts, IPrincipalToken(pt).getIBT(), _balances);\n            }\n            uint256 _expectedShares = IPrincipalToken(pt).previewDepositIBT(ibts);\n            ptRecipient = _resolveAddress(ptRecipient);\n            if (ptRecipient == address(this)) {\n                _increasePreviewTokenValue(_expectedShares, pt, _balances);\n            }\n            ytRecipient = _resolveAddress(ytRecipient);\n            if (ytRecipient == address(this)) {\n                _increasePreviewTokenValue(_expectedShares, IPrincipalToken(pt).getYT(), _balances);\n            }\n            // rate : shares * rayUnit / ibts\n            return _expectedShares.mulDiv(RayMath.RAY_UNIT, ibts);\n        } else if (command == Commands.REDEEM_IBT_FOR_ASSET) {\n            (address ibt, uint256 shares, address recipient) = abi.decode(\n                _inputs,\n                (address, uint256, address)\n            );\n            if (_spot) {\n                shares = RouterUtil(routerUtil).getUnit(ibt);\n            } else {\n                shares = _decreasePreviewTokenValue(shares, ibt, _balances);\n            }\n            uint256 _expectedAssets = IERC4626(ibt).previewRedeem(shares);\n            recipient = _resolveAddress(recipient);\n            if (recipient == address(this)) {\n                _increasePreviewTokenValue(_expectedAssets, IERC4626(ibt).asset(), _balances);\n            }\n            // rate : assets * rayUnit / shares\n            return _expectedAssets.mulDiv(RayMath.RAY_UNIT, shares);\n        } else if (command == Commands.REDEEM_PT_FOR_ASSET) {\n            (address pt, uint256 shares, address recipient) = abi.decode(\n                _inputs,\n                (address, uint256, address)\n            );\n            if (_spot) {\n                shares = RouterUtil(routerUtil).getUnit(pt);\n            } else {\n                shares = _decreasePreviewTokenValue(shares, pt, _balances);\n                if (block.timestamp < IPrincipalToken(pt).maturity()) {\n                    _decreasePreviewTokenValue(shares, IPrincipalToken(pt).getYT(), _balances);\n                }\n            }\n            uint256 _expectedAssets = IPrincipalToken(pt).previewRedeem(shares);\n            recipient = _resolveAddress(recipient);\n            if (recipient == address(this)) {\n                _increasePreviewTokenValue(\n                    _expectedAssets,\n                    IPrincipalToken(pt).underlying(),\n                    _balances\n                );\n            }\n            // rate : assets * rayUnit / shares\n            return _expectedAssets.mulDiv(RayMath.RAY_UNIT, shares);\n        } else if (command == Commands.REDEEM_PT_FOR_IBT) {\n            (address pt, uint256 shares, address recipient) = abi.decode(\n                _inputs,\n                (address, uint256, address)\n            );\n            if (_spot) {\n                shares = RouterUtil(routerUtil).getUnit(pt);\n            } else {\n                shares = _decreasePreviewTokenValue(shares, pt, _balances);\n                if (block.timestamp < IPrincipalToken(pt).maturity()) {\n                    _decreasePreviewTokenValue(shares, IPrincipalToken(pt).getYT(), _balances);\n                }\n            }\n            uint256 _expectedIBTs = IPrincipalToken(pt).previewRedeemForIBT(shares);\n            recipient = _resolveAddress(recipient);\n            if (recipient == address(this)) {\n                _increasePreviewTokenValue(_expectedIBTs, IPrincipalToken(pt).getIBT(), _balances);\n            }\n            // rate : ibts * rayUnit / shares\n            return _expectedIBTs.mulDiv(RayMath.RAY_UNIT, shares);\n        } else if (command == Commands.KYBER_SWAP) {\n            if (kyberRouter == address(0)) {\n                revert KyberRouterNotSet();\n            }\n            (address tokenIn, uint256 amountIn, address tokenOut, uint256 expectedAmountOut) = abi\n                .decode(_inputs, (address, uint256, address, uint256));\n            if (tokenOut == Constants.ETH) {\n                revert AddressError();\n            }\n            if (tokenIn != Constants.ETH) {\n                amountIn = _decreasePreviewTokenValue(amountIn, tokenIn, _balances);\n            }\n            _increasePreviewTokenValue(expectedAmountOut, tokenOut, _balances);\n\n            // rate : expectedAmountOut * rayUnit / amountIn\n            return expectedAmountOut.mulDiv(RayMath.RAY_UNIT, amountIn);\n        } else if (command == Commands.ASSERT_MIN_BALANCE) {\n            return (RayMath.RAY_UNIT);\n        } else {\n            revert InvalidCommandType(command);\n        }\n    }\n\n    /**\n     * @dev Decrease balance for given token by given value in provided balances array\n     * @param _value The value to subtract from token balance\n     * @param _token The token address\n     * @param _balances The TokenBalance array\n     * @return The actual value to subtract from token balance\n     */\n    function _decreasePreviewTokenValue(\n        uint256 _value,\n        address _token,\n        TokenBalance[] memory _balances\n    ) internal pure returns (uint256) {\n        if (_token == address(0)) {\n            revert AddressError();\n        }\n        uint256 _length = _balances.length;\n        for (uint256 i = 0; i < _length; ++i) {\n            if (_balances[i].token == address(0)) {\n                break;\n            } else if (_balances[i].token == _token) {\n                if (_value == Constants.CONTRACT_BALANCE) {\n                    uint256 _res = _balances[i].balance;\n                    _balances[i].balance = 0;\n                    return _res;\n                } else {\n                    if (_balances[i].balance < _value) {\n                        break;\n                    }\n                    _balances[i].balance -= _value;\n                    return _value;\n                }\n            }\n        }\n        revert BalanceUnderflow();\n    }\n\n    /**\n     * @dev Increase balance for given token by given value in provided balances array\n     * @param _value The value to subtract from token balance\n     * @param _token The token address\n     * @param _balances The TokenBalance array\n     * @return The token balance AFTER increase\n     */\n    function _increasePreviewTokenValue(\n        uint256 _value,\n        address _token,\n        TokenBalance[] memory _balances\n    ) internal pure returns (uint256) {\n        if (_token == address(0)) {\n            revert AddressError();\n        }\n        uint256 _length = _balances.length;\n        for (uint256 i = 0; i < _length; ++i) {\n            if (_balances[i].token == address(0)) {\n                _balances[i] = TokenBalance(_token, _value);\n                return _value;\n            } else if (_balances[i].token == _token) {\n                _balances[i].balance += _value;\n                return _balances[i].balance;\n            }\n        }\n        revert MaxInvolvedTokensExceeded();\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/access/manager/IAuthority.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/manager/IAuthority.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard interface for permissioning originally defined in Dappsys.\n */\ninterface IAuthority {\n    /**\n     * @dev Returns true if the caller can invoke on a target the function identified by a function selector.\n     */\n    function canCall(address caller, address target, bytes4 selector) external view returns (bool allowed);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/access/manager/AuthorityUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/manager/AuthorityUtils.sol)\n\npragma solidity ^0.8.20;\n\nimport {IAuthority} from \"./IAuthority.sol\";\n\nlibrary AuthorityUtils {\n    /**\n     * @dev Since `AccessManager` implements an extended IAuthority interface, invoking `canCall` with backwards compatibility\n     * for the preexisting `IAuthority` interface requires special care to avoid reverting on insufficient return data.\n     * This helper function takes care of invoking `canCall` in a backwards compatible way without reverting.\n     */\n    function canCallWithDelay(\n        address authority,\n        address caller,\n        address target,\n        bytes4 selector\n    ) internal view returns (bool immediate, uint32 delay) {\n        (bool success, bytes memory data) = authority.staticcall(\n            abi.encodeCall(IAuthority.canCall, (caller, target, selector))\n        );\n        if (success) {\n            if (data.length >= 0x40) {\n                (immediate, delay) = abi.decode(data, (bool, uint32));\n            } else if (data.length >= 0x20) {\n                immediate = abi.decode(data, (bool));\n            }\n        }\n        return (immediate, delay);\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/access/manager/IAccessManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/manager/IAccessManager.sol)\n\npragma solidity ^0.8.20;\n\nimport {IAccessManaged} from \"./IAccessManaged.sol\";\nimport {Time} from \"../../utils/types/Time.sol\";\n\ninterface IAccessManager {\n    /**\n     * @dev A delayed operation was scheduled.\n     */\n    event OperationScheduled(\n        bytes32 indexed operationId,\n        uint32 indexed nonce,\n        uint48 schedule,\n        address caller,\n        address target,\n        bytes data\n    );\n\n    /**\n     * @dev A scheduled operation was executed.\n     */\n    event OperationExecuted(bytes32 indexed operationId, uint32 indexed nonce);\n\n    /**\n     * @dev A scheduled operation was canceled.\n     */\n    event OperationCanceled(bytes32 indexed operationId, uint32 indexed nonce);\n\n    /**\n     * @dev Informational labelling for a roleId.\n     */\n    event RoleLabel(uint64 indexed roleId, string label);\n\n    /**\n     * @dev Emitted when `account` is granted `roleId`.\n     *\n     * NOTE: The meaning of the `since` argument depends on the `newMember` argument.\n     * If the role is granted to a new member, the `since` argument indicates when the account becomes a member of the role,\n     * otherwise it indicates the execution delay for this account and roleId is updated.\n     */\n    event RoleGranted(uint64 indexed roleId, address indexed account, uint32 delay, uint48 since, bool newMember);\n\n    /**\n     * @dev Emitted when `account` membership or `roleId` is revoked. Unlike granting, revoking is instantaneous.\n     */\n    event RoleRevoked(uint64 indexed roleId, address indexed account);\n\n    /**\n     * @dev Role acting as admin over a given `roleId` is updated.\n     */\n    event RoleAdminChanged(uint64 indexed roleId, uint64 indexed admin);\n\n    /**\n     * @dev Role acting as guardian over a given `roleId` is updated.\n     */\n    event RoleGuardianChanged(uint64 indexed roleId, uint64 indexed guardian);\n\n    /**\n     * @dev Grant delay for a given `roleId` will be updated to `delay` when `since` is reached.\n     */\n    event RoleGrantDelayChanged(uint64 indexed roleId, uint32 delay, uint48 since);\n\n    /**\n     * @dev Target mode is updated (true = closed, false = open).\n     */\n    event TargetClosed(address indexed target, bool closed);\n\n    /**\n     * @dev Role required to invoke `selector` on `target` is updated to `roleId`.\n     */\n    event TargetFunctionRoleUpdated(address indexed target, bytes4 selector, uint64 indexed roleId);\n\n    /**\n     * @dev Admin delay for a given `target` will be updated to `delay` when `since` is reached.\n     */\n    event TargetAdminDelayUpdated(address indexed target, uint32 delay, uint48 since);\n\n    error AccessManagerAlreadyScheduled(bytes32 operationId);\n    error AccessManagerNotScheduled(bytes32 operationId);\n    error AccessManagerNotReady(bytes32 operationId);\n    error AccessManagerExpired(bytes32 operationId);\n    error AccessManagerLockedAccount(address account);\n    error AccessManagerLockedRole(uint64 roleId);\n    error AccessManagerBadConfirmation();\n    error AccessManagerUnauthorizedAccount(address msgsender, uint64 roleId);\n    error AccessManagerUnauthorizedCall(address caller, address target, bytes4 selector);\n    error AccessManagerUnauthorizedConsume(address target);\n    error AccessManagerUnauthorizedCancel(address msgsender, address caller, address target, bytes4 selector);\n    error AccessManagerInvalidInitialAdmin(address initialAdmin);\n\n    /**\n     * @dev Check if an address (`caller`) is authorised to call a given function on a given contract directly (with\n     * no restriction). Additionally, it returns the delay needed to perform the call indirectly through the {schedule}\n     * & {execute} workflow.\n     *\n     * This function is usually called by the targeted contract to control immediate execution of restricted functions.\n     * Therefore we only return true if the call can be performed without any delay. If the call is subject to a\n     * previously set delay (not zero), then the function should return false and the caller should schedule the operation\n     * for future execution.\n     *\n     * If `immediate` is true, the delay can be disregarded and the operation can be immediately executed, otherwise\n     * the operation can be executed if and only if delay is greater than 0.\n     *\n     * NOTE: The IAuthority interface does not include the `uint32` delay. This is an extension of that interface that\n     * is backward compatible. Some contracts may thus ignore the second return argument. In that case they will fail\n     * to identify the indirect workflow, and will consider calls that require a delay to be forbidden.\n     *\n     * NOTE: This function does not report the permissions of this manager itself. These are defined by the\n     * {_canCallSelf} function instead.\n     */\n    function canCall(\n        address caller,\n        address target,\n        bytes4 selector\n    ) external view returns (bool allowed, uint32 delay);\n\n    /**\n     * @dev Expiration delay for scheduled proposals. Defaults to 1 week.\n     *\n     * IMPORTANT: Avoid overriding the expiration with 0. Otherwise every contract proposal will be expired immediately,\n     * disabling any scheduling usage.\n     */\n    function expiration() external view returns (uint32);\n\n    /**\n     * @dev Minimum setback for all delay updates, with the exception of execution delays. It\n     * can be increased without setback (and reset via {revokeRole} in the case event of an\n     * accidental increase). Defaults to 5 days.\n     */\n    function minSetback() external view returns (uint32);\n\n    /**\n     * @dev Get whether the contract is closed disabling any access. Otherwise role permissions are applied.\n     */\n    function isTargetClosed(address target) external view returns (bool);\n\n    /**\n     * @dev Get the role required to call a function.\n     */\n    function getTargetFunctionRole(address target, bytes4 selector) external view returns (uint64);\n\n    /**\n     * @dev Get the admin delay for a target contract. Changes to contract configuration are subject to this delay.\n     */\n    function getTargetAdminDelay(address target) external view returns (uint32);\n\n    /**\n     * @dev Get the id of the role that acts as an admin for the given role.\n     *\n     * The admin permission is required to grant the role, revoke the role and update the execution delay to execute\n     * an operation that is restricted to this role.\n     */\n    function getRoleAdmin(uint64 roleId) external view returns (uint64);\n\n    /**\n     * @dev Get the role that acts as a guardian for a given role.\n     *\n     * The guardian permission allows canceling operations that have been scheduled under the role.\n     */\n    function getRoleGuardian(uint64 roleId) external view returns (uint64);\n\n    /**\n     * @dev Get the role current grant delay.\n     *\n     * Its value may change at any point without an event emitted following a call to {setGrantDelay}.\n     * Changes to this value, including effect timepoint are notified in advance by the {RoleGrantDelayChanged} event.\n     */\n    function getRoleGrantDelay(uint64 roleId) external view returns (uint32);\n\n    /**\n     * @dev Get the access details for a given account for a given role. These details include the timepoint at which\n     * membership becomes active, and the delay applied to all operation by this user that requires this permission\n     * level.\n     *\n     * Returns:\n     * [0] Timestamp at which the account membership becomes valid. 0 means role is not granted.\n     * [1] Current execution delay for the account.\n     * [2] Pending execution delay for the account.\n     * [3] Timestamp at which the pending execution delay will become active. 0 means no delay update is scheduled.\n     */\n    function getAccess(uint64 roleId, address account) external view returns (uint48, uint32, uint32, uint48);\n\n    /**\n     * @dev Check if a given account currently has the permission level corresponding to a given role. Note that this\n     * permission might be associated with an execution delay. {getAccess} can provide more details.\n     */\n    function hasRole(uint64 roleId, address account) external view returns (bool, uint32);\n\n    /**\n     * @dev Give a label to a role, for improved role discoverability by UIs.\n     *\n     * Requirements:\n     *\n     * - the caller must be a global admin\n     *\n     * Emits a {RoleLabel} event.\n     */\n    function labelRole(uint64 roleId, string calldata label) external;\n\n    /**\n     * @dev Add `account` to `roleId`, or change its execution delay.\n     *\n     * This gives the account the authorization to call any function that is restricted to this role. An optional\n     * execution delay (in seconds) can be set. If that delay is non 0, the user is required to schedule any operation\n     * that is restricted to members of this role. The user will only be able to execute the operation after the delay has\n     * passed, before it has expired. During this period, admin and guardians can cancel the operation (see {cancel}).\n     *\n     * If the account has already been granted this role, the execution delay will be updated. This update is not\n     * immediate and follows the delay rules. For example, if a user currently has a delay of 3 hours, and this is\n     * called to reduce that delay to 1 hour, the new delay will take some time to take effect, enforcing that any\n     * operation executed in the 3 hours that follows this update was indeed scheduled before this update.\n     *\n     * Requirements:\n     *\n     * - the caller must be an admin for the role (see {getRoleAdmin})\n     * - granted role must not be the `PUBLIC_ROLE`\n     *\n     * Emits a {RoleGranted} event.\n     */\n    function grantRole(uint64 roleId, address account, uint32 executionDelay) external;\n\n    /**\n     * @dev Remove an account from a role, with immediate effect. If the account does not have the role, this call has\n     * no effect.\n     *\n     * Requirements:\n     *\n     * - the caller must be an admin for the role (see {getRoleAdmin})\n     * - revoked role must not be the `PUBLIC_ROLE`\n     *\n     * Emits a {RoleRevoked} event if the account had the role.\n     */\n    function revokeRole(uint64 roleId, address account) external;\n\n    /**\n     * @dev Renounce role permissions for the calling account with immediate effect. If the sender is not in\n     * the role this call has no effect.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * Emits a {RoleRevoked} event if the account had the role.\n     */\n    function renounceRole(uint64 roleId, address callerConfirmation) external;\n\n    /**\n     * @dev Change admin role for a given role.\n     *\n     * Requirements:\n     *\n     * - the caller must be a global admin\n     *\n     * Emits a {RoleAdminChanged} event\n     */\n    function setRoleAdmin(uint64 roleId, uint64 admin) external;\n\n    /**\n     * @dev Change guardian role for a given role.\n     *\n     * Requirements:\n     *\n     * - the caller must be a global admin\n     *\n     * Emits a {RoleGuardianChanged} event\n     */\n    function setRoleGuardian(uint64 roleId, uint64 guardian) external;\n\n    /**\n     * @dev Update the delay for granting a `roleId`.\n     *\n     * Requirements:\n     *\n     * - the caller must be a global admin\n     *\n     * Emits a {RoleGrantDelayChanged} event.\n     */\n    function setGrantDelay(uint64 roleId, uint32 newDelay) external;\n\n    /**\n     * @dev Set the role required to call functions identified by the `selectors` in the `target` contract.\n     *\n     * Requirements:\n     *\n     * - the caller must be a global admin\n     *\n     * Emits a {TargetFunctionRoleUpdated} event per selector.\n     */\n    function setTargetFunctionRole(address target, bytes4[] calldata selectors, uint64 roleId) external;\n\n    /**\n     * @dev Set the delay for changing the configuration of a given target contract.\n     *\n     * Requirements:\n     *\n     * - the caller must be a global admin\n     *\n     * Emits a {TargetAdminDelayUpdated} event.\n     */\n    function setTargetAdminDelay(address target, uint32 newDelay) external;\n\n    /**\n     * @dev Set the closed flag for a contract.\n     *\n     * Requirements:\n     *\n     * - the caller must be a global admin\n     *\n     * Emits a {TargetClosed} event.\n     */\n    function setTargetClosed(address target, bool closed) external;\n\n    /**\n     * @dev Return the timepoint at which a scheduled operation will be ready for execution. This returns 0 if the\n     * operation is not yet scheduled, has expired, was executed, or was canceled.\n     */\n    function getSchedule(bytes32 id) external view returns (uint48);\n\n    /**\n     * @dev Return the nonce for the latest scheduled operation with a given id. Returns 0 if the operation has never\n     * been scheduled.\n     */\n    function getNonce(bytes32 id) external view returns (uint32);\n\n    /**\n     * @dev Schedule a delayed operation for future execution, and return the operation identifier. It is possible to\n     * choose the timestamp at which the operation becomes executable as long as it satisfies the execution delays\n     * required for the caller. The special value zero will automatically set the earliest possible time.\n     *\n     * Returns the `operationId` that was scheduled. Since this value is a hash of the parameters, it can reoccur when\n     * the same parameters are used; if this is relevant, the returned `nonce` can be used to uniquely identify this\n     * scheduled operation from other occurrences of the same `operationId` in invocations of {execute} and {cancel}.\n     *\n     * Emits a {OperationScheduled} event.\n     *\n     * NOTE: It is not possible to concurrently schedule more than one operation with the same `target` and `data`. If\n     * this is necessary, a random byte can be appended to `data` to act as a salt that will be ignored by the target\n     * contract if it is using standard Solidity ABI encoding.\n     */\n    function schedule(address target, bytes calldata data, uint48 when) external returns (bytes32, uint32);\n\n    /**\n     * @dev Execute a function that is delay restricted, provided it was properly scheduled beforehand, or the\n     * execution delay is 0.\n     *\n     * Returns the nonce that identifies the previously scheduled operation that is executed, or 0 if the\n     * operation wasn't previously scheduled (if the caller doesn't have an execution delay).\n     *\n     * Emits an {OperationExecuted} event only if the call was scheduled and delayed.\n     */\n    function execute(address target, bytes calldata data) external payable returns (uint32);\n\n    /**\n     * @dev Cancel a scheduled (delayed) operation. Returns the nonce that identifies the previously scheduled\n     * operation that is cancelled.\n     *\n     * Requirements:\n     *\n     * - the caller must be the proposer, a guardian of the targeted function, or a global admin\n     *\n     * Emits a {OperationCanceled} event.\n     */\n    function cancel(address caller, address target, bytes calldata data) external returns (uint32);\n\n    /**\n     * @dev Consume a scheduled operation targeting the caller. If such an operation exists, mark it as consumed\n     * (emit an {OperationExecuted} event and clean the state). Otherwise, throw an error.\n     *\n     * This is useful for contract that want to enforce that calls targeting them were scheduled on the manager,\n     * with all the verifications that it implies.\n     *\n     * Emit a {OperationExecuted} event.\n     */\n    function consumeScheduledOp(address caller, bytes calldata data) external;\n\n    /**\n     * @dev Hashing function for delayed operations.\n     */\n    function hashOperation(address caller, address target, bytes calldata data) external view returns (bytes32);\n\n    /**\n     * @dev Changes the authority of a target managed by this manager instance.\n     *\n     * Requirements:\n     *\n     * - the caller must be a global admin\n     */\n    function updateAuthority(address target, address newAuthority) external;\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/access/manager/IAccessManaged.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/manager/IAccessManaged.sol)\n\npragma solidity ^0.8.20;\n\ninterface IAccessManaged {\n    /**\n     * @dev Authority that manages this contract was updated.\n     */\n    event AuthorityUpdated(address authority);\n\n    error AccessManagedUnauthorized(address caller);\n    error AccessManagedRequiredDelay(address caller, uint32 delay);\n    error AccessManagedInvalidAuthority(address authority);\n\n    /**\n     * @dev Returns the current authority.\n     */\n    function authority() external view returns (address);\n\n    /**\n     * @dev Transfers control to a new authority. The caller must be the current authority.\n     */\n    function setAuthority(address) external;\n\n    /**\n     * @dev Returns true only in the context of a delayed restricted call, at the moment that the scheduled operation is\n     * being consumed. Prevents denial of service for delayed restricted calls in the case that the contract performs\n     * attacker controlled calls.\n     */\n    function isConsumingScheduledOp() external view returns (bytes4);\n}\n"
    },
    "lib/openzeppelin-contracts-upgradeable/contracts/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Context.sol)\n\npragma solidity ^0.8.20;\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "lib/openzeppelin-contracts-upgradeable/contracts/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Storage of the initializable contract.\n     *\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n     * when using with upgradeable contracts.\n     *\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n     */\n    struct InitializableStorage {\n        /**\n         * @dev Indicates that the contract has been initialized.\n         */\n        uint64 _initialized;\n        /**\n         * @dev Indicates that the contract is in the process of being initialized.\n         */\n        bool _initializing;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Initializable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n\n    /**\n     * @dev The contract is already initialized.\n     */\n    error InvalidInitialization();\n\n    /**\n     * @dev The contract is not initializing.\n     */\n    error NotInitializing();\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint64 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n     * production.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        // Cache values to avoid duplicated sloads\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n\n        // Allowed calls:\n        // - initialSetup: the contract is not in the initializing state and no previous version was\n        //                 initialized\n        // - construction: the contract is initialized at version 1 (no reininitialization) and the\n        //                 current contract is just being deployed\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint64 version) {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n\n    /**\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n     */\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n\n    /**\n     * @dev Returns a pointer to the storage namespace.\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/interfaces/IERC3156FlashLender.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC3156FlashLender.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC3156FlashBorrower} from \"./IERC3156FlashBorrower.sol\";\n\n/**\n * @dev Interface of the ERC3156 FlashLender, as defined in\n * https://eips.ethereum.org/EIPS/eip-3156[ERC-3156].\n */\ninterface IERC3156FlashLender {\n    /**\n     * @dev The amount of currency available to be lended.\n     * @param token The loan currency.\n     * @return The amount of `token` that can be borrowed.\n     */\n    function maxFlashLoan(address token) external view returns (uint256);\n\n    /**\n     * @dev The fee to be charged for a given loan.\n     * @param token The loan currency.\n     * @param amount The amount of tokens lent.\n     * @return The amount of `token` to be charged for the loan, on top of the returned principal.\n     */\n    function flashFee(address token, uint256 amount) external view returns (uint256);\n\n    /**\n     * @dev Initiate a flash loan.\n     * @param receiver The receiver of the tokens in the loan, and the receiver of the callback.\n     * @param token The loan currency.\n     * @param amount The amount of tokens lent.\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\n     */\n    function flashLoan(\n        IERC3156FlashBorrower receiver,\n        address token,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (bool);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/interfaces/IERC4626.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC4626.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../token/ERC20/IERC20.sol\";\nimport {IERC20Metadata} from \"../token/ERC20/extensions/IERC20Metadata.sol\";\n\n/**\n * @dev Interface of the ERC4626 \"Tokenized Vault Standard\", as defined in\n * https://eips.ethereum.org/EIPS/eip-4626[ERC-4626].\n */\ninterface IERC4626 is IERC20, IERC20Metadata {\n    event Deposit(address indexed sender, address indexed owner, uint256 assets, uint256 shares);\n\n    event Withdraw(\n        address indexed sender,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /**\n     * @dev Returns the address of the underlying token used for the Vault for accounting, depositing, and withdrawing.\n     *\n     * - MUST be an ERC-20 token contract.\n     * - MUST NOT revert.\n     */\n    function asset() external view returns (address assetTokenAddress);\n\n    /**\n     * @dev Returns the total amount of the underlying asset that is “managed” by Vault.\n     *\n     * - SHOULD include any compounding that occurs from yield.\n     * - MUST be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT revert.\n     */\n    function totalAssets() external view returns (uint256 totalManagedAssets);\n\n    /**\n     * @dev Returns the amount of shares that the Vault would exchange for the amount of assets provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert.\n     *\n     * NOTE: This calculation MAY NOT reflect the “per-user” price-per-share, and instead should reflect the\n     * “average-user’s” price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n    function convertToShares(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Returns the amount of assets that the Vault would exchange for the amount of shares provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert.\n     *\n     * NOTE: This calculation MAY NOT reflect the “per-user” price-per-share, and instead should reflect the\n     * “average-user’s” price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n    function convertToAssets(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Returns the maximum amount of the underlying asset that can be deposited into the Vault for the receiver,\n     * through a deposit call.\n     *\n     * - MUST return a limited value if receiver is subject to some deposit limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of assets that may be deposited.\n     * - MUST NOT revert.\n     */\n    function maxDeposit(address receiver) external view returns (uint256 maxAssets);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their deposit at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of Vault shares that would be minted in a deposit\n     *   call in the same transaction. I.e. deposit should return the same or more shares as previewDeposit if called\n     *   in the same transaction.\n     * - MUST NOT account for deposit limits like those returned from maxDeposit and should always act as though the\n     *   deposit would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewDeposit SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n    function previewDeposit(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Mints shares Vault shares to receiver by depositing exactly amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   deposit execution, and are accounted for during deposit.\n     * - MUST revert if all of assets cannot be deposited (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault’s underlying asset token.\n     */\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\n\n    /**\n     * @dev Returns the maximum amount of the Vault shares that can be minted for the receiver, through a mint call.\n     * - MUST return a limited value if receiver is subject to some mint limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of shares that may be minted.\n     * - MUST NOT revert.\n     */\n    function maxMint(address receiver) external view returns (uint256 maxShares);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their mint at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of assets that would be deposited in a mint call\n     *   in the same transaction. I.e. mint should return the same or fewer assets as previewMint if called in the\n     *   same transaction.\n     * - MUST NOT account for mint limits like those returned from maxMint and should always act as though the mint\n     *   would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewMint SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by minting.\n     */\n    function previewMint(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the mint\n     *   execution, and are accounted for during mint.\n     * - MUST revert if all of shares cannot be minted (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault’s underlying asset token.\n     */\n    function mint(uint256 shares, address receiver) external returns (uint256 assets);\n\n    /**\n     * @dev Returns the maximum amount of the underlying asset that can be withdrawn from the owner balance in the\n     * Vault, through a withdraw call.\n     *\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n    function maxWithdraw(address owner) external view returns (uint256 maxAssets);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their withdrawal at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of Vault shares that would be burned in a withdraw\n     *   call in the same transaction. I.e. withdraw should return the same or fewer shares as previewWithdraw if\n     *   called\n     *   in the same transaction.\n     * - MUST NOT account for withdrawal limits like those returned from maxWithdraw and should always act as though\n     *   the withdrawal would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewWithdraw SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n    function previewWithdraw(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Burns shares from owner and sends exactly assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   withdraw execution, and are accounted for during withdraw.\n     * - MUST revert if all of assets cannot be withdrawn (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * Note that some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n    function withdraw(uint256 assets, address receiver, address owner) external returns (uint256 shares);\n\n    /**\n     * @dev Returns the maximum amount of Vault shares that can be redeemed from the owner balance in the Vault,\n     * through a redeem call.\n     *\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST return balanceOf(owner) if owner is not subject to any withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n    function maxRedeem(address owner) external view returns (uint256 maxShares);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their redeemption at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of assets that would be withdrawn in a redeem call\n     *   in the same transaction. I.e. redeem should return the same or more assets as previewRedeem if called in the\n     *   same transaction.\n     * - MUST NOT account for redemption limits like those returned from maxRedeem and should always act as though the\n     *   redemption would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewRedeem SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by redeeming.\n     */\n    function previewRedeem(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Burns exactly shares from owner and sends assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   redeem execution, and are accounted for during redeem.\n     * - MUST revert if all of shares cannot be redeemed (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * NOTE: some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n    function redeem(uint256 shares, address receiver, address owner) external returns (uint256 assets);\n}\n"
    },
    "src/router/Commands.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.20;\n\n// Based on https://github.com/Uniswap/universal-router/blob/main/contracts/libraries/Commands.sol\n\nlibrary Commands {\n    bytes1 internal constant COMMAND_TYPE_MASK = 0x3f;\n\n    /**\n     * Transfers tokens from msg.sender to the Router.\n     * (address token, uint256 value)\n     */\n    uint256 constant TRANSFER_FROM = 0x00;\n\n    /**\n     * Transfers tokens from msg.sender to the Router with a permit.\n     * (address token, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)\n     */\n    uint256 constant TRANSFER_FROM_WITH_PERMIT = 0x01;\n\n    /**\n     * Transfers tokens from the Router to a recipient.\n     * (address token, address recipient, uint256 value)\n     */\n    uint256 constant TRANSFER = 0x02;\n\n    /**\n     * Performs a swap on Curve CryptoSwap pool.\n     * (address pool, uint256 i, uint256 j, uint256 amountIn, uint256 minAmountOut, address recipient)\n     */\n    uint256 constant CURVE_SWAP = 0x03;\n\n    /**\n     * Deposits an ERC20 underlying into an ERC4626 IBT\n     * ibt represents the target IBT and assets represents the amount of underlying to deposit\n     * (address ibt, uint256 assets, address recipient)\n     */\n    uint256 constant DEPOSIT_ASSET_IN_IBT = 0x04;\n\n    /**\n     * Deposits an ERC20 underlying into a PT\n     * assets represents the amount of underlying to deposit\n     * (address pt, uint256 assets, address ptRecipient, address ytRecipient, uint256 minShares)\n     */\n    uint256 constant DEPOSIT_ASSET_IN_PT = 0x05;\n\n    /**\n     * Deposits an ERC4626 IBT into a PT\n     * ibts represents the amount of IBT to deposit\n     * (address pt, uint256 ibts, address ptRecipient, address ytRecipient, uint256 minShares)\n     */\n    uint256 constant DEPOSIT_IBT_IN_PT = 0x06;\n\n    /**\n     * Redeems an ERC4626 IBT for the corresponding ERC20 underlying\n     * ibt represents the target IBT and shares represents the amount of IBT to redeem\n     * (address ibt, uint256 shares, address recipient)\n     */\n    uint256 constant REDEEM_IBT_FOR_ASSET = 0x07;\n\n    /**\n     * Redeems a PT:YT pair for the corresponding ERC20 underlying\n     * shares represents the amount of PT to redeem\n     * (address pt, uint256 shares, address recipient, uint256 minAssets)\n     */\n    uint256 constant REDEEM_PT_FOR_ASSET = 0x08;\n\n    /**\n     * Redeems a PT:YT pair for the corresponding ERC4626 IBT\n     * shares represents the amount of PT to redeem\n     * (address pt, uint256 shares, address recipient, uint256 minIbts)\n     */\n    uint256 constant REDEEM_PT_FOR_IBT = 0x09;\n\n    /**\n     * Performs a flash loan\n     * data represents the sequence of commands and inputs to be executed during the loan\n     * (address lender, address token, uint256 amount, bytes calldata data)\n     */\n    uint256 constant FLASH_LOAN = 0x0a;\n\n    /**\n     * Splits liquidity between IBT and PT before depositing in a Curve CryptoSwap pool\n     * ibts represents the amount of IBT to split between IBT and PT before depositing in the pool\n     * recipient represents the address that will receive the IBT/PT\n     * ytRecipient represents the address that will receive the YTs generated by the split\n     * (address pool, uint256 ibts, address recipient, address ytRecipient, uint256 minPTShares)\n     */\n    uint256 constant CURVE_SPLIT_IBT_LIQUIDITY = 0x0b;\n\n    /**\n     * Deposits coins into a Curve CryptoSwap pool\n     * amounts includes the amounts of IBT and PT to deposit in the pool\n     * min_mint_amount represents the minimum amount of LP tokens to mint\n     * (address pool, uint256[2] amounts, uint256 min_mint_amount, address recipient)\n     */\n    uint256 constant CURVE_ADD_LIQUIDITY = 0x0c;\n\n    /**\n     * Withdraws coins from a Curve CryptoSwap pool\n     * lps represents the amount of LP tokens to burn\n     * min_amounts represents the minimum amount of coins to receive\n     * (address pool, uint256 lps, uint256[2] min_amounts, address recipient)\n     */\n    uint256 constant CURVE_REMOVE_LIQUIDITY = 0x0d;\n\n    /**\n     * Withdraws a single coin from a Curve CryptoSwap pool\n     * lps represents the amount of LP tokens to burn\n     * i represents the index of the coin to withdraw\n     * min_amount represents the minimum amount of coin to receive\n     * (address pool, uint256 lps, uint256 i, uint256 min_amount, address recipient)\n     */\n    uint256 constant CURVE_REMOVE_LIQUIDITY_ONE_COIN = 0x0e;\n\n    /**\n     * Performs a minimum balance check.\n     * (address token, address owner, uint256 minValue)\n     */\n    uint256 constant ASSERT_MIN_BALANCE = 0x0f;\n\n    /**\n     * Wraps shares of an interest-bearing vault into an ERC-4626 Wrapper\n     * vaultShares represents the amount of vault shares to unwrap\n     * (address wrapper, uint256 vaultShares, address recipient)\n     */\n    uint256 constant WRAP_VAULT_IN_4626_ADAPTER = 0x10;\n\n    /**\n     * Unwraps shares of an interest-bearing vault from an ERC-4626 Wrapper\n     * wrapperShares represents the amount of wrapper shares to redeem\n     * (address wrapper, uint256 wrapperShares, address recipient)\n     */\n    uint256 constant UNWRAP_VAULT_FROM_4626_ADAPTER = 0x11;\n\n    /**\n     * Performs a swap on Kyberswap.\n     * (address tokenIn, uint256 amountIn, address tokenOut, uint256 expectedAmountOut, bytes targetData)\n     */\n    uint256 constant KYBER_SWAP = 0x12;\n\n    /**\n     * Removes liquidity from Pendle.\n     * (address receiver, address market, uint256 netLpToRemove, TokenOutput calldata output, LimitOrderData calldata limit)\n     */\n    uint256 constant PENDLE_REMOVE_LIQUIDITY_SINGLE_TOKEN = 0x13;\n\n    /**\n     * Performs a swap on a Curve TwoCrypto NG pool.\n     * (address pool, uint256 i, uint256 j, uint256 amountIn, uint256 minAmountOut, address recipient)\n     */\n    uint256 constant CURVE_NG_SWAP = 0x15;\n\n    /**\n     * Splits liquidity between IBT and PT before depositing in a Curve TwoCrypto NG pool.\n     * ibts represents the amount of IBT to split between IBT and PT before depositing in the pool\n     * recipient represents the address that will receive the IBT/PT\n     * ytRecipient represents the address that will receive the YTs generated by the split\n     * (address pool, uint256 ibts, address recipient, address ytRecipient, uint256 minPTShares)\n     */\n    uint256 constant CURVE_NG_SPLIT_IBT_LIQUIDITY = 0x16;\n\n    /**\n     * Deposits coins into a Curve TwoCrypto NG pool.\n     * amounts includes the amounts of IBT and PT to deposit in the pool\n     * min_mint_amount represents the minimum amount of LP tokens to mint\n     * (address pool, uint256[2] amounts, uint256 min_mint_amount, address recipient)\n     */\n    uint256 constant CURVE_NG_ADD_LIQUIDITY = 0x17;\n\n    /**\n     * Withdraws coins from a Curve TwoCrypto NG pool.\n     * lps represents the amount of LP token shares to burn\n     * min_amounts represents the minimum amount of coins to receive\n     * (address pool, uint256 lps, uint256[2] min_amounts, address recipient)\n     */\n    uint256 constant CURVE_NG_REMOVE_LIQUIDITY = 0x18;\n\n    /**\n     * Withdraws a single coin from a Curve TwoCrypto NG pool.\n     * lps represents the amount of LP token shares to burn\n     * i represents the index of the coin to withdraw\n     * min_amount represents the minimum amount of coin to receive\n     * (address pool, uint256 lps, uint256 i, uint256 min_amount, address recipient)\n     */\n    uint256 constant CURVE_NG_REMOVE_LIQUIDITY_ONE_COIN = 0x19;\n\n    /**\n     * Splits liquidity between IBT and PT before depositing in a Curve Stableswap NG pool\n     * ibts represents the amount of IBT to split between IBT and PT before depositing in the pool\n     * recipient represents the address that will receive the IBT/PT\n     * ytRecipient represents the address that will receive the YTs generated by the split\n     * (address pool, uint256 ibts, address recipient, address ytRecipient, uint256 minPTShares)\n     */\n    uint256 constant CURVE_SPLIT_IBT_LIQUIDITY_SNG = 0x1A;\n\n    /**\n     * Deposits coins into a Curve Stableswap NG pool\n     * amounts includes the amounts of IBT and PT to deposit in the pool\n     * min_mint_amount represents the minimum amount of LP tokens to mint\n     * (address pool, uint256[2] amounts, uint256 min_mint_amount, address recipient)\n     */\n    uint256 constant CURVE_ADD_LIQUIDITY_SNG = 0x1B;\n\n    /**\n     * Withdraws coins from a Curve Stableswap NG pool\n     * lps represents the amount of LP tokens to burn\n     * min_amounts represents the minimum amount of coins to receive\n     * (address pool, uint256 lps, uint256[2] min_amounts, address recipient)\n     */\n    uint256 constant CURVE_REMOVE_LIQUIDITY_SNG = 0x1C;\n\n    /**\n     * Withdraws a single coin from a Curve Stableswap NG pool\n     * lps represents the amount of LP tokens to burn\n     * i represents the index of the coin to withdraw\n     * min_amount represents the minimum amount of coin to receive\n     * (address pool, uint256 lps, uint256 i, uint256 min_amount, address recipient)\n     */\n    uint256 constant CURVE_REMOVE_LIQUIDITY_ONE_COIN_SNG = 0x1D;\n\n    /**\n     * Performs a swap on Curve Stableswap NG pool.\n     * (address pool, uint256 i, uint256 j, uint256 amountIn, uint256 minAmountOut, address recipient)\n     */\n    uint256 constant CURVE_SWAP_SNG = 0x1E;\n\n    /**\n     * Given a ratio in which we want to add liquidity to Curve legacy Cryptoswap pools, calculates the amount of IBTs to tokenize in PTs and YTs\n     * so that the ratio of the IBTs left after tokenization with the PTs obtained via tokenization mathes the\n     * proportion given in function call arguments.\n     * (address pool, uint256 ibts, uint256 prop, address recipient, address ytRecipient, uint256 minPTShares)\n     */\n    uint256 constant CURVE_SPLIT_IBT_LIQUIDITY_CUSTOM_PROP = 0x1F;\n\n    /**\n     * Given a ratio in which we want to add liquidity to Curve NG Cryptoswap pools, calculates the amount of IBTs to tokenize in PTs and YTs\n     * so that the ratio of the IBTs left after tokenization with the PTs obtained via tokenization mathes the\n     * proportion given in function call arguments.\n     * (address pool, uint256 ibts, uint256 prop, address recipient, address ytRecipient, uint256 minPTShares)\n     */\n    uint256 constant CURVE_SPLIT_IBT_LIQUIDITY_CUSTOM_PROP_NG = 0x20;\n\n    /**\n     * Given a ratio in which we want to add liquidity to Curve StableSwap pools, calculates the amount of IBTs to tokenize in PTs and YTs\n     * so that the ratio of the IBTs left after tokenization with the PTs obtained via tokenization mathes the\n     * proportion given in function call arguments.\n     * (address pool, uint256 ibts, uint256 prop, address recipient, address ytRecipient, uint256 minPTShares)\n     */\n    uint256 constant CURVE_SPLIT_IBT_LIQUIDITY_CUSTOM_PROP_SNG = 0x21;\n\n    /**\n     * Deposits native token into a wrapper.\n     * (address wrapper, uint256 amount)\n     */\n    uint256 constant DEPOSIT_NATIVE_IN_WRAPPER = 0x22;\n\n    /**\n     * Withdraws native token from a wrapper.\n     * (address wrapper, uint256 amount)\n     */\n    uint256 constant WITHDRAW_NATIVE_FROM_WRAPPER = 0x23;\n\n    /**\n     * Transfers native token to a recipient.\n     * (address recipient, uint256 amount)\n     */\n    uint256 constant TRANSFER_NATIVE = 0x24;\n}\n"
    },
    "src/router/Constants.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.20;\n\nlibrary Constants {\n    /// @dev 18 decimal unit\n    uint256 internal constant UNIT = 1e18;\n\n    /// @dev identifier for native ETH\n    address public constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @dev maximal number of iterations in the secant method algorithm\n    uint256 internal constant MAX_ITERATIONS_SECANT = 255;\n\n    /// @dev maximal number of iterations in the linear search following secant method algorithm\n    uint256 internal constant MAX_ITERATIONS_LINEAR_SEARCH = 255;\n\n    /// @dev determines the rate at which an input value is scaled in each iteration of linear search\n    uint256 internal constant SCALING_FACTOR_LINEAR_SEARCH = 1e6;\n\n    /// @dev precision divisor for the secant method\n    uint256 internal constant PRECISION_DIVISOR = 1000;\n\n    /// @dev Used for identifying cases when this contract's balance of a token is to be used as an input\n    /// This value is equivalent to 1<<255, i.e. a singular 1 in the most significant bit.\n    uint256 internal constant CONTRACT_BALANCE =\n        0x8000000000000000000000000000000000000000000000000000000000000000;\n\n    /// @dev Used as a flag for identifying that msg.sender should be used, saves gas by sending more 0 bytes\n    address internal constant MSG_SENDER = address(0xc0);\n\n    /// @dev Used as a flag for identifying address(this) should be used, saves gas by sending more 0 bytes\n    address internal constant ADDRESS_THIS = address(0xe0);\n}\n"
    },
    "src/libraries/CurvePoolUtil.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.20;\n\nimport \"../interfaces/ICurvePool.sol\";\nimport \"../interfaces/ICurveNGPool.sol\";\nimport \"../interfaces/IStableSwapNG.sol\";\nimport \"../interfaces/IPrincipalToken.sol\";\nimport \"./RayMath.sol\";\nimport \"openzeppelin-math/Math.sol\";\n\n/**\n * @title CurvePoolUtil library\n * @author Spectra Finance\n * @notice Provides miscellaneous utils for computations related to Curve CryptoSwap pools.\n */\nlibrary CurvePoolUtil {\n    using Math for uint256;\n    using RayMath for uint256;\n\n    error SolutionNotFound();\n    error FailedToFetchExpectedLPTokenAmount();\n    error FailedToFetchExpectedCoinAmount();\n\n    /// @notice Decimal precision used internally in the Curve AMM\n    uint256 public constant CURVE_DECIMALS = 18;\n    /// @notice Base unit for Curve AMM calculations\n    uint256 public constant CURVE_UNIT = 1e18;\n    /// @notice Make rounding errors favoring other LPs a tiny bit\n    uint256 private constant APPROXIMATION_DECREMENT = 1;\n    /// @notice Maximal number of iterations in the binary search algorithm\n    uint256 private constant MAX_ITERATIONS_BINSEARCH = 255;\n\n    /**\n     * @notice Returns the expected LP token amount received for depositing given amounts of IBT and PT\n     * @notice Method to be used with legacy Curve Cryptoswap pools\n     * @param _curvePool The address of the Curve Pool in which liquidity will be deposited\n     * @param _amounts Array containing the amounts of IBT and PT to deposit in the Curve Pool\n     * @return minMintAmount The amount of expected LP tokens received for depositing the liquidity in the pool\n     */\n    function previewAddLiquidity(\n        address _curvePool,\n        uint256[2] memory _amounts\n    ) external view returns (uint256 minMintAmount) {\n        (bool success, bytes memory responseData) = _curvePool.staticcall(\n            abi.encodeCall(ICurvePool(address(0)).calc_token_amount, (_amounts))\n        );\n        if (!success) {\n            revert FailedToFetchExpectedLPTokenAmount();\n        }\n        minMintAmount = abi.decode(responseData, (uint256));\n    }\n\n    /**\n     * @notice Returns the expected LP token amount received for depositing given amounts of IBT and PT\n     * @notice Method to be used with legacy Curve Cryptoswap NG pools\n     * @param _curvePool The address of the Curve Pool in which liquidity will be deposited\n     * @param _amounts Array containing the amounts of IBT and PT to deposit in the Curve Pool\n     * @return minMintAmount The amount of expected LP tokens received for depositing the liquidity in the pool\n     */\n    function previewAddLiquidityNG(\n        address _curvePool,\n        uint256[2] memory _amounts\n    ) external view returns (uint256 minMintAmount) {\n        (bool success, bytes memory responseData) = _curvePool.staticcall(\n            abi.encodeCall(ICurveNGPool(address(0)).calc_token_amount, (_amounts, true))\n        );\n        if (!success) {\n            revert FailedToFetchExpectedLPTokenAmount();\n        }\n        minMintAmount = abi.decode(responseData, (uint256));\n    }\n\n    /**\n     * @notice Returns the expected LP token amount received for depositing given amounts of IBT and PT\n     * @notice Method to be used with StableSwap NG pools\n     * @param _curvePool The address of the Curve Pool in which liquidity will be deposited\n     * @param _amounts Array containing the amounts of IBT and PT to deposit in the Curve Pool\n     * @return minMintAmount The amount of expected LP tokens received for depositing the liquidity in the pool\n     */\n    function previewAddLiquiditySNG(\n        address _curvePool,\n        uint256[] memory _amounts\n    ) external view returns (uint256 minMintAmount) {\n        // @dev set the is_deposit to true\n        (bool success, bytes memory responseData) = _curvePool.staticcall(\n            abi.encodeCall(IStableSwapNG(address(0)).calc_token_amount, (_amounts, true))\n        );\n        if (!success) {\n            revert FailedToFetchExpectedLPTokenAmount();\n        }\n        minMintAmount = abi.decode(responseData, (uint256));\n    }\n\n    /**\n     * @notice Returns the IBT and PT amounts received for burning a given amount of LP tokens\n     * @notice Method to be used with legacy Curve Cryptoswap pools\n     * @param _curvePool The address of the curve pool\n     * @param _lpTokenAmount The amount of the lp token to burn\n     * @return minAmounts The expected respective amounts of IBT and PT withdrawn from the curve pool\n     */\n    function previewRemoveLiquidity(\n        address _curvePool,\n        uint256 _lpTokenAmount\n    ) external view returns (uint256[2] memory minAmounts) {\n        address lpToken = ICurvePool(_curvePool).token();\n        uint256 totalSupply = IERC20(lpToken).totalSupply();\n        (uint256 ibtBalance, uint256 ptBalance) = _getCurvePoolBalances(_curvePool);\n        // decrement following what Curve is doing\n        if (_lpTokenAmount > APPROXIMATION_DECREMENT && totalSupply != 0) {\n            _lpTokenAmount -= APPROXIMATION_DECREMENT;\n            minAmounts = [\n                (ibtBalance * _lpTokenAmount) / totalSupply,\n                (ptBalance * _lpTokenAmount) / totalSupply\n            ];\n        } else {\n            minAmounts = [uint256(0), uint256(0)];\n        }\n    }\n\n    /**\n     * @notice Returns the IBT and PT amounts received for burning a given amount of LP tokens\n     * @notice Method to be used with Curve Cryptoswap NG pools\n     * @param _curvePool The address of the curve pool\n     * @param _lpTokenAmount The amount of the lp token to burn\n     * @return minAmounts The expected respective amounts of IBT and PT withdrawn from the curve pool\n     */\n    function previewRemoveLiquidityNG(\n        address _curvePool,\n        uint256 _lpTokenAmount\n    ) external view returns (uint256[2] memory minAmounts) {\n        uint256 totalSupply = ICurveNGPool(_curvePool).totalSupply();\n        (uint256 ibtBalance, uint256 ptBalance) = _getCurvePoolBalances(_curvePool);\n        // reproduces Curve implementation\n        if (_lpTokenAmount == totalSupply) {\n            minAmounts = [ibtBalance, ptBalance];\n        } else if (_lpTokenAmount > APPROXIMATION_DECREMENT && totalSupply != 0) {\n            _lpTokenAmount -= APPROXIMATION_DECREMENT;\n            minAmounts = [\n                ibtBalance.mulDiv(_lpTokenAmount, totalSupply),\n                ptBalance.mulDiv(_lpTokenAmount, totalSupply)\n            ];\n        } else {\n            minAmounts = [uint256(0), uint256(0)];\n        }\n    }\n\n    /**\n     * @notice Returns the IBT and PT amounts received for burning a given amount of LP tokens\n     * @notice Method to be used with StableSwap NG pools\n     * @param _curvePool The address of the curve pool\n     * @param _lpTokenAmount The amount of the lp token to burn\n     * @return minAmounts The expected respective amounts of IBT and PT withdrawn from the curve pool\n     */\n    function previewRemoveLiquiditySNG(\n        address _curvePool,\n        uint256 _lpTokenAmount\n    ) external view returns (uint256[] memory) {\n        uint256 totalSupply = IERC20(_curvePool).totalSupply();\n        (uint256 ibtBalance, uint256 ptBalance) = _getCurvePoolBalances(_curvePool);\n        // decrement following what Curve is doing\n        uint256[] memory minAmounts = new uint256[](2);\n        if (_lpTokenAmount > APPROXIMATION_DECREMENT && totalSupply != 0) {\n            _lpTokenAmount -= APPROXIMATION_DECREMENT;\n            minAmounts[0] = (ibtBalance * _lpTokenAmount) / totalSupply;\n            minAmounts[1] = (ptBalance * _lpTokenAmount) / totalSupply;\n        } else {\n            minAmounts[0] = 0;\n            minAmounts[1] = 0;\n        }\n        return minAmounts;\n    }\n\n    /**\n     * @notice Returns the amount of coin i received for burning a given amount of LP tokens\n     * @notice Method to be used with legacy Curve CryptoSwap pools\n     * @param _curvePool The address of the curve pool\n     * @param _lpTokenAmount The amount of the LP tokens to burn\n     * @param _i The index of the unique coin to withdraw\n     * @return minAmount The expected amount of coin i withdrawn from the curve pool\n     */\n    function previewRemoveLiquidityOneCoin(\n        address _curvePool,\n        uint256 _lpTokenAmount,\n        uint256 _i\n    ) external view returns (uint256 minAmount) {\n        (bool success, bytes memory responseData) = _curvePool.staticcall(\n            abi.encodeCall(ICurvePool(address(0)).calc_withdraw_one_coin, (_lpTokenAmount, _i))\n        );\n        if (!success) {\n            revert FailedToFetchExpectedCoinAmount();\n        }\n        minAmount = abi.decode(responseData, (uint256));\n    }\n\n    /**\n     * @notice Returns the amount of coin i received for burning a given amount of LP tokens\n     * @notice Method to be used with Curve NG pools\n     * @param _curvePool The address of the curve pool\n     * @param _lpTokenAmount The amount of the LP tokens to burn\n     * @param _i The index of the unique coin to withdraw\n     * @return minAmount The expected amount of coin i withdrawn from the curve pool\n     */\n    function previewRemoveLiquidityOneCoinNG(\n        address _curvePool,\n        uint256 _lpTokenAmount,\n        uint256 _i\n    ) external view returns (uint256 minAmount) {\n        (bool success, bytes memory responseData) = _curvePool.staticcall(\n            abi.encodeCall(ICurveNGPool(address(0)).calc_withdraw_one_coin, (_lpTokenAmount, _i))\n        );\n        if (!success) {\n            revert FailedToFetchExpectedCoinAmount();\n        }\n        minAmount = abi.decode(responseData, (uint256));\n    }\n\n    /**\n     * @notice Returns the amount of coin i received for burning a given amount of LP tokens\n     * @notice Method to be used with StableSwap NG pools\n     * @param _curvePool The address of the curve pool\n     * @param _lpTokenAmount The amount of the LP tokens to burn\n     * @param _i The index of the unique coin to withdraw\n     * @return minAmount The expected amount of coin i withdrawn from the curve pool\n     */\n    function previewRemoveLiquidityOneCoinSNG(\n        address _curvePool,\n        uint256 _lpTokenAmount,\n        int128 _i\n    ) external view returns (uint256 minAmount) {\n        (bool success, bytes memory responseData) = _curvePool.staticcall(\n            abi.encodeCall(IStableSwapNG(address(0)).calc_withdraw_one_coin, (_lpTokenAmount, _i))\n        );\n        if (!success) {\n            revert FailedToFetchExpectedCoinAmount();\n        }\n        minAmount = abi.decode(responseData, (uint256));\n    }\n\n    /**\n     * @notice Return the amount of IBT to deposit in the curve pool, given the total amount of IBT available for deposit\n     * @param _amount The total amount of IBT available for deposit\n     * @param _curvePool The address of the pool to deposit the amounts\n     * @param _pt The address of the PT\n     * @return ibts The amount of IBT which will be deposited in the curve pool\n     */\n    function calcIBTsToTokenizeForCurvePool(\n        uint256 _amount,\n        address _curvePool,\n        address _pt\n    ) external view returns (uint256 ibts) {\n        (uint256 ibtBalance, uint256 ptBalance) = _getCurvePoolBalances(_curvePool);\n        uint256 ibtBalanceInPT = IPrincipalToken(_pt).previewDepositIBT(ibtBalance);\n        // Liquidity added in a ratio that (closely) matches the existing pool's ratio\n        ibts = _amount.mulDiv(ptBalance, ibtBalanceInPT + ptBalance);\n    }\n\n    /**\n     * @notice Return the amount of IBT to deposit in the curve pool given the proportion in which we want to deposit, given the total amount of IBT available for deposit\n     * @param _amount The total amount of IBT available for deposit\n     * @param _prop The proportion in which we want to make the deposit: _prop = nIBT / (nIBT + nPT)\n     * @param _pt The address of the PT\n     * @return ibts The amount of IBT which will be deposited in the curve pool\n     */\n    function calcIBTsToTokenizeForCurvePoolCustomProp(\n        uint256 _amount,\n        uint256 _prop,\n        address _pt\n    ) external view returns (uint256 ibts) {\n        uint256 rate = IPrincipalToken(_pt).previewDepositIBT(_amount).mulDiv(CURVE_UNIT, _amount);\n        ibts = _amount.mulDiv(CURVE_UNIT, CURVE_UNIT + _prop.mulDiv(rate, CURVE_UNIT));\n    }\n\n    /**\n     * @param _curvePool : PT/IBT curve pool\n     * @param _i token index\n     * @param _j token index\n     * @param _targetDy amount out desired\n     * @return dx The amount of token to provide in order to obtain _targetDy after swap\n     */\n    function getDx(\n        address _curvePool,\n        uint256 _i,\n        uint256 _j,\n        uint256 _targetDy\n    ) external view returns (uint256 dx) {\n        // Initial guesses\n        uint256 _minGuess = type(uint256).max;\n        uint256 _maxGuess = type(uint256).max;\n        uint256 _factor100;\n        uint256 _guess = ICurvePool(_curvePool).get_dy(_i, _j, _targetDy);\n\n        if (_guess > _targetDy) {\n            _maxGuess = _targetDy;\n            _factor100 = 10;\n        } else {\n            _minGuess = _targetDy;\n            _factor100 = 1000;\n        }\n        uint256 loops;\n        _guess = _targetDy;\n        while (!_dxSolved(_curvePool, _i, _j, _guess, _targetDy, _minGuess, _maxGuess)) {\n            loops++;\n\n            (_minGuess, _maxGuess, _guess) = _runLoop(\n                _minGuess,\n                _maxGuess,\n                _factor100,\n                _guess,\n                _targetDy,\n                _curvePool,\n                _i,\n                _j\n            );\n\n            if (loops >= MAX_ITERATIONS_BINSEARCH) {\n                revert SolutionNotFound();\n            }\n        }\n        dx = _guess;\n    }\n\n    /**\n     * @dev Runs bisection search\n     * @param _minGuess lower bound on searched value\n     * @param _maxGuess upper bound on searched value\n     * @param _factor100 search interval scaling factor\n     * @param _guess The previous guess for the `dx` value that is being refined through the search process\n     * @param _targetDy The target output of the `get_dy` function, which the search aims to achieve by adjusting `dx`.\n     * @param _curvePool PT/IBT curve pool\n     * @param _i token index, either 0 or 1\n     * @param _j token index, either 0 or 1, must be different than _i\n     * @return The lower bound on _guess, upper bound on _guess and next _guess\n     */\n    function _runLoop(\n        uint256 _minGuess,\n        uint256 _maxGuess,\n        uint256 _factor100,\n        uint256 _guess,\n        uint256 _targetDy,\n        address _curvePool,\n        uint256 _i,\n        uint256 _j\n    ) internal view returns (uint256, uint256, uint256) {\n        if (_minGuess == type(uint256).max || _maxGuess == type(uint256).max) {\n            _guess = (_guess * _factor100) / 100;\n        } else {\n            _guess = (_maxGuess + _minGuess) >> 1;\n        }\n        uint256 dy = ICurvePool(_curvePool).get_dy(_i, _j, _guess);\n        if (dy < _targetDy) {\n            _minGuess = _guess;\n        } else if (dy > _targetDy) {\n            _maxGuess = _guess;\n        }\n        return (_minGuess, _maxGuess, _guess);\n    }\n\n    /**\n     * @dev Returns true if algorithm converged\n     * @param _curvePool PT/IBT curve pool\n     * @param _i token index, either 0 or 1\n     * @param _j token index, either 0 or 1, must be different than _i\n     * @param _dx The current guess for the `dx` value that is being refined through the search process.\n     * @param _targetDy The target output of the `get_dy` function, which the search aims to achieve by adjusting `dx`.\n     * @param _minGuess lower bound on searched value\n     * @param _maxGuess upper bound on searched value\n     * @return true if the solution to the search problem was found, false otherwise\n     */\n    function _dxSolved(\n        address _curvePool,\n        uint256 _i,\n        uint256 _j,\n        uint256 _dx,\n        uint256 _targetDy,\n        uint256 _minGuess,\n        uint256 _maxGuess\n    ) internal view returns (bool) {\n        if (_minGuess == type(uint256).max || _maxGuess == type(uint256).max) {\n            return false;\n        }\n        uint256 dy = ICurvePool(_curvePool).get_dy(_i, _j, _dx);\n        if (dy == _targetDy) {\n            return true;\n        }\n        uint256 dy1 = ICurvePool(_curvePool).get_dy(_i, _j, _dx + 1);\n        if (dy < _targetDy && _targetDy < dy1) {\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * @notice Returns the balances of the two tokens in provided curve pool\n     * @param _curvePool address of the curve pool\n     * @return The IBT and PT balances of the curve pool\n     */\n    function _getCurvePoolBalances(address _curvePool) internal view returns (uint256, uint256) {\n        return (ICurvePool(_curvePool).balances(0), ICurvePool(_curvePool).balances(1));\n    }\n}\n"
    },
    "src/interfaces/ICurvePool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface for Curve CryptoSwap pool\n */\ninterface ICurvePool {\n    function coins(uint256 index) external view returns (address);\n\n    function balances(uint256 index) external view returns (uint256);\n\n    function A() external view returns (uint256);\n\n    function gamma() external view returns (uint256);\n\n    function D() external view returns (uint256);\n\n    function token() external view returns (address);\n\n    function price_scale() external view returns (uint256);\n\n    function future_A_gamma_time() external view returns (uint256);\n\n    function future_A_gamma() external view returns (uint256);\n\n    function initial_A_gamma_time() external view returns (uint256);\n\n    function initial_A_gamma() external view returns (uint256);\n\n    function fee_gamma() external view returns (uint256);\n\n    function mid_fee() external view returns (uint256);\n\n    function out_fee() external view returns (uint256);\n\n    function allowed_extra_profit() external view returns (uint256);\n\n    function adjustment_step() external view returns (uint256);\n\n    function admin_fee() external view returns (uint256);\n\n    function ma_half_time() external view returns (uint256);\n\n    function get_virtual_price() external view returns (uint256);\n\n    function fee() external view returns (uint256);\n\n    function get_dy(uint256 i, uint256 j, uint256 dx) external view returns (uint256);\n\n    function last_prices() external view returns (uint256);\n\n    function calc_token_amount(uint256[2] calldata amounts) external view returns (uint256);\n\n    function calc_withdraw_one_coin(\n        uint256 _token_amount,\n        uint256 i\n    ) external view returns (uint256);\n\n    function exchange(\n        uint256 i,\n        uint256 j,\n        uint256 dx,\n        uint256 min_dy,\n        bool use_eth,\n        address receiver\n    ) external returns (uint256);\n\n    function add_liquidity(\n        uint256[2] calldata amounts,\n        uint256 min_mint_amount\n    ) external returns (uint256);\n\n    function add_liquidity(\n        uint256[2] calldata amounts,\n        uint256 min_mint_amount,\n        bool use_eth,\n        address receiver\n    ) external returns (uint256);\n\n    function remove_liquidity(uint256 amount, uint256[2] calldata min_amounts) external;\n\n    function remove_liquidity(\n        uint256 amount,\n        uint256[2] calldata min_amounts,\n        bool use_eth,\n        address receiver\n    ) external;\n\n    function remove_liquidity_one_coin(\n        uint256 token_amount,\n        uint256 i,\n        uint256 min_amount\n    ) external;\n\n    function remove_liquidity_one_coin(\n        uint256 token_amount,\n        uint256 i,\n        uint256 min_amount,\n        bool use_eth,\n        address receiver\n    ) external;\n}\n"
    },
    "src/interfaces/IStableSwapNG.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.4;\n\ninterface IStableSwapNG {\n    function A() external view returns (uint256);\n    function A_precise() external view returns (uint256);\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function D_ma_time() external view returns (uint256);\n    function D_oracle() external view returns (uint256);\n    function N_COINS() external view returns (uint256);\n    function add_liquidity(\n        uint256[] memory _amounts,\n        uint256 _min_mint_amount,\n        address _receiver\n    ) external returns (uint256);\n    function admin_balances(uint256 arg0) external view returns (uint256);\n    function admin_fee() external view returns (uint256);\n    function allowance(address arg0, address arg1) external view returns (uint256);\n    function approve(address _spender, uint256 _value) external returns (bool);\n    function balanceOf(address arg0) external view returns (uint256);\n    function balances(uint256 i) external view returns (uint256);\n    function calc_token_amount(\n        uint256[] memory _amounts,\n        bool _is_deposit\n    ) external view returns (uint256);\n    function calc_withdraw_one_coin(uint256 _burn_amount, int128 i) external view returns (uint256);\n    function coins(uint256 arg0) external view returns (address);\n    function decimals() external view returns (uint8);\n    function dynamic_fee(int128 i, int128 j) external view returns (uint256);\n    function ema_price(uint256 i) external view returns (uint256);\n    function exchange(int128 i, int128 j, uint256 _dx, uint256 _min_dy) external returns (uint256);\n    function exchange(\n        int128 i,\n        int128 j,\n        uint256 _dx,\n        uint256 _min_dy,\n        address _receiver\n    ) external returns (uint256);\n    function exchange_received(\n        int128 i,\n        int128 j,\n        uint256 _dx,\n        uint256 _min_dy\n    ) external returns (uint256);\n    function exchange_received(\n        int128 i,\n        int128 j,\n        uint256 _dx,\n        uint256 _min_dy,\n        address _receiver\n    ) external returns (uint256);\n    function fee() external view returns (uint256);\n    function future_A() external view returns (uint256);\n    function future_A_time() external view returns (uint256);\n    function get_balances() external view returns (uint256[] memory);\n    function get_dx(int128 i, int128 j, uint256 dy) external view returns (uint256);\n    function get_dy(int128 i, int128 j, uint256 dx) external view returns (uint256);\n    function get_p(uint256 i) external view returns (uint256);\n    function get_virtual_price() external view returns (uint256);\n    function initial_A() external view returns (uint256);\n    function initial_A_time() external view returns (uint256);\n    function last_price(uint256 i) external view returns (uint256);\n    function ma_exp_time() external view returns (uint256);\n    function ma_last_time() external view returns (uint256);\n    function name() external view returns (string memory);\n    function nonces(address arg0) external view returns (uint256);\n    function offpeg_fee_multiplier() external view returns (uint256);\n    function permit(\n        address _owner,\n        address _spender,\n        uint256 _value,\n        uint256 _deadline,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external returns (bool);\n    function price_oracle(uint256 i) external view returns (uint256);\n    function ramp_A(uint256 _future_A, uint256 _future_time) external;\n    function remove_liquidity(\n        uint256 _burn_amount,\n        uint256[] memory _min_amounts\n    ) external returns (uint256[] memory);\n    function remove_liquidity(\n        uint256 _burn_amount,\n        uint256[] memory _min_amounts,\n        address _receiver\n    ) external returns (uint256[] memory);\n    function remove_liquidity(\n        uint256 _burn_amount,\n        uint256[] memory _min_amounts,\n        address _receiver,\n        bool _claim_admin_fees\n    ) external returns (uint256[] memory);\n    function remove_liquidity_imbalance(\n        uint256[] memory _amounts,\n        uint256 _max_burn_amount\n    ) external returns (uint256);\n    function remove_liquidity_imbalance(\n        uint256[] memory _amounts,\n        uint256 _max_burn_amount,\n        address _receiver\n    ) external returns (uint256);\n    function remove_liquidity_one_coin(\n        uint256 _burn_amount,\n        int128 i,\n        uint256 _min_received\n    ) external returns (uint256);\n    function remove_liquidity_one_coin(\n        uint256 _burn_amount,\n        int128 i,\n        uint256 _min_received,\n        address _receiver\n    ) external returns (uint256);\n    function salt() external view returns (bytes32);\n    function set_ma_exp_time(uint256 _ma_exp_time, uint256 _D_ma_time) external;\n    function set_new_fee(uint256 _new_fee, uint256 _new_offpeg_fee_multiplier) external;\n    function stop_ramp_A() external;\n    function stored_rates() external view returns (uint256[] memory);\n    function symbol() external view returns (string memory);\n    function totalSupply() external view returns (uint256);\n    function transfer(address _to, uint256 _value) external returns (bool);\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\n    function version() external view returns (string memory);\n    function withdraw_admin_fees() external;\n}\n"
    },
    "src/interfaces/ICurveNGPool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.20;\n\nimport {IERC20Metadata} from \"openzeppelin-contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\n/**\n * @dev Interface for Curve TwoCrypto-NG pool\n */\ninterface ICurveNGPool is IERC20Metadata {\n    function coins(uint256 index) external view returns (address);\n\n    function balances(uint256 index) external view returns (uint256);\n\n    function A() external view returns (uint256);\n\n    function gamma() external view returns (uint256);\n\n    function D() external view returns (uint256);\n\n    function token() external view returns (address);\n\n    function price_scale() external view returns (uint256);\n\n    function price_oracle() external view returns (uint256);\n\n    function future_A_gamma_time() external view returns (uint256);\n\n    function future_A_gamma() external view returns (uint256);\n\n    function initial_A_gamma_time() external view returns (uint256);\n\n    function initial_A_gamma() external view returns (uint256);\n\n    function fee_gamma() external view returns (uint256);\n\n    function mid_fee() external view returns (uint256);\n\n    function out_fee() external view returns (uint256);\n\n    function allowed_extra_profit() external view returns (uint256);\n\n    function adjustment_step() external view returns (uint256);\n\n    function admin_fee() external view returns (uint256);\n\n    function ma_time() external view returns (uint256);\n\n    function get_virtual_price() external view returns (uint256);\n\n    function fee() external view returns (uint256);\n\n    function get_dy(uint256 i, uint256 j, uint256 dx) external view returns (uint256);\n\n    function get_dx(uint256 i, uint256 j, uint256 dy) external view returns (uint256);\n\n    function last_prices() external view returns (uint256);\n\n    function calc_token_amount(\n        uint256[2] calldata amounts,\n        bool deposit\n    ) external view returns (uint256);\n\n    function calc_withdraw_one_coin(\n        uint256 _token_amount,\n        uint256 i\n    ) external view returns (uint256);\n\n    function exchange(uint256 i, uint256 j, uint256 dx, uint256 min_dy) external returns (uint256);\n\n    function exchange(\n        uint256 i,\n        uint256 j,\n        uint256 dx,\n        uint256 min_dy,\n        address receiver\n    ) external returns (uint256);\n\n    function add_liquidity(\n        uint256[2] calldata amounts,\n        uint256 min_mint_amount\n    ) external returns (uint256);\n\n    function add_liquidity(\n        uint256[2] calldata amounts,\n        uint256 min_mint_amount,\n        address receiver\n    ) external returns (uint256);\n\n    function remove_liquidity(uint256 amount, uint256[2] calldata min_amounts) external;\n\n    function remove_liquidity(\n        uint256 amount,\n        uint256[2] calldata min_amounts,\n        address receiver\n    ) external;\n\n    function remove_liquidity_one_coin(\n        uint256 token_amount,\n        uint256 i,\n        uint256 min_amount\n    ) external;\n\n    function remove_liquidity_one_coin(\n        uint256 token_amount,\n        uint256 i,\n        uint256 min_amount,\n        address receiver\n    ) external;\n}\n"
    },
    "src/interfaces/IPrincipalToken.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.20;\n\nimport \"openzeppelin-contracts/interfaces/IERC20.sol\";\nimport \"openzeppelin-contracts/interfaces/IERC20Metadata.sol\";\nimport \"openzeppelin-contracts/interfaces/IERC3156FlashLender.sol\";\n\ninterface IPrincipalToken is IERC20, IERC20Metadata, IERC3156FlashLender {\n    /* ERRORS\n     *****************************************************************************************************************/\n\n    error InvalidDecimals();\n    error BeaconNotSet();\n    error PTExpired();\n    error PTNotExpired();\n    error RateError();\n    error AddressError();\n    error UnauthorizedCaller();\n    error RatesAtExpiryAlreadyStored();\n    error ERC5143SlippageProtectionFailed();\n    error InsufficientBalance();\n    error FlashLoanExceedsMaxAmount();\n    error FlashLoanCallbackFailed();\n    error NoRewardsProxy();\n    error ClaimRewardsFailed();\n\n    /* Functions\n     *****************************************************************************************************************/\n\n    function initialize(address _ibt, uint256 _duration, address initialAuthority) external;\n\n    /**\n     * @notice Toggle Pause\n     * @dev Should only be called in extraordinary situations by the admin of the contract\n     */\n    function pause() external;\n\n    /**\n     * @notice Toggle UnPause\n     * @dev Should only be called in extraordinary situations by the admin of the contract\n     */\n    function unPause() external;\n\n    /**\n     * @notice Deposits amount of assets in the PT vault\n     * @param assets The amount of assets being deposited\n     * @param receiver The receiver address of the shares\n     * @return shares The amount of shares minted (same amount for PT & yt)\n     */\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\n\n    /**\n     * @notice Deposits amount of assets in the PT vault\n     * @param assets The amount of assets being deposited\n     * @param ptReceiver The receiver address of the PTs\n     * @param ytReceiver the receiver address of the YTs\n     * @return shares The amount of shares minted (same amount for PT & yt)\n     */\n    function deposit(\n        uint256 assets,\n        address ptReceiver,\n        address ytReceiver\n    ) external returns (uint256 shares);\n\n    /**\n     * @notice Deposits amount of assets with a lower bound on shares received\n     * @param assets The amount of assets being deposited\n     * @param ptReceiver The receiver address of the PTs\n     * @param ytReceiver The receiver address of the YTs\n     * @param minShares The minimum allowed shares from this deposit\n     * @return shares The amount of shares actually minted to the receiver\n     */\n    function deposit(\n        uint256 assets,\n        address ptReceiver,\n        address ytReceiver,\n        uint256 minShares\n    ) external returns (uint256 shares);\n\n    /**\n     * @notice Same as normal deposit but with IBTs\n     * @param ibts The amount of IBT being deposited\n     * @param receiver The receiver address of the shares\n     * @return shares The amount of shares minted to the receiver\n     */\n    function depositIBT(uint256 ibts, address receiver) external returns (uint256 shares);\n\n    /**\n     * @notice Same as normal deposit but with IBTs\n     * @param ibts The amount of IBT being deposited\n     * @param ptReceiver The receiver address of the PTs\n     * @param ytReceiver the receiver address of the YTs\n     * @return shares The amount of shares minted to the receiver\n     */\n    function depositIBT(\n        uint256 ibts,\n        address ptReceiver,\n        address ytReceiver\n    ) external returns (uint256 shares);\n\n    /**\n     * @notice Same as normal deposit but with IBTs\n     * @param ibts The amount of IBT being deposited\n     * @param ptReceiver The receiver address of the PTs\n     * @param ytReceiver The receiver address of the YTs\n     * @param minShares The minimum allowed shares from this deposit\n     * @return shares The amount of shares minted to the receiver\n     */\n    function depositIBT(\n        uint256 ibts,\n        address ptReceiver,\n        address ytReceiver,\n        uint256 minShares\n    ) external returns (uint256 shares);\n\n    /**\n     * @notice Burns owner's shares (PTs and YTs before expiry, PTs after expiry)\n     * and sends assets to receiver\n     * @param shares The amount of shares to burn\n     * @param receiver The address that will receive the assets\n     * @param owner The owner of the shares\n     * @return assets The actual amount of assets received for burning the shares\n     */\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) external returns (uint256 assets);\n\n    /**\n     * @notice Burns owner's shares (PTs and YTs before expiry, PTs after expiry)\n     * and sends assets to receiver\n     * @param shares The amount of shares to burn\n     * @param receiver The address that will receive the assets\n     * @param owner The owner of the shares\n     * @param minAssets The minimum assets that should be returned to user\n     * @return assets The actual amount of assets received for burning the shares\n     */\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner,\n        uint256 minAssets\n    ) external returns (uint256 assets);\n\n    /**\n     * @notice Burns owner's shares (PTs and YTs before expiry, PTs after expiry)\n     * and sends IBTs to receiver\n     * @param shares The amount of shares to burn\n     * @param receiver The address that will receive the IBTs\n     * @param owner The owner of the shares\n     * @return ibts The actual amount of IBT received for burning the shares\n     */\n    function redeemForIBT(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) external returns (uint256 ibts);\n\n    /**\n     * @notice Burns owner's shares (PTs and YTs before expiry, PTs after expiry)\n     * and sends IBTs to receiver\n     * @param shares The amount of shares to burn\n     * @param receiver The address that will receive the IBTs\n     * @param owner The owner of the shares\n     * @param minIbts The minimum IBTs that should be returned to user\n     * @return ibts The actual amount of IBT received for burning the shares\n     */\n    function redeemForIBT(\n        uint256 shares,\n        address receiver,\n        address owner,\n        uint256 minIbts\n    ) external returns (uint256 ibts);\n\n    /**\n     * @notice Burns owner's shares (before expiry : PTs and YTs) and sends assets to receiver\n     * @param assets The amount of assets to be received\n     * @param receiver The address that will receive the assets\n     * @param owner The owner of the shares (PTs and YTs)\n     * @return shares The actual amount of shares burnt for receiving the assets\n     */\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) external returns (uint256 shares);\n\n    /**\n     * @notice Burns owner's shares (before expiry : PTs and YTs) and sends assets to receiver\n     * @param assets The amount of assets to be received\n     * @param receiver The address that will receive the assets\n     * @param owner The owner of the shares (PTs and YTs)\n     * @param maxShares The maximum shares allowed to be burnt\n     * @return shares The actual amount of shares burnt for receiving the assets\n     */\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner,\n        uint256 maxShares\n    ) external returns (uint256 shares);\n\n    /**\n     * @notice Burns owner's shares (before expiry : PTs and YTs) and sends IBTs to receiver\n     * @param ibts The amount of IBT to be received\n     * @param receiver The address that will receive the IBTs\n     * @param owner The owner of the shares (PTs and YTs)\n     * @return shares The actual amount of shares burnt for receiving the IBTs\n     */\n    function withdrawIBT(\n        uint256 ibts,\n        address receiver,\n        address owner\n    ) external returns (uint256 shares);\n\n    /**\n     * @notice Burns owner's shares (before expiry : PTs and YTs) and sends IBTs to receiver\n     * @param ibts The amount of IBT to be received\n     * @param receiver The address that will receive the IBTs\n     * @param owner The owner of the shares (PTs and YTs)\n     * @param maxShares The maximum shares allowed to be burnt\n     * @return shares The actual amount of shares burnt for receiving the IBTs\n     */\n    function withdrawIBT(\n        uint256 ibts,\n        address receiver,\n        address owner,\n        uint256 maxShares\n    ) external returns (uint256 shares);\n\n    /**\n     * @notice Updates _user's yield since last update\n     * @param _user The user whose yield will be updated\n     * @return updatedUserYieldInIBT The unclaimed yield of the user in IBT (not just the updated yield)\n     */\n    function updateYield(address _user) external returns (uint256 updatedUserYieldInIBT);\n\n    /**\n     * @notice Claims caller's unclaimed yield in asset\n     * @param _receiver The receiver of yield\n     * @param _minAssets The minimum amount of assets that should be received\n     * @return yieldInAsset The amount of yield claimed in asset\n     */\n    function claimYield(\n        address _receiver,\n        uint256 _minAssets\n    ) external returns (uint256 yieldInAsset);\n\n    /**\n     * @notice Claims caller's unclaimed yield in IBT\n     * @param _receiver The receiver of yield\n     * @param _minIBT The minimum amount of IBT that should be received\n     * @return yieldInIBT The amount of yield claimed in IBT\n     */\n    function claimYieldInIBT(\n        address _receiver,\n        uint256 _minIBT\n    ) external returns (uint256 yieldInIBT);\n\n    /**\n     * @notice Claims the collected ibt fees and redeems them to the fee collector\n     * @param _minAssets The minimum amount of assets that should be received\n     * @return assets The amount of assets sent to the fee collector\n     */\n    function claimFees(uint256 _minAssets) external returns (uint256 assets);\n\n    /**\n     * @notice Updates yield of both sender and receiver of YTs\n     * @param _from the sender of YTs\n     * @param _to the receiver of YTs\n     */\n    function beforeYtTransfer(address _from, address _to) external;\n\n    /**\n     * Call the claimRewards function of the rewards contract\n     * @param data The optional data to be passed to the rewards contract\n     */\n    function claimRewards(bytes memory data) external;\n\n    /* SETTERS\n     *****************************************************************************************************************/\n\n    /**\n     * @notice Stores PT and IBT rates at expiry. Ideally, it should be called the day of expiry\n     */\n    function storeRatesAtExpiry() external;\n\n    /** Set a new Rewards Proxy\n     * @param _rewardsProxy The address of the new reward proxy\n     */\n    function setRewardsProxy(address _rewardsProxy) external;\n\n    /* GETTERS\n     *****************************************************************************************************************/\n\n    /**\n     * @notice Returns the amount of shares minted for the theorical deposited amount of assets\n     * @param assets The amount of assets deposited\n     * @return The amount of shares minted\n     */\n    function previewDeposit(uint256 assets) external view returns (uint256);\n\n    /**\n     * @notice Returns the amount of shares minted for the theorical deposited amount of IBT\n     * @param ibts The amount of IBT deposited\n     * @return The amount of shares minted\n     */\n    function previewDepositIBT(uint256 ibts) external view returns (uint256);\n\n    /**\n     * @notice Returns the maximum amount of the underlying asset that can be deposited into the Vault for the receiver,\n     * through a deposit call.\n     * @param receiver The receiver of the shares\n     * @return The maximum amount of assets that can be deposited\n     */\n    function maxDeposit(address receiver) external view returns (uint256);\n\n    /**\n     * @notice Returns the theorical amount of shares that need to be burnt to receive assets of underlying\n     * @param assets The amount of assets to receive\n     * @return The amount of shares burnt\n     */\n    function previewWithdraw(uint256 assets) external view returns (uint256);\n\n    /**\n     * @notice Returns the theorical amount of shares that need to be burnt to receive amount of IBT\n     * @param ibts The amount of IBT to receive\n     * @return The amount of shares burnt\n     */\n    function previewWithdrawIBT(uint256 ibts) external view returns (uint256);\n\n    /**\n     * @notice Returns the maximum amount of the underlying asset that can be withdrawn from the owner balance in the\n     * Vault, through a withdraw call.\n     * @param owner The owner of the Vault shares\n     * @return The maximum amount of assets that can be withdrawn\n     */\n    function maxWithdraw(address owner) external view returns (uint256);\n\n    /**\n     * @notice Returns the maximum amount of the IBT that can be withdrawn from the owner balance in the\n     * Vault, through a withdraw call.\n     * @param owner The owner of the Vault shares\n     * @return The maximum amount of IBT that can be withdrawn\n     */\n    function maxWithdrawIBT(address owner) external view returns (uint256);\n\n    /**\n     * @notice Returns the amount of assets received for the theorical amount of burnt shares\n     * @param shares The amount of shares to burn\n     * @return The amount of assets received\n     */\n    function previewRedeem(uint256 shares) external view returns (uint256);\n\n    /**\n     * @notice Returns the amount of IBT received for the theorical amount of burnt shares\n     * @param shares The amount of shares to burn\n     * @return The amount of IBT received\n     */\n    function previewRedeemForIBT(uint256 shares) external view returns (uint256);\n\n    /**\n     * @notice Returns the maximum amount of Vault shares that can be redeemed by the owner\n     * @notice This function behaves differently before and after expiry. Before expiry an equal amount of PT and YT\n     * needs to be burnt, while after expiry only PTs are burnt.\n     * @param owner The owner of the shares\n     * @return The maximum amount of shares that can be redeemed\n     */\n    function maxRedeem(address owner) external view returns (uint256);\n\n    /**\n     * Returns the total amount of the underlying asset that is owned by the Vault in the form of IBT.\n     */\n    function totalAssets() external view returns (uint256);\n\n    /**\n     * @notice Converts an underlying amount in principal. Equivalent to ERC-4626's convertToShares method.\n     * @param underlyingAmount The amount of underlying (or assets) to convert\n     * @return The resulting amount of principal (or shares)\n     */\n    function convertToPrincipal(uint256 underlyingAmount) external view returns (uint256);\n\n    /**\n     * @notice Converts a principal amount in underlying. Equivalent to ERC-4626's convertToAssets method.\n     * @param principalAmount The amount of principal (or shares) to convert\n     * @return The resulting amount of underlying (or assets)\n     */\n    function convertToUnderlying(uint256 principalAmount) external view returns (uint256);\n\n    /**\n     * @notice Returns whether or not the contract is paused.\n     * @return true if the contract is paused, and false otherwise\n     */\n    function paused() external view returns (bool);\n\n    /**\n     * @notice Returns the unix timestamp (uint256) at which the PT contract expires\n     * @return The unix timestamp (uint256) when PTs become redeemable\n     */\n    function maturity() external view returns (uint256);\n\n    /**\n     * @notice Returns the duration of the PT contract\n     * @return The duration (in s) to expiry/maturity of the PT contract\n     */\n    function getDuration() external view returns (uint256);\n\n    /**\n     * @notice Returns the address of the underlying token (or asset). Equivalent to ERC-4626's asset method.\n     * @return The address of the underlying token (or asset)\n     */\n    function underlying() external view returns (address);\n\n    /**\n     * @notice Returns the IBT address of the PT contract\n     * @return ibt The address of the IBT\n     */\n    function getIBT() external view returns (address ibt);\n\n    /**\n     * @notice Returns the yt address of the PT contract\n     * @return yt The address of the yt\n     */\n    function getYT() external view returns (address yt);\n\n    /**\n     * @notice Returns the current ibtRate\n     * @return The current ibtRate\n     */\n    function getIBTRate() external view returns (uint256);\n\n    /**\n     * @notice Returns the current ptRate\n     * @return The current ptRate\n     */\n    function getPTRate() external view returns (uint256);\n\n    /**\n     * @notice Returns 1 unit of IBT\n     * @return The IBT unit\n     */\n    function getIBTUnit() external view returns (uint256);\n\n    /**\n     * @notice Get the unclaimed fees in IBT\n     * @return The unclaimed fees in IBT\n     */\n    function getUnclaimedFeesInIBT() external view returns (uint256);\n\n    /**\n     * @notice Get the total collected fees in IBT (claimed and unclaimed)\n     * @return The total fees in IBT\n     */\n    function getTotalFeesInIBT() external view returns (uint256);\n\n    /**\n     * @notice Get the tokenization fee of the PT\n     * @return The tokenization fee\n     */\n    function getTokenizationFee() external view returns (uint256);\n\n    /**\n     * @notice Get the current IBT yield of the user\n     * @param _user The address of the user to get the current yield from\n     * @return The yield of the user in IBT\n     */\n    function getCurrentYieldOfUserInIBT(address _user) external view returns (uint256);\n}\n"
    },
    "src/interfaces/IRegistry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.20;\n\ninterface IRegistry {\n    /* Errors\n     *****************************************************************************************************************/\n    error FeeGreaterThanMaxValue();\n    error PTListUpdateFailed();\n    error ReductionTooBig();\n    error AddressError();\n\n    /* GETTERS\n     *****************************************************************************************************************/\n\n    /**\n     * @notice Getter for the factory address\n     * @return The address of token factory\n     */\n    function getFactory() external view returns (address);\n\n    /**\n     * @notice Get the address of the router\n     * @return The address of the router\n     */\n    function getRouter() external view returns (address);\n\n    /**\n     * @notice Get the address of the routerUtil\n     * @return The address of the routerUtil\n     */\n    function getRouterUtil() external view returns (address);\n\n    /**\n     * @notice Get the address of the pt beacon\n     * @return The address of PT beacon\n     */\n    function getPTBeacon() external view returns (address);\n\n    /**\n     * @notice Get the address of the yt beacon\n     * @return The address of yt beacon\n     */\n    function getYTBeacon() external view returns (address);\n\n    /**\n     * @notice Get the value of tokenization fee\n     * @return The value of tokenization fee\n     */\n    function getTokenizationFee() external view returns (uint256);\n\n    /**\n     * @notice Get the value of yield fee\n     * @return The value of yield fee\n     */\n    function getYieldFee() external view returns (uint256);\n\n    /**\n     * @notice Get the value of PT flash loan fee\n     * @return The value of PT flash loan fee\n     */\n    function getPTFlashLoanFee() external view returns (uint256);\n\n    /**\n     * @notice Get the address of the fee collector\n     * @return The address of fee collector\n     */\n    function getFeeCollector() external view returns (address);\n\n    /**\n     * @notice Get the fee reduction of the given user for the given pt\n     * @param _pt The address of the pt\n     * @param _user The address of the user\n     * @return The fee reduction of the given user for the given pt\n     */\n    function getFeeReduction(address _pt, address _user) external view returns (uint256);\n\n    /**\n     * @notice Getter to check if a pt is registered\n     * @param _pt the address of the pt to check the registration of\n     * @return true if it is, false otherwise\n     */\n    function isRegisteredPT(address _pt) external view returns (bool);\n\n    /**\n     * @notice Getter for the pt registered at an index\n     * @param _index the index of the pt to return\n     * @return The address of the corresponding pt\n     */\n    function getPTAt(uint256 _index) external view returns (address);\n\n    /**\n     * @notice Getter for number of PT registered\n     * @return The number of PT registered\n     */\n    function pTCount() external view returns (uint256);\n\n    /* SETTERS\n     *****************************************************************************************************************/\n\n    /**\n     * @notice Setter for the tokens factory address\n     * @param _newFactory The address of the new factory\n     */\n    function setFactory(address _newFactory) external;\n\n    /**\n     * @notice set the router\n     * @param _router The address of the router\n     */\n    function setRouter(address _router) external;\n\n    /**\n     * @notice set the routerUtil\n     * @param _routerUtil The address of the routerUtil\n     */\n    function setRouterUtil(address _routerUtil) external;\n\n    /**\n     * @notice set the tokenization fee\n     * @param _tokenizationFee The value of tokenization fee\n     */\n    function setTokenizationFee(uint256 _tokenizationFee) external;\n\n    /**\n     * @notice set the yield fee\n     * @param _yieldFee The value of yield fee\n     */\n    function setYieldFee(uint256 _yieldFee) external;\n\n    /**\n     * @notice set the PT flash loan fee\n     * @param _ptFlashLoanFee The value of PT flash loan fee\n     */\n    function setPTFlashLoanFee(uint256 _ptFlashLoanFee) external;\n\n    /**\n     * @notice set the fee collector\n     * @param _feeCollector The address of fee collector\n     */\n    function setFeeCollector(address _feeCollector) external;\n\n    /**\n     * @notice Set the fee reduction of the given pt for the given user\n     * @param _pt The address of the pt\n     * @param _user The address of the user\n     * @param _reduction The fee reduction\n     */\n    function reduceFee(address _pt, address _user, uint256 _reduction) external;\n\n    /**\n     * @notice set the pt beacon\n     * @param _ptBeacon The address of PT beacon\n     */\n    function setPTBeacon(address _ptBeacon) external;\n\n    /**\n     * @notice set the yt beacon\n     * @param _ytBeacon The address of yt beacon\n     */\n    function setYTBeacon(address _ytBeacon) external;\n\n    /**\n     * @notice Add a pt to the registry\n     * @param _pt The address of the pt to add to the registry\n     */\n    function addPT(address _pt) external;\n\n    /**\n     * @notice Remove a pt from the registry\n     * @param _pt The address of the pt to remove from the registry\n     */\n    function removePT(address _pt) external;\n}\n"
    },
    "src/interfaces/ISpectra4626Wrapper.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.20;\n\nimport {IERC4626} from \"@openzeppelin/contracts/interfaces/IERC4626.sol\";\n\n/// @dev Interface of Spectra4626Wrapper.\ninterface ISpectra4626Wrapper is IERC4626 {\n    /// @dev Emitted when vault shares are deposited in the wrapper.\n    event Wrap(\n        address indexed caller,\n        address indexed receiver,\n        uint256 vaultShares,\n        uint256 shares\n    );\n\n    /// @dev Emitted when vault shares are withdrawn from the wrapper.\n    event Unwrap(\n        address indexed caller,\n        address indexed receiver,\n        address indexed owner,\n        uint256 shares,\n        uint256 vaultShares\n    );\n\n    /// @dev Emitted when rewards proxy is updated.\n    event RewardsProxyUpdated(address oldRewardsProxy, address newRewardsProxy);\n\n    error ERC5143SlippageProtectionFailed();\n    error NoRewardsProxy();\n    error ClaimRewardsFailed();\n\n    /// @dev Returns the address of the wrapped vault share.\n    function vaultShare() external view returns (address);\n\n    /// @dev Returns the vault share balance of the wrapper.\n    function totalVaultShares() external view returns (uint256);\n\n    /// @dev Returns the rewards proxy of the wrapper.\n    function rewardsProxy() external view returns (address);\n\n    /// @dev Allows to preview the amount of minted wrapper shares for a given amount of deposited vault shares.\n    /// @param vaultShares The amount of vault shares to deposit.\n    /// @return The amount of minted vault shares.\n    function previewWrap(uint256 vaultShares) external view returns (uint256);\n\n    /// @dev Allows to preview the amount of withdrawn vault shares for a given amount of redeemed wrapper shares.\n    /// @param shares The amount of wrapper shares to redeem.\n    /// @return The amount of withdrawn vault shares.\n    function previewUnwrap(uint256 shares) external view returns (uint256);\n\n    /// @dev Allows the owner to deposit vault shares into the wrapper.\n    /// @param vaultShares The amount of vault shares to deposit.\n    /// @param receiver The address to receive the wrapper shares.\n    /// @return The amount of minted wrapper shares.\n    function wrap(uint256 vaultShares, address receiver) external returns (uint256);\n\n    /// @dev Allows the owner to deposit vault shares into the wrapper, with support for slippage protection.\n    /// @param vaultShares The amount of vault shares to deposit.\n    /// @param receiver The address to receive the wrapper shares.\n    /// @param minShares The minimum allowed wrapper shares from this deposit.\n    /// @return The amount of minted wrapper shares.\n    function wrap(\n        uint256 vaultShares,\n        address receiver,\n        uint256 minShares\n    ) external returns (uint256);\n\n    /// @dev Allows the owner to withdraw vault shares from the wrapper.\n    /// @param shares The amount of wrapper shares to redeem.\n    /// @param receiver The address to receive the vault shares.\n    /// @param owner The address of the owner of the wrapper shares.\n    /// @return The amount of withdrawn vault shares.\n    function unwrap(uint256 shares, address receiver, address owner) external returns (uint256);\n\n    /// @dev Allows the owner to withdraw vault shares from the wrapper, with support for slippage protection.\n    /// @param shares The amount of wrapper shares to redeem.\n    /// @param receiver The address to receive the vault shares.\n    /// @param owner The address of the owner of the wrapper shares.\n    /// @param minVaultShares The minimum vault shares that should be returned.\n    /// @return The amount of withdrawn vault shares.\n    function unwrap(\n        uint256 shares,\n        address receiver,\n        address owner,\n        uint256 minVaultShares\n    ) external returns (uint256);\n\n    /// @dev Setter for the rewards proxy.\n    /// @param newRewardsProxy The address of the new rewards proxy.\n    function setRewardsProxy(address newRewardsProxy) external;\n\n    /// @dev Claims rewards for the wrapped vault.\n    /// @param data The optional data used for claiming rewards.\n    function claimRewards(bytes calldata data) external;\n}\n"
    },
    "src/router/util/RouterUtil.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.20;\n\nimport {Math} from \"openzeppelin-math/Math.sol\";\nimport {IERC20Metadata} from \"openzeppelin-contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {IERC4626} from \"openzeppelin-contracts/interfaces/IERC4626.sol\";\nimport {IERC3156FlashLender} from \"openzeppelin-contracts/interfaces/IERC3156FlashLender.sol\";\nimport {SafeCast} from \"openzeppelin-contracts/utils/math/SafeCast.sol\";\nimport {CurvePoolUtil} from \"../../libraries/CurvePoolUtil.sol\";\nimport {ICurvePool} from \"../../interfaces/ICurvePool.sol\";\nimport {IStableSwapNG} from \"../../interfaces/IStableSwapNG.sol\";\nimport {ICurveNGPool} from \"../../interfaces/ICurveNGPool.sol\";\nimport {IPrincipalToken} from \"../../interfaces/IPrincipalToken.sol\";\nimport {Constants} from \"../Constants.sol\";\n\n/**\n * @title Router Util contract\n * @author Spectra Finance\n * @notice Provides miscellaneous utils and preview functions related to Router executions.\n */\ncontract RouterUtil {\n    using Math for uint256;\n    using SafeCast for uint256;\n    using SafeCast for int256;\n\n    error InvalidTokenIndex(uint256 i, uint256 j);\n    error PoolLiquidityError();\n    error UnsufficientAmountForFlashFee();\n    error ResultNotFound();\n\n    /**\n     * @dev Gives the spot exchange rate of token i in terms of token j. Exchange rate is in 18 decimals\n     * @dev To be used with Curve Cryptoswap pools\n     * @param _curvePool PT/IBT curve pool\n     * @param _i token index, either 0 or 1\n     * @param _j token index, either 0 or 1, must be different than _i\n     * @return The spot exchange rate of _i in terms of _j\n     */\n\n    function spotExchangeRate(\n        address _curvePool,\n        uint256 _i,\n        uint256 _j\n    ) public view returns (uint256) {\n        if (_i == 0 && _j == 1) {\n            return\n                CurvePoolUtil.CURVE_UNIT.mulDiv(\n                    CurvePoolUtil.CURVE_UNIT,\n                    ICurvePool(_curvePool).last_prices()\n                );\n        } else if (_i == 1 && _j == 0) {\n            return ICurvePool(_curvePool).last_prices();\n        } else {\n            revert InvalidTokenIndex(_i, _j);\n        }\n    }\n\n    /**\n     * @dev Gives the spot exchange rate of token i in terms of token j. Exchange rate is in 18 decimals\n     * @dev To be used with Curve Stableswap pools\n     * @param _curvePool PT/IBT curve pool\n     * @param _i token index, either 0 or 1\n     * @param _j token index, either 0 or 1, must be different than _i\n     * @return The spot exchange rate of _i in terms of _j\n     */\n    function spotExchangeRateSNG(\n        address _curvePool,\n        int128 _i,\n        int128 _j\n    ) public view returns (uint256) {\n        uint256 last_prices = IStableSwapNG(_curvePool).last_price(0);\n        uint256[] memory stored_rates = IStableSwapNG(_curvePool).stored_rates();\n\n        if (_i == 0 && _j == 1) {\n            last_prices = stored_rates[0].mulDiv(CurvePoolUtil.CURVE_UNIT, stored_rates[1]).mulDiv(\n                CurvePoolUtil.CURVE_UNIT,\n                last_prices\n            );\n            return last_prices;\n        } else if (_i == 1 && _j == 0) {\n            last_prices = last_prices.mulDiv(stored_rates[1], stored_rates[0]);\n            return last_prices;\n        } else {\n            revert InvalidTokenIndex(uint256(uint128(_i)), uint256(uint128(_j)));\n        }\n    }\n\n    /**\n     * @dev To be used with Curve Cryptoswap pools\n     * @dev Gives the upper bound of the interval to perform bisection search in previewFlashSwapExactIBTForYT().\n     * @param _inputIBTAmount amount of IBT exchanged for YT\n     * @param _curvePool PT/IBT curve pool\n     * @return The upper bound for search interval in root finding algorithms\n     */\n    function convertIBTToYTSpot(\n        uint256 _inputIBTAmount,\n        address _curvePool\n    ) public view returns (uint256) {\n        // The spot exchange rate between IBT and YT is evaluated using the tokenization equation without fees.\n        // This equation reads: ptRate = 1 PT + 1 YT .\n\n        address pt = ICurvePool(_curvePool).coins(1);\n        uint256 ibtRate = IPrincipalToken(pt).getIBTRate(); // Ray\n        uint256 ptRate = IPrincipalToken(pt).getPTRate(); // Ray\n\n        uint256 ptInUnderlyingRay = spotExchangeRate(_curvePool, 1, 0).mulDiv(\n            ibtRate,\n            CurvePoolUtil.CURVE_UNIT\n        );\n        if (ptInUnderlyingRay > ptRate) {\n            revert PoolLiquidityError();\n        }\n        uint256 ytInUnderlyingRay = ptRate - ptInUnderlyingRay;\n\n        return _inputIBTAmount.mulDiv(ibtRate, ytInUnderlyingRay);\n    }\n\n    /**\n     * @dev Returns the maximal amount of YT one can obtain with a given amount of IBT (i.e without fees or slippage).\n     * @dev To be used with Curve Stableswap NG pools\n     * @dev Gives the upper bound of the interval to perform bisection search in previewFlashSwapExactIBTForYT().\n     * @param _inputIBTAmount amount of IBT exchanged for YT\n     * @param _curvePool PT/IBT curve pool\n     * @return The upper bound for search interval in root finding algorithms\n     */\n    function convertIBTToYTSpotSNG(\n        uint256 _inputIBTAmount,\n        address _curvePool\n    ) public view returns (uint256) {\n        // The spot exchange rate between IBT and YT is evaluated using the tokenization equation without fees.\n        // This equation reads: ptRate = 1 PT + 1 YT .\n\n        address pt = ICurvePool(_curvePool).coins(1);\n        uint256 ibtRate = IPrincipalToken(pt).getIBTRate(); // Ray\n        uint256 ptRate = IPrincipalToken(pt).getPTRate(); // Ray\n\n        uint256 ptInUnderlyingRay = spotExchangeRateSNG(_curvePool, 1, 0).mulDiv(\n            ibtRate,\n            CurvePoolUtil.CURVE_UNIT\n        );\n        if (ptInUnderlyingRay > ptRate) {\n            revert PoolLiquidityError();\n        }\n        uint256 ytInUnderlyingRay = ptRate - ptInUnderlyingRay;\n\n        return _inputIBTAmount.mulDiv(ibtRate, ytInUnderlyingRay);\n    }\n\n    /* PREVIEW FUNCTIONS FOR CURVE CRYPTOSWAP POOLS\n     *****************************************************************************************************************/\n\n    /**\n     * @dev Computes the amount of IBT required to buy a given output amount of YT.\n     * @dev Works for both Cryptoswap\n     * @param _curvePool PT/IBT curve pool\n     * @param _outputYTAmount desired output YT token amount\n     * @return inputIBTAmount The amount of IBT needed for obtaining the defined amount of YT\n     * @return borrowedIBTAmount the quantity of IBT borrowed to execute that swap\n     */\n    function previewFlashSwapIBTToExactYT(\n        address _curvePool,\n        uint256 _outputYTAmount\n    ) public view returns (uint256 inputIBTAmount, uint256 borrowedIBTAmount) {\n        // Tokens\n        address pt = ICurvePool(_curvePool).coins(1);\n        address ibt = IPrincipalToken(pt).getIBT();\n\n        // Units and rates\n        uint256 ibtRate = IPrincipalToken(pt).getIBTRate(); // Ray\n        uint256 ptRate = IPrincipalToken(pt).getPTRate(); // Ray\n\n        // Outputs\n        uint256 swapPTForIBT = ICurvePool(_curvePool).get_dy(1, 0, _outputYTAmount);\n\n        // y PT:YT = (x IBT * ((UNIT - tokenizationFee) / UNIT) * ibtRate) / ptRate\n        // <=> x IBT = (y PT:YT * ptRate * UNIT) / (ibtRate * (UNIT - tokenizationFee))\n        borrowedIBTAmount = (_outputYTAmount * ptRate * Constants.UNIT).ceilDiv(\n            ibtRate * (Constants.UNIT - IPrincipalToken(pt).getTokenizationFee())\n        );\n        if (swapPTForIBT > borrowedIBTAmount) {\n            revert PoolLiquidityError();\n        }\n        inputIBTAmount =\n            borrowedIBTAmount +\n            _getFlashFee(pt, ibt, borrowedIBTAmount) -\n            swapPTForIBT;\n    }\n\n    /**\n     * @dev Computes the amount of IBT required to buy a given output amount of YT.\n     * @dev Works for both Stableswap NG pools\n     * @param _curvePool PT/IBT curve pool\n     * @param _outputYTAmount desired output YT token amount\n     * @return inputIBTAmount The amount of IBT needed for obtaining the defined amount of YT\n     * @return borrowedIBTAmount the quantity of IBT borrowed to execute that swap\n     */\n    function previewFlashSwapIBTToExactYTSNG(\n        address _curvePool,\n        uint256 _outputYTAmount\n    ) public view returns (uint256 inputIBTAmount, uint256 borrowedIBTAmount) {\n        // Tokens\n        address pt = ICurvePool(_curvePool).coins(1);\n        address ibt = IPrincipalToken(pt).getIBT();\n\n        // Units and rates\n        uint256 ibtRate = IPrincipalToken(pt).getIBTRate(); // Ray\n        uint256 ptRate = IPrincipalToken(pt).getPTRate(); // Ray\n\n        // Outputs\n        uint256 swapPTForIBT = IStableSwapNG(_curvePool).get_dy(1, 0, _outputYTAmount);\n\n        // y PT:YT = (x IBT * ((UNIT - tokenizationFee) / UNIT) * ibtRate) / ptRate\n        // <=> x IBT = (y PT:YT * ptRate * UNIT) / (ibtRate * (UNIT - tokenizationFee))\n        borrowedIBTAmount = (_outputYTAmount * ptRate * Constants.UNIT).ceilDiv(\n            ibtRate * (Constants.UNIT - IPrincipalToken(pt).getTokenizationFee())\n        );\n        if (swapPTForIBT > borrowedIBTAmount) {\n            revert PoolLiquidityError();\n        }\n        inputIBTAmount =\n            borrowedIBTAmount +\n            _getFlashFee(pt, ibt, borrowedIBTAmount) -\n            swapPTForIBT;\n    }\n\n    /**\n     * @dev Approximates the expected output amount of YT corresponding to a given input amount of IBT.\n     * @dev To be used with Curve Cryptoswap pools\n     * @dev May return an output YT amount that corresponds to an input IBT amount lower than the given _inputIBTAmount.\n     * @dev This function can be expensive to execute and should only be called off-chain. Avoid using it within a transaction.\n     * @param _curvePool PT/IBT curve pool\n     * @param _inputIBTAmount amount of IBT exchanged for YT\n     * @return ytAmount The guess of YT obtained for the given amount of IBT\n     * @return borrowedIBTAmount The quantity of IBT borrowed to execute that swap.\n     */\n    function previewFlashSwapExactIBTToYT(\n        address _curvePool,\n        uint256 _inputIBTAmount\n    ) public view returns (uint256 ytAmount, uint256 borrowedIBTAmount) {\n        // initial guesses\n        address pt = ICurvePool(_curvePool).coins(1);\n        uint256 x0 = IPrincipalToken(pt).previewDepositIBT(_inputIBTAmount);\n        uint256 x1 = convertIBTToYTSpot(_inputIBTAmount, _curvePool);\n        uint256 ibtUnit = getUnit(ICurvePool(_curvePool).coins(0));\n\n        // Use secant method to approximate ytAmount\n        for (uint256 i = 0; i < Constants.MAX_ITERATIONS_SECANT; ++i) {\n            if (\n                _delta(x0, x1).mulDiv(ibtUnit, Math.max(x0, x1)) <\n                ibtUnit / Constants.PRECISION_DIVISOR\n            ) {\n                break;\n            }\n\n            (uint256 inputIBTAmount0, ) = previewFlashSwapIBTToExactYT(_curvePool, x0);\n            (uint256 inputIBTAmount1, ) = previewFlashSwapIBTToExactYT(_curvePool, x1);\n            int256 answer0 = inputIBTAmount0.toInt256() - _inputIBTAmount.toInt256();\n            int256 answer1 = inputIBTAmount1.toInt256() - _inputIBTAmount.toInt256();\n\n            if (answer0 == answer1) {\n                break;\n            }\n\n            // x2 = x1 - (f(x1) * (x1 - x0) / (f(x1) - f(x0)))\n            // x0, x1 = x1, x2\n            uint256 x2 = (x1.toInt256() -\n                ((answer1 * (x1.toInt256() - x0.toInt256())) / (answer1 - answer0))).toUint256();\n            x0 = x1;\n            x1 = x2;\n        }\n        ytAmount = Math.min(x0, x1);\n\n        uint256 resInputIBTAmount;\n        (resInputIBTAmount, borrowedIBTAmount) = previewFlashSwapIBTToExactYT(_curvePool, ytAmount);\n\n        // Run linear search if inputIBTAmount corresponding to ytAmount is higher than requested\n        if (resInputIBTAmount > _inputIBTAmount) {\n            // linear search\n            uint256 sf = Constants.SCALING_FACTOR_LINEAR_SEARCH;\n            for (uint256 i = 0; i < Constants.MAX_ITERATIONS_LINEAR_SEARCH; ++i) {\n                ytAmount = ytAmount.mulDiv(sf - 1, sf);\n                (resInputIBTAmount, borrowedIBTAmount) = previewFlashSwapIBTToExactYT(\n                    _curvePool,\n                    ytAmount\n                );\n                if (resInputIBTAmount <= _inputIBTAmount) {\n                    break;\n                }\n            }\n        }\n\n        // if result is still higher or too far from requested value\n        if (\n            resInputIBTAmount > _inputIBTAmount ||\n            _delta(_inputIBTAmount, resInputIBTAmount).mulDiv(ibtUnit, _inputIBTAmount) >\n            ibtUnit / Constants.PRECISION_DIVISOR\n        ) {\n            revert ResultNotFound();\n        }\n    }\n\n    /**\n     * @dev Approximates the expected output amount of YT corresponding to a given input amount of IBT.\n     * @dev To be used with Curve Stableswap NG pools\n     * @dev May return an output YT amount that corresponds to an input IBT amount lower than the given _inputIBTAmount.\n     * @dev This function can be expensive to execute and should only be called off-chain. Avoid using it within a transaction.\n     * @param _curvePool PT/IBT curve pool\n     * @param _inputIBTAmount amount of IBT exchanged for YT\n     * @return ytAmount The guess of YT obtained for the given amount of IBT\n     * @return borrowedIBTAmount The quantity of IBT borrowed to execute that swap.\n     */\n    function previewFlashSwapExactIBTToYTSNG(\n        address _curvePool,\n        uint256 _inputIBTAmount\n    ) public view returns (uint256 ytAmount, uint256 borrowedIBTAmount) {\n        // initial guesses\n        address pt = IStableSwapNG(_curvePool).coins(1);\n        uint256 x0 = IPrincipalToken(pt).previewDepositIBT(_inputIBTAmount);\n        uint256 x1 = convertIBTToYTSpotSNG(_inputIBTAmount, _curvePool);\n        uint256 ibtUnit = getUnit(ICurvePool(_curvePool).coins(0));\n\n        // Use secant method to approximate ytAmount\n        for (uint256 i = 0; i < Constants.MAX_ITERATIONS_SECANT; ++i) {\n            if (\n                _delta(x0, x1).mulDiv(ibtUnit, Math.max(x0, x1)) <\n                ibtUnit / Constants.PRECISION_DIVISOR\n            ) {\n                break;\n            }\n\n            (uint256 inputIBTAmount0, ) = previewFlashSwapIBTToExactYTSNG(_curvePool, x0);\n            (uint256 inputIBTAmount1, ) = previewFlashSwapIBTToExactYTSNG(_curvePool, x1);\n            int256 answer0 = inputIBTAmount0.toInt256() - _inputIBTAmount.toInt256();\n            int256 answer1 = inputIBTAmount1.toInt256() - _inputIBTAmount.toInt256();\n\n            if (answer0 == answer1) {\n                break;\n            }\n\n            // x2 = x1 - (f(x1) * (x1 - x0) / (f(x1) - f(x0)))\n            // x0, x1 = x1, x2\n            uint256 x2 = (x1.toInt256() -\n                ((answer1 * (x1.toInt256() - x0.toInt256())) / (answer1 - answer0))).toUint256();\n            x0 = x1;\n            x1 = x2;\n        }\n        ytAmount = Math.min(x0, x1);\n\n        uint256 resInputIBTAmount;\n        (resInputIBTAmount, borrowedIBTAmount) = previewFlashSwapIBTToExactYTSNG(\n            _curvePool,\n            ytAmount\n        );\n\n        // Run linear search if inputIBTAmount corresponding to ytAmount is higher than requested\n        if (resInputIBTAmount > _inputIBTAmount) {\n            // linear search\n            uint256 sf = Constants.SCALING_FACTOR_LINEAR_SEARCH;\n            for (uint256 i = 0; i < Constants.MAX_ITERATIONS_LINEAR_SEARCH; ++i) {\n                ytAmount = ytAmount.mulDiv(sf - 1, sf);\n                (resInputIBTAmount, borrowedIBTAmount) = previewFlashSwapIBTToExactYTSNG(\n                    _curvePool,\n                    ytAmount\n                );\n                if (resInputIBTAmount <= _inputIBTAmount) {\n                    break;\n                }\n            }\n        }\n\n        // if result is still higher or too far from requested value\n        if (\n            resInputIBTAmount > _inputIBTAmount ||\n            _delta(_inputIBTAmount, resInputIBTAmount).mulDiv(ibtUnit, _inputIBTAmount) >\n            ibtUnit / Constants.PRECISION_DIVISOR\n        ) {\n            revert ResultNotFound();\n        }\n    }\n\n    /**\n     * @dev Given an amount of YT, previews the amount of IBT received after exchange\n     * @dev To be used with Curve Cryptoswap pools\n     * @param _curvePool PT/IBT curve pool\n     * @param inputYTAmount amount of YT exchanged for IBT\n     * @return The amount of IBT obtained for the given amount of YT\n     * @return The amount of IBT borrowed to execute that swap.\n     */\n    function previewFlashSwapExactYTToIBT(\n        address _curvePool,\n        uint256 inputYTAmount\n    ) public view returns (uint256, uint256) {\n        // Tokens\n        address pt = ICurvePool(_curvePool).coins(1);\n        address ibt = IPrincipalToken(pt).getIBT();\n        // Units and Rates\n        uint256 ibtRate = IPrincipalToken(pt).getIBTRate();\n        uint256 ptRate = IPrincipalToken(pt).getPTRate();\n        // Outputs\n        uint256 borrowedIBTAmount = CurvePoolUtil.getDx(_curvePool, 0, 1, inputYTAmount);\n        uint256 inputYTAmountInIBT = inputYTAmount.mulDiv(ptRate, ibtRate);\n        uint256 flashFee = _getFlashFee(pt, ibt, borrowedIBTAmount);\n        if (borrowedIBTAmount > inputYTAmountInIBT) {\n            revert PoolLiquidityError();\n        } else if (borrowedIBTAmount + flashFee > inputYTAmountInIBT) {\n            revert UnsufficientAmountForFlashFee();\n        }\n        uint256 outputIBTAmount = inputYTAmountInIBT - borrowedIBTAmount - flashFee;\n\n        return (outputIBTAmount, borrowedIBTAmount);\n    }\n\n    /**\n     * @dev Given an amount of YT, previews the amount of IBT received after exchange\n     * @dev To be used with Curve StableSwap NG pools\n     * @param _curvePool PT/IBT curve pool\n     * @param inputYTAmount amount of YT exchanged for IBT\n     * @return The amount of IBT obtained for the given amount of YT\n     * @return The amount of IBT borrowed to execute that swap.\n     */\n    function previewFlashSwapExactYTToIBTSNG(\n        address _curvePool,\n        uint256 inputYTAmount\n    ) public view returns (uint256, uint256) {\n        // Tokens\n        address pt = ICurvePool(_curvePool).coins(1);\n        address ibt = IPrincipalToken(pt).getIBT();\n        // Units and Rates\n        uint256 ibtRate = IPrincipalToken(pt).getIBTRate();\n        uint256 ptRate = IPrincipalToken(pt).getPTRate();\n        // Outputs\n        uint256 borrowedIBTAmount = IStableSwapNG(_curvePool).get_dx(0, 1, inputYTAmount);\n        uint256 inputYTAmountInIBT = inputYTAmount.mulDiv(ptRate, ibtRate);\n        uint256 flashFee = _getFlashFee(pt, ibt, borrowedIBTAmount);\n        if (borrowedIBTAmount > inputYTAmountInIBT) {\n            revert PoolLiquidityError();\n        } else if (borrowedIBTAmount + flashFee > inputYTAmountInIBT) {\n            revert UnsufficientAmountForFlashFee();\n        }\n        uint256 outputIBTAmount = inputYTAmountInIBT - borrowedIBTAmount - flashFee;\n\n        return (outputIBTAmount, borrowedIBTAmount);\n    }\n\n    /**\n     * @notice Given an amount of asset, previews the amount of lp tokens received after depositing in the curve pool\n     * @notice To be used with Curve Cryptoswap pools\n     * @param _curvePool address of the curve pool\n     * @param _assets amount of assets to deposit into the curve pool\n     * @return minMintAmount amount of lp tokens received\n     */\n    function previewAddLiquidityWithAsset(\n        address _curvePool,\n        uint256 _assets\n    ) public view returns (uint256 minMintAmount) {\n        address ibt = ICurvePool(_curvePool).coins(0);\n        uint256 ibts = IERC4626(ibt).previewDeposit(_assets);\n        minMintAmount = previewAddLiquidityWithIBT(_curvePool, ibts);\n    }\n\n    /**\n     * @notice Given an amount of asset, previews the amount of lp tokens received after depositing in the curve pool\n     * @notice To be used with Curve Stableswap NG pools\n     * @param _curvePool address of the curve pool\n     * @param _assets amount of assets to deposit into the curve pool\n     * @return minMintAmount amount of lp tokens received\n     */\n    function previewAddLiquidityWithAssetSNG(\n        address _curvePool,\n        uint256 _assets\n    ) public view returns (uint256 minMintAmount) {\n        address ibt = ICurvePool(_curvePool).coins(0);\n        uint256 ibts = IERC4626(ibt).previewDeposit(_assets);\n        minMintAmount = previewAddLiquidityWithIBTSNG(_curvePool, ibts);\n    }\n\n    /**\n     * @notice Given an amount of ibt, previews the amount of lp tokens received after depositing in the curve pool\n     * @notice To be used with Curve Cryptoswap pools\n     * @param _curvePool address of the curve pool\n     * @param _ibts amount of ibt to deposit into the curve pool\n     * @return minMintAmount amount of lp tokens received\n     */\n    function previewAddLiquidityWithIBT(\n        address _curvePool,\n        uint256 _ibts\n    ) public view returns (uint256 minMintAmount) {\n        address pt = ICurvePool(_curvePool).coins(1);\n        uint256 ibtToDepositInPT = CurvePoolUtil.calcIBTsToTokenizeForCurvePool(\n            _ibts,\n            _curvePool,\n            pt\n        );\n        uint256 amount0 = _ibts - ibtToDepositInPT;\n        uint256 amount1 = IPrincipalToken(pt).previewDepositIBT(ibtToDepositInPT);\n        minMintAmount = previewAddLiquidity(_curvePool, [amount0, amount1]);\n    }\n\n    /**\n     * @notice Given an amount of ibt, previews the amount of lp tokens received after depositing in the curve pool\n     * @notice To be used with Curve Stableswap NG pools\n     * @param _curvePool address of the curve pool\n     * @param _ibts amount of ibt to deposit into the curve pool\n     * @return minMintAmount amount of lp tokens received\n     */\n    function previewAddLiquidityWithIBTSNG(\n        address _curvePool,\n        uint256 _ibts\n    ) public view returns (uint256 minMintAmount) {\n        address pt = IStableSwapNG(_curvePool).coins(1);\n        uint256 ibtToDepositInPT = CurvePoolUtil.calcIBTsToTokenizeForCurvePool(\n            _ibts,\n            _curvePool,\n            pt\n        );\n        uint256 amount0 = _ibts - ibtToDepositInPT;\n        uint256 amount1 = IPrincipalToken(pt).previewDepositIBT(ibtToDepositInPT);\n        uint256[] memory amounts = new uint256[](2);\n        amounts[0] = amount0;\n        amounts[1] = amount1;\n        minMintAmount = previewAddLiquiditySNG(_curvePool, amounts);\n    }\n\n    /**\n     * @notice Given an amount of ibts and pts, previews the amount of lp tokens received after depositing in the curve pool\n     * @notice To be used with Curve Cryptoswap pools\n     * @param _curvePool address of the curve pool\n     * @param _amounts array of length two containing the amount of ibt and pt to deposit into the pool respectively\n     * @return minMintAmount amount of lp tokens received\n     */\n    function previewAddLiquidity(\n        address _curvePool,\n        uint256[2] memory _amounts\n    ) public view returns (uint256 minMintAmount) {\n        minMintAmount = CurvePoolUtil.previewAddLiquidity(_curvePool, _amounts);\n    }\n\n    /**\n     * @notice Given an amount of ibts and pts, previews the amount of lp tokens received after depositing in the curve pool\n     * @notice To be used with Curve Stableswap NG pools\n     * @param _curvePool address of the curve pool\n     * @param _amounts array of length two containing the amount of ibt and pt to deposit into the pool respectively\n     * @return minMintAmount amount of lp tokens received\n     */\n    function previewAddLiquiditySNG(\n        address _curvePool,\n        uint256[] memory _amounts\n    ) public view returns (uint256 minMintAmount) {\n        minMintAmount = CurvePoolUtil.previewAddLiquiditySNG(_curvePool, _amounts);\n    }\n\n    /**\n     * @notice Given an amount of lp tokens, previews the amount of asset received after withdrawing from the curve pool\n     * @notice To be used with Curve Cryptoswap and Stableswap NG pools\n     * @param _curvePool address of the curve pool\n     * @param _lpAmount amount of lp tokens to withdraw from the curve pool\n     * @return assets amount of asset received\n     */\n    function previewRemoveLiquidityForAsset(\n        address _curvePool,\n        uint256 _lpAmount\n    ) public view returns (uint256 assets) {\n        uint256[2] memory minAmounts = CurvePoolUtil.previewRemoveLiquidity(_curvePool, _lpAmount);\n        assets =\n            IERC4626(ICurvePool(_curvePool).coins(0)).previewRedeem(minAmounts[0]) +\n            IPrincipalToken(ICurvePool(_curvePool).coins(1)).previewRedeem(minAmounts[1]);\n    }\n\n    /**\n     * @notice Given an amount of lp tokens, previews the amount of asset received after withdrawing from the curve pool\n     * @notice To be used with Curve Stableswap NG pools\n     * @param _curvePool address of the curve pool\n     * @param _lpAmount amount of lp tokens to withdraw from the curve pool\n     * @return assets amount of asset received\n     */\n    function previewRemoveLiquidityForAssetSNG(\n        address _curvePool,\n        uint256 _lpAmount\n    ) public view returns (uint256 assets) {\n        uint256[] memory minAmounts = CurvePoolUtil.previewRemoveLiquiditySNG(\n            _curvePool,\n            _lpAmount\n        );\n        assets =\n            IERC4626(ICurvePool(_curvePool).coins(0)).previewRedeem(minAmounts[0]) +\n            IPrincipalToken(ICurvePool(_curvePool).coins(1)).previewRedeem(minAmounts[1]);\n    }\n\n    /**\n     * @notice Given an amount of lp tokens, previews the amount of ibt received after withdrawing from the curve pool\n     * @notice To be used with Curve Cryptoswap\n     * @param _curvePool address of the curve pool\n     * @param _lpAmount amount of lp tokens to withdraw from the curve pool\n     * @return ibts amount of ibt received\n     */\n    function previewRemoveLiquidityForIBT(\n        address _curvePool,\n        uint256 _lpAmount\n    ) public view returns (uint256 ibts) {\n        uint256[2] memory minAmounts = CurvePoolUtil.previewRemoveLiquidity(_curvePool, _lpAmount);\n        ibts =\n            minAmounts[0] +\n            IPrincipalToken(ICurvePool(_curvePool).coins(1)).previewRedeemForIBT(minAmounts[1]);\n    }\n\n    /**\n     * @notice Given an amount of lp tokens, previews the amount of ibt received after withdrawing from the curve pool\n     * @notice To be used with Curve Stableswap NG pools\n     * @param _curvePool address of the curve pool\n     * @param _lpAmount amount of lp tokens to withdraw from the curve pool\n     * @return ibts amount of ibt received\n     */\n    function previewRemoveLiquidityForIBTSNG(\n        address _curvePool,\n        uint256 _lpAmount\n    ) public view returns (uint256 ibts) {\n        uint256[] memory minAmounts = CurvePoolUtil.previewRemoveLiquiditySNG(\n            _curvePool,\n            _lpAmount\n        );\n        ibts =\n            minAmounts[0] +\n            IPrincipalToken(ICurvePool(_curvePool).coins(1)).previewRedeemForIBT(minAmounts[1]);\n    }\n\n    /**\n     * @notice Given an amount of lp tokens, previews the amount of ibt and pt received after withdrawing from the curve pool\n     * @notice To be used with Curve Cryptoswap and Stableswap NG pools\n     * @param _curvePool address of the curve pool\n     * @param _lpAmount amount of lp tokens to withdraw from the curve pool\n     * @return minAmounts array of length two cointaining the amount of ibt and pt received after withdrawing from the curve pool\n     */\n    function previewRemoveLiquidity(\n        address _curvePool,\n        uint256 _lpAmount\n    ) public view returns (uint256[2] memory minAmounts) {\n        minAmounts = CurvePoolUtil.previewRemoveLiquidity(_curvePool, _lpAmount);\n    }\n\n    /**\n     * @notice Given an amount of lp tokens, previews the amount of ibt and pt received after withdrawing from the curve pool\n     * @notice To be used with Stableswap NG pools\n     * @param _curvePool address of the curve pool\n     * @param _lpAmount amount of lp tokens to withdraw from the curve pool\n     * @return minAmounts array of length two cointaining the amount of ibt and pt received after withdrawing from the curve pool\n     */\n    function previewRemoveLiquiditySNG(\n        address _curvePool,\n        uint256 _lpAmount\n    ) public view returns (uint256[] memory minAmounts) {\n        minAmounts = CurvePoolUtil.previewRemoveLiquiditySNG(_curvePool, _lpAmount);\n    }\n\n    /**\n     * @notice Given an amount of lp tokens, previews the amount of token at index _i received after withdrawing from the curve pool\n     * @notice To be used with Curve Cryptoswap and  pools\n     * @param _curvePool address of the curve pool\n     * @param _lpAmount amount of lp tokens to withdraw from the curve pool\n     * @param _i Index of the token to withdraw in\n     * @return minAmount amount of token at index _i after withdrawing from the curve pool\n     */\n    function previewRemoveLiquidityOneCoin(\n        address _curvePool,\n        uint256 _lpAmount,\n        uint256 _i\n    ) public view returns (uint256 minAmount) {\n        minAmount = CurvePoolUtil.previewRemoveLiquidityOneCoin(_curvePool, _lpAmount, _i);\n    }\n\n    /**\n     * @notice Given an amount of lp tokens, previews the amount of token at index _i received after withdrawing from the curve pool\n     * @notice To be used with Curve  Stableswap NG pools\n     * @param _curvePool address of the curve pool\n     * @param _lpAmount amount of lp tokens to withdraw from the curve pool\n     * @param _i Index of the token to withdraw in\n     * @return minAmount amount of token at index _i after withdrawing from the curve pool\n     */\n    function previewRemoveLiquidityOneCoinSNG(\n        address _curvePool,\n        uint256 _lpAmount,\n        int128 _i\n    ) public view returns (uint256 minAmount) {\n        minAmount = CurvePoolUtil.previewRemoveLiquidityOneCoinSNG(_curvePool, _lpAmount, _i);\n    }\n\n    /* PREVIEW FUNCTIONS FOR CURVE TWOCRYPTO-NG POOLS\n     *****************************************************************************************************************/\n\n    /**\n     * @dev Computes the amount of IBT required to buy a given output amount of YT.\n     * @param _curvePool PT/IBT curve pool\n     * @param _outputYTAmount desired output YT token amount\n     * @return inputIBTAmount The amount of IBT needed for obtaining the defined amount of YT\n     * @return borrowedIBTAmount the quantity of IBT borrowed to execute that swap\n     */\n    function previewNGFlashSwapIBTToExactYT(\n        address _curvePool,\n        uint256 _outputYTAmount\n    ) public view returns (uint256 inputIBTAmount, uint256 borrowedIBTAmount) {\n        return previewFlashSwapIBTToExactYT(_curvePool, _outputYTAmount);\n    }\n\n    /**\n     * @dev Approximates the expected output amount of YT corresponding to a given input amount of IBT.\n     * @dev May return an output YT amount that corresponds to an input IBT amount lower than the given _inputIBTAmount.\n     * @dev This function can be expensive to execute and should only be called off-chain. Avoid using it within a transaction.\n     * @param _curvePool PT/IBT curve pool\n     * @param _inputIBTAmount amount of IBT exchanged for YT\n     * @return ytAmount The guess of YT obtained for the given amount of IBT\n     * @return borrowedIBTAmount The quantity of IBT borrowed to execute that swap.\n     */\n    function previewNGFlashSwapExactIBTToYT(\n        address _curvePool,\n        uint256 _inputIBTAmount\n    ) public view returns (uint256 ytAmount, uint256 borrowedIBTAmount) {\n        return previewFlashSwapExactIBTToYT(_curvePool, _inputIBTAmount);\n    }\n\n    /**\n     * @dev Given an amount of YT, previews the amount of IBT received after exchange\n     * @param _curvePool PT/IBT curve pool\n     * @param inputYTAmount amount of YT exchanged for IBT\n     * @return The amount of IBT obtained for the given amount of YT\n     * @return The amount of IBT borrowed to execute that swap.\n     */\n    function previewNGFlashSwapExactYTToIBT(\n        address _curvePool,\n        uint256 inputYTAmount\n    ) public view returns (uint256, uint256) {\n        // Tokens\n        address pt = ICurvePool(_curvePool).coins(1);\n        address ibt = IPrincipalToken(pt).getIBT();\n        // Units and Rates\n        uint256 ibtRate = IPrincipalToken(pt).getIBTRate();\n        uint256 ptRate = IPrincipalToken(pt).getPTRate();\n        // Outputs\n        uint256 borrowedIBTAmount = ICurveNGPool(_curvePool).get_dx(0, 1, inputYTAmount);\n        uint256 inputYTAmountInIBT = inputYTAmount.mulDiv(ptRate, ibtRate);\n        uint256 flashFee = _getFlashFee(pt, ibt, borrowedIBTAmount);\n        if (borrowedIBTAmount > inputYTAmountInIBT) {\n            revert PoolLiquidityError();\n        } else if (borrowedIBTAmount + flashFee > inputYTAmountInIBT) {\n            revert UnsufficientAmountForFlashFee();\n        }\n        uint256 outputIBTAmount = inputYTAmountInIBT - borrowedIBTAmount - flashFee;\n\n        return (outputIBTAmount, borrowedIBTAmount);\n    }\n\n    function previewNGAddLiquidityWithAsset(\n        address _curvePool,\n        uint256 _assets\n    ) public view returns (uint256 minMintAmount) {\n        address ibt = ICurveNGPool(_curvePool).coins(0);\n        uint256 ibts = IERC4626(ibt).previewDeposit(_assets);\n        minMintAmount = previewNGAddLiquidityWithIBT(_curvePool, ibts);\n    }\n\n    function previewNGAddLiquidityWithIBT(\n        address _curvePool,\n        uint256 _ibts\n    ) public view returns (uint256 minMintAmount) {\n        address pt = ICurveNGPool(_curvePool).coins(1);\n        uint256 ibtToDepositInPT = CurvePoolUtil.calcIBTsToTokenizeForCurvePool(\n            _ibts,\n            _curvePool,\n            pt\n        );\n        uint256 amount0 = _ibts - ibtToDepositInPT;\n        uint256 amount1 = IPrincipalToken(pt).previewDepositIBT(ibtToDepositInPT);\n        minMintAmount = CurvePoolUtil.previewAddLiquidityNG(_curvePool, [amount0, amount1]);\n    }\n\n    function previewNGAddLiquidity(\n        address _curvePool,\n        uint256[2] memory _amounts\n    ) public view returns (uint256 minMintAmount) {\n        minMintAmount = CurvePoolUtil.previewAddLiquidityNG(_curvePool, _amounts);\n    }\n\n    function previewNGRemoveLiquidityForAsset(\n        address _curvePool,\n        uint256 _lpAmount\n    ) public view returns (uint256 assets) {\n        uint256[2] memory minAmounts = CurvePoolUtil.previewRemoveLiquidityNG(\n            _curvePool,\n            _lpAmount\n        );\n        assets =\n            IERC4626(ICurveNGPool(_curvePool).coins(0)).previewRedeem(minAmounts[0]) +\n            IPrincipalToken(ICurveNGPool(_curvePool).coins(1)).previewRedeem(minAmounts[1]);\n    }\n\n    function previewNGRemoveLiquidityForIBT(\n        address _curvePool,\n        uint256 _lpAmount\n    ) public view returns (uint256 ibts) {\n        uint256[2] memory minAmounts = CurvePoolUtil.previewRemoveLiquidityNG(\n            _curvePool,\n            _lpAmount\n        );\n        ibts =\n            minAmounts[0] +\n            IPrincipalToken(ICurvePool(_curvePool).coins(1)).previewRedeemForIBT(minAmounts[1]);\n    }\n\n    function previewNGRemoveLiquidity(\n        address _curvePool,\n        uint256 _lpAmount\n    ) public view returns (uint256[2] memory minAmounts) {\n        minAmounts = CurvePoolUtil.previewRemoveLiquidityNG(_curvePool, _lpAmount);\n    }\n\n    function previewNGRemoveLiquidityOneCoin(\n        address _curvePool,\n        uint256 _lpAmount,\n        uint256 _i\n    ) public view returns (uint256 minAmount) {\n        minAmount = CurvePoolUtil.previewRemoveLiquidityOneCoinNG(_curvePool, _lpAmount, _i);\n    }\n\n    /* PUBLIC UTILS\n     *****************************************************************************************************************/\n\n    /**\n     * @dev Returns the unit element of the underlying asset of a PT\n     * @param _pt address of Principal Token\n     * @return The unit of underlying asset\n     */\n    function getPTUnderlyingUnit(address _pt) external view returns (uint256) {\n        return getUnit(IPrincipalToken(_pt).underlying());\n    }\n\n    /**\n     * @dev Returns the unit element of the token\n     * @param _token address of token\n     * @return The unit of asset\n     */\n    function getUnit(address _token) public view returns (uint256) {\n        return 10 ** IERC20Metadata(_token).decimals();\n    }\n\n    /* INTERNAL FUNCTIONS\n     *****************************************************************************************************************/\n\n    /**\n     * @dev Calculates the flash loan fee for borrowing a given quantity of IBT\n     * @param _pt address of Principal Token\n     * @param _ibt address of Interest Bearing Token\n     * @param _borrowedIBTAmount amount of Interest Bearing Tokens that have been borrowed in the flash loan\n     * @return The amount of fees charged for flash loan\n     */\n    function _getFlashFee(\n        address _pt,\n        address _ibt,\n        uint256 _borrowedIBTAmount\n    ) internal view returns (uint256) {\n        return IERC3156FlashLender(_pt).flashFee(_ibt, _borrowedIBTAmount);\n    }\n\n    /**\n     * @dev abs(a, b)\n     * @param a some integer\n     * @param b some integer\n     * @return The absolute value of a - b\n     */\n    function _delta(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a - b : b - a;\n    }\n}\n"
    },
    "src/interfaces/INATIVE.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.20;\n\ninterface INATIVE {\n    function deposit() external payable;\n\n    function withdraw(uint wad) external;\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/types/Time.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/types/Time.sol)\n\npragma solidity ^0.8.20;\n\nimport {Math} from \"../math/Math.sol\";\nimport {SafeCast} from \"../math/SafeCast.sol\";\n\n/**\n * @dev This library provides helpers for manipulating time-related objects.\n *\n * It uses the following types:\n * - `uint48` for timepoints\n * - `uint32` for durations\n *\n * While the library doesn't provide specific types for timepoints and duration, it does provide:\n * - a `Delay` type to represent duration that can be programmed to change value automatically at a given point\n * - additional helper functions\n */\nlibrary Time {\n    using Time for *;\n\n    /**\n     * @dev Get the block timestamp as a Timepoint.\n     */\n    function timestamp() internal view returns (uint48) {\n        return SafeCast.toUint48(block.timestamp);\n    }\n\n    /**\n     * @dev Get the block number as a Timepoint.\n     */\n    function blockNumber() internal view returns (uint48) {\n        return SafeCast.toUint48(block.number);\n    }\n\n    // ==================================================== Delay =====================================================\n    /**\n     * @dev A `Delay` is a uint32 duration that can be programmed to change value automatically at a given point in the\n     * future. The \"effect\" timepoint describes when the transitions happens from the \"old\" value to the \"new\" value.\n     * This allows updating the delay applied to some operation while keeping some guarantees.\n     *\n     * In particular, the {update} function guarantees that if the delay is reduced, the old delay still applies for\n     * some time. For example if the delay is currently 7 days to do an upgrade, the admin should not be able to set\n     * the delay to 0 and upgrade immediately. If the admin wants to reduce the delay, the old delay (7 days) should\n     * still apply for some time.\n     *\n     *\n     * The `Delay` type is 112 bits long, and packs the following:\n     *\n     * ```\n     *   | [uint48]: effect date (timepoint)\n     *   |           | [uint32]: value before (duration)\n     *   ↓           ↓       ↓ [uint32]: value after (duration)\n     * 0xAAAAAAAAAAAABBBBBBBBCCCCCCCC\n     * ```\n     *\n     * NOTE: The {get} and {withUpdate} functions operate using timestamps. Block number based delays are not currently\n     * supported.\n     */\n    type Delay is uint112;\n\n    /**\n     * @dev Wrap a duration into a Delay to add the one-step \"update in the future\" feature\n     */\n    function toDelay(uint32 duration) internal pure returns (Delay) {\n        return Delay.wrap(duration);\n    }\n\n    /**\n     * @dev Get the value at a given timepoint plus the pending value and effect timepoint if there is a scheduled\n     * change after this timepoint. If the effect timepoint is 0, then the pending value should not be considered.\n     */\n    function _getFullAt(Delay self, uint48 timepoint) private pure returns (uint32, uint32, uint48) {\n        (uint32 valueBefore, uint32 valueAfter, uint48 effect) = self.unpack();\n        return effect <= timepoint ? (valueAfter, 0, 0) : (valueBefore, valueAfter, effect);\n    }\n\n    /**\n     * @dev Get the current value plus the pending value and effect timepoint if there is a scheduled change. If the\n     * effect timepoint is 0, then the pending value should not be considered.\n     */\n    function getFull(Delay self) internal view returns (uint32, uint32, uint48) {\n        return _getFullAt(self, timestamp());\n    }\n\n    /**\n     * @dev Get the current value.\n     */\n    function get(Delay self) internal view returns (uint32) {\n        (uint32 delay, , ) = self.getFull();\n        return delay;\n    }\n\n    /**\n     * @dev Update a Delay object so that it takes a new duration after a timepoint that is automatically computed to\n     * enforce the old delay at the moment of the update. Returns the updated Delay object and the timestamp when the\n     * new delay becomes effective.\n     */\n    function withUpdate(\n        Delay self,\n        uint32 newValue,\n        uint32 minSetback\n    ) internal view returns (Delay updatedDelay, uint48 effect) {\n        uint32 value = self.get();\n        uint32 setback = uint32(Math.max(minSetback, value > newValue ? value - newValue : 0));\n        effect = timestamp() + setback;\n        return (pack(value, newValue, effect), effect);\n    }\n\n    /**\n     * @dev Split a delay into its components: valueBefore, valueAfter and effect (transition timepoint).\n     */\n    function unpack(Delay self) internal pure returns (uint32 valueBefore, uint32 valueAfter, uint48 effect) {\n        uint112 raw = Delay.unwrap(self);\n\n        valueAfter = uint32(raw);\n        valueBefore = uint32(raw >> 32);\n        effect = uint48(raw >> 64);\n\n        return (valueBefore, valueAfter, effect);\n    }\n\n    /**\n     * @dev pack the components into a Delay object.\n     */\n    function pack(uint32 valueBefore, uint32 valueAfter, uint48 effect) internal pure returns (Delay) {\n        return Delay.wrap((uint112(effect) << 64) | (uint112(valueBefore) << 32) | uint112(valueAfter));\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../token/ERC20/IERC20.sol\";\n"
    },
    "lib/openzeppelin-contracts/contracts/interfaces/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC20Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20Metadata} from \"../token/ERC20/extensions/IERC20Metadata.sol\";\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value > type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value > type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value > type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value > type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value > type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value > type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value > type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value > type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value > type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value > type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value > type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value > type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value > type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value > type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value > type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value > type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value > type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value > type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value > type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value > type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value > type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value > type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value > type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value > type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value > type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value > type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value > type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value > type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value > type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value > type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value > type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value < 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value > uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n}\n"
    }
  },
  "settings": {
    "remappings": [
      "ds-test/=lib/forge-std/lib/ds-test/src/",
      "erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/",
      "forge-std/=lib/forge-std/src/",
      "openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/",
      "openzeppelin-contracts/=lib/openzeppelin-contracts/contracts/",
      "openzeppelin-erc20-basic/=lib/openzeppelin-contracts/contracts/token/ERC20/",
      "openzeppelin-erc20-extensions/=lib/openzeppelin-contracts-upgradeable/contracts/token/ERC20/extensions/",
      "openzeppelin-erc20/=lib/openzeppelin-contracts-upgradeable/contracts/token/ERC20/",
      "openzeppelin-math/=lib/openzeppelin-contracts/contracts/utils/math/",
      "openzeppelin-proxy/=lib/openzeppelin-contracts-upgradeable/contracts/proxy/utils/",
      "openzeppelin-utils/=lib/openzeppelin-contracts/contracts/utils/",
      "@openzeppelin/contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/",
      "@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "metadata": {
      "useLiteralContent": false,
      "bytecodeHash": "ipfs",
      "appendCBOR": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "evmVersion": "shanghai",
    "viaIR": false,
    "libraries": {
      "src/libraries/CurvePoolUtil.sol": {
        "CurvePoolUtil": "0x662DeB224Ce02060688701fCC8cE156BBca4bDD5"
      }
    }
  }
}}