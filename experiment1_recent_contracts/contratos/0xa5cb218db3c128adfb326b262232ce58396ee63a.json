{{
  "language": "Solidity",
  "sources": {
    "src/MaseerGate.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Copyright (c) 2025 Maseer LTD\n//\n// This file is subject to the Business Source License 1.1.\n// You may not use this file except in compliance with the License.\n//\n// You may obtain a copy of the License at:\n// https://github.com/Maseer-LTD/maseer-one/blob/master/LICENSE\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\npragma solidity ^0.8.28;\n\nimport {MaseerImplementation} from \"./MaseerImplementation.sol\";\n\ncontract MaseerGate is MaseerImplementation {\n\n    bytes32 internal constant _OPEN_MINT_SLOT   = keccak256(\"maseer.gate.mint.open\");\n    bytes32 internal constant _HALT_MINT_SLOT   = keccak256(\"maseer.gate.mint.halt\");\n    bytes32 internal constant _OPEN_BURN_SLOT   = keccak256(\"maseer.gate.burn.open\");\n    bytes32 internal constant _HALT_BURN_SLOT   = keccak256(\"maseer.gate.burn.halt\");\n    bytes32 internal constant _BPSIN_SLOT       = keccak256(\"maseer.gate.bpsin\");\n    bytes32 internal constant _BPSOUT_SLOT      = keccak256(\"maseer.gate.bpsout\");\n    bytes32 internal constant _COOLDOWN_SLOT    = keccak256(\"maseer.gate.cooldown\");\n    bytes32 internal constant _CAPACITY_SLOT    = keccak256(\"maseer.gate.capacity\");\n    bytes32 internal constant _TERMS_SLOT       = keccak256(\"maseer.gate.terms\");\n\n    // Allocate slots 0-49\n    uint256[50] private __gap;\n\n    constructor() {\n        _rely(msg.sender);\n    }\n\n    function mintable() external view returns (bool) {\n        return block.timestamp >= openMint() &&\n               block.timestamp <= haltMint();\n    }\n\n    function burnable() external view returns (bool) {\n        return block.timestamp >= openBurn() &&\n               block.timestamp <= haltBurn();\n    }\n\n    function mintcost(uint256 _price) external view returns (uint256) {\n        return _adjustMintPrice(_price, bpsin());\n    }\n\n    function burncost(uint256 _price) external view returns (uint256) {\n        return _adjustBurnPrice(_price, bpsout());\n    }\n\n    function openMint() public view returns (uint256) {\n        return _uint256Slot(_OPEN_MINT_SLOT);\n    }\n\n    function haltMint() public view returns (uint256) {\n        return _uint256Slot(_HALT_MINT_SLOT);\n    }\n\n    function openBurn() public view returns (uint256) {\n        return _uint256Slot(_OPEN_BURN_SLOT);\n    }\n\n    function haltBurn() public view returns (uint256) {\n        return _uint256Slot(_HALT_BURN_SLOT);\n    }\n\n    function bpsin() public view returns (uint256) {\n        return _uint256Slot(_BPSIN_SLOT);\n    }\n\n    function bpsout() public view returns (uint256) {\n        return _uint256Slot(_BPSOUT_SLOT);\n    }\n\n    function cooldown() public view returns (uint256) {\n        return _uint256Slot(_COOLDOWN_SLOT);\n    }\n\n    function capacity() public view returns (uint256) {\n        return _uint256Slot(_CAPACITY_SLOT);\n    }\n\n    function terms() public view returns (string memory) {\n        return _stringSlot(_TERMS_SLOT);\n    }\n\n    function nextOpenMint() external view returns (uint256) {\n        uint256 _open = openMint();\n        return _open >= block.timestamp ? _open : 0;\n    }\n\n    function nextHaltMint() external view returns (uint256) {\n        uint256 _halt = haltMint();\n        return _halt >= block.timestamp ? _halt : 0;\n    }\n\n    function nextOpenBurn() external view returns (uint256) {\n        uint256 _open = openBurn();\n        return _open >= block.timestamp ? _open : 0;\n    }\n\n    function nextHaltBurn() external view returns (uint256) {\n        uint256 _halt = haltBurn();\n        return _halt >= block.timestamp ? _halt : 0;\n    }\n\n    function setOpenMint(uint256 open_) external auth {\n        if (open_ > block.timestamp + 365 days) revert UnrecognizedParam(bytes32(open_));\n        _setOpenMint(open_);\n    }\n\n    function setHaltMint(uint256 halt_) external auth {\n        if (halt_ > block.timestamp + 365 days) revert UnrecognizedParam(bytes32(halt_));\n        _setHaltMint(halt_);\n    }\n\n    function setOpenBurn(uint256 open_) external auth {\n        if (open_ > block.timestamp + 365 days) revert UnrecognizedParam(bytes32(open_));\n        _setOpenBurn(open_);\n    }\n\n    function setHaltBurn(uint256 halt_) external auth {\n        if (halt_ > block.timestamp + 365 days) revert UnrecognizedParam(bytes32(halt_));\n        _setHaltBurn(halt_);\n    }\n\n    function pauseMarket() external auth {\n        _setOpenMint(0);\n        _setHaltMint(0);\n        _setOpenBurn(0);\n        _setHaltBurn(0);\n    }\n\n    function setBpsin(uint256 bpsin_) external auth {\n        if (bpsin_ > 10000) revert UnrecognizedParam(bytes32(bpsin_));\n        _setBpsin(bpsin_);\n    }\n\n    function setBpsout(uint256 bpsout_) external auth {\n        if (bpsout_ > 10000) revert UnrecognizedParam(bytes32(bpsout_));\n        _setBpsout(bpsout_);\n    }\n\n    function setCooldown(uint256 cool_) external auth {\n        if (cool_ > 365 days) revert UnrecognizedParam(bytes32(cool_));\n        _setCooldown(cool_);\n    }\n\n    function setCapacity(uint256 capacity_) external auth {\n        _setCapacity(capacity_);\n    }\n\n    function setTerms(string calldata terms_) external auth {\n        _setVal(_TERMS_SLOT, terms_);\n    }\n\n    function file(bytes32 what, uint256 data) external auth {\n        if      (what == \"openmint\") _setOpenMint(data);\n        else if (what == \"haltmint\") _setHaltMint(data);\n        else if (what == \"openburn\") _setOpenBurn(data);\n        else if (what == \"haltburn\") _setHaltBurn(data);\n        else if (what == \"bpsin\")    _setBpsin(data);\n        else if (what == \"bpsout\")   _setBpsout(data);\n        else if (what == \"cooldown\") _setCooldown(data);\n        else if (what == \"capacity\") _setCapacity(data);\n        else    revert UnrecognizedParam(what);\n    }\n\n    function _setOpenMint(uint256 open_) internal {\n        _setVal(_OPEN_MINT_SLOT, bytes32(open_));\n    }\n\n    function _setHaltMint(uint256 halt_) internal {\n        _setVal(_HALT_MINT_SLOT, bytes32(halt_));\n    }\n\n    function _setOpenBurn(uint256 open_) internal {\n        _setVal(_OPEN_BURN_SLOT, bytes32(open_));\n    }\n\n    function _setHaltBurn(uint256 halt_) internal {\n        _setVal(_HALT_BURN_SLOT, bytes32(halt_));\n    }\n\n    function _setBpsin(uint256 bpsin_) internal {\n        _setVal(_BPSIN_SLOT, bytes32(bpsin_));\n    }\n\n    function _setBpsout(uint256 bpsout_) internal {\n        _setVal(_BPSOUT_SLOT, bytes32(bpsout_));\n    }\n\n    function _setCooldown(uint256 cool_) internal {\n        _setVal(_COOLDOWN_SLOT, bytes32(cool_));\n    }\n\n    function _setCapacity(uint256 cap_) internal {\n        _setVal(_CAPACITY_SLOT, bytes32(cap_));\n    }\n\n    function _adjustMintPrice(uint256 _price, uint256 _bps) internal pure returns (uint256) {\n        return _divup((_price * (10_000 + _bps)), 10_000);\n    }\n\n    function _adjustBurnPrice(uint256 _price, uint256 _bps) internal pure returns (uint256) {\n        return _divup((_price * (10_000 - _bps)), 10_000);\n    }\n\n    function _divup(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a + b - 1) / b;\n    }\n}\n\n"
    },
    "src/MaseerImplementation.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Copyright (c) 2025 Maseer LTD\n//\n// This file is subject to the Business Source License 1.1.\n// You may not use this file except in compliance with the License.\n//\n// You may obtain a copy of the License at:\n// https://github.com/Maseer-LTD/maseer-one/blob/master/LICENSE\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\npragma solidity ^0.8.28;\n\nabstract contract MaseerImplementation {\n\n    bytes32 internal constant _WARD_SLOT = keccak256(\"maseer.wards\");\n\n    error NotAuthorized(address usr);\n    error UnrecognizedParam(bytes32 param);\n\n    struct StringData {\n        string val;\n    }\n\n    modifier auth() {\n        if (uint256(_getVal(keccak256(abi.encode(_WARD_SLOT, msg.sender)))) != 1) revert NotAuthorized(msg.sender);\n        _;\n    }\n\n    function rely(address usr) external auth {\n        _rely(usr);\n    }\n\n    function deny(address usr) external auth {\n        _deny(usr);\n    }\n\n    function wards(address usr) external view returns (uint256) {\n        return uint256(_getVal(keccak256(abi.encode(_WARD_SLOT, usr))));\n    }\n\n    function _rely(address usr) internal {\n        _setVal(keccak256(abi.encode(_WARD_SLOT, usr)), bytes32(uint256(1)));\n    }\n\n    function _deny(address usr) internal {\n        _setVal(keccak256(abi.encode(_WARD_SLOT, usr)), bytes32(uint256(0)));\n    }\n\n    function _setVal(bytes32 slot, bytes32 val) internal {\n        assembly {\n            sstore(slot, val)\n        }\n    }\n\n    function _setVal(bytes32 slot, uint256 val) internal {\n        assembly {\n            sstore(slot, val)\n        }\n    }\n\n    function _setVal(bytes32 slot, address val) internal {\n        assembly {\n            sstore(slot, val)\n        }\n    }\n\n    function _setVal(bytes32 slot, bool val) internal {\n        assembly {\n            sstore(slot, val)\n        }\n    }\n\n    function _setVal(bytes32 slot, string memory val) internal {\n        StringData storage data;\n        assembly {\n            data.slot := slot\n        }\n        data.val = val;\n    }\n\n    function _getVal(bytes32 slot) internal view returns (bytes32 val) {\n        assembly {\n            val := sload(slot)\n        }\n    }\n\n    function _uint256Slot(bytes32 slot) internal view returns (uint256) {\n        return uint256(_getVal(slot));\n    }\n\n    function _addressSlot(bytes32 slot) internal view returns (address) {\n        return address(uint160(uint256(_getVal(slot))));\n    }\n\n    function _boolSlot(bytes32 slot) internal view returns (bool) {\n        return _getVal(slot) == bytes32(uint256(1)) ? true : false;\n    }\n\n    function _stringSlot(bytes32 slot) internal view returns (string memory) {\n        StringData storage data;\n        assembly {\n            data.slot := slot\n        }\n        return data.val;\n    }\n\n    function _b32toString(bytes32 _bytes32) internal pure returns (string memory) {\n        uint256 length = 0;\n        while (length < 32 && _bytes32[length] != 0) {\n            length++;\n        }\n\n        bytes memory bytesArray = new bytes(length);\n        for (uint256 i = 0; i < length; i++) {\n            bytesArray[i] = _bytes32[i];\n        }\n\n        return string(bytesArray);\n    }\n}\n"
    }
  },
  "settings": {
    "remappings": [
      "forge-std/=lib/forge-std/src/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 21000
    },
    "metadata": {
      "useLiteralContent": false,
      "bytecodeHash": "ipfs",
      "appendCBOR": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "evmVersion": "cancun",
    "viaIR": false,
    "libraries": {}
  }
}}