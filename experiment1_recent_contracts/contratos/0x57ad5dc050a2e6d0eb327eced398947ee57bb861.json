{{
  "language": "Solidity",
  "sources": {
    "contracts/EigenpieWithdrawManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.21;\n\nimport { UtilLib } from \"./utils/UtilLib.sol\";\nimport { EigenpieConstants } from \"./utils/EigenpieConstants.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { EigenpieConfigRoleChecker, IEigenpieConfig } from \"./utils/EigenpieConfigRoleChecker.sol\";\nimport { IMintableERC20 } from \"./interfaces/IMintableERC20.sol\";\nimport { INodeDelegator } from \"./interfaces/INodeDelegator.sol\";\nimport { IEigenpieStaking } from \"./interfaces/IEigenpieStaking.sol\";\nimport { IMLRT } from \"./interfaces/IMLRT.sol\";\nimport { IEigenpiePreDepositHelper } from \"./interfaces/IEigenpiePreDepositHelper.sol\";\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { PausableUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport { IEigenpieWithdrawManager } from \"./interfaces/IEigenpieWithdrawManager.sol\";\nimport { TransferHelper } from \"./utils/TransferHelper.sol\";\n\n/// @title EigenpieWithdrawManager - Withdraw Pool Contract for LSTs\n/// @notice Handles LST asset deposits\ncontract EigenpieWithdrawManager is\n    IEigenpieWithdrawManager,\n    EigenpieConfigRoleChecker,\n    PausableUpgradeable,\n    ReentrancyGuardUpgradeable\n{\n    using SafeERC20 for IERC20;\n\n    uint256 public lstWithdrawalDelay; // a buffer time period making sure user able to withdraw the LST unstake by\n        // Eigenpie\n    uint256 public startTimestamp; // the start timestamp counting epoch\n    uint256 public constant EPOCH_DURATION = 7 days;\n    uint256 public withdrawalscheduleCleanUp; // the threshold to clean up withdraw queue length\n\n    mapping(bytes32 => UserWithdrawalSchedule[]) public withdrawalSchedules; //bytes32 = user + asset\n    mapping(bytes32 => WithdrawalSum) public withdrawalSums; // aggregated withdrawal information // bytes32 = asset +\n        // epoch\n    //1st upgrade\n    /// @dev mapping of queued withdrawRequest, indexed by withdrawRequest hash\n    mapping(bytes32 => WithdrawQueueStatus) public withdrawQueued;\n    mapping(address => uint256[]) public userNonces;\n    mapping(uint256 => UserWithdrawalSchedule) public nonceToSchedule;\n\n    EthWithdrawQueue public ethWithdrawQueue;\n    uint256 public withdrawalBufferTarget; \n    uint256 public ethClaimReserve;\n    uint256 public withdrawRequestNonce;\n    //2nd upgrade\n    uint256 public epochTransitionTimestamp;\n\n    error InsufficientBalance();\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @dev Initializes the contract\n    /// @param eigenpieConfigAddr eigenpieConfig address\n    function initialize(\n        address eigenpieConfigAddr,\n        uint256 _lstWithdrawalDelay,\n        uint256 _startTimestamp\n    )\n        external\n        initializer\n    {\n        UtilLib.checkNonZeroAddress(eigenpieConfigAddr);\n\n        __Pausable_init();\n        __ReentrancyGuard_init();\n\n        eigenpieConfig = IEigenpieConfig(eigenpieConfigAddr);\n        lstWithdrawalDelay = _lstWithdrawalDelay;\n        startTimestamp = _startTimestamp;\n        withdrawalscheduleCleanUp = 5;\n\n        emit UpdatedEigenpieConfig(eigenpieConfigAddr);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            view functions\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Calculates the timestamp when a user can withdraw if they queue a withdrawal now\n     * @dev Takes into account epoch transitions and withdrawal delays:\n     *      - Before transition: Uses original 7-day EPOCH_DURATION\n     *      - After transition: Withdrawal delay increases to 2 epochs (14 days total) to align with EigenLayer's updated withdrawal period\n     * @return timestamp The timestamp when the withdrawal will be available\n     */\n    function nextUserWithdrawalTime() public view returns (uint256 timestamp) {\n        uint256 epoch = currentEpoch();\n        if (block.timestamp < epochTransitionTimestamp) {\n            // Before transition: calculate using original EPOCH_DURATION\n            return startTimestamp + epoch * EPOCH_DURATION + EPOCH_DURATION + lstWithdrawalDelay;\n        } else {\n            return startTimestamp + epoch * EPOCH_DURATION + 2 * EPOCH_DURATION + lstWithdrawalDelay;\n        }\n    }\n\n    /// @notice Gets the current epoch number\n    /// @dev Handles epoch calculation differently before and after the transition timestamp\n    /// @return The current epoch number\n    function currentEpoch() public view returns (uint256) {\n        return (block.timestamp - startTimestamp) / EPOCH_DURATION + 1;\n    }\n\n    function getUserQueuedWithdraw(\n        address _user,\n        address[] memory _assets\n    )\n        external\n        view\n        returns (uint256[] memory queuedAmounts, uint256[] memory claimableAmounts, uint256[] memory claimedAmounts)\n    {\n        return _calculateAmounts(_user, _assets);\n    }\n\n    function userToAssetKey(address _user, address _asset) public pure returns (bytes32) {\n        return _getKey(_user, _asset, 0, true);\n    }\n\n    function assetEpochKey(address _asset, uint256 _epochTime) public pure returns (bytes32) {\n        return _getKey(address(0), _asset, _epochTime, false);\n    }\n\n    function getUserWithdrawalSchedulesETH(address user)\n        external\n        view\n        returns (uint256[] memory nonces, UserWithdrawalSchedule[] memory schedules)\n    {\n        // Retrieve the user's nonces\n        uint256[] memory userNonceArray = userNonces[user];\n        uint256 length = userNonceArray.length;\n\n        // Create a schedules array of the same length\n        UserWithdrawalSchedule[] memory scheduleArray = new UserWithdrawalSchedule[](length);\n\n        // Populate the schedules array\n        for (uint256 i = 0; i < length; i++) {\n            uint256 nonce = userNonceArray[i];\n            scheduleArray[i] = nonceToSchedule[nonce];\n        }\n\n        return (userNonceArray, scheduleArray);\n    }\n\n    function getUserWithdrawalSchedules(\n        address user,\n        address[] memory assets\n    )\n        external\n        view\n        returns (uint256[][] memory queuedLstAmounts, uint256[][] memory endTimes)\n    {\n        queuedLstAmounts = new uint256[][](assets.length);\n        endTimes = new uint256[][](assets.length);\n\n        for (uint256 i = 0; i < assets.length; i++) {\n            bytes32 key = userToAssetKey(user, assets[i]);\n            UserWithdrawalSchedule[] memory schedules = withdrawalSchedules[key];\n\n            // Initialize arrays to store schedules for the current asset\n            uint256[] memory assetQueuedAmounts = new uint256[](schedules.length);\n            uint256[] memory assetEndTimes = new uint256[](schedules.length);\n\n            // Iterate through all schedules for the current asset\n            for (uint256 j = 0; j < schedules.length; j++) {\n                UserWithdrawalSchedule memory schedule = schedules[j];\n                assetQueuedAmounts[j] = schedule.queuedWithdrawLSTAmt;\n                assetEndTimes[j] = schedule.endTime;\n            }\n\n            // Assign arrays to the corresponding row in queuedAmounts and endTimes\n            queuedLstAmounts[i] = assetQueuedAmounts;\n            endTimes[i] = assetEndTimes;\n        }\n    }\n\n    /**\n     * @notice  returns available to withdraw for ETH\n     * @return  uint256  amount available to withdraw from buffer\n     */\n    function getAvailableToWithdraw() public view returns (uint256) {\n        return address(this).balance - ethClaimReserve;\n    }\n\n    /**\n     * @notice  returns empty withdraw buffer for eth\n     * @dev     returns 0 is buffer is full\n     * @return  uint256  amount of buffer to be filled\n     */\n    function getWithdrawDeficit() public view returns (uint256) {\n        uint256 availableToWithdraw = getAvailableToWithdraw();\n        uint256 bufferDeficit =\n            withdrawalBufferTarget > availableToWithdraw ? withdrawalBufferTarget - availableToWithdraw : 0;\n        // Only allow queueDeficit for ETH\n        uint256 queueDeficit = (ethWithdrawQueue.queuedWithdrawToFill > ethWithdrawQueue.queuedWithdrawFilled)\n            ? (ethWithdrawQueue.queuedWithdrawToFill - ethWithdrawQueue.queuedWithdrawFilled)\n            : 0;\n        return bufferDeficit + queueDeficit;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            Write functions\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @dev Allows a user to queue for withdrawal of a specific asset.\n     * @param asset The address of the asset to withdraw.\n     * @param mLRTamount The amount of the mLRT Token respective of LST token to withdraw.\n     */\n    function userQueuingForWithdraw(\n        address asset,\n        uint256 mLRTamount\n    )\n        external\n        whenNotPaused\n        nonReentrant\n        onlySupportedAsset(asset)\n    {\n        address receipt = eigenpieConfig.mLRTReceiptByAsset(asset);\n        uint256 userReceiptBal = IERC20(receipt).balanceOf(msg.sender);\n        if (mLRTamount > userReceiptBal) revert InvalidAmount();\n\n        uint256 epochCurr = currentEpoch();\n        bytes32 userToAsset = userToAssetKey(msg.sender, asset);\n        bytes32 assetToEpoch = assetEpochKey(asset, epochCurr);\n\n        uint256 rate = IMLRT(receipt).exchangeRateToLST();\n        uint256 withdrawLSTAmt = (rate * mLRTamount) / 1 ether;\n        uint256 userWithdrawableTime = nextUserWithdrawalTime();\n\n        UserWithdrawalSchedule memory schedule =\n            UserWithdrawalSchedule(mLRTamount, withdrawLSTAmt, 0, userWithdrawableTime);\n\n        if (asset == EigenpieConstants.PLATFORM_TOKEN_ADDRESS) {\n            uint256 availableToWithdraw = getAvailableToWithdraw();\n            withdrawRequestNonce++;\n            uint256 nonce = withdrawRequestNonce;\n\n            userNonces[msg.sender].push(nonce);\n            nonceToSchedule[nonce] = schedule;\n\n            if (withdrawLSTAmt > availableToWithdraw) {\n                // increase the claim reserve to partially fill withdrawRequest with max available in buffer\n                ethClaimReserve += availableToWithdraw;\n                // fill the queue with availableToWithdraw\n                ethWithdrawQueue.queuedWithdrawFilled += availableToWithdraw;\n                // update the queue to fill\n                ethWithdrawQueue.queuedWithdrawToFill += withdrawLSTAmt;\n                // calculate withdrawRequest hash\n                bytes32 withdrawHash = keccak256(abi.encode(nonce, msg.sender));\n\n                withdrawQueued[withdrawHash].queued = true;\n                withdrawQueued[withdrawHash].fillAt = ethWithdrawQueue.queuedWithdrawToFill;\n            } else {\n                // add redeem amount to claimReserve of claim asset\n                ethClaimReserve += withdrawLSTAmt;\n            }\n        } else {\n            WithdrawalSum storage withdrawalSum = withdrawalSums[assetToEpoch];\n            withdrawalSum.assetTotalToWithdrawAmt += withdrawLSTAmt;\n            withdrawalSum.mLRTTotalToBurn += mLRTamount;\n\n            withdrawalSchedules[userToAsset].push(schedule);\n        }\n\n        IERC20(receipt).safeTransferFrom(msg.sender, address(this), mLRTamount);\n\n        emit UserQueuingForWithdrawal(msg.sender, asset, mLRTamount, withdrawLSTAmt, epochCurr, userWithdrawableTime);\n    }\n\n    /**\n     * @notice Allows users to withdraw their assets after the withdrawal period\n     * @dev Current implementation as per no slashing mechanism\n     * TODO: When implementing slashing: Required to check for slashed shares before processing withdrawals and adjust withdrawal amounts accordingly\n     * @param assets Array of assets to withdraw\n     */\n    function userWithdrawAsset(address[] memory assets) external whenNotPaused nonReentrant {\n        uint256[] memory claimedWithdrawalSchedules = new uint256[](assets.length);\n\n        // check if there are no duplicate entries in input data\n        for (uint256 i = 0; i < assets.length; i++) {\n            for (uint256 j = i + 1; j < assets.length; j++) {\n                if (assets[i] == assets[j]) {\n                    revert InvalidInput();\n                }\n            }\n        }\n\n        for (uint256 i = 0; i < assets.length;) {\n            if (assets[i] == EigenpieConstants.PLATFORM_TOKEN_ADDRESS) revert PlatformTokenNotSupported();\n            bytes32 userToAsset = userToAssetKey(msg.sender, assets[i]);\n            UserWithdrawalSchedule[] storage schedules = withdrawalSchedules[userToAsset];\n\n            uint256 totalClaimedAmount;\n            uint256 claimedWithdrawalSchedulesPerAsset;\n\n            for (uint256 j = 0; j < schedules.length;) {\n                UserWithdrawalSchedule storage schedule = schedules[j];\n\n                // if claimmable\n                if (block.timestamp >= schedule.endTime && schedule.claimedAmt == 0) {\n                    claimedWithdrawalSchedulesPerAsset++;\n\n                    schedule.claimedAmt = schedule.queuedWithdrawLSTAmt;\n                    totalClaimedAmount += schedule.queuedWithdrawLSTAmt;\n                } else if (block.timestamp >= schedule.endTime && schedule.claimedAmt == schedule.queuedWithdrawLSTAmt)\n                {\n                    claimedWithdrawalSchedulesPerAsset++;\n                }\n\n                unchecked {\n                    ++j;\n                }\n            }\n\n            claimedWithdrawalSchedules[i] = claimedWithdrawalSchedulesPerAsset;\n            if (totalClaimedAmount > IERC20(assets[i]).balanceOf(address(this))) {\n                 revert InsufficientClaimableAmount();\n            } \n\n            if (totalClaimedAmount > 0) {\n                IERC20(assets[i]).safeTransfer(msg.sender, totalClaimedAmount);\n                emit AssetWithdrawn(msg.sender, assets[i], totalClaimedAmount);\n            }\n        \n            unchecked {\n                ++i;\n            }\n        }\n\n        _cleanUpWithdrawalSchedules(assets, claimedWithdrawalSchedules);\n    }\n\n    function userWithdrawETH(uint256 nonce) external whenNotPaused nonReentrant {\n        // Validate the nonce belongs to the user\n        uint256[] storage userNoncesArray = userNonces[msg.sender];\n        bool validNonce = false;\n        uint256 nonceIndex;\n\n        for (uint256 i = 0; i < userNoncesArray.length; i++) {\n            if (userNoncesArray[i] == nonce) {\n                validNonce = true;\n                nonceIndex = i;\n                break;\n            }\n        }\n\n        if (!validNonce) revert InvalidNonce();\n\n        // Fetch the schedule\n        UserWithdrawalSchedule storage schedule = nonceToSchedule[nonce];\n        if (block.timestamp < schedule.endTime) revert WithdrawalNotYetClaimable();\n\n        bytes32 withdrawHash = keccak256(abi.encode(nonce, msg.sender));\n        if (\n            withdrawQueued[withdrawHash].queued\n                && withdrawQueued[withdrawHash].fillAt > ethWithdrawQueue.queuedWithdrawFilled\n        ) revert QueuedWithdrawalNotFilled();\n\n        // Calculate withdrawal amount\n        uint256 withdrawAmount = schedule.queuedWithdrawLSTAmt;\n        ethClaimReserve -= withdrawAmount;\n\n        // Burn mLRT tokens\n        address receipt = eigenpieConfig.mLRTReceiptByAsset(EigenpieConstants.PLATFORM_TOKEN_ADDRESS);\n        IMintableERC20(receipt).burnFrom(address(this), schedule.receiptMLRTAmt);\n        TransferHelper.safeTransferETH(msg.sender, withdrawAmount);\n\n        // Clean up: Remove nonce and schedule\n        _removeNonceAndSchedule(msg.sender, nonceIndex, nonce);\n\n        emit ETHWithdrawn(msg.sender, nonce, withdrawAmount);\n    }\n\n    function _removeNonceAndSchedule(address user, uint256 index, uint256 nonce) internal {\n        uint256[] storage userNoncesArray = userNonces[user];\n        uint256 lastNonceIndex = userNoncesArray.length - 1;\n\n        if (index < lastNonceIndex) {\n            userNoncesArray[index] = userNoncesArray[lastNonceIndex];\n        }\n        userNoncesArray.pop();\n\n        delete nonceToSchedule[nonce];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            Admin functions\n    //////////////////////////////////////////////////////////////*/\n\n\n    function transferAssetToAdmin(address[] memory assets, uint256[] memory amounts) external onlyDefaultAdmin {\n        if(assets.length != amounts.length) revert LengthMismatch();\n        for (uint256 i = 0; i < assets.length; i++) {\n            if(IERC20(assets[i]).balanceOf(address(this)) < amounts[i]) revert InsufficientBalance();\n            IERC20(assets[i]).safeTransfer(msg.sender, amounts[i]);\n        }\n        emit AssetTransferredToAdmin(msg.sender, assets, amounts);\n    }\n\n    /**\n     * @notice  fill Eth WithdrawBuffer from node delegator deposits\n     * @dev     permissioned call (onlyNodeDelegator)\n     */\n    function fillEthWithdrawBuffer() external payable whenNotPaused nonReentrant onlyAllowedBot {\n        uint256 queueFilled = _checkAndFillEthWithdrawQueue(msg.value);\n        emit EthBufferFilled(msg.value - queueFilled);\n    }\n\n    /**\n     * @notice Admin function to queue withdrawals for aggregated user withdrawal requests\n     * @dev Current implementation as per no slashing mechanism\n     * TODO: When implementing slashing: Will remove the burn functionality from this function\n     * @param nodeDelegators Array of node delegator addresses\n     * @param nodeToAssets Array of arrays containing assets for each node delegator\n     * @param nodeToAmounts Array of arrays containing amounts for each node delegator\n     * @param epochNumber The epoch number for which to queue withdrawals\n     */\n    function queuingWithdraw(\n        address[] memory nodeDelegators,\n        address[][] memory nodeToAssets,\n        uint256[][] memory nodeToAmounts,\n        uint256 epochNumber\n    )\n        external\n        whenNotPaused\n        nonReentrant\n        onlyAllowedBot\n    {\n        if (nodeDelegators.length != nodeToAssets.length || nodeDelegators.length != nodeToAmounts.length) {\n            revert LengthMismatch();\n        }\n\n        for (uint256 i = 0; i < nodeDelegators.length;) {\n            if (nodeToAssets[i].length != nodeToAmounts[i].length) {\n                revert LengthMismatch();\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        if (epochNumber >= currentEpoch()) {\n            revert EpochNotYetReached();\n        }\n\n        for (uint256 i = 0; i < nodeDelegators.length;) {\n            uint256 assetsLength = nodeToAssets[i].length;\n\n            for (uint256 j = 0; j < assetsLength;) {\n                if (nodeToAssets[i][j] == EigenpieConstants.PLATFORM_TOKEN_ADDRESS) revert PlatformTokenNotSupported();\n                bytes32 assetToEpochKey = keccak256(abi.encodePacked(nodeToAssets[i][j], epochNumber));\n                WithdrawalSum storage withdrawalSum = withdrawalSums[assetToEpochKey];\n                withdrawalSum.assetTotalWithdrawQueued += nodeToAmounts[i][j];\n\n                unchecked {\n                    ++j;\n                }\n            }\n            INodeDelegator(nodeDelegators[i]).queueWithdrawalToEigenLayer(nodeToAssets[i], nodeToAmounts[i]);\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        address[] memory supportedAssets = eigenpieConfig.getSupportedAssetList();\n        for (uint256 i = 0; i < supportedAssets.length;) {\n            if (supportedAssets[i] != EigenpieConstants.PLATFORM_TOKEN_ADDRESS) {\n                bytes32 assetToEpochKey = keccak256(abi.encodePacked(supportedAssets[i], epochNumber));\n                WithdrawalSum storage withdrawalSum = withdrawalSums[assetToEpochKey];\n                if (withdrawalSum.assetTotalToWithdrawAmt != withdrawalSum.assetTotalWithdrawQueued) {\n                    revert NotWithdrawAllQueuedRequest();\n                }\n\n                withdrawalSum.mLRTburnt = true;\n\n                if (withdrawalSum.assetTotalWithdrawQueued > 0) {\n                    address receipt = eigenpieConfig.mLRTReceiptByAsset(supportedAssets[i]);\n                    IMintableERC20(receipt).burnFrom(address(this), withdrawalSum.mLRTTotalToBurn);\n                }\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @dev Triggers stopped state. Contract must not be paused.\n    function pause() external onlyPauser {\n        _pause();\n    }\n\n    /// @dev Returns to normal state. Contract must be paused\n    function unpause() external onlyDefaultAdmin {\n        _unpause();\n    }\n\n    function updateWithdrawalScheduleCleanUpThreshold(uint256 _newThreshold) external onlyDefaultAdmin {\n        require(_newThreshold > 0, \"New threshold must be greater than zero\");\n        withdrawalscheduleCleanUp = _newThreshold;\n        emit VestingWithdrawalCleanUpThresholdUpdated(_newThreshold);\n    }\n\n    /**\n     * @notice  Updates the WithdrawBufferTarget for max withdraw available\n     * @dev     Permissioned call\n     * @param   _newBufferTarget  new max buffer target available to withdraw\n     */\n    function updateWithdrawBufferTarget(uint256 _newBufferTarget) external onlyDefaultAdmin {\n        uint256 oldWithdrawalBufferTarget = withdrawalBufferTarget;\n        withdrawalBufferTarget = _newBufferTarget;\n        emit WithdrawBufferTargetUpdated(oldWithdrawalBufferTarget, _newBufferTarget);\n    }\n\n    function transferExcessETHToStaking(uint256 _amount) external onlyDefaultAdmin {\n        address eigenpieStaking = eigenpieConfig.getContract(EigenpieConstants.EIGENPIE_STAKING);\n        if(getAvailableToWithdraw() >= _amount){\n            TransferHelper.safeTransferETH(eigenpieStaking, _amount);\n            emit ExcessETHTransferredToStaking(_amount);\n        } else { revert InsufficientETH(); }\n    }\n\n    function setEpochTransitionTimestamp(uint256 _epochTransitionTimestamp) external onlyDefaultAdmin {\n        if ((_epochTransitionTimestamp - startTimestamp) % 7 days != 0) {\n            revert InvalidEpochTransitionTimestamp(); \n        }\n        epochTransitionTimestamp = _epochTransitionTimestamp;\n        emit EpochTransitionTimestampUpdated(_epochTransitionTimestamp);    \n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            Internal functions\n    //////////////////////////////////////////////////////////////*/\n\n    function _cleanUpWithdrawalSchedules(\n        address[] memory assets,\n        uint256[] memory claimedWithdrawalSchedules\n    )\n        internal\n    {\n        for (uint256 i = 0; i < assets.length;) {\n            bytes32 userToAsset = userToAssetKey(msg.sender, assets[i]);\n            UserWithdrawalSchedule[] storage schedules = withdrawalSchedules[userToAsset];\n\n            if (claimedWithdrawalSchedules[i] >= withdrawalscheduleCleanUp) {\n                for (uint256 j = 0; j < schedules.length - claimedWithdrawalSchedules[i];) {\n                    schedules[j] = schedules[j + claimedWithdrawalSchedules[i]];\n\n                    unchecked {\n                        ++j;\n                    }\n                }\n\n                while (claimedWithdrawalSchedules[i] > 0) {\n                    schedules.pop();\n                    claimedWithdrawalSchedules[i]--;\n                }\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function _calculateAmounts(\n        address _user,\n        address[] memory _assets\n    )\n        internal\n        view\n        returns (uint256[] memory queuedAmounts, uint256[] memory claimableAmounts, uint256[] memory claimedAmounts)\n    {\n        queuedAmounts = new uint256[](_assets.length);\n        claimableAmounts = new uint256[](_assets.length);\n        claimedAmounts = new uint256[](_assets.length);\n\n        for (uint256 i = 0; i < _assets.length;) {\n            bytes32 key = userToAssetKey(_user, _assets[i]);\n            uint256 totalAmount = 0;\n            uint256 totalClaimed = 0;\n            uint256 totalClaimable = 0;\n\n            UserWithdrawalSchedule[] memory schedules = withdrawalSchedules[key];\n            for (uint256 j = 0; j < schedules.length;) {\n                UserWithdrawalSchedule memory schedule = schedules[j];\n                bool claimable = (schedule.endTime <= block.timestamp) && schedule.claimedAmt == 0;\n                if (claimable) totalClaimable += schedule.queuedWithdrawLSTAmt;\n                totalAmount += schedule.queuedWithdrawLSTAmt;\n                totalClaimed += schedule.claimedAmt;\n\n                unchecked {\n                    ++j;\n                }\n            }\n\n            queuedAmounts[i] = totalAmount;\n            claimableAmounts[i] = totalClaimable;\n            claimedAmounts[i] = totalClaimed;\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        return (queuedAmounts, claimableAmounts, claimedAmounts);\n    }\n\n    function _getKey(address _user, address _asset, uint256 _epochTime, bool _isUser) internal pure returns (bytes32) {\n        if (_isUser) {\n            return keccak256(abi.encodePacked(_user, _asset));\n        } else {\n            return keccak256(abi.encodePacked(_asset, _epochTime));\n        }\n    }\n\n    function _checkAndFillEthWithdrawQueue(uint256 amount) internal returns (uint256) {\n        uint256 queueDeficit = (ethWithdrawQueue.queuedWithdrawToFill > ethWithdrawQueue.queuedWithdrawFilled)\n            ? (ethWithdrawQueue.queuedWithdrawToFill - ethWithdrawQueue.queuedWithdrawFilled)\n            : 0;\n        uint256 queueFilled = 0;\n        if (queueDeficit > 0) {\n            queueFilled = queueDeficit > amount ? amount : queueDeficit;\n\n            // Increase claimReserve\n            ethClaimReserve += queueFilled;\n\n            // Increase the queueFilled\n            ethWithdrawQueue.queuedWithdrawFilled += queueFilled;\n\n            emit QueueFilledForETH(queueFilled);\n        }\n        return queueFilled;\n    }\n}\n"
    },
    "contracts/utils/UtilLib.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.21;\n\nimport { EigenpieConstants } from \"./EigenpieConstants.sol\";\n\n/// @title UtilLib - Utility library\n/// @notice Utility functions\nlibrary UtilLib {\n    error ZeroAddressNotAllowed();\n\n    /// @dev zero address check modifier\n    /// @param address_ address to check\n    function checkNonZeroAddress(address address_) internal pure {\n        if (address_ == address(0)) revert ZeroAddressNotAllowed();\n    }\n\n    function isNativeToken(address addr) internal pure returns (bool) {\n        return addr == EigenpieConstants.PLATFORM_TOKEN_ADDRESS;\n    }\n}\n"
    },
    "contracts/utils/EigenpieConstants.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.21;\n\nlibrary EigenpieConstants {\n    //contracts\n    bytes32 public constant EIGENPIE_STAKING = keccak256(\"EIGENPIE_STAKING\");\n    bytes32 public constant EIGEN_STRATEGY_MANAGER = keccak256(\"EIGEN_STRATEGY_MANAGER\");\n    bytes32 public constant EIGEN_DELEGATION_MANAGER = keccak256(\"EIGEN_DELEGATION_MANAGER\");\n    bytes32 public constant PRICE_PROVIDER = keccak256(\"PRICE_PROVIDER\");\n    bytes32 public constant BEACON_DEPOSIT = keccak256(\"BEACON_DEPOSIT\");\n    bytes32 public constant EIGENPOD_MANAGER = keccak256(\"EIGENPOD_MANAGER\");\n    bytes32 public constant EIGENPIE_PREDEPOSITHELPER = keccak256(\"EIGENPIE_PREDEPOSITHELPER\");\n    bytes32 public constant EIGENPIE_REWADR_DISTRIBUTOR = keccak256(\"EIGENPIE_REWADR_DISTRIBUTOR\");\n    bytes32 public constant EIGENPIE_DWR = keccak256(\"EIGENPIE_DWR\");\n    bytes32 public constant MLRT_ADAPTER = keccak256(\"MLRT_ADAPTER\");\n    bytes32 public constant CCIP_BRIDGE = keccak256(\"CCIP_BRIDGE\");\n\n    bytes32 public constant SSVNETWORK_ENTRY = keccak256(\"SSVNETWORK_ENTRY\");\n    bytes32 public constant SSV_TOKEN = keccak256(\"SSV_TOKEN\");\n    bytes32 public constant REWARD_COORDINATOR = keccak256(\"REWARD_COORDINATOR\");\n    bytes32 public constant VAULT_LRT_SQUARED = keccak256(\"VAULT_LRT_SQUARED\");\n\n    //Roles\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n    bytes32 public constant MANAGER = keccak256(\"MANAGER\");\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n    bytes32 public constant BURNER_ROLE = keccak256(\"BURNER_ROLE\");\n    bytes32 public constant EGP_MINTER_ROLE = keccak256(\"EGP_MINTER_ROLE\");\n    bytes32 public constant EGP_BURNER_ROLE = keccak256(\"EGP_BURNER_ROLE\");\n    bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n\n    bytes32 public constant ORACLE_ROLE = keccak256(\"ORACLE_ROLE\");\n    bytes32 public constant ORACLE_ADMIN_ROLE = keccak256(\"ORACLE_ADMIN_ROLE\");\n    bytes32 public constant PRICE_PROVIDER_ROLE = keccak256(\"PRICE_PROVIDER_ROLE\");\n\n    bytes32 public constant ALLOWED_BOT_ROLE = keccak256(\"ALLOWED_BOT_ROLE\");\n\n    // For Native Restaking\n    uint256 constant PUBKEY_LENGTH = 48;\n    uint256 constant SIGNATURE_LENGTH = 96;\n    uint256 constant MAX_VALIDATORS = 100;\n    uint256 constant DEPOSIT_AMOUNT = 32 ether;\n    uint256 constant GWEI_TO_WEI = 1e9;\n\n    // For layerzero bridging\n    uint32 constant LZ_ZIRCUIT_DESTINATION_ID = 30_303;\n    uint32 constant LZ_ETHEREUM_DESTINATION_ID = 30_101;\n    uint32 constant LZ_HEMI_DESTINATION_ID = 30_329;\n\n    // For CCIP bridging\n    uint64 constant CCIP_ZIRCUIT_CHAIN_ID = 17_198_166_215_261_833_993;\n    uint64 constant CCIP_ETH_CHAIN_ID = 5_009_297_550_715_157_269;\n\n    uint256 public constant DENOMINATOR = 10_000;\n    address public constant PLATFORM_TOKEN_ADDRESS = 0xeFEfeFEfeFeFEFEFEfefeFeFefEfEfEfeFEFEFEf;\n    bytes32 public constant EIGENPIE_WITHDRAW_MANAGER = keccak256(\"EIGENPIE_WITHDRAW_MANAGER\");\n\n    // External Defi\n    bytes32 public constant ZIRCUIT_ZSTAKIGPOOL = keccak256(\"ZIRCUIT_ZSTAKIGPOOL\");\n    bytes32 public constant SWELL_SIMPLE_STAKING = keccak256(\"SWELL_SIMPLE_STAKING\");\n    bytes32 public constant ZSTAKIGPOOL_ZIRCUIT_CHAIN = keccak256(\"ZSTAKIGPOOL_ZIRCUIT_CHAIN\");\n    bytes32 public constant HSTAKIGPOOL_HEMI_CHAIN = keccak256(\"HSTAKIGPOOL_HEMI_CHAIN\");\n\n    bytes public constant BeaconProxyBytecode =\n        hex\"608060405260405161090e38038061090e83398101604081905261002291610460565b61002e82826000610035565b505061058a565b61003e83610100565b6040516001600160a01b038416907f1cf3b03a6cf19fa2baba4df148e9dcabedea7f8a5c07840e207e5c089be95d3e90600090a260008251118061007f5750805b156100fb576100f9836001600160a01b0316635c60da1b6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156100c5573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906100e99190610520565b836102a360201b6100291760201c565b505b505050565b610113816102cf60201b6100551760201c565b6101725760405162461bcd60e51b815260206004820152602560248201527f455243313936373a206e657720626561636f6e206973206e6f74206120636f6e6044820152641d1c9858dd60da1b60648201526084015b60405180910390fd5b6101e6816001600160a01b0316635c60da1b6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156101b3573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101d79190610520565b6102cf60201b6100551760201c565b61024b5760405162461bcd60e51b815260206004820152603060248201527f455243313936373a20626561636f6e20696d706c656d656e746174696f6e206960448201526f1cc81b9bdd08184818dbdb9d1c9858dd60821b6064820152608401610169565b806102827fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d5060001b6102de60201b6100641760201c565b80546001600160a01b0319166001600160a01b039290921691909117905550565b60606102c883836040518060600160405280602781526020016108e7602791396102e1565b9392505050565b6001600160a01b03163b151590565b90565b6060600080856001600160a01b0316856040516102fe919061053b565b600060405180830381855af49150503d8060008114610339576040519150601f19603f3d011682016040523d82523d6000602084013e61033e565b606091505b5090925090506103508683838761035a565b9695505050505050565b606083156103c65782516103bf576001600160a01b0385163b6103bf5760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e74726163740000006044820152606401610169565b50816103d0565b6103d083836103d8565b949350505050565b8151156103e85781518083602001fd5b8060405162461bcd60e51b81526004016101699190610557565b80516001600160a01b038116811461041957600080fd5b919050565b634e487b7160e01b600052604160045260246000fd5b60005b8381101561044f578181015183820152602001610437565b838111156100f95750506000910152565b6000806040838503121561047357600080fd5b61047c83610402565b60208401519092506001600160401b038082111561049957600080fd5b818501915085601f8301126104ad57600080fd5b8151818111156104bf576104bf61041e565b604051601f8201601f19908116603f011681019083821181831017156104e7576104e761041e565b8160405282815288602084870101111561050057600080fd5b610511836020830160208801610434565b80955050505050509250929050565b60006020828403121561053257600080fd5b6102c882610402565b6000825161054d818460208701610434565b9190910192915050565b6020815260008251806020840152610576816040850160208701610434565b601f01601f19169190910160400192915050565b61034e806105996000396000f3fe60806040523661001357610011610017565b005b6100115b610027610022610067565b610100565b565b606061004e83836040518060600160405280602781526020016102f260279139610124565b9392505050565b6001600160a01b03163b151590565b90565b600061009a7fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50546001600160a01b031690565b6001600160a01b0316635c60da1b6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156100d7573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906100fb9190610249565b905090565b3660008037600080366000845af43d6000803e80801561011f573d6000f35b3d6000fd5b6060600080856001600160a01b03168560405161014191906102a2565b600060405180830381855af49150503d806000811461017c576040519150601f19603f3d011682016040523d82523d6000602084013e610181565b606091505b50915091506101928683838761019c565b9695505050505050565b6060831561020d578251610206576001600160a01b0385163b6102065760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e747261637400000060448201526064015b60405180910390fd5b5081610217565b610217838361021f565b949350505050565b81511561022f5781518083602001fd5b8060405162461bcd60e51b81526004016101fd91906102be565b60006020828403121561025b57600080fd5b81516001600160a01b038116811461004e57600080fd5b60005b8381101561028d578181015183820152602001610275565b8381111561029c576000848401525b50505050565b600082516102b4818460208701610272565b9190910192915050565b60208152600082518060208401526102dd816040850160208701610272565b601f01601f1916919091016040019291505056fe416464726573733a206c6f772d6c6576656c2064656c65676174652063616c6c206661696c6564a2646970667358221220d51e81d3bc5ed20a26aeb05dce7e825c503b2061aa78628027300c8d65b9d89a64736f6c634300080c0033416464726573733a206c6f772d6c6576656c2064656c65676174652063616c6c206661696c6564\";\n\n    bytes32 public constant bEIGEN = keccak256(\"bEIGEN\");\n    bytes32 public constant ETHProcessor = keccak256(\"ETHProcessor\");\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }\n}\n"
    },
    "contracts/utils/EigenpieConfigRoleChecker.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.21;\n\nimport { UtilLib } from \"./UtilLib.sol\";\nimport { EigenpieConstants } from \"./EigenpieConstants.sol\";\n\nimport { IEigenpieConfig } from \"../interfaces/IEigenpieConfig.sol\";\n\nimport { IAccessControl } from \"@openzeppelin/contracts/access/IAccessControl.sol\";\n\n/// @title EigenpieConfigRoleChecker - Eigenpie Config Role Checker Contract\n/// @notice Handles Eigenpie config role checks\nabstract contract EigenpieConfigRoleChecker {\n    IEigenpieConfig public eigenpieConfig;\n\n    uint256[49] private __gap; // reserve for upgrade\n\n    // events\n    event UpdatedEigenpieConfig(address indexed eigenpieConfig);\n\n    // modifiers\n    modifier onlyRole(bytes32 role) {\n        if (!IAccessControl(address(eigenpieConfig)).hasRole(role, msg.sender)) {\n            string memory roleStr = string(abi.encodePacked(role));\n            revert IEigenpieConfig.CallerNotEigenpieConfigAllowedRole(roleStr);\n        }\n        _;\n    }\n\n    modifier onlyEigenpieManager() {\n        if (!IAccessControl(address(eigenpieConfig)).hasRole(EigenpieConstants.MANAGER, msg.sender)) {\n            revert IEigenpieConfig.CallerNotEigenpieConfigManager();\n        }\n        _;\n    }\n\n    modifier onlyPriceProvider() {\n        if (!IAccessControl(address(eigenpieConfig)).hasRole(EigenpieConstants.PRICE_PROVIDER_ROLE, msg.sender)) {\n            revert IEigenpieConfig.CallerNotEigenpieConfigPriceProvider();\n        }\n        _;\n    }\n\n    modifier onlyDefaultAdmin() {\n        if (!IAccessControl(address(eigenpieConfig)).hasRole(EigenpieConstants.DEFAULT_ADMIN_ROLE, msg.sender)) {\n            revert IEigenpieConfig.CallerNotEigenpieConfigAdmin();\n        }\n        _;\n    }\n\n    modifier onlyOracleAdmin() {\n        if (!IAccessControl(address(eigenpieConfig)).hasRole(EigenpieConstants.ORACLE_ADMIN_ROLE, msg.sender)) {\n            revert IEigenpieConfig.CallerNotEigenpieConfigOracleAdmin();\n        }\n        _;\n    }\n\n    modifier onlyOracle() {\n        if (!IAccessControl(address(eigenpieConfig)).hasRole(EigenpieConstants.ORACLE_ROLE, msg.sender)) {\n            revert IEigenpieConfig.CallerNotEigenpieConfigOracle();\n        }\n        _;\n    }\n\n    modifier onlyMinter() {\n        if (!IAccessControl(address(eigenpieConfig)).hasRole(EigenpieConstants.MINTER_ROLE, msg.sender)) {\n            revert IEigenpieConfig.CallerNotEigenpieConfigMinter();\n        }\n        _;\n    }\n\n    modifier onlyEGPMinter() {\n        if (!IAccessControl(address(eigenpieConfig)).hasRole(EigenpieConstants.EGP_MINTER_ROLE, msg.sender)) {\n            revert IEigenpieConfig.CallerNotEigenpieConfigMinter();\n        }\n        _;\n    }\n\n    modifier onlyBurner() {\n        if (!IAccessControl(address(eigenpieConfig)).hasRole(EigenpieConstants.BURNER_ROLE, msg.sender)) {\n            revert IEigenpieConfig.CallerNotEigenpieConfigBurner();\n        }\n        _;\n    }\n\n    modifier onlyEGPBurner() {\n        if (!IAccessControl(address(eigenpieConfig)).hasRole(EigenpieConstants.EGP_BURNER_ROLE, msg.sender)) {\n            revert IEigenpieConfig.CallerNotEigenpieConfigBurner();\n        }\n        _;\n    }\n\n    modifier onlyPauser() {\n        if (!IAccessControl(address(eigenpieConfig)).hasRole(EigenpieConstants.PAUSER_ROLE, msg.sender)) {\n            revert IEigenpieConfig.CallerNotEigenpiePauser();\n        }\n        _;\n    }\n\n    modifier onlySupportedAsset(address asset) {\n        if (!eigenpieConfig.isSupportedAsset(asset)) {\n            revert IEigenpieConfig.AssetNotSupported();\n        }\n        _;\n    }\n\n    modifier onlyAllowedBot() {\n        if (!IAccessControl(address(eigenpieConfig)).hasRole(EigenpieConstants.ALLOWED_BOT_ROLE, msg.sender)) {\n            revert IEigenpieConfig.CallerNotEigenpieConfigAllowedBot();\n        }\n        _;\n    }\n\n    // setters\n\n    /// @notice Updates the Eigenpie config contract\n    /// @dev only callable by Eigenpie default\n    /// @param eigenpieConfigAddr the new Eigenpie config contract Address\n    function updateEigenpieConfig(address eigenpieConfigAddr) external virtual onlyDefaultAdmin {\n        UtilLib.checkNonZeroAddress(eigenpieConfigAddr);\n        eigenpieConfig = IEigenpieConfig(eigenpieConfigAddr);\n        emit UpdatedEigenpieConfig(eigenpieConfigAddr);\n    }\n}\n"
    },
    "contracts/interfaces/IMintableERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\n\npragma solidity 0.8.21;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IMintableERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    function mint(address, uint256) external;\n\n    function faucet(uint256) external;\n\n    function burnFrom(address account, uint256 amount) external;\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/interfaces/INodeDelegator.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.21;\n\nimport \"./eigenlayer/IStrategy.sol\";\nimport \"./ssvNetwork/ISSVNetworkCore.sol\";\n\ninterface INodeDelegator {\n    // struct\n    struct DepositData {\n        bytes[] publicKeys;\n        bytes[] signatures;\n        bytes32[] depositDataRoots;\n    }\n\n    struct SSVPayload {\n        uint64[] operatorIds;\n        bytes[] sharesData;\n        uint256 amount;\n        ISSVNetworkCore.Cluster cluster;\n    }\n\n    // event\n    event AssetDepositIntoStrategy(address indexed asset, address indexed strategy, uint256 depositAmount);\n    event EigenPodCreated(address indexed createdEigenPod);\n    event RewardsForwarded(address indexed destinatino, uint256 amount);\n    event WithdrawalQueuedToEigenLayer(\n        bytes32[] withdrawalRoot,\n        IStrategy[] strategies,\n        address[] assets,\n        uint256[] withdrawalAmounts,\n        uint256 startBlock\n    );\n    event DelegationAddressUpdated(address delegate);\n    event GasSpent(address indexed spender, uint256 gasUsed);\n    event GasRefunded(address indexed receiver, uint256 gasRefund);\n    event NewProofSubmitter(address indexed oldProofSubmitter, address indexed _newProofSubmitter);\n    event AVSRewardClaimerUpdated(address indexed _prevClaimer, address indexed _newClaimer);\n\n    // errors\n    error TokenTransferFailed();\n    error StrategyIsNotSetForAsset();\n    error NoPubKeysProvided();\n    error EigenPodExisted();\n    error EigenPodDoesNotExist();\n    error InvalidCall();\n    error InvalidCaller();\n    error AtLeastOneValidator();\n    error MaxValidatorsInput();\n    error PublicKeyNotMatch();\n    error SignaturesNotMatch();\n    error DelegateAddressAlreadySet();\n    error InvalidAmount();\n    event BufferFilled(uint256 amount);\n    // methods\n    function depositAssetIntoStrategy(address asset) external;\n\n    function maxApproveToEigenStrategyManager(address asset) external;\n\n    function getAssetBalances() external view returns (address[] memory, uint256[] memory);\n\n    function getAssetBalance(address asset) external view returns (uint256);\n\n    function getEthBalance() external view returns (uint256);\n\n    function createEigenPod() external;\n\n    function queueWithdrawalToEigenLayer(address[] memory assets, uint256[] memory amount) external;\n}\n"
    },
    "contracts/interfaces/IEigenpieStaking.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.21;\n\ninterface IEigenpieStaking {\n    //errors\n    error TokenTransferFailed();\n    error InvalidAmountToDeposit();\n    error NotEnoughAssetToTransfer();\n    error MaximumDepositLimitReached();\n    error MaximumNodeDelegatorLimitReached();\n    error InvalidMaximumNodeDelegatorLimit();\n    error MinimumAmountToReceiveNotMet();\n    error InvalidIndex();\n    error NativeTokenTransferFailed();\n    error InvalidCaller();\n    error LengthMismatch();\n    error OnlyWhenPredeposit();\n    error IncorrectAssetForNativeToken();\n    error InvalidCycle();\n    error ETHProcessorNotSet();\n\n    //events\n    event MaxNodeDelegatorLimitUpdated(uint256 maxNodeDelegatorLimit);\n    event NodeDelegatorAddedinQueue(address[] nodeDelegatorContracts);\n    event AssetDeposit(\n        address indexed depositor,\n        address indexed asset,\n        uint256 depositAmount,\n        address indexed referral,\n        uint256 mintedAmount,\n        bool isPreDepsoit\n    );\n\n    event MinAmountToDepositUpdated(uint256 minAmountToDeposit);\n    event PreDepositHelperChanged(address oldPreDepositHelper, address newPreDepositHelper);\n    event PreDepositStatusChanged(bool newIsPreDeposit);\n\n    struct PoolInfo {\n        address mlrtReceipt;\n    }\n\n    function depositAsset(address asset, uint256 depositAmount, uint256 minRec, address referral) external payable;\n\n    function getTotalAssetDeposits(address asset) external view returns (uint256);\n\n    function getAssetCurrentLimit(address asset) external view returns (uint256);\n\n    function addNodeDelegatorContractToQueue(address[] calldata nodeDelegatorContract) external;\n\n    function transferAssetToNodeDelegator(uint256 ndcIndex, address asset, uint256 amount) external;\n\n    function updateMaxNodeDelegatorLimit(uint256 maxNodeDelegatorLimit) external;\n\n    function getNodeDelegatorQueue() external view returns (address[] memory);\n\n    function getAssetDistributionData(address asset)\n        external\n        view\n        returns (\n            uint256 assetLyingInDepositPool,\n            uint256 assetLyingInNDCs,\n            uint256 assetStakedInEigenLayer,\n            uint256 assetLyingInEWD\n        );\n}\n"
    },
    "contracts/interfaces/IMLRT.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.21;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IMLRT is IERC20 {\n    function updateExchangeRateToLST(uint256 _newRate) external;\n\n    function exchangeRateToLST() external view returns (uint256);\n\n    function underlyingAsset() external view returns (address);\n\n    function mint(address to, uint256 amount) external;\n\n    function burnFrom(address account, uint256 amount) external;\n}\n"
    },
    "contracts/interfaces/IEigenpiePreDepositHelper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.21;\n\ninterface IEigenpiePreDepositHelper {\n    function feedUserDeposit(address user, address asset, uint256 mintedAmount) external;\n    function withdraw(uint256 _cycle, address _user, address _asset, address _receipt, uint256 _mlrtAmount) external;\n\n    function claimableCycles(uint256 cycle) external returns (bool isClaimmable);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "lib/openzeppelin-contracts-upgradeable/contracts/security/PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "lib/openzeppelin-contracts-upgradeable/contracts/security/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "contracts/interfaces/IEigenpieWithdrawManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.21;\n\nimport { IDelegationManager } from \"./eigenlayer/IDelegationManager.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/interfaces/IERC20.sol\";\n\ninterface IEigenpieWithdrawManager {\n    struct UserWithdrawalSchedule {\n        uint256 receiptMLRTAmt;\n        uint256 queuedWithdrawLSTAmt;\n        uint256 claimedAmt;\n        uint256 endTime;\n    }\n\n    struct WithdrawalSum {\n        uint256 assetTotalToWithdrawAmt;\n        uint256 assetTotalWithdrawQueued;\n        uint256 mLRTTotalToBurn;\n        bool mLRTburnt;\n    }\n\n    struct EthWithdrawQueue {\n        uint256 queuedWithdrawToFill;\n        uint256 queuedWithdrawFilled;\n    }\n\n    /// @dev Struct for WithdrawRequest queue status with expected to be filled\n    struct WithdrawQueueStatus {\n        bool queued;\n        uint256 fillAt;\n    }\n\n    //errors\n    error InvalidAmount();\n    error LengthMismatch();\n    error EpochNotYetReached();\n    error NotWithdrawAllQueuedRequest();\n    error NativeWithdrawNotSupported();\n    error QueuedWithdrawalNotFilled();\n    error InvalidInput();\n    error WithdrawalNotYetClaimable();\n    error InvalidNonce();\n    error PlatformTokenNotSupported();\n    error InsufficientETH();\n    error InvalidEpochTransitionTimestamp();\n    error InsufficientClaimableAmount();\n    //events\n\n    event UserQueuingForWithdrawal(\n        address indexed user,\n        address indexed asset,\n        uint256 mLRTAmount,\n        uint256 LSTAmt,\n        uint256 currentEpoch,\n        uint256 endTime\n    );\n    event ETHWithdrawn(address indexed user, uint256 nonce, uint256 ethAmt);\n\n    event WithdrawBufferTargetUpdated(uint256 oldBufferTarget, uint256 newBufferTarget);\n    event EthBufferFilled(uint256 amount);\n    event QueueFilledForETH(uint256 amount);\n\n    event AssetWithdrawn(address indexed user, address indexed asset, uint256 LSTAmt);\n    event EpochUpdated(uint256 newEpochTime);\n    event VestingWithdrawalCleanUpThresholdUpdated(uint256 newThreshold);\n    event ExcessETHTransferredToStaking(uint256 amount);\n    event EpochTransitionTimestampUpdated(uint256 epochTransitionTimestamp);\n    event AssetTransferredToAdmin(address indexed admin, address[] assets, uint256[] amounts);\n    \n    function getWithdrawDeficit() external returns (uint256 bufferToFill);\n    function fillEthWithdrawBuffer() external payable;\n}\n"
    },
    "contracts/utils/TransferHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.21;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./UtilLib.sol\";\n\nlibrary TransferHelper {\n    using UtilLib for address;\n\n    function safeTransferToken(address token, address to, uint256 value) internal {\n        if (token.isNativeToken()) {\n            safeTransferETH(to, value);\n        } else {\n            safeTransfer(IERC20(token), to, value);\n        }\n    }\n\n    function safeTransferETH(address to, uint256 value) internal {\n        (bool success,) = address(to).call{ value: value }(\"\");\n        require(success, \"TransferHelper: Sending ETH failed\");\n    }\n\n    function balanceOf(address token, address addr) internal view returns (uint256) {\n        if (token.isNativeToken()) {\n            return addr.balance;\n        } else {\n            return IERC20(token).balanceOf(addr);\n        }\n    }\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)'))) -> 0xa9059cbb\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))), \"TransferHelper::safeTransfer: transfer failed\"\n        );\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)'))) -> 0x23b872dd\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            \"TransferHelper::safeTransferFrom: transfer failed\"\n        );\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IEigenpieConfig.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.21;\n\ninterface IEigenpieConfig {\n    // Errors\n    error ValueAlreadyInUse();\n    error AssetAlreadySupported();\n    error AssetNotSupported();\n    error CallerNotEigenpieConfigAdmin();\n    error CallerNotEigenpieConfigManager();\n    error CallerNotEigenpieConfigOracle();\n    error CallerNotEigenpieConfigOracleAdmin();\n    error CallerNotEigenpieConfigPriceProvider();\n    error CallerNotEigenpieConfigMinter();\n    error CallerNotEigenpieConfigBurner();\n    error CallerNotEigenpiePauser();\n    error CallerNotEigenpieConfigAllowedRole(string role);\n    error CallerNotEigenpieConfigAllowedBot();\n    error ContractNotConfigured();\n    // Events\n    event SetContract(bytes32 key, address indexed contractAddr);\n    event AddedNewSupportedAsset(address indexed asset, address indexed receipt, uint256 depositLimit);\n    event ReceiptTokenUpdated(address indexed asset, address indexed receipt);\n    event RemovedSupportedAsset(address indexed asset);\n    event AssetDepositLimitUpdate(address indexed asset, uint256 depositLimit);\n    event AssetStrategyUpdate(address indexed asset, address indexed strategy);\n    event AssetBoostUpdate(address indexed asset, uint256 newBoost);\n    event ReferralUpdate(address indexed me, address indexed myReferral);\n    event MLRTBridgeUpdated(address indexed receipt, address indexed mlrtBridge);\n    event BaseGasAmountSpentUpdated(uint256 newBaseGasAmountSpent);\n\n    // methods\n    function baseGasAmountSpent() external returns (uint256);\n\n    function assetStrategy(address asset) external view returns (address);\n\n    function boostByAsset(address) external view returns (uint256);\n\n    function mLRTReceiptByAsset(address) external view returns (address);\n\n    function isSupportedAsset(address asset) external view returns (bool);\n\n    function getContract(bytes32 contractId) external view returns (address);\n\n    function getSupportedAssetList() external view returns (address[] memory);\n\n    function depositLimitByAsset(address asset) external view returns (uint256);\n\n    function getMLRTBridgeByReceipt(address receipt) external view returns (address);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "contracts/interfaces/eigenlayer/IStrategy.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title Minimal interface for an `Strategy` contract.\n * @author Layr Labs, Inc.\n * @notice Terms of Service: https://docs.eigenlayer.xyz/overview/terms-of-service\n * @notice Custom `Strategy` implementations may expand extensively on this interface.\n */\ninterface IStrategy {\n    /**\n     * @notice Used to deposit tokens into this Strategy\n     * @param token is the ERC20 token being deposited\n     * @param amount is the amount of token being deposited\n     * @dev This function is only callable by the strategyManager contract. It is invoked inside of the\n     * strategyManager's\n     * `depositIntoStrategy` function, and individual share balances are recorded in the strategyManager as well.\n     * @return newShares is the number of new shares issued at the current exchange ratio.\n     */\n    function deposit(IERC20 token, uint256 amount) external returns (uint256);\n\n    /**\n     * @notice Used to withdraw tokens from this Strategy, to the `recipient`'s address\n     * @param recipient is the address to receive the withdrawn funds\n     * @param token is the ERC20 token being transferred out\n     * @param amountShares is the amount of shares being withdrawn\n     * @dev This function is only callable by the strategyManager contract. It is invoked inside of the\n     * strategyManager's\n     * other functions, and individual share balances are recorded in the strategyManager as well.\n     */\n    function withdraw(address recipient, IERC20 token, uint256 amountShares) external;\n\n    /**\n     * @notice Used to convert a number of shares to the equivalent amount of underlying tokens for this strategy.\n     * @notice In contrast to `sharesToUnderlyingView`, this function **may** make state modifications\n     * @param amountShares is the amount of shares to calculate its conversion into the underlying token\n     * @return The amount of underlying tokens corresponding to the input `amountShares`\n     * @dev Implementation for these functions in particular may vary significantly for different strategies\n     */\n    function sharesToUnderlying(uint256 amountShares) external returns (uint256);\n\n    /**\n     * @notice Used to convert an amount of underlying tokens to the equivalent amount of shares in this strategy.\n     * @notice In contrast to `underlyingToSharesView`, this function **may** make state modifications\n     * @param amountUnderlying is the amount of `underlyingToken` to calculate its conversion into strategy shares\n     * @return The amount of underlying tokens corresponding to the input `amountShares`\n     * @dev Implementation for these functions in particular may vary significantly for different strategies\n     */\n    function underlyingToShares(uint256 amountUnderlying) external returns (uint256);\n\n    /**\n     * @notice convenience function for fetching the current underlying value of all of the `user`'s shares in\n     * this strategy. In contrast to `userUnderlyingView`, this function **may** make state modifications\n     */\n    function userUnderlying(address user) external returns (uint256);\n\n    /**\n     * @notice convenience function for fetching the current total shares of `user` in this strategy, by\n     * querying the `strategyManager` contract\n     */\n    function shares(address user) external view returns (uint256);\n\n    /**\n     * @notice Used to convert a number of shares to the equivalent amount of underlying tokens for this strategy.\n     * @notice In contrast to `sharesToUnderlying`, this function guarantees no state modifications\n     * @param amountShares is the amount of shares to calculate its conversion into the underlying token\n     * @return The amount of shares corresponding to the input `amountUnderlying`\n     * @dev Implementation for these functions in particular may vary significantly for different strategies\n     */\n    function sharesToUnderlyingView(uint256 amountShares) external view returns (uint256);\n\n    /**\n     * @notice Used to convert an amount of underlying tokens to the equivalent amount of shares in this strategy.\n     * @notice In contrast to `underlyingToShares`, this function guarantees no state modifications\n     * @param amountUnderlying is the amount of `underlyingToken` to calculate its conversion into strategy shares\n     * @return The amount of shares corresponding to the input `amountUnderlying`\n     * @dev Implementation for these functions in particular may vary significantly for different strategies\n     */\n    function underlyingToSharesView(uint256 amountUnderlying) external view returns (uint256);\n\n    /**\n     * @notice convenience function for fetching the current underlying value of all of the `user`'s shares in\n     * this strategy. In contrast to `userUnderlying`, this function guarantees no state modifications\n     */\n    function userUnderlyingView(address user) external view returns (uint256);\n\n    /// @notice The underlying token for shares in this Strategy\n    function underlyingToken() external view returns (IERC20);\n\n    /// @notice The total number of extant shares in this Strategy\n    function totalShares() external view returns (uint256);\n\n    /// @notice Returns either a brief string explaining the strategy's goal & purpose, or a link to metadata that\n    /// explains in more detail.\n    function explanation() external view returns (string memory);\n}\n"
    },
    "contracts/interfaces/ssvNetwork/ISSVNetworkCore.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.21;\n\ninterface ISSVNetworkCore {\n    /**\n     *\n     */\n    /* Structs */\n    /**\n     *\n     */\n\n    /// @notice Represents a snapshot of an operator's or a DAO's state at a certain block\n    struct Snapshot {\n        /// @dev The block number when the snapshot was taken\n        uint32 block;\n        /// @dev The last index calculated by the formula index += (currentBlock - block) * fee\n        uint64 index;\n        /// @dev Total accumulated earnings calculated by the formula accumulated + lastIndex * validatorCount\n        uint64 balance;\n    }\n\n    /// @notice Represents an SSV operator\n    struct Operator {\n        /// @dev The number of validators associated with this operator\n        uint32 validatorCount;\n        /// @dev The fee charged by the operator, set to zero for private operators and cannot be increased once set\n        uint64 fee;\n        /// @dev The address of the operator's owner\n        address owner;\n        /// @dev Whitelisted flag for this operator\n        bool whitelisted;\n        /// @dev The state snapshot of the operator\n        Snapshot snapshot;\n    }\n\n    /// @notice Represents a request to change an operator's fee\n    struct OperatorFeeChangeRequest {\n        /// @dev The new fee proposed by the operator\n        uint64 fee;\n        /// @dev The time when the approval period for the fee change begins\n        uint64 approvalBeginTime;\n        /// @dev The time when the approval period for the fee change ends\n        uint64 approvalEndTime;\n    }\n\n    /// @notice Represents a cluster of validators\n    struct Cluster {\n        /// @dev The number of validators in the cluster\n        uint32 validatorCount;\n        /// @dev The index of network fees related to this cluster\n        uint64 networkFeeIndex;\n        /// @dev The last index calculated for the cluster\n        uint64 index;\n        /// @dev Flag indicating whether the cluster is active\n        bool active;\n        /// @dev The balance of the cluster\n        uint256 balance;\n    }\n\n    /**\n     *\n     */\n    /* Errors */\n    /**\n     *\n     */\n    error CallerNotOwner(); // 0x5cd83192\n    error CallerNotWhitelisted(); // 0x8c6e5d71\n    error FeeTooLow(); // 0x732f9413\n    error FeeExceedsIncreaseLimit(); // 0x958065d9\n    error NoFeeDeclared(); // 0x1d226c30\n    error ApprovalNotWithinTimeframe(); // 0x97e4b518\n    error OperatorDoesNotExist(); // 0x961e3e8c\n    error InsufficientBalance(); // 0xf4d678b8\n    error ValidatorDoesNotExist(); // 0xe51315d2\n    error ClusterNotLiquidatable(); // 0x60300a8d\n    error InvalidPublicKeyLength(); // 0x637297a4\n    error InvalidOperatorIdsLength(); // 0x38186224\n    error ClusterAlreadyEnabled(); // 0x3babafd2\n    error ClusterIsLiquidated(); // 0x95a0cf33\n    error ClusterDoesNotExists(); // 0x185e2b16\n    error IncorrectClusterState(); // 0x12e04c87\n    error UnsortedOperatorsList(); // 0xdd020e25\n    error NewBlockPeriodIsBelowMinimum(); // 0x6e6c9cac\n    error ExceedValidatorLimit(); // 0x6df5ab76\n    error TokenTransferFailed(); // 0x045c4b02\n    error SameFeeChangeNotAllowed(); // 0xc81272f8\n    error FeeIncreaseNotAllowed(); // 0x410a2b6c\n    error NotAuthorized(); // 0xea8e4eb5\n    error OperatorsListNotUnique(); // 0xa5a1ff5d\n    error OperatorAlreadyExists(); // 0x289c9494\n    error TargetModuleDoesNotExist(); // 0x8f9195fb\n    error MaxValueExceeded(); // 0x91aa3017\n    error FeeTooHigh(); // 0xcd4e6167\n    error PublicKeysSharesLengthMismatch(); // 0x9ad467b8\n    error IncorrectValidatorStateWithData(bytes publicKey); // 0x89307938\n    error ValidatorAlreadyExistsWithData(bytes publicKey); // 0x388e7999\n\n    // legacy errors\n    error ValidatorAlreadyExists(); // 0x8d09a73e\n    error IncorrectValidatorState(); // 0x2feda3c1\n}\n"
    },
    "lib/openzeppelin-contracts-upgradeable/contracts/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "lib/openzeppelin-contracts-upgradeable/contracts/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n"
    },
    "contracts/interfaces/eigenlayer/IDelegationManager.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport \"./IStrategy.sol\";\nimport \"./ISignatureUtils.sol\";\n\ninterface IDelegationManagerTypes {\n    /**\n     * @notice Abstract struct used in calculating an EIP712 signature for an operator's delegationApprover to approve that a specific staker delegate to the operator.\n     * @dev Used in computing the `DELEGATION_APPROVAL_TYPEHASH` and as a reference in the computation of the approverDigestHash in the `_delegate` function.\n     */\n    struct DelegationApproval {\n        // the staker who is delegating\n        address staker;\n        // the operator being delegated to\n        address operator;\n        // the operator's provided salt\n        bytes32 salt;\n        // the expiration timestamp (UTC) of the signature\n        uint256 expiry;\n    }\n\n    /**\n     * @dev A struct representing an existing queued withdrawal. After the withdrawal delay has elapsed, this withdrawal can be completed via `completeQueuedWithdrawal`.\n     * A `Withdrawal` is created by the `DelegationManager` when `queueWithdrawals` is called. The `withdrawalRoots` hashes returned by `queueWithdrawals` can be used\n     * to fetch the corresponding `Withdrawal` from storage (via `getQueuedWithdrawal`).\n     *\n     * @param staker The address that queued the withdrawal\n     * @param delegatedTo The address that the staker was delegated to at the time the withdrawal was queued. Used to determine if additional slashing occurred before\n     * this withdrawal became completable.\n     * @param withdrawer The address that will call the contract to complete the withdrawal. Note that this will always equal `staker`; alternate withdrawers are not\n     * supported at this time.\n     * @param nonce The staker's `cumulativeWithdrawalsQueued` at time of queuing. Used to ensure withdrawals have unique hashes.\n     * @param startBlock The block number when the withdrawal was queued.\n     * @param strategies The strategies requested for withdrawal when the withdrawal was queued\n     * @param scaledShares The staker's deposit shares requested for withdrawal, scaled by the staker's `depositScalingFactor`. Upon completion, these will be\n     * scaled by the appropriate slashing factor as of the withdrawal's completable block. The result is what is actually withdrawable.\n     */\n    struct Withdrawal {\n        address staker;\n        address delegatedTo;\n        address withdrawer;\n        uint256 nonce;\n        uint32 startBlock;\n        IStrategy[] strategies;\n        uint256[] scaledShares;\n    }\n\n    /**\n     * @param strategies The strategies to withdraw from\n     * @param depositShares For each strategy, the number of deposit shares to withdraw. Deposit shares can\n     * be queried via `getDepositedShares`.\n     * NOTE: The number of shares ultimately received when a withdrawal is completed may be lower depositShares\n     * if the staker or their delegated operator has experienced slashing.\n     * @param __deprecated_withdrawer This field is ignored. The only party that may complete a withdrawal\n     * is the staker that originally queued it. Alternate withdrawers are not supported.\n     */\n    struct QueuedWithdrawalParams {\n        IStrategy[] strategies;\n        uint256[] depositShares;\n        address __deprecated_withdrawer;\n    }\n}\n/**\n * @title DelegationManager\n * @author Layr Labs, Inc.\n * @notice Terms of Service: https://docs.eigenlayer.xyz/overview/terms-of-service\n * @notice  This is the contract for delegation in EigenLayer. The main functionalities of this contract are\n * - enabling anyone to register as an operator in EigenLayer\n * - allowing operators to specify parameters related to stakers who delegate to them\n * - enabling any staker to delegate its stake to the operator of its choice (a given staker can only delegate to a single operator at a time)\n * - enabling a staker to undelegate its assets from the operator it is delegated to (performed as part of the withdrawal process, initiated through the StrategyManager)\n */\ninterface IDelegationManager is ISignatureUtils,IDelegationManagerTypes\n{\n    /**\n     * @notice Caller delegates their stake to an operator.\n     * @param operator The account (`msg.sender`) is delegating its assets to for use in serving applications built on EigenLayer.\n     * @param approverSignatureAndExpiry (optional) Verifies the operator approves of this delegation\n     * @param approverSalt (optional) A unique single use value tied to an individual signature.\n     * @dev The signature/salt are used ONLY if the operator has configured a delegationApprover.\n     * If they have not, these params can be left empty.\n     */\n    function delegateTo(\n        address operator,\n        SignatureWithExpiry memory approverSignatureAndExpiry,\n        bytes32 approverSalt\n    ) external;\n\n\n    /**\n     * @notice Allows a staker to queue a withdrawal of their deposit shares. The withdrawal can be\n     * completed after the MIN_WITHDRAWAL_DELAY_BLOCKS via either of the completeQueuedWithdrawal methods.\n     *\n     * While in the queue, these shares are removed from the staker's balance, as well as from their operator's\n     * delegated share balance (if applicable). Note that while in the queue, deposit shares are still subject\n     * to slashing. If any slashing has occurred, the shares received may be less than the queued deposit shares.\n     *\n     * @dev To view all the staker's strategies/deposit shares that can be queued for withdrawal, see `getDepositedShares`\n     * @dev To view the current conversion between a staker's deposit shares and withdrawable shares, see `getWithdrawableShares`\n     */\n    function queueWithdrawals(\n        QueuedWithdrawalParams[] calldata params\n    ) external returns (bytes32[] memory);\n\n    /**\n     * @notice Used to complete a queued withdrawal\n     * @param withdrawal The withdrawal to complete\n     * @param tokens Array in which the i-th entry specifies the `token` input to the 'withdraw' function of the i-th Strategy in the `withdrawal.strategies` array.\n     * @param tokens For each `withdrawal.strategies`, the underlying token of the strategy\n     * NOTE: if `receiveAsTokens` is false, the `tokens` array is unused and can be filled with default values. However, `tokens.length` MUST still be equal to `withdrawal.strategies.length`.\n     * NOTE: For the `beaconChainETHStrategy`, the corresponding `tokens` value is ignored (can be 0).\n     * @param receiveAsTokens If true, withdrawn shares will be converted to tokens and sent to the caller. If false, the caller receives shares that can be delegated to an operator.\n     * NOTE: if the caller receives shares and is currently delegated to an operator, the received shares are\n     * automatically delegated to the caller's current operator.\n     */\n    function completeQueuedWithdrawal(\n        Withdrawal calldata withdrawal,\n        IERC20[] calldata tokens,\n        bool receiveAsTokens\n    ) external;\n\n    /**\n     * @notice Used to complete multiple queued withdrawals\n     * @param withdrawals Array of Withdrawals to complete. See `completeQueuedWithdrawal` for the usage of a single Withdrawal.\n     * @param tokens Array of tokens for each Withdrawal. See `completeQueuedWithdrawal` for the usage of a single array.\n     * @param receiveAsTokens Whether or not to complete each withdrawal as tokens. See `completeQueuedWithdrawal` for the usage of a single boolean.\n     * @dev See `completeQueuedWithdrawal` for relevant dev tags\n     */\n    function completeQueuedWithdrawals(\n        Withdrawal[] calldata withdrawals,\n        IERC20[][] calldata tokens,\n        bool[] calldata receiveAsTokens\n    ) external;\n\n    /**\n     * @notice Called by a share manager when a staker's deposit share balance in a strategy increases.\n     * This method delegates any new shares to an operator (if applicable), and updates the staker's\n     * deposit scaling factor regardless.\n     * @param staker The address whose deposit shares have increased\n     * @param strategy The strategy in which shares have been deposited\n     * @param prevDepositShares The number of deposit shares the staker had in the strategy prior to the increase\n     * @param addedShares The number of deposit shares added by the staker\n     *\n     * @dev Note that if the either the staker's current operator has been slashed 100% for `strategy`, OR the\n     * staker has been slashed 100% on the beacon chain such that the calculated slashing factor is 0, this\n     * method WILL REVERT.\n     */\n    function increaseDelegatedShares(\n        address staker,\n        IStrategy strategy,\n        uint256 prevDepositShares,\n        uint256 addedShares\n    ) external;\n\n    /**\n     * @notice If the staker is delegated, decreases its operator's shares in response to\n     * a decrease in balance in the beaconChainETHStrategy\n     * @param staker the staker whose operator's balance will be decreased\n     * @param curDepositShares the current deposit shares held by the staker\n     * @param beaconChainSlashingFactorDecrease the amount that the staker's beaconChainSlashingFactor has decreased by\n     * @dev Note: `beaconChainSlashingFactorDecrease` are assumed to ALWAYS be < 1 WAD.\n     * These invariants are maintained in the EigenPodManager.\n     */\n    function decreaseDelegatedShares(\n        address staker,\n        uint256 curDepositShares,\n        uint64 beaconChainSlashingFactorDecrease\n    ) external;\n\n    /**\n     *\n     *                         VIEW FUNCTIONS\n     *\n     */\n\n    /**\n     * @notice returns the address of the operator that `staker` is delegated to.\n     * @notice Mapping: staker => operator whom the staker is currently delegated to.\n     * @dev Note that returning address(0) indicates that the staker is not actively delegated to any operator.\n     */\n    function delegatedTo(address staker) external view returns (address);\n\n    /**\n     * @notice Mapping: delegationApprover => 32-byte salt => whether or not the salt has already been used by the delegationApprover.\n     * @dev Salts are used in the `delegateTo` function. Note that this function only processes the delegationApprover's\n     * signature + the provided salt if the operator being delegated to has specified a nonzero address as their `delegationApprover`.\n     */\n    function delegationApproverSaltIsSpent(\n        address _delegationApprover,\n        bytes32 salt\n    ) external view returns (bool);\n\n    /// @notice Mapping: staker => cumulative number of queued withdrawals they have ever initiated.\n    /// @dev This only increments (doesn't decrement), and is used to help ensure that otherwise identical withdrawals have unique hashes.\n    function cumulativeWithdrawalsQueued(\n        address staker\n    ) external view returns (uint256);\n\n    /**\n     * @notice Returns 'true' if `staker` *is* actively delegated, and 'false' otherwise.\n     */\n    function isDelegated(address staker) external view returns (bool);\n\n\n    /**\n     * @notice Returns the delegationApprover account for an operator\n     */\n    function delegationApprover(\n        address operator\n    ) external view returns (address);\n\n    /**\n     * @notice Returns the shares that an operator has delegated to them in a set of strategies\n     * @param operator the operator to get shares for\n     * @param strategies the strategies to get shares for\n     */\n    function getOperatorShares(\n        address operator,\n        IStrategy[] memory strategies\n    ) external view returns (uint256[] memory);\n\n    /**\n     * @notice Returns the shares that a set of operators have delegated to them in a set of strategies\n     * @param operators the operators to get shares for\n     * @param strategies the strategies to get shares for\n     */\n    function getOperatorsShares(\n        address[] memory operators,\n        IStrategy[] memory strategies\n    ) external view returns (uint256[][] memory);\n\n    /**\n     * @notice Returns amount of withdrawable shares from an operator for a strategy that is still in the queue\n     * and therefore slashable. Note that the *actual* slashable amount could be less than this value as this doesn't account\n     * for amounts that have already been slashed. This assumes that none of the shares have been slashed.\n     * @param operator the operator to get shares for\n     * @param strategy the strategy to get shares for\n     * @return the amount of shares that are slashable in the withdrawal queue for an operator and a strategy\n     */\n    function getSlashableSharesInQueue(\n        address operator,\n        IStrategy strategy\n    ) external view returns (uint256);\n\n    /**\n     * @notice Given a staker and a set of strategies, return the shares they can queue for withdrawal and the\n     * corresponding depositShares.\n     * This value depends on which operator the staker is delegated to.\n     * The shares amount returned is the actual amount of Strategy shares the staker would receive (subject\n     * to each strategy's underlying shares to token ratio).\n     */\n    function getWithdrawableShares(\n        address staker,\n        IStrategy[] memory strategies\n    )\n        external\n        view\n        returns (\n            uint256[] memory withdrawableShares,\n            uint256[] memory depositShares\n        );\n\n    /**\n     * @notice Returns the number of shares in storage for a staker and all their strategies\n     */\n    function getDepositedShares(\n        address staker\n    ) external view returns (IStrategy[] memory, uint256[] memory);\n\n    /**\n     * @notice Returns the scaling factor applied to a staker's deposits for a given strategy\n     */\n    function depositScalingFactor(\n        address staker,\n        IStrategy strategy\n    ) external view returns (uint256);\n\n     /**\n     * @notice Returns the Withdrawal and corresponding shares associated with a `withdrawalRoot`\n     * @param withdrawalRoot The hash identifying the queued withdrawal\n     * @return withdrawal The withdrawal details\n     * @return shares Array of shares corresponding to each strategy in the withdrawal\n     * @dev The shares are what a user would receive from completing a queued withdrawal, assuming all slashings are applied\n     * @dev Withdrawals queued before the slashing release cannot be queried with this method\n     */\n    function getQueuedWithdrawal(\n        bytes32 withdrawalRoot\n    ) external view returns (Withdrawal memory withdrawal, uint256[] memory shares);\n\n    /// @notice Returns a list of pending queued withdrawals for a `staker`, and the `shares` to be withdrawn.\n    function getQueuedWithdrawals(\n        address staker\n    )\n        external\n        view\n        returns (Withdrawal[] memory withdrawals, uint256[][] memory shares);\n\n    /// @notice Returns a list of queued withdrawal roots for the `staker`.\n    /// NOTE that this only returns withdrawals queued AFTER the slashing release.\n    function getQueuedWithdrawalRoots(\n        address staker\n    ) external view returns (bytes32[] memory);\n\n    /**\n     * @notice Converts shares for a set of strategies to deposit shares, likely in order to input into `queueWithdrawals`\n     * @param staker the staker to convert shares for\n     * @param strategies the strategies to convert shares for\n     * @param withdrawableShares the shares to convert\n     * @return the deposit shares\n     * @dev will be a few wei off due to rounding errors\n     */\n    function convertToDepositShares(\n        address staker,\n        IStrategy[] memory strategies,\n        uint256[] memory withdrawableShares\n    ) external view returns (uint256[] memory);\n\n    /// @notice Returns the keccak256 hash of `withdrawal`.\n    function calculateWithdrawalRoot(\n        Withdrawal memory withdrawal\n    ) external pure returns (bytes32);\n\n\n    /// @notice return address of the beaconChainETHStrategy\n    function beaconChainETHStrategy() external view returns (IStrategy);\n\n    /**\n     * @notice Returns the minimum withdrawal delay in blocks to pass for withdrawals queued to be completable.\n     * Also applies to legacy withdrawals so any withdrawals not completed prior to the slashing upgrade will be subject\n     * to this longer delay.\n     * @dev Backwards-compatible interface to return the internal `MIN_WITHDRAWAL_DELAY_BLOCKS` value\n     * @dev Previous value in storage was deprecated. See `__deprecated_minWithdrawalDelayBlocks`\n     */\n    function minWithdrawalDelayBlocks() external view returns (uint32);\n\n    function pendingWithdrawals(bytes32 withdrawalRoot) external view returns (bool);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC20/IERC20.sol\";\n"
    },
    "lib/openzeppelin-contracts-upgradeable/contracts/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "contracts/interfaces/eigenlayer/ISignatureUtils.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\n/**\n * @title The interface for common signature utilities.\n * @author Layr Labs, Inc.\n * @notice Terms of Service: https://docs.eigenlayer.xyz/overview/terms-of-service\n */\ninterface ISignatureUtils {\n    // @notice Struct that bundles together a signature and an expiration time for the signature. Used primarily for\n    // stack management.\n    struct SignatureWithExpiry {\n        // the signature itself, formatted as a single bytes object\n        bytes signature;\n        // the expiration timestamp (UTC) of the signature\n        uint256 expiry;\n    }\n\n    // @notice Struct that bundles together a signature, a salt for uniqueness, and an expiration time for the\n    // signature. Used primarily for stack management.\n    struct SignatureWithSaltAndExpiry {\n        // the signature itself, formatted as a single bytes object\n        bytes signature;\n        // the salt used to generate the signature\n        bytes32 salt;\n        // the expiration timestamp (UTC) of the signature\n        uint256 expiry;\n    }\n}\n"
    }
  },
  "settings": {
    "remappings": [
      "ds-test/=lib/forge-std/lib/ds-test/src/",
      "forge-std/=lib/forge-std/src/",
      "@openzeppelin/contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/",
      "@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/",
      "@arbitrum/=node_modules/@arbitrum/",
      "@axelar-network/=node_modules/@axelar-network/",
      "@chainlink/=node_modules/@chainlink/",
      "@eth-optimism/=node_modules/@eth-optimism/",
      "@layerzerolabs/=node_modules/@layerzerolabs/",
      "@offchainlabs/=node_modules/@offchainlabs/",
      "@scroll-tech/=node_modules/@scroll-tech/",
      "erc4626-tests/=lib/openzeppelin-contracts-upgradeable/lib/erc4626-tests/",
      "eth-gas-reporter/=node_modules/eth-gas-reporter/",
      "hardhat-deploy/=node_modules/hardhat-deploy/",
      "hardhat/=node_modules/hardhat/",
      "openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/",
      "openzeppelin-contracts/=lib/openzeppelin-contracts/",
      "openzeppelin/=lib/openzeppelin-contracts-upgradeable/contracts/",
      "solidity-bytes-utils/=node_modules/solidity-bytes-utils/",
      "solidity-code-metrics/=node_modules/solidity-code-metrics/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 10000
    },
    "metadata": {
      "useLiteralContent": false,
      "bytecodeHash": "ipfs",
      "appendCBOR": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "evmVersion": "shanghai",
    "viaIR": false,
    "libraries": {}
  }
}}