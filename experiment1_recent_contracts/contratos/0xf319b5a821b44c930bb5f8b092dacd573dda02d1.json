{{
  "language": "Solidity",
  "sources": {
    "src/registries/InvestorRegistry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.28;\n\nimport {ISchemaRegistry, SchemaRecord} from \"eas-contracts/ISchemaRegistry.sol\";\nimport {ISchemaResolver} from \"eas-contracts/resolver/ISchemaResolver.sol\";\nimport {\n    IEAS,\n    AttestationRequestData,\n    AttestationRequest,\n    Attestation,\n    RevocationRequestData,\n    RevocationRequest\n} from \"eas-contracts/IEAS.sol\";\n\nimport {IUserRegistry} from \"src/interfaces/IUserRegistry.sol\";\nimport {IInvestorRegistry} from \"src/interfaces/IInvestorRegistry.sol\";\nimport {IOperationsEngine} from \"src/interfaces/IOperationsEngine.sol\";\nimport {IRoleRegistry} from \"src/interfaces/IRoleRegistry.sol\";\nimport {IInstrumentRegistry} from \"src/interfaces/IInstrumentRegistry.sol\";\nimport {IDealerRegistry} from \"src/interfaces/IDealerRegistry.sol\";\nimport {IEternalRegistryStorage} from \"src/interfaces/IEternalRegistryStorage.sol\";\nimport {IGatewayManager} from \"src/interfaces/IGatewayManager.sol\";\n\nimport \"src/utils/Constant.sol\";\n\nimport {BaseRegistry} from \"src/registries/BaseRegistry.sol\";\nimport {BaseUserRegistry} from \"src/registries/BaseUserRegistry.sol\";\nimport {ResolverVerifier, IAccessVerifier} from \"src/credentials/ResolverVerifier.sol\";\nimport {GatewayUtils} from \"src/utils/GatewayUtils.sol\";\n\n/**\n * @title Investor Registry\n * @author Libre\n * @notice Keeps all the information relative to the investors\n * accreditation and compliance checks\n */\ncontract InvestorRegistry is BaseUserRegistry, IInvestorRegistry {\n    /// @custom:storage-location erc7201:InvestorRegistry.storage\n    struct InvestorRegistryStorage {\n        address resolverVerifier;\n        address policyViewer;\n        IEAS eas;\n        IGatewayManager gatewayManager;\n        bytes32 schemaId;\n        //TODO: Hopefully can use transient storage for this in solidity 0.8.29\n        SteelProofData tempSteelProofData;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"InvestorRegistry.storage\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant INVESTOR_REGISTRY_STORAGE_SLOT =\n        0x6038d02812ffb3cdd1975655e8b1ac798e35a8c7b30389858eb87a41fc030b00;\n\n    function initialize(\n        IRoleRegistry _roleRegistry,\n        IInstrumentRegistry _instrumentRegistry,\n        IDealerRegistry _dealerRegistry,\n        IEternalRegistryStorage _jurisdictionRegistry,\n        IOperationsEngine _operationsEngine,\n        IEAS _eas,\n        IGatewayManager _gatewayManager,\n        address _resolverVerifier,\n        address _policyViewer\n    ) external initializer {\n        BaseRegistryStorage storage brs = _getBaseRegistryStorage();\n        BaseRegistry.initialize(IS_INVESTOR);\n\n        brs.instrumentRegistry = _instrumentRegistry;\n        brs.dealerRegistry = _dealerRegistry;\n        brs.jurisdictionRegistry = _jurisdictionRegistry;\n        brs.operationsEngine = _operationsEngine;\n        InvestorRegistryStorage storage ivrs = _getInvestorRegistryStorage();\n        ivrs.eas = _eas;\n        ivrs.gatewayManager = _gatewayManager;\n        ivrs.resolverVerifier = _resolverVerifier;\n        ivrs.policyViewer = _policyViewer;\n        ISchemaRegistry easSchemaRegistry = _eas.getSchemaRegistry();\n        ivrs.schemaId = easSchemaRegistry.register(\n            \"bytes32 investorId, bytes32[] instrumentIds, uint64[] instrumentExpiryTimestamps\",\n            ISchemaResolver(_resolverVerifier),\n            true\n        );\n\n        PermissionedContractStorage storage pcs = _getPermissionedContractStorage();\n        pcs.roleRegistry = _roleRegistry;\n    }\n\n    /**\n     * @notice Adds a new investor to the registry.\n     * @param _senderRole Role of the sender performing the operation.\n     * @param _investorId The unique ID of the investor.\n     * @param _wallet The default wallet address of the investor.\n     * @param _dealerId The ID of the associated dealer.\n     */\n    function addInvestor(bytes32 _senderRole, bytes32 _investorId, address _wallet, bytes32 _dealerId) external {\n        BaseRegistryStorage storage brs = _getBaseRegistryStorage();\n\n        _nonZeroId(_investorId);\n        _nonZeroId(_dealerId);\n        _checkRoleHasAccess(_senderRole);\n        if (_isValidId(_investorId)) {\n            revert IInvestorRegistry_AlreadyAnInvestor();\n        }\n        _setDefaultReservedKeys(_investorId);\n\n        bytes32 dealerId = brs.dealerRegistry.getIdFromWallet(msg.sender);\n        //if msg.sender is a dealer, they must be the investor's dealer\n        if (dealerId != bytes32(0)) {\n            if (dealerId != _dealerId) {\n                revert IInvestorRegistry_NotInvestorsDealer();\n            }\n        }\n\n        // Validate that _dealerId exists and is a valid dealer\n        if (!brs.dealerRegistry.getBool(_dealerId, IS_DEALER)) {\n            revert IInvestorRegistry_InvalidDealerId();\n        }\n\n        _setBool(_investorId, IS_INVESTOR, true);\n        _setBytes(_investorId, DEALER, _dealerId);\n        _addWallet(_investorId, _wallet);\n\n        _setReservedKey(_investorId, CREDENTIAL_ID);\n        _setReservedKey(_investorId, DEALER);\n\n        emit NewInvestorAdded(_investorId, _wallet);\n    }\n\n    function configureResolverVerifier(address _resolverVerifier) external {\n        IRoleRegistry roleRegistry = _roleRegistry();\n\n        bytes32 contractManagerRole = roleRegistry.getContractManager(address(this));\n\n        if (!roleRegistry.hasRole(contractManagerRole, msg.sender)) {\n            revert IInvestorRegistry_NoContractManagerRole();\n        }\n        if (_resolverVerifier == address((0))) {\n            revert IInvestorRegistry_EmptyResolverVerifier();\n        }\n        //update schema with new resolverVerifier\n        InvestorRegistryStorage storage ivrs = _getInvestorRegistryStorage();\n        ISchemaRegistry easSchemaRegistry = ivrs.eas.getSchemaRegistry();\n        ivrs.schemaId = easSchemaRegistry.register(\n            \"bytes32 investorId, bytes32[] instrumentIds, uint64[] instrumentExpiryTimestamps\",\n            ISchemaResolver(_resolverVerifier),\n            true\n        );\n        //update stored resolverVerifier\n        ivrs.resolverVerifier = _resolverVerifier;\n        emit InvestorRegistryResolverVerifierChanged(_resolverVerifier);\n    }\n\n    /**\n     * @notice Updates zk program image IDs for credential and subscription verification.\n     * @param _credentialImageID New zk program image ID for credentials.\n     * @param _subscriptionImageID New zk program image ID for subscriptions.\n     */\n    function configureImageIDs(bytes32 _credentialImageID, bytes32 _subscriptionImageID) external {\n        IRoleRegistry roleRegistry = _roleRegistry();\n\n        bytes32 contractManagerRole = roleRegistry.getContractManager(address(this));\n        if (!roleRegistry.hasRole(contractManagerRole, msg.sender)) {\n            revert IInvestorRegistry_NoContractManagerRole();\n        }\n        if (_credentialImageID == bytes32(0) || _subscriptionImageID == bytes32(0)) {\n            revert IInvestorRegistry_EmptyImageIDs();\n        }\n        InvestorRegistryStorage storage ivrs = _getInvestorRegistryStorage();\n        ResolverVerifier(payable(ivrs.resolverVerifier)).updateImageIDs(_credentialImageID, _subscriptionImageID);\n        emit InvestorRegistryImageIDsChanged(_credentialImageID, _subscriptionImageID);\n    }\n\n    //@dev If a credential does not exist or the previous one is revoked, it creates a new one with all new values.\n    // Otherwise it creates a new credential adding the new instruments and/or updating expiry timestamps.\n    // In this second case the seal should only contain the proof for the updated instruments, but the journal\n    //should have existing instruments added to be kept in the new credential\n    function setCredential(CredentialProofData calldata _proof) external {\n        if (!_roleRegistry().hasRole(ATTESTER_ROLE, msg.sender)) {\n            revert IInvestorRegistry_NoAttesterRole();\n        }\n        InvestorRegistryStorage storage ivrs = _getInvestorRegistryStorage();\n        bytes32 schemaId = ivrs.schemaId;\n        if (schemaId == bytes32(0)) {\n            revert IInvestorRegistry_SchemaNotSet();\n        }\n\n        if (_proof.journal.policyViewer != ivrs.policyViewer) {\n            revert IInvestorRegistry_PolicyViewerProofMismatch();\n        }\n\n        bytes32 previousCredentialUid = getBytes(_proof.journal.investorId, CREDENTIAL_ID);\n\n        bytes memory encodedData = abi.encode(\n            _proof.journal.investorId, _proof.journal.instrumentIds, _proof.journal.instrumentExpiryTimestamps\n        );\n        AttestationRequestData memory attestation = AttestationRequestData({\n            recipient: address(0), //We are using investorId in the data rather than their address\n            expirationTime: _proof.journal.expiryTimestamp,\n            revocable: true,\n            refUID: bytes32(0), //Not referencing other attestations\n            data: encodedData,\n            value: 0\n        });\n\n        AttestationRequest memory attestationRequest = AttestationRequest({schema: schemaId, data: attestation});\n        ivrs.tempSteelProofData = SteelProofData({commitment: _proof.journal.commitment, seal: _proof.seal});\n        bytes32 credentialId = ivrs.eas.attest(attestationRequest);\n        _setBytes(_proof.journal.investorId, CREDENTIAL_ID, credentialId);\n\n        // Bridge the new credential\n        uint16[] memory chains;\n        ivrs.gatewayManager.bridgeCredential(credentialId, GATEWAY_MANAGER_ROLE, chains);\n\n        //revoke previous attestation\n        if (previousCredentialUid != bytes32(0) && ivrs.eas.getAttestation(previousCredentialUid).revocationTime == 0) {\n            _revokeAttestation(previousCredentialUid);\n        }\n\n        emit InvestorRegistryCredentialSet(_proof.journal.investorId, _proof.journal.instrumentIds);\n    }\n\n    //@dev If no instrument Ids sent as input, it revokes the entire credential.\n    // Otherwise it reissues the credential eliminating the instruments sent as input\n    function revokeCredential(bytes32 _investorId, bytes32[] calldata _instrumentIds) external {\n        if (!_roleRegistry().hasRole(ATTESTER_ROLE, msg.sender)) {\n            revert IInvestorRegistry_NoAttesterRole();\n        }\n        InvestorRegistryStorage storage ivrs = _getInvestorRegistryStorage();\n\n        bytes32 schemaId = ivrs.schemaId;\n        if (schemaId == bytes32(0)) {\n            revert IInvestorRegistry_SchemaNotSet();\n        }\n        bytes32 previousCredentialUid = getBytes(_investorId, CREDENTIAL_ID);\n        _revokeAttestation(previousCredentialUid);\n\n        if (_instrumentIds.length != 0) {\n            //Compare instruments to revoke with previous attestation\n            AttestationRequestData memory replacementAttestation;\n            {\n                Attestation memory oldAttestation = ivrs.eas.getAttestation(previousCredentialUid);\n                (, bytes32[] memory oldInstrumentIds, uint64[] memory oldInstrumentExpiryTimestamps) =\n                    abi.decode(oldAttestation.data, (bytes32, bytes32[], uint64[]));\n\n                //only keeping instruments that are not being revoked\n                bytes32[] memory keptInstrumentIds;\n                uint64[] memory keptInstrumentExpiryTimestamps;\n                {\n                    uint256 keptCount = oldInstrumentIds.length - _instrumentIds.length;\n                    keptInstrumentIds = new bytes32[](keptCount);\n                    keptInstrumentExpiryTimestamps = new uint64[](keptCount);\n                }\n\n                uint256 currentIndex;\n                for (uint256 i; i < oldInstrumentIds.length; ++i) {\n                    bool toRevoke;\n                    for (uint256 j; j < _instrumentIds.length; ++j) {\n                        if (oldInstrumentIds[i] == _instrumentIds[j]) {\n                            toRevoke = true;\n                            break;\n                        }\n                    }\n                    if (!toRevoke) {\n                        if (currentIndex >= keptInstrumentIds.length) {\n                            revert IInvestorRegistry_InstrumentsToRevokeNotInCredential();\n                        }\n                        keptInstrumentIds[currentIndex] = (oldInstrumentIds[i]);\n                        keptInstrumentExpiryTimestamps[currentIndex] = (oldInstrumentExpiryTimestamps[i]);\n                        ++currentIndex;\n                    }\n                }\n\n                bytes memory encodedData = abi.encode(_investorId, keptInstrumentIds, keptInstrumentExpiryTimestamps);\n                replacementAttestation = AttestationRequestData({\n                    recipient: address(0), //We are using investorId in the data rather than their address\n                    expirationTime: oldAttestation.expirationTime,\n                    revocable: true,\n                    refUID: bytes32(0), //Not referencing other attestations\n                    data: encodedData,\n                    value: 0\n                });\n            }\n\n            //replace attestation only with kept instruments\n            AttestationRequest memory attestationRequest =\n                AttestationRequest({schema: schemaId, data: replacementAttestation});\n            bytes32 credentialId = ivrs.eas.attest(attestationRequest);\n            _setBytes(_investorId, CREDENTIAL_ID, credentialId);\n\n            // Bridge the updated credential\n            uint16[] memory chains;\n            ivrs.gatewayManager.bridgeCredential(credentialId, GATEWAY_MANAGER_ROLE, chains);\n        } else {\n            // Bridge the revkoed credential\n            uint16[] memory chains;\n            ivrs.gatewayManager.bridgeCredential(previousCredentialUid, GATEWAY_MANAGER_ROLE, chains);\n        }\n        emit InvestorRegistryCredentialRevoked(_investorId, _instrumentIds);\n    }\n\n    /**\n     * @notice Overrides the addWallet method to bridge wallet changes across chains\n     * @param _userId The ID of the user.\n     * @param _wallet The wallet address to associate with the user ID.\n     * @param _role The role used by the caller.\n     */\n    function addWallet(bytes32 _userId, address _wallet, bytes32 _role)\n        public\n        override(BaseUserRegistry, IUserRegistry)\n    {\n        super.addWallet(_userId, _wallet, _role);\n        // Bridge wallet change\n        InvestorRegistryStorage storage ivrs = _getInvestorRegistryStorage();\n        GatewayUtils.bridgeAddressChange(\n            ivrs.gatewayManager, _userId, _wallet, true, NATIVE_CHAIN_SELECTOR, GATEWAY_MANAGER_ROLE\n        );\n    }\n\n    /**\n     * @notice Overrides the removeWallet method to bridge wallet changes across chains\n     * @param _wallet The wallet address to remove.\n     * @param _role The role used by the caller.\n     * @return The user ID that the wallet was removed from\n     */\n    function removeWallet(address _wallet, bytes32 _role)\n        public\n        override(BaseUserRegistry, IUserRegistry)\n        returns (bytes32)\n    {\n        bytes32 _userId = super.removeWallet(_wallet, _role);\n        // Bridge wallet change\n        InvestorRegistryStorage storage ivrs = _getInvestorRegistryStorage();\n        GatewayUtils.bridgeAddressChange(\n            ivrs.gatewayManager,\n            _userId,\n            _wallet,\n            false, // Remove wallet\n            NATIVE_CHAIN_SELECTOR,\n            GATEWAY_MANAGER_ROLE\n        );\n        return _userId;\n    }\n\n    /**\n     * @notice Retrieves the address of the Resolver Verifier.\n     * @dev This function provides access to the Resolver Verifier, which is used for investor credential verification.\n     * @return The address of the Resolver Verifier.\n     */\n    function getResolverVerifier() external view returns (address) {\n        InvestorRegistryStorage storage ivrs = _getInvestorRegistryStorage();\n        return ivrs.resolverVerifier;\n    }\n\n    /**\n     * @notice Retrieves the schema ID used for investor credential management.\n     * @dev This function provides access to the schema ID, which represents the structure of attestation data.\n     * @return The schema ID as a `bytes32` value.\n     */\n    function getSchemaId() external view returns (bytes32) {\n        InvestorRegistryStorage storage ivrs = _getInvestorRegistryStorage();\n        return ivrs.schemaId;\n    }\n\n    /**\n     * @notice Verifies a subscription order against a zk-based proof.\n     * @param _proof The proof data for the subscription.\n     * @dev This uses the Resolver Verifier to validate the subscription.\n     */\n    function checkSubscription(OrderProofData calldata _proof) external view {\n        InvestorRegistryStorage storage ivrs = _getInvestorRegistryStorage();\n        IAccessVerifier(ivrs.resolverVerifier).verifySubscription(_proof);\n    }\n\n    /**\n     * @notice Retrieves the temporary proof data for the current attestation.\n     * @return The temporary `SteelProofData` structure.\n     */\n    function getTempSteelProofData() external view returns (SteelProofData memory) {\n        InvestorRegistryStorage storage ivrs = _getInvestorRegistryStorage();\n        return ivrs.tempSteelProofData;\n    }\n\n    /**\n     * @notice Gets the dealer ID associated with an investor.\n     * @param _investorId The unique ID of the investor.\n     * @return dealerId The ID of the associated dealer.\n     */\n    function getDealer(bytes32 _investorId) public view returns (bytes32 dealerId) {\n        return getBytes(_investorId, DEALER);\n    }\n\n    /**\n     * @notice Verifies the validity of an investor's credential.\n     * @param _investorId The unique ID of the investor.\n     * @dev Reverts if the credential is invalid, expired, or revoked.\n     */\n    function checkCredential(bytes32 _investorId) public view {\n        InvestorRegistryStorage storage ivrs = _getInvestorRegistryStorage();\n        bytes32 credentialUid = getBytes(_investorId, CREDENTIAL_ID);\n\n        IEAS eas = ivrs.eas;\n        if (!eas.isAttestationValid(credentialUid)) {\n            revert IInvestorRegistry_NonExistingCredential();\n        }\n\n        Attestation memory attestation = eas.getAttestation(credentialUid);\n        if (\n            attestation.revocationTime != 0 || attestation.expirationTime < block.timestamp\n                || attestation.attester != address(this)\n        ) {\n            revert IInvestorRegistry_CredentialInvalid();\n        }\n\n        (bytes32 returnedInvestorId,,) = abi.decode(attestation.data, (bytes32, bytes32[], uint64[]));\n\n        if (returnedInvestorId != _investorId) {\n            revert IInvestorRegistry_MismatchInvestorId();\n        }\n    }\n\n    /**\n     * @notice Verifies that an investor has a valid credential for a specific instrument.\n     * @param _investorId The unique ID of the investor.\n     * @param _instrumentId The ID of the instrument to check against.\n     * @dev Reverts if the credential for the instrument is invalid or expired.\n     */\n    function checkCredentialInstrument(bytes32 _investorId, bytes32 _instrumentId) public view {\n        InvestorRegistryStorage storage ivrs = _getInvestorRegistryStorage();\n        bytes32 credentialUid = getBytes(_investorId, CREDENTIAL_ID);\n\n        IEAS eas = ivrs.eas;\n        if (!eas.isAttestationValid(credentialUid)) {\n            revert IInvestorRegistry_NonExistingCredential();\n        }\n        Attestation memory attestation = eas.getAttestation(credentialUid);\n\n        if (\n            attestation.revocationTime != 0 || attestation.expirationTime < block.timestamp\n                || attestation.attester != address(this)\n        ) {\n            revert IInvestorRegistry_CredentialInvalid();\n        }\n        (bytes32 returnedInvestorId, bytes32[] memory instrumentIds, uint64[] memory instrumentExpiryTimestamps) =\n            abi.decode(attestation.data, (bytes32, bytes32[], uint64[]));\n\n        if (returnedInvestorId != _investorId) {\n            revert IInvestorRegistry_MismatchInvestorId();\n        }\n\n        for (uint256 i; i < instrumentIds.length; ++i) {\n            if (_instrumentId == instrumentIds[i]) {\n                if (instrumentExpiryTimestamps[i] > block.timestamp) return;\n                else break;\n            }\n        }\n        revert IInvestorRegistry_InstrumentCredentialInvalid();\n    }\n\n    /**\n     * @notice Revokes an attestation.\n     * @param _attestationId The unique ID of the attestation to be revoked.\n     */\n    function _revokeAttestation(bytes32 _attestationId) internal {\n        RevocationRequestData memory revocationData = RevocationRequestData({\n            uid: _attestationId,\n            value: 0 //No eth\n        });\n        InvestorRegistryStorage storage ivrs = _getInvestorRegistryStorage();\n\n        RevocationRequest memory revocation =\n            RevocationRequest({schema: ivrs.eas.getAttestation(_attestationId).schema, data: revocationData});\n        ivrs.eas.revoke(revocation);\n    }\n\n    /**\n     * @notice Checks if the sender has extra access to the specified ID.\n     * @param _id The unique ID being checked.\n     * @return Boolean indicating if extra access is granted.\n     */\n    function _hasExtraAccess(bytes32 _id) internal view override returns (bool) {\n        BaseRegistryStorage storage brs = _getBaseRegistryStorage();\n        InvestorRegistryStorage storage ivrs = _getInvestorRegistryStorage();\n        if (_id == GENERAL_DATA_ID) {\n            return false;\n        }\n\n        // If this is a cross-chain address operation and sender is the Gateway Manager\n        if (msg.sender == address(ivrs.gatewayManager)) {\n            return true;\n        }\n\n        return getBytes(_id, DEALER) == brs.dealerRegistry.getIdFromWallet(msg.sender);\n    }\n\n    /**\n     * @notice Checks if the sender has extra access to a batch of IDs.\n     * @param _ids An array of IDs being checked.\n     * @return Boolean indicating if extra access is granted for all IDs.\n     */\n    function _hasExtraAccess(bytes32[] memory _ids) internal view override returns (bool) {\n        BaseRegistryStorage storage brs = _getBaseRegistryStorage();\n\n        bytes32 dealerId = brs.dealerRegistry.getIdFromWallet(msg.sender);\n        for (uint256 i; i < _ids.length; ++i) {\n            if (_ids[i] == GENERAL_DATA_ID) {\n                return false;\n            }\n            if (getBytes(_ids[i], DEALER) != dealerId) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @notice Retrieves the storage slot for the `InvestorRegistryStorage` structure.\n     * @dev Uses inline assembly to map the predefined storage slot to the `InvestorRegistryStorage` structure.\n     * This method is used internally to access the investor registry's storage layout.\n     * @return ivrs A reference to the `InvestorRegistryStorage` located at the predefined storage slot.\n     */\n    function _getInvestorRegistryStorage() private pure returns (InvestorRegistryStorage storage ivrs) {\n        assembly {\n            ivrs.slot := INVESTOR_REGISTRY_STORAGE_SLOT\n        }\n    }\n}\n"
    },
    "lib/eas-contracts/contracts/ISchemaRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { ISemver } from \"./ISemver.sol\";\n\nimport { ISchemaResolver } from \"./resolver/ISchemaResolver.sol\";\n\n/// @notice A struct representing a record for a submitted schema.\nstruct SchemaRecord {\n    bytes32 uid; // The unique identifier of the schema.\n    ISchemaResolver resolver; // Optional schema resolver.\n    bool revocable; // Whether the schema allows revocations explicitly.\n    string schema; // Custom specification of the schema (e.g., an ABI).\n}\n\n/// @title ISchemaRegistry\n/// @notice The interface of global attestation schemas for the Ethereum Attestation Service protocol.\ninterface ISchemaRegistry is ISemver {\n    /// @notice Emitted when a new schema has been registered\n    /// @param uid The schema UID.\n    /// @param registerer The address of the account used to register the schema.\n    /// @param schema The schema data.\n    event Registered(bytes32 indexed uid, address indexed registerer, SchemaRecord schema);\n\n    /// @notice Submits and reserves a new schema\n    /// @param schema The schema data schema.\n    /// @param resolver An optional schema resolver.\n    /// @param revocable Whether the schema allows revocations explicitly.\n    /// @return The UID of the new schema.\n    function register(string calldata schema, ISchemaResolver resolver, bool revocable) external returns (bytes32);\n\n    /// @notice Returns an existing schema by UID\n    /// @param uid The UID of the schema to retrieve.\n    /// @return The schema data members.\n    function getSchema(bytes32 uid) external view returns (SchemaRecord memory);\n}\n"
    },
    "lib/eas-contracts/contracts/resolver/ISchemaResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { Attestation } from \"./../Common.sol\";\nimport { ISemver } from \"./../ISemver.sol\";\n\n/// @title ISchemaResolver\n/// @notice The interface of an optional schema resolver.\ninterface ISchemaResolver is ISemver {\n    /// @notice Checks if the resolver can be sent ETH.\n    /// @return Whether the resolver supports ETH transfers.\n    function isPayable() external pure returns (bool);\n\n    /// @notice Processes an attestation and verifies whether it's valid.\n    /// @param attestation The new attestation.\n    /// @return Whether the attestation is valid.\n    function attest(Attestation calldata attestation) external payable returns (bool);\n\n    /// @notice Processes multiple attestations and verifies whether they are valid.\n    /// @param attestations The new attestations.\n    /// @param values Explicit ETH amounts which were sent with each attestation.\n    /// @return Whether all the attestations are valid.\n    function multiAttest(\n        Attestation[] calldata attestations,\n        uint256[] calldata values\n    ) external payable returns (bool);\n\n    /// @notice Processes an attestation revocation and verifies if it can be revoked.\n    /// @param attestation The existing attestation to be revoked.\n    /// @return Whether the attestation can be revoked.\n    function revoke(Attestation calldata attestation) external payable returns (bool);\n\n    /// @notice Processes revocation of multiple attestation and verifies they can be revoked.\n    /// @param attestations The existing attestations to be revoked.\n    /// @param values Explicit ETH amounts which were sent with each revocation.\n    /// @return Whether the attestations can be revoked.\n    function multiRevoke(\n        Attestation[] calldata attestations,\n        uint256[] calldata values\n    ) external payable returns (bool);\n}\n"
    },
    "lib/eas-contracts/contracts/IEAS.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { ISchemaRegistry } from \"./ISchemaRegistry.sol\";\nimport { ISemver } from \"./ISemver.sol\";\nimport { Attestation, Signature } from \"./Common.sol\";\n\n/// @notice A struct representing the arguments of the attestation request.\nstruct AttestationRequestData {\n    address recipient; // The recipient of the attestation.\n    uint64 expirationTime; // The time when the attestation expires (Unix timestamp).\n    bool revocable; // Whether the attestation is revocable.\n    bytes32 refUID; // The UID of the related attestation.\n    bytes data; // Custom attestation data.\n    uint256 value; // An explicit ETH amount to send to the resolver. This is important to prevent accidental user errors.\n}\n\n/// @notice A struct representing the full arguments of the attestation request.\nstruct AttestationRequest {\n    bytes32 schema; // The unique identifier of the schema.\n    AttestationRequestData data; // The arguments of the attestation request.\n}\n\n/// @notice A struct representing the full arguments of the full delegated attestation request.\nstruct DelegatedAttestationRequest {\n    bytes32 schema; // The unique identifier of the schema.\n    AttestationRequestData data; // The arguments of the attestation request.\n    Signature signature; // The ECDSA signature data.\n    address attester; // The attesting account.\n    uint64 deadline; // The deadline of the signature/request.\n}\n\n/// @notice A struct representing the full arguments of the multi attestation request.\nstruct MultiAttestationRequest {\n    bytes32 schema; // The unique identifier of the schema.\n    AttestationRequestData[] data; // The arguments of the attestation request.\n}\n\n/// @notice A struct representing the full arguments of the delegated multi attestation request.\nstruct MultiDelegatedAttestationRequest {\n    bytes32 schema; // The unique identifier of the schema.\n    AttestationRequestData[] data; // The arguments of the attestation requests.\n    Signature[] signatures; // The ECDSA signatures data. Please note that the signatures are assumed to be signed with increasing nonces.\n    address attester; // The attesting account.\n    uint64 deadline; // The deadline of the signature/request.\n}\n\n/// @notice A struct representing the arguments of the revocation request.\nstruct RevocationRequestData {\n    bytes32 uid; // The UID of the attestation to revoke.\n    uint256 value; // An explicit ETH amount to send to the resolver. This is important to prevent accidental user errors.\n}\n\n/// @notice A struct representing the full arguments of the revocation request.\nstruct RevocationRequest {\n    bytes32 schema; // The unique identifier of the schema.\n    RevocationRequestData data; // The arguments of the revocation request.\n}\n\n/// @notice A struct representing the arguments of the full delegated revocation request.\nstruct DelegatedRevocationRequest {\n    bytes32 schema; // The unique identifier of the schema.\n    RevocationRequestData data; // The arguments of the revocation request.\n    Signature signature; // The ECDSA signature data.\n    address revoker; // The revoking account.\n    uint64 deadline; // The deadline of the signature/request.\n}\n\n/// @notice A struct representing the full arguments of the multi revocation request.\nstruct MultiRevocationRequest {\n    bytes32 schema; // The unique identifier of the schema.\n    RevocationRequestData[] data; // The arguments of the revocation request.\n}\n\n/// @notice A struct representing the full arguments of the delegated multi revocation request.\nstruct MultiDelegatedRevocationRequest {\n    bytes32 schema; // The unique identifier of the schema.\n    RevocationRequestData[] data; // The arguments of the revocation requests.\n    Signature[] signatures; // The ECDSA signatures data. Please note that the signatures are assumed to be signed with increasing nonces.\n    address revoker; // The revoking account.\n    uint64 deadline; // The deadline of the signature/request.\n}\n\n/// @title IEAS\n/// @notice EAS - Ethereum Attestation Service interface.\ninterface IEAS is ISemver {\n    /// @notice Emitted when an attestation has been made.\n    /// @param recipient The recipient of the attestation.\n    /// @param attester The attesting account.\n    /// @param uid The UID of the new attestation.\n    /// @param schemaUID The UID of the schema.\n    event Attested(address indexed recipient, address indexed attester, bytes32 uid, bytes32 indexed schemaUID);\n\n    /// @notice Emitted when an attestation has been revoked.\n    /// @param recipient The recipient of the attestation.\n    /// @param attester The attesting account.\n    /// @param schemaUID The UID of the schema.\n    /// @param uid The UID the revoked attestation.\n    event Revoked(address indexed recipient, address indexed attester, bytes32 uid, bytes32 indexed schemaUID);\n\n    /// @notice Emitted when a data has been timestamped.\n    /// @param data The data.\n    /// @param timestamp The timestamp.\n    event Timestamped(bytes32 indexed data, uint64 indexed timestamp);\n\n    /// @notice Emitted when a data has been revoked.\n    /// @param revoker The address of the revoker.\n    /// @param data The data.\n    /// @param timestamp The timestamp.\n    event RevokedOffchain(address indexed revoker, bytes32 indexed data, uint64 indexed timestamp);\n\n    /// @notice Returns the address of the global schema registry.\n    /// @return The address of the global schema registry.\n    function getSchemaRegistry() external view returns (ISchemaRegistry);\n\n    /// @notice Attests to a specific schema.\n    /// @param request The arguments of the attestation request.\n    /// @return The UID of the new attestation.\n    ///\n    /// Example:\n    ///     attest({\n    ///         schema: \"0facc36681cbe2456019c1b0d1e7bedd6d1d40f6f324bf3dd3a4cef2999200a0\",\n    ///         data: {\n    ///             recipient: \"0xdEADBeAFdeAdbEafdeadbeafDeAdbEAFdeadbeaf\",\n    ///             expirationTime: 0,\n    ///             revocable: true,\n    ///             refUID: \"0x0000000000000000000000000000000000000000000000000000000000000000\",\n    ///             data: \"0xF00D\",\n    ///             value: 0\n    ///         }\n    ///     })\n    function attest(AttestationRequest calldata request) external payable returns (bytes32);\n\n    /// @notice Attests to a specific schema via the provided ECDSA signature.\n    /// @param delegatedRequest The arguments of the delegated attestation request.\n    /// @return The UID of the new attestation.\n    ///\n    /// Example:\n    ///     attestByDelegation({\n    ///         schema: '0x8e72f5bc0a8d4be6aa98360baa889040c50a0e51f32dbf0baa5199bd93472ebc',\n    ///         data: {\n    ///             recipient: '0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266',\n    ///             expirationTime: 1673891048,\n    ///             revocable: true,\n    ///             refUID: '0x0000000000000000000000000000000000000000000000000000000000000000',\n    ///             data: '0x1234',\n    ///             value: 0\n    ///         },\n    ///         signature: {\n    ///             v: 28,\n    ///             r: '0x148c...b25b',\n    ///             s: '0x5a72...be22'\n    ///         },\n    ///         attester: '0xc5E8740aD971409492b1A63Db8d83025e0Fc427e',\n    ///         deadline: 1673891048\n    ///     })\n    function attestByDelegation(\n        DelegatedAttestationRequest calldata delegatedRequest\n    ) external payable returns (bytes32);\n\n    /// @notice Attests to multiple schemas.\n    /// @param multiRequests The arguments of the multi attestation requests. The requests should be grouped by distinct\n    ///     schema ids to benefit from the best batching optimization.\n    /// @return The UIDs of the new attestations.\n    ///\n    /// Example:\n    ///     multiAttest([{\n    ///         schema: '0x33e9094830a5cba5554d1954310e4fbed2ef5f859ec1404619adea4207f391fd',\n    ///         data: [{\n    ///             recipient: '0xdEADBeAFdeAdbEafdeadbeafDeAdbEAFdeadbeaf',\n    ///             expirationTime: 1673891048,\n    ///             revocable: true,\n    ///             refUID: '0x0000000000000000000000000000000000000000000000000000000000000000',\n    ///             data: '0x1234',\n    ///             value: 1000\n    ///         },\n    ///         {\n    ///             recipient: '0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266',\n    ///             expirationTime: 0,\n    ///             revocable: false,\n    ///             refUID: '0x480df4a039efc31b11bfdf491b383ca138b6bde160988222a2a3509c02cee174',\n    ///             data: '0x00',\n    ///             value: 0\n    ///         }],\n    ///     },\n    ///     {\n    ///         schema: '0x5ac273ce41e3c8bfa383efe7c03e54c5f0bff29c9f11ef6ffa930fc84ca32425',\n    ///         data: [{\n    ///             recipient: '0xdEADBeAFdeAdbEafdeadbeafDeAdbEAFdeadbeaf',\n    ///             expirationTime: 0,\n    ///             revocable: true,\n    ///             refUID: '0x75bf2ed8dca25a8190c50c52db136664de25b2449535839008ccfdab469b214f',\n    ///             data: '0x12345678',\n    ///             value: 0\n    ///         },\n    ///     }])\n    function multiAttest(MultiAttestationRequest[] calldata multiRequests) external payable returns (bytes32[] memory);\n\n    /// @notice Attests to multiple schemas using via provided ECDSA signatures.\n    /// @param multiDelegatedRequests The arguments of the delegated multi attestation requests. The requests should be\n    ///     grouped by distinct schema ids to benefit from the best batching optimization.\n    /// @return The UIDs of the new attestations.\n    ///\n    /// Example:\n    ///     multiAttestByDelegation([{\n    ///         schema: '0x8e72f5bc0a8d4be6aa98360baa889040c50a0e51f32dbf0baa5199bd93472ebc',\n    ///         data: [{\n    ///             recipient: '0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266',\n    ///             expirationTime: 1673891048,\n    ///             revocable: true,\n    ///             refUID: '0x0000000000000000000000000000000000000000000000000000000000000000',\n    ///             data: '0x1234',\n    ///             value: 0\n    ///         },\n    ///         {\n    ///             recipient: '0xdEADBeAFdeAdbEafdeadbeafDeAdbEAFdeadbeaf',\n    ///             expirationTime: 0,\n    ///             revocable: false,\n    ///             refUID: '0x0000000000000000000000000000000000000000000000000000000000000000',\n    ///             data: '0x00',\n    ///             value: 0\n    ///         }],\n    ///         signatures: [{\n    ///             v: 28,\n    ///             r: '0x148c...b25b',\n    ///             s: '0x5a72...be22'\n    ///         },\n    ///         {\n    ///             v: 28,\n    ///             r: '0x487s...67bb',\n    ///             s: '0x12ad...2366'\n    ///         }],\n    ///         attester: '0x1D86495b2A7B524D747d2839b3C645Bed32e8CF4',\n    ///         deadline: 1673891048\n    ///     }])\n    function multiAttestByDelegation(\n        MultiDelegatedAttestationRequest[] calldata multiDelegatedRequests\n    ) external payable returns (bytes32[] memory);\n\n    /// @notice Revokes an existing attestation to a specific schema.\n    /// @param request The arguments of the revocation request.\n    ///\n    /// Example:\n    ///     revoke({\n    ///         schema: '0x8e72f5bc0a8d4be6aa98360baa889040c50a0e51f32dbf0baa5199bd93472ebc',\n    ///         data: {\n    ///             uid: '0x101032e487642ee04ee17049f99a70590c735b8614079fc9275f9dd57c00966d',\n    ///             value: 0\n    ///         }\n    ///     })\n    function revoke(RevocationRequest calldata request) external payable;\n\n    /// @notice Revokes an existing attestation to a specific schema via the provided ECDSA signature.\n    /// @param delegatedRequest The arguments of the delegated revocation request.\n    ///\n    /// Example:\n    ///     revokeByDelegation({\n    ///         schema: '0x8e72f5bc0a8d4be6aa98360baa889040c50a0e51f32dbf0baa5199bd93472ebc',\n    ///         data: {\n    ///             uid: '0xcbbc12102578c642a0f7b34fe7111e41afa25683b6cd7b5a14caf90fa14d24ba',\n    ///             value: 0\n    ///         },\n    ///         signature: {\n    ///             v: 27,\n    ///             r: '0xb593...7142',\n    ///             s: '0x0f5b...2cce'\n    ///         },\n    ///         revoker: '0x244934dd3e31bE2c81f84ECf0b3E6329F5381992',\n    ///         deadline: 1673891048\n    ///     })\n    function revokeByDelegation(DelegatedRevocationRequest calldata delegatedRequest) external payable;\n\n    /// @notice Revokes existing attestations to multiple schemas.\n    /// @param multiRequests The arguments of the multi revocation requests. The requests should be grouped by distinct\n    ///     schema ids to benefit from the best batching optimization.\n    ///\n    /// Example:\n    ///     multiRevoke([{\n    ///         schema: '0x8e72f5bc0a8d4be6aa98360baa889040c50a0e51f32dbf0baa5199bd93472ebc',\n    ///         data: [{\n    ///             uid: '0x211296a1ca0d7f9f2cfebf0daaa575bea9b20e968d81aef4e743d699c6ac4b25',\n    ///             value: 1000\n    ///         },\n    ///         {\n    ///             uid: '0xe160ac1bd3606a287b4d53d5d1d6da5895f65b4b4bab6d93aaf5046e48167ade',\n    ///             value: 0\n    ///         }],\n    ///     },\n    ///     {\n    ///         schema: '0x5ac273ce41e3c8bfa383efe7c03e54c5f0bff29c9f11ef6ffa930fc84ca32425',\n    ///         data: [{\n    ///             uid: '0x053d42abce1fd7c8fcddfae21845ad34dae287b2c326220b03ba241bc5a8f019',\n    ///             value: 0\n    ///         },\n    ///     }])\n    function multiRevoke(MultiRevocationRequest[] calldata multiRequests) external payable;\n\n    /// @notice Revokes existing attestations to multiple schemas via provided ECDSA signatures.\n    /// @param multiDelegatedRequests The arguments of the delegated multi revocation attestation requests. The requests\n    ///     should be grouped by distinct schema ids to benefit from the best batching optimization.\n    ///\n    /// Example:\n    ///     multiRevokeByDelegation([{\n    ///         schema: '0x8e72f5bc0a8d4be6aa98360baa889040c50a0e51f32dbf0baa5199bd93472ebc',\n    ///         data: [{\n    ///             uid: '0x211296a1ca0d7f9f2cfebf0daaa575bea9b20e968d81aef4e743d699c6ac4b25',\n    ///             value: 1000\n    ///         },\n    ///         {\n    ///             uid: '0xe160ac1bd3606a287b4d53d5d1d6da5895f65b4b4bab6d93aaf5046e48167ade',\n    ///             value: 0\n    ///         }],\n    ///         signatures: [{\n    ///             v: 28,\n    ///             r: '0x148c...b25b',\n    ///             s: '0x5a72...be22'\n    ///         },\n    ///         {\n    ///             v: 28,\n    ///             r: '0x487s...67bb',\n    ///             s: '0x12ad...2366'\n    ///         }],\n    ///         revoker: '0x244934dd3e31bE2c81f84ECf0b3E6329F5381992',\n    ///         deadline: 1673891048\n    ///     }])\n    function multiRevokeByDelegation(\n        MultiDelegatedRevocationRequest[] calldata multiDelegatedRequests\n    ) external payable;\n\n    /// @notice Timestamps the specified bytes32 data.\n    /// @param data The data to timestamp.\n    /// @return The timestamp the data was timestamped with.\n    function timestamp(bytes32 data) external returns (uint64);\n\n    /// @notice Timestamps the specified multiple bytes32 data.\n    /// @param data The data to timestamp.\n    /// @return The timestamp the data was timestamped with.\n    function multiTimestamp(bytes32[] calldata data) external returns (uint64);\n\n    /// @notice Revokes the specified bytes32 data.\n    /// @param data The data to timestamp.\n    /// @return The timestamp the data was revoked with.\n    function revokeOffchain(bytes32 data) external returns (uint64);\n\n    /// @notice Revokes the specified multiple bytes32 data.\n    /// @param data The data to timestamp.\n    /// @return The timestamp the data was revoked with.\n    function multiRevokeOffchain(bytes32[] calldata data) external returns (uint64);\n\n    /// @notice Returns an existing attestation by UID.\n    /// @param uid The UID of the attestation to retrieve.\n    /// @return The attestation data members.\n    function getAttestation(bytes32 uid) external view returns (Attestation memory);\n\n    /// @notice Checks whether an attestation exists.\n    /// @param uid The UID of the attestation to retrieve.\n    /// @return Whether an attestation exists.\n    function isAttestationValid(bytes32 uid) external view returns (bool);\n\n    /// @notice Returns the timestamp that the specified data was timestamped with.\n    /// @param data The data to query.\n    /// @return The timestamp the data was timestamped with.\n    function getTimestamp(bytes32 data) external view returns (uint64);\n\n    /// @notice Returns the timestamp that the specified data was timestamped with.\n    /// @param data The data to query.\n    /// @return The timestamp the data was timestamped with.\n    function getRevokeOffchain(address revoker, bytes32 data) external view returns (uint64);\n}\n"
    },
    "src/interfaces/IUserRegistry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title IUserRegistry\n * @author Libre\n * @notice Interface for managing user wallets and their association with investor/dealer IDs.\n * @dev Provides functions for adding wallets, retrieving wallets, and mapping wallets to user IDs.\n */\ninterface IUserRegistry {\n    /**\n     * @notice Thrown when the wallet address being added is already associated with another user ID.\n     */\n    error IUserRegistry_WalletAlreadyClaimed();\n\n    /**\n     * @notice Thrown when the provided signature fails to verify ownership of the wallet address.\n     */\n    error IUserRegistry_WalletOwnershipVerificationFailure();\n\n    /**\n     * @notice Thrown when the provided wallet signature has expired.\n     */\n    error IUserRegistry_WalletSignatureExpired();\n\n    /**\n     * @notice Thrown when the provided wallet address to add is blacklisted.\n     */\n    error IUserRegistry_WalletBlacklisted();\n\n    /**\n     * @notice Emited when secondary wallet is removed\n     * @param wallet User wallet address\n     */\n    event WalletAdded(address indexed wallet);\n\n    /**\n     * @notice Emited when secondary wallet is removed\n     * @param wallet User wallet address\n     */\n    event WalletRemoved(address indexed wallet);\n\n    /**\n     * @notice Adds a new investor to the registry\n     * @param _userId The ID of the user.\n     * @param _wallet The wallet address to associate with the user ID.\n     * @param _role The role used by the caller.\n     */\n    function addWallet(bytes32 _userId, address _wallet, bytes32 _role) external;\n\n    /**\n     * @notice Removes a wallet from the registry\n     * @param _wallet The wallet address to remove.\n     * @param _role The role used by the caller.\n     * @return The user ID that the wallet was removed from\n     */\n    function removeWallet(address _wallet, bytes32 _role) external returns (bytes32);\n\n    /**\n     * @notice Get Investor/Dealer array of wallets\n     * @param _userId Investor/Dealer ID\n     */\n    function getWallets(bytes32 _userId) external view returns (address[] memory);\n\n    /**\n     * @notice Get Investor/Dealer ID\n     * @param _wallet Investor/Dealer address\n     */\n    function getIdFromWallet(address _wallet) external view returns (bytes32);\n}\n"
    },
    "src/interfaces/IInvestorRegistry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {IERC20MetadataUpgradeable} from\n    \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\n\nimport {IEAS, AttestationRequestData} from \"eas-contracts/IEAS.sol\";\nimport {IRiscZeroVerifier} from \"risc0/IRiscZeroVerifier.sol\";\n\nimport {IBaseRegistry} from \"src/interfaces/IBaseRegistry.sol\";\nimport {IRoleRegistry} from \"src/interfaces/IRoleRegistry.sol\";\nimport {IInstrumentRegistry} from \"src/interfaces/IInstrumentRegistry.sol\";\nimport {IDealerRegistry} from \"src/interfaces/IDealerRegistry.sol\";\nimport {IOperationsEngine} from \"src/interfaces/IOperationsEngine.sol\";\nimport {IUserRegistry} from \"src/interfaces/IUserRegistry.sol\";\nimport {IGatewayManager} from \"src/interfaces/IGatewayManager.sol\";\nimport {IEternalRegistryStorage} from \"src/interfaces/IEternalRegistryStorage.sol\";\nimport {OrderProofData, SteelProofData, CredentialProofData} from \"src/utils/Types.sol\";\nimport {IRiscZeroVerifier} from \"risc0/IRiscZeroVerifier.sol\";\n\n/**\n * @title IInvestorRegistry\n * @author Libre\n * @notice Interface for managing investors, including adding new investors, managing credentials, and verifying subscriptions.\n * It integrates with Ethereum Attestation Service (EAS) and zk-verifiers to ensure security and compliance.\n */\ninterface IInvestorRegistry is IBaseRegistry, IUserRegistry {\n    /// @notice Thrown when an operation is not permitted due to insufficient privileges.\n    error IInvestorRegistry_OperationNotPermitted();\n\n    /// @notice Thrown when the sender is not the dealer associated with the specified investor.\n    error IInvestorRegistry_NotInvestorsDealer();\n\n    /// @notice Thrown when the caller is not the Operations Engine.\n    error IInvestorRegistry_NotOperationsEngine();\n\n    /// @notice Thrown when the caller is not the Jurisdiction Registry.\n    error IInvestorRegistry_NotJurisdictionRegistry();\n\n    /// @notice Thrown when attempting to add an investor who is already registered.\n    error IInvestorRegistry_AlreadyAnInvestor();\n\n    /// @notice Thrown when the sender does not have the Contract Manager role.\n    error IInvestorRegistry_NoContractManagerRole();\n\n    /// @notice Thrown when the Resolver Verifier address is empty or invalid.\n    error IInvestorRegistry_EmptyResolverVerifier();\n\n    /// @notice Thrown when the provided zk program image IDs are empty.\n    error IInvestorRegistry_EmptyImageIDs();\n\n    /// @notice Thrown when the sender does not have the Attester role.\n    error IInvestorRegistry_NoAttesterRole();\n\n    /// @notice Thrown when attempting to access a schema that has not been set.\n    error IInvestorRegistry_SchemaNotSet();\n\n    /// @notice Thrown when attempting to access a credential that does not exist.\n    error IInvestorRegistry_NonExistingCredential();\n\n    /// @notice Thrown when the credential is found to be invalid or revoked.\n    error IInvestorRegistry_CredentialInvalid();\n\n    /// @notice Thrown when the Investor Id doesn't match with the attestation's investor Id.\n    error IInvestorRegistry_MismatchInvestorId();\n\n    /// @notice Thrown when a credential does not grant access to the specified instrument.\n    error IInvestorRegistry_InstrumentCredentialInvalid();\n\n    /// @notice Thrown when attempting to revoke access to instruments that are not part of the credential.\n    error IInvestorRegistry_InstrumentsToRevokeNotInCredential();\n\n    /// @notice Thrown when there is a mismatch in the policy viewer proof.\n    error IInvestorRegistry_PolicyViewerProofMismatch();\n\n    /// @notice Thrown when an invalid dealer ID is provided.\n    error IInvestorRegistry_InvalidDealerId();\n\n    // Events\n    /**\n     * @notice Emitted when a new investor is added to the registry.\n     * @param investorId The unique identifier of the new investor.\n     * @param wallet The initial wallet address associated with the investor.\n     */\n    event NewInvestorAdded(bytes32 investorId, address wallet);\n\n    /**\n     * @notice Emitted when a credential is set for an investor.\n     * @param investorId The unique identifier of the investor.\n     * @param instrumentIds The list of instrument IDs included in the credential.\n     */\n    event InvestorRegistryCredentialSet(bytes32 investorId, bytes32[] instrumentIds);\n\n    /**\n     * @notice Emitted when a credential is revoked for an investor.\n     * @param investorId The unique identifier of the investor.\n     * @param instrumentIds The list of instrument IDs that have been revoked.\n     */\n    event InvestorRegistryCredentialRevoked(bytes32 investorId, bytes32[] instrumentIds);\n\n    /**\n     * @notice Emitted when the Resolver Verifier is updated.\n     * @param resolverVerifierAddress The address of the new Resolver Verifier.\n     */\n    event InvestorRegistryResolverVerifierChanged(address resolverVerifierAddress);\n\n    /**\n     * @notice Emitted when the zk program image IDs are updated.\n     * @param credentialImageID The new image ID for the credential zk program.\n     * @param subscriptionImageID The new image ID for the subscription zk program.\n     */\n    event InvestorRegistryImageIDsChanged(bytes32 credentialImageID, bytes32 subscriptionImageID);\n\n    /**\n     * @notice Initialize the registry\n     * @param _roleRegistry Address of the Role Registry\n     * @param _instrumentRegistry Address of the Instrument Registry\n     * @param _dealerRegistry Address of the Dealer Registry\n     * @param _jurisdictionRegistry Address of the Jurisdiction Registry\n     * @param _operationsEngine Address of the Operations Engine\n     * @param _eas Address of the Ethereum Attestation Service contract\n     * @param _gatewayManager Address of the gateway manager contract\n     * @param _resolverVerifier Address of the Resolver Verifier\n     * @param _policyViewer Address of the Policy Viewer\n     */\n    function initialize(\n        IRoleRegistry _roleRegistry,\n        IInstrumentRegistry _instrumentRegistry,\n        IDealerRegistry _dealerRegistry,\n        IEternalRegistryStorage _jurisdictionRegistry,\n        IOperationsEngine _operationsEngine,\n        IEAS _eas,\n        IGatewayManager _gatewayManager,\n        address _resolverVerifier,\n        address _policyViewer\n    ) external;\n\n    /**\n     * @notice Adds a new investor to the registry\n     * @param _senderRole Role the sender claims to have\n     * @param _investorId ID of the investor\n     * @param _wallet Default address of the investor\n     * @param _dealerId ID of the dealer\n     */\n    function addInvestor(bytes32 _senderRole, bytes32 _investorId, address _wallet, bytes32 _dealerId) external;\n\n    /**\n     * @notice Checks a subscription is allowed into the instrument\n     * @param _proof proof data for zk verifier\n     */\n    function checkSubscription(OrderProofData calldata _proof) external view;\n\n    /**\n     * @notice Replaces the ResolverVerifier contract with a new version, renewing the schema in the process\n     * @param _resolverVerifier address of new resolverVerifier\n     */\n    function configureResolverVerifier(address _resolverVerifier) external;\n\n    /**\n     * @notice Changes the zk program image IDs to use with the verifier\n     * @param _credentialImageID new image ID for the credential zk program\n     * @param _subscriptionImageID new image ID for the subscription zk program\n     */\n    function configureImageIDs(bytes32 _credentialImageID, bytes32 _subscriptionImageID) external;\n\n    /**\n     * @notice Creates a new investor credential or updates an existing/revoked one\n     * @param _proof contains data for setting the credential, including the zk-proof to verify\n     * @dev When updating credential, seal should contain the proof for new instruments, while\n     * the journal should include existing ones to be kept, bridge new credential via gateway manager\n     */\n    function setCredential(CredentialProofData calldata _proof) external;\n\n    /**\n     * @notice Revokes an investor credential, or access to certain instruments, bridge revoked credential via gateway manager\n     * @param _investorId Id of the investor\n     * @param _instrumentIds Instruments to revoke access from (entire credential revoked if left empty)\n     */\n    function revokeCredential(bytes32 _investorId, bytes32[] calldata _instrumentIds) external;\n\n    /**\n     * @notice Checks if the investor has a valid credential\n     * @param _investorId Id of the investor\n     */\n    function checkCredential(bytes32 _investorId) external view;\n\n    /**\n     * @notice Checks if the investor has a valid credential granting access to the instrument\n     * @param _investorId Id of the investor\n     * @param _instrumentId Id of the instrument\n     */\n    function checkCredentialInstrument(bytes32 _investorId, bytes32 _instrumentId) external view;\n\n    /**\n     * @notice Get dealer id of an investor\n     * @param _investorId The ID of the investor\n     * @return dealerId_ Id of the dealer associated to the investor\n     */\n    function getDealer(bytes32 _investorId) external view returns (bytes32 dealerId_);\n\n    /**\n     * Used by the ResolverVerifier to fetch the proof data for the current attestation\n     * @return Proof Data\n     */\n    function getTempSteelProofData() external view returns (SteelProofData memory);\n}\n"
    },
    "src/interfaces/IOperationsEngine.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {IInvestorRegistry} from \"src/interfaces/IInvestorRegistry.sol\";\nimport {IFundRegistry} from \"src/interfaces/IFundRegistry.sol\";\nimport {IDealerRegistry} from \"src/interfaces/IDealerRegistry.sol\";\nimport {IInstrumentRegistry} from \"src/interfaces/IInstrumentRegistry.sol\";\nimport {IRoleRegistry} from \"src/interfaces/IRoleRegistry.sol\";\nimport {IEternalRegistryStorage} from \"src/interfaces/IEternalRegistryStorage.sol\";\nimport {OPERATIONS} from \"./operations/IOperationModule.sol\";\n\n/**\n * @title Operations Engine Interface\n * @author Libre\n * @notice Defines the interface for managing modules, operations, and dependencies in the system.\n * @dev Includes error definitions, events, and function signatures for interacting with the operations engine.\n */\ninterface IOperationsEngine {\n    // Enums\n    /**\n     * @notice Defines the type of ID for the module check, modules are either tracking ones or check ones.\n     */\n    enum IdType {\n        NULL,\n        INSTRUMENT_CHECK,\n        FEE,\n        TRACKING\n    }\n\n    /**\n     * @notice Defines the type of check a module performs.\n     */\n    enum CHECK_TYPE {\n        BOOLEAN,\n        NUMERIC_MIN,\n        NUMERIC_MAX\n    }\n\n    // Errors\n    /**\n     * @dev Revert when the tracking module reverts for any reason\n     */\n    error IOperationsEngine_TrackingModuleFailure();\n\n    /**\n     * @dev Revert when the fee module reverts for any reason\n     */\n    error IOperationsEngine_FeeModuleFailure();\n\n    /**\n     * @dev Revert when the module address provided is invalid.\n     */\n    error IOperationsEngine_InvalidModuleAddress();\n\n    /**\n     * @dev Revert when the module is not of the Libre type.\n     */\n    error IOperationsEngine_ModuleIsNotLibreType();\n\n    /**\n     * @dev Revert when a lending module cannot be disabled.\n     */\n    error IOperationsEngine_LendingModuleDisable();\n\n    /**\n     * @dev Revert when dependencies required for an operation are missing.\n     */\n    error IOperationsEngine_MissingDependencies();\n\n    /**\n     * @dev Revert when an invalid check type is used.\n     */\n    error IOperationsEngine_InvalidCheckType();\n\n    /**\n     * @dev Revert when the caller is not authorized to perform the action.\n     */\n    error IOperationsEngine_CallerNotAuthorized();\n\n    /**\n     * @dev Revert when adding a module that is already been added.\n     */\n    error IOperationsEngine_ModuleAlreadyAdded();\n\n    /**\n     * @dev Revert when module already enabled for the same instrument.\n     */\n    error IOperationsEngine_ModuleAlreadyEnabled();\n\n    /**\n     * @dev Revert when a module to be disabled for an instrument is not enabled\n     */\n    error IOperationsEngine_ModuleNotEnabled();\n\n    // Events\n    /**\n     * @notice Emitted when a module is added to the available modules library.\n     * @param moduleAddress Address of the module that was added.\n     */\n    event ModuleAdded(address indexed moduleAddress);\n\n    /**\n     * @notice Emitted when a module is removed from the available modules library.\n     * @param moduleAddress Address of the module that was removed.\n     */\n    event ModuleRemoved(address indexed moduleAddress);\n\n    /**\n     * @notice Emitted when a module is enabled for a specific instrument.\n     * @param moduleAddress Address of the module that was enabled.\n     * @param instrumentId Id of the instrument for which the module was enabled.\n     */\n    event ModuleEnabled(address indexed moduleAddress, bytes32 instrumentId);\n\n    /**\n     * @notice Emitted when a module is disabled for a specific instrument.\n     * @param moduleAddress Address of the module that was disabled.\n     * @param instrumentId Id of the instrument for which the module was disabled.\n     */\n    event ModuleDisabled(address indexed moduleAddress, bytes32 instrumentId);\n\n    /**\n     * @dev Event emitted when a fee is applied.\n     * @param instrumentId The ID of the instrument.\n     * @param orderId The ID of the order.\n     * @param feeModule The address of the fee module.\n     * @param feeAmount The amount of the fee applied.\n     */\n    event FeeApplied(bytes32 indexed instrumentId, uint256 orderId, address feeModule, uint256 feeAmount);\n\n    //functions\n\n    /**\n     * @notice Initializes the Rules Engine with necessary registries.\n     * @param _investorRegistry Address of the Investor Registry.\n     * @param _dealerRegistry Address of the Dealer Registry.\n     * @param _fundRegistry Address of the Fund Registry.\n     * @param _instrumentRegistry Address of the Instrument Registry.\n     * @param _roleRegistry Address of the Role Registry.\n     * @param _jurisdictionRegistry Address of the Jurisdiction Registry.\n     */\n    function initialize(\n        IInvestorRegistry _investorRegistry,\n        IDealerRegistry _dealerRegistry,\n        IFundRegistry _fundRegistry,\n        IInstrumentRegistry _instrumentRegistry,\n        IRoleRegistry _roleRegistry,\n        IEternalRegistryStorage _jurisdictionRegistry\n    ) external;\n\n    /**\n     * @notice Gets the addresses for registered check modules implementing the given operation.\n     * @param _id Id of the dealer or instrument the modules belong to.\n     * @param _operation Operation implemented in modules.\n     * @return An array of addresses of modules implementing the given operation.\n     */\n    function getCheckModules(bytes32 _id, OPERATIONS _operation) external view returns (address[] memory);\n\n    /**\n     * @notice Gets the addresses for registered fee modules implementing the given operation.\n     * @param _id Id of the dealer or instrument the modules belong to.\n     * @param _operation Operation implemented in modules.\n     * @return An array of addresses of modules implementing the given operation.\n     */\n    function getFeeModules(bytes32 _id, OPERATIONS _operation) external view returns (address[] memory);\n\n    /**\n     * @notice Gets the addresses for registered tracking modules implementing the given operation.\n     * @param _id Id of the dealer or instrument the modules belong to.\n     * @param _operation Operation implemented in modules.\n     * @return An array of addresses of modules implementing the given operation.\n     */\n    function getTrackingModules(bytes32 _id, OPERATIONS _operation) external view returns (address[] memory);\n\n    /**\n     * @notice Adds a module to the available modules library.\n     * @param _moduleAddress Address of the module to add.\n     * @param _role Role required to add the module.\n     * @param _idType Type of the module.\n     */\n    function addModule(address _moduleAddress, bytes32 _role, IdType _idType) external;\n\n    /**\n     * @notice Removes a module from the available modules library.\n     * @param _moduleAddress Address of the module to remove.\n     * @param _role Role required to remove the module.\n     */\n    function removeModule(address _moduleAddress, bytes32 _role) external;\n\n    /**\n     * @notice Enables a module for a specific instrument.\n     * @param _moduleAddress Address of the module to enable.\n     * @param _instrumentId Id of the instrument.\n     * @param _role Role required to enable the module.\n     */\n    function enableModule(address _moduleAddress, bytes32 _instrumentId, bytes32 _role) external;\n\n    /**\n     * @notice Disables a module for a specific instrument.\n     * @param _moduleAddress Address of the module to disable.\n     * @param _instrumentId Id of the instrument.\n     * @param _role Role required to disable the module.\n     * @dev Lending modules cannot be disabled, because at least one module must be enabled at all times.\n     * Instead, the lending module can be replaced with another lending module by enabling the new module.\n     */\n    function disableModule(address _moduleAddress, bytes32 _instrumentId, bytes32 _role) external;\n\n    /**\n     * @notice Checks if a module is available in the available modules library.\n     * @param _moduleAddress Address of the module to check.\n     * @return True if the module is available, false otherwise.\n     */\n    function isAvailableModule(address _moduleAddress) external view returns (bool);\n\n    /**\n     * @notice Checks if a module is enabled for a specific instrument.\n     * @param _id Id of the instrument.\n     * @param _moduleName Hash of the abi.encodePacked of the module name\n     * @return True if the module is enabled, false otherwise.\n     */\n    function hasModuleEnabled(bytes32 _id, bytes32 _moduleName) external view returns (bool);\n\n    /**\n     * @notice Function to be delegatecalled by the registry to perform the check\n     * @param _operation The operation to be checked\n     * @param _id The id of the operation\n     * @param _data Arbitrary data that can be used by the module to perform the check\n     * @return result memory Result of the check\n     */\n    function check(OPERATIONS _operation, bytes32 _id, bytes calldata _data) external returns (bytes memory result);\n\n    /**\n     * @notice Tracks the operation\n     * @param _operation The operation to track\n     * @param _id The id of the instrument or investor\n     * @param _data The data to track\n     * @return True if the tracking was successful, false otherwise\n     */\n    function track(OPERATIONS _operation, bytes32 _id, bytes memory _data) external returns (bool);\n\n    /**\n     * @notice Calculates the total fee amount to be deducted for a given operation and instrument.\n     * @dev Loops through all enabled fee modules for the given operation and instrument, calls them with the input data,\n     *      and sums up the returned fee amounts. Also emits `FeeApplied` events for each individual module fee.\n     *\n     * @param _operation The operation type (e.g., SETTLE_SUBSCRIPTION_PER_ORDER).\n     * @param _id The instrument ID for which the fees are being calculated.\n     * @param _data ABI-encoded parameters required for fee calculation. Must encode the following values in order:\n     *        - `uint256 _orderId`: Unique identifier of the order\n     *        - `bytes32 _investorId`: The ID of the investor associated with the order\n     *        - `uint256 _amountToSettle`: The current amount to be settled\n     *\n     * @return totalFee The total fee amount to be deducted across all enabled fee modules.\n     */\n    function calculateFees(OPERATIONS _operation, bytes32 _id, bytes memory _data)\n        external\n        returns (uint256 totalFee);\n}\n"
    },
    "src/interfaces/IRoleRegistry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {IAccessControlUpgradeable} from\n    \"openzeppelin-contracts-upgradeable/contracts/access/IAccessControlUpgradeable.sol\";\n\n/**\n * @title Roles Registry\n * @author Libre\n * @notice Store all the roles of the system as well as the permissions a user get by having each role.\n * @dev It is meant to be used for roles access validation in all the components of the system.\n */\ninterface IRoleRegistry is IAccessControlUpgradeable {\n    /**\n     * @notice Thrown when attempting to create a role that already exists.\n     */\n    error IRoleRegistry_RoleAlreadyExists();\n\n    /**\n     * @notice Thrown when attempting to grant a role that does not exist.\n     */\n    error IRoleRegistry_RoleDoesNotExist();\n\n    /**\n     * @notice Thrown when attempting to use a blacklisted wallet.\n     */\n    error IRoleRegistry_WalletBlacklisted();\n\n    /**\n     * @notice Used when a new role is created\n     * @param _role Parent role\n     * @param _subRole Newly created Role\n     */\n    event RoleCreated(bytes32 _role, bytes32 _subRole);\n\n    /**\n     * @notice Used when a contract manager is set\n     * @param _contract Contract managed\n     * @param _roleManager New contract manager role\n     */\n    event ContractManagerAdded(address _contract, bytes32 _roleManager);\n\n    /**\n     * @notice Used when a wallet is blacklisted\n     * @param _wallet Wallet blacklisted\n     */\n    event WalletBlacklisted(address _wallet);\n\n    /**\n     * @notice Used when a contract function access is granted\n     * @param _contract Contract managed\n     * @param _selector Selector of the funtion which access is modified\n     * @param _role Role getting access gratend\n     */\n    event AccessGranted(address _contract, bytes4 _selector, bytes32 _role);\n\n    /**\n     * @notice Used when a contract function access is revoked\n     * @param _contract Contract managed\n     * @param _selector Selector of the funtion which access is modified\n     * @param _role Role which access is revoked\n     */\n    event RevokedAccess(address _contract, bytes4 _selector, bytes32 _role);\n\n    /**\n     * @notice Used when a contract access is reset\n     * @param _contract Contract managed\n     * @param _timestamp Time when the reset is executed\n     */\n    event ResetedAccess(address _contract, uint256 _timestamp);\n\n    /**\n     * @notice Function to create subroles\n     * @param _role New role to create\n     * @param _adminRole Parent role of the newly created role\n     * @dev Caller needs to has role _adminRole\n     */\n    function createRole(bytes32 _role, bytes32 _adminRole) external;\n\n    /**\n     * @notice Set the role going to manage permissions in a specific contract\n     * @param _contract Address of the contract to where permissions are needed to be managed\n     * @param _roleManager Role in charge of managing the permissions\n     */\n    function setContractManager(address _contract, bytes32 _roleManager) external;\n\n    /**\n     * @notice Get the role that manages permissions in a specific contract\n     * @param _contract Address of the contract\n     */\n    function getContractManager(address _contract) external view returns (bytes32);\n\n    /**\n     * @notice Grant a role the right access a functionality of a contract\n     * @param _contract Contract where the access is granted\n     * @param _selector Functionality granted access for\n     * @param _role Role getting the access\n     */\n    function grantAccess(address _contract, bytes4 _selector, bytes32 _role) external;\n\n    /**\n     * @notice Prevent a role for having access to a functionality of a contract\n     * @param _contract Contract where the access is revoked\n     * @param _selector Functionality revoked access for\n     * @param _role Role losing the access\n     */\n    function revokeAccess(address _contract, bytes4 _selector, bytes32 _role) external;\n\n    /**\n     * @notice Revoke access to a functionality of a contract for all roles\n     * @param _contract Contract where the access is reset\n     * @param _selector Functionality reset access for\n     * @dev Cleans all the previously granted roles\n     */\n    function resetAccess(address _contract, bytes4 _selector) external;\n\n    /**\n     * @notice Blacklists a wallet.\n     * @param _wallet The wallet to blacklist.\n     */\n    function blacklistWallet(address _wallet) external;\n\n    /**\n     * @notice Check access of a role to a contract functionality\n     * @param _contract Contract where accessed\n     * @param _selector Functionality accessed\n     * @param _requestor Address attempting to access\n     * @param _role Role of the address attempting to access\n     */\n    function hasAccess(address _contract, bytes4 _selector, address _requestor, bytes32 _role)\n        external\n        view\n        returns (bool);\n\n    /**\n     * @notice Checks if a wallet is blacklisted.\n     * @param _wallet The wallet to check.\n     * @return Boolean indicating whether the wallet is blacklisted.\n     */\n    function isBlacklisted(address _wallet) external view returns (bool);\n}\n"
    },
    "src/interfaces/IInstrumentRegistry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {IERC20Metadata} from \"openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport {IBaseRegistry} from \"src/interfaces/IBaseRegistry.sol\";\nimport {IDealerRegistry} from \"src/interfaces/IDealerRegistry.sol\";\nimport {IFundRegistry} from \"src/interfaces/IFundRegistry.sol\";\nimport {IRoleRegistry} from \"src/interfaces/IRoleRegistry.sol\";\nimport {IInvestorRegistry} from \"src/interfaces/IInvestorRegistry.sol\";\nimport {IOperationsEngine} from \"src/interfaces/IOperationsEngine.sol\";\nimport {IEternalRegistryStorage} from \"src/interfaces/IEternalRegistryStorage.sol\";\n\n/**\n * @title IInstrumentRegistry\n * @author Libre\n * @notice Interface for managing instruments within a fund registry system.\n * Provides functionalities to initialize, add, and manage instruments, track their subscription and redemption periods,\n * update Net Asset Value (NAV) per share, and manage investor access.\n */\ninterface IInstrumentRegistry is IBaseRegistry {\n    /**\n     * @notice Thrown when attempting to add an instrument that already exists in the registry.\n     */\n    error IInstrumentRegistry_InstrumentAlreadyExists();\n\n    /**\n     * @notice Thrown when the specified instrument does not exist in the registry.\n     */\n    error IInstrumentRegistry_InstrumentDoesNotExist();\n\n    /**\n     * @notice Thrown when attempting to initialize an instrument that has already been initialized.\n     */\n    error IInstrumentRegistry_InstrumentAlreadyInitialized();\n\n    /**\n     * @notice Emited when a new instrument is added\n     * @param fundId Id of the fund where the instrument is added\n     * @param instrumentId Id of the new instrument\n     */\n    event NewFundInstrumentAdded(bytes32 indexed fundId, bytes32 indexed instrumentId);\n\n    /**\n     * @notice Emited when an instrument is initialized\n     * @param instrumentId Id of the new instrument\n     * @param settlementToken Address of the settlement token of the instrument\n     * @param securityToken Address of the deployed security token\n     * @param subscriptionBook Address of the deployed subscription book\n     * @param redemptionBook Address of the deployed redemption book\n     */\n    event FundInstrumentInitialized(\n        bytes32 indexed instrumentId,\n        address settlementToken,\n        address securityToken,\n        address subscriptionBook,\n        address redemptionBook\n    );\n\n    /**\n     * @notice Emited when an instrument is closed\n     * @param instrumentId Id of the instrument\n     */\n    event InstrumentClosed(bytes32 indexed instrumentId);\n\n    /**\n     * @notice Emited when an instrument is paused\n     * @param instrumentId Id of the instrument\n     * @param paused Y/N value indicating if the instrument is paused or not\n     */\n    event InstrumentPaused(bytes32 indexed instrumentId, bool paused);\n\n    /**\n     * @notice Emited when an investor's allowlist status is updated for an instrument\n     * @param instrumentId Id of the instrument\n     * @param investorId Id of the investor\n     * @param allowed Y/N value indicating if the investor is allowed or not\n     */\n    event InvestorAllowedUpdated(bytes32 indexed instrumentId, bytes32 indexed investorId, bool allowed);\n\n    /**\n     * @notice Initialize the registry\n     * @param _roleRegistry Address of the Role Registry\n     * @param _investorRegistry Address of the Investor Registry\n     * @param _dealerRegistry Address of the Dealer Registry\n     * @param _fundRegistry Address of the Fund Registry\n     * @param _jurisdictionRegistry Address of the Jurisdiction Registry\n     * @param _operationsEngine Address of the Rules Engine\n     */\n    function initialize(\n        IRoleRegistry _roleRegistry,\n        IInvestorRegistry _investorRegistry,\n        IDealerRegistry _dealerRegistry,\n        IFundRegistry _fundRegistry,\n        IEternalRegistryStorage _jurisdictionRegistry,\n        IOperationsEngine _operationsEngine\n    ) external;\n\n    /**\n     * @notice Adds a new fund instrument to the registry\n     * @dev _senderRole is ignored if the caller if the Fund Admin of the instrument\n     * @param _senderRole Role of the sender which allow the operation execution\n     * @param _instrumentId the instrument ID\n     * @param _fundId the fund ID\n     */\n    function addFundInstrument(bytes32 _senderRole, bytes32 _instrumentId, bytes32 _fundId) external;\n\n    /**\n     * @notice Adds a new instrument to the registry\n     * @dev _senderRole is ignored if the caller if the Fund Admin of the instrument\n     * @param _senderRole Role of the sender which allow the operation execution\n     * @param _instrumentId the instrument ID\n     * @param _settlementToken settlement token address\n     * @param _name the instrument token name\n     * @param _symbol the instrument token symbol\n     * @param _subscriptionBookImp The implementation of subscription book to be cloned\n     * @param _redemptionBookImp The implementation of redemption book to be cloned\n     * @param _stTokenImpl The implementation of security token implementation to be cloned\n     * @param _treasury The address of instrument treasury\n     * @param _policyViewerAddress The address of instrument policy viewer\n     */\n    function initializeFundInstrument(\n        bytes32 _senderRole,\n        bytes32 _fundId,\n        bytes32 _instrumentId,\n        address _settlementToken,\n        string memory _name,\n        string memory _symbol,\n        address _subscriptionBookImp,\n        address _redemptionBookImp,\n        address _stTokenImpl,\n        address _treasury,\n        address _policyViewerAddress\n    ) external;\n\n    /**\n     * @notice Close a fund instrument\n     * @param _senderRole Role of the sender which allow the operation execution\n     * @param _instrumentId The ID of the instrument\n     */\n    function closeFundInstrument(bytes32 _senderRole, bytes32 _instrumentId) external;\n\n    /**\n     * @notice Return the number of the current subscription period or\n     * 0 in case subscription is not started or infinite if subscriptions are done\n     * @dev Infinite is represented by type(uint256).max;\n     * @param _instrumentId Id of the instrument\n     * @return The current period of the subscription, the start & the end of it\n     */\n    function currentSubscriptionPeriod(bytes32 _instrumentId) external view returns (uint256, uint256, uint256);\n\n    /**\n     * @notice Return the number of the current redemption period or\n     * 0 in case redemption is not started or infinite if redemptions are done\n     * @param _instrumentId Id of the instrument\n     * @return The current period of the redemption, the start & the end of it\n     */\n    function currentRedemptionPeriod(bytes32 _instrumentId) external view returns (uint256, uint256, uint256);\n\n    /**\n     * @notice Sets a new value for the audited NAV per share of a fund\n     * @param _senderRole Role of the sender which allow the operation execution\n     * @param _instrumentId ID of the fund\n     * @param _newNavPerShare new value of the nav\n     * @dev Expressed with 6 decimals as it is in settlement tokens units\n     */\n    function updateAuditedNavPerShare(bytes32 _senderRole, bytes32 _instrumentId, uint256 _newNavPerShare) external;\n\n    /**\n     * @notice Allow investor for a specific instrument\n     * @param _instrumentId The ID of the instrument\n     * @param _investorId Id of the investor\n     * @param _allowed Y/N value indicating if the investor is allowed or not\n     * @param _senderRole Role of the sender\n     */\n    function allowInvestor(bytes32 _instrumentId, bytes32 _investorId, bool _allowed, bytes32 _senderRole) external;\n}\n"
    },
    "src/interfaces/IDealerRegistry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {IBaseRegistry} from \"src/interfaces/IBaseRegistry.sol\";\nimport {IRoleRegistry} from \"src/interfaces/IRoleRegistry.sol\";\nimport {IInvestorRegistry} from \"src/interfaces/IInvestorRegistry.sol\";\nimport {IUserRegistry} from \"src/interfaces/IUserRegistry.sol\";\nimport {IOperationsEngine} from \"src/interfaces/IOperationsEngine.sol\";\nimport {IInstrumentRegistry} from \"src/interfaces/IInstrumentRegistry.sol\";\n\n/**\n * @title IDealerRegistry\n * @notice Interface for managing dealers within the registry, including adding new dealers,\n * allowing dealers for specific instruments, and checking dealer permissions.\n * @dev Extends both `IBaseRegistry` and `IUserRegistry` for core registry and user management functionality.\n */\ninterface IDealerRegistry is IBaseRegistry, IUserRegistry {\n    /**\n     * @notice Thrown when attempting to add a dealer who is already registered.\n     */\n    error IDealerRegistry_AlreadyADealer();\n\n    /**\n     * @notice Thrown when invalid input parameters are provided.\n     */\n    error IDealerRegistry_InvalidInput();\n\n    /**\n     * @notice Thrown when the specified instrument does not exist in the registry.\n     */\n    error IDealerRegistry_NonExistingInstrument();\n\n    /**\n     * @notice Thrown when the dealer is not allowed for the specified instrument.\n     */\n    error IDealerRegistry_DealerNotAllowed();\n\n    /**\n     * @notice Emited when a new dealer is added\n     * @param dealerId Id of the new dealer\n     * @param wallet Initial wallet of the dealer\n     */\n    event NewDealerAdded(bytes32 dealerId, address wallet);\n\n    /**\n     * @notice Emited when an dealer's allowed status is updated\n     * @param dealerId Id of the dealer updated\n     * @param allowed Y/N if dealer is allowed for the instrument\n     */\n    event dealerAllowedUpdated(bytes32 dealerId, bytes32 instrumentId, bool allowed);\n\n    /**\n     * @notice Initialize the registry\n     * @param _roleRegistry Address of the role registry\n     */\n    function initialize(\n        IRoleRegistry _roleRegistry,\n        IOperationsEngine _operationsEngine,\n        IInvestorRegistry _investorRegistry,\n        IInstrumentRegistry _instrumentRegistry\n    ) external;\n\n    /**\n     * @notice Adds a new dealer to the registry\n     * @param _senderRole Role of the sender which allows the operation execution\n     * @param _dealerId ID of the dealer\n     * @param _wallet Wallet of the dealer\n     */\n    function addDealer(bytes32 _senderRole, bytes32 _dealerId, address _wallet) external;\n\n    /**\n     * @notice Allows a dealer for a specific instrument\n     * @param _senderRole Role of the sender which allows the operation execution\n     * @param _dealerId ID of the dealer\n     * @param _instrumentId ID of the instrument\n     * @param _allowed Y/N if dealer is allowed for the instrument\n     */\n    function allowDealer(bytes32 _senderRole, bytes32 _dealerId, bytes32 _instrumentId, bool _allowed) external;\n\n    /**\n     * @notice Returns if the dealer is allowed for a specific instrument\n     * @param _dealerId ID of the dealer\n     * @param _instrumentId ID of the instrument\n     * @return Bool indicating if dealer if allowed\n     */\n    function isDealerAllowed(bytes32 _dealerId, bytes32 _instrumentId) external view returns (bool);\n\n    /**\n     * @notice Reverts if the dealer is not allowed for a specific instrument\n     * @param _dealerId ID of the dealer\n     * @param _instrumentId ID of the instrument\n     */\n    function checkDealerAllowed(bytes32 _dealerId, bytes32 _instrumentId) external view;\n}\n"
    },
    "src/interfaces/IEternalRegistryStorage.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title IEternalRegistryStorage\n * @notice Interface for managing a flexible and extensible storage system, allowing various types of values to be\n * stored and retrieved for specific registry entries. Provides a robust and modular way to interact with registry data.\n * @dev Enables storage and retrieval of multiple data types (e.g., uint256, address, string, bool, bytes32) and\n * supports operations like batch updates, array manipulations, and role-based access control for data modifications.\n */\ninterface IEternalRegistryStorage {\n    /**\n     * @notice Thrown when attempting to modify a key that has been restricted.\n     */\n    error IEternalRegistryStorage_AttemptToSetARestrictedKey();\n\n    /**\n     * @notice Thrown when the length of the provided input arrays does not match.\n     */\n    error IEternalRegistryStorage_BatchLengthMismatch();\n\n    /**\n     * @notice Thrown when attempting to access an array index that is out of bounds.\n     */\n    error IEternalRegistryStorage_IndexShouldBeLessThanLengthOfTheArray();\n\n    /**\n     * @notice Emitted when a boolean value is added to the registry.\n     * @param id The identifier of the registry entry.\n     * @param key The key associated with the boolean value.\n     * @param value The boolean value added to the registry.\n     */\n    event AddedBool(bytes32 indexed id, bytes32 indexed key, bool value);\n\n    /**\n     * @notice Emitted when a uint256 value is added to the registry.\n     * @param id The identifier of the registry entry.\n     * @param key The key associated with the uint256 value.\n     * @param value The uint256 value added to the registry.\n     */\n    event AddedUint(bytes32 indexed id, bytes32 indexed key, uint256 value);\n\n    /**\n     * @notice Emitted when an address value is added to the registry.\n     * @param id The identifier of the registry entry.\n     * @param key The key associated with the address value.\n     * @param value The address value added to the registry.\n     */\n    event AddedAddress(bytes32 indexed id, bytes32 indexed key, address value);\n\n    /**\n     * @notice Emitted when a string value is added to the registry.\n     * @param id The identifier of the registry entry.\n     * @param key The key associated with the string value.\n     * @param value The string value added to the registry.\n     */\n    event AddedString(bytes32 indexed id, bytes32 indexed key, string value);\n\n    /**\n     * @notice Emitted when a bytes32 value is added to the registry.\n     * @param id The identifier of the registry entry.\n     * @param key The key associated with the bytes32 value.\n     * @param value The bytes32 value added to the registry.\n     */\n    event AddedBytes(bytes32 indexed id, bytes32 indexed key, bytes32 value);\n\n    /**\n     * @notice Emitted every time a key is restricted from being set\n     * for an specific entry\n     * @param _id Id of the entry where the key is restricted\n     * @param _key Key being restricted\n     */\n    event KeyRestricted(bytes32 indexed _id, bytes32 indexed _key);\n\n    /**\n     * @notice Get a boolean value from the storage\n     * @param _id Id of the registry entry to get the value from\n     * @param _key Key identifying the value to get\n     * @return bool value of the element associated to the key\n     * in the requested registry entry\n     */\n    function getBool(bytes32 _id, bytes32 _key) external view returns (bool);\n\n    /**\n     * @notice Get a uint256 value from the storage\n     * @param _id Id of the registry entry to get the value from\n     * @param _key Key identifying the value to get\n     * @return uint256 value of the element associated to the key\n     * in the requested registry entry\n     */\n    function getUint(bytes32 _id, bytes32 _key) external view returns (uint256);\n\n    /**\n     * @notice Get an address value from the storage\n     * @param _id Id of the registry entry to get the value from\n     * @param _key Key identifying the value to get\n     * @return address value of the element associated to the key\n     * in the requested registry entry\n     */\n    function getAddress(bytes32 _id, bytes32 _key) external view returns (address);\n\n    /**\n     * @notice Get a string value from the storage\n     * @param _id Id of the registry entry to get the value from\n     * @param _key Key identifying the value to get\n     * @return string value of the element associated to the key\n     * in the requested registry entry\n     */\n    function getString(bytes32 _id, bytes32 _key) external view returns (string memory);\n\n    /**\n     * @notice Get a bytes value from the storage\n     * @param _id Id of the registry entry to get the value from\n     * @param _key Key identifying the value to get\n     * @return bytes value of the element associated to the key\n     * in the requested registry entry\n     */\n    function getBytes(bytes32 _id, bytes32 _key) external view returns (bytes32);\n\n    /**\n     * @notice Set a boolean value on the storage\n     * @param _id Id of the registry entry to set the value on\n     * @param _key Key identifying the value to set\n     * @param _value Value to set\n     * @param _senderRole Role of the sender allowing the operation\n     */\n    function setBool(bytes32 _id, bytes32 _key, bool _value, bytes32 _senderRole) external;\n\n    /**\n     * @notice Set a uint256 value on the storage\n     * @param _id Id of the registry entry to set the value on\n     * @param _key Key identifying the value to set\n     * @param _value Value to set\n     * @param _senderRole Role of the sender allowing the operation\n     */\n    function setUint(bytes32 _id, bytes32 _key, uint256 _value, bytes32 _senderRole) external;\n\n    /**\n     * @notice Set an address value on the storage\n     * @param _id Id of the registry entry to set the value on\n     * @param _key Key identifying the value to set\n     * @param _value Value to set\n     * @param _senderRole Role of the sender allowing the operation\n     */\n    function setAddress(bytes32 _id, bytes32 _key, address _value, bytes32 _senderRole) external;\n\n    /**\n     * @notice Set a string value on the storage\n     * @param _id Id of the registry entry to set the value on\n     * @param _key Key identifying the value to set\n     * @param _value Value to set\n     * @param _senderRole Role of the sender allowing the operation\n     */\n    function setString(bytes32 _id, bytes32 _key, string calldata _value, bytes32 _senderRole) external;\n\n    /**\n     * @notice Set a bytes value on the storage\n     * @param _id Id of the registry entry to set the value on\n     * @param _key Key identifying the value to set\n     * @param _value Value to set\n     * @param _senderRole Role of the sender allowing the operation\n     */\n    function setBytes(bytes32 _id, bytes32 _key, bytes32 _value, bytes32 _senderRole) external;\n\n    /**\n     * @notice Set multiple values in one transaction\n     * @param _ids Ids associated to the values to set\n     * @param _keys Key associated to the values to set\n     * @param _boolValues Bool values to set\n     * @param _uintValues Uint256 values to set\n     * @param _addressValues Address values to set\n     * @param _stringValues String values to set\n     * @param _bytesValues Bytes32 values to set\n     * @param _senderRole Role of the sender allowing the operation\n     */\n    function setBatch(\n        bytes32[] memory _ids,\n        bytes32[] memory _keys,\n        bool[] memory _boolValues,\n        uint256[] memory _uintValues,\n        address[] memory _addressValues,\n        string[] memory _stringValues,\n        bytes32[] memory _bytesValues,\n        bytes32 _senderRole\n    ) external;\n\n    /**\n     * @notice Get multiple values in one transaction\n     * @param _ids Ids associated to the values to get\n     * @param _keys Keys associated to the values to get\n     * @param _boolCount Number of bool values to get\n     * @param _uintCount Number of uint256 values to get\n     * @param _addressCount Number of address values to get\n     * @param _stringCount Number of string values to get\n     * @param _bytesCount Number of bytes32 values to get\n     * @return _boolValues Bool values return array\n     * @return _uintValues Uint256 values return array\n     * @return _addressValues Address values return array\n     * @return _stringValues String values return array\n     * @return _bytesValues Bytes32 values return array\n     */\n    function getBatch(\n        bytes32[] memory _ids,\n        bytes32[] memory _keys,\n        uint256 _boolCount,\n        uint256 _uintCount,\n        uint256 _addressCount,\n        uint256 _stringCount,\n        uint256 _bytesCount\n    )\n        external\n        view\n        returns (\n            bool[] memory _boolValues,\n            uint256[] memory _uintValues,\n            address[] memory _addressValues,\n            string[] memory _stringValues,\n            bytes32[] memory _bytesValues\n        );\n}\n"
    },
    "src/interfaces/IGatewayManager.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {IInvestorRegistry} from \"src/interfaces/IInvestorRegistry.sol\";\nimport {IRoleRegistry} from \"src/interfaces/IRoleRegistry.sol\";\nimport {ILibreCoreGateway} from \"src/interfaces/ILibreCoreGateway.sol\";\nimport {IEAS} from \"eas-contracts/IEAS.sol\";\n\n/**\n * @title IGatewayManager Interface\n * @notice Interface for managing cross-chain addresses and investor chain preferences\n * @dev Coordinates with LibreCoreGateway for cross-chain operations\n */\ninterface IGatewayManager {\n    /**\n     * @notice Emitted when an investor's preferred chains are updated or set\n     * @param investorId The unique identifier of the investor\n     * @param chains Array of custom chain IDs that the investor prefers\n     * @param oldChains Previous array of chain IDs for the investor\n     */\n    event InvestorChainsUpdated(bytes32 investorId, uint16[] chains, uint16[] oldChains);\n\n    /**\n     * @notice Emitted when cross-chain addresses are updated for an investor\n     * @dev Each address change is encoded as: [1 byte action][2 bytes chainSelector][n bytes address]\n     * @param investorId The unique identifier of the investor\n     * @param addressChanges A list of concatenated bytes describing a change in multi-chain address\n     */\n    event InvestorAddressesUpdated(bytes32 investorId, bytes[] addressChanges);\n\n    /// @notice Thrown when an unsupported or invalid chain ID is provided\n    error GatewayManager_InvalidChain();\n\n    /// @notice Thrown when the investor ID doesn't exist or is invalid\n    error GatewayManager_InvalidInvestor();\n\n    /// @notice Thrown when input parameters are invalid or missing\n    error GatewayManager_InvalidInput();\n\n    /// @notice Thrown when a cross-chain address is already associated with another investor\n    error GatewayManager_AddressAlreadyUsed();\n\n    /**\n     * @notice Initializes the gateway manager\n     * @param _coreGateway Address of the LibreCoreGateway contract\n     * @param _eas Address of the Ethereum Attestation Service\n     * @param _investorRegistry Address of the InvestorRegistry contract\n     * @param _roleRegistry Address of the RoleRegistry contract\n     */\n    function initialize(\n        ILibreCoreGateway _coreGateway,\n        IEAS _eas,\n        IInvestorRegistry _investorRegistry,\n        IRoleRegistry _roleRegistry\n    ) external;\n\n    /**\n     * @notice Sets the preferred chains for an investor\n     * @param _senderRole Role of the transaction sender\n     * @param _investorId Unique identifier of the investor\n     * @param _chains Array of chain IDs to set as preferred\n     */\n    function setInvestorChains(bytes32 _senderRole, bytes32 _investorId, uint16[] calldata _chains) external;\n\n    /**\n     * @notice Updates investor's cross-chain addresses and propagates changes to other chains\n     * @dev Adds or removes addresses and bridges the updates to other chains\n     * @param _senderRole Role of the transaction sender\n     * @param _investorId Unique identifier of the investor\n     * @param _addressChanges A list of concatenated bytes describing a change in multi-chain address\n     */\n    function manageCrossChainAddresses(bytes32 _senderRole, bytes32 _investorId, bytes[] calldata _addressChanges)\n        external;\n\n    /**\n     * @notice Bridges a credential to all investor's preferred chains via core gateway.\n     * @param _attestationId The unique ID of the attestation to be bridged.\n     * @param _senderRole Role of the transaction sender.\n     * @param _chains Chains to bridge credential to (all investor chains if empty)\n     */\n    function bridgeCredential(bytes32 _attestationId, bytes32 _senderRole, uint16[] memory _chains) external;\n\n    /**\n     * @notice Validates if an address is a valid cross-chain address for an investor\n     * @param _investorId The investor ID to check\n     * @param _chainSelector The chain ID to check\n     * @param _address The address to validate\n     * @return bool True if the address is valid for the investor on the chain\n     */\n    function isValidCrossChainAddress(bytes32 _investorId, uint16 _chainSelector, bytes calldata _address)\n        external\n        view\n        returns (bool);\n\n    /**\n     * @notice Gets an investor's preferred chains\n     * @param _investorId The investor's unique identifier\n     * @return uint16[] Array of preferred chain IDs\n     */\n    function getInvestorChains(bytes32 _investorId) external view returns (uint16[] memory);\n\n    /**\n     * @notice Gets the owner of a cross-chain address\n     * @param _chainSelector The chain ID of the address\n     * @param _address The address to get the owner of\n     * @return bytes32 The owner of the address\n     */\n    function getAddressOwner(uint16 _chainSelector, bytes calldata _address) external view returns (bytes32);\n}\n"
    },
    "src/utils/Constant.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.28;\n\nimport \"src/utils/JurisdictionEncodings.sol\";\nimport \"src/utils/Types.sol\";\n\n// General Config\nbytes32 constant TIMEZONE = keccak256(\"TIMEZONE\");\nbytes32 constant MAX_TIMEZONE = keccak256(\"MAX_TIMEZONE\");\n\n// Chain/Gateway Config\nuint16 constant NATIVE_CHAIN_SELECTOR = 101;\n\n// NAV\nbytes32 constant AUDITED_NAV_PER_SHARE = keccak256(\"AUDITED_NAV_PER_SHARE\");\nbytes32 constant INSTRUMENT_ALLOWED_ADDRESSES = keccak256(\"INSTRUMENT_ALLOWED_ADDRESSES\");\n\n// Volatility\nbytes32 constant ANNUALIZED_VOLATILITY = keccak256(\"ANNUALIZED_VOLATILITY\");\n\n// Subscription Config\nbytes32 constant SUBSCRIPTION_PHASES = keccak256(\"SUBSCRIPTION_PHASES\");\nbytes32 constant SUBSCRIPTION_START = keccak256(\"SUBSCRIPTION_START\");\nbytes32 constant SUBSCRIPTION_END = keccak256(\"SUBSCRIPTION_END\");\nbytes32 constant SUBSCRIPTION_FREQUENCY = keccak256(\"SUBSCRIPTION_FREQUENCY\");\nbytes32 constant SUBSCRIPTION_FREQUENCY_TIME_UNIT = keccak256(\"SUBSCRIPTION_FREQUENCY_TIME_UNIT\");\n\n// Redemption Config\nbytes32 constant REDEMPTION_START = keccak256(\"REDEMPTION_START\");\nbytes32 constant REDEMPTION_END = keccak256(\"REDEMPTION_END\");\nbytes32 constant REDEMPTION_FREQUENCY = keccak256(\"REDEMPTION_FREQUENCY\");\nbytes32 constant REDEMPTION_FREQUENCY_TIME_UNIT = keccak256(\"REDEMPTION_FREQUENCY_TIME_UNIT\");\n\n// Fund data\nbytes32 constant FUND_ID = keccak256(\"FUND_ID\");\nbytes32 constant DISCLOSURE_DOCUMENTS = keccak256(\"DISCLOSURE_DOCUMENTS\");\nbytes32 constant LISTED_ON_REGULATED_VENUE = keccak256(\"LISTED_ON_REGULATED_VENUE\");\nbytes32 constant LOCAL_AIFM = keccak256(\"LOCAL_AIFM\");\nbytes32 constant NON_EU_AIFM = keccak256(\"NON_EU_AIFM\");\n\n// Fund Instruments data\nbytes32 constant INSTRUMENT_TOKEN = keccak256(\"INSTRUMENT_TOKEN\");\nbytes32 constant LOCAL_INVESTOR_MINIMUM_HOLDING = keccak256(\"LOCAL_INVESTOR_MINIMUM_HOLDING\");\nbytes32 constant AGGREGATED_MINIMUM_REDEMPTION_VALUE = keccak256(\"AGGREGATED_MINIMUM_REDEMPTION_VALUE\");\nbytes32 constant AGGREGATED_MINIMUM_SUBSEQUENT_SUBSCRIPTION = keccak256(\"AGGREGATED_MINIMUM_SUBSEQUENT_SUBSCRIPTION\");\nbytes32 constant INVESTOR_MINIMUM_INITIAL_SUBSCRIPTION = keccak256(\"INVESTOR_MINIMUM_INITIAL_SUBSCRIPTION\");\nbytes32 constant INVESTOR_MINIMUM_SUBSEQUENT_SUBSCRIPTION = keccak256(\"INVESTOR_MINIMUM_SUBSEQUENT_SUBSCRIPTION\");\nbytes32 constant REDEMPTION_BOOK = keccak256(\"REDEMPTION_BOOK\");\nbytes32 constant SUBSCRIPTION_BOOK = keccak256(\"SUBSCRIPTION_BOOK\");\n\n// Subscription Cutoff\nbytes32 constant SUBSCRIPTION_CUT_OFF_CALENDAR_DAYS = keccak256(\"SUBSCRIPTION_CUT_OFF_CALENDAR_DAYS\");\nbytes32 constant SUBSCRIPTION_CUT_OFF_BUSINESS_DAYS = keccak256(\"SUBSCRIPTION_CUT_OFF_BUSINESS_DAYS\");\nbytes32 constant SUBSCRIPTION_CUT_OFF_TIME = keccak256(\"SUBSCRIPTION_CUT_OFF_TIME\");\nbytes32 constant SUBSCRIPTION_CUT_OFF_PERIOD = keccak256(\"SUBSCRIPTION_CUT_OFF_PERIOD\");\n\nbytes32 constant LOCAL_AGGREGATE_MINIMUM_HOLDING = keccak256(\"LOCAL_AGGREGATE_MINIMUM_HOLDING\");\nbytes32 constant SUBSCRIPTION_SIZE_MULTIPLE = keccak256(\"SUBSCRIPTION_SIZE_MULTIPLE\");\nbytes32 constant GLOBAL_AGGREGATE_MINIMUM_BREACH = keccak256(\"GLOBAL_AGGREGATE_MINIMUM_BREACH\");\nbytes32 constant FORCED_REDEMPTION_TOP_UP_PERIOD = keccak256(\"FORCED_REDEMPTION_TOP_UP_PERIOD\");\nbytes32 constant FORCED_REDEMPTION_TOP_UP_PERIOD_UNIT = keccak256(\"FORCED_REDEMPTION_TOP_UP_PERIOD_UNIT\");\nbytes32 constant REDEMPTION_VOLUME_LIMIT = keccak256(\"REDEMPTION_VOLUME_LIMIT\");\nbytes32 constant REDEMPTION_VOLUME_LIMIT_PER_INVESTOR = keccak256(\"REDEMPTION_VOLUME_LIMIT_PER_INVESTOR\");\nbytes32 constant REDEMPTION_VOLUME_LIMIT_PER_INVESTOR_FEE = keccak256(\"REDEMPTION_VOLUME_LIMIT_PER_INVESTOR_FEE\");\nbytes32 constant REDEMPTION_LOOKBACK_PERIOD = keccak256(\"REDEMPTION_LOOKBACK_PERIOD\");\nbytes32 constant REDEMPTION_LOOKBACK_PERIOD_UNIT = keccak256(\"REDEMPTION_LOOKBACK_PERIOD_UNIT\");\nbytes32 constant GATE_CRITERIA_1 = keccak256(\"GATE_CRITERIA_1\");\nbytes32 constant REDEMPTION_NOTICE_PERIOD = keccak256(\"REDEMPTION_NOTICE_PERIOD\");\nbytes32 constant REDEMPTION_NOTICE_PERIOD_UNIT = keccak256(\"REDEMPTION_NOTICE_PERIOD_UNIT\");\nbytes32 constant REDEMPTION_CUT_OFF_PERIOD = keccak256(\"REDEMPTION_CUT_OFF_PERIOD\");\n// Calendar\nbytes32 constant BUSINESS_DAY_BITMAP_PART_1 = keccak256(\"BUSINESS_DAY_BITMAP_PART_1\");\nbytes32 constant BUSINESS_DAY_BITMAP_PART_2 = keccak256(\"BUSINESS_DAY_BITMAP_PART_2\");\n\n// Redemption Cutoff\nbytes32 constant REDEMPTION_CUT_OFF_CALENDAR_DAYS = keccak256(\"REDEMPTION_CUT_OFF_CALENDAR_DAYS\");\nbytes32 constant REDEMPTION_CUT_OFF_BUSINESS_DAYS = keccak256(\"REDEMPTION_CUT_OFF_BUSINESS_DAYS\");\nbytes32 constant REDEMPTION_CUT_OFF_TIME = keccak256(\"REDEMPTION_CUT_OFF_TIME\");\n\n// Execution Date\nbytes32 constant SUBSCRIPTION_NOTICE_PERIOD_CALENDAR_MONTHS = keccak256(\"SUBSCRIPTION_NOTICE_PERIOD_CALENDAR_MONTHS\");\nbytes32 constant SUBSCRIPTION_NOTICE_PERIOD_CALENDAR_DAYS = keccak256(\"SUBSCRIPTION_NOTICE_PERIOD_CALENDAR_DAYS\");\nbytes32 constant SUBSCRIPTION_NOTICE_PERIOD_BUSINESS_DAYS = keccak256(\"SUBSCRIPTION_NOTICE_PERIOD_BUSINESS_DAYS\");\nbytes32 constant SUBSCRIPTION_CUTOFF_TIME = keccak256(\"SUBSCRIPTION_CUTOFF_TIME\");\nbytes32 constant WAIVE_SUBSCRIPTION_NOTICE_PERIOD = keccak256(\"WAIVE_SUBSCRIPTION_NOTICE_PERIOD\");\nbytes32 constant SUBSCRIPTION_PREADJUSTMENT_DEALING_DAY_OF_MONTH =\n    keccak256(\"SUBSCRIPTION_PREADJUSTMENT_DEALING_DAY_OF_MONTH\");\nbytes32 constant REDEMPTION_NOTICE_PERIOD_CALENDAR_MONTHS = keccak256(\"REDEMPTION_NOTICE_PERIOD_CALENDAR_MONTHS\");\nbytes32 constant REDEMPTION_NOTICE_PERIOD_CALENDAR_DAYS = keccak256(\"REDEMPTION_NOTICE_PERIOD_CALENDAR_DAYS\");\nbytes32 constant REDEMPTION_NOTICE_PERIOD_BUSINESS_DAYS = keccak256(\"REDEMPTION_NOTICE_PERIOD_BUSINESS_DAYS\");\nbytes32 constant REDEMPTION_CUTOFF_TIME = keccak256(\"REDEMPTION_CUTOFF_TIME\");\nbytes32 constant WAIVE_REDEMPTION_NOTICE_PERIOD = keccak256(\"WAIVE_REDEMPTION_NOTICE_PERIOD\");\nbytes32 constant REDEMPTION_PREADJUSTMENT_DEALING_DAY_OF_MONTH =\n    keccak256(\"REDEMPTION_PREADJUSTMENT_DEALING_DAY_OF_MONTH\");\n\n// Redemption Holding Intervals\nbytes32 constant REDEMPTION_FIRST_UNLOCK_PERIOD = keccak256(\"REDEMPTION_FIRST_UNLOCK_PERIOD\");\nbytes32 constant REDEMPTION_SECOND_UNLOCK_PERIOD = keccak256(\"REDEMPTION_SECOND_UNLOCK_PERIOD\");\n\nbytes32 constant CUMULATIVE_REDEMPTION_PERIOD = keccak256(\"CUMULATIVE_REDEMPTION_PERIOD\");\nbytes32 constant CUMULATIVE_REDEMPTION_PERIOD_UNIT = keccak256(\"CUMULATIVE_REDEMPTION_PERIOD_UNIT\");\nbytes32 constant CUMULATIVE_REDEMPTION_LIMIT_FEE = keccak256(\"CUMULATIVE_REDEMPTION_LIMIT_FEE\");\nbytes32 constant CUMULATIVE_REDEMPTION_LIMIT_ALLOWANCE = keccak256(\"CUMULATIVE_REDEMPTION_LIMIT_ALLOWANCE\");\nbytes32 constant CUMULATIVE_REDEMPTION_LIMIT_PER_INVESTOR_ALLOWANCE =\n    keccak256(\"CUMULATIVE_REDEMPTION_LIMIT_PER_INVESTOR_ALLOWANCE\");\nbytes32 constant CUMULATIVE_REDEMPTION_LIMIT_PER_INVESTOR_FEE =\n    keccak256(\"CUMULATIVE_REDEMPTION_LIMIT_PER_INVESTOR_FEE\");\nbytes32 constant INITIAL_REDEMPTION_RESTRICTED_PERIOD = keccak256(\"INITIAL_REDEMPTION_RESTRICTED_PERIOD\");\nbytes32 constant INITIAL_SUBSCRIPTION_RESTRICTED_PERIOD = keccak256(\"INITIAL_SUBSCRIPTION_RESTRICTED_PERIOD\");\nbytes32 constant INITIAL_SUBSCRIPTION_RESTRICTED_PERIOD_UNIT = keccak256(\"INITIAL_SUBSCRIPTION_RESTRICTED_PERIOD_UNIT\");\nbytes32 constant INITIAL_SUBSCRIPTION_RESTRICTED_PERIOD_ALLOWANCE =\n    keccak256(\"INITIAL_SUBSCRIPTION_RESTRICTED_PERIOD_ALLOWANCE\");\nbytes32 constant INITIAL_SUBSCRIPTION_RESTRICTED_PERIOD_FEE = keccak256(\"INITIAL_SUBSCRIPTION_RESTRICTED_PERIOD_FEE\");\nbytes32 constant INITIAL_REDEMPTION_RESTRICTED_PERIOD_ALLOWANCE =\n    keccak256(\"INITIAL_REDEMPTION_RESTRICTED_PERIOD_ALLOWANCE\");\nbytes32 constant POST_SUBSCRIPTION_RESTRICTED_PERIOD_ALLOWANCE =\n    keccak256(\"POST_SUBSCRIPTION_RESTRICTED_PERIOD_ALLOWANCE\");\nbytes32 constant POST_SUBSCRIPTION_RESTRICTED_PERIOD_FEE = keccak256(\"POST_SUBSCRIPTION_RESTRICTED_PERIOD_FEE\");\nbytes32 constant INITIAL_REDEMPTION_RESTRICTED_PERIOD_FEE = keccak256(\"INITIAL_REDEMPTION_RESTRICTED_PERIOD_FEE\");\nbytes32 constant POST_REDEMPTION_RESTRICTED_PERIOD_ALLOWANCE = keccak256(\"POST_REDEMPTION_RESTRICTED_PERIOD_ALLOWANCE\");\nbytes32 constant POST_REDEMPTION_RESTRICTED_PERIOD_FEE = keccak256(\"POST_REDEMPTION_RESTRICTED_PERIOD_FEE\");\nbytes32 constant GLOBAL_AGGREGATE_MINIMUM_HOLDING = keccak256(\"GLOBAL_AGGREGATE_MINIMUM_HOLDING\");\nbytes32 constant BLOCKED = keccak256(\"BLOCKED\");\nbytes32 constant RESIDENCES_ALLOWED = keccak256(\"RESIDENCES_ALLOWED\");\nbytes32 constant NATIONALITIES_ALLOWED = keccak256(\"NATIONALITIES_ALLOWED\");\nbytes32 constant INVESTOR_TYPES_ALLOWED = keccak256(\"INVESTOR_TYPES_ALLOWED\");\nbytes32 constant ESTIMATED_REDEMPTION_FEE = keccak256(\"ESTIMATED_REDEMPTION_FEE\");\nbytes32 constant IS_INVESTOR_ALLOWED = keccak256(\"IS_INVESTOR_ALLOWED\");\nbytes32 constant HOLDING_FEE = keccak256(\"HOLDING_FEE\");\nbytes32 constant HOLDING_FEE_PERIOD = keccak256(\"HOLDING_FEE_PERIOD\");\nbytes32 constant HOLDING_FEE_PERIOD_UNIT = keccak256(\"HOLDING_FEE_PERIOD_UNIT\");\n\n// Investors data\nbytes32 constant INVESTOR_TYPE = keccak256(\"INVESTOR_TYPE\");\nbytes32 constant MAX_INVESTOR_TYPE = keccak256(\"MAX_INVESTOR_TYPE\");\nbytes32 constant NATIONALITIES = keccak256(\"NATIONALITIES\");\nbytes32 constant REVIEW_DATE = keccak256(\"REVIEW_DATE\");\nbytes32 constant KYC_PASSED = keccak256(\"KYC_PASSED\");\nbytes32 constant AML_PASSED = keccak256(\"AML_PASSED\");\nbytes32 constant SANCTIONS_PASSED = keccak256(\"SANCTIONS_PASSED\");\nbytes32 constant SELF_CERTIFICATION = keccak256(\"SELF_CERTIFICATION\");\nbytes32 constant FITNESS_TEST = keccak256(\"FITNESS_TEST\");\nbytes32 constant FROZEN = keccak256(\"FROZEN\");\nbytes32 constant USA_STATE = keccak256(\"USA_STATE\");\nbytes32 constant ALLOWED_TO_INTERACT_DAY = keccak256(\"ALLOWED_TO_INTERACT_DAY\");\nbytes32 constant DEALER = keccak256(\"DEALER\");\nbytes32 constant REVERSE_ENQUIRY = keccak256(\"REVERSE_ENQUIRY\");\n\n// Jurisdictions data\nbytes32 constant JURISDICTION_ALLOWED = keccak256(\"JURISDICTION_ALLOWED\");\nbytes32 constant INVESTOR_ALLOWLISTED_REQUIRED = keccak256(\"INVESTOR_ALLOWLISTED_REQUIRED\");\nbytes32 constant SELF_CERTIFICATION_REQUIRED = keccak256(\"SELF_CERTIFICATION_REQUIRED\");\nbytes32 constant FITNESS_TEST_REQUIRED = keccak256(\"FITNESS_TEST_REQUIRED\");\nbytes32 constant DISCLOSURE_DOCUMENTS_REQUIRED = keccak256(\"DISCLOSURE_DOCUMENTS_REQUIRED\");\nbytes32 constant LISTED_ON_REGULATED_VENUE_REQUIRED = keccak256(\"LISTED_ON_REGULATED_VENUE_REQUIRED\");\nbytes32 constant LOCAL_AIFM_REQUIRED = keccak256(\"LOCAL_AIFM_REQUIRED\");\nbytes32 constant NON_EU_AIFM_REQUIRED = keccak256(\"NON_EU_AIFM_REQUIRED\");\nbytes32 constant MINIMUM_INVESTMENT_REQUIRED = keccak256(\"MINIMUM_INVESTMENT_REQUIRED\");\nbytes32 constant MINIMUM_INVESTMENT = keccak256(\"MINIMUM_INVESTMENT\");\nbytes32 constant NO_MINIMUM_INVESTMENT_HOLDER_NUMBER = keccak256(\"NO_MINIMUM_INVESTMENT_HOLDER_NUMBER\");\n\n// Registries\nbytes32 constant GENERAL_DATA_ID = bytes32(0);\nbytes32 constant ETERNAL_STORAGE_SLOT = keccak256(\"ETERNAL_STORAGE_SLOT\");\nbytes32 constant BLACKLISTED_WALLET = keccak256(\"BLACKLISTED_WALLET\");\n\n// Tracking\nbytes32 constant CURRENT_SUBSCRIPTIONS_AMOUNT = keccak256(\"CURRENT_SUBSCRIPTIONS_AMOUNT\");\nbytes32 constant INVESTOR_SUBSCRIPTION_AMOUNT = keccak256(\"INVESTOR_SUBSCRIPTION_AMOUNT\");\nbytes32 constant CURRENT_REDEMPTIONS_AMOUNT = keccak256(\"CURRENT_REDEMPTIONS_AMOUNT\");\nbytes32 constant INVESTOR_REDEMPTION_AMOUNT = keccak256(\"INVESTOR_REDEMPTION_AMOUNT\");\nbytes32 constant REDEMPTION_RECORDS = keccak256(\"REDEMPTION_RECORDS\");\nbytes32 constant REDEMPTION_RECORDS_COUNT = keccak256(\"REDEMPTION_RECORDS_COUNT\");\nbytes32 constant REDEMPTION_RECORDS_AGGREGATE = keccak256(\"REDEMPTION_RECORDS_AGGREGATE\");\nbytes32 constant REDEMPTION_RECORDS_TIMESTAMP = keccak256(\"REDEMPTION_RECORDS_TIMESTAMP\");\nbytes32 constant HOLDING_FEE_EXEMPTION_CREDITS = keccak256(\"HOLDING_FEE_EXEMPTION_CREDITS\");\nbytes32 constant HOLDING_FEE_EXEMPTION_CREDITS_START = keccak256(\"HOLDING_FEE_EXEMPTION_CREDITS_START\");\nbytes32 constant HOLDING_FEE_EXEMPTION_CREDITS_COUNT = keccak256(\"HOLDING_FEE_EXEMPTION_CREDITS_COUNT\");\nbytes32 constant HOLDING_FEE_EXEMPTION_CREDITS_AMOUNT = keccak256(\"HOLDING_FEE_EXEMPTION_CREDITS_AMOUNT\");\nbytes32 constant HOLDING_FEE_EXEMPTION_CREDITS_TIMESTAMP = keccak256(\"HOLDING_FEE_EXEMPTION_CREDITS_TIMESTAMP\");\n\n// Tracking (Holding Intervals)\nbytes32 constant HOLDING_TIME_CREDITS = keccak256(\"HOLDING_TIME_CREDITS\");\nbytes32 constant HOLDING_TIME_CREDITS_START = keccak256(\"HOLDING_TIME_CREDITS_START\");\nbytes32 constant HOLDING_TIME_CREDITS_COUNT = keccak256(\"HOLDING_TIME_CREDITS_COUNT\");\nbytes32 constant HOLDING_TIME_CREDITS_TIMESTAMP = keccak256(\"HOLDING_TIME_CREDITS_TIMESTAMP\");\n\nbytes32 constant HOLDING_CREDITS_FIRST_PERIOD = keccak256(\"HOLDING_CREDITS_FIRST_PERIOD\"); // related to REDEMPTION_FIRST_UNLOCK_PERIOD\nbytes32 constant HOLDING_CREDITS_SECOND_PERIOD = keccak256(\"HOLDING_CREDITS_SECOND_PERIOD\"); // related to REDEMPTION_SECOND_UNLOCK_PERIOD\n\nbytes32 constant HOLDING_PERCENTAGE_FIRST_PERIOD = keccak256(\"HOLDING_PERCENTAGE_FIRST_PERIOD\");\nbytes32 constant HOLDING_PERCENTAGE_SECOND_PERIOD = keccak256(\"HOLDING_PERCENTAGE_SECOND_PERIOD\");\n\n// Tracking (NAV Track Module)\nbytes32 constant NAV_NUM_CHECKPOINTS = keccak256(\"NAV_NUM_CHECKPOINTS\");\nbytes32 constant NAV_CHECKPOINT = keccak256(\"NAV_CHECKPOINT\");\nbytes32 constant NAV_CHECKPOINT_TIMESTAMP = keccak256(\"NAV_CHECKPOINT_TIMESTAMP\");\n\n// Security Token Track (Per investor)\nbytes32 constant SECURITY_TOKEN_NUM_CHECKPOINTS = keccak256(\"SECURITY_TOKEN_NUM_CHECKPOINTS\");\nbytes32 constant SECURITY_TOKEN_CHECKPOINT_TIMESTAMP = keccak256(\"SECURITY_TOKEN_CHECKPOINT_TIMESTAMP\");\nbytes32 constant SECURITY_TOKEN_CHECKPOINTS = keccak256(\"SECURITY_TOKEN_CHECKPOINTS\");\n\n// Investor Registry\nbytes32 constant IS_INVESTOR = keccak256(\"IS_INVESTOR\");\nbytes32 constant LAST_OPERATION_TIMESTAMP = keccak256(\"LAST_OPERATION_TIMESTAMP\");\nbytes32 constant CREDENTIAL_ID = keccak256(\"CREDENTIAL_ID\");\nbytes32 constant INVESTOR_CROSS_CHAIN_ADDRESSES = keccak256(\"INVESTOR_CROSS_CHAIN_ADDRESSES\");\n\n// Instrument Registry\nbytes32 constant IS_INSTRUMENT = keccak256(\"IS_INSTRUMENT\");\nbytes32 constant TRADING_DAYS_IN_YEAR = keccak256(\"TRADING_DAYS_IN_YEAR\");\nbytes32 constant INSTRUMENT_INITIALIZED = keccak256(\"INSTRUMENT_INITIALIZED\");\nbytes32 constant INSTRUMENT_CLOSED = keccak256(\"INSTRUMENT_CLOSED\");\nbytes32 constant INSTANT_SETTLEMENT = keccak256(\"INSTANT_SETTLEMENT\");\nbytes32 constant CAN_TRANSFER_SETTLEMENT_TOKEN = keccak256(\"CAN_TRANSFER_SETTLEMENT_TOKEN\");\nbytes32 constant CAN_TRANSFER_SECURITY_TOKEN = keccak256(\"CAN_TRANSFER_SECURITY_TOKEN\");\nbytes32 constant INSTRUMENT_PAUSED = keccak256(\"INSTRUMENT_PAUSED\");\n\n// Dealer Registry\nbytes32 constant IS_DEALER = keccak256(\"IS_DEALER\");\n\n// Fund Registry\nbytes32 constant IS_FUND = keccak256(\"IS_FUND\");\nbytes32 constant DEFAULT_FUND_MODULES = keccak256(\"DEFAULT_FUND_MODULES\");\n\n// Roles\nbytes32 constant DEFAULT_ADMIN_ROLE = bytes32(0);\nbytes32 constant DEALER_MANAGER_ROLE = keccak256(\"DEALER_MANAGER_ROLE\");\nbytes32 constant LIBRE_DEALER_ROLE = keccak256(\"LIBRE_DEALER_ROLE\");\nbytes32 constant INSTRUMENT_MANAGER_ROLE = keccak256(\"INSTRUMENT_MANAGER_ROLE\");\nbytes32 constant SETTLEMENT_TOKEN_MINTER_ROLE = keccak256(\"SETTLEMENT_TOKEN_MINTER_ROLE\");\nbytes32 constant SETTLEMENT_TOKEN_BURNER_ROLE = keccak256(\"SETTLEMENT_TOKEN_BURNER_ROLE\");\nbytes32 constant RELAYER_ROLE = keccak256(\"RELAYER_ROLE\");\nbytes32 constant CONTRACT_MANAGER_ROLE = keccak256(\"CONTRACT_MANAGER_ROLE\");\nbytes32 constant REGISTRY_WRITER_ROLE_ADMIN = keccak256(\"REGISTRY_WRITER_ROLE_ADMIN\");\nbytes32 constant REGISTRY_WRITER_ROLE = keccak256(\"REGISTRY_WRITER_ROLE\");\nbytes32 constant ATTESTER_ROLE = keccak256(\"ATTESTER_ROLE\");\nbytes32 constant GATEWAY_MANAGER_ROLE = keccak256(\"GATEWAY_MANAGER_ROLE\");\nbytes32 constant CORE_GATEWAY_ROLE = keccak256(\"CORE_GATEWAY_ROLE\");\nbytes32 constant BRIDGE_ROLE = keccak256(\"BRIDGE_ROLE\");\nbytes32 constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n\n// Hash of module names\nbytes32 constant TRANSFER_MODULE = keccak256(\"TransferModule\");\nbytes32 constant DAILY_EXECUTION_CALCULATOR_MODULE = keccak256(\"DailyExecutionCalculatorModule\");\nbytes32 constant EXECUTION_DATE_ENFORCEMENT_MODULE = keccak256(\"ExecutionDateEnforcementModule\");\nbytes32 constant HALT_MODULE = keccak256(\"HaltModule\");\nbytes32 constant HOLDINGS_MODULE = keccak256(\"HoldingsModule\");\nbytes32 constant MONTHLY_EXECUTION_CALCULATOR_MODULE = keccak256(\"MonthlyExecutionCalculatorModule\");\nbytes32 constant FORCED_REDEMPTION_MODULE = keccak256(\"ForcedRedemptionModule\");\nbytes32 constant GATE_1_MODULE = keccak256(\"Gate1Module\");\nbytes32 constant HOLDING_INTERVALS_MODULE = keccak256(\"HoldingIntervalsModule\");\nbytes32 constant REDEMPTIONS_AGGREGATION_LIMIT_MODULE = keccak256(\"RedemptionsAggregationLimitModule\");\nbytes32 constant SUBSCRIPTIONS_AGGREGATION_LIMIT_MODULE = keccak256(\"SubscriptionsAggregationLimitModule\");\nbytes32 constant HOLDING_FEE_MODULE = keccak256(\"HoldingFeeModule\");\nbytes32 constant REDEMPTION_VOLUME_LIMIT_PER_INVESTOR_FEE_MODULE =\n    keccak256(\"RedemptionVolumeLimitPerInvestorFeeModule\");\nbytes32 constant INVESTOR_LAST_OPERATION_TRACKING_MODULE = keccak256(\"InvestorLastOperationTrackingModule\");\nbytes32 constant NAV_TRACKING_MODULE = keccak256(\"NAVTrackingModule\");\nbytes32 constant REDEMPTIONS_RECORDS_MODULE = keccak256(\"RedemptionsRecordsModule\");\nbytes32 constant REDEMPTIONS_TOTAL_AMOUNT_MODULE = keccak256(\"RedemptionsTotalAmountModule\");\nbytes32 constant SECURITY_TOKEN_TRACKING_MODULE = keccak256(\"SecurityTokenTrackingModule\");\nbytes32 constant SUBSCRIPTIONS_TOTAL_AMOUNT_MODULE = keccak256(\"SubscriptionsTotalAmountModule\");\nbytes32 constant HOLDING_FEE_EXEMPTION_MODULE = keccak256(\"HoldingFeeExemptionModule\");\nbytes32 constant HOLDING_INTERVALS_TRACKING_MODULE = keccak256(\"HoldingIntervalsTrackingModule\");\n\n// Percentage calculations\nuint256 constant PERCENTAGE_BASE = 100_00;\n"
    },
    "src/registries/BaseRegistry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.28;\n\nimport {IInvestorRegistry} from \"src/interfaces/IInvestorRegistry.sol\";\nimport {IInstrumentRegistry} from \"src/interfaces/IInstrumentRegistry.sol\";\nimport {IDealerRegistry} from \"src/interfaces/IDealerRegistry.sol\";\nimport {IFundRegistry} from \"src/interfaces/IFundRegistry.sol\";\nimport {IEternalRegistryStorage} from \"src/interfaces/IEternalRegistryStorage.sol\";\nimport {IOperationsEngine} from \"src/interfaces/IOperationsEngine.sol\";\nimport {IBaseRegistry} from \"src/interfaces/IBaseRegistry.sol\";\nimport {ICheckModule} from \"src/interfaces/operations/ICheckModule.sol\";\n\nimport {LibreUUPSUpgradeable} from \"src/utils/LibreUUPSUpgradeable.sol\";\n\nimport {EternalRegistryStorage} from \"src/registries/EternalRegistryStorage.sol\";\n\nimport \"src/utils/Constant.sol\";\n\n/**\n * @title Base contract for Registies implementations\n * @author Libre\n * @notice Shared functionalities for registries\n * @dev RoleRegistry not included as it is a special type of registry\n */\nabstract contract BaseRegistry is IBaseRegistry, LibreUUPSUpgradeable, EternalRegistryStorage {\n    // keccak256(abi.encode(uint256(keccak256(\"BaseRegistry.storage\")) - 1)) & ~bytes32(uint256(0xff));\n    bytes32 private constant BASE_REGISTRY_STORAGE_SLOT =\n        0xb2c66b460d9aa93b78f84537d8b5e3f1eafaad44c253f0046a48cca1de146000;\n\n    /// @custom:storage-location erc7201:BaseRegistry.storage\n    struct BaseRegistryStorage {\n        bytes32 IS_VALID_ID;\n        IInvestorRegistry investorRegistry;\n        IInstrumentRegistry instrumentRegistry;\n        IDealerRegistry dealerRegistry;\n        IFundRegistry fundRegistry;\n        IEternalRegistryStorage jurisdictionRegistry;\n        IOperationsEngine operationsEngine;\n    }\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    function getTrackedData(bytes memory _data) external returns (bytes memory) {\n        BaseRegistryStorage storage brs = _getBaseRegistryStorage();\n\n        if (!brs.operationsEngine.isAvailableModule(msg.sender)) {\n            revert IBaseRegistry_NotRegisteredModule();\n        }\n\n        (bool success, bytes memory returnData) =\n            msg.sender.delegatecall(abi.encodeWithSelector(ICheckModule.getTrackedData.selector, _data));\n        if (!success) {\n            revert IBaseRegistry_FailedToGetTrackedData();\n        }\n\n        return abi.decode(returnData, (bytes));\n    }\n\n    function setBool(bytes32 _id, bytes32 _key, bool _value, bytes32 _senderRole) external {\n        _checkHasRegistryWriteAccess(_id, _senderRole);\n        _onlyConfigurableKey(_id, _key);\n        _setBool(_id, _key, _value);\n        _afterEntryUpdate(_id);\n    }\n\n    function setUint(bytes32 _id, bytes32 _key, uint256 _value, bytes32 _senderRole) external {\n        _checkHasRegistryWriteAccess(_id, _senderRole);\n        _onlyConfigurableKey(_id, _key);\n        _setUint(_id, _key, _value);\n        _afterEntryUpdate(_id);\n    }\n\n    function setAddress(bytes32 _id, bytes32 _key, address _value, bytes32 _senderRole) external {\n        _checkHasRegistryWriteAccess(_id, _senderRole);\n        _onlyConfigurableKey(_id, _key);\n        _setAddress(_id, _key, _value);\n        _afterEntryUpdate(_id);\n    }\n\n    function setString(bytes32 _id, bytes32 _key, string calldata _value, bytes32 _senderRole) external {\n        _checkHasRegistryWriteAccess(_id, _senderRole);\n        _onlyConfigurableKey(_id, _key);\n        _setString(_id, _key, _value);\n        _afterEntryUpdate(_id);\n    }\n\n    function setBytes(bytes32 _id, bytes32 _key, bytes32 _value, bytes32 _senderRole) external {\n        _checkHasRegistryWriteAccess(_id, _senderRole);\n        _onlyConfigurableKey(_id, _key);\n        _setBytes(_id, _key, _value);\n        _afterEntryUpdate(_id);\n    }\n\n    function setBatch(\n        bytes32[] memory _ids,\n        bytes32[] memory _keys,\n        bool[] memory _boolValues,\n        uint256[] memory _uintValues,\n        address[] memory _addressValues,\n        string[] memory _stringValues,\n        bytes32[] memory _bytesValues,\n        bytes32 _senderRole\n    ) external {\n        _checkHasRegistryWriteAccess(_ids, _senderRole);\n        _onlyConfigurableKeys(_ids, _keys);\n        _setBatch(_ids, _keys, _boolValues, _uintValues, _addressValues, _stringValues, _bytesValues);\n        _afterEntryUpdate(_ids);\n    }\n\n    /**\n     * @notice Retrieves the address of the Investor Registry contract.\n     * @return The `IInvestorRegistry` interface instance representing the Investor Registry contract.\n     */\n    function getInvestorRegistry() external view returns (IInvestorRegistry) {\n        BaseRegistryStorage storage brs = _getBaseRegistryStorage();\n        return brs.investorRegistry;\n    }\n\n    /**\n     * @notice Retrieves the address of the Instrument Registry contract.\n     * @return The `IInstrumentRegistry` interface instance representing the Instrument Registry contract.\n     */\n    function getInstrumentRegistry() external view returns (IInstrumentRegistry) {\n        BaseRegistryStorage storage brs = _getBaseRegistryStorage();\n        return brs.instrumentRegistry;\n    }\n\n    /**\n     * @notice Retrieves the address of the Dealer Registry contract.\n     * @return The `IDealerRegistry` interface instance representing the Dealer Registry contract.\n     */\n    function getDealerRegistry() external view returns (IDealerRegistry) {\n        BaseRegistryStorage storage brs = _getBaseRegistryStorage();\n        return brs.dealerRegistry;\n    }\n\n    /**\n     * @notice Retrieves the address of the Fund Registry contract.\n     * @return The `IFundRegistry` interface instance representing the Fund Registry contract.\n     */\n    function getFundRegistry() external view returns (IFundRegistry) {\n        BaseRegistryStorage storage brs = _getBaseRegistryStorage();\n        return brs.fundRegistry;\n    }\n\n    /**\n     * @notice Retrieves the address of the Jurisdiction Registry contract.\n     * @return The `IEternalRegistryStorage` interface instance representing the Jurisdiction Registry contract.\n     */\n    function getJurisdictionRegistry() external view returns (IEternalRegistryStorage) {\n        BaseRegistryStorage storage brs = _getBaseRegistryStorage();\n        return brs.jurisdictionRegistry;\n    }\n\n    /**\n     * @notice Retrieves the address of the Operations Engine contract.\n     * @return The `IOperationsEngine` interface instance representing the Operations Engine contract.\n     */\n    function getOperationsEngine() external view returns (IOperationsEngine) {\n        BaseRegistryStorage storage brs = _getBaseRegistryStorage();\n        return brs.operationsEngine;\n    }\n\n    function initialize(bytes32 _validIdHash) public onlyInitializing {\n        BaseRegistryStorage storage brs = _getBaseRegistryStorage();\n        brs.IS_VALID_ID = _validIdHash;\n        _setReservedKey(GENERAL_DATA_ID, _validIdHash);\n        _setBool(GENERAL_DATA_ID, _validIdHash, true);\n        __UUPSUpgradeable_init();\n    }\n\n    // internals for single calls\n\n    /**\n     * @notice Set the basic reserved keys for new entries\n     * @param _id Id of the entry\n     */\n    function _setDefaultReservedKeys(bytes32 _id) internal virtual {\n        BaseRegistryStorage storage brs = _getBaseRegistryStorage();\n        _setReservedKey(_id, brs.IS_VALID_ID);\n    }\n\n    /**\n     * @notice Trigger updates to be done after entry updates\n     * @param _id Id of the updated entry\n     * @dev Override for different logic\n     */\n    function _afterEntryUpdate(bytes32 _id) internal virtual {}\n\n    /**\n     * @notice Trigger updates to be done after entry updates\n     * @param _ids Id of the entries updated\n     * @dev Override for different logic\n     * @dev Empty to avoid iterating the array when no logic is needed\n     */\n    function _afterEntryUpdate(bytes32[] memory _ids) internal virtual {}\n\n    /**\n     * @notice Checks if the caller can set values for a specific entry\n     * @param _id The id of the entry being accessed\n     * @param _senderRole The role sender claims to have\n     * @dev Tracking engine has special access and can call with empty args\n     */\n    function _checkHasRegistryWriteAccess(bytes32 _id, bytes32 _senderRole) internal view {\n        if (_roleRegistry().hasRole(REGISTRY_WRITER_ROLE, msg.sender)) return;\n        _checkHasAccess(_id, _senderRole);\n    }\n\n    /**\n     * @notice Checks if the caller can set values for a list of entries\n     * @param _ids The ids of the entries being accessed\n     * @param _senderRole The role sender claims to have\n     * @dev Tracking engine has special access and can call with empty args\n     */\n    function _checkHasRegistryWriteAccess(bytes32[] memory _ids, bytes32 _senderRole) internal view {\n        if (_roleRegistry().hasRole(REGISTRY_WRITER_ROLE, msg.sender)) return;\n        _checkHasAccess(_ids, _senderRole);\n    }\n\n    /**\n     * @notice Checks if the caller can set values for a specific entry\n     * @param _id Id of the entry being accessed\n     * @param _senderRole Role sender claims to have\n     * @dev Entry id needs to be valid\n     * @dev Override for different logic\n     */\n    function _checkHasAccess(bytes32 _id, bytes32 _senderRole) internal view virtual {\n        if (!(_isValidId(_id) && _hasAccess(_id, _senderRole))) {\n            revert IBaseRegistry_AccessDenied();\n        }\n    }\n\n    /**\n     * @notice Verify if the caller can access a specific entry\n     * @param _id Id of the entry being accessed\n     * @param _senderRole Role sender claims to have\n     * @return Y/N\n     * @dev Override for different logic\n     */\n    function _hasAccess(bytes32 _id, bytes32 _senderRole) internal view virtual returns (bool) {\n        return _roleHasAccess(_senderRole) || _hasExtraAccess(_id);\n    }\n\n    /**\n     * @notice Verify if the caller has special access to an entry\n     * @param _id Id of the entry being accessed\n     * @return Y/N\n     * @dev Override for different logic\n     */\n    function _hasExtraAccess(bytes32 _id) internal view virtual returns (bool) {}\n\n    /**\n     * @notice Verify if an entry is valid\n     * @param _id Id to verify\n     * @return Y/N\n     * @dev Override for different logic\n     */\n    function _isValidId(bytes32 _id) internal view virtual returns (bool) {\n        BaseRegistryStorage storage brs = _getBaseRegistryStorage();\n        return getBool(_id, brs.IS_VALID_ID);\n    }\n\n    /**\n     * @notice Check if an entry is valid\n     * @param _id Id to verify\n     */\n    function _checkIsValidId(bytes32 _id) internal view {\n        if (!_isValidId(_id)) {\n            revert IBaseRegistry_NotAValidId();\n        }\n    }\n\n    // internals for batch calls\n\n    /**\n     * @notice Checks if the caller can set values for a list of entries\n     * @param _ids Ids of the entries being accessed\n     * @param _senderRole Role sender claims to have\n     * @dev Each entry id needs to be valid\n     * @dev Override for different logic\n     */\n    function _checkHasAccess(bytes32[] memory _ids, bytes32 _senderRole) internal view virtual {\n        if (!_areValidIds(_ids) || !_hasAccess(_ids, _senderRole)) {\n            revert IBaseRegistry_AccessDenied();\n        }\n    }\n\n    /**\n     * @notice Verify if the caller can access a list of entries\n     * @param _ids Ids of the entries being accessed\n     * @param _senderRole Role sender claims to have\n     * @return Y/N\n     * @dev Override for different logic\n     */\n    function _hasAccess(bytes32[] memory _ids, bytes32 _senderRole) internal view virtual returns (bool) {\n        return _roleHasAccess(_senderRole) || _hasExtraAccess(_ids);\n    }\n\n    /**\n     * @notice Verify if the caller has special access to a list of entries\n     * @param _ids Ids of the entries being accessed\n     * @return Y/N\n     * @dev Override for different logic\n     */\n    function _hasExtraAccess(bytes32[] memory _ids) internal view virtual returns (bool) {\n        for (uint256 i; i < _ids.length; ++i) {\n            if (!_hasExtraAccess(_ids[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @notice Verify if a list of entries are valid\n     * @param _ids Ids to verify\n     * @return Y/N\n     * @dev Override for different logic\n     * @dev Override if entries validation is not needed to avoid iterating the list\n     */\n    function _areValidIds(bytes32[] memory _ids) internal view virtual returns (bool) {\n        for (uint256 i; i < _ids.length; ++i) {\n            if (!_isValidId(_ids[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @dev Retrieves the storage structure for the contract.\n     * @return store The storage object for the base registry.\n     */\n    function _getBaseRegistryStorage() internal pure returns (BaseRegistryStorage storage store) {\n        assembly {\n            store.slot := BASE_REGISTRY_STORAGE_SLOT\n        }\n    }\n\n    /**\n     * @notice Ensures that the provided ID is not a zero value.\n     * @dev Reverts with `IBaseRegistry_NotAValidId` if the ID is zero.\n     * @param _id The ID to validate.\n     */\n    function _nonZeroId(bytes32 _id) internal pure {\n        if (_id == 0) {\n            revert IBaseRegistry_NotAValidId();\n        }\n    }\n}\n"
    },
    "src/registries/BaseUserRegistry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {ECDSA} from \"openzeppelin-contracts/contracts/utils/cryptography/ECDSA.sol\";\n\nimport {BaseRegistry} from \"src/registries/BaseRegistry.sol\";\nimport {IUserRegistry} from \"src/interfaces/IUserRegistry.sol\";\n\n/**\n * @title BaseUserRegistry\n * @author Libre\n * @notice Provides functionality for managing wallets and associating them with user IDs.\n * @dev This contract verifies wallet ownership using ECDSA signatures and ensures that wallets are uniquely linked to user IDs.\n *\n * Features:\n * - Add a wallet to a user ID after verifying ownership with a signed message.\n * - Retrieve all wallets linked to a specific user ID.\n * - Get the user ID associated with a specific wallet.\n */\nabstract contract BaseUserRegistry is BaseRegistry, IUserRegistry {\n    using ECDSA for bytes32;\n\n    // keccak256(abi.encode(uint256(keccak256(\"BaseUserRegistry.storage\")) - 1)) & ~bytes32(uint256(0xff));\n    bytes32 private constant BASE_USER_REGISTRY_STORAGE_SLOT =\n        0x6f933317f0ef3f5c481822d7bb2f0d5186d0b51ef77db971f6da83b7e837e000;\n\n    /// @custom:storage-location erc7201:BaseUserRegistry.storage\n    struct BaseUserRegistryStorage {\n        // Mapping of wallet addresses (param1) to user IDs (param2)\n        mapping(address wallet => bytes32 userId) ownedBy;\n        // Mapping of user IDs (param1) to an array of wallet addresses (param2)\n        mapping(bytes32 userId => address[] wallets) ownedWallets;\n    }\n\n    function getWallets(bytes32 _userId) external view override returns (address[] memory) {\n        BaseUserRegistryStorage storage burs = _getBaseUserRegistryStorage();\n        return burs.ownedWallets[_userId];\n    }\n\n    /**\n     * @notice Adds a wallet to a user ID after verifying correct role\n     * @param _userId The ID of the user.\n     * @param _wallet The wallet address to associate with the user ID.\n     * @param _role The role used by the caller.\n     */\n    function addWallet(bytes32 _userId, address _wallet, bytes32 _role) public virtual override {\n        _checkRoleHasAccess(_role);\n        _checkIsValidId(_userId);\n        _addWallet(_userId, _wallet);\n    }\n\n    /**\n     * @notice Removes a wallet from a user ID.\n     * @param _wallet The wallet address to remove from the user ID.\n     * @param _role The role used by the caller.\n     * @return The user ID that the wallet was removed from.\n     *\n     * Requirements:\n     * - The `_wallet` must be associated with a user ID.\n     */\n    function removeWallet(address _wallet, bytes32 _role) public virtual returns (bytes32) {\n        _checkRoleHasAccess(_role);\n        BaseUserRegistryStorage storage burs = _getBaseUserRegistryStorage();\n        bytes32 _userId = burs.ownedBy[_wallet];\n        _checkIsValidId(_userId);\n\n        uint256 ownedWalletsLength = burs.ownedWallets[_userId].length;\n\n        for (uint256 i; i < ownedWalletsLength; i++) {\n            if (burs.ownedWallets[_userId][i] == _wallet) {\n                burs.ownedWallets[_userId][i] = burs.ownedWallets[_userId][ownedWalletsLength - 1];\n                burs.ownedWallets[_userId].pop();\n                break;\n            }\n        }\n        burs.ownedBy[_wallet] = 0x0;\n\n        emit WalletRemoved(_wallet);\n        return _userId;\n    }\n\n    function getIdFromWallet(address wallet) public view override returns (bytes32) {\n        BaseUserRegistryStorage storage burs = _getBaseUserRegistryStorage();\n        return burs.ownedBy[wallet];\n    }\n\n    /**\n     * @notice Internally adds a wallet to a user ID.\n     * @param _id The user ID to associate with the wallet.\n     * @param _wallet The wallet address to associate with the user ID.\n     *\n     * Requirements:\n     * - The `_wallet` must not already be associated with another user ID.\n     */\n    function _addWallet(bytes32 _id, address _wallet) internal {\n        BaseUserRegistryStorage storage burs = _getBaseUserRegistryStorage();\n\n        if (_roleRegistry().isBlacklisted(_wallet)) {\n            revert IUserRegistry_WalletBlacklisted();\n        }\n\n        if (burs.ownedBy[_wallet] != 0x0) {\n            revert IUserRegistry_WalletAlreadyClaimed();\n        }\n\n        burs.ownedWallets[_id].push(_wallet);\n        burs.ownedBy[_wallet] = _id;\n        emit WalletAdded(_wallet);\n    }\n\n    /**\n     * @dev Retrieves the storage structure for the contract.\n     * @return store The storage object for the base user registry.\n     */\n    function _getBaseUserRegistryStorage() internal pure returns (BaseUserRegistryStorage storage store) {\n        assembly {\n            store.slot := BASE_USER_REGISTRY_STORAGE_SLOT\n        }\n    }\n}\n"
    },
    "src/credentials/ResolverVerifier.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.28;\n\nimport {IRiscZeroVerifier} from \"risc0/IRiscZeroVerifier.sol\";\nimport {Steel} from \"risc0/steel/Steel.sol\";\nimport {IAccessVerifier, CredentialProofData} from \"src/interfaces/IAccessVerifier.sol\";\nimport {SchemaResolver} from \"eas-contracts/resolver/SchemaResolver.sol\";\nimport {IEAS, Attestation} from \"eas-contracts/IEAS.sol\";\nimport {IInvestorRegistry} from \"src/interfaces/IInvestorRegistry.sol\";\nimport \"src/utils/Constant.sol\";\n\n/**\n * @title ResolverVerifier\n * @notice This contract handles the verification of credentials and subscriptions using zkVM proofs.\n *         It integrates with RISC Zero Verifier and manages attestation schemas for investor compliance.\n * @dev The contract utilizes SchemaResolver for EAS-based attestation validation and implements IAccessVerifier.\n * @author Libre\n */\ncontract ResolverVerifier is SchemaResolver, IAccessVerifier {\n    /// @notice Image IDs of the zkVM binaries to accept verification from.\n    bytes32 public credentialImageID;\n    bytes32 public subscriptionImageID;\n\n    /// @notice RISC Zero verifier contract address.\n    IRiscZeroVerifier public immutable verifier;\n\n    /// @notice Investor registry to manage investor-related data and credentials.\n    IInvestorRegistry public immutable investorRegistry;\n\n    /// @notice Address of the policy viewer used to generate the proofs\n    address public immutable policyViewer;\n\n    /// @dev Error thrown when a non-investor registry address tries to update image IDs.\n    error ResolverVerifier_NotInvestorRegistry();\n\n    /// @dev Error thrown when a journal commitment fails validation.\n    error ResolverVerifier_InvalidCommitment();\n\n    constructor(\n        IEAS eas,\n        IInvestorRegistry _investorRegistry,\n        IRiscZeroVerifier _verifier,\n        bytes32 _credentialImageID,\n        bytes32 _subscriptionImageID,\n        address _policyViewer\n    ) SchemaResolver(eas) {\n        investorRegistry = _investorRegistry;\n        verifier = _verifier;\n        credentialImageID = _credentialImageID;\n        subscriptionImageID = _subscriptionImageID;\n        policyViewer = _policyViewer;\n    }\n\n    function updateImageIDs(bytes32 _credentialImageID, bytes32 _subscriptionImageID) external {\n        if (msg.sender != address(investorRegistry)) {\n            revert ResolverVerifier_NotInvestorRegistry();\n        }\n        credentialImageID = _credentialImageID;\n        subscriptionImageID = _subscriptionImageID;\n    }\n\n    function verifyCredential(CredentialProofData memory _proof) public view {\n        if (!Steel.validateCommitment(_proof.journal.commitment)) {\n            revert ResolverVerifier_InvalidCommitment();\n        }\n        bytes32 journalHash = sha256(abi.encode(_proof.journal));\n        verifier.verify(_proof.seal, credentialImageID, journalHash);\n    }\n\n    function verifySubscription(OrderProofData calldata _proof) public view {\n        if (!Steel.validateCommitment(_proof.journal.commitment)) {\n            revert ResolverVerifier_InvalidCommitment();\n        }\n        bytes32 journalHash = sha256(abi.encode(_proof.journal));\n        verifier.verify(_proof.seal, subscriptionImageID, journalHash);\n    }\n\n    /**\n     * @notice Handles logic for attestation verification.\n     * @param _attestation The attestation data.\n     * @return Whether the attestation passes verification.\n     * @dev Includes credential validation and instrument-specific compliance checks.\n     */\n    function onAttest(Attestation calldata _attestation, uint256 /*value*/ ) internal view override returns (bool) {\n        if (_attestation.attester != address(investorRegistry)) {\n            return false;\n        }\n        SteelProofData memory steelProofData = investorRegistry.getTempSteelProofData();\n        //Decode attestation schema\n        (bytes32 investorId, bytes32[] memory instrumentIds, uint64[] memory instrumentExpiryTimestamps) =\n            abi.decode(_attestation.data, (bytes32, bytes32[], uint64[]));\n\n        if (instrumentIds.length != instrumentExpiryTimestamps.length) {\n            return false;\n        }\n\n        bytes32 currentCredentialId = investorRegistry.getBytes(investorId, CREDENTIAL_ID);\n        if (currentCredentialId != bytes32(0)) {\n            Attestation memory oldAttestation = _eas.getAttestation(currentCredentialId);\n            if (oldAttestation.revocationTime == block.timestamp) {\n                return true;\n            }\n        }\n\n        CredentialProofData memory proof;\n        proof.journal.commitment = steelProofData.commitment;\n        proof.journal.expiryTimestamp = _attestation.expirationTime;\n        proof.journal.investorId = investorId;\n        proof.journal.policyViewer = policyViewer;\n        proof.seal = steelProofData.seal;\n\n        {\n            //Decode old attestation schema\n            bytes32 oldAttestationId = investorRegistry.getBytes(investorId, CREDENTIAL_ID);\n            if (oldAttestationId == bytes32(0)) {\n                proof.journal.instrumentIds = instrumentIds;\n                proof.journal.instrumentExpiryTimestamps = instrumentExpiryTimestamps;\n            } else {\n                Attestation memory oldAttestation = _eas.getAttestation(oldAttestationId);\n                (, bytes32[] memory oldInstrumentIds, uint64[] memory oldInstrumentExpiryTimestamps) =\n                    abi.decode(oldAttestation.data, (bytes32, bytes32[], uint64[]));\n\n                //only keeping instruments that are new or updated for proof checking\n                bytes32[] memory newInstrumentIds = new bytes32[](instrumentIds.length);\n                uint64[] memory newInstrumentExpiryTimestamps = new uint64[](instrumentExpiryTimestamps.length);\n                uint256 newOrUpdatedCount;\n                for (uint256 i; i < instrumentIds.length; ++i) {\n                    bool newOrUpdated = true;\n                    for (uint256 j; j < oldInstrumentIds.length; ++j) {\n                        if (instrumentIds[i] == oldInstrumentIds[j]) {\n                            if (instrumentExpiryTimestamps[i] == oldInstrumentExpiryTimestamps[j]) {\n                                newOrUpdated = false;\n                            }\n                            break;\n                        }\n                    }\n                    if (newOrUpdated) {\n                        newInstrumentIds[newOrUpdatedCount] = (instrumentIds[i]);\n                        newInstrumentExpiryTimestamps[newOrUpdatedCount] = (instrumentExpiryTimestamps[i]);\n                        ++newOrUpdatedCount;\n                    }\n                }\n\n                //Resize Arrays to have length of newOrUpdatedCount\n                assembly {\n                    mstore(newInstrumentIds, newOrUpdatedCount)\n                    mstore(newInstrumentExpiryTimestamps, newOrUpdatedCount)\n                }\n\n                proof.journal.instrumentIds = newInstrumentIds;\n                proof.journal.instrumentExpiryTimestamps = newInstrumentExpiryTimestamps;\n            }\n        }\n\n        //reverts if proof is invalid\n        verifyCredential(proof);\n\n        return true;\n    }\n\n    /**\n     * @notice Handles logic for attestation revocation.\n     * @return Always returns true as all revocation requests are allowed.\n     */\n    function onRevoke(Attestation calldata, /*attestation*/ uint256 /*value*/ ) internal pure override returns (bool) {\n        return true;\n    }\n}\n"
    },
    "src/utils/GatewayUtils.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.28;\n\nimport {IGatewayManager} from \"src/interfaces/IGatewayManager.sol\";\n\n/**\n * @title GatewayUtils\n * @author Libre\n * @notice Utility functions for gateway contracts\n * @dev Shared utilities used by LibreCoreGateway and GatewayManager\n */\nlibrary GatewayUtils {\n    /**\n     * @notice Error thrown when input data is invalid\n     */\n    error GatewayUtils_InvalidInput();\n\n    /**\n     * @notice Bridges wallet address changes to other chains\n     * @param _gatewayManager The gateway manager contract\n     * @param _userId The ID of the user\n     * @param _wallet The wallet address being added or removed\n     * @param _isAdd True if adding a wallet, false if removing\n     * @param _nativeChainSelector The chain selector for the native chain\n     * @param _gatewayManagerRole The role required for cross-chain operations\n     */\n    function bridgeAddressChange(\n        IGatewayManager _gatewayManager,\n        bytes32 _userId,\n        address _wallet,\n        bool _isAdd,\n        uint16 _nativeChainSelector,\n        bytes32 _gatewayManagerRole\n    ) public {\n        if (address(_gatewayManager) == address(0)) {\n            return;\n        }\n\n        bytes memory addressChange = encodeAddressChange(_wallet, _isAdd, _nativeChainSelector);\n\n        bytes[] memory addressChanges = new bytes[](1);\n        addressChanges[0] = addressChange;\n\n        // Bridge the address change to other chains\n        _gatewayManager.manageCrossChainAddresses(_gatewayManagerRole, _userId, addressChanges);\n    }\n\n    /**\n     * @notice Decodes an address change byte array\n     * @param addressChange The encoded address change\n     * @return isAdd True if adding an address, false if removing\n     * @return chainId The chain ID for the address\n     * @return walletAddress The wallet address being added or removed\n     */\n    function decodeAddressChange(bytes calldata addressChange)\n        public\n        pure\n        returns (bool isAdd, uint16 chainId, bytes memory walletAddress)\n    {\n        // excluding the action and chainId, the address has to be of at least one byte\n        if (addressChange.length < 4) {\n            revert GatewayUtils_InvalidInput();\n        }\n\n        // Extract isAdd, first byte (0 -> Add, 1 -> Remove)\n        isAdd = addressChange[0] == 0x00;\n\n        // Extract chainId (bytes 1-2)\n        chainId = uint16(uint8(addressChange[1])) << 8 | uint16(uint8(addressChange[2]));\n\n        // Remaining bytes are the wallet address\n        uint256 walletLength = addressChange.length - 3;\n        walletAddress = new bytes(walletLength);\n        for (uint256 i; i < walletLength; ++i) {\n            walletAddress[i] = addressChange[i + 3];\n        }\n    }\n\n    /**\n     * @notice Creates an encoded address change\n     * @param _wallet The wallet address being added or removed\n     * @param _isAdd True if adding a wallet, false if removing\n     * @param _chainSelector The chain selector for the chain\n     * @return The encoded address change\n     */\n    function encodeAddressChange(address _wallet, bool _isAdd, uint16 _chainSelector)\n        public\n        pure\n        returns (bytes memory)\n    {\n        // Create the address change encoding: [action byte][2 bytes chainSelector][n bytes address]\n        bytes memory addressChange = new bytes(23); // 1 byte action + 2 bytes chainSelector + 20 bytes address\n        addressChange[0] = _isAdd ? bytes1(0x00) : bytes1(0x01); // 0x00 for add, 0x01 for remove\n\n        // Set the chainSelector\n        addressChange[1] = bytes1(uint8(_chainSelector >> 8));\n        addressChange[2] = bytes1(uint8(_chainSelector));\n\n        // Copy the wallet address bytes\n        bytes memory walletBytes = abi.encodePacked(_wallet);\n        for (uint256 i = 0; i < 20; i++) {\n            addressChange[i + 3] = walletBytes[i];\n        }\n\n        return addressChange;\n    }\n}\n"
    },
    "lib/eas-contracts/contracts/ISemver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/// @title ISemver\n/// @notice A semver interface.\ninterface ISemver {\n    /// @notice Returns the full semver contract version.\n    /// @return Semver contract version as a string.\n    function version() external view returns (string memory);\n}\n"
    },
    "lib/eas-contracts/contracts/Common.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n// A representation of an empty/uninitialized UID.\nbytes32 constant EMPTY_UID = 0;\n\n// A zero expiration represents an non-expiring attestation.\nuint64 constant NO_EXPIRATION_TIME = 0;\n\nerror AccessDenied();\nerror DeadlineExpired();\nerror InvalidEAS();\nerror InvalidLength();\nerror InvalidSignature();\nerror NotFound();\n\n/// @notice A struct representing ECDSA signature data.\nstruct Signature {\n    uint8 v; // The recovery ID.\n    bytes32 r; // The x-coordinate of the nonce R.\n    bytes32 s; // The signature data.\n}\n\n/// @notice A struct representing a single attestation.\nstruct Attestation {\n    bytes32 uid; // A unique identifier of the attestation.\n    bytes32 schema; // The unique identifier of the schema.\n    uint64 time; // The time when the attestation was created (Unix timestamp).\n    uint64 expirationTime; // The time when the attestation expires (Unix timestamp).\n    uint64 revocationTime; // The time when the attestation was revoked (Unix timestamp).\n    bytes32 refUID; // The UID of the related attestation.\n    address recipient; // The recipient of the attestation.\n    address attester; // The attester/sender of the attestation.\n    bool revocable; // Whether the attestation is revocable.\n    bytes data; // Custom attestation data.\n}\n\n/// @notice A helper function to work with unchecked iterators in loops.\nfunction uncheckedInc(uint256 i) pure returns (uint256 j) {\n    unchecked {\n        j = i + 1;\n    }\n}\n"
    },
    "lib/openzeppelin-contracts-upgradeable/contracts/token/ERC20/extensions/IERC20MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.19;\n\nimport \"../IERC20Upgradeable.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "lib/risc0-ethereum/contracts/src/IRiscZeroVerifier.sol": {
      "content": "// Copyright 2024 RISC Zero, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n\npragma solidity ^0.8.9;\n\nimport {reverseByteOrderUint32} from \"./Util.sol\";\n\n/// @notice A receipt attesting to the execution of a guest program.\n/// @dev A receipt contains two parts: a seal and a claim. The seal is a zero-knowledge proof\n/// attesting to knowledge of a zkVM execution resulting in the claim. The claim is a set of public\n/// outputs for the execution. Crucially, the claim includes the journal and the image ID. The\n/// image ID identifies the program that was executed, and the journal is the public data written\n/// by the program. Note that this struct only contains the claim digest, as can be obtained with\n/// the `digest()` function on `ReceiptClaimLib`.\nstruct Receipt {\n    bytes seal;\n    bytes32 claimDigest;\n}\n\n/// @notice Public claims about a zkVM guest execution, such as the journal committed to by the guest.\n/// @dev Also includes important information such as the exit code and the starting and ending system\n/// state (i.e. the state of memory). `ReceiptClaim` is a \"Merkle-ized struct\" supporting\n/// partial openings of the underlying fields from a hash commitment to the full structure.\nstruct ReceiptClaim {\n    /// @notice Digest of the SystemState just before execution has begun.\n    bytes32 preStateDigest;\n    /// @notice Digest of the SystemState just after execution has completed.\n    bytes32 postStateDigest;\n    /// @notice The exit code for the execution.\n    ExitCode exitCode;\n    /// @notice A digest of the input to the guest.\n    /// @dev This field is currently unused and must be set to the zero digest.\n    bytes32 input;\n    /// @notice Digest of the Output of the guest, including the journal\n    /// and assumptions set during execution.\n    bytes32 output;\n}\n\nlibrary ReceiptClaimLib {\n    using OutputLib for Output;\n    using SystemStateLib for SystemState;\n\n    bytes32 constant TAG_DIGEST = sha256(\"risc0.ReceiptClaim\");\n\n    // Define a constant to ensure hashing is done at compile time. Can't use the\n    // SystemStateLib.digest method here because the Solidity compiler complains.\n    bytes32 constant SYSTEM_STATE_ZERO_DIGEST = 0xa3acc27117418996340b84e5a90f3ef4c49d22c79e44aad822ec9c313e1eb8e2;\n\n    /// @notice Construct a ReceiptClaim from the given imageId and journalDigest.\n    ///         Returned ReceiptClaim will represent a successful execution of the zkVM, running\n    ///         the program committed by imageId and resulting in the journal specified by\n    ///         journalDigest.\n    /// @param imageId The identifier for the guest program.\n    /// @param journalDigest The SHA-256 digest of the journal bytes.\n    /// @dev Input hash and postStateDigest are set to all-zeros (i.e. no committed input, or\n    ///      final memory state), the exit code is (Halted, 0), and there are no assumptions\n    ///      (i.e. the receipt is unconditional).\n    function ok(bytes32 imageId, bytes32 journalDigest) internal pure returns (ReceiptClaim memory) {\n        return ReceiptClaim(\n            imageId,\n            SYSTEM_STATE_ZERO_DIGEST,\n            ExitCode(SystemExitCode.Halted, 0),\n            bytes32(0),\n            Output(journalDigest, bytes32(0)).digest()\n        );\n    }\n\n    function digest(ReceiptClaim memory claim) internal pure returns (bytes32) {\n        return sha256(\n            abi.encodePacked(\n                TAG_DIGEST,\n                // down\n                claim.input,\n                claim.preStateDigest,\n                claim.postStateDigest,\n                claim.output,\n                // data\n                uint32(claim.exitCode.system) << 24,\n                uint32(claim.exitCode.user) << 24,\n                // down.length\n                uint16(4) << 8\n            )\n        );\n    }\n}\n\n/// @notice Commitment to the memory state and program counter (pc) of the zkVM.\n/// @dev The \"pre\" and \"post\" fields of the ReceiptClaim are digests of the system state at the\n///      start are stop of execution. Programs are loaded into the zkVM by creating a memory image\n///      of the loaded program, and creating a system state for initializing the zkVM. This is\n///      known as the \"image ID\".\nstruct SystemState {\n    /// @notice Program counter.\n    uint32 pc;\n    /// @notice Root hash of a merkle tree which confirms the integrity of the memory image.\n    bytes32 merkle_root;\n}\n\nlibrary SystemStateLib {\n    bytes32 constant TAG_DIGEST = sha256(\"risc0.SystemState\");\n\n    function digest(SystemState memory state) internal pure returns (bytes32) {\n        return sha256(\n            abi.encodePacked(\n                TAG_DIGEST,\n                // down\n                state.merkle_root,\n                // data\n                reverseByteOrderUint32(state.pc),\n                // down.length\n                uint16(1) << 8\n            )\n        );\n    }\n}\n\n/// @notice Exit condition indicated by the zkVM at the end of the guest execution.\n/// @dev Exit codes have a \"system\" part and a \"user\" part. Semantically, the system part is set to\n/// indicate the type of exit (e.g. halt, pause, or system split) and is directly controlled by the\n/// zkVM. The user part is an exit code, similar to exit codes used in Linux, chosen by the guest\n/// program to indicate additional information (e.g. 0 to indicate success or 1 to indicate an\n/// error).\nstruct ExitCode {\n    SystemExitCode system;\n    uint8 user;\n}\n\n/// @notice Exit condition indicated by the zkVM at the end of the execution covered by this proof.\n/// @dev\n/// `Halted` indicates normal termination of a program with an interior exit code returned from the\n/// guest program. A halted program cannot be resumed.\n///\n/// `Paused` indicates the execution ended in a paused state with an interior exit code set by the\n/// guest program. A paused program can be resumed such that execution picks up where it left\n/// of, with the same memory state.\n///\n/// `SystemSplit` indicates the execution ended on a host-initiated system split. System split is\n/// mechanism by which the host can temporarily stop execution of the execution ended in a system\n/// split has no output and no conclusions can be drawn about whether the program will eventually\n/// halt. System split is used in continuations to split execution into individually provable segments.\nenum SystemExitCode {\n    Halted,\n    Paused,\n    SystemSplit\n}\n\n/// @notice Output field in the `ReceiptClaim`, committing to a claimed journal and assumptions list.\nstruct Output {\n    /// @notice Digest of the journal committed to by the guest execution.\n    bytes32 journalDigest;\n    /// @notice Digest of the ordered list of `ReceiptClaim` digests corresponding to the\n    /// calls to `env::verify` and `env::verify_integrity`.\n    /// @dev Verifying the integrity of a `Receipt` corresponding to a `ReceiptClaim` with a\n    /// non-empty assumptions list does not guarantee unconditionally any of the claims over the\n    /// guest execution (i.e. if the assumptions list is non-empty, then the journal digest cannot\n    /// be trusted to correspond to a genuine execution). The claims can be checked by additional\n    /// verifying a `Receipt` for every digest in the assumptions list.\n    bytes32 assumptionsDigest;\n}\n\nlibrary OutputLib {\n    bytes32 constant TAG_DIGEST = sha256(\"risc0.Output\");\n\n    function digest(Output memory output) internal pure returns (bytes32) {\n        return sha256(\n            abi.encodePacked(\n                TAG_DIGEST,\n                // down\n                output.journalDigest,\n                output.assumptionsDigest,\n                // down.length\n                uint16(2) << 8\n            )\n        );\n    }\n}\n\n/// @notice Error raised when cryptographic verification of the zero-knowledge proof fails.\nerror VerificationFailed();\n\n/// @notice Verifier interface for RISC Zero receipts of execution.\ninterface IRiscZeroVerifier {\n    /// @notice Verify that the given seal is a valid RISC Zero proof of execution with the\n    ///     given image ID and journal digest. Reverts on failure.\n    /// @dev This method additionally ensures that the input hash is all-zeros (i.e. no\n    /// committed input), the exit code is (Halted, 0), and there are no assumptions (i.e. the\n    /// receipt is unconditional).\n    /// @param seal The encoded cryptographic proof (i.e. SNARK).\n    /// @param imageId The identifier for the guest program.\n    /// @param journalDigest The SHA-256 digest of the journal bytes.\n    function verify(bytes calldata seal, bytes32 imageId, bytes32 journalDigest) external view;\n\n    /// @notice Verify that the given receipt is a valid RISC Zero receipt, ensuring the `seal` is\n    /// valid a cryptographic proof of the execution with the given `claim`. Reverts on failure.\n    /// @param receipt The receipt to be verified.\n    function verifyIntegrity(Receipt calldata receipt) external view;\n}\n"
    },
    "src/interfaces/IBaseRegistry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {IEternalRegistryStorage} from \"src/interfaces/IEternalRegistryStorage.sol\";\n\n/**\n * @title IBaseRegistry\n * @notice Interface for the base registry, which provides functionality for tracking and retrieving data\n * specific to modules that interact with the registry.\n * @dev The tracked data can be queried via a delegatecall callback to the relevant module,\n * which implements the query logic.\n */\ninterface IBaseRegistry is IEternalRegistryStorage {\n    /**\n     * @notice Thrown when an unauthorized caller tries to access a restricted function or resource.\n     */\n    error IBaseRegistry_AccessDenied();\n\n    /**\n     * @notice Thrown when an action is attempted on a module that is not registered in the registry.\n     */\n    error IBaseRegistry_NotRegisteredModule();\n\n    /**\n     * @notice Thrown when an invalid or non-existent ID is provided for an operation.\n     */\n    error IBaseRegistry_NotAValidId();\n\n    /**\n     * @notice Thrown when the system fails to retrieve the tracked data for a specific operation or ID.\n     */\n    error IBaseRegistry_FailedToGetTrackedData();\n\n    /**\n     * @notice Get the tracked data of the registry\n     * @param _data Data to be used by the module to get the tracked data\n     * @return bytes memory of the tracked data\n     * @dev This function is used to get the tracked data from the registry\n     * by doing a delegatecall callback to the module requesting the data\n     * which can implement the query logic\n     */\n    function getTrackedData(bytes memory _data) external returns (bytes memory);\n}\n"
    },
    "src/utils/Types.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {Steel} from \"risc0/steel/Steel.sol\";\n\nstruct SteelProofData {\n    //Block hash commitment for Steel\n    Steel.Commitment commitment;\n    //Seal for Steel\n    bytes seal;\n}\n\nstruct CredentialProofData {\n    //Journal Data for Steel\n    CredentialJournal journal;\n    //Seal for Steel\n    bytes seal;\n}\n\n// @notice Journal that is committed to for Credentials\nstruct CredentialJournal {\n    //Block hash commitment for Steel\n    Steel.Commitment commitment;\n    //Id of the investor\n    bytes32 investorId;\n    //Credential expiry timestamp\n    uint64 expiryTimestamp;\n    //Ids of instruments the investor is registered for\n    bytes32[] instrumentIds;\n    //Access expiry timestamps for instruments the investor is registered for\n    uint64[] instrumentExpiryTimestamps;\n    address policyViewer;\n}\n\nstruct OrderProofData {\n    //Journal Data for Steel\n    OrderJournal journal;\n    //Seal for Steel\n    bytes seal;\n}\n\n// @notice Journal that is committed to for Orders\nstruct OrderJournal {\n    //Block hash commitment for Steel\n    Steel.Commitment commitment;\n    //Id of the investor\n    bytes32 investorId;\n    //Id of the instrument the investor is subscribing or redeeming to\n    bytes32 instrumentId;\n    //Amount the investor is subscribing or redeeming with\n    uint256 amount;\n    address policyViewer;\n}\n"
    },
    "src/interfaces/IFundRegistry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {IBaseRegistry} from \"src/interfaces/IBaseRegistry.sol\";\nimport {IRoleRegistry} from \"src/interfaces/IRoleRegistry.sol\";\nimport {IOperationsEngine} from \"src/interfaces/IOperationsEngine.sol\";\n\n/**\n * @title IFundRegistry\n * @author Libre\n * @notice Interface for managing and storing information related to funds within a registry.\n * Provides functionality to initialize the registry, add new funds, and emit events for key actions.\n */\ninterface IFundRegistry is IBaseRegistry {\n    /// @notice Error raised when attempting to register a fund that is already registered.\n    error IFundRegistry_AlreadyRegistered();\n\n    /**\n     * @notice Emited when a new Fund is added\n     * @param fundId Id of the new fund\n     */\n    event NewFundAdded(bytes32 indexed fundId);\n\n    /**\n     * @notice Initialize the registry\n     * @param _roleRegistry Address of the role registry\n     */\n    function initialize(IRoleRegistry _roleRegistry, IOperationsEngine _operationsEngine) external;\n\n    /**\n     * @notice Adds a new fund to the registry\n     * @param _senderRole Role of the sender which allow the operation execution\n     * @param _fundId The ID of the fund\n     */\n    function addNewFund(bytes32 _senderRole, bytes32 _fundId) external;\n}\n"
    },
    "src/interfaces/operations/IOperationModule.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {IInvestorRegistry} from \"src/interfaces/IInvestorRegistry.sol\";\nimport {IFundRegistry} from \"src/interfaces/IFundRegistry.sol\";\nimport {IDealerRegistry} from \"src/interfaces/IDealerRegistry.sol\";\nimport {IInstrumentRegistry} from \"src/interfaces/IInstrumentRegistry.sol\";\nimport {IEternalRegistryStorage} from \"src/interfaces/IEternalRegistryStorage.sol\";\nimport {IRoleRegistry} from \"src/interfaces/IRoleRegistry.sol\";\n\nenum OPERATIONS {\n    // Transfer specific operations:\n    TRANSFER,\n    FORCED_TRANSFER,\n    RECEIVE,\n    SEND,\n    CLAWBACK,\n    // Subscription specific operations:\n    ADVISED_CREATE_SUBSCRIPTION,\n    CREATE_SUBSCRIPTION,\n    SUBSCRIPTION_EXECUTION_DATE_CALCULATION,\n    SETTLE_SUBSCRIPTIONS,\n    SETTLE_SUBSCRIPTION_PER_ORDER,\n    SUBSCRIPTION_CANCELLATION,\n    // Redemption specific operations:\n    ADVISED_CREATE_REDEMPTION,\n    CREATE_REDEMPTION,\n    REDEMPTION_EXECUTION_DATE_CALCULATION,\n    REDEMPTION_CANCELLATION,\n    SETTLE_REDEMPTIONS,\n    SETTLE_REDEMPTION_PER_ORDER,\n    FORCED_REDEMPTION,\n    REDEMPTION_FEE,\n    // Secondary Market specific operations:\n    FILL,\n    ORDER,\n    TRADE,\n    // NAV operations:\n    UPDATE_AUDITED_NAV_PER_SHARE\n}\n\ninterface IOperationModule {\n    /**\n     * @return The list of operations associated with a module\n     * @dev It should contains all the Operation ids of all\n     * the IOperations it implements\n     */\n    function getOperations() external pure returns (OPERATIONS[] memory);\n\n    /**\n     * @return Returns the name of the module\n     */\n    function name() external pure returns (string memory);\n\n    /**\n     * @return Returns the hash of the module name\n     */\n    function nameHash() external pure returns (bytes32);\n}\n"
    },
    "lib/openzeppelin-contracts-upgradeable/contracts/access/IAccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.19;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControlUpgradeable {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.19;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "src/interfaces/ILibreCoreGateway.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {IInvestorRegistry} from \"src/interfaces/IInvestorRegistry.sol\";\nimport {IInstrumentRegistry} from \"src/interfaces/IInstrumentRegistry.sol\";\nimport {IRoleRegistry} from \"src/interfaces/IRoleRegistry.sol\";\nimport {IGatewayManager} from \"src/interfaces/IGatewayManager.sol\";\nimport {Attestation} from \"eas-contracts/IEAS.sol\";\n\n/**\n * @notice Structure representing token transfer details across chains\n * @dev Used for both locking and unlocking operations\n */\nstruct TokenTransfer {\n    uint16 chainSelector; // Unique 16-bit Custom Chain ID where the Token is transfered\n    bytes32 instrumentId; // Instrument ID associated with the security token\n    bytes32 investorId; // Investor ID associated with the sender\n    bytes receiver; // Recipient's address for minting/unlocking\n    uint256 amount; // Amount of the asset to transfer\n}\n\n/**\n * @notice Structure for managing investor addresses across specific chain\n * @dev Each address change is encoded as: [1 byte action][n bytes address]\n */\nstruct ChainInvestorAddresses {\n    // Unique investor ID\n    bytes32 investorId;\n    // Unique chain ID\n    uint16 chainSelector;\n    // Address size for that chain\n    uint8 addressSize;\n    // A list of concatenated bytes describing a change in addresses\n    // Format `addressChanges`` := bytes1 action ++ bytes accountAddress\n    // where `action`: 0b0 -> Add, 0b1 -> Remove\n    bytes[] addressChanges;\n}\n\n/// @notice Interface for the Libre Core Gateway.\ninterface ILibreCoreGateway {\n    // Events\n    /**\n     * @notice Emitted when tokens are locked on source chain\n     * @param encodedTransferDetails ABI-encoded TokenTransfer struct\n     */\n    event TokenLockedAndBridged(bytes encodedTransferDetails);\n\n    /**\n     * @notice Emitted when tokens are unlocked on destination chain\n     * @param encodedTransferDetails ABI-encoded TokenTransfer struct\n     */\n    event TokenUnlocked(bytes encodedTransferDetails);\n\n    /**\n     * @notice Emitted when a credential is bridged to other chains\n     * @param investorId Investor ID of the investor\n     * @param chainSelectors Array of investor preffered chains on which credential to be bridged\n     * @param credentialId Unique identifier of the bridged credential\n     */\n    event CredentialBridged(bytes32 investorId, uint16[] chainSelectors, bytes32 credentialId);\n\n    /**\n     * @notice Emitted when investor chain-specific addresses are bridged\n     * @param investorId Investor ID of the investor\n     * @param chainSelectors Array of investor preferred chains on which addresses updates to be bridged\n     * @param encodedChainInvestorAddresses ABI-encoded ChainInvestorAddresses struct\n     */\n    event ChainInvestorAddressesBridged(\n        bytes32 investorId, uint16[] chainSelectors, bytes encodedChainInvestorAddresses\n    );\n\n    /**\n     * @notice Emitted when chain support status is updated\n     * @param chainSelector Chain ID whose support status changed\n     * @param isSupported New support status\n     */\n    event ChainSupportUpdated(uint16 chainSelector, bool isSupported);\n\n    /**\n     * @notice Emitted when chain variable length address support status is updated\n     * @param _chainSelector Chain ID whose support status changed\n     * @param _isVariableLengthAddress New support status\n     */\n    event ChainVariableLengthAddressSupportUpdated(uint16 _chainSelector, bool _isVariableLengthAddress);\n\n    // Custom Errors\n    /// @notice Thrown when operation is attempted on an unsupported chain\n    /// @param chainSelector The unsupported chain ID\n    error CoreGateway_ChainNotSupported(uint16 chainSelector);\n\n    /// @notice Thrown when the chain selector (chain ID) not matches with Native chain ID for unlock requests\n    error CoreGateway_InvalidNativeChainSelector();\n\n    /// @notice Thrown when token address is not found or invalid\n    /// @param token The invalid token address\n    error CoreGateway_TokenAddressNotFound(address token);\n\n    /// @notice Thrown when attempting transfer with zero amount\n    error CoreGateway_ZeroAmount();\n\n    /// @notice Thrown when transfer validation fails\n    error CoreGateway_InvalidTransfer();\n\n    /// @notice Thrown when provided investor id is not found\n    error CoreGateway_InvalidInvestor();\n\n    /// @notice Thrown when wrong inputs are provided\n    error CoreGateway_InvalidInput();\n\n    /// @notice Thrown when credential to be bridged are not stored or mismatches with registry\n    error CoreGateway_InvalidCredential();\n\n    /// @notice Thrown when an attempted status update results in no actual change.\n    error CoreGateway_NoStatusChanged();\n\n    /**\n     * @notice Initializes the gateway contract\n     * @param _instrumentRegistry Address of the Instrument Registry\n     * @param _investorRegistry Address of the Investor Registry\n     * @param _gatewayManager Address of the Gateway Manager\n     * @param _roleRegistry Address of the Role Registry\n     * @param _nativeChainSelector Native Custom Chain ID\n     * @param _supportedChains Array of supported custom chain Ids\n     */\n    function initialize(\n        IInstrumentRegistry _instrumentRegistry,\n        IInvestorRegistry _investorRegistry,\n        IGatewayManager _gatewayManager,\n        IRoleRegistry _roleRegistry,\n        uint16 _nativeChainSelector,\n        uint16[] memory _supportedChains\n    ) external;\n\n    /**\n     * @notice Locks tokens for cross-chain transfer and emits event for minting\n     * @dev Validates investor credentials and cross-chain addresses before locking\n     * @param transferDetails The details of the token transfer.\n     */\n    function lockAndBridge(TokenTransfer calldata transferDetails) external;\n\n    /**\n     * @notice Unlocks tokens on the source chain\n     * @dev Called by bridge operators to release tokens to the recipient\n     * @param _senderRole The role of the caller\n     * @param encodedTransferDetails ABI-encoded transfer details.\n     */\n    function unlock(bytes32 _senderRole, bytes calldata encodedTransferDetails) external;\n\n    /**\n     * @notice Bridges a credential to one or more destination chains.\n     * @dev Perform below steps:\n     *      1. Verifies all destination chains are supported\n     *      2. Validates the attestation matches the stored credential for the investor\n     *      3. Emits CredentialBridged event for cross-chain communication\n     * @param _senderRole The role of the caller\n     * @param attestation The attestation details to bridge.\n     * @param destinationChainSelectors Array of destination chain IDs.\n     */\n    function bridgeCredential(\n        bytes32 _senderRole,\n        Attestation calldata attestation,\n        uint16[] calldata destinationChainSelectors\n    ) external;\n\n    /**\n     * @notice Bridges investor addresses updates.\n     * @dev Processes and broadcasts chain specific address changes across investor preferred chains\n     *         Emits `ChainInvestorAddressesBridged` event for each chain's address updates.\n     *\n     * @param _senderRole The role of the caller.\n     * @param _investorId The unique identifier of the investor whose addresses are being updated.\n     * @param _addressChanges ABI-encoded updates representing address changes per chain or context.\n     * @param chainSelectors Array of investor preferred chains on which addresses updates to be bridged\n     */\n    function bridgeInvestorAddresses(\n        bytes32 _senderRole,\n        bytes32 _investorId,\n        bytes[] calldata _addressChanges,\n        uint16[] calldata chainSelectors\n    ) external;\n\n    /**\n     * @notice Pauses all gateway operations\n     * @param _senderRole The role of the caller\n     */\n    function pause(bytes32 _senderRole) external;\n\n    /**\n     * @notice Unpauses gateway operations\n     * @param _senderRole The role of the caller\n     */\n    function unpause(bytes32 _senderRole) external;\n\n    /**\n     * @notice Enables or disables support for a specific chain.\n     * @param _senderRole The role of the caller\n     * @param chainSelector The Custom chain ID.\n     * @param isSupported Whether the chain is supported.\n     */\n    function setChainSupport(bytes32 _senderRole, uint16 chainSelector, bool isSupported) external;\n\n    /**\n     * @notice Enables or disables support for variable length addresses for a specific chain.\n     * @param _senderRole The role of the caller\n     * @param _chainSelector The Custom chain ID.\n     * @param _isVariableLengthAddress Whether variable length addresses for the chain are supported.\n     */\n    function setChainVariableLengthAddressSupport(\n        bytes32 _senderRole,\n        uint16 _chainSelector,\n        bool _isVariableLengthAddress\n    ) external;\n\n    /**\n     * @notice Retrieves the total amount of a specific instrument/token locked in the gateway.\n     * @param instrumentId The Instrument ID associated with the security token\n     * @return The total amount of the token locked in the gateway\n     */\n    function getLockedBalance(bytes32 instrumentId) external view returns (uint256);\n\n    /**\n     * @notice Checks if a chain is supported.\n     * @param chainSelector The ID of the chain to check.\n     * @return True if the chain is supported, false otherwise.\n     */\n    function isSupportedChain(uint16 chainSelector) external view returns (bool);\n\n    /**\n     * @notice Gets the list of supported chains\n     * @return uint16[] Array of supported chain IDs\n     */\n    function getSupportedChains() external view returns (uint16[] memory);\n}\n"
    },
    "src/utils/JurisdictionEncodings.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n//The encodings used for jurisdictions are based and ordered after the ISO 3166 standard as of 2023/11/28\n//(https://en.wikipedia.org/wiki/List_of_ISO_3166_country_codes)\n//Any new additions after this date will be added at the end as to not modify existing encodings\n//allowed values are in the range of: 2^x, 0  x  255\nuint256 constant AF = 2 ** 0;\nuint256 constant AX = 2 ** 1;\nuint256 constant AL = 2 ** 2;\nuint256 constant DZ = 2 ** 3;\nuint256 constant AS = 2 ** 4;\nuint256 constant AD = 2 ** 5;\nuint256 constant AO = 2 ** 6;\nuint256 constant AI = 2 ** 7;\nuint256 constant AQ = 2 ** 8;\nuint256 constant AG = 2 ** 9;\nuint256 constant AR = 2 ** 10;\nuint256 constant AM = 2 ** 11;\nuint256 constant AW = 2 ** 12;\nuint256 constant AU = 2 ** 13;\nuint256 constant AT = 2 ** 14;\nuint256 constant AZ = 2 ** 15;\nuint256 constant BS = 2 ** 16;\nuint256 constant BH = 2 ** 17;\nuint256 constant BD = 2 ** 18;\nuint256 constant BB = 2 ** 19;\nuint256 constant BY = 2 ** 20;\nuint256 constant BE = 2 ** 21;\nuint256 constant BZ = 2 ** 22;\nuint256 constant BJ = 2 ** 23;\nuint256 constant BM = 2 ** 24;\nuint256 constant BT = 2 ** 25;\nuint256 constant BO = 2 ** 26;\nuint256 constant BQ = 2 ** 27;\nuint256 constant BA = 2 ** 28;\nuint256 constant BW = 2 ** 29;\nuint256 constant BV = 2 ** 30;\nuint256 constant BR = 2 ** 31;\nuint256 constant IO = 2 ** 32;\nuint256 constant BN = 2 ** 33;\nuint256 constant BG = 2 ** 34;\nuint256 constant BF = 2 ** 35;\nuint256 constant BI = 2 ** 36;\nuint256 constant CV = 2 ** 37;\nuint256 constant KH = 2 ** 38;\nuint256 constant CM = 2 ** 39;\nuint256 constant CA = 2 ** 40;\nuint256 constant KY = 2 ** 41;\nuint256 constant CF = 2 ** 42;\nuint256 constant TD = 2 ** 43;\nuint256 constant CL = 2 ** 44;\nuint256 constant CN = 2 ** 45;\nuint256 constant CX = 2 ** 46;\nuint256 constant CC = 2 ** 47;\nuint256 constant CO = 2 ** 48;\nuint256 constant KM = 2 ** 49;\nuint256 constant CD = 2 ** 50;\nuint256 constant CG = 2 ** 51;\nuint256 constant CK = 2 ** 52;\nuint256 constant CR = 2 ** 53;\nuint256 constant CI = 2 ** 54;\nuint256 constant HR = 2 ** 55;\nuint256 constant CU = 2 ** 56;\nuint256 constant CW = 2 ** 57;\nuint256 constant CY = 2 ** 58;\nuint256 constant CZ = 2 ** 59;\nuint256 constant DK = 2 ** 60;\nuint256 constant DJ = 2 ** 61;\nuint256 constant DM = 2 ** 62;\nuint256 constant DO = 2 ** 63;\nuint256 constant EC = 2 ** 64;\nuint256 constant EG = 2 ** 65;\nuint256 constant SV = 2 ** 66;\nuint256 constant GQ = 2 ** 67;\nuint256 constant ER = 2 ** 68;\nuint256 constant EE = 2 ** 69;\nuint256 constant SZ = 2 ** 70;\nuint256 constant ET = 2 ** 71;\nuint256 constant FK = 2 ** 72;\nuint256 constant FO = 2 ** 73;\nuint256 constant FJ = 2 ** 74;\nuint256 constant FI = 2 ** 75;\nuint256 constant FR = 2 ** 76;\nuint256 constant GF = 2 ** 77;\nuint256 constant PF = 2 ** 78;\nuint256 constant TF = 2 ** 79;\nuint256 constant GA = 2 ** 80;\nuint256 constant GM = 2 ** 81;\nuint256 constant GE = 2 ** 82;\nuint256 constant DE = 2 ** 83;\nuint256 constant GH = 2 ** 84;\nuint256 constant GI = 2 ** 85;\nuint256 constant GR = 2 ** 86;\nuint256 constant GL = 2 ** 87;\nuint256 constant GD = 2 ** 88;\nuint256 constant GP = 2 ** 89;\nuint256 constant GU = 2 ** 90;\nuint256 constant GT = 2 ** 91;\nuint256 constant GG = 2 ** 92;\nuint256 constant GN = 2 ** 93;\nuint256 constant GW = 2 ** 94;\nuint256 constant GY = 2 ** 95;\nuint256 constant HT = 2 ** 96;\nuint256 constant HM = 2 ** 97;\nuint256 constant VA = 2 ** 98;\nuint256 constant HN = 2 ** 99;\nuint256 constant HK = 2 ** 100;\nuint256 constant HU = 2 ** 101;\nuint256 constant IS = 2 ** 102;\nuint256 constant IN = 2 ** 103;\nuint256 constant ID = 2 ** 104;\nuint256 constant IR = 2 ** 105;\nuint256 constant IQ = 2 ** 106;\nuint256 constant IE = 2 ** 107;\nuint256 constant IM = 2 ** 108;\nuint256 constant IL = 2 ** 109;\nuint256 constant IT = 2 ** 110;\nuint256 constant JM = 2 ** 111;\nuint256 constant JP = 2 ** 112;\nuint256 constant JE = 2 ** 113;\nuint256 constant JO = 2 ** 114;\nuint256 constant KZ = 2 ** 115;\nuint256 constant KE = 2 ** 116;\nuint256 constant KI = 2 ** 117;\nuint256 constant KP = 2 ** 118;\nuint256 constant KR = 2 ** 119;\nuint256 constant KW = 2 ** 120;\nuint256 constant KG = 2 ** 121;\nuint256 constant LA = 2 ** 122;\nuint256 constant LV = 2 ** 123;\nuint256 constant LB = 2 ** 124;\nuint256 constant LS = 2 ** 125;\nuint256 constant LR = 2 ** 126;\nuint256 constant LY = 2 ** 127;\nuint256 constant LI = 2 ** 128;\nuint256 constant LT = 2 ** 129;\nuint256 constant LU = 2 ** 130;\nuint256 constant MO = 2 ** 131;\nuint256 constant MK = 2 ** 132;\nuint256 constant MG = 2 ** 133;\nuint256 constant MW = 2 ** 134;\nuint256 constant MY = 2 ** 135;\nuint256 constant MV = 2 ** 136;\nuint256 constant ML = 2 ** 137;\nuint256 constant MT = 2 ** 138;\nuint256 constant MH = 2 ** 139;\nuint256 constant MQ = 2 ** 140;\nuint256 constant MR = 2 ** 141;\nuint256 constant MU = 2 ** 142;\nuint256 constant YT = 2 ** 143;\nuint256 constant MX = 2 ** 144;\nuint256 constant FM = 2 ** 145;\nuint256 constant MD = 2 ** 146;\nuint256 constant MC = 2 ** 147;\nuint256 constant MN = 2 ** 148;\nuint256 constant ME = 2 ** 149;\nuint256 constant MS = 2 ** 150;\nuint256 constant MA = 2 ** 151;\nuint256 constant MZ = 2 ** 152;\nuint256 constant MM = 2 ** 153;\nuint256 constant NA = 2 ** 154;\nuint256 constant NR = 2 ** 155;\nuint256 constant NP = 2 ** 156;\nuint256 constant NL = 2 ** 157;\nuint256 constant NC = 2 ** 158;\nuint256 constant NZ = 2 ** 159;\nuint256 constant NI = 2 ** 160;\nuint256 constant NE = 2 ** 161;\nuint256 constant NG = 2 ** 162;\nuint256 constant NU = 2 ** 163;\nuint256 constant NF = 2 ** 164;\nuint256 constant MP = 2 ** 165;\nuint256 constant NO = 2 ** 166;\nuint256 constant OM = 2 ** 167;\nuint256 constant PK = 2 ** 168;\nuint256 constant PW = 2 ** 169;\nuint256 constant PS = 2 ** 170;\nuint256 constant PA = 2 ** 171;\nuint256 constant PG = 2 ** 172;\nuint256 constant PY = 2 ** 173;\nuint256 constant PE = 2 ** 174;\nuint256 constant PH = 2 ** 175;\nuint256 constant PN = 2 ** 176;\nuint256 constant PL = 2 ** 177;\nuint256 constant PT = 2 ** 178;\nuint256 constant PR = 2 ** 179;\nuint256 constant QA = 2 ** 180;\nuint256 constant RE = 2 ** 181;\nuint256 constant RO = 2 ** 182;\nuint256 constant RU = 2 ** 183;\nuint256 constant RW = 2 ** 184;\nuint256 constant BL = 2 ** 185;\nuint256 constant SH = 2 ** 186;\nuint256 constant KN = 2 ** 187;\nuint256 constant LC = 2 ** 188;\nuint256 constant MF = 2 ** 189;\nuint256 constant PM = 2 ** 190;\nuint256 constant VC = 2 ** 191;\nuint256 constant WS = 2 ** 192;\nuint256 constant SM = 2 ** 193;\nuint256 constant ST = 2 ** 194;\nuint256 constant SA = 2 ** 195;\nuint256 constant SN = 2 ** 196;\nuint256 constant RS = 2 ** 197;\nuint256 constant SC = 2 ** 198;\nuint256 constant SL = 2 ** 199;\nuint256 constant SG = 2 ** 200;\nuint256 constant SX = 2 ** 201;\nuint256 constant SK = 2 ** 202;\nuint256 constant SI = 2 ** 203;\nuint256 constant SB = 2 ** 204;\nuint256 constant SO = 2 ** 205;\nuint256 constant ZA = 2 ** 206;\nuint256 constant GS = 2 ** 207;\nuint256 constant SS = 2 ** 208;\nuint256 constant ES = 2 ** 209;\nuint256 constant LK = 2 ** 210;\nuint256 constant SD = 2 ** 211;\nuint256 constant SR = 2 ** 212;\nuint256 constant SJ = 2 ** 213;\nuint256 constant SE = 2 ** 214;\nuint256 constant CH = 2 ** 215;\nuint256 constant SY = 2 ** 216;\nuint256 constant TW = 2 ** 217;\nuint256 constant TJ = 2 ** 218;\nuint256 constant TZ = 2 ** 219;\nuint256 constant TH = 2 ** 220;\nuint256 constant TL = 2 ** 221;\nuint256 constant TG = 2 ** 222;\nuint256 constant TK = 2 ** 223;\nuint256 constant TO = 2 ** 224;\nuint256 constant TT = 2 ** 225;\nuint256 constant TN = 2 ** 226;\nuint256 constant TR = 2 ** 227;\nuint256 constant TM = 2 ** 228;\nuint256 constant TC = 2 ** 229;\nuint256 constant TV = 2 ** 230;\nuint256 constant UG = 2 ** 231;\nuint256 constant UA = 2 ** 232;\nuint256 constant AE = 2 ** 233;\nuint256 constant GB = 2 ** 234;\nuint256 constant UM = 2 ** 235;\nuint256 constant US = 2 ** 236;\nuint256 constant UY = 2 ** 237;\nuint256 constant UZ = 2 ** 238;\nuint256 constant VU = 2 ** 239;\nuint256 constant VE = 2 ** 240;\nuint256 constant VN = 2 ** 241;\nuint256 constant VG = 2 ** 242;\nuint256 constant VI = 2 ** 243;\nuint256 constant WF = 2 ** 244;\nuint256 constant EH = 2 ** 245;\nuint256 constant YE = 2 ** 246;\nuint256 constant ZM = 2 ** 247;\nuint256 constant ZW = 2 ** 248;\n//values 249-255 reserved for future additions\n"
    },
    "src/interfaces/operations/ICheckModule.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {IInvestorRegistry} from \"src/interfaces/IInvestorRegistry.sol\";\nimport {IFundRegistry} from \"src/interfaces/IFundRegistry.sol\";\nimport {IDealerRegistry} from \"src/interfaces/IDealerRegistry.sol\";\nimport {IInstrumentRegistry} from \"src/interfaces/IInstrumentRegistry.sol\";\nimport {IEternalRegistryStorage} from \"src/interfaces/IEternalRegistryStorage.sol\";\nimport {IRoleRegistry} from \"src/interfaces/IRoleRegistry.sol\";\n\nimport {IOperationModule, OPERATIONS} from \"src/interfaces/operations/IOperationModule.sol\";\n\n/**\n * @title ICheckModule\n * @author Libre\n * @notice Interface for modules that perform validation checks on operations for instruments.\n * @dev This interface extends the IOperationModule interface and adds functionality for checking dependencies,\n *      querying tracked data, and performing operation-specific checks.\n */\ninterface ICheckModule is IOperationModule {\n    /**\n     * @notice Checks if the dependencies of the module are respected\n     * @param _id The id of the instrument the module is enabled for\n     * @return true if the dependencies are respected, false otherwise\n     */\n    function getDependenciesRespected(bytes32 _id) external view returns (bool);\n\n    /**\n     * @notice Function to be delegatecalled by the registry to query the tracked data\n     * @param _data Arbitrary data that can be used by the module to get the tracked data\n     * @return Tracked data needed to perform the check\n     */\n    function getTrackedData(bytes memory _data) external view returns (bytes memory);\n\n    /**\n     * @notice Function to be delegatecalled by the registry to perform the check\n     * @param _operation The operation to be checked\n     * @param _id The id of the operation\n     * @param _data Arbitrary data that can be used by the module to perform the check\n     * @return result memory Result of the check\n     */\n    function check(OPERATIONS _operation, bytes32 _id, bytes calldata _data) external returns (bytes memory result);\n}\n"
    },
    "src/utils/LibreUUPSUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {ERC1967UtilsUpgradeable} from\n    \"openzeppelin-contracts-upgradeable/contracts/proxy/ERC1967/ERC1967UtilsUpgradeable.sol\";\nimport {UUPSUpgradeable} from \"openzeppelin-contracts-upgradeable/contracts/proxy/utils/UUPSUpgradeable.sol\";\n\nimport {PermissionedContract} from \"src/PermissionedContract.sol\";\n\n/**\n * @title LibreUUPSUpgradeable\n * @author Libre\n * @notice An extension of UUPSUpgradeable with role-based access control for upgrades.\n * @dev Integrates UUPSUpgradeable and PermissionedContract to provide secured upgrade functionalities.\n */\ncontract LibreUUPSUpgradeable is UUPSUpgradeable, PermissionedContract {\n    /// @dev Error thrown when a restricted function is called directly.\n    error LibreUUPSUpgradeable_WrongUpgradeToFunction();\n\n    /**\n     * @notice Retrieve the address of the current implementation.\n     * @return The address of the current implementation.\n     */\n    function getImplementation() external view returns (address) {\n        return ERC1967UtilsUpgradeable.getImplementation();\n    }\n\n    /**\n     * @notice Upgrade the contract to a new implementation with a specific role and optionally execute a call.\n     * @param _newImplementation The address of the new implementation contract.\n     * @param _role The role required to perform the upgrade.\n     * @param _data The data for the function call to execute after the upgrade.\n     */\n    function upgradeToWithRoleAndCall(address _newImplementation, bytes32 _role, bytes memory _data)\n        public\n        payable\n        virtual\n        onlyProxy\n    {\n        _checkRoleHasAccess(_role);\n        ERC1967UtilsUpgradeable.upgradeToAndCallUUPS(_newImplementation, _data, true);\n    }\n\n    /**\n     * @notice Override to prevent direct usage of the `upgradeToAndCall` function.\n     * @dev Always reverts with a custom error.\n     */\n    function upgradeToAndCall(address, bytes memory) public payable virtual override onlyProxy {\n        revert LibreUUPSUpgradeable_WrongUpgradeToFunction();\n    }\n\n    /**\n     * @notice Upgrade the contract to a new implementation with a specific role.\n     * @param _newImplementation The address of the new implementation contract.\n     * @param _role The role required to perform the upgrade.\n     */\n    function upgradeToWithRole(address _newImplementation, bytes32 _role) public virtual onlyProxy {\n        _checkRoleHasAccess(_role);\n        ERC1967UtilsUpgradeable.upgradeToAndCallUUPS(_newImplementation, new bytes(0), false);\n    }\n\n    /**\n     * @notice Override to prevent direct usage of the `upgradeTo` function.\n     * @dev Always reverts with a custom error.\n     */\n    function upgradeTo(address) public virtual override onlyProxy {\n        revert LibreUUPSUpgradeable_WrongUpgradeToFunction();\n    }\n\n    /**\n     * @notice Internal function to authorize an upgrade.\n     * @dev Can be overridden by derived contracts to implement custom logic.\n     * @notice param _newImplementation The address of the new implementation contract (not used).\n     */\n    function _authorizeUpgrade(address) internal view virtual override {}\n}\n"
    },
    "src/registries/EternalRegistryStorage.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.28;\n\nimport {IEternalRegistryStorage} from \"src/interfaces/IEternalRegistryStorage.sol\";\n\nimport \"src/utils/Constant.sol\";\n\n/**\n * @title EternalRegistryStorage\n * @author Libre\n * @notice A flexible storage system for managing different types of data (booleans, numbers, addresses, strings, and arrays).\n *\n * Features:\n * - Store and retrieve various data types using IDs and keys.\n * - Batch operations to handle multiple updates at once.\n * - Protect certain keys from being changed in the future.\n * - Keep logs of changes through events.\n *\n * How to use:\n * - Use `get` methods to retrieve stored data.\n * - Use `set` methods to save or update data.\n * - Use `_setReservedKey` to lock a key so it can't be changed.\n */\nabstract contract EternalRegistryStorage is IEternalRegistryStorage {\n    struct EternalStorage {\n        // Mapping of entry ID (`id`) to a mapping of key (`key`) to a boolean value.\n        mapping(bytes32 id => mapping(bytes32 key => bool value)) booleans;\n        // Mapping of entry ID (`id`) to a mapping of key (`key`) to a uint256 value.\n        mapping(bytes32 id => mapping(bytes32 key => uint256 value)) uints;\n        // Mapping of entry ID (`id`) to a mapping of key (`key`) to an address value.\n        mapping(bytes32 id => mapping(bytes32 key => address value)) addresses;\n        // Mapping of entry ID (`id`) to a mapping of key (`key`) to a string value.\n        mapping(bytes32 id => mapping(bytes32 key => string value)) strings;\n        // Mapping of entry ID (`id`) to a mapping of key (`key`) to a bytes32 value.\n        mapping(bytes32 id => mapping(bytes32 key => bytes32 value)) bytesStorage;\n        // Mapping of entry ID (`id`) to a mapping of restricted key (`key`) to a boolean indicating restriction status.\n        // set of key identifiers that cannot be edited per each entry\n        mapping(bytes32 id => mapping(bytes32 key => bool isRestricted)) internalKeys;\n    }\n\n    function getBool(bytes32 _id, bytes32 _key) public view returns (bool) {\n        EternalStorage storage es = _getEternalStorage();\n        return es.booleans[_id][_key];\n    }\n\n    function getUint(bytes32 _id, bytes32 _key) public view returns (uint256) {\n        EternalStorage storage es = _getEternalStorage();\n        return es.uints[_id][_key];\n    }\n\n    function getAddress(bytes32 _id, bytes32 _key) public view returns (address) {\n        EternalStorage storage es = _getEternalStorage();\n        return es.addresses[_id][_key];\n    }\n\n    function getString(bytes32 _id, bytes32 _key) public view returns (string memory) {\n        EternalStorage storage es = _getEternalStorage();\n        return es.strings[_id][_key];\n    }\n\n    function getBatch(\n        bytes32[] memory _ids,\n        bytes32[] memory _keys,\n        uint256 _boolCount,\n        uint256 _uintCount,\n        uint256 _addressCount,\n        uint256 _stringCount,\n        uint256 _bytesCount\n    )\n        public\n        view\n        returns (\n            bool[] memory _boolValues,\n            uint256[] memory _uintValues,\n            address[] memory _addressValues,\n            string[] memory _stringValues,\n            bytes32[] memory _bytesValues\n        )\n    {\n        {\n            if (\n                _ids.length != _keys.length\n                    || _ids.length != _boolCount + _uintCount + _addressCount + _stringCount + _bytesCount\n            ) {\n                revert IEternalRegistryStorage_BatchLengthMismatch();\n            }\n        }\n        _boolValues = new bool[](_boolCount);\n        _uintValues = new uint256[](_uintCount);\n        _addressValues = new address[](_addressCount);\n        _stringValues = new string[](_stringCount);\n        _bytesValues = new bytes32[](_bytesCount);\n\n        uint256 batchElement;\n        for (uint256 i; i < _boolCount; ++i) {\n            _boolValues[i] = getBool(_ids[batchElement], _keys[batchElement]);\n            ++batchElement;\n        }\n        for (uint256 i; i < _uintCount; ++i) {\n            _uintValues[i] = getUint(_ids[batchElement], _keys[batchElement]);\n            ++batchElement;\n        }\n        for (uint256 i; i < _addressCount; ++i) {\n            _addressValues[i] = getAddress(_ids[batchElement], _keys[batchElement]);\n            ++batchElement;\n        }\n        for (uint256 i; i < _stringCount; ++i) {\n            _stringValues[i] = getString(_ids[batchElement], _keys[batchElement]);\n            ++batchElement;\n        }\n        for (uint256 i; i < _bytesCount; ++i) {\n            _bytesValues[i] = getBytes(_ids[batchElement], _keys[batchElement]);\n            ++batchElement;\n        }\n        return (_boolValues, _uintValues, _addressValues, _stringValues, _bytesValues);\n    }\n\n    function getBytes(bytes32 _id, bytes32 _key) public view returns (bytes32) {\n        EternalStorage storage es = _getEternalStorage();\n        return es.bytesStorage[_id][_key];\n    }\n\n    /**\n     * @notice Prevent future modifications of a specific key in a given entry\n     * @param _id Id of the entry where the key is restricted\n     * @param _key Key to restrict\n     * @dev use `onlyConfigurableKey` modifier to ensure\n     * only non restricted keys are modified\n     */\n    function _setReservedKey(bytes32 _id, bytes32 _key) internal {\n        EternalStorage storage es = _getEternalStorage();\n        es.internalKeys[_id][_key] = true;\n        emit KeyRestricted(_id, _key);\n    }\n\n    function _setBool(bytes32 _id, bytes32 _key, bool _value) internal {\n        EternalStorage storage es = _getEternalStorage();\n        es.booleans[_id][_key] = _value;\n        emit AddedBool(_id, _key, _value);\n    }\n\n    function _setUint(bytes32 _id, bytes32 _key, uint256 _value) internal {\n        EternalStorage storage es = _getEternalStorage();\n        es.uints[_id][_key] = _value;\n        emit AddedUint(_id, _key, _value);\n    }\n\n    function _setAddress(bytes32 _id, bytes32 _key, address _value) internal {\n        EternalStorage storage es = _getEternalStorage();\n        es.addresses[_id][_key] = _value;\n        emit AddedAddress(_id, _key, _value);\n    }\n\n    function _setString(bytes32 _id, bytes32 _key, string calldata _value) internal {\n        EternalStorage storage es = _getEternalStorage();\n        es.strings[_id][_key] = _value;\n        emit AddedString(_id, _key, _value);\n    }\n\n    function _setBytes(bytes32 _id, bytes32 _key, bytes32 _value) internal {\n        EternalStorage storage es = _getEternalStorage();\n        es.bytesStorage[_id][_key] = _value;\n        emit AddedBytes(_id, _key, _value);\n    }\n\n    function _setBatch(\n        bytes32[] memory _ids,\n        bytes32[] memory _keys,\n        bool[] memory _boolValues,\n        uint256[] memory _uintValues,\n        address[] memory _addressValues,\n        string[] memory _stringValues,\n        bytes32[] memory _bytesValues\n    ) internal {\n        if (\n            _ids.length != _keys.length\n                || _ids.length\n                    != _boolValues.length + _uintValues.length + _addressValues.length + _stringValues.length\n                        + _bytesValues.length\n        ) {\n            revert IEternalRegistryStorage_BatchLengthMismatch();\n        }\n        uint256 batchElement;\n        for (uint256 i; i < _boolValues.length; ++i) {\n            _setBool(_ids[batchElement], _keys[batchElement], _boolValues[i]);\n            ++batchElement;\n        }\n        for (uint256 i; i < _uintValues.length; ++i) {\n            _setUint(_ids[batchElement], _keys[batchElement], _uintValues[i]);\n            ++batchElement;\n        }\n        for (uint256 i; i < _addressValues.length; ++i) {\n            _setAddress(_ids[batchElement], _keys[batchElement], _addressValues[i]);\n            ++batchElement;\n        }\n        for (uint256 i; i < _stringValues.length; ++i) {\n            EternalStorage storage es = _getEternalStorage();\n            // no conversion from memory to calldata\n            es.strings[_ids[batchElement]][_keys[batchElement]] = _stringValues[i];\n            emit AddedString(_ids[batchElement], _keys[batchElement], _stringValues[i]);\n            ++batchElement;\n        }\n        for (uint256 i; i < _bytesValues.length; ++i) {\n            _setBytes(_ids[batchElement], _keys[batchElement], _bytesValues[i]);\n            ++batchElement;\n        }\n    }\n\n    function _getEternalStorage() internal view returns (EternalStorage storage) {\n        EternalStorage storage es;\n        bytes32 slot = ETERNAL_STORAGE_SLOT;\n        assembly {\n            es.slot := slot\n        }\n        return es;\n    }\n\n    function _onlyConfigurableKey(bytes32 _id, bytes32 _key) internal view {\n        EternalStorage storage es = _getEternalStorage();\n        if (es.internalKeys[_id][_key]) {\n            revert IEternalRegistryStorage_AttemptToSetARestrictedKey();\n        }\n    }\n\n    function _onlyConfigurableKeys(bytes32[] memory _ids, bytes32[] memory _keys) internal view {\n        for (uint256 i; i < _keys.length; ++i) {\n            _onlyConfigurableKey(_ids[i], _keys[i]);\n        }\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.19;\n\nimport \"../Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n\n    /**\n     * @dev The signature derives the `address(0)`.\n     */\n    error ECDSAInvalidSignature();\n\n    /**\n     * @dev The signature has an invalid length.\n     */\n    error ECDSAInvalidSignatureLength(uint256 length);\n\n    /**\n     * @dev The signature has an S value that is in the upper half order.\n     */\n    error ECDSAInvalidSignatureS(bytes32 s);\n\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\n        unchecked {\n            bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            // We do not check for an overflow here since the shift operation results in 0 or 1.\n            uint8 v = uint8((uint256(vs) >> 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError, bytes32) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n  2 + 1, and for v in (302): v  {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\")\n            mstore(0x1c, hash)\n            message := keccak256(0x00, 0x3c)\n        }\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, hex\"19_01\")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            data := keccak256(ptr, 0x42)\n        }\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Data with intended validator, created from a\n     * `validator` and `data` according to the version 0 of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(hex\"19_00\", validator, data));\n    }\n}\n"
    },
    "lib/risc0-ethereum/contracts/src/steel/Steel.sol": {
      "content": "// Copyright 2024 RISC Zero, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n\npragma solidity ^0.8.9;\n\n/// @title Steel Library\n/// @notice This library provides a collection of utilities to work with Steel commitments in Solidity.\nlibrary Steel {\n    /// @notice Represents a commitment to a specific block in the blockchain.\n    /// @dev The `id` combines the version and the actual identifier of the claim, such as the block number.\n    /// @dev The `digest` represents the data being committed to, e.g. the hash of the execution block.\n    /// @dev The `configID` is the cryptographic digest of the network configuration.\n    struct Commitment {\n        uint256 id;\n        bytes32 digest;\n        bytes32 configID;\n    }\n\n    /// @notice The version of the Commitment is incorrect.\n    error InvalidCommitmentVersion();\n\n    /// @notice The Commitment is too old and can no longer be validated.\n    error CommitmentTooOld();\n\n    /// @notice Validates if the provided Commitment matches the block hash of the given block number.\n    /// @param commitment The Commitment struct to validate.\n    /// @return True if the commitment's block hash matches the block hash of the block number, false otherwise.\n    function validateCommitment(Commitment memory commitment) internal view returns (bool) {\n        (uint240 claimID, uint16 version) = Encoding.decodeVersionedID(commitment.id);\n        if (version == 0) {\n            return validateBlockCommitment(claimID, commitment.digest);\n        } else if (version == 1) {\n            return validateBeaconCommitment(claimID, commitment.digest);\n        } else {\n            revert InvalidCommitmentVersion();\n        }\n    }\n\n    /// @notice Validates if the provided block commitment matches the block hash of the given block number.\n    /// @param blockNumber The block number to compare against.\n    /// @param blockHash The block hash to validate.\n    /// @return True if the block's block hash matches the block hash, false otherwise.\n    function validateBlockCommitment(uint256 blockNumber, bytes32 blockHash) internal view returns (bool) {\n        if (block.number - blockNumber > 256) {\n            revert CommitmentTooOld();\n        }\n        return blockHash == blockhash(blockNumber);\n    }\n\n    /// @notice Validates if the provided beacon commitment matches the block root of the given timestamp.\n    /// @param timestamp The timestamp to compare against.\n    /// @param blockRoot The block root to validate.\n    /// @return True if the block's block root matches the block root, false otherwise.\n    function validateBeaconCommitment(uint256 timestamp, bytes32 blockRoot) internal view returns (bool) {\n        if (block.timestamp - timestamp > 12 * 8191) {\n            revert CommitmentTooOld();\n        }\n        return blockRoot == Beacon.parentBlockRoot(timestamp);\n    }\n}\n\n/// @title Beacon Library\nlibrary Beacon {\n    /// @notice The address of the Beacon roots contract.\n    /// @dev https://eips.ethereum.org/EIPS/eip-4788\n    address internal constant BEACON_ROOTS_ADDRESS = 0x000F3df6D732807Ef1319fB7B8bB8522d0Beac02;\n\n    /// @notice Find the root of the Beacon block corresponding to the parent of the execution block with the given timestamp.\n    /// @return root Returns the corresponding Beacon block root or null, if no such block exists.\n    function parentBlockRoot(uint256 timestamp) internal view returns (bytes32 root) {\n        (bool success, bytes memory result) = BEACON_ROOTS_ADDRESS.staticcall(abi.encode(timestamp));\n        if (success) {\n            return abi.decode(result, (bytes32));\n        }\n    }\n}\n\n/// @title Encoding Library\nlibrary Encoding {\n    /// @notice Encodes a version and ID into a single uint256 value.\n    /// @param id The base ID to be encoded, limited by 240 bits (or the maximum value of a uint240).\n    /// @param version The version number to be encoded, limited by 16 bits (or the maximum value of a uint16).\n    /// @return Returns a single uint256 value that contains both the `id` and the `version` encoded into it.\n    function encodeVersionedID(uint240 id, uint16 version) internal pure returns (uint256) {\n        uint256 encoded;\n        assembly {\n            encoded := or(shl(240, version), id)\n        }\n        return encoded;\n    }\n\n    /// @notice Decodes a version and ID from a single uint256 value.\n    /// @param id The single uint256 value to be decoded.\n    /// @return Returns two values: a uint240 for the original base ID and a uint16 for the version number encoded into it.\n    function decodeVersionedID(uint256 id) internal pure returns (uint240, uint16) {\n        uint240 decoded;\n        uint16 version;\n        assembly {\n            decoded := and(id, 0x0000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n            version := shr(240, id)\n        }\n        return (decoded, version);\n    }\n}\n"
    },
    "src/interfaces/IAccessVerifier.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {CredentialProofData, OrderProofData} from \"src/utils/Types.sol\";\n\n/**\n * @title IAccessVerifier\n * @notice Interface for verifying access credentials and subscription orders using off-chain generated proofs.\n * This interface utilizes cryptographic proofs (e.g., Steel proofs) to ensure secure verification of investor credentials\n * and subscription orders in compliance with the defined rules and regulations.\n *\n * @dev The Steel proofs must be generated off-chain using RISC0-zkVM and then submitted on-chain for verification.\n * These proofs ensure privacy and correctness while validating investor actions and subscriptions.\n */\ninterface IAccessVerifier {\n    /// @notice Verifies the Credential for an investor, if the Steel proof verifies that they are allowed to interact with an instrument\n    /// @dev The Steel proof must be generated off-chain using RISC0-zkVM and submitted here.\n    function verifyCredential(CredentialProofData calldata _proof) external;\n\n    /// @notice Verifies a subscription order for an investor, if the Steel proof verifies that their subscription to an instrument is valid\n    /// @dev The Steel proof must be generated off-chain using RISC0-zkVM and submitted here.\n    function verifySubscription(OrderProofData calldata _proof) external view;\n\n    /// @notice Returns the image ID used for credential verification.\n    function credentialImageID() external view returns (bytes32);\n\n    /// @notice Returns the image ID used for subscription verification.\n    function subscriptionImageID() external view returns (bytes32);\n}\n"
    },
    "lib/eas-contracts/contracts/resolver/SchemaResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\n\nimport { AccessDenied, InvalidEAS, InvalidLength, uncheckedInc } from \"./../Common.sol\";\nimport { IEAS, Attestation } from \"./../IEAS.sol\";\nimport { Semver } from \"./../Semver.sol\";\nimport { ISchemaResolver } from \"./ISchemaResolver.sol\";\n\n/// @title SchemaResolver\n/// @notice The base schema resolver contract.\nabstract contract SchemaResolver is ISchemaResolver, Semver {\n    error InsufficientValue();\n    error NotPayable();\n\n    // The global EAS contract.\n    IEAS internal immutable _eas;\n\n    /// @dev Creates a new resolver.\n    /// @param eas The address of the global EAS contract.\n    constructor(IEAS eas) Semver(1, 3, 0) {\n        if (address(eas) == address(0)) {\n            revert InvalidEAS();\n        }\n\n        _eas = eas;\n    }\n\n    /// @dev Ensures that only the EAS contract can make this call.\n    modifier onlyEAS() {\n        _onlyEAS();\n\n        _;\n    }\n\n    /// @inheritdoc ISchemaResolver\n    function isPayable() public pure virtual returns (bool) {\n        return false;\n    }\n\n    /// @dev ETH callback.\n    receive() external payable virtual {\n        if (!isPayable()) {\n            revert NotPayable();\n        }\n    }\n\n    /// @inheritdoc ISchemaResolver\n    function attest(Attestation calldata attestation) external payable onlyEAS returns (bool) {\n        return onAttest(attestation, msg.value);\n    }\n\n    /// @inheritdoc ISchemaResolver\n    function multiAttest(\n        Attestation[] calldata attestations,\n        uint256[] calldata values\n    ) external payable onlyEAS returns (bool) {\n        uint256 length = attestations.length;\n        if (length != values.length) {\n            revert InvalidLength();\n        }\n\n        // We are keeping track of the remaining ETH amount that can be sent to resolvers and will keep deducting\n        // from it to verify that there isn't any attempt to send too much ETH to resolvers. Please note that unless\n        // some ETH was stuck in the contract by accident (which shouldn't happen in normal conditions), it won't be\n        // possible to send too much ETH anyway.\n        uint256 remainingValue = msg.value;\n\n        for (uint256 i = 0; i < length; i = uncheckedInc(i)) {\n            // Ensure that the attester/revoker doesn't try to spend more than available.\n            uint256 value = values[i];\n            if (value > remainingValue) {\n                revert InsufficientValue();\n            }\n\n            // Forward the attestation to the underlying resolver and return false in case it isn't approved.\n            if (!onAttest(attestations[i], value)) {\n                return false;\n            }\n\n            unchecked {\n                // Subtract the ETH amount, that was provided to this attestation, from the global remaining ETH amount.\n                remainingValue -= value;\n            }\n        }\n\n        return true;\n    }\n\n    /// @inheritdoc ISchemaResolver\n    function revoke(Attestation calldata attestation) external payable onlyEAS returns (bool) {\n        return onRevoke(attestation, msg.value);\n    }\n\n    /// @inheritdoc ISchemaResolver\n    function multiRevoke(\n        Attestation[] calldata attestations,\n        uint256[] calldata values\n    ) external payable onlyEAS returns (bool) {\n        uint256 length = attestations.length;\n        if (length != values.length) {\n            revert InvalidLength();\n        }\n\n        // We are keeping track of the remaining ETH amount that can be sent to resolvers and will keep deducting\n        // from it to verify that there isn't any attempt to send too much ETH to resolvers. Please note that unless\n        // some ETH was stuck in the contract by accident (which shouldn't happen in normal conditions), it won't be\n        // possible to send too much ETH anyway.\n        uint256 remainingValue = msg.value;\n\n        for (uint256 i = 0; i < length; i = uncheckedInc(i)) {\n            // Ensure that the attester/revoker doesn't try to spend more than available.\n            uint256 value = values[i];\n            if (value > remainingValue) {\n                revert InsufficientValue();\n            }\n\n            // Forward the revocation to the underlying resolver and return false in case it isn't approved.\n            if (!onRevoke(attestations[i], value)) {\n                return false;\n            }\n\n            unchecked {\n                // Subtract the ETH amount, that was provided to this attestation, from the global remaining ETH amount.\n                remainingValue -= value;\n            }\n        }\n\n        return true;\n    }\n\n    /// @notice A resolver callback that should be implemented by child contracts.\n    /// @param attestation The new attestation.\n    /// @param value An explicit ETH amount that was sent to the resolver. Please note that this value is verified in\n    ///     both attest() and multiAttest() callbacks EAS-only callbacks and that in case of multi attestations, it'll\n    ///     usually hold that msg.value != value, since msg.value aggregated the sent ETH amounts for all the\n    ///     attestations in the batch.\n    /// @return Whether the attestation is valid.\n    function onAttest(Attestation calldata attestation, uint256 value) internal virtual returns (bool);\n\n    /// @notice Processes an attestation revocation and verifies if it can be revoked.\n    /// @param attestation The existing attestation to be revoked.\n    /// @param value An explicit ETH amount that was sent to the resolver. Please note that this value is verified in\n    ///     both revoke() and multiRevoke() callbacks EAS-only callbacks and that in case of multi attestations, it'll\n    ///     usually hold that msg.value != value, since msg.value aggregated the sent ETH amounts for all the\n    ///     attestations in the batch.\n    /// @return Whether the attestation can be revoked.\n    function onRevoke(Attestation calldata attestation, uint256 value) internal virtual returns (bool);\n\n    /// @dev Ensures that only the EAS contract can make this call.\n    function _onlyEAS() private view {\n        if (msg.sender != address(_eas)) {\n            revert AccessDenied();\n        }\n    }\n}\n"
    },
    "lib/openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.19;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "lib/risc0-ethereum/contracts/src/Util.sol": {
      "content": "// Copyright 2024 RISC Zero, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n\npragma solidity ^0.8.9;\n\n/// @notice reverse the byte order of the uint256 value.\n/// @dev Solidity uses a big-endian ABI encoding. Reversing the byte order before encoding\n/// ensure that the encoded value will be little-endian.\n/// Written by k06a. https://ethereum.stackexchange.com/a/83627\nfunction reverseByteOrderUint256(uint256 input) pure returns (uint256 v) {\n    v = input;\n\n    // swap bytes\n    v = ((v & 0xFF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00) >> 8)\n        | ((v & 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) << 8);\n\n    // swap 2-byte long pairs\n    v = ((v & 0xFFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000) >> 16)\n        | ((v & 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) << 16);\n\n    // swap 4-byte long pairs\n    v = ((v & 0xFFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000) >> 32)\n        | ((v & 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) << 32);\n\n    // swap 8-byte long pairs\n    v = ((v & 0xFFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF0000000000000000) >> 64)\n        | ((v & 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) << 64);\n\n    // swap 16-byte long pairs\n    v = (v >> 128) | (v << 128);\n}\n\n/// @notice reverse the byte order of the uint32 value.\n/// @dev Solidity uses a big-endian ABI encoding. Reversing the byte order before encoding\n/// ensure that the encoded value will be little-endian.\n/// Written by k06a. https://ethereum.stackexchange.com/a/83627\nfunction reverseByteOrderUint32(uint32 input) pure returns (uint32 v) {\n    v = input;\n\n    // swap bytes\n    v = ((v & 0xFF00FF00) >> 8) | ((v & 0x00FF00FF) << 8);\n\n    // swap 2-byte long pairs\n    v = (v >> 16) | (v << 16);\n}\n\n/// @notice reverse the byte order of the uint16 value.\n/// @dev Solidity uses a big-endian ABI encoding. Reversing the byte order before encoding\n/// ensure that the encoded value will be little-endian.\n/// Written by k06a. https://ethereum.stackexchange.com/a/83627\nfunction reverseByteOrderUint16(uint16 input) pure returns (uint16 v) {\n    v = input;\n\n    // swap bytes\n    v = (v >> 8) | ((v & 0x00FF) << 8);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.19;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "lib/openzeppelin-contracts-upgradeable/contracts/proxy/ERC1967/ERC1967UtilsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/ERC1967/ERC1967Utils.sol)\n\npragma solidity ^0.8.20;\n\nimport \"../beacon/IBeaconUpgradeable.sol\";\nimport \"../../interfaces/IERC1967Upgradeable.sol\";\nimport \"../../interfaces/draft-IERC1822Upgradeable.sol\";\nimport \"../../utils/AddressUpgradeable.sol\";\nimport \"../../utils/StorageSlotUpgradeable.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n */\nlibrary ERC1967UtilsUpgradeable {\n    // We re-declare ERC-1967 events here because they can't be used directly from IERC1967.\n    // This will be fixed in Solidity 0.8.21. At that point we should remove these events.\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Emitted when the beacon is changed.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev The `implementation` of the proxy is invalid.\n     */\n    error ERC1967InvalidImplementation(address implementation);\n\n    /**\n     * @dev The `admin` of the proxy is invalid.\n     */\n    error ERC1967InvalidAdmin(address admin);\n\n    /**\n     * @dev The `beacon` of the proxy is invalid.\n     */\n    error ERC1967InvalidBeacon(address beacon);\n\n    /**\n     * @dev The storage `slot` is unsupported as a UUID.\n     */\n    error ERC1967UnsupportedProxiableUUID(bytes32 slot);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function getImplementation() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        if (newImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(newImplementation);\n        }\n        StorageSlotUpgradeable.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {IERC1967-Upgraded} event.\n     */\n    function upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {IERC1967-Upgraded} event.\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\n        upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {IERC1967-Upgraded} event.\n     */\n    function upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822ProxiableUpgradeable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                if (slot != IMPLEMENTATION_SLOT) {\n                    revert ERC1967UnsupportedProxiableUUID(slot);\n                }\n            } catch {\n                // The implementation is not UUPS\n                revert ERC1967InvalidImplementation(newImplementation);\n            }\n            upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function getAdmin() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        if (newAdmin == address(0)) {\n            revert ERC1967InvalidAdmin(address(0));\n        }\n        StorageSlotUpgradeable.getAddressSlot(ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {IERC1967-AdminChanged} event.\n     */\n    function changeAdmin(address newAdmin) internal {\n        emit AdminChanged(getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1) and is validated in the constructor.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function getBeacon() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        if (newBeacon.code.length == 0) {\n            revert ERC1967InvalidBeacon(newBeacon);\n        }\n\n        address beaconImplementation = IBeaconUpgradeable(newBeacon).implementation();\n        if (beaconImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(beaconImplementation);\n        }\n\n        StorageSlotUpgradeable.getAddressSlot(BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits an {IERC1967-BeaconUpgraded} event.\n     */\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\n        }\n    }\n}\n"
    },
    "lib/openzeppelin-contracts-upgradeable/contracts/proxy/utils/UUPSUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/UUPSUpgradeable.sol)\n\npragma solidity ^0.8.19;\n\nimport \"../../interfaces/draft-IERC1822Upgradeable.sol\";\nimport \"../ERC1967/ERC1967UtilsUpgradeable.sol\";\nimport \"./Initializable.sol\";\n\n/**\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\n *\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\n * `UUPSUpgradeable` with a custom implementation of upgrades.\n *\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\n *\n * _Available since v4.1._\n */\nabstract contract UUPSUpgradeable is Initializable, IERC1822ProxiableUpgradeable {\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\n    address private immutable __self = address(this);\n\n    /**\n     * @dev The call is from an unauthorized context.\n     */\n    error UUPSUnauthorizedCallContext();\n\n    /**\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\n     * fail.\n     */\n    modifier onlyProxy() {\n        if (address(this) == __self) {\n            // Must be called through delegatecall\n            revert UUPSUnauthorizedCallContext();\n        }\n        if (ERC1967UtilsUpgradeable.getImplementation() != __self) {\n            // Must be called through an active proxy\n            revert UUPSUnauthorizedCallContext();\n        }\n        _;\n    }\n\n    /**\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\n     * callable on the implementing contract but not through proxies.\n     */\n    modifier notDelegated() {\n        if (address(this) != __self) {\n            // Must not be called through delegatecall\n            revert UUPSUnauthorizedCallContext();\n        }\n        _;\n    }\n\n    /**\n     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\n     * implementation. It is used to validate the implementation's compatibility when performing an upgrade.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\n     */\n    function proxiableUUID() external view virtual notDelegated returns (bytes32) {\n        return ERC1967UtilsUpgradeable.IMPLEMENTATION_SLOT;\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\n     */\n    function upgradeTo(address newImplementation) public virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        ERC1967UtilsUpgradeable.upgradeToAndCallUUPS(newImplementation, new bytes(0), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\n     * encoded in `data`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        ERC1967UtilsUpgradeable.upgradeToAndCallUUPS(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\n     * {upgradeTo} and {upgradeToAndCall}.\n     *\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\n     *\n     * ```solidity\n     * function _authorizeUpgrade(address) internal  onlyOwner {}\n     * ```\n     */\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "src/PermissionedContract.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.28;\n\nimport {IRoleRegistry} from \"src/interfaces/IRoleRegistry.sol\";\n\n/**\n * @title PermissionedContract\n * @author Libre\n * @notice Base contract for managing access control via roles.\n * @dev Provides shared functionality for role-based access control across contracts.\n */\nabstract contract PermissionedContract {\n    /// @custom:storage-location erc7201:PermissionedContract.storage\n    struct PermissionedContractStorage {\n        IRoleRegistry roleRegistry;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"PermissionedContract.storage\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant PERMISSIONED_CONTRACT_STORAGE_SLOT =\n        0x5a84e274199d81bb7497e94f6b60cc9eba947b73ccf3412997ff6bcdecf19d00;\n\n    error PermissionedContract_AccessDenied();\n\n    function _roleRegistry() internal view returns (IRoleRegistry) {\n        PermissionedContractStorage storage s = _getPermissionedContractStorage();\n        return s.roleRegistry;\n    }\n\n    /**\n     * @notice Verify that the user can execute the operation\n     * using the role specified\n     * @param _role Role the caller wants to use\n     */\n    function _roleHasAccess(bytes32 _role) internal view returns (bool) {\n        return _roleRegistry().hasAccess(address(this), msg.sig, msg.sender, _role);\n    }\n\n    /**\n     * @notice Check that the user can execute the operation\n     * using the role specified\n     * @param _role Role the caller wants to use\n     */\n    function _checkRoleHasAccess(bytes32 _role) internal view {\n        if (!_roleHasAccess(_role)) {\n            revert PermissionedContract_AccessDenied();\n        }\n    }\n\n    /**\n     * @notice Retrieves the storage for the Permissioned Contract.\n     * @dev This function uses inline assembly to access the storage slot defined by `PERMISSIONED_CONTRACT_STORAGE_SLOT`.\n     *      It allows access to the `PermissionedContractStorage` structure, enabling the management of permissioned contract data.\n     * @return s The `PermissionedContractStorage` structure located at the specified storage slot.\n     */\n    function _getPermissionedContractStorage() internal pure returns (PermissionedContractStorage storage s) {\n        assembly {\n            s.slot := PERMISSIONED_CONTRACT_STORAGE_SLOT\n        }\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\n\npragma solidity ^0.8.19;\n\nimport \"./math/Math.sol\";\nimport \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev The `value` string doesn't fit in the specified `length`.\n     */\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toString(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value)));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "lib/eas-contracts/contracts/Semver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\n\nimport { Strings } from \"@openzeppelin/contracts/utils/Strings.sol\";\n\nimport { ISemver } from \"./ISemver.sol\";\n\n/// @title Semver\n/// @notice A simple contract for managing contract versions.\ncontract Semver is ISemver {\n    // Contract's major version number.\n    uint256 private immutable _major;\n\n    // Contract's minor version number.\n    uint256 private immutable _minor;\n\n    // Contract's patch version number.\n    uint256 private immutable _patch;\n\n    /// @dev Create a new Semver instance.\n    /// @param major Major version number.\n    /// @param minor Minor version number.\n    /// @param patch Patch version number.\n    constructor(uint256 major, uint256 minor, uint256 patch) {\n        _major = major;\n        _minor = minor;\n        _patch = patch;\n    }\n\n    /// @notice Returns the full semver contract version.\n    /// @return Semver contract version as a string.\n    function version() external view returns (string memory) {\n        return\n            string(\n                abi.encodePacked(Strings.toString(_major), \".\", Strings.toString(_minor), \".\", Strings.toString(_patch))\n            );\n    }\n}\n"
    },
    "lib/openzeppelin-contracts-upgradeable/contracts/proxy/beacon/IBeaconUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.19;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeaconUpgradeable {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "lib/openzeppelin-contracts-upgradeable/contracts/interfaces/IERC1967Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC1967.sol)\n\npragma solidity ^0.8.19;\n\n/**\n * @dev ERC-1967: Proxy Storage Slots. This interface contains the events defined in the ERC.\n *\n * _Available since v4.8.3._\n */\ninterface IERC1967Upgradeable {\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Emitted when the beacon is changed.\n     */\n    event BeaconUpgraded(address indexed beacon);\n}\n"
    },
    "lib/openzeppelin-contracts-upgradeable/contracts/interfaces/draft-IERC1822Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.19;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822ProxiableUpgradeable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "lib/openzeppelin-contracts-upgradeable/contracts/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.19;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, defaultRevert);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with a\n     * `customRevert` function as a fallback when `target` reverts.\n     *\n     * Requirements:\n     *\n     * - `customRevert` must be a reverting function.\n     *\n     * _Available since v5.0._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        function() internal view customRevert\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, customRevert);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, defaultRevert);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with a `customRevert` function as a fallback revert reason when `target` reverts.\n     *\n     * Requirements:\n     *\n     * - `customRevert` must be a reverting function.\n     *\n     * _Available since v5.0._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        function() internal view customRevert\n    ) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, customRevert);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, defaultRevert);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        function() internal view customRevert\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, customRevert);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, defaultRevert);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        function() internal view customRevert\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, customRevert);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided `customRevert`) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v5.0._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        function() internal view customRevert\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check if target is a contract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                if (target.code.length == 0) {\n                    revert AddressEmptyCode(target);\n                }\n            }\n            return returndata;\n        } else {\n            _revert(returndata, customRevert);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or with a default revert error.\n     *\n     * _Available since v5.0._\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal view returns (bytes memory) {\n        return verifyCallResult(success, returndata, defaultRevert);\n    }\n\n    /**\n     * @dev Same as {xref-Address-verifyCallResult-bool-bytes-}[`verifyCallResult`], but with a\n     * `customRevert` function as a fallback when `success` is `false`.\n     *\n     * Requirements:\n     *\n     * - `customRevert` must be a reverting function.\n     *\n     * _Available since v5.0._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        function() internal view customRevert\n    ) internal view returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, customRevert);\n        }\n    }\n\n    /**\n     * @dev Default reverting function when no `customRevert` is provided in a function call.\n     */\n    function defaultRevert() internal pure {\n        revert FailedInnerCall();\n    }\n\n    function _revert(bytes memory returndata, function() internal view customRevert) private view {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            customRevert();\n            revert FailedInnerCall();\n        }\n    }\n}\n"
    },
    "lib/openzeppelin-contracts-upgradeable/contracts/utils/StorageSlotUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.19;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(newImplementation.code.length > 0);\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, `uint256`._\n * _Available since v4.9 for `string`, `bytes`._\n */\nlibrary StorageSlotUpgradeable {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}\n"
    },
    "lib/openzeppelin-contracts-upgradeable/contracts/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.19;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev The contract is already initialized.\n     */\n    error AlreadyInitialized();\n\n    /**\n     * @dev The contract is not initializing.\n     */\n    error NotInitializing();\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        if (!(isTopLevelCall && _initialized < 1) && !(address(this).code.length == 0 && _initialized == 1)) {\n            revert AlreadyInitialized();\n        }\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        if (_initializing || _initialized >= version) {\n            revert AlreadyInitialized();\n        }\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        if (!_initializing) {\n            revert NotInitializing();\n        }\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        if (_initializing) {\n            revert AlreadyInitialized();\n        }\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.19;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Muldiv operation overflow.\n     */\n    error MathOverflowedMulDiv();\n\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v5.0._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v5.0._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v5.0._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v5.0._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v5.0._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            return a / b;\n        }\n\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.19;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "remappings": [
      "BokkyPooBahsDateTimeLibrary/=lib/BokkyPooBahsDateTimeLibrary/",
      "ds-test/=lib/forge-std/lib/ds-test/src/",
      "forge-std/=lib/forge-std/src/",
      "openzeppelin-contracts/=lib/openzeppelin-contracts/",
      "openzeppelin/=lib/openzeppelin-contracts/",
      "@openzeppelin/=lib/openzeppelin-contracts/",
      "openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/",
      "risc0/=lib/risc0-ethereum/contracts/src/",
      "eas-contracts/=lib/eas-contracts/contracts/",
      "safe-contracts/=lib/safe-contracts/contracts/",
      "erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/",
      "risc0-ethereum/=lib/risc0-ethereum/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "metadata": {
      "useLiteralContent": false,
      "bytecodeHash": "ipfs",
      "appendCBOR": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "evmVersion": "cancun",
    "viaIR": false,
    "libraries": {
      "src/lib/SortedLinkedList.sol": {
        "SortedLinkedList": "0x07B879C1bAaeeDe4dbC7383f6342556Ef144b27F"
      },
      "src/lib/TimeOperations.sol": {
        "TimeOperations": "0x852BE1E091189E68cD8721163286172d1e162a5a"
      },
      "src/utils/GatewayUtils.sol": {
        "GatewayUtils": "0xaB8b3a4CDdcf7B83C57880926Ba940F388897D11"
      }
    }
  }
}}