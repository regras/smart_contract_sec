{{
  "language": "Solidity",
  "sources": {
    "lib/aave-umbrella/src/contracts/helpers/UmbrellaBatchHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nimport {IERC20} from 'openzeppelin-contracts/contracts/token/ERC20/IERC20.sol';\nimport {IERC20Permit} from 'openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Permit.sol';\n\nimport {Ownable} from 'openzeppelin-contracts/contracts/access/Ownable.sol';\nimport {SafeERC20} from 'openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol';\n\nimport {Pausable} from 'openzeppelin-contracts/contracts/utils/Pausable.sol';\nimport {Multicall} from 'openzeppelin-contracts/contracts/utils/Multicall.sol';\n\nimport {IRescuableBase, RescuableBase} from 'solidity-utils/contracts/utils/RescuableBase.sol';\nimport {Rescuable} from 'solidity-utils/contracts/utils/Rescuable.sol';\n\nimport {IUmbrellaBatchHelper} from './interfaces/IUmbrellaBatchHelper.sol';\nimport {IUniversalToken} from './interfaces/IUniversalToken.sol';\n\nimport {IStataTokenV2} from 'aave-v3-origin/contracts/extensions/stata-token/interfaces/IStataTokenV2.sol';\nimport {IERC4626StataToken} from 'aave-v3-origin/contracts/extensions/stata-token/interfaces/IERC4626StataToken.sol';\n\nimport {IStakeToken} from '../stakeToken/interfaces/IStakeToken.sol';\nimport {IERC4626StakeToken} from '../stakeToken/interfaces/IERC4626StakeToken.sol';\n\nimport {IRewardsController} from '../rewards/interfaces/IRewardsController.sol';\nimport {IRewardsStructs} from '../rewards/interfaces/IRewardsStructs.sol';\n\n/**\n * @title UmbrellaBatchHelper\n * @notice UmbrellaBatchHelper is a utility contract designed to consolidate multiple transactions into a single one.\n * It simplifies deposits, withdrawals, restaking, and cooldown activation,\n * making these actions more convenient for holders of multiple `StakeToken`s.\n * @author BGD labs\n */\ncontract UmbrellaBatchHelper is IUmbrellaBatchHelper, Ownable, Pausable, Multicall, Rescuable {\n  using SafeERC20 for *;\n\n  /**\n   * @notice Defines possible conversion paths for a `StakeToken`.\n   * @dev Used internally to determine how a token can be converted to/from a `StakeToken`.\n   * @param None Indicates that the token cannot be directly converted to or from a `StakeToken`.\n   * @param StataToken Indicates that deposit starts from or withdrawals ends with a `StataToken`.\n   * @param AToken Indicates that deposit starts from or withdrawals ends with an `AToken`.\n   * @param Token Indicates that deposit starts from or withdrawals ends with a regular `Token`.\n   */\n  enum Path {\n    None,\n    StataToken,\n    AToken,\n    Token\n  }\n\n  struct Info {\n    /// @notice Set to true, when path is initialized for `StakeToken`\n    bool initialized;\n    /// @notice Set to true, when underlying token of stake is stata\n    bool isStata;\n    /// @notice Address of the underlying token from stake\n    IUniversalToken stakeTokenUnderlying;\n  }\n\n  struct Config {\n    /// @notice 1-slot info\n    Info info;\n    /// @notice Mapping to get start/end path from `transactionToken` or `reward`\n    mapping(address => Path) tokenToPath;\n  }\n\n  /// @notice Internal mapping with `StakeToken` path configs\n  mapping(IStakeToken => Config) internal _configs;\n\n  /// @inheritdoc IUmbrellaBatchHelper\n  IRewardsController public immutable REWARDS_CONTROLLER;\n\n  constructor(address rewardsController_, address owner_) Ownable(owner_) {\n    require(rewardsController_ != address(0), ZeroAddress());\n\n    REWARDS_CONTROLLER = IRewardsController(rewardsController_);\n  }\n\n  /// @inheritdoc IUmbrellaBatchHelper\n  function initializePath(IStakeToken[] calldata stakeTokens) external {\n    for (uint256 i; i < stakeTokens.length; ++i) {\n      _checkAndInitializePath(stakeTokens[i]);\n    }\n  }\n\n  /// @inheritdoc IUmbrellaBatchHelper\n  function cooldownPermit(CooldownPermit calldata p) external whenNotPaused {\n    _checkAndInitializePath(p.stakeToken);\n    // Due to the fact, that `StakeToken` uses `_msgSender()` inside digest, then signature shouldn't be able\n    // to be reused by external actor, that's why there's no try-catch here\n    p.stakeToken.cooldownWithPermit(\n      _msgSender(),\n      p.deadline,\n      IERC4626StakeToken.SignatureParams(p.v, p.r, p.s)\n    );\n  }\n\n  /// @inheritdoc IUmbrellaBatchHelper\n  function claimRewardsPermit(ClaimPermit calldata p) external whenNotPaused {\n    _checkAndInitializePath(p.stakeToken);\n\n    uint256[] memory amounts = _claimRewardsPermit(p);\n\n    // If restake is set to true, then rewards are transferred to this contract, otherwise to `_msgSender()`\n    if (!p.restake) {\n      return;\n    }\n\n    Config storage config = _configs[p.stakeToken];\n\n    // `amounts` length is always the same as `p.rewards` length\n    for (uint256 i; i < amounts.length; ++i) {\n      if (amounts[i] == 0) {\n        continue;\n      }\n\n      Path startPath = config.tokenToPath[p.rewards[i]];\n\n      // If `reward` is `aToken` or another token with dynamic balance, then transfer could lead to some wei loss\n      uint256 actualAmountReceived = IERC20(p.rewards[i]).balanceOf(address(this));\n\n      if (actualAmountReceived == 0) {\n        continue;\n      }\n\n      if (actualAmountReceived < amounts[i]) {\n        amounts[i] = actualAmountReceived;\n      }\n\n      if (startPath == Path.None) {\n        // Can't restake this token, so just transfer to `_msgSender()`\n        IERC20(p.rewards[i]).safeTransfer(_msgSender(), amounts[i]);\n      } else {\n        // Restake token\n        _depositToStake(p.stakeToken, p.rewards[i], amounts[i], config.info, startPath);\n      }\n    }\n  }\n\n  /// @inheritdoc IUmbrellaBatchHelper\n  function permit(Permit calldata p) external whenNotPaused {\n    // To prevent a griefing attack where a malicious actor duplicates the `permit` call (with the same signature and params)\n    // directly to the token we wrap it into a `try-catch` block\n    try\n      IERC20Permit(p.token).permit(_msgSender(), address(this), p.value, p.deadline, p.v, p.r, p.s)\n    {} catch {}\n  }\n\n  /// @inheritdoc IUmbrellaBatchHelper\n  function deposit(IOData calldata io) external whenNotPaused {\n    require(io.value != 0, ZeroAmount());\n\n    _checkAndInitializePath(io.stakeToken);\n\n    Config storage config = _configs[io.stakeToken];\n\n    Path path = config.tokenToPath[io.edgeToken];\n    require(path != Path.None, InvalidEdgeToken());\n\n    uint256 value = io.value;\n\n    if (path == Path.AToken) {\n      bool wholeBalanceTransferred;\n      // If we are using `aToken`s, then we can't guarantee that whole balance will be sent to the helper, cause of it's dynamic growth\n      // So, setting `io.value` more than actual balance will transfer all balance available\n      uint256 balanceInCurrentBlock = IERC20(io.edgeToken).balanceOf(_msgSender());\n\n      require(balanceInCurrentBlock != 0, ZeroAmount());\n\n      if (value > balanceInCurrentBlock) {\n        wholeBalanceTransferred = true;\n        value = balanceInCurrentBlock;\n      }\n\n      IERC20(io.edgeToken).safeTransferFrom(_msgSender(), address(this), value);\n\n      // `aToken` transfer could lead to some wei being lost if not whole balance has been transferred\n      if (!wholeBalanceTransferred) {\n        uint256 actualAmountReceived = IERC20(io.edgeToken).balanceOf(address(this));\n\n        if (value > actualAmountReceived) {\n          value = actualAmountReceived;\n        }\n      }\n    } else {\n      // Transfer `StataToken` and `Token` without dynamic balance growth\n      IERC20(io.edgeToken).safeTransferFrom(_msgSender(), address(this), value);\n    }\n\n    _depositToStake(io.stakeToken, io.edgeToken, value, config.info, path);\n  }\n\n  /// @inheritdoc IUmbrellaBatchHelper\n  function redeem(IOData calldata io) external whenNotPaused {\n    require(io.value != 0, ZeroAmount());\n\n    _checkAndInitializePath(io.stakeToken);\n\n    Config storage config = _configs[io.stakeToken];\n\n    Path path = config.tokenToPath[io.edgeToken];\n    require(path != Path.None, InvalidEdgeToken());\n\n    _redeemFromStake(io.stakeToken, io.value, config.info, path);\n  }\n\n  /// @inheritdoc IUmbrellaBatchHelper\n  function pause() external onlyOwner {\n    _pause();\n  }\n\n  /// @inheritdoc IUmbrellaBatchHelper\n  function unpause() external onlyOwner {\n    _unpause();\n  }\n\n  function whoCanRescue() public view override returns (address) {\n    return owner();\n  }\n\n  function maxRescue(\n    address\n  ) public pure override(IRescuableBase, RescuableBase) returns (uint256) {\n    return type(uint256).max;\n  }\n\n  /**\n   * @notice Claims rewards on behalf of `_msgSender`.\n   * @dev Rewards could be transferred to this balance (if `restake` flag is `true`) or to the `_msgSender`\n   * @param p Struct with all necessary data\n   */\n  function _claimRewardsPermit(ClaimPermit calldata p) internal returns (uint256[] memory) {\n    // Due to the fact, that `RewardsController` uses `msg.sender` inside digest, then signature shouldn't\n    // be able to be reused by external actor, that's why there's no try-catch here\n    return\n      REWARDS_CONTROLLER.claimSelectedRewardsPermit(\n        address(p.stakeToken),\n        p.rewards,\n        _msgSender(),\n        p.restake ? address(this) : _msgSender(),\n        p.deadline,\n        IRewardsStructs.SignatureParams(p.v, p.r, p.s)\n      );\n  }\n\n  /**\n   * @notice Deposits `edgeToken` using smart route to `StakeToken`\n   * @param edgeToken Address of already transferred token\n   * @param value Amount of `edgeToken` transferred\n   * @param info Struct with common information about `StakeToken`\n   * @param startPath Path to start from, can have any value (`StataToken/AToken/Token`) except `None`\n   */\n  function _depositToStake(\n    IStakeToken stakeToken,\n    address edgeToken,\n    uint256 value,\n    Info memory info,\n    Path startPath\n  ) internal {\n    // deposit to stata if needed\n    if (_needToUseStata(startPath, info.isStata)) {\n      IERC20(edgeToken).forceApprove(address(info.stakeTokenUnderlying), value);\n\n      // rewrite the amount of tokens to be deposited to stake\n      if (startPath == Path.Token) {\n        value = info.stakeTokenUnderlying.deposit(value, address(this));\n      } else {\n        // only aToken remains here\n        value = info.stakeTokenUnderlying.depositATokens(value, address(this));\n      }\n    }\n\n    // deposit underlying asset (stata or common token) to stake\n    info.stakeTokenUnderlying.forceApprove(address(stakeToken), value);\n    stakeToken.deposit(value, _msgSender());\n  }\n\n  /**\n   * @notice Redeems `edgeToken` using smart route from `StakeToken`\n   * @param value Amount of `StakeToken` to be redeemed\n   * @param info Struct with common information about `StakeToken`\n   * @param endPath Token that ends the path, can have any value (`StataToken/AToken/Token`) except `None`\n   */\n  function _redeemFromStake(\n    IStakeToken stakeToken,\n    uint256 value,\n    Info memory info,\n    Path endPath\n  ) internal {\n    if (_needToUseStata(endPath, info.isStata)) {\n      // redeem stata from stake and rewrite the amount of tokens to be redeemed from stata\n      value = stakeToken.redeem(value, address(this), _msgSender());\n\n      if (endPath == Path.Token) {\n        // redeem Token from stata\n        info.stakeTokenUnderlying.redeem(value, _msgSender(), address(this));\n      } else {\n        // only `aToken` remains here\n        info.stakeTokenUnderlying.redeemATokens(value, _msgSender(), address(this));\n      }\n    } else {\n      stakeToken.redeem(value, _msgSender(), _msgSender());\n    }\n  }\n\n  /**\n   * @notice Checks that smart route is initialized. Initializes if it's possible and hasn't been made before.\n   * @dev Reverts if it's not possible.\n   * @param stakeToken Address of `StakeToken`\n   */\n  function _checkAndInitializePath(IStakeToken stakeToken) internal {\n    if (!_configs[stakeToken].info.initialized) {\n      // check that `StakeToken` was initialized inside `RewardsController`\n      require(\n        REWARDS_CONTROLLER.getAssetData(address(stakeToken)).targetLiquidity != 0,\n        NotInitializedStake()\n      );\n\n      Config storage config = _configs[stakeToken];\n      address underlyingOfStakeToken = stakeToken.asset();\n      address token;\n\n      // check if underlying token is stata or common token (like GHO or LP-token)\n      (bool success, bytes memory data) = address(underlyingOfStakeToken).staticcall(\n        abi.encodeWithSelector(IERC4626StataToken.aToken.selector)\n      );\n\n      if (success) {\n        address aToken = abi.decode(data, (address));\n\n        config.tokenToPath[underlyingOfStakeToken] = Path.StataToken;\n        config.tokenToPath[aToken] = Path.AToken;\n\n        // Asset of `StataToken` is `Token` itself, not `aToken`\n        token = IUniversalToken(underlyingOfStakeToken).asset();\n      } else {\n        token = underlyingOfStakeToken;\n      }\n\n      config.tokenToPath[token] = Path.Token;\n\n      config.info = Info({\n        initialized: true,\n        isStata: underlyingOfStakeToken != token,\n        stakeTokenUnderlying: IUniversalToken(underlyingOfStakeToken)\n      });\n\n      emit AssetPathInitialized(address(stakeToken));\n    }\n  }\n\n  /**\n   * @notice Checks if `deposit/withdrawal` to/from `StataToken` is needed or not.\n   * @param path Path to start from / end with\n   * @param isStata Flag, true is underlying of `StakeToken` is `StataToken`, false otherwise\n   */\n  function _needToUseStata(Path path, bool isStata) internal pure returns (bool) {\n    // If `isStata == false`, then path could be only `Token` -> always return `false`\n    // If `isStata == true`, then path could be `Token`, `AToken` and `StataToken` -> return `false` if `path` is `StataToken`, `true` otherwise\n    return path != Path.StataToken && isStata;\n  }\n}\n"
    },
    "lib/aave-umbrella/lib/aave-v3-origin/lib/solidity-utils/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "lib/aave-umbrella/lib/aave-v3-origin/lib/solidity-utils/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[ERC-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC-20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "lib/aave-umbrella/lib/aave-v3-origin/lib/solidity-utils/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "lib/aave-umbrella/lib/aave-v3-origin/lib/solidity-utils/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC1363} from \"../../../interfaces/IERC1363.sol\";\nimport {Address} from \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC-20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    /**\n     * @dev An operation with an ERC-20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     *\n     * NOTE: If the token implements ERC-7674, this function will not modify any temporary allowance. This function\n     * only sets the \"standard\" allowance. Any temporary allowance will remain active, in addition to the value being\n     * set here.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferAndCall, with a fallback to the simple {ERC20} transfer if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            safeTransfer(token, to, value);\n        } else if (!token.transferAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferFromAndCall, with a fallback to the simple {ERC20} transferFrom if the target\n     * has no code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferFromAndCallRelaxed(\n        IERC1363 token,\n        address from,\n        address to,\n        uint256 value,\n        bytes memory data\n    ) internal {\n        if (to.code.length == 0) {\n            safeTransferFrom(token, from, to, value);\n        } else if (!token.transferFromAndCall(from, to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} approveAndCall, with a fallback to the simple {ERC20} approve if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * NOTE: When the recipient address (`to`) has no code (i.e. is an EOA), this function behaves as {forceApprove}.\n     * Opposedly, when the recipient address (`to`) has code, this function only attempts to call {ERC1363-approveAndCall}\n     * once without retrying, and relies on the returned value to be true.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function approveAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            forceApprove(token, to, value);\n        } else if (!token.approveAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturnBool} that reverts if call fails to meet the requirements.\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            let success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            // bubble errors\n            if iszero(success) {\n                let ptr := mload(0x40)\n                returndatacopy(ptr, 0, returndatasize())\n                revert(ptr, returndatasize())\n            }\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n\n        if (returnSize == 0 ? address(token).code.length == 0 : returnValue != 1) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silently catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n        return success && (returnSize == 0 ? address(token).code.length > 0 : returnValue == 1);\n    }\n}\n"
    },
    "lib/aave-umbrella/lib/aave-v3-origin/lib/solidity-utils/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/utils/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Pausable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    bool private _paused;\n\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    /**\n     * @dev The operation failed because the contract is paused.\n     */\n    error EnforcedPause();\n\n    /**\n     * @dev The operation failed because the contract is not paused.\n     */\n    error ExpectedPause();\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        if (paused()) {\n            revert EnforcedPause();\n        }\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        if (!paused()) {\n            revert ExpectedPause();\n        }\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "lib/aave-umbrella/lib/aave-v3-origin/lib/solidity-utils/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/utils/Multicall.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Multicall.sol)\n\npragma solidity ^0.8.20;\n\nimport {Address} from \"./Address.sol\";\nimport {Context} from \"./Context.sol\";\n\n/**\n * @dev Provides a function to batch together multiple calls in a single external call.\n *\n * Consider any assumption about calldata validation performed by the sender may be violated if it's not especially\n * careful about sending transactions invoking {multicall}. For example, a relay address that filters function\n * selectors won't filter calls nested within a {multicall} operation.\n *\n * NOTE: Since 5.0.1 and 4.9.4, this contract identifies non-canonical contexts (i.e. `msg.sender` is not {_msgSender}).\n * If a non-canonical context is identified, the following self `delegatecall` appends the last bytes of `msg.data`\n * to the subcall. This makes it safe to use with {ERC2771Context}. Contexts that don't affect the resolution of\n * {_msgSender} are not propagated to subcalls.\n */\nabstract contract Multicall is Context {\n    /**\n     * @dev Receives and executes a batch of function calls on this contract.\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\n     */\n    function multicall(bytes[] calldata data) external virtual returns (bytes[] memory results) {\n        bytes memory context = msg.sender == _msgSender()\n            ? new bytes(0)\n            : msg.data[msg.data.length - _contextSuffixLength():];\n\n        results = new bytes[](data.length);\n        for (uint256 i = 0; i < data.length; i++) {\n            results[i] = Address.functionDelegateCall(address(this), bytes.concat(data[i], context));\n        }\n        return results;\n    }\n}\n"
    },
    "lib/aave-umbrella/lib/aave-v3-origin/lib/solidity-utils/src/contracts/utils/RescuableBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.8;\n\nimport {IERC20} from 'openzeppelin-contracts/contracts/token/ERC20/IERC20.sol';\nimport {SafeERC20} from 'openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol';\nimport {IRescuableBase} from './interfaces/IRescuableBase.sol';\n\nabstract contract RescuableBase is IRescuableBase {\n  using SafeERC20 for IERC20;\n\n  /// @inheritdoc IRescuableBase\n  function maxRescue(address erc20Token) public view virtual returns (uint256);\n\n  function _emergencyTokenTransfer(address erc20Token, address to, uint256 amount) internal {\n    uint256 max = maxRescue(erc20Token);\n    amount = max > amount ? amount : max;\n    IERC20(erc20Token).safeTransfer(to, amount);\n\n    emit ERC20Rescued(msg.sender, erc20Token, to, amount);\n  }\n\n  function _emergencyEtherTransfer(address to, uint256 amount) internal {\n    (bool success, ) = to.call{value: amount}(new bytes(0));\n    if (!success) {\n      revert EthTransferFailed();\n    }\n\n    emit NativeTokensRescued(msg.sender, to, amount);\n  }\n}\n"
    },
    "lib/aave-umbrella/lib/aave-v3-origin/lib/solidity-utils/src/contracts/utils/Rescuable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.8;\n\nimport {IERC20} from 'openzeppelin-contracts/contracts/token/ERC20/IERC20.sol';\nimport {RescuableBase} from './RescuableBase.sol';\nimport {IRescuable} from './interfaces/IRescuable.sol';\n\n/**\n * @title Rescuable\n * @author BGD Labs\n * @notice abstract contract with the methods to rescue tokens (ERC20 and native)  from a contract\n */\nabstract contract Rescuable is RescuableBase, IRescuable {\n  /// @notice modifier that checks that caller is allowed address\n  modifier onlyRescueGuardian() {\n    if (msg.sender != whoCanRescue()) {\n      revert OnlyRescueGuardian();\n    }\n    _;\n  }\n\n  /// @inheritdoc IRescuable\n  function emergencyTokenTransfer(\n    address erc20Token,\n    address to,\n    uint256 amount\n  ) external virtual onlyRescueGuardian {\n    _emergencyTokenTransfer(erc20Token, to, amount);\n  }\n\n  /// @inheritdoc IRescuable\n  function emergencyEtherTransfer(address to, uint256 amount) external virtual onlyRescueGuardian {\n    _emergencyEtherTransfer(to, amount);\n  }\n\n  function whoCanRescue() public view virtual returns (address);\n}\n"
    },
    "lib/aave-umbrella/src/contracts/helpers/interfaces/IUmbrellaBatchHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IRescuable} from 'solidity-utils/contracts/utils/interfaces/IRescuable.sol';\n\nimport {IRewardsController} from '../../rewards/interfaces/IRewardsController.sol';\nimport {IStakeToken} from '../../stakeToken/interfaces/IStakeToken.sol';\n\ninterface IUmbrellaBatchHelper is IRescuable {\n  struct CooldownPermit {\n    /// @notice Address of the `StakeToken`, which `cooldown` should be activated via signature\n    IStakeToken stakeToken;\n    /// @notice Deadline of the signature\n    uint256 deadline;\n    /// @notice Signature params\n    uint8 v;\n    bytes32 r;\n    bytes32 s;\n  }\n\n  struct ClaimPermit {\n    /// @notice Address of the `StakeToken`, whose rewards could be claimed or restaked\n    IStakeToken stakeToken;\n    /// @notice Addresses of the rewards\n    address[] rewards;\n    /// @notice Deadline of the signature\n    uint256 deadline;\n    /// @notice Signature params\n    uint8 v;\n    bytes32 r;\n    bytes32 s;\n    /// @notice Flag to determine the direction of funds, simply claim or try to make a transfer and restake them\n    /// @dev If restake flag is set to true, then signature should be signed using `UmbrellaBatchHelper` contract address as a rewards receiver\n    /// @dev Otherwise, the receiver in the signature must match the `msg.sender`\n    bool restake;\n  }\n  /// @dev Doesn't work with `DAI`, as it's incompatible with the `ERC-2612` standard\n  struct Permit {\n    /// @notice Address of the token to call permit\n    address token;\n    /// @notice Amount of funds to permit\n    uint256 value;\n    /// @notice Deadline of the signature\n    uint256 deadline;\n    /// @notice Signature params\n    uint8 v;\n    bytes32 r;\n    bytes32 s;\n  }\n\n  struct IOData {\n    /// @notice Address of the `StakeToken`\n    IStakeToken stakeToken;\n    /// @notice Deposit start token or redemption end token\n    address edgeToken;\n    /// @notice Amount of funds to be deposited or amount of funds to be burned during `redeem`\n    uint256 value;\n  }\n\n  /**\n   * @notice Event is emitted when the path of `StakeToken` is initialized.\n   * @param stakeToken Address of the `StakeToken` which path is initialized\n   */\n  event AssetPathInitialized(address indexed stakeToken);\n\n  /**\n   * @dev Attempted to set zero address.\n   */\n  error ZeroAddress();\n\n  /**\n   * @dev Attempted to use an invalid token for deposit/redeem.\n   */\n  error InvalidEdgeToken();\n\n  /**\n   * @dev Attempted to initialize path for `StakeToken`, which wasn't configured inside `RewardsController`.\n   * (Without initialization inside `RewardsController` `StakeToken` isn't working at all.)\n   */\n  error NotInitializedStake();\n\n  /**\n   * @dev Attempted to `deposit/redeem` zero amount.\n   */\n  error ZeroAmount();\n\n  /**\n   * @notice Helps to initialize paths for several `StakeToken`s.\n   * @dev Optional, can be skipped, useful to avoid overpaying gas for early adopters of new `StakeToken`s.\n   * @param stakeTokens Array of `StakeToken`s\n   */\n  function initializePath(IStakeToken[] calldata stakeTokens) external;\n\n  /**\n   * @notice Trigger `cooldown` on specified `StakeToken` via signature.\n   * @param cooldownPermit_ Struct with necessary data and signature.\n   */\n  function cooldownPermit(CooldownPermit calldata cooldownPermit_) external;\n\n  /**\n   * @notice Claims rewards using a signature.\n   * @dev Transfers rewards to `_msgSender`, in the token accrued or in `StakeToken`s, depending on the `restake` option.\n   *\n   * The user must specify the `StakeToken` and the list of rewards to claim, along with a valid signature for the helper contract.\n   * - If `restake` is `true`, the rewards receiver (used in the signature) should be this contract.\n   * - Otherwise, signature will use `_msgSender` as rewards recipient.\n   *\n   * Regardless of the `restake` option, `msg.sender` always receives rewards from the `RewardsController` or freshly minted `StakeToken`s (if possible).\n   *\n   * @param claimPermit_ Struct containing the required data and signature.\n   */\n  function claimRewardsPermit(ClaimPermit calldata claimPermit_) external;\n\n  /**\n   * @notice Adjusts the user's token allowance for this helper contract via permit signature.\n   * @dev This function should be used in conjunction with the `deposit/redeem` functions.\n   * It allows this contract to call `transferFrom` or `redeem` on behalf of `_msgSender` during token `deposit/redeem`.\n   * @param permit_ Struct containing the required data and signature.\n   */\n  function permit(Permit calldata permit_) external;\n\n  /**\n   * @notice Handles deposits\n   * @dev The necessary `allowance` must be allocated before the call, for example by using `permit`.\n   *\n   * `edgeToken` should indicate the token used to start the deposit process from in order to receive a `StakeToken`.\n   * The user can start with a `Token`, `aToken` or `StataToken`.\n   *\n   * If the specified token's address cannot be used for direct deposit to the `StakeToken`\n   * (via `StataToken`, if required), the transaction will fail.\n   *\n   * @param io Struct containing the required data.\n   */\n  function deposit(IOData calldata io) external;\n\n  /**\n   * @notice Handles redemptions.\n   * @dev The necessary `allowance` must be allocated before the call, for example by using `permit`.\n   * When withdrawing funds, the user must specify the desired output token using the `edgeToken`.\n   *\n   * If the specified token's address cannot be used for direct redemption from the `StakeToken` (via `StataToken`, if required),\n   * the transaction will fail.\n   *\n   * @param io Struct containing the required data.\n   */\n  function redeem(IOData calldata io) external;\n\n  /**\n   * @notice Pauses the contract, can be called by `owner`.\n   * Emits a {Paused} event.\n   */\n  function pause() external;\n\n  /**\n   * @notice Unpauses the contract, can be called by `owner`.\n   * Emits a {Unpaused} event.\n   */\n  function unpause() external;\n\n  /**\n   * @notice Returns the `RewardsController` contract address.\n   * @return Address wrapped to interface of `RewardsController`\n   */\n  function REWARDS_CONTROLLER() external returns (IRewardsController);\n}\n"
    },
    "lib/aave-umbrella/src/contracts/helpers/interfaces/IUniversalToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IStataTokenV2} from 'aave-v3-origin/contracts/extensions/stata-token/interfaces/IStataTokenV2.sol';\n\n/**\n * @title IUniversalToken\n * @notice IUniversalToken is renamed interface of IStataTokenV2, because it includes the interface of a regular IERC20 token and IStataTokenV2.\n * This is necessary to avoid confusion in names inside `UmbrellaBatchHelper`, since it allows both `StataTokenV2`, `ERC20Permit` and `ERC20` calls (like transfer, approve, etc).\n * @author BGD labs\n */\ninterface IUniversalToken is IStataTokenV2 {\n\n}\n"
    },
    "lib/aave-umbrella/lib/aave-v3-origin/src/contracts/extensions/stata-token/interfaces/IStataTokenV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC4626} from 'openzeppelin-contracts/contracts/interfaces/IERC4626.sol';\nimport {IERC20Permit} from 'openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Permit.sol';\nimport {IERC4626StataToken} from './IERC4626StataToken.sol';\nimport {IERC20AaveLM} from './IERC20AaveLM.sol';\n\ninterface IStataTokenV2 is IERC4626, IERC20Permit, IERC4626StataToken, IERC20AaveLM {\n  /**\n   * @notice Checks if the passed actor is permissioned emergency admin.\n   * @param actor The reward to claim\n   * @return bool signaling if actor can pause the vault.\n   */\n  function canPause(address actor) external view returns (bool);\n\n  /**\n   * @notice Pauses/unpauses all system's operations\n   * @param paused boolean determining if the token should be paused or unpaused\n   */\n  function setPaused(bool paused) external;\n}\n"
    },
    "lib/aave-umbrella/lib/aave-v3-origin/src/contracts/extensions/stata-token/interfaces/IERC4626StataToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport {IPool, IPoolAddressesProvider} from '../../../interfaces/IPool.sol';\n\ninterface IERC4626StataToken {\n  struct SignatureParams {\n    uint8 v;\n    bytes32 r;\n    bytes32 s;\n  }\n\n  error PoolAddressMismatch(address pool);\n\n  error StaticATokenInvalidZeroShares();\n\n  error OnlyPauseGuardian(address caller);\n\n  /**\n   * @notice The pool associated with the aToken.\n   * @return The pool address.\n   */\n  function POOL() external view returns (IPool);\n\n  /**\n   * @notice The poolAddressesProvider associated with the pool.\n   * @return The poolAddressesProvider address.\n   */\n  function POOL_ADDRESSES_PROVIDER() external view returns (IPoolAddressesProvider);\n\n  /**\n   * @notice Burns `shares` of static aToken, with receiver receiving the corresponding amount of aToken\n   * @param shares The shares to withdraw, in static balance of StaticAToken\n   * @param receiver The address that will receive the amount of `ASSET` withdrawn from the Aave protocol\n   * @return amountToWithdraw: aToken send to `receiver`, dynamic balance\n   **/\n  function redeemATokens(\n    uint256 shares,\n    address receiver,\n    address owner\n  ) external returns (uint256);\n\n  /**\n   * @notice Deposits aTokens and mints static aTokens to msg.sender\n   * @param assets The amount of aTokens to deposit (e.g. deposit of 100 aUSDC)\n   * @param receiver The address that will receive the static aTokens\n   * @return uint256 The amount of StaticAToken minted, static balance\n   **/\n  function depositATokens(uint256 assets, address receiver) external returns (uint256);\n\n  /**\n   * @notice Universal deposit method for proving aToken or underlying liquidity with permit\n   * @param assets The amount of aTokens or underlying to deposit\n   * @param receiver The address that will receive the static aTokens\n   * @param deadline Must be a timestamp in the future\n   * @param sig A `secp256k1` signature params from `msgSender()`\n   * @return uint256 The amount of StaticAToken minted, static balance\n   **/\n  function depositWithPermit(\n    uint256 assets,\n    address receiver,\n    uint256 deadline,\n    SignatureParams memory sig,\n    bool depositToAave\n  ) external returns (uint256);\n\n  /**\n   * @notice The aToken used inside the 4626 vault.\n   * @return address The aToken address.\n   */\n  function aToken() external view returns (address);\n\n  /**\n   * @notice Returns the current asset price of the stataToken.\n   * The price is calculated as `underlying_price * exchangeRate`.\n   * It is important to note that:\n   * - `underlying_price` is the price obtained by the aave-oracle and is subject to it's internal pricing mechanisms.\n   * - as the price is scaled over the exchangeRate, but maintains the same precision as the underlying the price might be underestimated by 1 unit.\n   * - when pricing multiple `shares` as `shares * price` keep in mind that the error compounds.\n   * @return price the current asset price.\n   */\n  function latestAnswer() external view returns (int256);\n}\n"
    },
    "lib/aave-umbrella/src/contracts/stakeToken/interfaces/IStakeToken.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {IERC20Permit} from 'openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Permit.sol';\n\nimport {IERC4626StakeToken} from './IERC4626StakeToken.sol';\n\ninterface IStakeToken is IERC4626StakeToken, IERC20Permit {}\n"
    },
    "lib/aave-umbrella/src/contracts/stakeToken/interfaces/IERC4626StakeToken.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {IERC4626} from 'openzeppelin-contracts/contracts/interfaces/IERC4626.sol';\n\ninterface IERC4626StakeToken is IERC4626 {\n  struct CooldownSnapshot {\n    /// @notice Amount of shares available to redeem\n    uint192 amount;\n    /// @notice Timestamp after which funds will be unlocked for withdrawal\n    uint32 endOfCooldown;\n    /// @notice Period of time to withdraw funds after end of cooldown\n    uint32 withdrawalWindow;\n  }\n\n  struct SignatureParams {\n    uint8 v;\n    bytes32 r;\n    bytes32 s;\n  }\n\n  /**\n   * @notice Event is emitted when a cooldown of staker is changed.\n   * @param user Staker address\n   * @param amount Amount of shares on the time cooldown is changed\n   * @param endOfCooldown Future timestamp, from which funds can be withdrawn\n   * @param unstakeWindow Duration of time to withdraw funds\n   */\n  event StakerCooldownUpdated(\n    address indexed user,\n    uint256 amount,\n    uint256 endOfCooldown,\n    uint256 unstakeWindow\n  );\n\n  /**\n   * @notice Event is emitted when a user installs/disables the operator for cooldown.\n   * @param user User address\n   * @param operator Address of operator to install/disable\n   * @param flag Flag responsible for setting/disabling operator\n   */\n  event CooldownOperatorSet(address indexed user, address indexed operator, bool flag);\n\n  /**\n   * @notice Event is emitted when a successful slash occurs\n   * @param destination Address, where funds transferred to\n   * @param amount Amount of funds transferred\n   */\n  event Slashed(address indexed destination, uint256 amount);\n\n  /**\n   * @notice Event is emitted when `cooldown` is changed to the new one\n   * @param oldCooldown Old `cooldown` duration\n   * @param newCooldown New `cooldown` duration\n   */\n  event CooldownChanged(uint256 oldCooldown, uint256 newCooldown);\n\n  /**\n   * @notice Event is emitted when `unstakeWindow` is changed to the new one\n   * @param oldUnstakeWindow Old `unstakeWindow` duration\n   * @param newUnstakeWindow new `unstakeWindow` duration\n   */\n  event UnstakeWindowChanged(uint256 oldUnstakeWindow, uint256 newUnstakeWindow);\n\n  /**\n   * @dev Attempted to set zero address as a variable.\n   */\n  error ZeroAddress();\n\n  /**\n   * @dev Attempted to call cooldown without locked liquidity.\n   */\n  error ZeroBalanceInStaking();\n\n  /**\n   * @dev Attempted to slash for zero amount of assets.\n   */\n  error ZeroAmountSlashing();\n\n  /**\n   * @dev Attempted to slash with insufficient funds in staking.\n   */\n  error ZeroFundsAvailable();\n\n  /**\n   * @dev Attempted to call cooldown without approval for `cooldownOnBehalf`.\n   * @param owner Address of user, which cooldown wasn't triggered\n   * @param spender Address of `msg.sender`\n   */\n  error NotApprovedForCooldown(address owner, address spender);\n\n  /**\n   * @notice Deposits by issuing approval for the required number of tokens (if `asset` supports the `permit` function).\n   * Emits a {Deposit} event.\n   * @param assets Amount of assets to be deposited\n   * @param receiver Receiver of shares\n   * @param deadline Signature deadline for issuing approve\n   * @param sig Signature parameters\n   * @return Amount of shares received\n   */\n  function depositWithPermit(\n    uint256 assets,\n    address receiver,\n    uint256 deadline,\n    SignatureParams calldata sig\n  ) external returns (uint256);\n\n  /**\n   * @notice Triggers user's `cooldown` using signature.\n   * Emits a {StakerCooldownUpdated} event.\n   * @param user The address, which `cooldown` will be triggered\n   * @param deadline Signature deadline for issuing approve\n   * @param sig Signature parameters\n   */\n  function cooldownWithPermit(\n    address user,\n    uint256 deadline,\n    SignatureParams calldata sig\n  ) external;\n\n  /**\n   * @notice Activates the cooldown period to unstake for `msg.sender`.\n   * It can't be called if the user is not staking.\n   * Emits a {StakerCooldownUpdated} event.\n   */\n  function cooldown() external;\n\n  /**\n   * @notice Activates the cooldown period to unstake for a certain user.\n   * It can't be called if the user is not staking.\n   * `from` must set as `cooldownOperator` for `msg.sender` so that he can activate the cooldown on his behalf.\n   * Emits a {StakerCooldownUpdated} event.\n   * @param from Address at which the `cooldown` will be activated\n   */\n  function cooldownOnBehalfOf(address from) external;\n\n  /**\n   * @notice Sets the ability to call `cooldownOnBehalf` for `msg.sender` by specified `operator` to `true` or `false`.\n   * Doesn't revert if the new `flag` value is the same as the old one.\n   * Emits a {CooldownOnBehalfChanged} event.\n   * @param operator The address that the ability to call `cooldownOnBehalf` for `msg.sender` can be changed\n   * @param flag True - to activate this ability, false - to deactivate\n   */\n  function setCooldownOperator(address operator, bool flag) external;\n\n  /**\n   * @notice Executes a slashing of the asset of a certain amount, transferring the seized funds\n   * to destination. Decreasing the amount of underlying will automatically adjust the exchange rate.\n   * If the amount exceeds maxSlashableAmount then the second one is taken.\n   * Can only be called by the `owner`.\n   * Emits a {Slashed} event.\n   * @param destination Address where seized funds will be transferred\n   * @param amount Amount to be slashed\n   * @return amount Amount slashed\n   */\n  function slash(address destination, uint256 amount) external returns (uint256);\n\n  /**\n   * @notice Pauses the contract, can be called by `owner`.\n   * Emits a {Paused} event.\n   */\n  function pause() external;\n\n  /**\n   * @notice Unpauses the contract, can be called by `owner`.\n   * Emits a {Unpaused} event.\n   */\n  function unpause() external;\n\n  /**\n   * @notice Sets a new `cooldown` duration.\n   * Can only be called by the `owner`.\n   * Emits a {CooldownChanged} event.\n   * @param cooldown Amount of seconds users have to wait between starting the `cooldown` and being able to withdraw funds\n   */\n  function setCooldown(uint256 cooldown) external;\n\n  /**\n   * @notice Sets a new `unstakeWindow` duration.\n   * Can only be called by the `owner`.\n   * Emits a {UnstakeWindowChanged} event.\n   * @param newUnstakeWindow Amount of seconds users have to withdraw after `cooldown`\n   */\n  function setUnstakeWindow(uint256 newUnstakeWindow) external;\n\n  /**\n   * @notice Returns current `cooldown` duration.\n   * @return _cooldown duration\n   */\n  function getCooldown() external view returns (uint256);\n\n  /**\n   * @notice Returns current `unstakeWindow` duration.\n   * @return _unstakeWindow duration\n   */\n  function getUnstakeWindow() external view returns (uint256);\n\n  /**\n   * @notice Returns the last activated user `cooldown`. Contains the amount of tokens and timestamp.\n   * May return zero values if all funds have been withdrawn or transferred.\n   * @param user Address of user\n   * @return User's cooldown snapshot\n   */\n  function getStakerCooldown(address user) external view returns (CooldownSnapshot memory);\n\n  /**\n   * @notice Returns true if the user's cooldown can be triggered by an operator, false - otherwise.\n   * @param user Address of the user.\n   * @param operator Address of an operator.\n   * @return Is operator set for `cooldownOnBehalf`\n   */\n  function isCooldownOperator(address user, address operator) external view returns (bool);\n\n  /**\n   * @notice Returns the next unused nonce for an address, which could be used inside signature for `cooldownWithPermit()` function.\n   * @param owner Address for which unused `cooldown` nonce will be returned\n   * @return The next unused `cooldown` nonce\n   */\n  function cooldownNonces(address owner) external view returns (uint256);\n\n  /**\n   * @notice Returns the maximum slashable assets available for now.\n   * @return Maximum assets available for slash\n   */\n  function getMaxSlashableAssets() external view returns (uint256);\n\n  /**\n   * @notice Returns the minimum amount of assets, which can't be slashed.\n   * @return Minimum assets value that cannot be slashed\n   */\n  function MIN_ASSETS_REMAINING() external view returns (uint256);\n}\n"
    },
    "lib/aave-umbrella/src/contracts/rewards/interfaces/IRewardsController.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {IRewardsDistributor} from './IRewardsDistributor.sol';\n\ninterface IRewardsController is IRewardsDistributor {\n  /**\n   * @notice Event is emitted when an asset is initialized.\n   * @param asset Address of the new `asset` added\n   */\n  event AssetInitialized(address indexed asset);\n\n  /**\n   * @notice Event is emitted when a `targetLiquidity` of the `asset` is changed.\n   * @param asset Address of the `asset`\n   * @param newTargetLiquidity New amount of `targetLiquidity` set for the `asset`\n   */\n  event TargetLiquidityUpdated(address indexed asset, uint256 newTargetLiquidity);\n\n  /**\n   * @notice Event is emitted when a `lastUpdatedTimestamp` of the `asset` is updated.\n   * @param asset Address of the `asset`\n   * @param newTimestamp New value of `lastUpdatedTimestamp` updated for the `asset`\n   */\n  event LastTimestampUpdated(address indexed asset, uint256 newTimestamp);\n\n  /**\n   * @notice Event is emitted when a reward is initialized for concrete `asset`.\n   * @param asset Address of the `asset`\n   * @param reward Address of the `reward`\n   */\n  event RewardInitialized(address indexed asset, address indexed reward);\n\n  /**\n   * @notice Event is emitted when a reward config is updated.\n   * @param asset Address of the `asset`\n   * @param reward Address of the `reward`\n   * @param maxEmissionPerSecond Amount of maximum possible rewards emission per second\n   * @param distributionEnd Timestamp after which distribution ends\n   * @param rewardPayer Address from where rewards will be transferred\n   */\n  event RewardConfigUpdated(\n    address indexed asset,\n    address indexed reward,\n    uint256 maxEmissionPerSecond,\n    uint256 distributionEnd,\n    address rewardPayer\n  );\n\n  /**\n   * @notice Event is emitted when a `reward` index is updated.\n   * @param asset Address of the `asset`\n   * @param reward Address of the `reward`\n   * @param newIndex New `reward` index updated for certain `asset`\n   */\n  event RewardIndexUpdated(address indexed asset, address indexed reward, uint256 newIndex);\n\n  /**\n   * @notice Event is emitted when a user interacts with the asset (transfer, mint, burn)  or manually updates the rewards data or claims them\n   * @param asset Address of the `asset`\n   * @param reward Address of the `reward`, which `user` data is updated\n   * @param user Address of the `user` whose `reward` data is updated\n   * @param newIndex Reward index set after update\n   * @param accruedFromLastUpdate Amount of accrued rewards from last update\n   */\n  event UserDataUpdated(\n    address indexed asset,\n    address indexed reward,\n    address indexed user,\n    uint256 newIndex,\n    uint256 accruedFromLastUpdate\n  );\n\n  /**\n   * @notice Event is emitted when a `user` `reward` is claimed.\n   * @param asset Address of the `asset`, whose `reward` was claimed\n   * @param reward Address of the `reward`, which is claimed\n   * @param user Address of the `user` whose `reward` is claimed\n   * @param receiver Address of the funds receiver\n   * @param amount Amount of the received funds\n   */\n  event RewardClaimed(\n    address indexed asset,\n    address indexed reward,\n    address indexed user,\n    address receiver,\n    uint256 amount\n  );\n\n  /**\n   * @dev Attempted to update data on the `asset` before it was initialized.\n   */\n  error AssetNotInitialized(address asset);\n\n  /**\n   * @dev Attempted to change the configuration of the `reward` before it was initialized.\n   */\n  error RewardNotInitialized(address reward);\n\n  /**\n   * @dev Attempted to set `distributionEnd` less than `block.timestamp` during `reward` initialization.\n   */\n  error InvalidDistributionEnd();\n\n  /**\n   * @dev Attempted to initialize more rewards than limit.\n   */\n  error MaxRewardsLengthReached();\n\n  // DEFAULT_ADMIN_ROLE\n  /////////////////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @notice Configures asset: sets `targetLiquidity` and updates `lastUpdatedTimestamp`.\n   * If the asset has already been initialized, then updates the rewards indexes and `lastUpdatedTimestamp`,\n   * also changes `targetLiquidity`, otherwise initializes asset and rewards.\n   * @dev `targetLiquidity` should be greater than 1 whole token.\n   * `maxEmissionPerSecond` inside `rewardConfig` should be less than 1000 tokens and greater than 2 wei.\n   * It must also be greater than `targetLiquidity * 1000 / 1e18`. Check EmissionMath.sol for more info.\n   * if `maxEmissionPerSecond` is zero or `distributionEnd` is less than current `block.timestamp`,\n   * then disable distribution for this `reward` if it was previously initialized.\n   * It can't initialize already disabled reward.\n   * @param asset Address of the `asset` to be configured/initialized\n   * @param targetLiquidity Amount of liquidity where will be the maximum emission of rewards per second applied\n   * @param rewardConfigs Optional array of reward configs, can be empty\n   */\n  function configureAssetWithRewards(\n    address asset,\n    uint256 targetLiquidity,\n    RewardSetupConfig[] calldata rewardConfigs\n  ) external;\n\n  // REWARDS_ADMIN_ROLE\n  /////////////////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @notice Configures already initialized rewards for certain `asset`: sets `distributionEnd` and `maxEmissionPerSecond`.\n   * If any reward hasn't initialized before then it reverts.\n   * Before setting new configuration updates all rewards indexes for `asset`.\n   * @dev `maxEmissionPerSecond` inside `rewardConfig` should be less than 1000 tokens and greater than 2 wei.\n   * It must also be greater than `targetLiquidity * 1000 / 1e18`. Check EmissionMath.sol for more info.\n   * If `maxEmissionPerSecond` is zero or `distributionEnd` is less than the current `block.timestamp`,\n   * then distribution for this `reward` will be disabled.\n   * @param asset Address of the `asset` whose reward should be configured\n   * @param rewardConfigs Array of structs with params to set\n   */\n  function configureRewards(address asset, RewardSetupConfig[] calldata rewardConfigs) external;\n\n  /////////////////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @notice Special hook, which is called every time `StakeToken` makes `_update` or `slash`.\n   * Makes an update and calculates new `index` and `accrued`. Also updates `lastUpdateTimestamp`.\n   * @dev All variables are passed here before the actual update.\n   * @param totalSupply Total supply of `StakeToken`\n   * @param totalAssets Total assets of `StakeToken`\n   * @param user User, whose `index` and rewards accrued will be updated, if address is zero then skips user update\n   * @param userBalance Amount of `StakeToken` shares owned by user\n   */\n  function handleAction(\n    uint256 totalSupply,\n    uint256 totalAssets,\n    address user,\n    uint256 userBalance\n  ) external;\n\n  /**\n   * @notice Updates all `reward` indexes and `lastUpdateTimestamp` for the `asset`.\n   * @param asset Address of the `asset` whose rewards will be updated\n   */\n  function updateAsset(address asset) external;\n\n  /**\n   * @notice Returns an array of all initialized assets (all `StakeTokens`, which are initialized here).\n   * @dev Return zero data if assets aren't set.\n   * @return assets Array of asset addresses\n   */\n  function getAllAssets() external view returns (address[] memory assets);\n\n  /**\n   * @notice Returns an array of all initialized rewards for a certain `asset`.\n   * @dev Return zero data if asset or rewards aren't set.\n   * @param asset Address of the `asset` whose rewards should be returned\n   * @return rewards Array of reward addresses\n   */\n  function getAllRewards(address asset) external view returns (address[] memory rewards);\n\n  /**\n   * @notice Returns all data about the asset and its rewards.\n   * @dev Return zero data if asset or rewards aren't set.\n   * Function made without some gas optimizations, so it's recommended to avoid calling it often from non-view method or inside batch.\n   * If the emission for a specific reward has ended at the time of the call (i.e., block.timestamp >= distributionEnd),\n   * the function will return a zero emission, even though there may still be remaining rewards.\n   * Note that the actual reward data will be updated the next time someone manually refreshes the data or interacts with the `StakeToken`.\n   * @param asset Address of the `asset` whose params should be returned\n   * @return assetData `targetLiquidity` and `lastUpdatedTimestamp` inside struct\n   * @return rewardsData All data about rewards including addresses and `RewardData`\n   */\n  function getAssetAndRewardsData(\n    address asset\n  )\n    external\n    view\n    returns (AssetDataExternal memory assetData, RewardDataExternal[] memory rewardsData);\n\n  /**\n   * @notice Returns data about the asset.\n   * @dev Return zero data if asset isn't set.\n   * @param asset Address of the `asset` whose params should be returned\n   * @return assetData `targetLiquidity` and `lastUpdatedTimestamp` inside struct\n   */\n  function getAssetData(address asset) external view returns (AssetDataExternal memory assetData);\n\n  /**\n   * @notice Returns data about the reward.\n   * @dev Return zero data if asset or rewards aren't set.\n   * If the emission has ended at the time of the call (i.e., block.timestamp >= distributionEnd), the function will return a zero emission,\n   * even though there may still be remaining rewards.\n   * Note that the actual reward data will be updated the next time someone manually refreshes the data or interacts with the `StakeToken`.\n   * @param asset Address of the `asset` whose `reward` params should be returned\n   * @param reward Address of the `reward` whose params should be returned\n   * @return rewardData `index`, `maxEmissionPerSecond` and `distributionEnd` and address inside struct, address is duplicated from external one\n   */\n  function getRewardData(\n    address asset,\n    address reward\n  ) external view returns (RewardDataExternal memory rewardData);\n\n  /**\n   * @notice Returns data about the reward emission.\n   * @dev Return zero data if asset or rewards aren't set.\n   * If `maxEmissionPerSecond` is equal to 1 wei, then `flatEmission` will be 0, although in fact it is not 0 and emission is taken into account correctly inside the code.\n   * Here this calculation is made specifically to simplify the function behaviour.\n   * If the emission has ended at the time of the call (i.e., block.timestamp >= distributionEnd), the function will return a zero max and flat emissions,\n   * even though there may still be remaining rewards.\n   * Note that the actual reward data will be updated the next time someone manually refreshes the data or interacts with the `StakeToken`.\n   * @param asset Address of the `asset` whose `reward` emission params should be returned\n   * @param reward Address of the `reward` whose emission params should be returned\n   * @return emissionData `targetLiquidity`, `targetLiquidityExcess`, `maxEmission` and `flatEmission` inside struct\n   */\n  function getEmissionData(\n    address asset,\n    address reward\n  ) external view returns (EmissionData memory emissionData);\n\n  /**\n   * @notice Returns `user` `index` and `accrued` for all rewards for certain `asset` at the time of the last user update.\n   * If you want to get current `accrued` of all rewards, see `calculateCurrentUserRewards`.\n   * @dev Return zero data if asset or rewards aren't set.\n   * @param asset Address of the `asset` for which the rewards are accumulated\n   * @param user Address of `user` accumulating rewards\n   * @return rewards Array of `reward` addresses\n   * @return userData `index` and `accrued` inside structs\n   */\n  function getUserDataByAsset(\n    address asset,\n    address user\n  ) external view returns (address[] memory rewards, UserDataExternal[] memory userData);\n\n  /**\n   * @notice Returns `user` `index` and `accrued` for certain `asset` and `reward` at the time of the last user update.\n   * If you want to calculate current `accrued` of the `reward`, see `calculateCurrentUserReward`.\n   * @dev Return zero data if asset or rewards aren't set.\n   * @param asset Address of the `asset` for which the `reward` is accumulated\n   * @param reward Address of the accumulating `reward`\n   * @param user Address of `user` accumulating rewards\n   * @return data `index` and `accrued` inside struct\n   */\n  function getUserDataByReward(\n    address asset,\n    address reward,\n    address user\n  ) external view returns (UserDataExternal memory data);\n\n  /**\n   * @notice Returns current `reward` indexes for `asset`.\n   * @dev Return zero if asset or rewards aren't set.\n   * Function made without some gas optimizations, so it's recommended to avoid calling it often from non-view method or inside batch.\n   * @param asset Address of the `asset` whose indexes of rewards should be calculated\n   * @return rewards Array of `reward` addresses\n   * @return indexes Current indexes\n   */\n  function calculateRewardIndexes(\n    address asset\n  ) external view returns (address[] memory rewards, uint256[] memory indexes);\n\n  /**\n   * @notice Returns current `index` for certain `asset` and `reward`.\n   * @dev Return zero if asset or rewards aren't set.\n   * @param asset Address of the `asset` whose `index` of `reward` should be calculated\n   * @param reward Address of the accumulating `reward`\n   * @return index Current `index`\n   */\n  function calculateRewardIndex(\n    address asset,\n    address reward\n  ) external view returns (uint256 index);\n\n  /**\n   * @notice Returns `emissionPerSecondScaled` for certain `asset` and `reward`. Returned value scaled to 18 decimals.\n   * @dev Return zero if asset or rewards aren't set.\n   * @param asset Address of the `asset` which current emission of `reward` should be returned\n   * @param reward Address of the `reward` which `emissionPerSecond` should be returned\n   * @return emissionPerSecondScaled Current amount of rewards distributed every second (scaled to 18 decimals)\n   */\n  function calculateCurrentEmissionScaled(\n    address asset,\n    address reward\n  ) external view returns (uint256 emissionPerSecondScaled);\n\n  /**\n   * @notice  Returns `emissionPerSecond` for certain `asset` and `reward`.\n   * @dev Return zero if asset or rewards aren't set.\n   * An integer quantity is returned, although the accuracy of the calculations in reality is higher.\n   * @param asset Address of the `asset` which current emission of `reward` should be returned\n   * @param reward Address of the `reward` which `emissionPerSecond` should be returned\n   * @return emissionPerSecond Current amount of rewards distributed every second\n   */\n  function calculateCurrentEmission(\n    address asset,\n    address reward\n  ) external view returns (uint256 emissionPerSecond);\n\n  /**\n   * @notice Calculates and returns `user` `accrued` amounts for all rewards for certain `asset`.\n   * @dev Return zero data if asset or rewards aren't set.\n   * Function made without some gas optimizations, so it's recommended to avoid calling it often from non-view method or inside batch.\n   * @param asset Address of the `asset` whose rewards are accumulated\n   * @param user Address of `user` accumulating rewards\n   * @return rewards Array of `reward` addresses\n   * @return rewardsAccrued Array of current calculated `accrued` amounts\n   */\n  function calculateCurrentUserRewards(\n    address asset,\n    address user\n  ) external view returns (address[] memory rewards, uint256[] memory rewardsAccrued);\n\n  /**\n   * @notice Calculates and returns `user` `accrued` amount for certain `reward` and `asset`.\n   * @dev Return zero if asset or rewards aren't set.\n   * @param asset Address of the `asset` whose reward is accumulated\n   * @param reward Address of the `reward` that accumulates for the user\n   * @param user Address of `user` accumulating rewards\n   * @return rewardAccrued Amount of current calculated `accrued` amount\n   */\n  function calculateCurrentUserReward(\n    address asset,\n    address reward,\n    address user\n  ) external view returns (uint256 rewardAccrued);\n}\n"
    },
    "lib/aave-umbrella/src/contracts/rewards/interfaces/IRewardsStructs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title IRewardsStructs interface\n * @notice An interface containing structures that can be used externally.\n * @author BGD labs\n */\ninterface IRewardsStructs {\n  struct RewardSetupConfig {\n    /// @notice Reward address\n    address reward;\n    /// @notice Address, from which this reward will be transferred (should give approval to this address)\n    address rewardPayer;\n    /// @notice Maximum possible emission rate of rewards per second\n    uint256 maxEmissionPerSecond;\n    /// @notice End of the rewards distribution\n    uint256 distributionEnd;\n  }\n\n  struct AssetDataExternal {\n    /// @notice Liquidity value at which there will be maximum emission per second (expected amount of asset to be deposited into `StakeToken`)\n    uint256 targetLiquidity;\n    /// @notice Timestamp of the last update\n    uint256 lastUpdateTimestamp;\n  }\n\n  struct RewardDataExternal {\n    /// @notice Reward address\n    address addr;\n    /// @notice Liquidity index of the reward set during the last update\n    uint256 index;\n    /// @notice Maximum possible emission rate of rewards per second\n    uint256 maxEmissionPerSecond;\n    /// @notice End of the reward distribution\n    uint256 distributionEnd;\n  }\n\n  struct EmissionData {\n    /// @notice Liquidity value at which there will be maximum emission per second applied\n    uint256 targetLiquidity;\n    /// @notice Liquidity value after which emission per second will be flat\n    uint256 targetLiquidityExcess;\n    /// @notice Maximum possible emission rate of rewards per second (can be with or without scaling to 18 decimals, depending on usage in code)\n    uint256 maxEmission;\n    /// @notice Flat emission value per second (can be with or without scaling, depending on usage in code)\n    uint256 flatEmission;\n  }\n\n  struct UserDataExternal {\n    /// @notice Liquidity index of the user reward set during the last update\n    uint256 index;\n    /// @notice Amount of accrued rewards that the user earned at the time of his last index update (pending to claim)\n    uint256 accrued;\n  }\n\n  struct SignatureParams {\n    uint8 v;\n    bytes32 r;\n    bytes32 s;\n  }\n}\n"
    },
    "lib/aave-umbrella/lib/aave-v3-origin/lib/solidity-utils/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "lib/aave-umbrella/lib/aave-v3-origin/lib/solidity-utils/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/interfaces/IERC1363.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (interfaces/IERC1363.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @title IERC1363\n * @dev Interface of the ERC-1363 standard as defined in the https://eips.ethereum.org/EIPS/eip-1363[ERC-1363].\n *\n * Defines an extension interface for ERC-20 tokens that supports executing code on a recipient contract\n * after `transfer` or `transferFrom`, or code on a spender contract after `approve`, in a single transaction.\n */\ninterface IERC1363 is IERC20, IERC165 {\n    /*\n     * Note: the ERC-165 identifier for this interface is 0xb0202a11.\n     * 0xb0202a11 ===\n     *   bytes4(keccak256('transferAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))\n     */\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @param data Additional data with no specified format, sent in call to `spender`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value, bytes calldata data) external returns (bool);\n}\n"
    },
    "lib/aave-umbrella/lib/aave-v3-origin/lib/solidity-utils/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Address.sol)\n\npragma solidity ^0.8.20;\n\nimport {Errors} from \"./Errors.sol\";\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert Errors.InsufficientBalance(address(this).balance, amount);\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert Errors.FailedCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {Errors.FailedCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert Errors.InsufficientBalance(address(this).balance, value);\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {Errors.FailedCall}) in case\n     * of an unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {Errors.FailedCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {Errors.FailedCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            assembly (\"memory-safe\") {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert Errors.FailedCall();\n        }\n    }\n}\n"
    },
    "lib/aave-umbrella/lib/aave-v3-origin/lib/solidity-utils/src/contracts/utils/interfaces/IRescuableBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.8;\n\n/**\n * @title IRescuableBase\n * @author BGD Labs\n * @notice interface containing the objects, events and methods definitions of the RescuableBase contract\n */\ninterface IRescuableBase {\n  error EthTransferFailed();\n  /**\n   * @notice emitted when erc20 tokens get rescued\n   * @param caller address that triggers the rescue\n   * @param token address of the rescued token\n   * @param to address that will receive the rescued tokens\n   * @param amount quantity of tokens rescued\n   */\n  event ERC20Rescued(\n    address indexed caller,\n    address indexed token,\n    address indexed to,\n    uint256 amount\n  );\n\n  /**\n   * @notice emitted when native tokens get rescued\n   * @param caller address that triggers the rescue\n   * @param to address that will receive the rescued tokens\n   * @param amount quantity of tokens rescued\n   */\n  event NativeTokensRescued(address indexed caller, address indexed to, uint256 amount);\n\n  /**\n   * @notice method that defined the maximum amount rescuable for any given asset.\n   * @dev there's currently no way to limit the rescuable \"native asset\", as we assume erc20s as intended underlying.\n   * @return the maximum amount of\n   */\n  function maxRescue(address erc20Token) external view returns (uint256);\n}\n"
    },
    "lib/aave-umbrella/lib/aave-v3-origin/lib/solidity-utils/src/contracts/utils/interfaces/IRescuable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.8;\n\nimport {IRescuableBase} from './IRescuableBase.sol';\n\n/**\n * @title IRescuable\n * @author BGD Labs\n * @notice interface containing the objects, events and methods definitions of the Rescuable contract\n */\ninterface IRescuable is IRescuableBase {\n  error OnlyRescueGuardian();\n\n  /**\n   * @notice method called to rescue tokens sent erroneously to the contract. Only callable by owner\n   * @param erc20Token address of the token to rescue\n   * @param to address to send the tokens\n   * @param amount of tokens to rescue\n   */\n  function emergencyTokenTransfer(address erc20Token, address to, uint256 amount) external;\n\n  /**\n   * @notice method called to rescue ether sent erroneously to the contract. Only callable by owner\n   * @param to address to send the eth\n   * @param amount of eth to rescue\n   */\n  function emergencyEtherTransfer(address to, uint256 amount) external;\n}\n"
    },
    "lib/aave-umbrella/lib/aave-v3-origin/lib/solidity-utils/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/interfaces/IERC4626.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (interfaces/IERC4626.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../token/ERC20/IERC20.sol\";\nimport {IERC20Metadata} from \"../token/ERC20/extensions/IERC20Metadata.sol\";\n\n/**\n * @dev Interface of the ERC-4626 \"Tokenized Vault Standard\", as defined in\n * https://eips.ethereum.org/EIPS/eip-4626[ERC-4626].\n */\ninterface IERC4626 is IERC20, IERC20Metadata {\n    event Deposit(address indexed sender, address indexed owner, uint256 assets, uint256 shares);\n\n    event Withdraw(\n        address indexed sender,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /**\n     * @dev Returns the address of the underlying token used for the Vault for accounting, depositing, and withdrawing.\n     *\n     * - MUST be an ERC-20 token contract.\n     * - MUST NOT revert.\n     */\n    function asset() external view returns (address assetTokenAddress);\n\n    /**\n     * @dev Returns the total amount of the underlying asset that is managed by Vault.\n     *\n     * - SHOULD include any compounding that occurs from yield.\n     * - MUST be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT revert.\n     */\n    function totalAssets() external view returns (uint256 totalManagedAssets);\n\n    /**\n     * @dev Returns the amount of shares that the Vault would exchange for the amount of assets provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert.\n     *\n     * NOTE: This calculation MAY NOT reflect the per-user price-per-share, and instead should reflect the\n     * average-users price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n    function convertToShares(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Returns the amount of assets that the Vault would exchange for the amount of shares provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert.\n     *\n     * NOTE: This calculation MAY NOT reflect the per-user price-per-share, and instead should reflect the\n     * average-users price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n    function convertToAssets(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Returns the maximum amount of the underlying asset that can be deposited into the Vault for the receiver,\n     * through a deposit call.\n     *\n     * - MUST return a limited value if receiver is subject to some deposit limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of assets that may be deposited.\n     * - MUST NOT revert.\n     */\n    function maxDeposit(address receiver) external view returns (uint256 maxAssets);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their deposit at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of Vault shares that would be minted in a deposit\n     *   call in the same transaction. I.e. deposit should return the same or more shares as previewDeposit if called\n     *   in the same transaction.\n     * - MUST NOT account for deposit limits like those returned from maxDeposit and should always act as though the\n     *   deposit would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewDeposit SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n    function previewDeposit(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Mints shares Vault shares to receiver by depositing exactly amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   deposit execution, and are accounted for during deposit.\n     * - MUST revert if all of assets cannot be deposited (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vaults underlying asset token.\n     */\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\n\n    /**\n     * @dev Returns the maximum amount of the Vault shares that can be minted for the receiver, through a mint call.\n     * - MUST return a limited value if receiver is subject to some mint limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of shares that may be minted.\n     * - MUST NOT revert.\n     */\n    function maxMint(address receiver) external view returns (uint256 maxShares);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their mint at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of assets that would be deposited in a mint call\n     *   in the same transaction. I.e. mint should return the same or fewer assets as previewMint if called in the\n     *   same transaction.\n     * - MUST NOT account for mint limits like those returned from maxMint and should always act as though the mint\n     *   would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewMint SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by minting.\n     */\n    function previewMint(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the mint\n     *   execution, and are accounted for during mint.\n     * - MUST revert if all of shares cannot be minted (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vaults underlying asset token.\n     */\n    function mint(uint256 shares, address receiver) external returns (uint256 assets);\n\n    /**\n     * @dev Returns the maximum amount of the underlying asset that can be withdrawn from the owner balance in the\n     * Vault, through a withdraw call.\n     *\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n    function maxWithdraw(address owner) external view returns (uint256 maxAssets);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their withdrawal at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of Vault shares that would be burned in a withdraw\n     *   call in the same transaction. I.e. withdraw should return the same or fewer shares as previewWithdraw if\n     *   called\n     *   in the same transaction.\n     * - MUST NOT account for withdrawal limits like those returned from maxWithdraw and should always act as though\n     *   the withdrawal would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewWithdraw SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n    function previewWithdraw(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Burns shares from owner and sends exactly assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   withdraw execution, and are accounted for during withdraw.\n     * - MUST revert if all of assets cannot be withdrawn (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * Note that some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n    function withdraw(uint256 assets, address receiver, address owner) external returns (uint256 shares);\n\n    /**\n     * @dev Returns the maximum amount of Vault shares that can be redeemed from the owner balance in the Vault,\n     * through a redeem call.\n     *\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST return balanceOf(owner) if owner is not subject to any withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n    function maxRedeem(address owner) external view returns (uint256 maxShares);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their redeemption at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of assets that would be withdrawn in a redeem call\n     *   in the same transaction. I.e. redeem should return the same or more assets as previewRedeem if called in the\n     *   same transaction.\n     * - MUST NOT account for redemption limits like those returned from maxRedeem and should always act as though the\n     *   redemption would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewRedeem SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by redeeming.\n     */\n    function previewRedeem(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Burns exactly shares from owner and sends assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   redeem execution, and are accounted for during redeem.\n     * - MUST revert if all of shares cannot be redeemed (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * NOTE: some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n    function redeem(uint256 shares, address receiver, address owner) external returns (uint256 assets);\n}\n"
    },
    "lib/aave-umbrella/lib/aave-v3-origin/src/contracts/extensions/stata-token/interfaces/IERC20AaveLM.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\ninterface IERC20AaveLM {\n  struct UserRewardsData {\n    uint128 rewardsIndexOnLastInteraction;\n    uint128 unclaimedRewards;\n  }\n\n  struct RewardIndexCache {\n    bool isRegistered;\n    uint248 lastUpdatedIndex;\n  }\n\n  error ZeroIncentivesControllerIsForbidden();\n  error InvalidClaimer(address claimer);\n  error RewardNotInitialized(address reward);\n\n  event RewardTokenRegistered(address indexed reward, uint256 startIndex);\n\n  /**\n   * @notice Claims rewards from `INCENTIVES_CONTROLLER` and updates internal accounting of rewards.\n   * @param reward The reward to claim\n   * @return uint256 Amount collected\n   */\n  function collectAndUpdateRewards(address reward) external returns (uint256);\n\n  /**\n   * @notice Claim rewards on behalf of a user and send them to a receiver\n   * @dev Only callable by if sender is onBehalfOf or sender is approved claimer\n   * @param onBehalfOf The address to claim on behalf of\n   * @param receiver The address to receive the rewards\n   * @param rewards The rewards to claim\n   */\n  function claimRewardsOnBehalf(\n    address onBehalfOf,\n    address receiver,\n    address[] memory rewards\n  ) external;\n\n  /**\n   * @notice Claim rewards and send them to a receiver\n   * @param receiver The address to receive the rewards\n   * @param rewards The rewards to claim\n   */\n  function claimRewards(address receiver, address[] memory rewards) external;\n\n  /**\n   * @notice Claim rewards\n   * @param rewards The rewards to claim\n   */\n  function claimRewardsToSelf(address[] memory rewards) external;\n\n  /**\n   * @notice Get the total claimable rewards of the contract.\n   * @param reward The reward to claim\n   * @return uint256 The current balance + pending rewards from the `_incentivesController`\n   */\n  function getTotalClaimableRewards(address reward) external view returns (uint256);\n\n  /**\n   * @notice Get the total claimable rewards for a user in asset decimals\n   * @param user The address of the user\n   * @param reward The reward to claim\n   * @return uint256 The claimable amount of rewards in asset decimals\n   */\n  function getClaimableRewards(address user, address reward) external view returns (uint256);\n\n  /**\n   * @notice The unclaimed rewards for a user in asset decimals\n   * @param user The address of the user\n   * @param reward The reward to claim\n   * @return uint256 The unclaimed amount of rewards in asset decimals\n   */\n  function getUnclaimedRewards(address user, address reward) external view returns (uint256);\n\n  /**\n   * @notice The underlying asset reward index in RAY\n   * @param reward The reward to claim\n   * @return uint256 The underlying asset reward index in RAY\n   */\n  function getCurrentRewardsIndex(address reward) external view returns (uint256);\n\n  /**\n   * @notice Returns reference a/v token address used on INCENTIVES_CONTROLLER for tracking\n   * @return address of reference token\n   */\n  function getReferenceAsset() external view returns (address);\n\n  /**\n   * @notice The IERC20s that are currently rewarded to addresses of the vault via LM on incentivescontroller.\n   * @return IERC20 The IERC20s of the rewards.\n   */\n  function rewardTokens() external view returns (address[] memory);\n\n  /**\n   * @notice Fetches all rewardTokens from the incentivecontroller and registers the missing ones.\n   */\n  function refreshRewardTokens() external;\n\n  /**\n   * @notice Checks if the passed token is a registered reward.\n   * @param reward The reward to claim\n   * @return bool signaling if token is a registered reward.\n   */\n  function isRegisteredRewardToken(address reward) external view returns (bool);\n}\n"
    },
    "lib/aave-umbrella/lib/aave-v3-origin/src/contracts/interfaces/IPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IPoolAddressesProvider} from './IPoolAddressesProvider.sol';\nimport {DataTypes} from '../protocol/libraries/types/DataTypes.sol';\n\n/**\n * @title IPool\n * @author Aave\n * @notice Defines the basic interface for an Aave Pool.\n */\ninterface IPool {\n  /**\n   * @dev Emitted on mintUnbacked()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address initiating the supply\n   * @param onBehalfOf The beneficiary of the supplied assets, receiving the aTokens\n   * @param amount The amount of supplied assets\n   * @param referralCode The referral code used\n   */\n  event MintUnbacked(\n    address indexed reserve,\n    address user,\n    address indexed onBehalfOf,\n    uint256 amount,\n    uint16 indexed referralCode\n  );\n\n  /**\n   * @dev Emitted on backUnbacked()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param backer The address paying for the backing\n   * @param amount The amount added as backing\n   * @param fee The amount paid in fees\n   */\n  event BackUnbacked(address indexed reserve, address indexed backer, uint256 amount, uint256 fee);\n\n  /**\n   * @dev Emitted on supply()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address initiating the supply\n   * @param onBehalfOf The beneficiary of the supply, receiving the aTokens\n   * @param amount The amount supplied\n   * @param referralCode The referral code used\n   */\n  event Supply(\n    address indexed reserve,\n    address user,\n    address indexed onBehalfOf,\n    uint256 amount,\n    uint16 indexed referralCode\n  );\n\n  /**\n   * @dev Emitted on withdraw()\n   * @param reserve The address of the underlying asset being withdrawn\n   * @param user The address initiating the withdrawal, owner of aTokens\n   * @param to The address that will receive the underlying\n   * @param amount The amount to be withdrawn\n   */\n  event Withdraw(address indexed reserve, address indexed user, address indexed to, uint256 amount);\n\n  /**\n   * @dev Emitted on borrow() and flashLoan() when debt needs to be opened\n   * @param reserve The address of the underlying asset being borrowed\n   * @param user The address of the user initiating the borrow(), receiving the funds on borrow() or just\n   * initiator of the transaction on flashLoan()\n   * @param onBehalfOf The address that will be getting the debt\n   * @param amount The amount borrowed out\n   * @param interestRateMode The rate mode: 2 for Variable, 1 is deprecated (changed on v3.2.0)\n   * @param borrowRate The numeric rate at which the user has borrowed, expressed in ray\n   * @param referralCode The referral code used\n   */\n  event Borrow(\n    address indexed reserve,\n    address user,\n    address indexed onBehalfOf,\n    uint256 amount,\n    DataTypes.InterestRateMode interestRateMode,\n    uint256 borrowRate,\n    uint16 indexed referralCode\n  );\n\n  /**\n   * @dev Emitted on repay()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The beneficiary of the repayment, getting his debt reduced\n   * @param repayer The address of the user initiating the repay(), providing the funds\n   * @param amount The amount repaid\n   * @param useATokens True if the repayment is done using aTokens, `false` if done with underlying asset directly\n   */\n  event Repay(\n    address indexed reserve,\n    address indexed user,\n    address indexed repayer,\n    uint256 amount,\n    bool useATokens\n  );\n\n  /**\n   * @dev Emitted on borrow(), repay() and liquidationCall() when using isolated assets\n   * @param asset The address of the underlying asset of the reserve\n   * @param totalDebt The total isolation mode debt for the reserve\n   */\n  event IsolationModeTotalDebtUpdated(address indexed asset, uint256 totalDebt);\n\n  /**\n   * @dev Emitted when the user selects a certain asset category for eMode\n   * @param user The address of the user\n   * @param categoryId The category id\n   */\n  event UserEModeSet(address indexed user, uint8 categoryId);\n\n  /**\n   * @dev Emitted on setUserUseReserveAsCollateral()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user enabling the usage as collateral\n   */\n  event ReserveUsedAsCollateralEnabled(address indexed reserve, address indexed user);\n\n  /**\n   * @dev Emitted on setUserUseReserveAsCollateral()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user enabling the usage as collateral\n   */\n  event ReserveUsedAsCollateralDisabled(address indexed reserve, address indexed user);\n\n  /**\n   * @dev Emitted on flashLoan()\n   * @param target The address of the flash loan receiver contract\n   * @param initiator The address initiating the flash loan\n   * @param asset The address of the asset being flash borrowed\n   * @param amount The amount flash borrowed\n   * @param interestRateMode The flashloan mode: 0 for regular flashloan,\n   *        1 for Stable (Deprecated on v3.2.0), 2 for Variable\n   * @param premium The fee flash borrowed\n   * @param referralCode The referral code used\n   */\n  event FlashLoan(\n    address indexed target,\n    address initiator,\n    address indexed asset,\n    uint256 amount,\n    DataTypes.InterestRateMode interestRateMode,\n    uint256 premium,\n    uint16 indexed referralCode\n  );\n\n  /**\n   * @dev Emitted when a borrower is liquidated.\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n   * @param user The address of the borrower getting liquidated\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n   * @param liquidatedCollateralAmount The amount of collateral received by the liquidator\n   * @param liquidator The address of the liquidator\n   * @param receiveAToken True if the liquidators wants to receive the collateral aTokens, `false` if he wants\n   * to receive the underlying collateral asset directly\n   */\n  event LiquidationCall(\n    address indexed collateralAsset,\n    address indexed debtAsset,\n    address indexed user,\n    uint256 debtToCover,\n    uint256 liquidatedCollateralAmount,\n    address liquidator,\n    bool receiveAToken\n  );\n\n  /**\n   * @dev Emitted when the state of a reserve is updated.\n   * @param reserve The address of the underlying asset of the reserve\n   * @param liquidityRate The next liquidity rate\n   * @param stableBorrowRate The next stable borrow rate @note deprecated on v3.2.0\n   * @param variableBorrowRate The next variable borrow rate\n   * @param liquidityIndex The next liquidity index\n   * @param variableBorrowIndex The next variable borrow index\n   */\n  event ReserveDataUpdated(\n    address indexed reserve,\n    uint256 liquidityRate,\n    uint256 stableBorrowRate,\n    uint256 variableBorrowRate,\n    uint256 liquidityIndex,\n    uint256 variableBorrowIndex\n  );\n\n  /**\n   * @dev Emitted when the deficit of a reserve is covered.\n   * @param reserve The address of the underlying asset of the reserve\n   * @param caller The caller that triggered the DeficitCovered event\n   * @param amountCovered The amount of deficit covered\n   */\n  event DeficitCovered(address indexed reserve, address caller, uint256 amountCovered);\n\n  /**\n   * @dev Emitted when the protocol treasury receives minted aTokens from the accrued interest.\n   * @param reserve The address of the reserve\n   * @param amountMinted The amount minted to the treasury\n   */\n  event MintedToTreasury(address indexed reserve, uint256 amountMinted);\n\n  /**\n   * @dev Emitted when deficit is realized on a liquidation.\n   * @param user The user address where the bad debt will be burned\n   * @param debtAsset The address of the underlying borrowed asset to be burned\n   * @param amountCreated The amount of deficit created\n   */\n  event DeficitCreated(address indexed user, address indexed debtAsset, uint256 amountCreated);\n\n  /**\n   * @notice Mints an `amount` of aTokens to the `onBehalfOf`\n   * @param asset The address of the underlying asset to mint\n   * @param amount The amount to mint\n   * @param onBehalfOf The address that will receive the aTokens\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   */\n  function mintUnbacked(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external;\n\n  /**\n   * @notice Back the current unbacked underlying with `amount` and pay `fee`.\n   * @param asset The address of the underlying asset to back\n   * @param amount The amount to back\n   * @param fee The amount paid in fees\n   * @return The backed amount\n   */\n  function backUnbacked(address asset, uint256 amount, uint256 fee) external returns (uint256);\n\n  /**\n   * @notice Supplies an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\n   * - E.g. User supplies 100 USDC and gets in return 100 aUSDC\n   * @param asset The address of the underlying asset to supply\n   * @param amount The amount to be supplied\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n   *   is a different wallet\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   */\n  function supply(address asset, uint256 amount, address onBehalfOf, uint16 referralCode) external;\n\n  /**\n   * @notice Supply with transfer approval of asset to be supplied done via permit function\n   * see: https://eips.ethereum.org/EIPS/eip-2612 and https://eips.ethereum.org/EIPS/eip-713\n   * @param asset The address of the underlying asset to supply\n   * @param amount The amount to be supplied\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n   *   is a different wallet\n   * @param deadline The deadline timestamp that the permit is valid\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   * @param permitV The V parameter of ERC712 permit sig\n   * @param permitR The R parameter of ERC712 permit sig\n   * @param permitS The S parameter of ERC712 permit sig\n   */\n  function supplyWithPermit(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode,\n    uint256 deadline,\n    uint8 permitV,\n    bytes32 permitR,\n    bytes32 permitS\n  ) external;\n\n  /**\n   * @notice Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\n   * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\n   * @param asset The address of the underlying asset to withdraw\n   * @param amount The underlying amount to be withdrawn\n   *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\n   * @param to The address that will receive the underlying, same as msg.sender if the user\n   *   wants to receive it on his own wallet, or a different address if the beneficiary is a\n   *   different wallet\n   * @return The final amount withdrawn\n   */\n  function withdraw(address asset, uint256 amount, address to) external returns (uint256);\n\n  /**\n   * @notice Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower\n   * already supplied enough collateral, or he was given enough allowance by a credit delegator on the VariableDebtToken\n   * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet\n   *   and 100 variable debt tokens\n   * @param asset The address of the underlying asset to borrow\n   * @param amount The amount to be borrowed\n   * @param interestRateMode 2 for Variable, 1 is deprecated on v3.2.0\n   * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   * @param onBehalfOf The address of the user who will receive the debt. Should be the address of the borrower itself\n   * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator\n   * if he has been given credit delegation allowance\n   */\n  function borrow(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode,\n    uint16 referralCode,\n    address onBehalfOf\n  ) external;\n\n  /**\n   * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned\n   * - E.g. User repays 100 USDC, burning 100 variable debt tokens of the `onBehalfOf` address\n   * @param asset The address of the borrowed underlying asset previously borrowed\n   * @param amount The amount to repay\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n   * @param interestRateMode 2 for Variable, 1 is deprecated on v3.2.0\n   * @param onBehalfOf The address of the user who will get his debt reduced/removed. Should be the address of the\n   * user calling the function if he wants to reduce/remove his own debt, or the address of any other\n   * other borrower whose debt should be removed\n   * @return The final amount repaid\n   */\n  function repay(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode,\n    address onBehalfOf\n  ) external returns (uint256);\n\n  /**\n   * @notice Repay with transfer approval of asset to be repaid done via permit function\n   * see: https://eips.ethereum.org/EIPS/eip-2612 and https://eips.ethereum.org/EIPS/eip-713\n   * @param asset The address of the borrowed underlying asset previously borrowed\n   * @param amount The amount to repay\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n   * @param interestRateMode 2 for Variable, 1 is deprecated on v3.2.0\n   * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the\n   * user calling the function if he wants to reduce/remove his own debt, or the address of any other\n   * other borrower whose debt should be removed\n   * @param deadline The deadline timestamp that the permit is valid\n   * @param permitV The V parameter of ERC712 permit sig\n   * @param permitR The R parameter of ERC712 permit sig\n   * @param permitS The S parameter of ERC712 permit sig\n   * @return The final amount repaid\n   */\n  function repayWithPermit(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode,\n    address onBehalfOf,\n    uint256 deadline,\n    uint8 permitV,\n    bytes32 permitR,\n    bytes32 permitS\n  ) external returns (uint256);\n\n  /**\n   * @notice Repays a borrowed `amount` on a specific reserve using the reserve aTokens, burning the\n   * equivalent debt tokens\n   * - E.g. User repays 100 USDC using 100 aUSDC, burning 100 variable debt tokens\n   * @dev  Passing uint256.max as amount will clean up any residual aToken dust balance, if the user aToken\n   * balance is not enough to cover the whole debt\n   * @param asset The address of the borrowed underlying asset previously borrowed\n   * @param amount The amount to repay\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n   * @param interestRateMode DEPRECATED in v3.2.0\n   * @return The final amount repaid\n   */\n  function repayWithATokens(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode\n  ) external returns (uint256);\n\n  /**\n   * @notice Allows suppliers to enable/disable a specific supplied asset as collateral\n   * @param asset The address of the underlying asset supplied\n   * @param useAsCollateral True if the user wants to use the supply as collateral, false otherwise\n   */\n  function setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external;\n\n  /**\n   * @notice Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1\n   * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives\n   *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n   * @param user The address of the borrower getting liquidated\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n   * @param receiveAToken True if the liquidators wants to receive the collateral aTokens, `false` if he wants\n   * to receive the underlying collateral asset directly\n   */\n  function liquidationCall(\n    address collateralAsset,\n    address debtAsset,\n    address user,\n    uint256 debtToCover,\n    bool receiveAToken\n  ) external;\n\n  /**\n   * @notice Allows smartcontracts to access the liquidity of the pool within one transaction,\n   * as long as the amount taken plus a fee is returned.\n   * @dev IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept\n   * into consideration. For further details please visit https://docs.aave.com/developers/\n   * @param receiverAddress The address of the contract receiving the funds, implementing IFlashLoanReceiver interface\n   * @param assets The addresses of the assets being flash-borrowed\n   * @param amounts The amounts of the assets being flash-borrowed\n   * @param interestRateModes Types of the debt to open if the flash loan is not returned:\n   *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver\n   *   1 -> Deprecated on v3.2.0\n   *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n   * @param onBehalfOf The address  that will receive the debt in the case of using 2 on `modes`\n   * @param params Variadic packed params to pass to the receiver as extra information\n   * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   */\n  function flashLoan(\n    address receiverAddress,\n    address[] calldata assets,\n    uint256[] calldata amounts,\n    uint256[] calldata interestRateModes,\n    address onBehalfOf,\n    bytes calldata params,\n    uint16 referralCode\n  ) external;\n\n  /**\n   * @notice Allows smartcontracts to access the liquidity of the pool within one transaction,\n   * as long as the amount taken plus a fee is returned.\n   * @dev IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept\n   * into consideration. For further details please visit https://docs.aave.com/developers/\n   * @param receiverAddress The address of the contract receiving the funds, implementing IFlashLoanSimpleReceiver interface\n   * @param asset The address of the asset being flash-borrowed\n   * @param amount The amount of the asset being flash-borrowed\n   * @param params Variadic packed params to pass to the receiver as extra information\n   * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   */\n  function flashLoanSimple(\n    address receiverAddress,\n    address asset,\n    uint256 amount,\n    bytes calldata params,\n    uint16 referralCode\n  ) external;\n\n  /**\n   * @notice Returns the user account data across all the reserves\n   * @param user The address of the user\n   * @return totalCollateralBase The total collateral of the user in the base currency used by the price feed\n   * @return totalDebtBase The total debt of the user in the base currency used by the price feed\n   * @return availableBorrowsBase The borrowing power left of the user in the base currency used by the price feed\n   * @return currentLiquidationThreshold The liquidation threshold of the user\n   * @return ltv The loan to value of The user\n   * @return healthFactor The current health factor of the user\n   */\n  function getUserAccountData(\n    address user\n  )\n    external\n    view\n    returns (\n      uint256 totalCollateralBase,\n      uint256 totalDebtBase,\n      uint256 availableBorrowsBase,\n      uint256 currentLiquidationThreshold,\n      uint256 ltv,\n      uint256 healthFactor\n    );\n\n  /**\n   * @notice Initializes a reserve, activating it, assigning an aToken and debt tokens and an\n   * interest rate strategy\n   * @dev Only callable by the PoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param aTokenAddress The address of the aToken that will be assigned to the reserve\n   * @param variableDebtAddress The address of the VariableDebtToken that will be assigned to the reserve\n   * @param interestRateStrategyAddress The address of the interest rate strategy contract\n   */\n  function initReserve(\n    address asset,\n    address aTokenAddress,\n    address variableDebtAddress,\n    address interestRateStrategyAddress\n  ) external;\n\n  /**\n   * @notice Drop a reserve\n   * @dev Only callable by the PoolConfigurator contract\n   * @dev Does not reset eMode flags, which must be considered when reusing the same reserve id for a different reserve.\n   * @param asset The address of the underlying asset of the reserve\n   */\n  function dropReserve(address asset) external;\n\n  /**\n   * @notice Updates the address of the interest rate strategy contract\n   * @dev Only callable by the PoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param rateStrategyAddress The address of the interest rate strategy contract\n   */\n  function setReserveInterestRateStrategyAddress(\n    address asset,\n    address rateStrategyAddress\n  ) external;\n\n  /**\n   * @notice Accumulates interest to all indexes of the reserve\n   * @dev Only callable by the PoolConfigurator contract\n   * @dev To be used when required by the configurator, for example when updating interest rates strategy data\n   * @param asset The address of the underlying asset of the reserve\n   */\n  function syncIndexesState(address asset) external;\n\n  /**\n   * @notice Updates interest rates on the reserve data\n   * @dev Only callable by the PoolConfigurator contract\n   * @dev To be used when required by the configurator, for example when updating interest rates strategy data\n   * @param asset The address of the underlying asset of the reserve\n   */\n  function syncRatesState(address asset) external;\n\n  /**\n   * @notice Sets the configuration bitmap of the reserve as a whole\n   * @dev Only callable by the PoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param configuration The new configuration bitmap\n   */\n  function setConfiguration(\n    address asset,\n    DataTypes.ReserveConfigurationMap calldata configuration\n  ) external;\n\n  /**\n   * @notice Returns the configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The configuration of the reserve\n   */\n  function getConfiguration(\n    address asset\n  ) external view returns (DataTypes.ReserveConfigurationMap memory);\n\n  /**\n   * @notice Returns the configuration of the user across all the reserves\n   * @param user The user address\n   * @return The configuration of the user\n   */\n  function getUserConfiguration(\n    address user\n  ) external view returns (DataTypes.UserConfigurationMap memory);\n\n  /**\n   * @notice Returns the normalized income of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve's normalized income\n   */\n  function getReserveNormalizedIncome(address asset) external view returns (uint256);\n\n  /**\n   * @notice Returns the normalized variable debt per unit of asset\n   * @dev WARNING: This function is intended to be used primarily by the protocol itself to get a\n   * \"dynamic\" variable index based on time, current stored index and virtual rate at the current\n   * moment (approx. a borrower would get if opening a position). This means that is always used in\n   * combination with variable debt supply/balances.\n   * If using this function externally, consider that is possible to have an increasing normalized\n   * variable debt that is not equivalent to how the variable debt index would be updated in storage\n   * (e.g. only updates with non-zero variable debt supply)\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve normalized variable debt\n   */\n  function getReserveNormalizedVariableDebt(address asset) external view returns (uint256);\n\n  /**\n   * @notice Returns the state and configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The state and configuration data of the reserve\n   */\n  function getReserveData(address asset) external view returns (DataTypes.ReserveDataLegacy memory);\n\n  /**\n   * @notice Returns the virtual underlying balance of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve virtual underlying balance\n   */\n  function getVirtualUnderlyingBalance(address asset) external view returns (uint128);\n\n  /**\n   * @notice Validates and finalizes an aToken transfer\n   * @dev Only callable by the overlying aToken of the `asset`\n   * @param asset The address of the underlying asset of the aToken\n   * @param from The user from which the aTokens are transferred\n   * @param to The user receiving the aTokens\n   * @param amount The amount being transferred/withdrawn\n   * @param balanceFromBefore The aToken balance of the `from` user before the transfer\n   * @param balanceToBefore The aToken balance of the `to` user before the transfer\n   */\n  function finalizeTransfer(\n    address asset,\n    address from,\n    address to,\n    uint256 amount,\n    uint256 balanceFromBefore,\n    uint256 balanceToBefore\n  ) external;\n\n  /**\n   * @notice Returns the list of the underlying assets of all the initialized reserves\n   * @dev It does not include dropped reserves\n   * @return The addresses of the underlying assets of the initialized reserves\n   */\n  function getReservesList() external view returns (address[] memory);\n\n  /**\n   * @notice Returns the number of initialized reserves\n   * @dev It includes dropped reserves\n   * @return The count\n   */\n  function getReservesCount() external view returns (uint256);\n\n  /**\n   * @notice Returns the address of the underlying asset of a reserve by the reserve id as stored in the DataTypes.ReserveData struct\n   * @param id The id of the reserve as stored in the DataTypes.ReserveData struct\n   * @return The address of the reserve associated with id\n   */\n  function getReserveAddressById(uint16 id) external view returns (address);\n\n  /**\n   * @notice Returns the PoolAddressesProvider connected to this contract\n   * @return The address of the PoolAddressesProvider\n   */\n  function ADDRESSES_PROVIDER() external view returns (IPoolAddressesProvider);\n\n  /**\n   * @notice Updates the protocol fee on the bridging\n   * @param bridgeProtocolFee The part of the premium sent to the protocol treasury\n   */\n  function updateBridgeProtocolFee(uint256 bridgeProtocolFee) external;\n\n  /**\n   * @notice Updates flash loan premiums. Flash loan premium consists of two parts:\n   * - A part is sent to aToken holders as extra, one time accumulated interest\n   * - A part is collected by the protocol treasury\n   * @dev The total premium is calculated on the total borrowed amount\n   * @dev The premium to protocol is calculated on the total premium, being a percentage of `flashLoanPremiumTotal`\n   * @dev Only callable by the PoolConfigurator contract\n   * @param flashLoanPremiumTotal The total premium, expressed in bps\n   * @param flashLoanPremiumToProtocol The part of the premium sent to the protocol treasury, expressed in bps\n   */\n  function updateFlashloanPremiums(\n    uint128 flashLoanPremiumTotal,\n    uint128 flashLoanPremiumToProtocol\n  ) external;\n\n  /**\n   * @notice Configures a new or alters an existing collateral configuration of an eMode.\n   * @dev In eMode, the protocol allows very high borrowing power to borrow assets of the same category.\n   * The category 0 is reserved as it's the default for volatile assets\n   * @param id The id of the category\n   * @param config The configuration of the category\n   */\n  function configureEModeCategory(\n    uint8 id,\n    DataTypes.EModeCategoryBaseConfiguration memory config\n  ) external;\n\n  /**\n   * @notice Replaces the current eMode collateralBitmap.\n   * @param id The id of the category\n   * @param collateralBitmap The collateralBitmap of the category\n   */\n  function configureEModeCategoryCollateralBitmap(uint8 id, uint128 collateralBitmap) external;\n\n  /**\n   * @notice Replaces the current eMode borrowableBitmap.\n   * @param id The id of the category\n   * @param borrowableBitmap The borrowableBitmap of the category\n   */\n  function configureEModeCategoryBorrowableBitmap(uint8 id, uint128 borrowableBitmap) external;\n\n  /**\n   * @notice Returns the data of an eMode category\n   * @dev DEPRECATED use independent getters instead\n   * @param id The id of the category\n   * @return The configuration data of the category\n   */\n  function getEModeCategoryData(\n    uint8 id\n  ) external view returns (DataTypes.EModeCategoryLegacy memory);\n\n  /**\n   * @notice Returns the label of an eMode category\n   * @param id The id of the category\n   * @return The label of the category\n   */\n  function getEModeCategoryLabel(uint8 id) external view returns (string memory);\n\n  /**\n   * @notice Returns the collateral config of an eMode category\n   * @param id The id of the category\n   * @return The ltv,lt,lb of the category\n   */\n  function getEModeCategoryCollateralConfig(\n    uint8 id\n  ) external view returns (DataTypes.CollateralConfig memory);\n\n  /**\n   * @notice Returns the collateralBitmap of an eMode category\n   * @param id The id of the category\n   * @return The collateralBitmap of the category\n   */\n  function getEModeCategoryCollateralBitmap(uint8 id) external view returns (uint128);\n\n  /**\n   * @notice Returns the borrowableBitmap of an eMode category\n   * @param id The id of the category\n   * @return The borrowableBitmap of the category\n   */\n  function getEModeCategoryBorrowableBitmap(uint8 id) external view returns (uint128);\n\n  /**\n   * @notice Allows a user to use the protocol in eMode\n   * @param categoryId The id of the category\n   */\n  function setUserEMode(uint8 categoryId) external;\n\n  /**\n   * @notice Returns the eMode the user is using\n   * @param user The address of the user\n   * @return The eMode id\n   */\n  function getUserEMode(address user) external view returns (uint256);\n\n  /**\n   * @notice Resets the isolation mode total debt of the given asset to zero\n   * @dev It requires the given asset has zero debt ceiling\n   * @param asset The address of the underlying asset to reset the isolationModeTotalDebt\n   */\n  function resetIsolationModeTotalDebt(address asset) external;\n\n  /**\n   * @notice Sets the liquidation grace period of the given asset\n   * @dev To enable a liquidation grace period, a timestamp in the future should be set,\n   *      To disable a liquidation grace period, any timestamp in the past works, like 0\n   * @param asset The address of the underlying asset to set the liquidationGracePeriod\n   * @param until Timestamp when the liquidation grace period will end\n   **/\n  function setLiquidationGracePeriod(address asset, uint40 until) external;\n\n  /**\n   * @notice Returns the liquidation grace period of the given asset\n   * @param asset The address of the underlying asset\n   * @return Timestamp when the liquidation grace period will end\n   **/\n  function getLiquidationGracePeriod(address asset) external view returns (uint40);\n\n  /**\n   * @notice Returns the total fee on flash loans\n   * @return The total fee on flashloans\n   */\n  function FLASHLOAN_PREMIUM_TOTAL() external view returns (uint128);\n\n  /**\n   * @notice Returns the part of the bridge fees sent to protocol\n   * @return The bridge fee sent to the protocol treasury\n   */\n  function BRIDGE_PROTOCOL_FEE() external view returns (uint256);\n\n  /**\n   * @notice Returns the part of the flashloan fees sent to protocol\n   * @return The flashloan fee sent to the protocol treasury\n   */\n  function FLASHLOAN_PREMIUM_TO_PROTOCOL() external view returns (uint128);\n\n  /**\n   * @notice Returns the maximum number of reserves supported to be listed in this Pool\n   * @return The maximum number of reserves supported\n   */\n  function MAX_NUMBER_RESERVES() external view returns (uint16);\n\n  /**\n   * @notice Mints the assets accrued through the reserve factor to the treasury in the form of aTokens\n   * @param assets The list of reserves for which the minting needs to be executed\n   */\n  function mintToTreasury(address[] calldata assets) external;\n\n  /**\n   * @notice Rescue and transfer tokens locked in this contract\n   * @param token The address of the token\n   * @param to The address of the recipient\n   * @param amount The amount of token to transfer\n   */\n  function rescueTokens(address token, address to, uint256 amount) external;\n\n  /**\n   * @notice Supplies an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\n   * - E.g. User supplies 100 USDC and gets in return 100 aUSDC\n   * @dev Deprecated: Use the `supply` function instead\n   * @param asset The address of the underlying asset to supply\n   * @param amount The amount to be supplied\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n   *   is a different wallet\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   */\n  function deposit(address asset, uint256 amount, address onBehalfOf, uint16 referralCode) external;\n\n  /**\n   * @notice It covers the deficit of a specified reserve by burning:\n   * - the equivalent aToken `amount` for assets with virtual accounting enabled\n   * - the equivalent `amount` of underlying for assets with virtual accounting disabled (e.g. GHO)\n   * @dev The deficit of a reserve can occur due to situations where borrowed assets are not repaid, leading to bad debt.\n   * @param asset The address of the underlying asset to cover the deficit.\n   * @param amount The amount to be covered, in aToken or underlying on non-virtual accounted assets\n   */\n  function eliminateReserveDeficit(address asset, uint256 amount) external;\n\n  /**\n   * @notice Returns the current deficit of a reserve.\n   * @param asset The address of the underlying asset of the reserve\n   * @return The current deficit of the reserve\n   */\n  function getReserveDeficit(address asset) external view returns (uint256);\n\n  /**\n   * @notice Returns the aToken address of a reserve.\n   * @param asset The address of the underlying asset of the reserve\n   * @return The address of the aToken\n   */\n  function getReserveAToken(address asset) external view returns (address);\n\n  /**\n   * @notice Returns the variableDebtToken address of a reserve.\n   * @param asset The address of the underlying asset of the reserve\n   * @return The address of the variableDebtToken\n   */\n  function getReserveVariableDebtToken(address asset) external view returns (address);\n\n  /**\n   * @notice Gets the address of the external FlashLoanLogic\n   */\n  function getFlashLoanLogic() external view returns (address);\n\n  /**\n   * @notice Gets the address of the external BorrowLogic\n   */\n  function getBorrowLogic() external view returns (address);\n\n  /**\n   * @notice Gets the address of the external BridgeLogic\n   */\n  function getBridgeLogic() external view returns (address);\n\n  /**\n   * @notice Gets the address of the external EModeLogic\n   */\n  function getEModeLogic() external view returns (address);\n\n  /**\n   * @notice Gets the address of the external LiquidationLogic\n   */\n  function getLiquidationLogic() external view returns (address);\n\n  /**\n   * @notice Gets the address of the external PoolLogic\n   */\n  function getPoolLogic() external view returns (address);\n\n  /**\n   * @notice Gets the address of the external SupplyLogic\n   */\n  function getSupplyLogic() external view returns (address);\n}\n"
    },
    "lib/aave-umbrella/src/contracts/rewards/interfaces/IRewardsDistributor.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {IRewardsStructs} from './IRewardsStructs.sol';\n\ninterface IRewardsDistributor is IRewardsStructs {\n  /**\n   * @notice Event is emitted when a `user` or admin installs/disables `claimer` for claiming user rewards.\n   * @param user Address of the `user`\n   * @param claimer Address of the `claimer` to install/disable\n   * @param caller Address of the `msg.sender` who changes claimer\n   * @param flag Flag responsible for setting/disabling `claimer`\n   */\n  event ClaimerSet(\n    address indexed user,\n    address indexed claimer,\n    address indexed caller,\n    bool flag\n  );\n\n  /**\n   * @dev Attempted to use signature with expired deadline.\n   */\n  error ExpiredSignature(uint256 deadline);\n\n  /**\n   * @dev Mismatched signature.\n   */\n  error InvalidSigner(address signer, address owner);\n\n  /**\n   * @dev Attempted to claim `reward` without authorization.\n   */\n  error ClaimerNotAuthorized(address claimer, address user);\n\n  /**\n   * @dev Attempted to claim rewards for assets while arrays lengths don't match.\n   */\n  error LengthsDontMatch();\n\n  /**\n   * @dev Attempted to set zero address.\n   */\n  error ZeroAddress();\n\n  // DEFAULT_ADMIN_ROLE\n  /////////////////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @notice Installs/disables `claimer` for claiming `user` rewards.\n   * @param user Address of the `user`\n   * @param claimer Address of the `claimer` to install/disable\n   * @param flag Flag responsible for setting/disabling `claimer`\n   */\n  function setClaimer(address user, address claimer, bool flag) external;\n\n  /////////////////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @notice Installs/disables `claimer` for claiming `msg.sender` rewards.\n   * @param claimer Address of the `claimer` to install/disable\n   * @param flag Flag responsible for setting/disabling `claimer`\n   */\n  function setClaimer(address claimer, bool flag) external;\n\n  /**\n   * @notice Claims all existing `rewards` for a certain `asset` on behalf of `msg.sender`.\n   * Makes an update and calculates new `index` and `accrued` `rewards` before claim.\n   * @dev Always claims all `rewards`.\n   * @param asset Address of the `asset` whose `rewards` should be claimed\n   * @param receiver Address of the funds receiver\n   * @return rewards Array containing the addresses of all `reward` tokens claimed\n   * @return amounts Array containing the corresponding `amounts` of each `reward` claimed\n   */\n  function claimAllRewards(\n    address asset,\n    address receiver\n  ) external returns (address[] memory rewards, uint256[] memory amounts);\n\n  /**\n   * @notice Claims all existing `rewards` on behalf of `user` for a certain `asset` by `msg.sender`.\n   * Makes an update and calculates new `index` and `accrued` `rewards` before claim.\n   * @dev Always claims all `rewards`.\n   * @param asset Address of the `asset` whose `rewards` should be claimed\n   * @param user Address of user, which accrued `rewards` should be claimed\n   * @param receiver Address of the funds receiver\n   * @return rewards Array containing the addresses of all `reward` tokens claimed\n   * @return amounts Array containing the corresponding `amounts` of each `reward` claimed\n   */\n  function claimAllRewardsOnBehalf(\n    address asset,\n    address user,\n    address receiver\n  ) external returns (address[] memory rewards, uint256[] memory amounts);\n\n  /**\n   * @notice Claims all existing `rewards` on behalf of `user` for a certain `asset` using signature.\n   * Makes an update and calculates new `index` and `accrued` `rewards` before claim.\n   * @dev Always claims all `rewards`.\n   * @param asset Address of the `asset` whose `rewards` should be claimed\n   * @param user Address of user, which accrued `rewards` should be claimed\n   * @param receiver Address of the funds receiver\n   * @param deadline Signature deadline for claiming\n   * @param sig Signature parameters\n   * @return rewards Array containing the addresses of all `reward` tokens claimed\n   * @return amounts Array containing the corresponding `amounts` of each `reward` claimed\n   */\n  function claimAllRewardsPermit(\n    address asset,\n    address user,\n    address receiver,\n    uint256 deadline,\n    SignatureParams calldata sig\n  ) external returns (address[] memory rewards, uint256[] memory amounts);\n\n  /**\n   * @notice Claims selected `rewards` of `msg.sender` for a certain `asset`.\n   * Makes an update and calculates new `index` and `accrued` `rewards` before claim.\n   * @param asset Address of the `asset` whose `rewards` should be claimed\n   * @param rewards Array of `reward` addresses, which should be claimed\n   * @param receiver Address of the funds receiver\n   * @return amounts Array containing the corresponding `amounts` of each `reward` claimed\n   */\n  function claimSelectedRewards(\n    address asset,\n    address[] calldata rewards,\n    address receiver\n  ) external returns (uint256[] memory amounts);\n\n  /**\n   * @notice Claims selected `rewards` on behalf of `user` for a certain `asset` by `msg.sender`.\n   * Makes an update and calculates new `index` and `accrued` `rewards` before claim.\n   * @param asset Address of the `asset` whose `rewards` should be claimed\n   * @param rewards Array of `reward` addresses, which should be claimed\n   * @param user Address of user, which accrued `rewards` should be claimed\n   * @param receiver Address of the funds receiver\n   * @return amounts Array containing the corresponding `amounts` of each `reward` claimed\n   */\n  function claimSelectedRewardsOnBehalf(\n    address asset,\n    address[] calldata rewards,\n    address user,\n    address receiver\n  ) external returns (uint256[] memory amounts);\n\n  /**\n   * @notice Claims selected `rewards` on behalf of `user` for a certain `asset` using signature.\n   * Makes an update and calculates new `index` and `accrued` `rewards` before claim.\n   * @param asset Address of the `asset` whose `rewards` should be claimed\n   * @param rewards Array of `reward` addresses, which should be claimed\n   * @param user Address of user, which accrued `rewards` should be claimed\n   * @param receiver Address of the funds receiver\n   * @param deadline Signature deadline for claiming\n   * @param sig Signature parameters\n   * @return amounts Array containing the corresponding `amounts` of each `reward` claimed\n   */\n  function claimSelectedRewardsPermit(\n    address asset,\n    address[] calldata rewards,\n    address user,\n    address receiver,\n    uint256 deadline,\n    SignatureParams calldata sig\n  ) external returns (uint256[] memory amounts);\n\n  /**\n   * @notice Claims all existing `rewards` of `msg.sender` across multiple `assets`.\n   * Makes an update and calculates new `index` and `accrued` `rewards` before claim.\n   * @dev Always claims all `rewards`.\n   * @param assets Array of addresses representing the `assets`, whose `rewards` should be claimed\n   * @param receiver Address of the funds receiver\n   * @return rewards Two-dimensional array where each inner array contains the addresses of `reward` tokens for a specific `asset`\n   * @return amounts Two-dimensional array where each inner array contains the amounts of each `reward` claimed for a specific `asset`\n   */\n  function claimAllRewards(\n    address[] calldata assets,\n    address receiver\n  ) external returns (address[][] memory rewards, uint256[][] memory amounts);\n\n  /**\n   * @notice Claims all existing `rewards` on behalf of `user` across multiple `assets` by `msg.sender`.\n   * Makes an update and calculates new `index` and `accrued` `rewards` before claim.\n   * @dev Always claims all `rewards`.\n   * @param assets Array of addresses representing the `assets`, whose `rewards` should be claimed\n   * @param user Address of user, which accrued `rewards` should be claimed\n   * @param receiver Address of the funds receiver\n   * @return rewards Two-dimensional array where each inner array contains the addresses of `reward` tokens for a specific `asset`\n   * @return amounts Two-dimensional array where each inner array contains the amounts of each `reward` claimed for a specific `asset`\n   */\n  function claimAllRewardsOnBehalf(\n    address[] calldata assets,\n    address user,\n    address receiver\n  ) external returns (address[][] memory rewards, uint256[][] memory amounts);\n\n  /**\n   * @notice Claims selected `rewards` of `msg.sender` across multiple `assets`.\n   * Makes an update and calculates new `index` and `accrued` `rewards` before claim.\n   * @param assets Array of addresses representing the `assets`, whose `rewards` should be claimed\n   * @param rewards Two-dimensional array where each inner array contains the addresses of `rewards` for a specific `asset`\n   * @param receiver Address of the funds receiver\n   * @return amounts Two-dimensional array where each inner array contains the amounts of each `reward` claimed for a specific `asset`\n   */\n  function claimSelectedRewards(\n    address[] calldata assets,\n    address[][] calldata rewards,\n    address receiver\n  ) external returns (uint256[][] memory);\n\n  /**\n   * @notice Claims selected `rewards` on behalf of `user` across multiple `assets` by `msg.sender`.\n   * Makes an update and calculates new `index` and `accrued` `rewards` before claim.\n   * @param assets Array of addresses representing the `assets`, whose `rewards` should be claimed\n   * @param rewards Two-dimensional array where each inner array contains the addresses of `rewards` for a specific `asset`\n   * @param user Address of user, which accrued `rewards` should be claimed\n   * @param receiver Address of the funds receiver\n   * @return amounts Two-dimensional array where each inner array contains the amounts of each `reward` claimed for a specific `asset`\n   */\n  function claimSelectedRewardsOnBehalf(\n    address[] calldata assets,\n    address[][] calldata rewards,\n    address user,\n    address receiver\n  ) external returns (uint256[][] memory);\n}\n"
    },
    "lib/aave-umbrella/lib/aave-v3-origin/lib/solidity-utils/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../token/ERC20/IERC20.sol\";\n"
    },
    "lib/aave-umbrella/lib/aave-v3-origin/lib/solidity-utils/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../utils/introspection/IERC165.sol\";\n"
    },
    "lib/aave-umbrella/lib/aave-v3-origin/lib/solidity-utils/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/utils/Errors.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Errors.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of common custom errors used in multiple contracts\n *\n * IMPORTANT: Backwards compatibility is not guaranteed in future versions of the library.\n * It is recommended to avoid relying on the error API for critical functionality.\n *\n * _Available since v5.1._\n */\nlibrary Errors {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error InsufficientBalance(uint256 balance, uint256 needed);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedCall();\n\n    /**\n     * @dev The deployment failed.\n     */\n    error FailedDeployment();\n\n    /**\n     * @dev A necessary precompile is missing.\n     */\n    error MissingPrecompile(address);\n}\n"
    },
    "lib/aave-umbrella/lib/aave-v3-origin/lib/solidity-utils/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC-20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "lib/aave-umbrella/lib/aave-v3-origin/src/contracts/interfaces/IPoolAddressesProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title IPoolAddressesProvider\n * @author Aave\n * @notice Defines the basic interface for a Pool Addresses Provider.\n */\ninterface IPoolAddressesProvider {\n  /**\n   * @dev Emitted when the market identifier is updated.\n   * @param oldMarketId The old id of the market\n   * @param newMarketId The new id of the market\n   */\n  event MarketIdSet(string indexed oldMarketId, string indexed newMarketId);\n\n  /**\n   * @dev Emitted when the pool is updated.\n   * @param oldAddress The old address of the Pool\n   * @param newAddress The new address of the Pool\n   */\n  event PoolUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the pool configurator is updated.\n   * @param oldAddress The old address of the PoolConfigurator\n   * @param newAddress The new address of the PoolConfigurator\n   */\n  event PoolConfiguratorUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the price oracle is updated.\n   * @param oldAddress The old address of the PriceOracle\n   * @param newAddress The new address of the PriceOracle\n   */\n  event PriceOracleUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the ACL manager is updated.\n   * @param oldAddress The old address of the ACLManager\n   * @param newAddress The new address of the ACLManager\n   */\n  event ACLManagerUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the ACL admin is updated.\n   * @param oldAddress The old address of the ACLAdmin\n   * @param newAddress The new address of the ACLAdmin\n   */\n  event ACLAdminUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the price oracle sentinel is updated.\n   * @param oldAddress The old address of the PriceOracleSentinel\n   * @param newAddress The new address of the PriceOracleSentinel\n   */\n  event PriceOracleSentinelUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the pool data provider is updated.\n   * @param oldAddress The old address of the PoolDataProvider\n   * @param newAddress The new address of the PoolDataProvider\n   */\n  event PoolDataProviderUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when a new proxy is created.\n   * @param id The identifier of the proxy\n   * @param proxyAddress The address of the created proxy contract\n   * @param implementationAddress The address of the implementation contract\n   */\n  event ProxyCreated(\n    bytes32 indexed id,\n    address indexed proxyAddress,\n    address indexed implementationAddress\n  );\n\n  /**\n   * @dev Emitted when a new non-proxied contract address is registered.\n   * @param id The identifier of the contract\n   * @param oldAddress The address of the old contract\n   * @param newAddress The address of the new contract\n   */\n  event AddressSet(bytes32 indexed id, address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the implementation of the proxy registered with id is updated\n   * @param id The identifier of the contract\n   * @param proxyAddress The address of the proxy contract\n   * @param oldImplementationAddress The address of the old implementation contract\n   * @param newImplementationAddress The address of the new implementation contract\n   */\n  event AddressSetAsProxy(\n    bytes32 indexed id,\n    address indexed proxyAddress,\n    address oldImplementationAddress,\n    address indexed newImplementationAddress\n  );\n\n  /**\n   * @notice Returns the id of the Aave market to which this contract points to.\n   * @return The market id\n   */\n  function getMarketId() external view returns (string memory);\n\n  /**\n   * @notice Associates an id with a specific PoolAddressesProvider.\n   * @dev This can be used to create an onchain registry of PoolAddressesProviders to\n   * identify and validate multiple Aave markets.\n   * @param newMarketId The market id\n   */\n  function setMarketId(string calldata newMarketId) external;\n\n  /**\n   * @notice Returns an address by its identifier.\n   * @dev The returned address might be an EOA or a contract, potentially proxied\n   * @dev It returns ZERO if there is no registered address with the given id\n   * @param id The id\n   * @return The address of the registered for the specified id\n   */\n  function getAddress(bytes32 id) external view returns (address);\n\n  /**\n   * @notice General function to update the implementation of a proxy registered with\n   * certain `id`. If there is no proxy registered, it will instantiate one and\n   * set as implementation the `newImplementationAddress`.\n   * @dev IMPORTANT Use this function carefully, only for ids that don't have an explicit\n   * setter function, in order to avoid unexpected consequences\n   * @param id The id\n   * @param newImplementationAddress The address of the new implementation\n   */\n  function setAddressAsProxy(bytes32 id, address newImplementationAddress) external;\n\n  /**\n   * @notice Sets an address for an id replacing the address saved in the addresses map.\n   * @dev IMPORTANT Use this function carefully, as it will do a hard replacement\n   * @param id The id\n   * @param newAddress The address to set\n   */\n  function setAddress(bytes32 id, address newAddress) external;\n\n  /**\n   * @notice Returns the address of the Pool proxy.\n   * @return The Pool proxy address\n   */\n  function getPool() external view returns (address);\n\n  /**\n   * @notice Updates the implementation of the Pool, or creates a proxy\n   * setting the new `pool` implementation when the function is called for the first time.\n   * @param newPoolImpl The new Pool implementation\n   */\n  function setPoolImpl(address newPoolImpl) external;\n\n  /**\n   * @notice Returns the address of the PoolConfigurator proxy.\n   * @return The PoolConfigurator proxy address\n   */\n  function getPoolConfigurator() external view returns (address);\n\n  /**\n   * @notice Updates the implementation of the PoolConfigurator, or creates a proxy\n   * setting the new `PoolConfigurator` implementation when the function is called for the first time.\n   * @param newPoolConfiguratorImpl The new PoolConfigurator implementation\n   */\n  function setPoolConfiguratorImpl(address newPoolConfiguratorImpl) external;\n\n  /**\n   * @notice Returns the address of the price oracle.\n   * @return The address of the PriceOracle\n   */\n  function getPriceOracle() external view returns (address);\n\n  /**\n   * @notice Updates the address of the price oracle.\n   * @param newPriceOracle The address of the new PriceOracle\n   */\n  function setPriceOracle(address newPriceOracle) external;\n\n  /**\n   * @notice Returns the address of the ACL manager.\n   * @return The address of the ACLManager\n   */\n  function getACLManager() external view returns (address);\n\n  /**\n   * @notice Updates the address of the ACL manager.\n   * @param newAclManager The address of the new ACLManager\n   */\n  function setACLManager(address newAclManager) external;\n\n  /**\n   * @notice Returns the address of the ACL admin.\n   * @return The address of the ACL admin\n   */\n  function getACLAdmin() external view returns (address);\n\n  /**\n   * @notice Updates the address of the ACL admin.\n   * @param newAclAdmin The address of the new ACL admin\n   */\n  function setACLAdmin(address newAclAdmin) external;\n\n  /**\n   * @notice Returns the address of the price oracle sentinel.\n   * @return The address of the PriceOracleSentinel\n   */\n  function getPriceOracleSentinel() external view returns (address);\n\n  /**\n   * @notice Updates the address of the price oracle sentinel.\n   * @param newPriceOracleSentinel The address of the new PriceOracleSentinel\n   */\n  function setPriceOracleSentinel(address newPriceOracleSentinel) external;\n\n  /**\n   * @notice Returns the address of the data provider.\n   * @return The address of the DataProvider\n   */\n  function getPoolDataProvider() external view returns (address);\n\n  /**\n   * @notice Updates the address of the data provider.\n   * @param newDataProvider The address of the new DataProvider\n   */\n  function setPoolDataProvider(address newDataProvider) external;\n}\n"
    },
    "lib/aave-umbrella/lib/aave-v3-origin/src/contracts/protocol/libraries/types/DataTypes.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nlibrary DataTypes {\n  /**\n   * This exists specifically to maintain the `getReserveData()` interface, since the new, internal\n   * `ReserveData` struct includes the reserve's `virtualUnderlyingBalance`.\n   */\n  struct ReserveDataLegacy {\n    //stores the reserve configuration\n    ReserveConfigurationMap configuration;\n    //the liquidity index. Expressed in ray\n    uint128 liquidityIndex;\n    //the current supply rate. Expressed in ray\n    uint128 currentLiquidityRate;\n    //variable borrow index. Expressed in ray\n    uint128 variableBorrowIndex;\n    //the current variable borrow rate. Expressed in ray\n    uint128 currentVariableBorrowRate;\n    // DEPRECATED on v3.2.0\n    uint128 currentStableBorrowRate;\n    //timestamp of last update\n    uint40 lastUpdateTimestamp;\n    //the id of the reserve. Represents the position in the list of the active reserves\n    uint16 id;\n    //aToken address\n    address aTokenAddress;\n    // DEPRECATED on v3.2.0\n    address stableDebtTokenAddress;\n    //variableDebtToken address\n    address variableDebtTokenAddress;\n    //address of the interest rate strategy\n    address interestRateStrategyAddress;\n    //the current treasury balance, scaled\n    uint128 accruedToTreasury;\n    //the outstanding unbacked aTokens minted through the bridging feature\n    uint128 unbacked;\n    //the outstanding debt borrowed against this asset in isolation mode\n    uint128 isolationModeTotalDebt;\n  }\n\n  struct ReserveData {\n    //stores the reserve configuration\n    ReserveConfigurationMap configuration;\n    //the liquidity index. Expressed in ray\n    uint128 liquidityIndex;\n    //the current supply rate. Expressed in ray\n    uint128 currentLiquidityRate;\n    //variable borrow index. Expressed in ray\n    uint128 variableBorrowIndex;\n    //the current variable borrow rate. Expressed in ray\n    uint128 currentVariableBorrowRate;\n    /// @notice reused `__deprecatedStableBorrowRate` storage from pre 3.2\n    // the current accumulate deficit in underlying tokens\n    uint128 deficit;\n    //timestamp of last update\n    uint40 lastUpdateTimestamp;\n    //the id of the reserve. Represents the position in the list of the active reserves\n    uint16 id;\n    //timestamp until when liquidations are not allowed on the reserve, if set to past liquidations will be allowed\n    uint40 liquidationGracePeriodUntil;\n    //aToken address\n    address aTokenAddress;\n    // DEPRECATED on v3.2.0\n    address __deprecatedStableDebtTokenAddress;\n    //variableDebtToken address\n    address variableDebtTokenAddress;\n    //address of the interest rate strategy\n    address interestRateStrategyAddress;\n    //the current treasury balance, scaled\n    uint128 accruedToTreasury;\n    //the outstanding unbacked aTokens minted through the bridging feature\n    uint128 unbacked;\n    //the outstanding debt borrowed against this asset in isolation mode\n    uint128 isolationModeTotalDebt;\n    //the amount of underlying accounted for by the protocol\n    uint128 virtualUnderlyingBalance;\n  }\n\n  struct ReserveConfigurationMap {\n    //bit 0-15: LTV\n    //bit 16-31: Liq. threshold\n    //bit 32-47: Liq. bonus\n    //bit 48-55: Decimals\n    //bit 56: reserve is active\n    //bit 57: reserve is frozen\n    //bit 58: borrowing is enabled\n    //bit 59: DEPRECATED: stable rate borrowing enabled\n    //bit 60: asset is paused\n    //bit 61: borrowing in isolation mode is enabled\n    //bit 62: siloed borrowing enabled\n    //bit 63: flashloaning enabled\n    //bit 64-79: reserve factor\n    //bit 80-115: borrow cap in whole tokens, borrowCap == 0 => no cap\n    //bit 116-151: supply cap in whole tokens, supplyCap == 0 => no cap\n    //bit 152-167: liquidation protocol fee\n    //bit 168-175: DEPRECATED: eMode category\n    //bit 176-211: unbacked mint cap in whole tokens, unbackedMintCap == 0 => minting disabled\n    //bit 212-251: debt ceiling for isolation mode with (ReserveConfiguration::DEBT_CEILING_DECIMALS) decimals\n    //bit 252: virtual accounting is enabled for the reserve\n    //bit 253-255 unused\n\n    uint256 data;\n  }\n\n  struct UserConfigurationMap {\n    /**\n     * @dev Bitmap of the users collaterals and borrows. It is divided in pairs of bits, one pair per asset.\n     * The first bit indicates if an asset is used as collateral by the user, the second whether an\n     * asset is borrowed by the user.\n     */\n    uint256 data;\n  }\n\n  // DEPRECATED: kept for backwards compatibility, might be removed in a future version\n  struct EModeCategoryLegacy {\n    // each eMode category has a custom ltv and liquidation threshold\n    uint16 ltv;\n    uint16 liquidationThreshold;\n    uint16 liquidationBonus;\n    // DEPRECATED\n    address priceSource;\n    string label;\n  }\n\n  struct CollateralConfig {\n    uint16 ltv;\n    uint16 liquidationThreshold;\n    uint16 liquidationBonus;\n  }\n\n  struct EModeCategoryBaseConfiguration {\n    uint16 ltv;\n    uint16 liquidationThreshold;\n    uint16 liquidationBonus;\n    string label;\n  }\n\n  struct EModeCategory {\n    // each eMode category has a custom ltv and liquidation threshold\n    uint16 ltv;\n    uint16 liquidationThreshold;\n    uint16 liquidationBonus;\n    uint128 collateralBitmap;\n    string label;\n    uint128 borrowableBitmap;\n  }\n\n  enum InterestRateMode {\n    NONE,\n    __DEPRECATED,\n    VARIABLE\n  }\n\n  struct ReserveCache {\n    uint256 currScaledVariableDebt;\n    uint256 nextScaledVariableDebt;\n    uint256 currLiquidityIndex;\n    uint256 nextLiquidityIndex;\n    uint256 currVariableBorrowIndex;\n    uint256 nextVariableBorrowIndex;\n    uint256 currLiquidityRate;\n    uint256 currVariableBorrowRate;\n    uint256 reserveFactor;\n    ReserveConfigurationMap reserveConfiguration;\n    address aTokenAddress;\n    address variableDebtTokenAddress;\n    uint40 reserveLastUpdateTimestamp;\n  }\n\n  struct ExecuteLiquidationCallParams {\n    uint256 reservesCount;\n    uint256 debtToCover;\n    address collateralAsset;\n    address debtAsset;\n    address user;\n    bool receiveAToken;\n    address priceOracle;\n    uint8 userEModeCategory;\n    address priceOracleSentinel;\n  }\n\n  struct ExecuteSupplyParams {\n    address asset;\n    uint256 amount;\n    address onBehalfOf;\n    uint16 referralCode;\n  }\n\n  struct ExecuteBorrowParams {\n    address asset;\n    address user;\n    address onBehalfOf;\n    uint256 amount;\n    InterestRateMode interestRateMode;\n    uint16 referralCode;\n    bool releaseUnderlying;\n    uint256 reservesCount;\n    address oracle;\n    uint8 userEModeCategory;\n    address priceOracleSentinel;\n  }\n\n  struct ExecuteRepayParams {\n    address asset;\n    uint256 amount;\n    InterestRateMode interestRateMode;\n    address onBehalfOf;\n    bool useATokens;\n  }\n\n  struct ExecuteWithdrawParams {\n    address asset;\n    uint256 amount;\n    address to;\n    uint256 reservesCount;\n    address oracle;\n    uint8 userEModeCategory;\n  }\n\n  struct ExecuteEliminateDeficitParams {\n    address asset;\n    uint256 amount;\n  }\n\n  struct ExecuteSetUserEModeParams {\n    uint256 reservesCount;\n    address oracle;\n    uint8 categoryId;\n  }\n\n  struct FinalizeTransferParams {\n    address asset;\n    address from;\n    address to;\n    uint256 amount;\n    uint256 balanceFromBefore;\n    uint256 balanceToBefore;\n    uint256 reservesCount;\n    address oracle;\n    uint8 fromEModeCategory;\n  }\n\n  struct FlashloanParams {\n    address receiverAddress;\n    address[] assets;\n    uint256[] amounts;\n    uint256[] interestRateModes;\n    address onBehalfOf;\n    bytes params;\n    uint16 referralCode;\n    uint256 flashLoanPremiumToProtocol;\n    uint256 flashLoanPremiumTotal;\n    uint256 reservesCount;\n    address addressesProvider;\n    address pool;\n    uint8 userEModeCategory;\n    bool isAuthorizedFlashBorrower;\n  }\n\n  struct FlashloanSimpleParams {\n    address receiverAddress;\n    address asset;\n    uint256 amount;\n    bytes params;\n    uint16 referralCode;\n    uint256 flashLoanPremiumToProtocol;\n    uint256 flashLoanPremiumTotal;\n  }\n\n  struct FlashLoanRepaymentParams {\n    uint256 amount;\n    uint256 totalPremium;\n    uint256 flashLoanPremiumToProtocol;\n    address asset;\n    address receiverAddress;\n    uint16 referralCode;\n  }\n\n  struct CalculateUserAccountDataParams {\n    UserConfigurationMap userConfig;\n    uint256 reservesCount;\n    address user;\n    address oracle;\n    uint8 userEModeCategory;\n  }\n\n  struct ValidateBorrowParams {\n    ReserveCache reserveCache;\n    UserConfigurationMap userConfig;\n    address asset;\n    address userAddress;\n    uint256 amount;\n    InterestRateMode interestRateMode;\n    uint256 reservesCount;\n    address oracle;\n    uint8 userEModeCategory;\n    address priceOracleSentinel;\n    bool isolationModeActive;\n    address isolationModeCollateralAddress;\n    uint256 isolationModeDebtCeiling;\n  }\n\n  struct ValidateLiquidationCallParams {\n    ReserveCache debtReserveCache;\n    uint256 totalDebt;\n    uint256 healthFactor;\n    address priceOracleSentinel;\n  }\n\n  struct CalculateInterestRatesParams {\n    uint256 unbacked;\n    uint256 liquidityAdded;\n    uint256 liquidityTaken;\n    uint256 totalDebt;\n    uint256 reserveFactor;\n    address reserve;\n    bool usingVirtualBalance;\n    uint256 virtualUnderlyingBalance;\n  }\n\n  struct InitReserveParams {\n    address asset;\n    address aTokenAddress;\n    address variableDebtAddress;\n    address interestRateStrategyAddress;\n    uint16 reservesCount;\n    uint16 maxNumberReserves;\n  }\n}\n"
    },
    "lib/aave-umbrella/lib/aave-v3-origin/lib/solidity-utils/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    }
  },
  "settings": {
    "remappings": [
      "forge-std/=lib/aave-umbrella/lib/forge-std/src/",
      "@openzeppelin/contracts-upgradeable/=lib/aave-umbrella/lib/aave-v3-origin/lib/solidity-utils/lib/openzeppelin-contracts-upgradeable/contracts/",
      "@openzeppelin/contracts/=lib/aave-umbrella/lib/aave-v3-origin/lib/solidity-utils/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/",
      "openzeppelin-contracts-upgradeable/=lib/aave-umbrella/lib/aave-v3-origin/lib/solidity-utils/lib/openzeppelin-contracts-upgradeable/",
      "openzeppelin-contracts/=lib/aave-umbrella/lib/aave-v3-origin/lib/solidity-utils/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/",
      "aave-v3-core/=lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/core/",
      "aave-v3-origin-tests/=lib/aave-umbrella/lib/aave-v3-origin/tests/",
      "aave-v3-origin/=lib/aave-umbrella/lib/aave-v3-origin/src/",
      "aave-v3-periphery/=lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/periphery/",
      "solidity-utils/=lib/aave-umbrella/lib/aave-v3-origin/lib/solidity-utils/src/",
      "aave-address-book/=lib/aave-helpers/lib/aave-address-book/src/",
      "aave-helpers/=lib/aave-helpers/src/",
      "aave-umbrella/=lib/aave-umbrella/",
      "ds-test/=lib/aave-umbrella/lib/aave-v3-origin/lib/forge-std/lib/ds-test/src/",
      "erc4626-tests/=lib/aave-umbrella/lib/erc4626-tests/",
      "halmos-cheatcodes/=lib/aave-umbrella/lib/aave-v3-origin/lib/solidity-utils/lib/openzeppelin-contracts-upgradeable/lib/halmos-cheatcodes/src/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "metadata": {
      "useLiteralContent": false,
      "bytecodeHash": "ipfs",
      "appendCBOR": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "evmVersion": "shanghai",
    "viaIR": false,
    "libraries": {}
  }
}}