{{
  "language": "Solidity",
  "sources": {
    "contracts/libraries/liquiditySlotsLink.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\n/// @notice library that helps in reading / working with storage slot data of Fluid Liquidity.\n/// @dev as all data for Fluid Liquidity is internal, any data must be fetched directly through manual\n/// slot reading through this library or, if gas usage is less important, through the FluidLiquidityResolver.\nlibrary LiquiditySlotsLink {\n    /// @dev storage slot for status at Liquidity\n    uint256 internal constant LIQUIDITY_STATUS_SLOT = 1;\n    /// @dev storage slot for auths mapping at Liquidity\n    uint256 internal constant LIQUIDITY_AUTHS_MAPPING_SLOT = 2;\n    /// @dev storage slot for guardians mapping at Liquidity\n    uint256 internal constant LIQUIDITY_GUARDIANS_MAPPING_SLOT = 3;\n    /// @dev storage slot for user class mapping at Liquidity\n    uint256 internal constant LIQUIDITY_USER_CLASS_MAPPING_SLOT = 4;\n    /// @dev storage slot for exchangePricesAndConfig mapping at Liquidity\n    uint256 internal constant LIQUIDITY_EXCHANGE_PRICES_MAPPING_SLOT = 5;\n    /// @dev storage slot for rateData mapping at Liquidity\n    uint256 internal constant LIQUIDITY_RATE_DATA_MAPPING_SLOT = 6;\n    /// @dev storage slot for totalAmounts mapping at Liquidity\n    uint256 internal constant LIQUIDITY_TOTAL_AMOUNTS_MAPPING_SLOT = 7;\n    /// @dev storage slot for user supply double mapping at Liquidity\n    uint256 internal constant LIQUIDITY_USER_SUPPLY_DOUBLE_MAPPING_SLOT = 8;\n    /// @dev storage slot for user borrow double mapping at Liquidity\n    uint256 internal constant LIQUIDITY_USER_BORROW_DOUBLE_MAPPING_SLOT = 9;\n    /// @dev storage slot for listed tokens array at Liquidity\n    uint256 internal constant LIQUIDITY_LISTED_TOKENS_ARRAY_SLOT = 10;\n    /// @dev storage slot for listed tokens array at Liquidity\n    uint256 internal constant LIQUIDITY_CONFIGS2_MAPPING_SLOT = 11;\n\n    // --------------------------------\n    // @dev stacked uint256 storage slots bits position data for each:\n\n    // ExchangePricesAndConfig\n    uint256 internal constant BITS_EXCHANGE_PRICES_BORROW_RATE = 0;\n    uint256 internal constant BITS_EXCHANGE_PRICES_FEE = 16;\n    uint256 internal constant BITS_EXCHANGE_PRICES_UTILIZATION = 30;\n    uint256 internal constant BITS_EXCHANGE_PRICES_UPDATE_THRESHOLD = 44;\n    uint256 internal constant BITS_EXCHANGE_PRICES_LAST_TIMESTAMP = 58;\n    uint256 internal constant BITS_EXCHANGE_PRICES_SUPPLY_EXCHANGE_PRICE = 91;\n    uint256 internal constant BITS_EXCHANGE_PRICES_BORROW_EXCHANGE_PRICE = 155;\n    uint256 internal constant BITS_EXCHANGE_PRICES_SUPPLY_RATIO = 219;\n    uint256 internal constant BITS_EXCHANGE_PRICES_BORROW_RATIO = 234;\n    uint256 internal constant BITS_EXCHANGE_PRICES_USES_CONFIGS2 = 249;\n\n    // RateData:\n    uint256 internal constant BITS_RATE_DATA_VERSION = 0;\n    // RateData: V1\n    uint256 internal constant BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_ZERO = 4;\n    uint256 internal constant BITS_RATE_DATA_V1_UTILIZATION_AT_KINK = 20;\n    uint256 internal constant BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_KINK = 36;\n    uint256 internal constant BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_MAX = 52;\n    // RateData: V2\n    uint256 internal constant BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_ZERO = 4;\n    uint256 internal constant BITS_RATE_DATA_V2_UTILIZATION_AT_KINK1 = 20;\n    uint256 internal constant BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK1 = 36;\n    uint256 internal constant BITS_RATE_DATA_V2_UTILIZATION_AT_KINK2 = 52;\n    uint256 internal constant BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK2 = 68;\n    uint256 internal constant BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_MAX = 84;\n\n    // TotalAmounts\n    uint256 internal constant BITS_TOTAL_AMOUNTS_SUPPLY_WITH_INTEREST = 0;\n    uint256 internal constant BITS_TOTAL_AMOUNTS_SUPPLY_INTEREST_FREE = 64;\n    uint256 internal constant BITS_TOTAL_AMOUNTS_BORROW_WITH_INTEREST = 128;\n    uint256 internal constant BITS_TOTAL_AMOUNTS_BORROW_INTEREST_FREE = 192;\n\n    // UserSupplyData\n    uint256 internal constant BITS_USER_SUPPLY_MODE = 0;\n    uint256 internal constant BITS_USER_SUPPLY_AMOUNT = 1;\n    uint256 internal constant BITS_USER_SUPPLY_PREVIOUS_WITHDRAWAL_LIMIT = 65;\n    uint256 internal constant BITS_USER_SUPPLY_LAST_UPDATE_TIMESTAMP = 129;\n    uint256 internal constant BITS_USER_SUPPLY_EXPAND_PERCENT = 162;\n    uint256 internal constant BITS_USER_SUPPLY_EXPAND_DURATION = 176;\n    uint256 internal constant BITS_USER_SUPPLY_BASE_WITHDRAWAL_LIMIT = 200;\n    uint256 internal constant BITS_USER_SUPPLY_IS_PAUSED = 255;\n\n    // UserBorrowData\n    uint256 internal constant BITS_USER_BORROW_MODE = 0;\n    uint256 internal constant BITS_USER_BORROW_AMOUNT = 1;\n    uint256 internal constant BITS_USER_BORROW_PREVIOUS_BORROW_LIMIT = 65;\n    uint256 internal constant BITS_USER_BORROW_LAST_UPDATE_TIMESTAMP = 129;\n    uint256 internal constant BITS_USER_BORROW_EXPAND_PERCENT = 162;\n    uint256 internal constant BITS_USER_BORROW_EXPAND_DURATION = 176;\n    uint256 internal constant BITS_USER_BORROW_BASE_BORROW_LIMIT = 200;\n    uint256 internal constant BITS_USER_BORROW_MAX_BORROW_LIMIT = 218;\n    uint256 internal constant BITS_USER_BORROW_IS_PAUSED = 255;\n\n    // Configs2\n    uint256 internal constant BITS_CONFIGS2_MAX_UTILIZATION = 0;\n\n    // --------------------------------\n\n    /// @notice Calculating the slot ID for Liquidity contract for single mapping at `slot_` for `key_`\n    function calculateMappingStorageSlot(uint256 slot_, address key_) internal pure returns (bytes32) {\n        return keccak256(abi.encode(key_, slot_));\n    }\n\n    /// @notice Calculating the slot ID for Liquidity contract for double mapping at `slot_` for `key1_` and `key2_`\n    function calculateDoubleMappingStorageSlot(\n        uint256 slot_,\n        address key1_,\n        address key2_\n    ) internal pure returns (bytes32) {\n        bytes32 intermediateSlot_ = keccak256(abi.encode(key1_, slot_));\n        return keccak256(abi.encode(key2_, intermediateSlot_));\n    }\n}\n"
    },
    "contracts/oracle/cappedRates/rlpCappedRate.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IRLPPrice } from \"../interfaces/external/IRLPPrice.sol\";\nimport { FluidCappedRate } from \"../fluidCappedRate.sol\";\nimport { ErrorTypes } from \"../errorTypes.sol\";\n\n/// @notice Stores gas optimized and safety up and/or down capped exchange rate for RLP / USD Oracle.\n///\n/// @dev RLP price contract; 0xaE2364579D6cB4Bbd6695846C1D595cA9AF3574d\ncontract FluidRLPCappedRate is FluidCappedRate {\n    constructor(FluidCappedRate.CappedRateConstructorParams memory params_) FluidCappedRate(params_) {\n        if (_RATE_MULTIPLIER != 1e9) {\n            revert FluidOracleError(ErrorTypes.CappedRate__InvalidParams);\n        }\n    }\n\n    function _getNewRateRaw() internal view virtual override returns (uint256 exchangeRate_) {\n        IRLPPrice.Price memory price_ = IRLPPrice(_RATE_SOURCE).lastPrice();\n        return price_.price;\n    }\n}\n"
    },
    "contracts/oracle/error.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\ncontract Error {\n    error FluidOracleError(uint256 errorId_);\n}\n"
    },
    "contracts/oracle/errorTypes.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nlibrary ErrorTypes {\n    /***********************************|\n    |           FluidOracleL2           | \n    |__________________________________*/\n\n    /// @notice thrown when sequencer on a L2 has an outage and grace period has not yet passed.\n    uint256 internal constant FluidOracleL2__SequencerOutage = 60000;\n\n    /***********************************|\n    |     UniV3CheckCLRSOracle          | \n    |__________________________________*/\n\n    /// @notice thrown when the delta between main price source and check rate source is exceeding the allowed delta\n    uint256 internal constant UniV3CheckCLRSOracle__InvalidPrice = 60001;\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant UniV3CheckCLRSOracle__InvalidParams = 60002;\n\n    /// @notice thrown when the exchange rate is zero, even after all possible fallbacks depending on config\n    uint256 internal constant UniV3CheckCLRSOracle__ExchangeRateZero = 60003;\n\n    /***********************************|\n    |           FluidOracle             | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid info name is passed into a fluid oracle (e.g. not set or too long)\n    uint256 internal constant FluidOracle__InvalidInfoName = 60010;\n\n    /***********************************|\n    |            sUSDe Oracle           | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant SUSDeOracle__InvalidParams = 60102;\n\n    /***********************************|\n    |           Pendle Oracle           | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant PendleOracle__InvalidParams = 60201;\n\n    /// @notice thrown when the Pendle market Oracle has not been initialized yet\n    uint256 internal constant PendleOracle__MarketNotInitialized = 60202;\n\n    /// @notice thrown when the Pendle market does not have 18 decimals\n    uint256 internal constant PendleOracle__MarketInvalidDecimals = 60203;\n\n    /// @notice thrown when the Pendle market returns an unexpected price\n    uint256 internal constant PendleOracle__InvalidPrice = 60204;\n\n    /***********************************|\n    |    CLRS2UniV3CheckCLRSOracleL2    | \n    |__________________________________*/\n\n    /// @notice thrown when the exchange rate is zero, even after all possible fallbacks depending on config\n    uint256 internal constant CLRS2UniV3CheckCLRSOracleL2__ExchangeRateZero = 60301;\n\n    /***********************************|\n    |    Ratio2xFallbackCLRSOracleL2    | \n    |__________________________________*/\n\n    /// @notice thrown when the exchange rate is zero, even after all possible fallbacks depending on config\n    uint256 internal constant Ratio2xFallbackCLRSOracleL2__ExchangeRateZero = 60311;\n\n    /***********************************|\n    |            WeETHsOracle           | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant WeETHsOracle__InvalidParams = 60321;\n\n    /***********************************|\n    |        DexSmartColOracle          | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant DexSmartColOracle__InvalidParams = 60331;\n\n    /// @notice thrown when smart col is not enabled\n    uint256 internal constant DexSmartColOracle__SmartColNotEnabled = 60332;\n\n    /// @notice thrown when the exchange rate is zero, even after all possible fallbacks depending on config\n    uint256 internal constant DexSmartColOracle__ExchangeRateZero = 60333;\n\n    /***********************************|\n    |        DexSmartDebtOracle         | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant DexSmartDebtOracle__InvalidParams = 60341;\n\n    /// @notice thrown when smart debt is not enabled\n    uint256 internal constant DexSmartDebtOracle__SmartDebtNotEnabled = 60342;\n\n    /// @notice thrown when the exchange rate is zero, even after all possible fallbacks depending on config\n    uint256 internal constant DexSmartDebtOracle__ExchangeRateZero = 60343;\n\n    /***********************************|\n    |            CappedRate           | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant CappedRate__InvalidParams = 60351;\n\n    /// @notice thrown when caller is not authorized\n    uint256 internal constant CappedRate__Unauthorized = 60352;\n\n    /// @notice thrown when minimum diff for triggering update on the stared rate is not reached\n    uint256 internal constant CappedRate__MinUpdateDiffNotReached = 60353;\n\n    /// @notice thrown when the external rate source returns 0 for the new rate\n    uint256 internal constant CappedRate__NewRateZero = 60354;\n\n    /// @notice thrown when the new rate source does not fit in 192 bit storage uint, should never happen.\n    uint256 internal constant CappedRate__StorageOverflow = 60355;\n\n    /***********************************|\n    |            sUSDs Oracle           | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant SUSDsOracle__InvalidParams = 60361;\n\n    /***********************************|\n    |            Peg Oracle             | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant PegOracle__InvalidParams = 60371;\n\n    /***********************************|\n    |              DexOracle            | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant DexOracle__InvalidParams = 60381;\n\n    /// @notice thrown when the exchange rate is zero, even after all possible fallbacks depending on config\n    uint256 internal constant DexOracle__ExchangeRateZero = 60382;\n\n    /***********************************|\n    |           GenericOracle           | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant GenericOracle__InvalidParams = 60401;\n\n    /// @notice thrown when reaching an unexepcted config state\n    uint256 internal constant GenericOracle__UnexpectedConfig = 60402;\n\n    /// @notice thrown when the exchange rate is zero\n    uint256 internal constant GenericOracle__RateZero = 60403;\n\n    /***********************************|\n    |          Chainlink Oracle         | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant ChainlinkOracle__InvalidParams = 61001;\n\n    /***********************************|\n    |          UniswapV3 Oracle         | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant UniV3Oracle__InvalidParams = 62001;\n\n    /// @notice thrown when constructor is called with invalid ordered seconds agos values\n    uint256 internal constant UniV3Oracle__InvalidSecondsAgos = 62002;\n\n    /// @notice thrown when constructor is called with invalid delta values > 100%\n    uint256 internal constant UniV3Oracle__InvalidDeltas = 62003;\n\n    /***********************************|\n    |            WstETh Oracle          | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant WstETHOracle__InvalidParams = 63001;\n\n    /***********************************|\n    |           Redstone Oracle         | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant RedstoneOracle__InvalidParams = 64001;\n\n    /***********************************|\n    |          Fallback Oracle          | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant FallbackOracle__InvalidParams = 65001;\n\n    /***********************************|\n    |       FallbackCLRSOracle          | \n    |__________________________________*/\n\n    /// @notice thrown when the exchange rate is zero, even for the fallback oracle source (if enabled)\n    uint256 internal constant FallbackCLRSOracle__ExchangeRateZero = 66001;\n\n    /***********************************|\n    |         WstETHCLRSOracle          | \n    |__________________________________*/\n\n    /// @notice thrown when the exchange rate is zero, even for the fallback oracle source (if enabled)\n    uint256 internal constant WstETHCLRSOracle__ExchangeRateZero = 67001;\n\n    /***********************************|\n    |        CLFallbackUniV3Oracle      | \n    |__________________________________*/\n\n    /// @notice thrown when the exchange rate is zero, even for the uniV3 rate\n    uint256 internal constant CLFallbackUniV3Oracle__ExchangeRateZero = 68001;\n\n    /***********************************|\n    |  WstETHCLRS2UniV3CheckCLRSOracle  | \n    |__________________________________*/\n\n    /// @notice thrown when the exchange rate is zero, even for the uniV3 rate\n    uint256 internal constant WstETHCLRS2UniV3CheckCLRSOracle__ExchangeRateZero = 69001;\n\n    /***********************************|\n    |             WeETh Oracle          | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant WeETHOracle__InvalidParams = 70001;\n}\n"
    },
    "contracts/oracle/fluidCappedRate.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IFluidOracle } from \"./interfaces/iFluidOracle.sol\";\nimport { IFluidCappedRate } from \"./interfaces/iFluidCappedRate.sol\";\nimport { FluidCenterPrice } from \"./fluidCenterPrice.sol\";\n\nimport { LiquiditySlotsLink } from \"../libraries/liquiditySlotsLink.sol\";\n\nimport { Error as OracleError } from \"./error.sol\";\nimport { ErrorTypes } from \"./errorTypes.sol\";\n\ninterface IFluidLiquidity {\n    function readFromStorage(bytes32 slot_) external view returns (uint256 result_);\n}\n\nabstract contract Events {\n    /// @notice emitted when rebalancer successfully changes the contract rate\n    event LogRebalanceRate(uint256 oldRate, uint256 newRate, uint256 oldMaxRate, uint256 newMaxRate);\n\n    /// @notice emitted when the external rate is currently lower than the previous maximum rate by at least `_maxDownFromMaxReachedPercent`\n    event LogRateBelowMaxReached();\n\n    /// @notice emitted when the external rate increased faster than `_maxAPRPercent` allows\n    event LogRateMaxAPRCapped();\n\n    /// @notice Emitted when avoidForcedLiquidations col is updated\n    event LogUpdateAvoidForcedLiquidationsCol(bool oldAvoidForcedLiquidations, bool newAvoidForcedLiquidations);\n\n    /// @notice Emitted when avoidForcedLiquidations debt is updated\n    event LogUpdateAvoidForcedLiquidationsDebt(bool oldAvoidForcedLiquidations, bool newAvoidForcedLiquidations);\n\n    /// @notice Emitted when maxAPRPercent is updated\n    event LogUpdateMaxAPRPercent(uint256 oldMaxAPRPercent, uint256 newMaxAPRPercent);\n\n    /// @notice Emitted when _maxDownFromMaxReachedPercentCol is updated\n    event LogUpdateMaxDownFromMaxReachedPercentCol(\n        uint256 oldMaxDownFromMaxReachedPercent,\n        uint256 newMaxDownFromMaxReachedPercent\n    );\n\n    /// @notice Emitted when _maxDownFromMaxReachedPercentDebt is updated\n    event LogUpdateMaxDownFromMaxReachedPercentDebt(\n        uint256 oldMaxDownFromMaxReachedPercent,\n        uint256 newMaxDownFromMaxReachedPercent\n    );\n\n    /// @notice Emitted when max reached rate is reset to `_rate`\n    event LogForceResetMaxRate(uint256 oldMaxRate, uint256 newMaxRate);\n\n    /// @notice Emitted when _maxDebtUpCapPercent is updated\n    event LogUpdateMaxDebtUpCapPercent(uint256 oldMaxDebtUpCapPercent, uint256 newMaxDebtUpCapPercent);\n\n    /// @notice Emitted when _minHeartbeat is updated\n    event LogUpdateMinHeartbeat(uint256 oldMinHeartbeat, uint256 newMinHeartbeat);\n\n    /// @notice Emitted when _minUpdateDiffPercent is updated\n    event LogUpdateMinUpdateDiffPercent(uint256 oldMinUpdateDiffPercent, uint256 newMinUpdateDiffPercent);\n}\n\nabstract contract Constants {\n    /// @dev Ignoring leap years\n    uint256 internal constant _SECONDS_PER_YEAR = 365 days;\n\n    /// @dev 100% precision\n    uint256 internal constant _SIX_DECIMALS = 1e6;\n\n    /// @dev liquidity layer address\n    address internal immutable _LIQUIDITY;\n\n    /// @dev external exchange rate source contract\n    address internal immutable _RATE_SOURCE;\n\n    /// @dev flag if fetched rate should be inverted\n    bool internal immutable _INVERT_RATE;\n\n    /// @dev external exchange rate source multiplier to get to 1e27 decimals\n    uint256 internal immutable _RATE_MULTIPLIER;\n}\n\nabstract contract Variables is Constants {\n    // slot 0 flag bitmasks\n    uint8 internal constant _FLAG_BITMASK_IS_RATE_BELOW_MAX_REACHED = 1;\n    uint8 internal constant _FLAG_BITMASK_IS_UP_MAX_APR_CAPPED = 2;\n    uint8 internal constant _FLAG_BITMASK_AVOID_FORCED_LIQUIDATIONS_COL = 4;\n    uint8 internal constant _FLAG_BITMASK_AVOID_FORCED_LIQUIDATIONS_DEBT = 8;\n\n    struct Slot0 {\n        /// @dev exchange rate as fetched from external rate source in 1e27 decimals. max value 3.74e50\n        uint168 rate;\n        /// @dev time when last update for rate happened\n        uint40 lastUpdateTime;\n        /// @dev flags bitmap:\n        /// Bit 1: true if the `_rate` value is currently < _maxReachedAPRCappedRate\n        ///        bool internal _isRateBelowMaxReached;\n\n        /// Bit 2: true if the `_rate` value is currently > _maxReachedAPRCappedRate, so capped because of the maxAPR limit\n        ///        bool internal _isUpMaxAPRCapped;\n\n        /// Bit 3: Col side: config flag to signal whether to protect users vs protect protocol depending on asset reliability (accept temporary bad debt if trusting peg).\n        ///        flag should only be active for trusted assets where we assume any peg can only be temporary as when this flag is on\n        ///        it can lead to bad debt until asset repeg is reached. For not 100% trusted assets better to liquidate on depeg and avoid any bad debt\n        ///        Configurable by Governance and Liquidity guardians\n        ///        bool internal _avoidForcedLiquidationsCol;\n\n        /// Bit 4: same as Bit 3, but for debt side\n        ///        bool internal _avoidForcedLiquidationsDebt;\n        uint8 flags;\n        /// @dev Minimum time after which an update can trigger, even if it does not reach `_minUpdateDiffPercent`. Max value = 16_777_215 -> ~194 days\n        ///      Configurable by Governance.\n        uint24 minHeartbeat;\n        /// @dev Minimum difference to trigger update in percent 1e4 decimals, 10000 = 1%. Max value = 6,5535%\n        ///      Configurable by Governance.\n        uint16 minUpdateDiffPercent;\n    }\n\n    struct Slot1 {\n        /// @dev tracks the maximum ever reached rate with respect of maxAPR percent (a temporary 100x spike does not increase this value beyond max apr increase).\n        /// this is only updated IF `_rate` is not == `_maxReachedAPRCappedRate`, i.e. if `_isRateBelowMaxReached || _isUpMaxAPRCapped`. max value 3.74e50\n        ///\n        /// Can be reset synced to match `_rate` by Govnernance and Liquidity guardians, when wanting to force skip max APR or forcing reset after rate reduced\n        uint168 maxReachedAPRCappedRate;\n        /// @dev maximum yield APR that exchange rate can increase in each update\n        /// in 1e2 precision, 1% = 100. max value-> 167_772,15%, can be set to 0 to force no rate increase possible for upwards cap\n        ///\n        /// Configurable by Governance and Liquidity guardians.\n        uint24 maxAPRPercent;\n        /// @dev Col side: maximum down percent reduction of `_maxReachedAPRCappedRate` for rates with downward cap protection.\n        /// in 1e4 precision, 1% = 1e4. max value-> 1_677,7215 % (so max configurable value = _SIX_DECIMALS which is 100% -> removing downward cap entirely)\n        ///\n        /// Configurable by Governance and Liquidity guardians\n        uint24 maxDownFromMaxReachedPercentCol;\n        /// @dev same as above but for debt\n        uint24 maxDownFromMaxReachedPercentDebt;\n        /// @dev Debt side: maximum up percent cap on top of `_maxReachedAPRCappedRate`, only relevant when avoid forced liquidations attack for debt side is active,\n        /// when _avoidForcedLiquidationsDebt flag is true. in 1e2 precision, 1% = 100. max value-> 655,35%, can be set to 0 to have same cap as on col side.\n        ///\n        /// Configurable by Governance and Liquidity guardians.\n        uint16 maxDebtUpCapPercent;\n    }\n\n    Slot0 internal _slot0; // Used in default view methods\n\n    Slot1 internal _slot1; // Used only in special cases, storage updates or admin related\n}\n\nabstract contract CappedRateInternals is Variables, Events, OracleError {\n    /// @dev read the exchange rate from the external contract e.g. wstETH or rsETH exchange rate, yet to be scaled to 1e27\n    /// To be implemented by inheriting contract\n    function _getNewRateRaw() internal view virtual returns (uint256 exchangeRate_);\n\n    /// @dev gets the percentage difference between `oldValue_` and `newValue_` in relation to `oldValue_` in percent (10000 = 1%, 1 = 0.0001%).\n    function _percentDiffForValue(\n        uint256 oldValue_,\n        uint256 newValue_\n    ) internal pure returns (uint256 configPercentDiff_) {\n        unchecked {\n            if (oldValue_ > newValue_) {\n                configPercentDiff_ = ((oldValue_ - newValue_) * _SIX_DECIMALS) / oldValue_;\n            } else if (newValue_ > oldValue_) {\n                configPercentDiff_ = ((newValue_ - oldValue_) * _SIX_DECIMALS) / oldValue_;\n            }\n        }\n    }\n\n    /// @dev get new rate from external source and return updated related parameters.\n    function _getUpdateRates(\n        uint256 maxReachedRate_,\n        uint256 lastUpdateTime_,\n        uint256 maxAPRPercent_\n    )\n        internal\n        view\n        virtual\n        returns (uint256 newRate_, uint256 maxRate_, bool isUpMaxAPRCapped_, bool isRateBelowMaxReached_)\n    {\n        newRate_ = _getNewRateRaw() * _RATE_MULTIPLIER;\n        if (newRate_ == 0) {\n            revert FluidOracleError(ErrorTypes.CappedRate__NewRateZero);\n        }\n\n        maxRate_ = _calcMaxAPRCappedRate(newRate_, maxReachedRate_, lastUpdateTime_, maxAPRPercent_);\n        isUpMaxAPRCapped_ = newRate_ > maxRate_;\n        isRateBelowMaxReached_ = newRate_ < maxRate_;\n    }\n\n    /// @dev updates the values in storage according to the newly fetched rate from external source.\n    function _updateRates(bool forceUpdate_) internal virtual returns (uint256 newRate_) {\n        Slot0 memory slot0_ = _slot0;\n        Slot1 memory slot1_ = _slot1;\n\n        uint256 newMaxReachedRate_;\n        bool isUpMaxAPRCapped_;\n        bool isRateBelowMaxReached_;\n\n        uint256 maxReachedAPRCappedRate_ = uint256(slot1_.maxReachedAPRCappedRate);\n\n        (newRate_, newMaxReachedRate_, isUpMaxAPRCapped_, isRateBelowMaxReached_) = _getUpdateRates(\n            maxReachedAPRCappedRate_,\n            uint256(slot0_.lastUpdateTime),\n            uint256(slot1_.maxAPRPercent)\n        );\n\n        if (newRate_ > type(uint168).max || newMaxReachedRate_ > type(uint168).max) {\n            revert FluidOracleError(ErrorTypes.CappedRate__StorageOverflow);\n        }\n\n        uint256 curRate_ = uint256(slot0_.rate);\n\n        uint256 minUpdateDiffPercent_ = uint256(slot0_.minUpdateDiffPercent);\n        if (\n            !forceUpdate_ &&\n            _percentDiffForValue(curRate_, newRate_) < minUpdateDiffPercent_ &&\n            _percentDiffForValue(maxReachedAPRCappedRate_, newMaxReachedRate_) < minUpdateDiffPercent_\n        ) {\n            revert FluidOracleError(ErrorTypes.CappedRate__MinUpdateDiffNotReached);\n        }\n\n        if (isUpMaxAPRCapped_) {\n            // if this flag is true then the rate is always effectively upwards capped\n            emit LogRateMaxAPRCapped();\n        }\n        if (isRateBelowMaxReached_) {\n            uint256 downPercent_ = ((newMaxReachedRate_ - newRate_) * _SIX_DECIMALS) / newMaxReachedRate_;\n            if (\n                downPercent_ > slot1_.maxDownFromMaxReachedPercentCol ||\n                downPercent_ > slot1_.maxDownFromMaxReachedPercentDebt\n            ) {\n                // only log this if the decrease is by more than `_maxDownFromMaxReachedPercent` so if the returned rate actually ends up getting\n                // downwards capped (for either col or debt)\n                emit LogRateBelowMaxReached();\n            }\n        }\n\n        // storage slot 1 ALWAYS gets updated because of timestamp so no need to optimize much here\n        slot0_.lastUpdateTime = uint40(block.timestamp);\n        slot0_.rate = uint168(newRate_);\n        slot0_.flags =\n            (slot0_.flags & 0xFC) |\n            (isRateBelowMaxReached_ ? _FLAG_BITMASK_IS_RATE_BELOW_MAX_REACHED : 0) |\n            (isUpMaxAPRCapped_ ? _FLAG_BITMASK_IS_UP_MAX_APR_CAPPED : 0);\n        _slot0 = slot0_; // write to storage\n\n        // storage slot 2 might not always change, only if max rate changes, which could be not needed e.g. if rate decreased\n        if (maxReachedAPRCappedRate_ < newMaxReachedRate_) {\n            _slot1.maxReachedAPRCappedRate = uint168(newMaxReachedRate_);\n        }\n\n        emit LogRebalanceRate(curRate_, newRate_, maxReachedAPRCappedRate_, newMaxReachedRate_);\n    }\n\n    /// @dev returns the downwards capped rate max(downCappedRate_, rate_), where downCappedRate_ is capped at maxReachedAPRCappedRate_ - _maxDownFromMaxReachedPercent %.\n    function _calcDownCappedRate(\n        uint256 rate_,\n        uint256 maxReachedRate_,\n        uint256 maxDownPercent_\n    ) internal pure returns (uint256 downCappedRate_) {\n        unchecked {\n            downCappedRate_ = (maxReachedRate_ * (_SIX_DECIMALS - maxDownPercent_)) / _SIX_DECIMALS;\n        }\n\n        if (rate_ > downCappedRate_) {\n            downCappedRate_ = rate_;\n        }\n    }\n\n    /// @dev returns the upwards capped rate min(upCappedRate_, rate_), where upCappedRate_ is capped at maxReachedAPRCappedRate_ + _maxAPRPercent %\n    /// adjusted for passed time since last update time.\n    function _calcMaxAPRCappedRate(\n        uint256 rate_,\n        uint256 maxReachedRate_,\n        uint256 lastUpdateTime_,\n        uint256 maxAPRPercent_\n    ) internal view returns (uint256 maxRate_) {\n        unchecked {\n            maxRate_ = (maxAPRPercent_ * uint256(100) * (block.timestamp - lastUpdateTime_)) / _SECONDS_PER_YEAR; // maxRate_ = max APR for passed time since last update time\n            maxRate_ = (maxReachedRate_ * (_SIX_DECIMALS + maxRate_)) / _SIX_DECIMALS;\n        }\n\n        if (rate_ > maxRate_) {\n            // rate increase is capped at max rate\n            return maxRate_;\n        }\n        if (rate_ < maxReachedRate_) {\n            // if rate is lower than previous max reached rate, then previous max reached rate is the max rate\n            return maxReachedRate_;\n        }\n\n        // rate is > maxReachedRate and < max allowed rate\n        return rate_;\n    }\n\n    /// @dev returns true if last update timestamp is too long ago so heartbeat update should trigger\n    function _isHeartbeatTrigger(Slot0 memory slot0_) internal view returns (bool) {\n        unchecked {\n            return ((uint256(slot0_.lastUpdateTime) + slot0_.minHeartbeat) < block.timestamp);\n        }\n    }\n\n    /// @dev returns inverted rate if needed (when _INVERT_RATE flag is set to true)\n    function _invertRateIfNeeded(uint256 exchangeRate_) internal view returns (uint256) {\n        if (exchangeRate_ == 0) {\n            return 0;\n        }\n        unchecked {\n            return _INVERT_RATE ? 1e54 / exchangeRate_ : exchangeRate_;\n        }\n    }\n}\n\nabstract contract CappedRateAdmin is Variables, Events, OracleError {\n    /// This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1 where current liquidity owner on proxy is stored\n    bytes32 internal constant GOVERNANCE_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /// @dev only Liquidity Layer owner (governance) and guardians access modifier\n    modifier onlyGuardians() {\n        bool isGuardian_ = (IFluidLiquidity(_LIQUIDITY).readFromStorage(\n            LiquiditySlotsLink.calculateMappingStorageSlot(\n                LiquiditySlotsLink.LIQUIDITY_GUARDIANS_MAPPING_SLOT,\n                msg.sender\n            )\n        ) & 1) == 1;\n\n        bool isGovernance_ = address(uint160(IFluidLiquidity(_LIQUIDITY).readFromStorage(GOVERNANCE_SLOT))) ==\n            msg.sender;\n\n        if (!isGuardian_ && !isGovernance_) {\n            revert FluidOracleError(ErrorTypes.CappedRate__Unauthorized);\n        }\n        _;\n    }\n\n    /// @dev only Liquidity Layer owner (governance) access modifier\n    modifier onlyGovernance() {\n        if (address(uint160(IFluidLiquidity(_LIQUIDITY).readFromStorage(GOVERNANCE_SLOT))) != msg.sender) {\n            revert FluidOracleError(ErrorTypes.CappedRate__Unauthorized);\n        }\n        _;\n    }\n\n    /// @notice Updates the avoidForcedLiquidations_ col side config flag. Only callable by Liquidity Layer guardians\n    function updateAvoidForcedLiquidationsCol(bool avoid_) external onlyGuardians {\n        bool oldAvoidForcedLiquidations_ = _slot0.flags & _FLAG_BITMASK_AVOID_FORCED_LIQUIDATIONS_COL ==\n            _FLAG_BITMASK_AVOID_FORCED_LIQUIDATIONS_COL;\n        _slot0.flags = (_slot0.flags & 0xFB) | (avoid_ ? _FLAG_BITMASK_AVOID_FORCED_LIQUIDATIONS_COL : 0); // mask F1011\n        emit LogUpdateAvoidForcedLiquidationsCol(oldAvoidForcedLiquidations_, avoid_);\n    }\n\n    /// @notice Updates the avoidForcedLiquidations_ debt side config flag. Only callable by Liquidity Layer guardians\n    function updateAvoidForcedLiquidationsDebt(bool avoid_) external onlyGuardians {\n        bool oldAvoidForcedLiquidations_ = _slot0.flags & _FLAG_BITMASK_AVOID_FORCED_LIQUIDATIONS_DEBT ==\n            _FLAG_BITMASK_AVOID_FORCED_LIQUIDATIONS_DEBT;\n        _slot0.flags = (_slot0.flags & 0xF7) | (avoid_ ? _FLAG_BITMASK_AVOID_FORCED_LIQUIDATIONS_DEBT : 0); // mask F0111\n        emit LogUpdateAvoidForcedLiquidationsDebt(oldAvoidForcedLiquidations_, avoid_);\n    }\n\n    /// @notice resets max reached rate to current `_rate` value. Only callable by Liquidity Layer guardians\n    function forceResetMaxRate() external onlyGuardians {\n        uint256 oldMaxRate_ = uint256(_slot1.maxReachedAPRCappedRate);\n        _slot1.maxReachedAPRCappedRate = _slot0.rate;\n        emit LogForceResetMaxRate(oldMaxRate_, uint256(_slot1.maxReachedAPRCappedRate));\n    }\n\n    /// @notice Updates the maxAPRPercent_ config, in 1e4 percent (1% = 1e4). Only callable by Governance\n    function updateMaxAPRPercent(uint256 newMaxAPRPercent_) external onlyGuardians {\n        if (newMaxAPRPercent_ > type(uint24).max * uint256(100)) {\n            revert FluidOracleError(ErrorTypes.CappedRate__InvalidParams);\n        }\n        uint256 oldMaxAPRPercent_ = uint256(_slot1.maxAPRPercent) * uint256(100);\n        _slot1.maxAPRPercent = uint24(newMaxAPRPercent_ / uint256(100));\n        emit LogUpdateMaxAPRPercent(oldMaxAPRPercent_, newMaxAPRPercent_);\n    }\n\n    /// @notice Updates the _maxDownFromMaxReachedPercentCol config. Only callable by Liquidity Layer guardians.\n    ///         Set to 100% (1e6) to completely remove down peg (same as updateAvoidForcedLiquidationsCol = false)\n    function updateMaxDownFromMaxReachedPercentCol(uint256 newMaxDownFromMaxReachedPercent_) external onlyGuardians {\n        if (newMaxDownFromMaxReachedPercent_ > _SIX_DECIMALS) {\n            revert FluidOracleError(ErrorTypes.CappedRate__InvalidParams);\n        }\n        uint256 oldMaxDownFromMaxReachedPercent_ = uint256(_slot1.maxDownFromMaxReachedPercentCol);\n        _slot1.maxDownFromMaxReachedPercentCol = uint24(newMaxDownFromMaxReachedPercent_);\n        emit LogUpdateMaxDownFromMaxReachedPercentCol(\n            oldMaxDownFromMaxReachedPercent_,\n            newMaxDownFromMaxReachedPercent_\n        );\n    }\n\n    /// @notice Updates the _maxDownFromMaxReachedPercentDebt config. Only callable by Liquidity Layer guardians.\n    ///         Set to 100% (1e6) to completely remove down peg.\n    function updateMaxDownFromMaxReachedPercentDebt(uint256 newMaxDownFromMaxReachedPercent_) external onlyGuardians {\n        if (newMaxDownFromMaxReachedPercent_ > _SIX_DECIMALS) {\n            revert FluidOracleError(ErrorTypes.CappedRate__InvalidParams);\n        }\n        uint256 oldMaxDownFromMaxReachedPercent_ = uint256(_slot1.maxDownFromMaxReachedPercentDebt);\n        _slot1.maxDownFromMaxReachedPercentDebt = uint24(newMaxDownFromMaxReachedPercent_);\n        emit LogUpdateMaxDownFromMaxReachedPercentDebt(\n            oldMaxDownFromMaxReachedPercent_,\n            newMaxDownFromMaxReachedPercent_\n        );\n    }\n\n    /// @notice Updates the _maxDebtUpCapPercent config. Only callable by Liquidity Layer guardians.\n    function updateMaxDebtUpCapPercent(uint256 newMaxDebtUpCapPercent_) external onlyGuardians {\n        if (newMaxDebtUpCapPercent_ > type(uint16).max * uint256(100)) {\n            revert FluidOracleError(ErrorTypes.CappedRate__InvalidParams);\n        }\n        uint256 oldMaxDebtUpCapPercent_ = uint256(_slot1.maxDebtUpCapPercent) * uint256(100);\n        _slot1.maxDebtUpCapPercent = uint16(newMaxDebtUpCapPercent_ / uint256(100));\n        emit LogUpdateMaxDebtUpCapPercent(oldMaxDebtUpCapPercent_, newMaxDebtUpCapPercent_);\n    }\n\n    /// @notice Updates the _minHeartbeat config. Only callable by Governance.\n    function updateMinHeartbeat(uint256 newMinHeartbeat_) external onlyGovernance {\n        if (newMinHeartbeat_ > type(uint24).max || newMinHeartbeat_ == 0) {\n            revert FluidOracleError(ErrorTypes.CappedRate__InvalidParams);\n        }\n        uint256 oldMinHeartbeat_ = uint256(_slot0.minHeartbeat);\n        _slot0.minHeartbeat = uint24(newMinHeartbeat_);\n        emit LogUpdateMinHeartbeat(oldMinHeartbeat_, newMinHeartbeat_);\n    }\n\n    /// @notice Updates the _minUpdateDiffPercent config. Only callable by Governance.\n    function updateMinUpdateDiffPercent(uint256 newMinUpdateDiffPercent_) external onlyGovernance {\n        if (newMinUpdateDiffPercent_ > type(uint16).max || newMinUpdateDiffPercent_ == 0) {\n            revert FluidOracleError(ErrorTypes.CappedRate__InvalidParams);\n        }\n        uint256 oldMinUpdateDiffPercent_ = uint256(_slot0.minUpdateDiffPercent);\n        _slot0.minUpdateDiffPercent = uint16(newMinUpdateDiffPercent_);\n        emit LogUpdateMinUpdateDiffPercent(oldMinUpdateDiffPercent_, newMinUpdateDiffPercent_);\n    }\n}\n\n/// @notice This contract stores an exchange rate with caps in intervals to optimize gas cost.\n/// @notice Properly implements all interfaces for use as IFluidCenterPrice and IFluidOracle.\nabstract contract FluidCappedRateBase is CappedRateInternals, CappedRateAdmin, IFluidCappedRate {\n    /// @dev Validates that an address is not the zero address\n    modifier validAddress(address value_) {\n        if (value_ == address(0)) {\n            revert FluidOracleError(ErrorTypes.CappedRate__InvalidParams);\n        }\n        _;\n    }\n\n    struct CappedRateConstructorParams {\n        string infoName;\n        address liquidity;\n        address rateSource;\n        uint256 rateMultiplier;\n        bool invertRate;\n        uint256 minUpdateDiffPercent;\n        uint256 minHeartbeat;\n        bool avoidForcedLiquidationsCol;\n        bool avoidForcedLiquidationsDebt;\n        uint256 maxAPRPercent;\n        uint256 maxDownFromMaxReachedPercentCol;\n        uint256 maxDownFromMaxReachedPercentDebt;\n        uint256 maxDebtUpCapPercent;\n    }\n\n    constructor(\n        CappedRateConstructorParams memory params_\n    ) validAddress(params_.liquidity) validAddress(params_.rateSource) {\n        if (\n            params_.rateMultiplier == 0 ||\n            params_.rateMultiplier > 1e21 ||\n            params_.minUpdateDiffPercent == 0 ||\n            params_.minUpdateDiffPercent > type(uint16).max ||\n            params_.minHeartbeat == 0 ||\n            params_.minHeartbeat > type(uint24).max ||\n            params_.maxDownFromMaxReachedPercentCol > _SIX_DECIMALS ||\n            params_.maxDownFromMaxReachedPercentDebt > _SIX_DECIMALS ||\n            params_.maxAPRPercent > type(uint24).max * uint256(100) ||\n            params_.maxDebtUpCapPercent > type(uint16).max * uint256(100)\n        ) {\n            revert FluidOracleError(ErrorTypes.CappedRate__InvalidParams);\n        }\n        _LIQUIDITY = params_.liquidity;\n        _RATE_SOURCE = params_.rateSource;\n        _RATE_MULTIPLIER = params_.rateMultiplier;\n        _INVERT_RATE = params_.invertRate;\n\n        _slot0.rate = uint168(_getNewRateRaw() * _RATE_MULTIPLIER);\n        _slot0.lastUpdateTime = uint40(block.timestamp);\n\n        _slot0.minUpdateDiffPercent = uint16(params_.minUpdateDiffPercent);\n        _slot0.minHeartbeat = uint24(params_.minHeartbeat);\n\n        _slot0.flags =\n            (params_.avoidForcedLiquidationsCol ? _FLAG_BITMASK_AVOID_FORCED_LIQUIDATIONS_COL : 0) |\n            (params_.avoidForcedLiquidationsDebt ? _FLAG_BITMASK_AVOID_FORCED_LIQUIDATIONS_DEBT : 0);\n\n        _slot1.maxAPRPercent = uint24(params_.maxAPRPercent / uint256(100));\n        _slot1.maxDownFromMaxReachedPercentCol = uint24(params_.maxDownFromMaxReachedPercentCol);\n        _slot1.maxDownFromMaxReachedPercentDebt = uint24(params_.maxDownFromMaxReachedPercentDebt);\n        _slot1.maxDebtUpCapPercent = uint16(params_.maxDebtUpCapPercent / uint256(100));\n        _slot1.maxReachedAPRCappedRate = _slot0.rate;\n    }\n\n    /// @inheritdoc IFluidOracle\n    function getExchangeRate() public view virtual returns (uint256 exchangeRate_) {\n        // deprecated legacy support method -> Should not be used anywhere anymore.\n        Slot0 memory slot0_ = _slot0;\n\n        if (_isHeartbeatTrigger(slot0_)) {\n            Slot1 memory slot1_ = _slot1;\n            (exchangeRate_, , , ) = _getUpdateRates(\n                uint256(slot1_.maxReachedAPRCappedRate),\n                uint256(slot0_.lastUpdateTime),\n                uint256(slot1_.maxAPRPercent)\n            );\n            return _invertRateIfNeeded(exchangeRate_);\n        }\n        return _invertRateIfNeeded(uint256(slot0_.rate));\n    }\n\n    /// @inheritdoc IFluidOracle\n    function getExchangeRateOperate() public view virtual returns (uint256 exchangeRate_) {\n        // for col -> up APR capped (avoid overpricing exploit), down no cap\n        Slot0 memory slot0_ = _slot0;\n\n        if (_isHeartbeatTrigger(slot0_)) {\n            Slot1 memory slot1_ = _slot1;\n            uint256 maxReachedRate_;\n            bool isUpMaxAPRCapped_;\n            (exchangeRate_, maxReachedRate_, isUpMaxAPRCapped_, ) = _getUpdateRates(\n                uint256(slot1_.maxReachedAPRCappedRate),\n                uint256(slot0_.lastUpdateTime),\n                uint256(slot1_.maxAPRPercent)\n            );\n            return _invertRateIfNeeded(isUpMaxAPRCapped_ ? maxReachedRate_ : exchangeRate_);\n        }\n\n        return\n            _invertRateIfNeeded(\n                (slot0_.flags & _FLAG_BITMASK_IS_UP_MAX_APR_CAPPED == _FLAG_BITMASK_IS_UP_MAX_APR_CAPPED) // is _isUpMaxAPRCapped\n                    ? uint256(_slot1.maxReachedAPRCappedRate)\n                    : uint256(slot0_.rate)\n            );\n    }\n\n    /// @inheritdoc IFluidOracle\n    function getExchangeRateLiquidate() public view virtual returns (uint256 exchangeRate_) {\n        // for col -> up max APR cap, down capped (avoid forced liquidations attack)\n        Slot0 memory slot0_ = _slot0;\n\n        Slot1 memory slot1_; // only read if needed\n\n        uint256 maxReachedRate_;\n        bool isUpMaxAPRCapped_;\n        bool isRateBelowMaxReached_;\n\n        if (_isHeartbeatTrigger(slot0_)) {\n            slot1_ = _slot1;\n            (exchangeRate_, maxReachedRate_, isUpMaxAPRCapped_, isRateBelowMaxReached_) = _getUpdateRates(\n                uint256(slot1_.maxReachedAPRCappedRate),\n                uint256(slot0_.lastUpdateTime),\n                uint256(slot1_.maxAPRPercent)\n            );\n        } else {\n            isUpMaxAPRCapped_ = slot0_.flags & _FLAG_BITMASK_IS_UP_MAX_APR_CAPPED == _FLAG_BITMASK_IS_UP_MAX_APR_CAPPED;\n            isRateBelowMaxReached_ =\n                slot0_.flags & _FLAG_BITMASK_IS_RATE_BELOW_MAX_REACHED == _FLAG_BITMASK_IS_RATE_BELOW_MAX_REACHED;\n            exchangeRate_ = uint256(slot0_.rate);\n        }\n\n        if (isUpMaxAPRCapped_) {\n            return _invertRateIfNeeded(maxReachedRate_ > 0 ? maxReachedRate_ : uint256(_slot1.maxReachedAPRCappedRate));\n        }\n\n        if (\n            isRateBelowMaxReached_ &&\n            (slot0_.flags & _FLAG_BITMASK_AVOID_FORCED_LIQUIDATIONS_COL == _FLAG_BITMASK_AVOID_FORCED_LIQUIDATIONS_COL)\n        ) {\n            // is _avoidForcedLiquidationsCol\n            if (slot1_.maxReachedAPRCappedRate == 0) {\n                slot1_ = _slot1;\n            }\n\n            return\n                _invertRateIfNeeded(\n                    _calcDownCappedRate(\n                        exchangeRate_,\n                        maxReachedRate_ > 0 ? maxReachedRate_ : uint256(slot1_.maxReachedAPRCappedRate),\n                        uint256(slot1_.maxDownFromMaxReachedPercentCol)\n                    )\n                );\n        }\n\n        return _invertRateIfNeeded(exchangeRate_);\n    }\n\n    /// @inheritdoc IFluidCappedRate\n    function getExchangeRateOperateDebt() public view virtual returns (uint256 exchangeRate_) {\n        // for debt -> up no cap, down capped (avoid underpricing exploit)\n        Slot0 memory slot0_ = _slot0;\n\n        Slot1 memory slot1_; // only read if needed\n\n        uint256 maxReachedRate_;\n        bool isRateBelowMaxReached_;\n\n        if (_isHeartbeatTrigger(slot0_)) {\n            slot1_ = _slot1;\n            (exchangeRate_, maxReachedRate_, , isRateBelowMaxReached_) = _getUpdateRates(\n                uint256(slot1_.maxReachedAPRCappedRate),\n                uint256(slot0_.lastUpdateTime),\n                uint256(slot1_.maxAPRPercent)\n            );\n        } else {\n            exchangeRate_ = uint256(slot0_.rate);\n            isRateBelowMaxReached_ =\n                slot0_.flags & _FLAG_BITMASK_IS_RATE_BELOW_MAX_REACHED == _FLAG_BITMASK_IS_RATE_BELOW_MAX_REACHED;\n        }\n\n        if (!isRateBelowMaxReached_) {\n            return _invertRateIfNeeded(exchangeRate_);\n        }\n\n        if (slot1_.maxReachedAPRCappedRate == 0) {\n            slot1_ = _slot1;\n        }\n\n        return\n            _invertRateIfNeeded(\n                _calcDownCappedRate(\n                    exchangeRate_,\n                    maxReachedRate_ > 0 ? maxReachedRate_ : uint256(slot1_.maxReachedAPRCappedRate),\n                    uint256(slot1_.maxDownFromMaxReachedPercentDebt)\n                )\n            );\n    }\n\n    /// @inheritdoc IFluidCappedRate\n    function getExchangeRateLiquidateDebt() public view virtual returns (uint256 exchangeRate_) {\n        // for debt -> up max APR capped (avoid forced liquidations attack), down capped\n        Slot0 memory slot0_ = _slot0;\n        Slot1 memory slot1_; // only read if needed\n\n        uint256 maxReachedRate_;\n        bool isRateBelowMaxReached_;\n        bool isUpMaxAPRCapped_;\n\n        if (_isHeartbeatTrigger(slot0_)) {\n            slot1_ = _slot1;\n            (exchangeRate_, maxReachedRate_, isUpMaxAPRCapped_, isRateBelowMaxReached_) = _getUpdateRates(\n                uint256(slot1_.maxReachedAPRCappedRate),\n                uint256(slot0_.lastUpdateTime),\n                uint256(slot1_.maxAPRPercent)\n            );\n        } else {\n            exchangeRate_ = uint256(slot0_.rate);\n            isRateBelowMaxReached_ =\n                slot0_.flags & _FLAG_BITMASK_IS_RATE_BELOW_MAX_REACHED == _FLAG_BITMASK_IS_RATE_BELOW_MAX_REACHED;\n            isUpMaxAPRCapped_ = slot0_.flags & _FLAG_BITMASK_IS_UP_MAX_APR_CAPPED == _FLAG_BITMASK_IS_UP_MAX_APR_CAPPED;\n        }\n\n        if (\n            isUpMaxAPRCapped_ &&\n            (slot0_.flags & _FLAG_BITMASK_AVOID_FORCED_LIQUIDATIONS_DEBT ==\n                _FLAG_BITMASK_AVOID_FORCED_LIQUIDATIONS_DEBT)\n        ) {\n            // is _avoidForcedLiquidationsDebt\n            // case _rate > _maxReachedAPRCappedRate\n            if (maxReachedRate_ == 0) {\n                slot1_ = _slot1;\n                maxReachedRate_ = uint256(slot1_.maxReachedAPRCappedRate);\n            }\n            // add max up cap percent on top\n            maxReachedRate_ =\n                (maxReachedRate_ * (_SIX_DECIMALS + uint256(slot1_.maxDebtUpCapPercent) * uint256(100))) /\n                _SIX_DECIMALS;\n\n            // return max(exchangeRate_, maxReachedRate_) where maxReachedRate_ is maxAPRReachedRate + maxDebtUpCapPercent on top\n            return _invertRateIfNeeded(exchangeRate_ > maxReachedRate_ ? maxReachedRate_ : exchangeRate_);\n        }\n\n        if (!isRateBelowMaxReached_) {\n            return _invertRateIfNeeded(exchangeRate_);\n        }\n\n        if (slot1_.maxReachedAPRCappedRate == 0) {\n            slot1_ = _slot1;\n        }\n\n        return\n            _invertRateIfNeeded(\n                _calcDownCappedRate(\n                    exchangeRate_,\n                    maxReachedRate_ > 0 ? maxReachedRate_ : uint256(slot1_.maxReachedAPRCappedRate),\n                    uint256(slot1_.maxDownFromMaxReachedPercentDebt)\n                )\n            );\n    }\n\n    /// @notice Rebalance the stored rates according to the newly fetched rate from the external source.\n    /// @dev The rate is only updated if the difference between the current rate and the new rate is greater than or\n    ///      equal to the minimum update difference percentage for either rate or maxRate OR if the heartbeat is reached\n    function rebalance() external {\n        _updateRates(_isHeartbeatTrigger(_slot0));\n    }\n\n    /// @notice Returns rates: capped and uncapped, and current cap status, all rates are NOT inverted even when invert flag is set to true\n    /// @return rate_ The rate_ value: last fetched value from external source with no cap up and no cap down as in storage\n    /// @return maxReachedRate_ The maximum reached upward capped rate for col: within APR percent limit as in storage\n    /// @return maxUpCappedRateDebt_ The maximum reached upward capped rate for debt: up to `maxReachedRate_` + `maxDebtUpCapPercent` on top\n    /// @return isRateBelowMaxReached_ Indicates if the rate is currently below the maximum reached APR capped rate flag as in storage\n    /// @return isUpMaxAPRCapped_ Indicates if the rate is currently capped due to exceeding the maximum APR limit flag as in storage\n    /// @return downCappedRateCol_ The capped downward rate on col side\n    /// @return downCappedRateDebt_ The capped downward rate on debt side\n    /// @return isDownCappedCol_ Indicates if the rate is currently getting downward capped on col side\n    /// @return isDownCappedDebt_ Indicates if the rate is currently getting downward capped on debt side\n    /// @return isUpCapped_ Indicates if the rate is currently getting upward capped\n    function getRatesAndCaps()\n        public\n        view\n        returns (\n            uint256 rate_,\n            uint256 maxReachedRate_,\n            uint256 maxUpCappedRateDebt_,\n            bool isRateBelowMaxReached_,\n            bool isUpMaxAPRCapped_,\n            uint256 downCappedRateCol_,\n            uint256 downCappedRateDebt_,\n            bool isDownCappedCol_,\n            bool isDownCappedDebt_,\n            bool isUpCapped_\n        )\n    {\n        Slot0 memory slot0_ = _slot0;\n        Slot1 memory slot1_ = _slot1;\n\n        if (_isHeartbeatTrigger(slot0_)) {\n            (rate_, maxReachedRate_, isUpMaxAPRCapped_, isRateBelowMaxReached_) = _getUpdateRates(\n                uint256(slot1_.maxReachedAPRCappedRate),\n                uint256(slot0_.lastUpdateTime),\n                uint256(slot1_.maxAPRPercent)\n            );\n        } else {\n            rate_ = uint256(slot0_.rate);\n            maxReachedRate_ = uint256(slot1_.maxReachedAPRCappedRate);\n            isRateBelowMaxReached_ =\n                slot0_.flags & _FLAG_BITMASK_IS_RATE_BELOW_MAX_REACHED == _FLAG_BITMASK_IS_RATE_BELOW_MAX_REACHED;\n            isUpMaxAPRCapped_ = slot0_.flags & _FLAG_BITMASK_IS_UP_MAX_APR_CAPPED == _FLAG_BITMASK_IS_UP_MAX_APR_CAPPED;\n        }\n\n        downCappedRateCol_ = _calcDownCappedRate(0, maxReachedRate_, uint256(slot1_.maxDownFromMaxReachedPercentCol));\n        downCappedRateDebt_ = _calcDownCappedRate(0, maxReachedRate_, uint256(slot1_.maxDownFromMaxReachedPercentDebt));\n\n        maxUpCappedRateDebt_ =\n            (maxReachedRate_ * (_SIX_DECIMALS + uint256(slot1_.maxDebtUpCapPercent) * uint256(100))) /\n            _SIX_DECIMALS;\n        if (rate_ > maxReachedRate_ && rate_ < maxUpCappedRateDebt_) {\n            // maxUpCappedRateDebt_ capped at + maxDebtUpCapPercent, but less if rate is less\n            maxUpCappedRateDebt_ = rate_;\n        }\n\n        isDownCappedCol_ = rate_ < downCappedRateCol_;\n        isDownCappedDebt_ = rate_ < downCappedRateDebt_;\n        isUpCapped_ = rate_ > maxReachedRate_;\n    }\n\n    /// @notice returns how much the new rate OR new max rate would be different from current value in storage in percent (10000 = 1%, 1 = 0.0001%).\n    function configPercentDiff() public view virtual returns (uint256 configPercentDiff_) {\n        Slot0 memory slot0_ = _slot0;\n        Slot1 memory slot1_ = _slot1;\n\n        (uint256 newRate_, uint256 newMaxReachedRate_, , ) = _getUpdateRates(\n            uint256(slot1_.maxReachedAPRCappedRate),\n            uint256(slot0_.lastUpdateTime),\n            uint256(slot1_.maxAPRPercent)\n        );\n\n        uint256 rateDiff_ = _percentDiffForValue(uint256(slot0_.rate), newRate_);\n        uint256 maxRateDiff_ = _percentDiffForValue(uint256(slot1_.maxReachedAPRCappedRate), newMaxReachedRate_);\n\n        return rateDiff_ > maxRateDiff_ ? rateDiff_ : maxRateDiff_;\n    }\n\n    /// @notice returns all config vars, last update timestamp, and external rate source oracle address\n    function configData()\n        external\n        view\n        returns (\n            address liquidity_,\n            uint16 minUpdateDiffPercent_,\n            uint24 minHeartbeat_,\n            uint40 lastUpdateTime_,\n            address rateSource_,\n            bool invertRate_,\n            bool avoidForcedLiquidationsCol_,\n            bool avoidForcedLiquidationsDebt_,\n            uint256 maxAPRPercent_,\n            uint24 maxDownFromMaxReachedPercentCol_,\n            uint24 maxDownFromMaxReachedPercentDebt_,\n            uint256 maxDebtUpCapPercent_\n        )\n    {\n        Slot0 memory slot0_ = _slot0;\n        Slot1 memory slot1_ = _slot1;\n        return (\n            _LIQUIDITY,\n            slot0_.minUpdateDiffPercent,\n            slot0_.minHeartbeat,\n            slot0_.lastUpdateTime,\n            _RATE_SOURCE,\n            _INVERT_RATE,\n            (slot0_.flags & _FLAG_BITMASK_AVOID_FORCED_LIQUIDATIONS_COL) == _FLAG_BITMASK_AVOID_FORCED_LIQUIDATIONS_COL,\n            (slot0_.flags & _FLAG_BITMASK_AVOID_FORCED_LIQUIDATIONS_DEBT) ==\n                _FLAG_BITMASK_AVOID_FORCED_LIQUIDATIONS_DEBT,\n            uint256(slot1_.maxAPRPercent) * uint256(100),\n            slot1_.maxDownFromMaxReachedPercentCol,\n            slot1_.maxDownFromMaxReachedPercentDebt,\n            uint256(slot1_.maxDebtUpCapPercent) * uint256(100)\n        );\n    }\n\n    /// @notice returns true if last update timestamp is > min heart time update time ago so heartbeat update should trigger\n    function isHeartbeatTrigger() public view returns (bool) {\n        return _isHeartbeatTrigger(_slot0);\n    }\n}\n\n/// @notice This contract stores an exchange rate in intervals to optimize gas cost.\n/// @notice Properly implements all interfaces for use as IFluidCenterPrice and IFluidOracle.\nabstract contract FluidCappedRate is FluidCappedRateBase, FluidCenterPrice {\n    constructor(\n        CappedRateConstructorParams memory params_\n    ) FluidCappedRateBase(params_) FluidCenterPrice(params_.infoName) {}\n\n    /// @inheritdoc FluidCenterPrice\n    function centerPrice() external override(IFluidCappedRate, FluidCenterPrice) returns (uint256 price_) {\n        // for centerPrice -> no up cap, no down cap\n        Slot0 memory slot0_ = _slot0;\n        if (_isHeartbeatTrigger(slot0_)) {\n            return _invertRateIfNeeded(_updateRates(true));\n        }\n\n        return _invertRateIfNeeded(uint256(slot0_.rate));\n    }\n\n    /// @inheritdoc FluidCenterPrice\n    function infoName() public view override(IFluidOracle, FluidCenterPrice) returns (string memory) {\n        return super.infoName();\n    }\n\n    /// @inheritdoc IFluidOracle\n    function targetDecimals() public pure override(IFluidOracle, FluidCenterPrice) returns (uint8) {\n        return _TARGET_DECIMALS;\n    }\n}\n"
    },
    "contracts/oracle/fluidCenterPrice.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IFluidCenterPrice } from \"./interfaces/iFluidCenterPrice.sol\";\nimport { ErrorTypes } from \"./errorTypes.sol\";\nimport { Error as OracleError } from \"./error.sol\";\n\n/// @title   FluidCenterPrice\n/// @notice  Base contract that any Fluid Center Price must implement\nabstract contract FluidCenterPrice is IFluidCenterPrice, OracleError {\n    /// @dev short helper string to easily identify the center price oracle. E.g. token symbols\n    //\n    // using a bytes32 because string can not be immutable.\n    bytes32 private immutable _infoName;\n\n    uint8 internal constant _TARGET_DECIMALS = 27; // target decimals for center price and contract rates is always 27\n\n    constructor(string memory infoName_) {\n        if (bytes(infoName_).length > 32 || bytes(infoName_).length == 0) {\n            revert FluidOracleError(ErrorTypes.FluidOracle__InvalidInfoName);\n        }\n\n        // convert string to bytes32\n        bytes32 infoNameBytes32_;\n        assembly {\n            infoNameBytes32_ := mload(add(infoName_, 32))\n        }\n        _infoName = infoNameBytes32_;\n    }\n\n    /// @inheritdoc IFluidCenterPrice\n    function targetDecimals() public pure virtual returns (uint8) {\n        return _TARGET_DECIMALS;\n    }\n\n    /// @inheritdoc IFluidCenterPrice\n    function infoName() public view virtual returns (string memory) {\n        // convert bytes32 to string\n        uint256 length_;\n        while (length_ < 32 && _infoName[length_] != 0) {\n            length_++;\n        }\n        bytes memory infoNameBytes_ = new bytes(length_);\n        for (uint256 i; i < length_; i++) {\n            infoNameBytes_[i] = _infoName[i];\n        }\n        return string(infoNameBytes_);\n    }\n\n    /// @inheritdoc IFluidCenterPrice\n    function centerPrice() external virtual returns (uint256 price_);\n}\n"
    },
    "contracts/oracle/interfaces/external/IRLPPrice.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\ninterface IRLPPrice {\n    struct Price {\n        uint256 price;\n        uint256 timestamp;\n    }\n\n    function lastPrice() external view returns (Price memory price);\n}\n"
    },
    "contracts/oracle/interfaces/iFluidCappedRate.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IFluidOracle } from \"./iFluidOracle.sol\";\n\ninterface IFluidCappedRate is IFluidOracle {\n    /// @notice Get the operate() exchange rate for debt asset side, with no cap upwards and capped decrease\n    function getExchangeRateOperateDebt() external view returns (uint256 exchangeRate_);\n\n    /// @notice Get the liquidate() exchange rate for debt asset side, with max APR cap upwards, and capped decrease\n    function getExchangeRateLiquidateDebt() external view returns (uint256 exchangeRate_);\n\n    /// @notice Retrieves the center price for use in a Fluid dex pool\n    /// @dev This function is marked as non-constant (potentially state-changing) to allow flexibility in price fetching mechanisms.\n    ///      While typically used as a read-only operation, this design permits write operations if needed for certain token pairs\n    ///      (e.g., fetching up-to-date exchange rates that may require state changes).\n    /// @return price_ The current price ratio of token1 to token0, expressed with 27 decimal places\n    function centerPrice() external returns (uint256 price_);\n}\n"
    },
    "contracts/oracle/interfaces/iFluidCenterPrice.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\ninterface IFluidCenterPrice {\n    /// @notice Retrieves the center price for the pool\n    /// @dev This function is marked as non-constant (potentially state-changing) to allow flexibility in price fetching mechanisms.\n    ///      While typically used as a read-only operation, this design permits write operations if needed for certain token pairs\n    ///      (e.g., fetching up-to-date exchange rates that may require state changes).\n    /// @return price_ The current price ratio of token1 to token0, expressed with 27 decimal places\n    function centerPrice() external returns (uint256 price_);\n\n    /// @notice helper string to easily identify the oracle. E.g. token symbols\n    function infoName() external view returns (string memory);\n\n    /// @notice target decimals of the returned rate. for center price contracts it is always 27\n    function targetDecimals() external view returns (uint8);\n}\n"
    },
    "contracts/oracle/interfaces/iFluidOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\ninterface IFluidOracle {\n    /// @dev Deprecated. Use `getExchangeRateOperate()` and `getExchangeRateLiquidate()` instead. Only implemented for\n    ///      backwards compatibility.\n    function getExchangeRate() external view returns (uint256 exchangeRate_);\n\n    /// @notice Get the `exchangeRate_` between the underlying asset and the peg asset in 1e27 for operates\n    function getExchangeRateOperate() external view returns (uint256 exchangeRate_);\n\n    /// @notice Get the `exchangeRate_` between the underlying asset and the peg asset in 1e27 for liquidations\n    function getExchangeRateLiquidate() external view returns (uint256 exchangeRate_);\n\n    /// @notice helper string to easily identify the oracle. E.g. token symbols\n    function infoName() external view returns (string memory);\n\n    /// @notice target decimals of the returned oracle rate when scaling to 1e27. E.g. for ETH / USDC it would be 15\n    /// because diff of ETH decimals to 1e27 is 9, and USDC has 6 decimals, so 6+9 = 15, e.g. 2029,047772120364926\n    /// For USDC / ETH: 21 + 18 = 39, e.g. 0,000492842018675092636829357843847601646\n    function targetDecimals() external view returns (uint8);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 10000000
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    },
    "libraries": {}
  }
}}