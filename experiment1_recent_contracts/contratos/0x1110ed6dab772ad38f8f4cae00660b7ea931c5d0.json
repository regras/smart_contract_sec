{{
  "language": "Solidity",
  "sources": {
    "contracts/oracle/aspTKNMinimalOracle.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport \"@openzeppelin/contracts/interfaces/IERC4626.sol\";\nimport \"./spTKNMinimalOracle.sol\";\n\ncontract aspTKNMinimalOracle is spTKNMinimalOracle {\n    address public immutable ASP_TKN; // QUOTE_TOKEN\n\n    constructor(address _aspTKN, bytes memory _requiredImmutables, bytes memory _optionalImmutables)\n        spTKNMinimalOracle(_requiredImmutables, _optionalImmutables)\n    {\n        ASP_TKN = _aspTKN;\n    }\n\n    function getPrices()\n        public\n        view\n        virtual\n        override\n        returns (bool _isBadData, uint256 _priceLow, uint256 _priceHigh)\n    {\n        uint256 _assetFactor = 10 ** 18;\n        uint256 _aspTknPerSpTkn = IERC4626(ASP_TKN).convertToShares(_assetFactor);\n        (_isBadData, _priceLow, _priceHigh) = super.getPrices();\n        _priceLow = (_priceLow * _aspTknPerSpTkn) / _assetFactor;\n        _priceHigh = (_priceHigh * _aspTknPerSpTkn) / _assetFactor;\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts/interfaces/IERC4626.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (interfaces/IERC4626.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../token/ERC20/IERC20.sol\";\nimport {IERC20Metadata} from \"../token/ERC20/extensions/IERC20Metadata.sol\";\n\n/**\n * @dev Interface of the ERC-4626 \"Tokenized Vault Standard\", as defined in\n * https://eips.ethereum.org/EIPS/eip-4626[ERC-4626].\n */\ninterface IERC4626 is IERC20, IERC20Metadata {\n    event Deposit(address indexed sender, address indexed owner, uint256 assets, uint256 shares);\n\n    event Withdraw(\n        address indexed sender,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /**\n     * @dev Returns the address of the underlying token used for the Vault for accounting, depositing, and withdrawing.\n     *\n     * - MUST be an ERC-20 token contract.\n     * - MUST NOT revert.\n     */\n    function asset() external view returns (address assetTokenAddress);\n\n    /**\n     * @dev Returns the total amount of the underlying asset that is “managed” by Vault.\n     *\n     * - SHOULD include any compounding that occurs from yield.\n     * - MUST be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT revert.\n     */\n    function totalAssets() external view returns (uint256 totalManagedAssets);\n\n    /**\n     * @dev Returns the amount of shares that the Vault would exchange for the amount of assets provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert.\n     *\n     * NOTE: This calculation MAY NOT reflect the “per-user” price-per-share, and instead should reflect the\n     * “average-user’s” price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n    function convertToShares(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Returns the amount of assets that the Vault would exchange for the amount of shares provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert.\n     *\n     * NOTE: This calculation MAY NOT reflect the “per-user” price-per-share, and instead should reflect the\n     * “average-user’s” price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n    function convertToAssets(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Returns the maximum amount of the underlying asset that can be deposited into the Vault for the receiver,\n     * through a deposit call.\n     *\n     * - MUST return a limited value if receiver is subject to some deposit limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of assets that may be deposited.\n     * - MUST NOT revert.\n     */\n    function maxDeposit(address receiver) external view returns (uint256 maxAssets);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their deposit at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of Vault shares that would be minted in a deposit\n     *   call in the same transaction. I.e. deposit should return the same or more shares as previewDeposit if called\n     *   in the same transaction.\n     * - MUST NOT account for deposit limits like those returned from maxDeposit and should always act as though the\n     *   deposit would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewDeposit SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n    function previewDeposit(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Mints shares Vault shares to receiver by depositing exactly amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   deposit execution, and are accounted for during deposit.\n     * - MUST revert if all of assets cannot be deposited (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault’s underlying asset token.\n     */\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\n\n    /**\n     * @dev Returns the maximum amount of the Vault shares that can be minted for the receiver, through a mint call.\n     * - MUST return a limited value if receiver is subject to some mint limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of shares that may be minted.\n     * - MUST NOT revert.\n     */\n    function maxMint(address receiver) external view returns (uint256 maxShares);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their mint at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of assets that would be deposited in a mint call\n     *   in the same transaction. I.e. mint should return the same or fewer assets as previewMint if called in the\n     *   same transaction.\n     * - MUST NOT account for mint limits like those returned from maxMint and should always act as though the mint\n     *   would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewMint SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by minting.\n     */\n    function previewMint(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the mint\n     *   execution, and are accounted for during mint.\n     * - MUST revert if all of shares cannot be minted (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault’s underlying asset token.\n     */\n    function mint(uint256 shares, address receiver) external returns (uint256 assets);\n\n    /**\n     * @dev Returns the maximum amount of the underlying asset that can be withdrawn from the owner balance in the\n     * Vault, through a withdraw call.\n     *\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n    function maxWithdraw(address owner) external view returns (uint256 maxAssets);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their withdrawal at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of Vault shares that would be burned in a withdraw\n     *   call in the same transaction. I.e. withdraw should return the same or fewer shares as previewWithdraw if\n     *   called\n     *   in the same transaction.\n     * - MUST NOT account for withdrawal limits like those returned from maxWithdraw and should always act as though\n     *   the withdrawal would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewWithdraw SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n    function previewWithdraw(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Burns shares from owner and sends exactly assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   withdraw execution, and are accounted for during withdraw.\n     * - MUST revert if all of assets cannot be withdrawn (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * Note that some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n    function withdraw(uint256 assets, address receiver, address owner) external returns (uint256 shares);\n\n    /**\n     * @dev Returns the maximum amount of Vault shares that can be redeemed from the owner balance in the Vault,\n     * through a redeem call.\n     *\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST return balanceOf(owner) if owner is not subject to any withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n    function maxRedeem(address owner) external view returns (uint256 maxShares);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their redeemption at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of assets that would be withdrawn in a redeem call\n     *   in the same transaction. I.e. redeem should return the same or more assets as previewRedeem if called in the\n     *   same transaction.\n     * - MUST NOT account for redemption limits like those returned from maxRedeem and should always act as though the\n     *   redemption would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewRedeem SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by redeeming.\n     */\n    function previewRedeem(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Burns exactly shares from owner and sends assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   redeem execution, and are accounted for during redeem.\n     * - MUST revert if all of shares cannot be redeemed (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * NOTE: some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n    function redeem(uint256 shares, address receiver, address owner) external returns (uint256 assets);\n}\n"
    },
    "contracts/oracle/spTKNMinimalOracle.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"../interfaces/IDecentralizedIndex.sol\";\nimport \"../interfaces/IFraxlendPair.sol\";\nimport \"../interfaces/IStakingPoolToken.sol\";\nimport \"../interfaces/IUniswapV2Pair.sol\";\nimport \"../interfaces/IMinimalOracle.sol\";\nimport \"../interfaces/ISPTknOracle.sol\";\nimport \"../interfaces/IMinimalSinglePriceOracle.sol\";\nimport \"../interfaces/IV2Reserves.sol\";\n\ncontract spTKNMinimalOracle is IMinimalOracle, ISPTknOracle, Ownable {\n    enum PriceSourceType {\n        DEX_CL,\n        CHAINLINK,\n        DIA\n    }\n\n    struct PriceSource {\n        PriceSourceType priceType;\n        address singlePriceOracle;\n        address quoteFeed;\n        address baseFeed;\n    }\n\n    /// @dev The base token we will price against in the oracle. Will be either pairedLpAsset\n    /// @dev or the borrow token in a lending pair\n    address public immutable BASE_TOKEN;\n    bool public immutable BASE_IS_POD;\n    bool public immutable BASE_IS_FRAX_PAIR;\n    address internal immutable BASE_IN_CL;\n\n    /// @dev The concentrated liquidity UniV3 pool where we get the TWAP to price the underlying TKN\n    /// @dev of the pod represented through spTkn and then convert it to the spTKN price\n    address public immutable UNDERLYING_TKN_CL_POOL;\n\n    /// @dev The Chainlink price feed we can use to convert the price we fetch through UNDERLYING_TKN_CL_POOL\n    /// @dev into a BASE_TOKEN normalized price,\n    /// @dev NOTE: primarily only needed if the paired token of the CL_POOL is not BASE_TOKEN\n    address public immutable BASE_CONVERSION_CHAINLINK_FEED;\n    address public immutable BASE_CONVERSION_CL_POOL;\n    address public immutable BASE_CONVERSION_DIA_FEED;\n\n    /// @dev Chainlink config to fetch a 2nd price for the oracle\n    /// @dev The assumption would be that the paired asset of both oracles are the same\n    /// @dev For example, if base=ETH, quote=BTC, the feeds we could use would be ETH/USD & BTC/USD\n    address public immutable CHAINLINK_BASE_PRICE_FEED;\n    address public immutable CHAINLINK_QUOTE_PRICE_FEED;\n\n    /// @dev DIA oracle config to fetch a 2nd price for the oracle\n    address public immutable DIA_QUOTE_PRICE_FEED;\n\n    /// @dev Single price oracle helpers to get already formatted prices that are easy to convert/use\n    address public immutable CHAINLINK_SINGLE_PRICE_ORACLE;\n    address public immutable UNISWAP_V3_SINGLE_PRICE_ORACLE;\n    address public immutable DIA_SINGLE_PRICE_ORACLE;\n\n    /// @dev Different networks will use different forked implementations of UniswapV2, so\n    /// @dev this allows us to define a uniform interface to fetch the reserves of each asset in a pair\n    IV2Reserves public immutable V2_RESERVES;\n\n    // the price feed sources stored and used for pricing in oracle\n    PriceSource[] public priceFeeds;\n\n    /// @dev The pod staked LP token and oracle quote token that custodies UniV2 LP tokens\n    address public spTkn; // QUOTE_TOKEN\n    address public pod;\n    address public underlyingTkn;\n\n    uint32 twapInterval = 10 minutes;\n\n    // errors\n    error InvalidTwapInterval();\n    error NoPriceAvailableFromSources();\n    error NotValidSpTkn();\n    error OnlyOneOrNoBaseConversionsRequired();\n    error PodLocked();\n    error PrimaryOracleConfigInvalid();\n    error QuoteAndBaseChainlinkFeedsNotProvided();\n    error SpTknAlreadySet();\n    error UnableToPriceBasePerSpTkn();\n\n    // events\n    event SetSpTknAndDependencies(address _pod);\n    event SetTwapInterval(uint32 oldMax, uint32 newMax);\n\n    constructor(bytes memory _requiredImmutables, bytes memory _optionalImmutables) Ownable(_msgSender()) {\n        address _spTkn;\n        address _v2Reserves;\n        (\n            CHAINLINK_SINGLE_PRICE_ORACLE,\n            UNISWAP_V3_SINGLE_PRICE_ORACLE,\n            DIA_SINGLE_PRICE_ORACLE,\n            BASE_TOKEN,\n            BASE_IS_POD,\n            BASE_IS_FRAX_PAIR,\n            _spTkn,\n            UNDERLYING_TKN_CL_POOL\n        ) = abi.decode(_requiredImmutables, (address, address, address, address, bool, bool, address, address));\n        (\n            BASE_CONVERSION_CHAINLINK_FEED,\n            BASE_CONVERSION_CL_POOL,\n            BASE_CONVERSION_DIA_FEED,\n            CHAINLINK_BASE_PRICE_FEED,\n            CHAINLINK_QUOTE_PRICE_FEED,\n            DIA_QUOTE_PRICE_FEED,\n            _v2Reserves\n        ) = abi.decode(_optionalImmutables, (address, address, address, address, address, address, address));\n        V2_RESERVES = IV2Reserves(_v2Reserves);\n\n        if (\n            (CHAINLINK_QUOTE_PRICE_FEED != address(0) && CHAINLINK_BASE_PRICE_FEED == address(0))\n                || (CHAINLINK_QUOTE_PRICE_FEED == address(0) && CHAINLINK_BASE_PRICE_FEED != address(0))\n        ) {\n            revert QuoteAndBaseChainlinkFeedsNotProvided();\n        }\n\n        // build price feeds array to be used for pricing in oracle\n        if (UNDERLYING_TKN_CL_POOL != address(0)) {\n            priceFeeds.push(\n                PriceSource({\n                    priceType: PriceSourceType.DEX_CL,\n                    singlePriceOracle: UNISWAP_V3_SINGLE_PRICE_ORACLE,\n                    quoteFeed: UNDERLYING_TKN_CL_POOL,\n                    baseFeed: address(0)\n                })\n            );\n        }\n        if (CHAINLINK_QUOTE_PRICE_FEED != address(0)) {\n            priceFeeds.push(\n                PriceSource({\n                    priceType: PriceSourceType.CHAINLINK,\n                    singlePriceOracle: CHAINLINK_SINGLE_PRICE_ORACLE,\n                    quoteFeed: CHAINLINK_QUOTE_PRICE_FEED,\n                    baseFeed: CHAINLINK_BASE_PRICE_FEED\n                })\n            );\n        }\n        if (DIA_QUOTE_PRICE_FEED != address(0)) {\n            priceFeeds.push(\n                PriceSource({\n                    priceType: PriceSourceType.DIA,\n                    singlePriceOracle: DIA_SINGLE_PRICE_ORACLE,\n                    quoteFeed: DIA_QUOTE_PRICE_FEED,\n                    baseFeed: address(0)\n                })\n            );\n        }\n        // first source must have quote feed and there should only be two sources provided\n        if (priceFeeds[0].quoteFeed == address(0) || priceFeeds.length > 2) {\n            revert PrimaryOracleConfigInvalid();\n        }\n\n        // only one (or neither) of the base conversion config should be populated\n        address _baseConvFinal =\n            BASE_CONVERSION_DIA_FEED != address(0) ? BASE_CONVERSION_DIA_FEED : BASE_CONVERSION_CL_POOL;\n        if (BASE_CONVERSION_CHAINLINK_FEED != address(0) && _baseConvFinal != address(0)) {\n            revert OnlyOneOrNoBaseConversionsRequired();\n        }\n\n        address _baseInCl = BASE_TOKEN;\n        if (BASE_IS_POD) {\n            IDecentralizedIndex.IndexAssetInfo[] memory _baseAssets = IDecentralizedIndex(BASE_TOKEN).getAllAssets();\n            _baseInCl = _baseAssets[0].token;\n        } else if (BASE_IS_FRAX_PAIR) {\n            _baseInCl = IFraxlendPair(BASE_TOKEN).asset();\n        }\n        BASE_IN_CL = _baseInCl;\n\n        _setSpTknAndDependencies(_spTkn);\n    }\n\n    function getPodPerBasePrice() external view override returns (uint256 _pricePTknPerBase18) {\n        _pricePTknPerBase18 = 10 ** (18 * 2) / _calculateBasePerPTkn(0);\n    }\n\n    /// @notice The ```getPrices``` function gets the mathematical price of spTkn / BASE_TOKEN, so in plain english will\n    /// @notice be the number of spTkn per every BASE_TOKEN at 1e18 precision\n    /// @return _isBadData Whether the price(s) returned should be considered bad\n    /// @return _priceLow The lower of the dual prices returned\n    /// @return _priceHigh The higher of the dual prices returned\n    function getPrices()\n        public\n        view\n        virtual\n        override\n        returns (bool _isBadData, uint256 _priceLow, uint256 _priceHigh)\n    {\n        uint8 _baseDec = IERC20Metadata(BASE_TOKEN).decimals();\n        uint256[] memory _prices = new uint256[](2);\n        for (uint256 _i; _i < priceFeeds.length; _i++) {\n            if (priceFeeds[_i].priceType == PriceSourceType.DEX_CL) {\n                uint256 _priceSpTKNBase = _calculateSpTknPerBase(0);\n                _isBadData = _isBadData || _priceSpTKNBase == 0;\n                _prices[_i] = _priceSpTKNBase * 10 ** (_baseDec > 18 ? _baseDec - 18 : 18 - _baseDec);\n            } else if (priceFeeds[_i].priceType == PriceSourceType.CHAINLINK) {\n                uint256 _clPrice18 = _chainlinkBasePerPaired18();\n                uint256 _clPriceBaseSpTKN = _calculateSpTknPerBase(_clPrice18);\n                _prices[_i] = _clPriceBaseSpTKN * 10 ** (_baseDec > 18 ? _baseDec - 18 : 18 - _baseDec);\n                _isBadData = _isBadData || _clPrice18 == 0;\n            } else if (priceFeeds[_i].priceType == PriceSourceType.DIA) {\n                (bool _subBadData, uint256 _diaPrice18) = IMinimalSinglePriceOracle(DIA_SINGLE_PRICE_ORACLE)\n                    .getPriceUSD18(BASE_CONVERSION_CHAINLINK_FEED, underlyingTkn, priceFeeds[_i].quoteFeed, 0);\n                (bool _subBadData2, uint256 _diaPrice182) = _applyBaseConversionToPrice(_diaPrice18, false);\n                uint256 _diaPriceBaseSpTKN = _calculateSpTknPerBase(_diaPrice182);\n                _prices[_i] = _diaPriceBaseSpTKN * 10 ** (_baseDec > 18 ? _baseDec - 18 : 18 - _baseDec);\n                _isBadData = _isBadData || _subBadData || _subBadData2;\n            }\n        }\n\n        if (_prices[0] == 0 && _prices[1] == 0) {\n            revert NoPriceAvailableFromSources();\n        }\n\n        if (_prices[0] == 0) {\n            _priceLow = _prices[1];\n            _priceHigh = _prices[1];\n        } else if (_prices[1] == 0) {\n            _priceLow = _prices[0];\n            _priceHigh = _prices[0];\n        } else {\n            // If the prices are the same it means the CL price was pulled as the UniV3 price\n            (_priceLow, _priceHigh) = _prices[0] > _prices[1] ? (_prices[1], _prices[0]) : (_prices[0], _prices[1]);\n        }\n    }\n\n    function _calculateSpTknPerBase(uint256 _price18) internal view returns (uint256 _spTknBasePrice18) {\n        uint256 _priceBasePerPTkn18 = _calculateBasePerPTkn(_price18);\n        address _pair = _getPair();\n\n        (uint112 _reserve0, uint112 _reserve1) = V2_RESERVES.getReserves(_pair);\n        uint256 _k = uint256(_reserve0) * _reserve1;\n        uint256 _kDec = 10 ** IERC20Metadata(IUniswapV2Pair(_pair).token0()).decimals()\n            * 10 ** IERC20Metadata(IUniswapV2Pair(_pair).token1()).decimals();\n        uint256 _avgBaseAssetInLp27 = _sqrt((_priceBasePerPTkn18 * _k) / _kDec) * 10 ** 18;\n        uint256 _pairSupply = IERC20(_pair).totalSupply();\n        if (_pairSupply == 0) {\n            return 0;\n        }\n        uint256 _basePerSpTkn27 = (2 * _avgBaseAssetInLp27 * 10 ** IERC20Metadata(_pair).decimals()) / _pairSupply;\n        if (_basePerSpTkn27 == 0) {\n            revert UnableToPriceBasePerSpTkn();\n        }\n        _spTknBasePrice18 = 10 ** (27 + 18) / _basePerSpTkn27;\n\n        // if the base asset is a pod, we will assume that the CL/chainlink pool(s) are\n        // pricing the underlying asset of the base asset pod, and therefore we will\n        // adjust the output price by CBR and unwrap fee for this pod for more accuracy and\n        // better handling accounting for liquidation path\n        if (BASE_IS_POD) {\n            _spTknBasePrice18 = _checkAndHandleBaseTokenPodConfig(_spTknBasePrice18);\n        } else if (BASE_IS_FRAX_PAIR) {\n            _spTknBasePrice18 = IFraxlendPair(BASE_TOKEN).convertToAssets(_spTknBasePrice18);\n        }\n    }\n\n    function _calculateBasePerPTkn(uint256 _price18) internal view returns (uint256 _basePerPTkn18) {\n        // pull from UniV3 TWAP if passed as 0\n        if (_price18 == 0) {\n            bool _isBadData;\n            (_isBadData, _price18) = _getDefaultPriceBasePerQuote18();\n            if (_isBadData) {\n                return 0;\n            }\n        }\n        _basePerPTkn18 = _accountForCBRInPrice(pod, underlyingTkn, _price18);\n\n        // adjust current price for spTKN pod unwrap fee, which will end up making the end price\n        // (spTKN per base) higher, meaning it will take more spTKN to equal the value\n        // of base token. This will more accurately ensure healthy LTVs when lending since\n        // a liquidation path will need to account for unwrap fees\n        _basePerPTkn18 = _accountForUnwrapFeeInPrice(pod, _basePerPTkn18);\n    }\n\n    function _getDefaultPriceBasePerQuote18() internal view returns (bool _isBadData, uint256 _price18) {\n        if (priceFeeds[0].priceType == PriceSourceType.CHAINLINK) {\n            (_isBadData, _price18) = IMinimalSinglePriceOracle(priceFeeds[0].singlePriceOracle).getPriceUSD18(\n                priceFeeds[0].quoteFeed, priceFeeds[0].baseFeed, address(0), 0\n            );\n        } else {\n            (_isBadData, _price18) = IMinimalSinglePriceOracle(priceFeeds[0].singlePriceOracle).getPriceUSD18(\n                BASE_CONVERSION_CHAINLINK_FEED, underlyingTkn, priceFeeds[0].quoteFeed, twapInterval\n            );\n        }\n        if (_isBadData) {\n            return (true, 0);\n        }\n        (_isBadData, _price18) = _applyBaseConversionToPrice(_price18, false);\n    }\n\n    function _applyBaseConversionToPrice(uint256 _inputPrice18, bool _includeChainlink)\n        internal\n        view\n        returns (bool _isBadData, uint256 _price18)\n    {\n        _price18 = _inputPrice18;\n        if (_includeChainlink && BASE_CONVERSION_CHAINLINK_FEED != address(0)) {\n            (bool _subBadData, uint256 _baseConvPrice18) = IMinimalSinglePriceOracle(CHAINLINK_SINGLE_PRICE_ORACLE)\n                .getPriceUSD18(CHAINLINK_QUOTE_PRICE_FEED, CHAINLINK_BASE_PRICE_FEED, address(0), 0);\n            if (_subBadData) {\n                return (true, 0);\n            }\n            _price18 = (10 ** 18 * _price18) / _baseConvPrice18;\n        } else if (BASE_CONVERSION_DIA_FEED != address(0)) {\n            (bool _subBadData, uint256 _baseConvPrice18) = IMinimalSinglePriceOracle(DIA_SINGLE_PRICE_ORACLE)\n                .getPriceUSD18(address(0), BASE_IN_CL, BASE_CONVERSION_DIA_FEED, 0);\n            if (_subBadData) {\n                return (true, 0);\n            }\n            _price18 = (10 ** 18 * _price18) / _baseConvPrice18;\n        } else if (BASE_CONVERSION_CL_POOL != address(0)) {\n            (bool _subBadData, uint256 _baseConvPrice18) = IMinimalSinglePriceOracle(UNISWAP_V3_SINGLE_PRICE_ORACLE)\n                .getPriceUSD18(address(0), BASE_IN_CL, BASE_CONVERSION_CL_POOL, twapInterval);\n            if (_subBadData) {\n                return (true, 0);\n            }\n            _price18 = (10 ** 18 * _price18) / _baseConvPrice18;\n        }\n    }\n\n    // final price with pod as baseTkn = price * baseCbr / (1 - basePodWrapFee)\n    function _checkAndHandleBaseTokenPodConfig(uint256 _currentPrice18) internal view returns (uint256 _finalPrice18) {\n        _finalPrice18 = _accountForCBRInPrice(BASE_TOKEN, address(0), _currentPrice18);\n        _finalPrice18 = (_finalPrice18 * 10000) / (10000 - IDecentralizedIndex(BASE_TOKEN).BOND_FEE());\n    }\n\n    function _chainlinkBasePerPaired18() internal view returns (uint256 _price18) {\n        (bool _isBadData, uint256 _basePerPaired18) = IMinimalSinglePriceOracle(CHAINLINK_SINGLE_PRICE_ORACLE)\n            .getPriceUSD18(CHAINLINK_QUOTE_PRICE_FEED, CHAINLINK_BASE_PRICE_FEED, address(0), 0);\n        if (_isBadData) {\n            return 0;\n        }\n        _price18 = _basePerPaired18;\n    }\n\n    function _getPair() private view returns (address) {\n        return IStakingPoolToken(spTkn).stakingToken();\n    }\n\n    function _accountForCBRInPrice(address _pod, address _underlying, uint256 _amtUnderlying)\n        internal\n        view\n        returns (uint256)\n    {\n        if (_underlying == address(0)) {\n            IDecentralizedIndex.IndexAssetInfo[] memory _assets = IDecentralizedIndex(_pod).getAllAssets();\n            _underlying = _assets[0].token;\n        }\n        uint256 _pTknAmt =\n            (_amtUnderlying * 10 ** IERC20Metadata(_pod).decimals()) / 10 ** IERC20Metadata(_underlying).decimals();\n\n        uint256 _assetConv;\n        if (_pod == BASE_TOKEN && IDecentralizedIndex(_pod).isFlashMinting() == 1) {\n            _assetConv = IDecentralizedIndex(_pod).convertToAssetsPreFlashMint(_pTknAmt);\n        } else if (IDecentralizedIndex(_pod).unlocked() == 1) {\n            _assetConv = IDecentralizedIndex(_pod).convertToAssets(_pTknAmt);\n        } else {\n            revert PodLocked();\n        }\n        return (_assetConv * 10000) / (10000 - IDecentralizedIndex(_pod).DEBOND_FEE());\n    }\n\n    function _accountForUnwrapFeeInPrice(address _pod, uint256 _currentPrice)\n        internal\n        view\n        returns (uint256 _newPrice)\n    {\n        uint16 _unwrapFee = IDecentralizedIndex(_pod).DEBOND_FEE();\n        _newPrice = _currentPrice - (_currentPrice * _unwrapFee) / 10000;\n    }\n\n    function _sqrt(uint256 x) private pure returns (uint256 y) {\n        uint256 z = (x + 1) / 2;\n        y = x;\n        while (z < y) {\n            y = z;\n            z = (x / z + z) / 2;\n        }\n    }\n\n    function _setSpTknAndDependencies(address _spTkn) internal {\n        if (address(_spTkn) == address(0)) {\n            return;\n        }\n        if (address(spTkn) != address(0)) {\n            revert SpTknAlreadySet();\n        }\n        spTkn = _spTkn;\n        pod = IStakingPoolToken(spTkn).INDEX_FUND();\n        IDecentralizedIndex.IndexAssetInfo[] memory _assets = IDecentralizedIndex(pod).getAllAssets();\n        underlyingTkn = _assets[0].token;\n        emit SetSpTknAndDependencies(address(pod));\n    }\n\n    function setSpTknAndDependencies(address _spTkn) external onlyOwner {\n        if (address(_spTkn) == address(0)) {\n            revert NotValidSpTkn();\n        }\n        _setSpTknAndDependencies(_spTkn);\n    }\n\n    function setTwapInterval(uint32 _interval) external onlyOwner {\n        if (_interval == 0) {\n            revert InvalidTwapInterval();\n        }\n        uint32 _oldInterval = twapInterval;\n        twapInterval = _interval;\n        emit SetTwapInterval(_oldInterval, _interval);\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "node_modules/@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC-20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "node_modules/@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "contracts/interfaces/IDecentralizedIndex.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./IDexAdapter.sol\";\n\ninterface IDecentralizedIndex is IERC20 {\n    enum IndexType {\n        WEIGHTED,\n        UNWEIGHTED\n    }\n\n    struct Config {\n        address partner;\n        uint256 debondCooldown;\n        bool hasTransferTax;\n        bool blacklistTKNpTKNPoolV2; // DEPRECATED: we should remove this in future versions\n    }\n\n    // all fees: 1 == 0.01%, 10 == 0.1%, 100 == 1%\n    struct Fees {\n        uint16 burn;\n        uint16 bond;\n        uint16 debond;\n        uint16 buy;\n        uint16 sell;\n        uint16 partner;\n    }\n\n    struct IndexAssetInfo {\n        address token;\n        uint256 weighting;\n        uint256 basePriceUSDX96;\n        address c1; // arbitrary contract/address field we can use for an index\n        uint256 q1; // arbitrary quantity/number field we can use for an index\n    }\n\n    /// @notice The ```Create``` event fires when a new decentralized index has been created\n    /// @param newIdx The CA of the new index contract\n    /// @param wallet The creator of the new index\n    event Create(address indexed newIdx, address indexed wallet);\n\n    /// @notice The ```FlashLoan``` event fires when someone flash loans assets from the pod\n    /// @param executor The sender of the request\n    /// @param recipient The recipient of the flashed funds\n    /// @param token The token being flash loaned\n    /// @param amount The amount of token to flash loan\n    event FlashLoan(address indexed executor, address indexed recipient, address token, uint256 amount);\n\n    /// @notice The ```FlashMint``` event fires when someone flash mints pTKN from the pod\n    /// @param executor The sender of the request\n    /// @param recipient The recipient of the flashed funds\n    /// @param amount The amount of pTKN to flash mint\n    event FlashMint(address indexed executor, address indexed recipient, uint256 amount);\n\n    /// @notice The ```Initialize``` event fires when the new pod has been initialized,\n    /// @notice which is at creation on some and in another txn for others (gas limits)\n    /// @param wallet The wallet that initialized\n    /// @param v2Pool The new UniV2 derivative pool that was created at initialization\n    event Initialize(address indexed wallet, address v2Pool);\n\n    /// @notice The ```Bond``` event fires when someone wraps into the pod which mints new pod tokens\n    /// @param wallet The wallet that wrapped\n    /// @param token The token that was used as a ref to wrap into, representing an underlying tkn\n    /// @param amountTokensBonded Amount of underlying tkns used to wrap/bond\n    /// @param amountTokensMinted Amount of new pod tokens (pTKN) minted\n    event Bond(address indexed wallet, address indexed token, uint256 amountTokensBonded, uint256 amountTokensMinted);\n\n    /// @notice The ```Debond``` event fires when someone unwraps from a pod and redeems underlying tkn(s)\n    /// @param wallet The wallet that unwrapped/debond\n    /// @param amountDebonded Amount of pTKNs burned/unwrapped\n    event Debond(address indexed wallet, uint256 amountDebonded);\n\n    /// @notice The ```AddLiquidity``` event fires when new liquidity (LP) for a pod is added\n    /// @param wallet The wallet that added LP\n    /// @param amountTokens Amount of pTKNs used for LP\n    /// @param amountDAI Amount of pairedLpAsset used for LP\n    event AddLiquidity(address indexed wallet, uint256 amountTokens, uint256 amountDAI);\n\n    /// @notice The ```RemoveLiquidity``` event fires when LP is removed for a pod\n    /// @param wallet The wallet that removed LP\n    /// @param amountLiquidity Amount of liquidity removed\n    event RemoveLiquidity(address indexed wallet, uint256 amountLiquidity);\n\n    event SetPartner(address indexed wallet, address newPartner);\n\n    event SetPartnerFee(address indexed wallet, uint16 newFee);\n\n    function BOND_FEE() external view returns (uint16);\n\n    function DEBOND_FEE() external view returns (uint16);\n\n    function DEX_HANDLER() external view returns (IDexAdapter);\n\n    function FLASH_FEE_AMOUNT_DAI() external view returns (uint256);\n\n    function PAIRED_LP_TOKEN() external view returns (address);\n\n    function config() external view returns (Config calldata);\n\n    function fees() external view returns (Fees calldata);\n\n    function unlocked() external view returns (uint8);\n\n    function isFlashMinting() external view returns (uint8);\n\n    function indexType() external view returns (IndexType);\n\n    function created() external view returns (uint256);\n\n    function lpStakingPool() external view returns (address);\n\n    function lpRewardsToken() external view returns (address);\n\n    function isAsset(address token) external view returns (bool);\n\n    function getAllAssets() external view returns (IndexAssetInfo[] memory);\n\n    function getInitialAmount(address sToken, uint256 sAmount, address tToken) external view returns (uint256);\n\n    function processPreSwapFeesAndSwap() external;\n\n    function totalAssets() external view returns (uint256 totalManagedAssets);\n\n    function totalAssets(address asset) external view returns (uint256 totalManagedAssets);\n\n    function convertToShares(uint256 assets) external view returns (uint256 shares);\n\n    function convertToAssets(uint256 shares) external view returns (uint256 assets);\n\n    function convertToAssetsPreFlashMint(uint256 shares) external view returns (uint256 assets);\n\n    function setup() external;\n\n    function bond(address token, uint256 amount, uint256 amountMintMin) external;\n\n    function debond(uint256 amount, address[] memory token, uint8[] memory percentage) external;\n\n    function addLiquidityV2(uint256 idxTokens, uint256 daiTokens, uint256 slippage, uint256 deadline)\n        external\n        returns (uint256);\n\n    function removeLiquidityV2(uint256 lpTokens, uint256 minTokens, uint256 minDAI, uint256 deadline) external;\n\n    function flash(address recipient, address token, uint256 amount, bytes calldata data) external;\n\n    function flashMint(address recipient, uint256 amount, bytes calldata data) external;\n\n    function setLpStakingPool(address lpStakingPool) external;\n}\n"
    },
    "contracts/interfaces/IFraxlendPair.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nimport \"@openzeppelin/contracts/interfaces/IERC20.sol\";\nimport {VaultAccount} from \"../libraries/VaultAccount.sol\";\n\ninterface IFraxlendPair is IERC20 {\n    struct CurrentRateInfo {\n        uint32 lastBlock;\n        uint32 feeToProtocolRate; // Fee amount 1e5 precision\n        uint64 lastTimestamp;\n        uint64 ratePerSec;\n        uint64 fullUtilizationRate;\n    }\n\n    struct ExchangeRateInfo {\n        address oracle;\n        uint32 maxOracleDeviation; // % of larger number, 1e5 precision\n        uint184 lastTimestamp;\n        uint256 lowExchangeRate;\n        uint256 highExchangeRate;\n    }\n\n    function exchangeRateInfo() external view returns (ExchangeRateInfo memory);\n\n    function totalBorrow() external view returns (VaultAccount memory);\n\n    function asset() external view returns (address);\n\n    function collateralContract() external view returns (address);\n\n    function convertToAssets(uint256 shares) external view returns (uint256 assets);\n\n    function convertToShares(uint256 assets) external view returns (uint256 shares);\n\n    function userCollateralBalance(address user) external view returns (uint256); // amount of collateral each user is backed\n\n    function userBorrowShares(address user) external view returns (uint256); // represents the shares held by individuals\n\n    function previewAddInterest()\n        external\n        view\n        returns (\n            uint256 _interestEarned,\n            uint256 _feesAmount,\n            uint256 _feesShare,\n            CurrentRateInfo memory _newCurrentRateInfo,\n            VaultAccount memory _totalAsset,\n            VaultAccount memory _totalBorrow\n        );\n\n    function addInterest(bool _returnAccounting)\n        external\n        returns (uint256, uint256, uint256, CurrentRateInfo memory, VaultAccount memory, VaultAccount memory);\n\n    function updateExchangeRate()\n        external\n        returns (bool _isBorrowAllowed, uint256 _lowExchangeRate, uint256 _highExchangeRate);\n\n    function deposit(uint256 _amount, address _receiver) external returns (uint256 _sharesReceived);\n\n    function redeem(uint256 _shares, address _receiver, address _owner) external returns (uint256 _amountToReturn);\n\n    function borrowAsset(uint256 _borrowAmount, uint256 _collateralAmount, address _receiver)\n        external\n        returns (uint256 _shares);\n\n    function repayAsset(uint256 _shares, address _borrower) external returns (uint256 _amountToRepay);\n\n    function addCollateral(uint256 _collateralAmount, address _borrower) external;\n\n    function removeCollateral(uint256 _collateralAmount, address _receiver) external;\n}\n"
    },
    "contracts/interfaces/IStakingPoolToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\ninterface IStakingPoolToken {\n    event Stake(address indexed executor, address indexed user, uint256 amount);\n\n    event Unstake(address indexed user, uint256 amount);\n\n    function INDEX_FUND() external view returns (address);\n\n    function POOL_REWARDS() external view returns (address);\n\n    function stakingToken() external view returns (address);\n\n    function stakeUserRestriction() external view returns (address);\n\n    function stake(address user, uint256 amount) external;\n\n    function unstake(uint256 amount) external;\n\n    function setPoolRewards(address poolRewards) external;\n\n    function setStakingToken(address stakingToken) external;\n}\n"
    },
    "contracts/interfaces/IUniswapV2Pair.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\ninterface IUniswapV2Pair {\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n}\n"
    },
    "contracts/interfaces/IMinimalOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\ninterface IMinimalOracle {\n    function getPrices() external view returns (bool _isBadData, uint256 _priceLow, uint256 _priceHigh);\n}\n"
    },
    "contracts/interfaces/ISPTknOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\ninterface ISPTknOracle {\n    function getPodPerBasePrice() external view returns (uint256 _price);\n}\n"
    },
    "contracts/interfaces/IMinimalSinglePriceOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\ninterface IMinimalSinglePriceOracle {\n    function getPriceUSD18(\n        address base,\n        address quote,\n        address a1, // any extra address parameter an implementation may need\n        uint256 q1 // any extra uint256 parameter an implementation may need\n    ) external view returns (bool isBadData, uint256 price18);\n}\n"
    },
    "contracts/interfaces/IV2Reserves.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\ninterface IV2Reserves {\n    function getReserves(address _pair) external view returns (uint112 reserve0, uint112 reserve1);\n}\n"
    },
    "node_modules/@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "contracts/interfaces/IDexAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\ninterface IDexAdapter {\n    function ASYNC_INITIALIZE() external view returns (bool);\n\n    function V2_ROUTER() external view returns (address);\n\n    function V3_ROUTER() external view returns (address);\n\n    function WETH() external view returns (address);\n\n    function getV3Pool(address _token0, address _token1, int24 _tickSpacing) external view returns (address _pool);\n\n    function getV3Pool(address _token0, address _token1, uint24 _poolFee) external view returns (address _pool);\n\n    function getV2Pool(address _token0, address _token1) external view returns (address _pool);\n\n    function createV2Pool(address _token0, address _token1) external returns (address _pool);\n\n    function getReserves(address _pool) external view returns (uint112, uint112);\n\n    function swapV2Single(\n        address _tokenIn,\n        address _tokenOut,\n        uint256 _amountIn,\n        uint256 _amountOutMin,\n        address _recipient\n    ) external returns (uint256 _amountOut);\n\n    function swapV2SingleExactOut(\n        address _tokenIn,\n        address _tokenOut,\n        uint256 _amountInMax,\n        uint256 _amountOut,\n        address _recipient\n    ) external returns (uint256 _amountInUsed);\n\n    function swapV3Single(\n        address _tokenIn,\n        address _tokenOut,\n        uint24 _fee,\n        uint256 _amountIn,\n        uint256 _amountOutMin,\n        address _recipient\n    ) external returns (uint256 _amountOut);\n\n    function swapV3Single(\n        address _tokenIn,\n        address _tokenOut,\n        int24 _tickSpacing,\n        uint256 _amountIn,\n        uint256 _amountOutMin,\n        address _recipient\n    ) external returns (uint256 _amountOut);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    ) external;\n\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    ) external;\n}\n"
    },
    "node_modules/@openzeppelin/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../token/ERC20/IERC20.sol\";\n"
    },
    "contracts/libraries/VaultAccount.sol": {
      "content": "// SPDX-License-Identifier: ISC\npragma solidity ^0.8.28;\n\nstruct VaultAccount {\n    uint128 amount; // Total amount, analogous to market cap\n    uint128 shares; // Total shares, analogous to shares outstanding\n}\n\n/// @title VaultAccount Library\n/// @author Drake Evans (Frax Finance) github.com/drakeevans, modified from work by @Boring_Crypto github.com/boring_crypto\n/// @notice Provides a library for use with the VaultAccount struct, provides convenient math implementations\n/// @dev Uses uint128 to save on storage\nlibrary VaultAccountingLibrary {\n    /// @notice Calculates the shares value in relationship to `amount` and `total`\n    /// @dev Given an amount, return the appropriate number of shares\n    function toShares(VaultAccount memory total, uint256 amount, bool roundUp) internal pure returns (uint256 shares) {\n        if (total.amount == 0) {\n            shares = amount;\n        } else {\n            shares = (amount * total.shares) / total.amount;\n            if (roundUp && (shares * total.amount) / total.shares < amount) {\n                shares = shares + 1;\n            }\n        }\n    }\n\n    /// @notice Calculates the amount value in relationship to `shares` and `total`\n    /// @dev Given a number of shares, returns the appropriate amount\n    function toAmount(VaultAccount memory total, uint256 shares, bool roundUp) internal pure returns (uint256 amount) {\n        if (total.shares == 0) {\n            amount = shares;\n        } else {\n            amount = (shares * total.amount) / total.shares;\n            if (roundUp && (amount * total.shares) / total.amount < shares) {\n                amount = amount + 1;\n            }\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "remappings": [
      "@chainlink/=node_modules/@chainlink/",
      "@fraxlend/=test/invariant/modules/fraxlend/",
      "fuzzlib/=lib/fuzzlib/src/",
      "swap-router/=test/invariant/modules/v3-periphery/swapRouter/",
      "v3-core/=test/invariant/modules/v3-core/",
      "v3-periphery/=test/invariant/modules/v3-periphery/",
      "v2-core/=test/invariant/modules/uniswap-v2/v2-core/contracts/",
      "v2-periphery/=test/invariant/modules/uniswap-v2/v2-periphery/contracts/",
      "uniswap-v2/=test/invariant/modules/uniswap-v2/",
      "solidity-bytes-utils/contracts/=test/invariant/modules/fraxlend/libraries/",
      "@rari-capital/solmate/=node_modules/solmate/",
      "@arbitrum/=node_modules/@arbitrum/",
      "@ensdomains/=node_modules/@ensdomains/",
      "@eth-optimism/=node_modules/@eth-optimism/",
      "@ethereum-waffle/=node_modules/@ethereum-waffle/",
      "@mean-finance/=node_modules/@mean-finance/",
      "@offchainlabs/=node_modules/@offchainlabs/",
      "@openzeppelin/=node_modules/@openzeppelin/",
      "@scroll-tech/=node_modules/@scroll-tech/",
      "@uniswap/=node_modules/@uniswap/",
      "@zksync/=node_modules/@zksync/",
      "base64-sol/=node_modules/base64-sol/",
      "ds-test/=lib/fuzzlib/lib/forge-std/lib/ds-test/src/",
      "erc721a/=node_modules/erc721a/",
      "eth-gas-reporter/=node_modules/eth-gas-reporter/",
      "forge-std/=lib/forge-std/src/",
      "hardhat/=node_modules/hardhat/",
      "solidity-code-metrics/=node_modules/solidity-code-metrics/",
      "solmate/=node_modules/solmate/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "metadata": {
      "useLiteralContent": false,
      "bytecodeHash": "ipfs",
      "appendCBOR": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "evmVersion": "cancun",
    "viaIR": false,
    "libraries": {}
  }
}}