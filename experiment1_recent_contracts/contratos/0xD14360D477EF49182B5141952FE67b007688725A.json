{"Context.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}"},"Enscribe.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity = 0.8.24;\n\nimport \"./Ownable.sol\";\n\ninterface IENSRegistry {\n    function owner(bytes32 node) external view returns (address);\n    function resolver(bytes32 node) external view returns (address);\n    function setSubnodeRecord(bytes32 node, bytes32 label, address owner, address resolver, uint64 ttl) external;\n    function setOwner(bytes32 node, address owner) external;\n}\n\ninterface INameWrapper {\n    function ownerOf(uint256 tokenId) external view returns (address);\n    function isWrapped(bytes32 node) external view returns (bool);\n    function setSubnodeRecord(bytes32 node, string calldata label, address owner, address resolver, uint64 ttl, uint32 fuses, uint64 expiry) external;\n}\n\ninterface IReverseRegistrar {\n    function setNameForAddr(address addr, address owner, address resolver, string calldata name) external;\n    function node(address addr) external view returns (bytes32);\n}\n\ninterface IPublicResolver {\n    function setAddr(bytes32 node, uint256 coinType, bytes calldata a) external;\n    function setAddr(bytes32 node, address a) external;\n    function setName(bytes32 node, string calldata newName) external;\n}\n\ninterface IERC165 {\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\ninterface IERC1155Receiver is IERC165 {\n    function onERC1155Received(address, address, uint256, uint256, bytes calldata) external returns (bytes4);\n    function onERC1155BatchReceived(address, address, uint256[] calldata, uint256[] calldata, bytes calldata) external returns (bytes4);\n}\n\ncontract Enscribe is Ownable, IERC1155Receiver {\n    IReverseRegistrar public reverseRegistrar;\n    IENSRegistry public ensRegistry;\n    INameWrapper public nameWrapper;\n\n    uint256 public pricing;\n    string public defaultParent;\n\n    event ContractDeployed(address contractAddress);\n    event SubnameCreated(bytes32 parentHash, string label);\n    event SetAddrSuccess(address indexed contractAddress, string subname);\n    event SetPrimaryNameSuccess(address indexed deployedAddress, string subname);\n    event ContractOwnershipTransferred(address deployedAddress, address owner);\n    event EtherReceived(address sender, uint256 amount);\n\n    /**\n     * @dev Constructor initializes ENS-related contracts and default settings.\n     */\n    constructor(\n        address _reverseRegistrar,\n        address _ensRegistry,\n        address _nameWrapper,\n        string memory _defaultParent,\n        uint256 _pricing\n    ) Ownable(msg.sender) {\n        reverseRegistrar = IReverseRegistrar(_reverseRegistrar);\n        ensRegistry = IENSRegistry(_ensRegistry);\n        nameWrapper = INameWrapper(_nameWrapper);\n        defaultParent = _defaultParent;\n        pricing = _pricing;\n    }\n\n    // ------------------ Admin Setters ------------------\n\n    function setReverseRegistrar(address _addr) external onlyOwner {\n        reverseRegistrar = IReverseRegistrar(_addr);\n    }\n\n    function setENSRegistry(address _addr) external onlyOwner {\n        ensRegistry = IENSRegistry(_addr);\n    }\n\n    function setNameWrapper(address _addr) external onlyOwner {\n        nameWrapper = INameWrapper(_addr);\n    }\n\n    function updatePricing(uint256 newPrice) external onlyOwner {\n        require(newPrice \u003e 0, \"Price must be \u003e 0\");\n        pricing = newPrice;\n    }\n\n    function updateDefaultParent(string calldata newParent) external onlyOwner {\n        defaultParent = newParent;\n    }\n\n    function withdraw() external onlyOwner {\n        (bool success, ) = owner().call{value: address(this).balance}(\"\");\n        require(success, \"Withdraw failed\");\n    }\n\n    // ------------------ Core Logic ------------------\n\n    /**\n     * @dev Computes CREATE2 deterministic address.\n     */\n    function computeAddress(uint256 salt, bytes memory bytecode) public view returns (address) {\n        bytes32 bytecodeHash = keccak256(bytecode);\n        bytes32 saltHash = keccak256(abi.encodePacked(salt));\n        return address(uint160(uint256(keccak256(abi.encodePacked(\n            bytes1(0xff), address(this), saltHash, bytecodeHash\n        )))));\n    }\n\n    /**\n     * @dev Deploys a contract, create subname and set ENS as primary name.\n     */\n    function setNameAndDeploy(bytes memory bytecode, string calldata label, string calldata parentName, bytes32 parentNode) public payable returns (address deployedAddress) {\n        require(msg.value \u003e= pricing, \"Insufficient ETH\");\n\n        bytes32 labelHash = keccak256(bytes(label));\n        bytes32 node = keccak256(abi.encodePacked(parentNode, labelHash));\n        string memory subname = string(abi.encodePacked(label, \".\", parentName));\n        deployedAddress = computeAddress(uint256(node), bytecode);\n\n        _deploy(uint256(node), bytecode);\n\n        require(setName(deployedAddress, label, parentName, parentNode), \"Failed to create subname and set forward resolution\");\n\n        require(_setPrimaryName(deployedAddress, subname, address(getResolver(node))), \"Failed to set primary name\");\n        emit SetPrimaryNameSuccess(deployedAddress, subname);\n\n        _transferContractOwnership(deployedAddress, msg.sender);\n        emit ContractOwnershipTransferred(deployedAddress, msg.sender);\n\n        emit EtherReceived(msg.sender, msg.value);\n    }\n\n    /**\n     * @dev Sets the ENS subname and forward resolution for a deployed contract.\n     */\n    function setName(address contractAddress, string calldata label, string calldata parentName, bytes32 parentNode) public payable returns (bool success) {\n        require(msg.value \u003e= pricing, \"Insufficient ETH\");\n\n        bytes32 labelHash = keccak256(bytes(label));\n        bytes32 node = keccak256(abi.encodePacked(parentNode, labelHash));\n        string memory subname = string(abi.encodePacked(label, \".\", parentName));\n\n        require(_isDefaultParent(parentName) || _isSenderOwner(parentNode), \"Sender is not the owner of parent node\");\n        require(_createSubname(parentNode, label, labelHash), \"Subname creation failed\");\n        emit SubnameCreated(parentNode, label);\n\n        require(_setAddr(node, 60, abi.encodePacked(contractAddress)), \"setAddr, forward resolution failed\");\n        emit SetAddrSuccess(contractAddress, subname);\n\n        emit EtherReceived(msg.sender, msg.value);\n        return true;\n    }\n\n    /**\n     * @dev Deploys contract and sets primary name using node. Doesn\u0027t create new subname\n     */\n    function setNameAndDeployWithoutLabel(bytes memory bytecode, string calldata ensName, bytes32 node) public payable returns (address deployedAddress) {\n        require(msg.value \u003e= pricing, \"Insufficient ETH\");\n\n        deployedAddress = computeAddress(uint256(node), bytecode);\n        _deploy(uint256(node), bytecode);\n\n        require(_isSenderOwner(node), \"Sender is not the owner of node\");\n\n        require(_setAddr(node, 60, abi.encodePacked(deployedAddress)), \"setAddr, forward resolution failed\");\n        emit SetAddrSuccess(deployedAddress, ensName);\n\n        require(_setPrimaryName(deployedAddress, ensName, address(getResolver(node))), \"Failed to set primary name\");\n        emit SetPrimaryNameSuccess(deployedAddress, ensName);\n\n        _transferContractOwnership(deployedAddress, msg.sender);\n        emit ContractOwnershipTransferred(deployedAddress, msg.sender);\n\n        emit EtherReceived(msg.sender, msg.value);\n    }\n\n    /**\n     * @dev Deploys contract and sets primary name using reverse node. For contracts extending ReverseClaimable\n     */\n    function setNameAndDeployReverseClaimer(bytes memory bytecode, string calldata label, string calldata parentName, bytes32 parentNode) public payable returns (address deployedAddress) {\n        require(msg.value \u003e= pricing, \"Insufficient ETH\");\n\n        bytes32 labelHash = keccak256(bytes(label));\n        bytes32 node = keccak256(abi.encodePacked(parentNode, labelHash));\n        string memory subname = string(abi.encodePacked(label, \".\", parentName));\n\n        deployedAddress = computeAddress(uint256(node), bytecode);\n        _deploy(uint256(node), bytecode);\n\n        require(_isDefaultParent(parentName) || _isSenderOwner(parentNode), \"Sender is not the owner of parent node\");\n        require(_createSubname(parentNode, label, labelHash), \"Subname creation failed\");\n        emit SubnameCreated(parentNode, label);\n\n        bytes32 reverseNode = reverseRegistrar.node(deployedAddress);\n        getResolver(reverseNode).setName(reverseNode, subname);\n        emit SetPrimaryNameSuccess(deployedAddress, subname);\n\n        require(_setAddr(node, 60, abi.encodePacked(deployedAddress)), \"setAddr, forward resolution failed\");\n        emit SetAddrSuccess(deployedAddress, subname);\n\n        ensRegistry.setOwner(reverseNode, msg.sender);\n        emit ContractOwnershipTransferred(deployedAddress, msg.sender);\n\n        emit EtherReceived(msg.sender, msg.value);\n    }\n\n    /**\n    * @dev Deploys contract and sets primary name during deployment. For contracts extending ReverseSetter\n     */\n    function setNameAndDeployReverseSetter(bytes memory bytecode, string calldata label, string calldata parentName, bytes32 parentNode) public payable returns (address deployedAddress) {\n        require(msg.value \u003e= pricing, \"Insufficient ETH\");\n\n        bytes32 labelHash = keccak256(bytes(label));\n        bytes32 node = keccak256(abi.encodePacked(parentNode, labelHash));\n        string memory subname = string(abi.encodePacked(label, \".\", parentName));\n\n        require(_isDefaultParent(parentName) || _isSenderOwner(parentNode), \"Sender is not the owner of parent node\");\n        require(_createSubname(parentNode, label, labelHash), \"Subname creation failed\");\n        emit SubnameCreated(parentNode, label);\n\n        deployedAddress = computeAddress(uint256(node), bytecode);\n        _deploy(uint256(node), bytecode);\n\n        require(_setAddr(node, 60, abi.encodePacked(deployedAddress)), \"setAddr, forward resolution failed\");\n        emit SetAddrSuccess(deployedAddress, subname);\n\n        emit EtherReceived(msg.sender, msg.value);\n    }\n\n    /**\n     * @dev Internal: Deploy contract with CREATE2.\n     */\n    function _deploy(uint256 salt, bytes memory bytecode) private returns (address deployed) {\n        require(bytecode.length \u003e 0, \"Empty bytecode\");\n        bytes32 saltHash = keccak256(abi.encodePacked(salt));\n        assembly {\n            deployed := create2(0, add(bytecode, 0x20), mload(bytecode), saltHash)\n        }\n        require(deployed != address(0), \"Deployment failed\");\n        emit ContractDeployed(deployed);\n    }\n\n    /**\n     * @dev Internal: Transfers ownership of deployed contract using `transferOwnership`.\n     */\n    function _transferContractOwnership(address contractAddress, address newOwner) private {\n        (bool success, ) = contractAddress.call(abi.encodeWithSignature(\"transferOwnership(address)\", newOwner));\n        require(success, \"Ownership transfer failed\");\n    }\n\n    /**\n     * @dev Internal: Set reverse record for deployed contract.\n     */\n    function _setPrimaryName(address addr, string memory name, address resolver) private returns (bool) {\n        try reverseRegistrar.setNameForAddr(addr, address(this), resolver, name) {\n            return true;\n        } catch {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Internal: Creates ENS subname under given parent.\n     */\n    function _createSubname(bytes32 parentNode, string calldata label, bytes32 labelHash) private returns (bool) {\n        if (checkWrapped(parentNode)) {\n            nameWrapper.setSubnodeRecord(parentNode, label, address(this), address(getResolver(parentNode)), 0, 0, 0);\n        } else {\n            ensRegistry.setSubnodeRecord(parentNode, labelHash, address(this), address(getResolver(parentNode)), 0);\n        }\n        return true;\n    }\n\n    /**\n     * @dev Internal: Sets address record, forward resolution.\n     */\n    function _setAddr(bytes32 node, uint256 coinType, bytes memory addrBytes) private returns (bool) {\n        try getResolver(node).setAddr(node, coinType, addrBytes) {\n            return true;\n        } catch {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Internal: Returns whether the ENS name is wrapped.\n     */\n    function checkWrapped(bytes32 node) public view returns (bool) {\n        try nameWrapper.isWrapped(node) returns (bool wrapped) {\n            return wrapped;\n        } catch {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Internal: Verifies if the caller is owner of the given node.\n     */\n    function _isSenderOwner(bytes32 node) private view returns (bool) {\n        return checkWrapped(node)\n            ? nameWrapper.ownerOf(uint256(node)) == msg.sender\n            : ensRegistry.owner(node) == msg.sender;\n    }\n\n    /**\n     * @dev Checks if the given parentName equals defaultParent.\n     */\n    function _isDefaultParent(string calldata parent) private view returns (bool) {\n        return keccak256(bytes(parent)) == keccak256(bytes(defaultParent));\n    }\n\n    /**\n     * @dev Returns the Resolver address for given ENS node\n     */\n    function getResolver(bytes32 node) internal view returns (IPublicResolver)  {\n        return IPublicResolver(ensRegistry.resolver(node));\n    }\n\n    // ------------------ ERC1155 Receiver \u0026 Fallback ------------------\n\n    function onERC1155Received(address, address, uint256, uint256, bytes calldata) external pure override returns (bytes4) {\n        return IERC1155Receiver.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(address, address, uint256[] calldata, uint256[] calldata, bytes calldata) external pure override returns (bytes4) {\n        return IERC1155Receiver.onERC1155BatchReceived.selector;\n    }\n\n    function supportsInterface(bytes4 interfaceId) external pure override returns (bool) {\n        return interfaceId == type(IERC1155Receiver).interfaceId || interfaceId == type(IERC165).interfaceId;\n    }\n\n    receive() external payable {\n        emit EtherReceived(msg.sender, msg.value);\n    }\n\n    fallback() external payable {\n        emit EtherReceived(msg.sender, msg.value);\n    }\n}"},"Ownable.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"./Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}"}}