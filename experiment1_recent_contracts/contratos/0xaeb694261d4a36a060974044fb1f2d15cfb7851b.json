{{
  "language": "Solidity",
  "sources": {
    "lib/aave-umbrella/src/contracts/helpers/DataAggregationHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nimport {IERC20Metadata} from 'openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol';\nimport {IERC20} from 'openzeppelin-contracts/contracts/token/ERC20/IERC20.sol';\n\nimport {Ownable} from 'openzeppelin-contracts/contracts/access/Ownable.sol';\n\nimport {IRescuableBase, RescuableBase} from 'solidity-utils/contracts/utils/RescuableBase.sol';\nimport {Rescuable} from 'solidity-utils/contracts/utils/Rescuable.sol';\n\nimport {IERC4626StataToken} from 'aave-v3-origin/contracts/extensions/stata-token/interfaces/IERC4626StataToken.sol';\nimport {IStataTokenV2} from 'aave-v3-origin/contracts/extensions/stata-token/interfaces/IStataTokenV2.sol';\nimport {IAaveOracle} from 'aave-v3-origin/contracts/interfaces/IAaveOracle.sol';\nimport {IAToken} from 'aave-v3-origin/contracts/interfaces/IAToken.sol';\n\nimport {IUmbrellaConfiguration} from '../umbrella/interfaces/IUmbrellaConfiguration.sol';\nimport {IUmbrellaStakeToken} from '../stakeToken/interfaces/IUmbrellaStakeToken.sol';\nimport {IRewardsController} from '../rewards/interfaces/IRewardsController.sol';\nimport {IStakeToken} from '../stakeToken/interfaces/IStakeToken.sol';\nimport {IUmbrella} from '../umbrella/interfaces/IUmbrella.sol';\n\n/**\n * @title DataAggregationHelper\n * @notice DataAggregationHelper is a utility contract designed to help getting all necessary data for frontend.\n * @author BGD labs\n */\ncontract DataAggregationHelper is Ownable, Rescuable {\n  IRewardsController public immutable REWARDS_CONTROLLER;\n\n  enum TokenType {\n    None,\n    Token,\n    AToken,\n    StataToken\n  }\n\n  struct StakeTokenData {\n    TokenData stakeTokenData;\n    uint256 totalAssets;\n    bool isStakeConfigured;\n    RewardTokenData[] rewardsTokenData;\n  }\n\n  struct RewardTokenData {\n    TokenData rewardTokenData;\n    uint256 currentEmissionPerSecondScaled;\n  }\n\n  struct TokenRouteData {\n    address stakeToken;\n    TokenFromRoute[] tokensFromRoute;\n  }\n\n  struct TokenFromRoute {\n    TokenType typeOfToken;\n    TokenData tokenData;\n  }\n\n  struct TokenData {\n    address token;\n    uint256 price;\n    string name;\n    string symbol;\n    uint8 decimals;\n  }\n\n  struct StakeTokenUserData {\n    address stakeToken;\n    uint256 stakeUserBalance;\n    RewardTokenUserData[] rewardsTokenUserData;\n  }\n\n  struct RewardTokenUserData {\n    address reward;\n    uint256 currentReward;\n  }\n\n  struct TokenRouteBalances {\n    address stakeToken;\n    BalanceOfTokenFromRoute[] balancesOfRouteTokens;\n  }\n\n  struct BalanceOfTokenFromRoute {\n    TokenType typeOfToken;\n    address token;\n    uint256 userBalance;\n  }\n\n  error ZeroAddress();\n\n  constructor(address rewardsController_, address owner_) Ownable(owner_) {\n    require(rewardsController_ != address(0), ZeroAddress());\n\n    REWARDS_CONTROLLER = IRewardsController(rewardsController_);\n  }\n\n  function getAllAggregatedData(\n    IUmbrella umbrella,\n    IAaveOracle aaveOracle,\n    address user\n  )\n    external\n    view\n    returns (\n      StakeTokenData[] memory,\n      TokenRouteData[] memory,\n      StakeTokenUserData[] memory,\n      TokenRouteBalances[] memory\n    )\n  {\n    address[] memory stakeTokens = IUmbrella(umbrella).getStkTokens();\n\n    StakeTokenData[] memory tokenData = _getTokenAggregatedData(stakeTokens, umbrella, aaveOracle);\n    TokenRouteData[] memory tokenRouteData = _getTokensRouteData(stakeTokens, aaveOracle);\n\n    StakeTokenUserData[] memory userData;\n    TokenRouteBalances[] memory userBalances;\n\n    if (user != address(0)) {\n      userData = _getUserAggregatedData(stakeTokens, user);\n      userBalances = _getUserBalancesFromRouteTokens(stakeTokens, user);\n    }\n\n    return (tokenData, tokenRouteData, userData, userBalances);\n  }\n\n  function getTokensAggregatedData(\n    IUmbrella umbrella,\n    IAaveOracle aaveOracle\n  ) external view returns (StakeTokenData[] memory) {\n    address[] memory stakeTokens = IUmbrella(umbrella).getStkTokens();\n\n    return _getTokenAggregatedData(stakeTokens, umbrella, aaveOracle);\n  }\n\n  function getTokensRouteData(\n    IUmbrella umbrella,\n    IAaveOracle aaveOracle\n  ) external view returns (TokenRouteData[] memory) {\n    address[] memory stakeTokens = IUmbrella(umbrella).getStkTokens();\n\n    return _getTokensRouteData(stakeTokens, aaveOracle);\n  }\n\n  function getUserAggregatedData(\n    IUmbrella umbrella,\n    address user\n  ) external view returns (StakeTokenUserData[] memory) {\n    address[] memory stakeTokens = IUmbrella(umbrella).getStkTokens();\n\n    return _getUserAggregatedData(stakeTokens, user);\n  }\n\n  function getUserBalancesFromRouteTokens(\n    IUmbrella umbrella,\n    address user\n  ) external view returns (TokenRouteBalances[] memory) {\n    address[] memory stakeTokens = IUmbrella(umbrella).getStkTokens();\n\n    return _getUserBalancesFromRouteTokens(stakeTokens, user);\n  }\n\n  function whoCanRescue() public view override returns (address) {\n    return owner();\n  }\n\n  function maxRescue(\n    address\n  ) public pure override(IRescuableBase, RescuableBase) returns (uint256) {\n    return type(uint256).max;\n  }\n\n  function _getTokenAggregatedData(\n    address[] memory stakeTokens,\n    IUmbrella umbrella,\n    IAaveOracle aaveOracle\n  ) internal view returns (StakeTokenData[] memory) {\n    StakeTokenData[] memory stakeTokensData = new StakeTokenData[](stakeTokens.length);\n    IUmbrellaConfiguration.StakeTokenData memory stakeConfig;\n\n    for (uint256 i; i < stakeTokens.length; ++i) {\n      stakeConfig = umbrella.getStakeTokenData(stakeTokens[i]);\n\n      stakeTokensData[i].totalAssets = IUmbrellaStakeToken(stakeTokens[i]).totalAssets();\n      stakeTokensData[i].isStakeConfigured = stakeConfig.reserve != address(0);\n\n      uint256 stakePrice;\n      if (stakeConfig.underlyingOracle != address(0)) {\n        // ask for a price directly, cause token configuration was already initialized at least once\n        stakePrice = uint256(IUmbrellaStakeToken(stakeTokens[i]).latestAnswer());\n      } else if (stakeConfig.underlyingOracle == address(0) && stakeConfig.reserve == address(0)) {\n        // stake token wasn't included in config yet, so it's price is equal to price of underlying\n        address underlying = IStakeToken(stakeTokens[i]).asset();\n\n        (bool isStata, ) = _stataTokenCheck(underlying);\n\n        _tryGetUnderlyingPrice(underlying, aaveOracle, isStata);\n      } else {\n        // unreachable code in the current version, will set max in case this could happen in future\n        stakePrice = type(uint256).max;\n      }\n\n      stakeTokensData[i].stakeTokenData = _buildTokenStruct(stakeTokens[i], stakePrice, 0);\n\n      address[] memory rewards = REWARDS_CONTROLLER.getAllRewards(stakeTokens[i]);\n      stakeTokensData[i].rewardsTokenData = new RewardTokenData[](rewards.length);\n\n      for (uint256 j; j < rewards.length; ++j) {\n        stakeTokensData[i].rewardsTokenData[j].currentEmissionPerSecondScaled = REWARDS_CONTROLLER\n          .calculateCurrentEmissionScaled(stakeTokens[i], rewards[j]);\n\n        // Top reward cases:\n        // 1) aToken\n        // 2) Token\n        // 3) StataToken (should be only in rare cases)\n        // return max otherwise, cause source of price isn't known\n        address tokenToAskPriceFor = rewards[j];\n        uint256 rewardPrice;\n\n        // check if reward is `aToken`\n        (bool success, bytes memory data) = rewards[j].staticcall(\n          abi.encodeWithSelector(IAToken.UNDERLYING_ASSET_ADDRESS.selector)\n        );\n\n        if (success) {\n          tokenToAskPriceFor = abi.decode(data, (address));\n        }\n\n        // Token || aToken\n        // price of `aToken` is equal to price of `Token`, cause backed 1-1\n        try aaveOracle.getAssetPrice(tokenToAskPriceFor) returns (uint256 reservePrice) {\n          rewardPrice = reservePrice;\n        } catch {\n          // Check for `StataToken`, if this `Stata` isn't even from this `Pool` it will anyway return actual price\n          (success, data) = rewards[j].staticcall(\n            abi.encodeWithSelector(IERC4626StataToken.latestAnswer.selector)\n          );\n          // if success is false, then source of price isn't known, it's a `Token/aToken` or another type of `Token` except `StataToken`, that isn't listed on this concrete Aave `Pool`\n          // Don't make revert here, cause it's a normal situation and this price should be get from somewhere else\n          rewardPrice = success ? abi.decode(data, (uint256)) : type(uint256).max;\n        }\n\n        stakeTokensData[i].rewardsTokenData[j].rewardTokenData = _buildTokenStruct(\n          rewards[j],\n          rewardPrice,\n          0\n        );\n      }\n    }\n\n    return stakeTokensData;\n  }\n\n  function _getTokensRouteData(\n    address[] memory stakeTokens,\n    IAaveOracle aaveOracle\n  ) internal view returns (TokenRouteData[] memory) {\n    TokenRouteData[] memory tokenRouteData = new TokenRouteData[](stakeTokens.length);\n\n    for (uint256 i; i < stakeTokens.length; ++i) {\n      tokenRouteData[i].stakeToken = stakeTokens[i];\n      tokenRouteData[i].tokensFromRoute = _getTokensFromRoute(stakeTokens[i], aaveOracle);\n    }\n\n    return tokenRouteData;\n  }\n\n  function _getUserAggregatedData(\n    address[] memory stakeTokens,\n    address user\n  ) internal view returns (StakeTokenUserData[] memory) {\n    StakeTokenUserData[] memory stakeTokensUserData = new StakeTokenUserData[](stakeTokens.length);\n\n    for (uint256 i; i < stakeTokens.length; ++i) {\n      stakeTokensUserData[i].stakeToken = stakeTokens[i];\n      stakeTokensUserData[i].stakeUserBalance = IERC20(stakeTokens[i]).balanceOf(user);\n\n      address[] memory rewards = REWARDS_CONTROLLER.getAllRewards(stakeTokens[i]);\n      stakeTokensUserData[i].rewardsTokenUserData = new RewardTokenUserData[](rewards.length);\n\n      for (uint256 j; j < rewards.length; ++j) {\n        stakeTokensUserData[i].rewardsTokenUserData[j] = RewardTokenUserData({\n          reward: rewards[j],\n          currentReward: REWARDS_CONTROLLER.calculateCurrentUserReward(\n            stakeTokens[i],\n            rewards[j],\n            user\n          )\n        });\n      }\n    }\n\n    return stakeTokensUserData;\n  }\n\n  function _getUserBalancesFromRouteTokens(\n    address[] memory stakeTokens,\n    address user\n  ) internal view returns (TokenRouteBalances[] memory) {\n    TokenRouteBalances[] memory tokenRouteBalances = new TokenRouteBalances[](stakeTokens.length);\n\n    for (uint256 i; i < stakeTokens.length; ++i) {\n      tokenRouteBalances[i].stakeToken = stakeTokens[i];\n      tokenRouteBalances[i].balancesOfRouteTokens = _getBalancesFromRoute(stakeTokens[i], user);\n    }\n\n    return tokenRouteBalances;\n  }\n\n  function _getTokensFromRoute(\n    address stakeToken,\n    IAaveOracle aaveOracle\n  ) internal view returns (TokenFromRoute[] memory) {\n    uint8 decimals = IERC20Metadata(stakeToken).decimals();\n\n    address underlyingOfStakeToken = IStakeToken(stakeToken).asset();\n\n    (bool isStata, address aToken) = _stataTokenCheck(underlyingOfStakeToken);\n\n    TokenFromRoute[] memory tokens = new TokenFromRoute[](isStata ? 3 : 1);\n\n    tokens[0] = TokenFromRoute({\n      typeOfToken: isStata ? TokenType.StataToken : TokenType.Token,\n      tokenData: _buildTokenStruct(\n        underlyingOfStakeToken,\n        _tryGetUnderlyingPrice(underlyingOfStakeToken, aaveOracle, isStata),\n        decimals\n      )\n    });\n\n    if (isStata) {\n      address token = IStataTokenV2(underlyingOfStakeToken).asset();\n\n      uint256 price = aaveOracle.getAssetPrice(token);\n\n      tokens[1] = TokenFromRoute({\n        typeOfToken: TokenType.AToken,\n        tokenData: _buildTokenStruct(aToken, price, decimals)\n      });\n\n      tokens[2] = TokenFromRoute({\n        typeOfToken: TokenType.Token,\n        tokenData: _buildTokenStruct(token, price, decimals)\n      });\n    }\n\n    return tokens;\n  }\n\n  function _getBalancesFromRoute(\n    address stakeToken,\n    address user\n  ) internal view returns (BalanceOfTokenFromRoute[] memory) {\n    address underlyingOfStakeToken = IStakeToken(stakeToken).asset();\n\n    (bool isStata, address aToken) = _stataTokenCheck(underlyingOfStakeToken);\n\n    BalanceOfTokenFromRoute[] memory balances = new BalanceOfTokenFromRoute[](isStata ? 3 : 1);\n\n    balances[0] = BalanceOfTokenFromRoute({\n      typeOfToken: isStata ? TokenType.StataToken : TokenType.Token,\n      token: underlyingOfStakeToken,\n      userBalance: IERC20(underlyingOfStakeToken).balanceOf(user)\n    });\n\n    if (isStata) {\n      address token = IStataTokenV2(underlyingOfStakeToken).asset();\n\n      balances[1] = BalanceOfTokenFromRoute({\n        typeOfToken: TokenType.AToken,\n        token: aToken,\n        userBalance: IERC20(aToken).balanceOf(user)\n      });\n\n      balances[2] = BalanceOfTokenFromRoute({\n        typeOfToken: TokenType.Token,\n        token: token,\n        userBalance: IERC20(token).balanceOf(user)\n      });\n    }\n\n    return balances;\n  }\n\n  function _stataTokenCheck(address token) internal view returns (bool isStata, address aToken) {\n    bytes memory data;\n\n    (isStata, data) = address(token).staticcall(\n      abi.encodeWithSelector(IERC4626StataToken.aToken.selector)\n    );\n\n    if (isStata) {\n      aToken = abi.decode(data, (address));\n    }\n\n    return (isStata, aToken);\n  }\n\n  function _buildTokenStruct(\n    address token,\n    uint256 price,\n    uint8 decimals\n  ) internal view returns (TokenData memory) {\n    return\n      TokenData({\n        token: token,\n        price: price,\n        name: IERC20Metadata(token).name(),\n        symbol: IERC20Metadata(token).symbol(),\n        decimals: decimals != 0 ? decimals : IERC20Metadata(token).decimals()\n      });\n  }\n\n  function _tryGetUnderlyingPrice(\n    address underlyingToken,\n    IAaveOracle aaveOracle,\n    bool isStata\n  ) internal view returns (uint256) {\n    if (isStata) {\n      return uint256(IStataTokenV2(underlyingToken).latestAnswer()); // stata has `latestAnswer()`\n    } else {\n      try aaveOracle.getAssetPrice(underlyingToken) returns (uint256 price) {\n        return price; // just token used as underlying for stake\n      } catch {\n        return type(uint256).max; // not standard or lp-token, which isn't listed in the `Pool` connected with `AaveOracle`\n      }\n    }\n  }\n}\n"
    },
    "lib/aave-umbrella/lib/aave-v3-origin/lib/solidity-utils/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC-20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "lib/aave-umbrella/lib/aave-v3-origin/lib/solidity-utils/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "lib/aave-umbrella/lib/aave-v3-origin/lib/solidity-utils/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "lib/aave-umbrella/lib/aave-v3-origin/lib/solidity-utils/src/contracts/utils/RescuableBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.8;\n\nimport {IERC20} from 'openzeppelin-contracts/contracts/token/ERC20/IERC20.sol';\nimport {SafeERC20} from 'openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol';\nimport {IRescuableBase} from './interfaces/IRescuableBase.sol';\n\nabstract contract RescuableBase is IRescuableBase {\n  using SafeERC20 for IERC20;\n\n  /// @inheritdoc IRescuableBase\n  function maxRescue(address erc20Token) public view virtual returns (uint256);\n\n  function _emergencyTokenTransfer(address erc20Token, address to, uint256 amount) internal {\n    uint256 max = maxRescue(erc20Token);\n    amount = max > amount ? amount : max;\n    IERC20(erc20Token).safeTransfer(to, amount);\n\n    emit ERC20Rescued(msg.sender, erc20Token, to, amount);\n  }\n\n  function _emergencyEtherTransfer(address to, uint256 amount) internal {\n    (bool success, ) = to.call{value: amount}(new bytes(0));\n    if (!success) {\n      revert EthTransferFailed();\n    }\n\n    emit NativeTokensRescued(msg.sender, to, amount);\n  }\n}\n"
    },
    "lib/aave-umbrella/lib/aave-v3-origin/lib/solidity-utils/src/contracts/utils/Rescuable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.8;\n\nimport {IERC20} from 'openzeppelin-contracts/contracts/token/ERC20/IERC20.sol';\nimport {RescuableBase} from './RescuableBase.sol';\nimport {IRescuable} from './interfaces/IRescuable.sol';\n\n/**\n * @title Rescuable\n * @author BGD Labs\n * @notice abstract contract with the methods to rescue tokens (ERC20 and native)  from a contract\n */\nabstract contract Rescuable is RescuableBase, IRescuable {\n  /// @notice modifier that checks that caller is allowed address\n  modifier onlyRescueGuardian() {\n    if (msg.sender != whoCanRescue()) {\n      revert OnlyRescueGuardian();\n    }\n    _;\n  }\n\n  /// @inheritdoc IRescuable\n  function emergencyTokenTransfer(\n    address erc20Token,\n    address to,\n    uint256 amount\n  ) external virtual onlyRescueGuardian {\n    _emergencyTokenTransfer(erc20Token, to, amount);\n  }\n\n  /// @inheritdoc IRescuable\n  function emergencyEtherTransfer(address to, uint256 amount) external virtual onlyRescueGuardian {\n    _emergencyEtherTransfer(to, amount);\n  }\n\n  function whoCanRescue() public view virtual returns (address);\n}\n"
    },
    "lib/aave-umbrella/lib/aave-v3-origin/src/contracts/extensions/stata-token/interfaces/IERC4626StataToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport {IPool, IPoolAddressesProvider} from '../../../interfaces/IPool.sol';\n\ninterface IERC4626StataToken {\n  struct SignatureParams {\n    uint8 v;\n    bytes32 r;\n    bytes32 s;\n  }\n\n  error PoolAddressMismatch(address pool);\n\n  error StaticATokenInvalidZeroShares();\n\n  error OnlyPauseGuardian(address caller);\n\n  /**\n   * @notice The pool associated with the aToken.\n   * @return The pool address.\n   */\n  function POOL() external view returns (IPool);\n\n  /**\n   * @notice The poolAddressesProvider associated with the pool.\n   * @return The poolAddressesProvider address.\n   */\n  function POOL_ADDRESSES_PROVIDER() external view returns (IPoolAddressesProvider);\n\n  /**\n   * @notice Burns `shares` of static aToken, with receiver receiving the corresponding amount of aToken\n   * @param shares The shares to withdraw, in static balance of StaticAToken\n   * @param receiver The address that will receive the amount of `ASSET` withdrawn from the Aave protocol\n   * @return amountToWithdraw: aToken send to `receiver`, dynamic balance\n   **/\n  function redeemATokens(\n    uint256 shares,\n    address receiver,\n    address owner\n  ) external returns (uint256);\n\n  /**\n   * @notice Deposits aTokens and mints static aTokens to msg.sender\n   * @param assets The amount of aTokens to deposit (e.g. deposit of 100 aUSDC)\n   * @param receiver The address that will receive the static aTokens\n   * @return uint256 The amount of StaticAToken minted, static balance\n   **/\n  function depositATokens(uint256 assets, address receiver) external returns (uint256);\n\n  /**\n   * @notice Universal deposit method for proving aToken or underlying liquidity with permit\n   * @param assets The amount of aTokens or underlying to deposit\n   * @param receiver The address that will receive the static aTokens\n   * @param deadline Must be a timestamp in the future\n   * @param sig A `secp256k1` signature params from `msgSender()`\n   * @return uint256 The amount of StaticAToken minted, static balance\n   **/\n  function depositWithPermit(\n    uint256 assets,\n    address receiver,\n    uint256 deadline,\n    SignatureParams memory sig,\n    bool depositToAave\n  ) external returns (uint256);\n\n  /**\n   * @notice The aToken used inside the 4626 vault.\n   * @return address The aToken address.\n   */\n  function aToken() external view returns (address);\n\n  /**\n   * @notice Returns the current asset price of the stataToken.\n   * The price is calculated as `underlying_price * exchangeRate`.\n   * It is important to note that:\n   * - `underlying_price` is the price obtained by the aave-oracle and is subject to it's internal pricing mechanisms.\n   * - as the price is scaled over the exchangeRate, but maintains the same precision as the underlying the price might be underestimated by 1 unit.\n   * - when pricing multiple `shares` as `shares * price` keep in mind that the error compounds.\n   * @return price the current asset price.\n   */\n  function latestAnswer() external view returns (int256);\n}\n"
    },
    "lib/aave-umbrella/lib/aave-v3-origin/src/contracts/extensions/stata-token/interfaces/IStataTokenV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC4626} from 'openzeppelin-contracts/contracts/interfaces/IERC4626.sol';\nimport {IERC20Permit} from 'openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Permit.sol';\nimport {IERC4626StataToken} from './IERC4626StataToken.sol';\nimport {IERC20AaveLM} from './IERC20AaveLM.sol';\n\ninterface IStataTokenV2 is IERC4626, IERC20Permit, IERC4626StataToken, IERC20AaveLM {\n  /**\n   * @notice Checks if the passed actor is permissioned emergency admin.\n   * @param actor The reward to claim\n   * @return bool signaling if actor can pause the vault.\n   */\n  function canPause(address actor) external view returns (bool);\n\n  /**\n   * @notice Pauses/unpauses all system's operations\n   * @param paused boolean determining if the token should be paused or unpaused\n   */\n  function setPaused(bool paused) external;\n}\n"
    },
    "lib/aave-umbrella/lib/aave-v3-origin/src/contracts/interfaces/IAaveOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IPriceOracleGetter} from './IPriceOracleGetter.sol';\nimport {IPoolAddressesProvider} from './IPoolAddressesProvider.sol';\n\n/**\n * @title IAaveOracle\n * @author Aave\n * @notice Defines the basic interface for the Aave Oracle\n */\ninterface IAaveOracle is IPriceOracleGetter {\n  /**\n   * @dev Emitted after the base currency is set\n   * @param baseCurrency The base currency of used for price quotes\n   * @param baseCurrencyUnit The unit of the base currency\n   */\n  event BaseCurrencySet(address indexed baseCurrency, uint256 baseCurrencyUnit);\n\n  /**\n   * @dev Emitted after the price source of an asset is updated\n   * @param asset The address of the asset\n   * @param source The price source of the asset\n   */\n  event AssetSourceUpdated(address indexed asset, address indexed source);\n\n  /**\n   * @dev Emitted after the address of fallback oracle is updated\n   * @param fallbackOracle The address of the fallback oracle\n   */\n  event FallbackOracleUpdated(address indexed fallbackOracle);\n\n  /**\n   * @notice Returns the PoolAddressesProvider\n   * @return The address of the PoolAddressesProvider contract\n   */\n  function ADDRESSES_PROVIDER() external view returns (IPoolAddressesProvider);\n\n  /**\n   * @notice Sets or replaces price sources of assets\n   * @param assets The addresses of the assets\n   * @param sources The addresses of the price sources\n   */\n  function setAssetSources(address[] calldata assets, address[] calldata sources) external;\n\n  /**\n   * @notice Sets the fallback oracle\n   * @param fallbackOracle The address of the fallback oracle\n   */\n  function setFallbackOracle(address fallbackOracle) external;\n\n  /**\n   * @notice Returns a list of prices from a list of assets addresses\n   * @param assets The list of assets addresses\n   * @return The prices of the given assets\n   */\n  function getAssetsPrices(address[] calldata assets) external view returns (uint256[] memory);\n\n  /**\n   * @notice Returns the address of the source for an asset address\n   * @param asset The address of the asset\n   * @return The address of the source\n   */\n  function getSourceOfAsset(address asset) external view returns (address);\n\n  /**\n   * @notice Returns the address of the fallback oracle\n   * @return The address of the fallback oracle\n   */\n  function getFallbackOracle() external view returns (address);\n}\n"
    },
    "lib/aave-umbrella/lib/aave-v3-origin/src/contracts/interfaces/IAToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC20} from '../dependencies/openzeppelin/contracts/IERC20.sol';\nimport {IScaledBalanceToken} from './IScaledBalanceToken.sol';\nimport {IInitializableAToken} from './IInitializableAToken.sol';\n\n/**\n * @title IAToken\n * @author Aave\n * @notice Defines the basic interface for an AToken.\n */\ninterface IAToken is IERC20, IScaledBalanceToken, IInitializableAToken {\n  /**\n   * @dev Emitted during the transfer action\n   * @param from The user whose tokens are being transferred\n   * @param to The recipient\n   * @param value The scaled amount being transferred\n   * @param index The next liquidity index of the reserve\n   */\n  event BalanceTransfer(address indexed from, address indexed to, uint256 value, uint256 index);\n\n  /**\n   * @notice Mints `amount` aTokens to `user`\n   * @param caller The address performing the mint\n   * @param onBehalfOf The address of the user that will receive the minted aTokens\n   * @param amount The amount of tokens getting minted\n   * @param index The next liquidity index of the reserve\n   * @return `true` if the the previous balance of the user was 0\n   */\n  function mint(\n    address caller,\n    address onBehalfOf,\n    uint256 amount,\n    uint256 index\n  ) external returns (bool);\n\n  /**\n   * @notice Burns aTokens from `user` and sends the equivalent amount of underlying to `receiverOfUnderlying`\n   * @dev In some instances, the mint event could be emitted from a burn transaction\n   * if the amount to burn is less than the interest that the user accrued\n   * @param from The address from which the aTokens will be burned\n   * @param receiverOfUnderlying The address that will receive the underlying\n   * @param amount The amount being burned\n   * @param index The next liquidity index of the reserve\n   */\n  function burn(address from, address receiverOfUnderlying, uint256 amount, uint256 index) external;\n\n  /**\n   * @notice Mints aTokens to the reserve treasury\n   * @param amount The amount of tokens getting minted\n   * @param index The next liquidity index of the reserve\n   */\n  function mintToTreasury(uint256 amount, uint256 index) external;\n\n  /**\n   * @notice Transfers aTokens in the event of a borrow being liquidated, in case the liquidators reclaims the aToken\n   * @param from The address getting liquidated, current owner of the aTokens\n   * @param to The recipient\n   * @param value The amount of tokens getting transferred\n   */\n  function transferOnLiquidation(address from, address to, uint256 value) external;\n\n  /**\n   * @notice Transfers the underlying asset to `target`.\n   * @dev Used by the Pool to transfer assets in borrow(), withdraw() and flashLoan()\n   * @param target The recipient of the underlying\n   * @param amount The amount getting transferred\n   */\n  function transferUnderlyingTo(address target, uint256 amount) external;\n\n  /**\n   * @notice Handles the underlying received by the aToken after the transfer has been completed.\n   * @dev The default implementation is empty as with standard ERC20 tokens, nothing needs to be done after the\n   * transfer is concluded. However in the future there may be aTokens that allow for example to stake the underlying\n   * to receive LM rewards. In that case, `handleRepayment()` would perform the staking of the underlying asset.\n   * @param user The user executing the repayment\n   * @param onBehalfOf The address of the user who will get his debt reduced/removed\n   * @param amount The amount getting repaid\n   */\n  function handleRepayment(address user, address onBehalfOf, uint256 amount) external;\n\n  /**\n   * @notice Allow passing a signed message to approve spending\n   * @dev implements the permit function as for\n   * https://github.com/ethereum/EIPs/blob/8a34d644aacf0f9f8f00815307fd7dd5da07655f/EIPS/eip-2612.md\n   * @param owner The owner of the funds\n   * @param spender The spender\n   * @param value The amount\n   * @param deadline The deadline timestamp, type(uint256).max for max deadline\n   * @param v Signature param\n   * @param s Signature param\n   * @param r Signature param\n   */\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n\n  /**\n   * @notice Returns the address of the underlying asset of this aToken (E.g. WETH for aWETH)\n   * @return The address of the underlying asset\n   */\n  function UNDERLYING_ASSET_ADDRESS() external view returns (address);\n\n  /**\n   * @notice Returns the address of the Aave treasury, receiving the fees on this aToken.\n   * @return Address of the Aave treasury\n   */\n  function RESERVE_TREASURY_ADDRESS() external view returns (address);\n\n  /**\n   * @notice Get the domain separator for the token\n   * @dev Return cached value if chainId matches cache, otherwise recomputes separator\n   * @return The domain separator of the token at current chain\n   */\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n  /**\n   * @notice Returns the nonce for owner.\n   * @param owner The address of the owner\n   * @return The nonce of the owner\n   */\n  function nonces(address owner) external view returns (uint256);\n\n  /**\n   * @notice Rescue and transfer tokens locked in this contract\n   * @param token The address of the token\n   * @param to The address of the recipient\n   * @param amount The amount of token to transfer\n   */\n  function rescueTokens(address token, address to, uint256 amount) external;\n}\n"
    },
    "lib/aave-umbrella/src/contracts/umbrella/interfaces/IUmbrellaConfiguration.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.27;\n\nimport {IPool} from 'aave-v3-origin/contracts/interfaces/IPool.sol';\nimport {IPoolAddressesProvider} from 'aave-v3-origin/contracts/interfaces/IPoolAddressesProvider.sol';\n\ninterface IUmbrellaConfiguration {\n  struct SlashingConfigUpdate {\n    /// @notice Reserve which configuration should be updated\n    address reserve;\n    /// @notice Address of `UmbrellaStakeToken` that should be set for this reserve\n    address umbrellaStake;\n    /// @notice Percentage of funds slashed on top of the new deficit\n    uint256 liquidationFee;\n    /// @notice Oracle of `UmbrellaStakeToken`s underlying\n    address umbrellaStakeUnderlyingOracle;\n  }\n\n  struct SlashingConfigRemoval {\n    /// @notice Reserve which configuration is being removed\n    address reserve;\n    /// @notice Address of `UmbrellaStakeToken` that will be removed from this reserve\n    address umbrellaStake;\n  }\n\n  struct SlashingConfig {\n    /// @notice Address of `UmbrellaStakeToken`\n    address umbrellaStake;\n    /// @notice `UmbrellaStakeToken` underlying oracle address\n    address umbrellaStakeUnderlyingOracle;\n    /// @notice Percentage of funds slashed on top of the new deficit\n    uint256 liquidationFee;\n  }\n\n  struct StakeTokenData {\n    /// @notice Oracle for pricing an underlying assets of `UmbrellaStakeToken`\n    /// @dev Remains after removal of `SlashingConfig`\n    address underlyingOracle;\n    /// @notice Reserve address for which this `UmbrellaStakeToken` is configured\n    /// @dev Will be deleted after removal of `SlashingConfig`\n    address reserve;\n  }\n\n  /**\n   * @notice Event is emitted whenever a configuration is added or updated.\n   * @param reserve Reserve which configuration is changed\n   * @param umbrellaStake Address of `UmbrellaStakeToken`\n   * @param liquidationFee Percentage of funds slashed on top of the deficit\n   * @param umbrellaStakeUnderlyingOracle `UmbrellaStakeToken` underlying oracle address\n   */\n  event SlashingConfigurationChanged(\n    address indexed reserve,\n    address indexed umbrellaStake,\n    uint256 liquidationFee,\n    address umbrellaStakeUnderlyingOracle\n  );\n\n  /**\n   * @notice Event is emitted whenever a configuration is removed.\n   * @param reserve Reserve which configuration is removed\n   * @param umbrellaStake Address of `UmbrellaStakeToken`\n   */\n  event SlashingConfigurationRemoved(address indexed reserve, address indexed umbrellaStake);\n\n  /**\n   * @notice Event is emitted whenever the `deficitOffset` is changed.\n   * @param reserve Reserve which `deficitOffset` is changed\n   * @param newDeficitOffset New amount of `deficitOffset`\n   */\n  event DeficitOffsetChanged(address indexed reserve, uint256 newDeficitOffset);\n\n  /**\n   * @notice Event is emitted whenever the `pendingDeficit` is changed.\n   * @param reserve Reserve which `pendingDeficit` is changed\n   * @param newPendingDeficit New amount of `pendingDeficit`\n   */\n  event PendingDeficitChanged(address indexed reserve, uint256 newPendingDeficit);\n\n  /**\n   * @dev Attempted to set zero address.\n   */\n  error ZeroAddress();\n\n  /**\n   * @dev Attempted to interact with a `UmbrellaStakeToken` that should be deployed by this `Umbrella` instance, but is not.\n   */\n  error InvalidStakeToken();\n\n  /**\n   * @dev Attempted to set a `UmbrellaStakeToken` that has a different number of decimals than `reserve`.\n   */\n  error InvalidNumberOfDecimals();\n\n  /**\n   * @dev Attempted to set `liquidationFee` greater than 100%.\n   */\n  error InvalidLiquidationFee();\n\n  /**\n   * @dev Attempted to get `SlashingConfig` for this `reserve` and `StakeToken`, however config doesn't exist for this pair.\n   */\n  error ConfigurationNotExist();\n\n  /**\n   * @dev Attempted to get price of `StakeToken` underlying, however the oracle has never been set.\n   */\n  error ConfigurationHasNotBeenSet();\n  /**\n   * @dev Attempted to set `UmbrellaStakeToken`, which is already set for another reserve.\n   */\n  error UmbrellaStakeAlreadySetForAnotherReserve();\n\n  /**\n   * @dev Attempted to add `reserve` to configuration, which isn't exist in the `Pool`.\n   */\n  error InvalidReserve();\n\n  /**\n   * @dev Attempted to set `umbrellaStakeUnderlyingOracle` that returns invalid price.\n   */\n  error InvalidOraclePrice();\n\n  // DEFAULT_ADMIN_ROLE\n  /////////////////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @notice Updates a set of slashing configurations.\n   * @dev If the configs contain an already existing configuration, the configuration will be overwritten.\n   * If install more than 1 configuration, then `slash` will not work in the current version.\n   * @param slashingConfigs An array of configurations\n   */\n  function updateSlashingConfigs(SlashingConfigUpdate[] calldata slashingConfigs) external;\n\n  /**\n   * @notice Removes a set of slashing configurations.\n   * @dev If such a config did not exist, the function does not revert.\n   * @param removalPairs An array of coverage pairs (reserve:stk) to remove\n   */\n  function removeSlashingConfigs(SlashingConfigRemoval[] calldata removalPairs) external;\n\n  /////////////////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @notice Returns all the slashing configurations, configured for a given `reserve`.\n   * @param reserve Address of the `reserve`\n   * @return An array of `SlashingConfig` structs\n   */\n  function getReserveSlashingConfigs(\n    address reserve\n  ) external view returns (SlashingConfig[] memory);\n\n  /**\n   * @notice Returns the slashing configuration for a given `UmbrellaStakeToken` in regards to a specific `reserve`.\n   * @dev Reverts if `SlashingConfig` doesn't exist.\n   * @param reserve Address of the `reserve`\n   * @param umbrellaStake Address of the `UmbrellaStakeToken`\n   * @return A `SlashingConfig` struct\n   */\n  function getReserveSlashingConfig(\n    address reserve,\n    address umbrellaStake\n  ) external view returns (SlashingConfig memory);\n\n  /**\n   * @notice Returns if a reserve is currently slashable or not.\n   * A reserve is slashable if:\n   * - there's only one stk configured for slashing\n   * - if there is a non zero new deficit\n   * @param reserve Address of the `reserve`\n   * @return flag If `Umbrella` could slash for a given `reserve`\n   * @return amount Amount of the new deficit, by which `UmbrellaStakeToken` potentially could be slashed\n   */\n  function isReserveSlashable(address reserve) external view returns (bool flag, uint256 amount);\n\n  /**\n   * @notice Returns the amount of deficit that can't be slashed using `UmbrellaStakeToken` funds.\n   * @param reserve Address of the `reserve`\n   * @return The amount of the `deficitOffset`\n   */\n  function getDeficitOffset(address reserve) external view returns (uint256);\n\n  /**\n   * @notice Returns the amount of already slashed funds that have not yet been used for the deficit elimination.\n   * @param reserve Address of the `reserve`\n   * @return The amount of funds pending for deficit elimination\n   */\n  function getPendingDeficit(address reserve) external view returns (uint256);\n\n  /**\n   * @notice Returns the `StakeTokenData` of the `umbrellaStake`.\n   * @param umbrellaStake Address of the `UmbrellaStakeToken`\n   * @return stakeTokenData A `StakeTokenData` struct\n   */\n  function getStakeTokenData(\n    address umbrellaStake\n  ) external view returns (StakeTokenData memory stakeTokenData);\n\n  /**\n   * @notice Returns the price of the `UmbrellaStakeToken` underlying.\n   * @dev This price is used for calculations inside `Umbrella` and should not be used outside of this system.\n   *\n   * The underlying price is determined based on the current oracle, if the oracle has never been set, the function will revert.\n   * The system retains information about the last oracle installed for a given `StakeToken`.\n   *\n   * If the `SlashingConfig` associated with the `StakeToken` is removed, this function will still be operational.\n   * However, the results of its work are not guaranteed.\n   *\n   * @param umbrellaStake Address of the `UmbrellaStakeToken`\n   * @return latestAnswer Price of the underlying\n   */\n  function latestUnderlyingAnswer(\n    address umbrellaStake\n  ) external view returns (int256 latestAnswer);\n\n  /**\n   * @notice Returns the Pool addresses provider.\n   * @return Pool addresses provider address\n   */\n  function POOL_ADDRESSES_PROVIDER() external view returns (IPoolAddressesProvider);\n\n  /**\n   * @notice Returns the address that is receiving the slashed funds.\n   * @return Slashed funds recipient\n   */\n  function SLASHED_FUNDS_RECIPIENT() external view returns (address);\n\n  /**\n   * @notice Returns the Aave Pool for which this `Umbrella` instance is configured.\n   * @return Pool address\n   */\n  function POOL() external view returns (IPool);\n}\n"
    },
    "lib/aave-umbrella/src/contracts/stakeToken/interfaces/IUmbrellaStakeToken.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {IStakeToken} from './IStakeToken.sol';\nimport {IOracleToken} from './IOracleToken.sol';\n\ninterface IUmbrellaStakeToken is IStakeToken, IOracleToken {}\n"
    },
    "lib/aave-umbrella/src/contracts/rewards/interfaces/IRewardsController.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {IRewardsDistributor} from './IRewardsDistributor.sol';\n\ninterface IRewardsController is IRewardsDistributor {\n  /**\n   * @notice Event is emitted when an asset is initialized.\n   * @param asset Address of the new `asset` added\n   */\n  event AssetInitialized(address indexed asset);\n\n  /**\n   * @notice Event is emitted when a `targetLiquidity` of the `asset` is changed.\n   * @param asset Address of the `asset`\n   * @param newTargetLiquidity New amount of `targetLiquidity` set for the `asset`\n   */\n  event TargetLiquidityUpdated(address indexed asset, uint256 newTargetLiquidity);\n\n  /**\n   * @notice Event is emitted when a `lastUpdatedTimestamp` of the `asset` is updated.\n   * @param asset Address of the `asset`\n   * @param newTimestamp New value of `lastUpdatedTimestamp` updated for the `asset`\n   */\n  event LastTimestampUpdated(address indexed asset, uint256 newTimestamp);\n\n  /**\n   * @notice Event is emitted when a reward is initialized for concrete `asset`.\n   * @param asset Address of the `asset`\n   * @param reward Address of the `reward`\n   */\n  event RewardInitialized(address indexed asset, address indexed reward);\n\n  /**\n   * @notice Event is emitted when a reward config is updated.\n   * @param asset Address of the `asset`\n   * @param reward Address of the `reward`\n   * @param maxEmissionPerSecond Amount of maximum possible rewards emission per second\n   * @param distributionEnd Timestamp after which distribution ends\n   * @param rewardPayer Address from where rewards will be transferred\n   */\n  event RewardConfigUpdated(\n    address indexed asset,\n    address indexed reward,\n    uint256 maxEmissionPerSecond,\n    uint256 distributionEnd,\n    address rewardPayer\n  );\n\n  /**\n   * @notice Event is emitted when a `reward` index is updated.\n   * @param asset Address of the `asset`\n   * @param reward Address of the `reward`\n   * @param newIndex New `reward` index updated for certain `asset`\n   */\n  event RewardIndexUpdated(address indexed asset, address indexed reward, uint256 newIndex);\n\n  /**\n   * @notice Event is emitted when a user interacts with the asset (transfer, mint, burn)  or manually updates the rewards data or claims them\n   * @param asset Address of the `asset`\n   * @param reward Address of the `reward`, which `user` data is updated\n   * @param user Address of the `user` whose `reward` data is updated\n   * @param newIndex Reward index set after update\n   * @param accruedFromLastUpdate Amount of accrued rewards from last update\n   */\n  event UserDataUpdated(\n    address indexed asset,\n    address indexed reward,\n    address indexed user,\n    uint256 newIndex,\n    uint256 accruedFromLastUpdate\n  );\n\n  /**\n   * @notice Event is emitted when a `user` `reward` is claimed.\n   * @param asset Address of the `asset`, whose `reward` was claimed\n   * @param reward Address of the `reward`, which is claimed\n   * @param user Address of the `user` whose `reward` is claimed\n   * @param receiver Address of the funds receiver\n   * @param amount Amount of the received funds\n   */\n  event RewardClaimed(\n    address indexed asset,\n    address indexed reward,\n    address indexed user,\n    address receiver,\n    uint256 amount\n  );\n\n  /**\n   * @dev Attempted to update data on the `asset` before it was initialized.\n   */\n  error AssetNotInitialized(address asset);\n\n  /**\n   * @dev Attempted to change the configuration of the `reward` before it was initialized.\n   */\n  error RewardNotInitialized(address reward);\n\n  /**\n   * @dev Attempted to set `distributionEnd` less than `block.timestamp` during `reward` initialization.\n   */\n  error InvalidDistributionEnd();\n\n  /**\n   * @dev Attempted to initialize more rewards than limit.\n   */\n  error MaxRewardsLengthReached();\n\n  // DEFAULT_ADMIN_ROLE\n  /////////////////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @notice Configures asset: sets `targetLiquidity` and updates `lastUpdatedTimestamp`.\n   * If the asset has already been initialized, then updates the rewards indexes and `lastUpdatedTimestamp`,\n   * also changes `targetLiquidity`, otherwise initializes asset and rewards.\n   * @dev `targetLiquidity` should be greater than 1 whole token.\n   * `maxEmissionPerSecond` inside `rewardConfig` should be less than 1000 tokens and greater than 2 wei.\n   * It must also be greater than `targetLiquidity * 1000 / 1e18`. Check EmissionMath.sol for more info.\n   * if `maxEmissionPerSecond` is zero or `distributionEnd` is less than current `block.timestamp`,\n   * then disable distribution for this `reward` if it was previously initialized.\n   * It can't initialize already disabled reward.\n   * @param asset Address of the `asset` to be configured/initialized\n   * @param targetLiquidity Amount of liquidity where will be the maximum emission of rewards per second applied\n   * @param rewardConfigs Optional array of reward configs, can be empty\n   */\n  function configureAssetWithRewards(\n    address asset,\n    uint256 targetLiquidity,\n    RewardSetupConfig[] calldata rewardConfigs\n  ) external;\n\n  // REWARDS_ADMIN_ROLE\n  /////////////////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @notice Configures already initialized rewards for certain `asset`: sets `distributionEnd` and `maxEmissionPerSecond`.\n   * If any reward hasn't initialized before then it reverts.\n   * Before setting new configuration updates all rewards indexes for `asset`.\n   * @dev `maxEmissionPerSecond` inside `rewardConfig` should be less than 1000 tokens and greater than 2 wei.\n   * It must also be greater than `targetLiquidity * 1000 / 1e18`. Check EmissionMath.sol for more info.\n   * If `maxEmissionPerSecond` is zero or `distributionEnd` is less than the current `block.timestamp`,\n   * then distribution for this `reward` will be disabled.\n   * @param asset Address of the `asset` whose reward should be configured\n   * @param rewardConfigs Array of structs with params to set\n   */\n  function configureRewards(address asset, RewardSetupConfig[] calldata rewardConfigs) external;\n\n  /////////////////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @notice Special hook, which is called every time `StakeToken` makes `_update` or `slash`.\n   * Makes an update and calculates new `index` and `accrued`. Also updates `lastUpdateTimestamp`.\n   * @dev All variables are passed here before the actual update.\n   * @param totalSupply Total supply of `StakeToken`\n   * @param totalAssets Total assets of `StakeToken`\n   * @param user User, whose `index` and rewards accrued will be updated, if address is zero then skips user update\n   * @param userBalance Amount of `StakeToken` shares owned by user\n   */\n  function handleAction(\n    uint256 totalSupply,\n    uint256 totalAssets,\n    address user,\n    uint256 userBalance\n  ) external;\n\n  /**\n   * @notice Updates all `reward` indexes and `lastUpdateTimestamp` for the `asset`.\n   * @param asset Address of the `asset` whose rewards will be updated\n   */\n  function updateAsset(address asset) external;\n\n  /**\n   * @notice Returns an array of all initialized assets (all `StakeTokens`, which are initialized here).\n   * @dev Return zero data if assets aren't set.\n   * @return assets Array of asset addresses\n   */\n  function getAllAssets() external view returns (address[] memory assets);\n\n  /**\n   * @notice Returns an array of all initialized rewards for a certain `asset`.\n   * @dev Return zero data if asset or rewards aren't set.\n   * @param asset Address of the `asset` whose rewards should be returned\n   * @return rewards Array of reward addresses\n   */\n  function getAllRewards(address asset) external view returns (address[] memory rewards);\n\n  /**\n   * @notice Returns all data about the asset and its rewards.\n   * @dev Return zero data if asset or rewards aren't set.\n   * Function made without some gas optimizations, so it's recommended to avoid calling it often from non-view method or inside batch.\n   * If the emission for a specific reward has ended at the time of the call (i.e., block.timestamp >= distributionEnd),\n   * the function will return a zero emission, even though there may still be remaining rewards.\n   * Note that the actual reward data will be updated the next time someone manually refreshes the data or interacts with the `StakeToken`.\n   * @param asset Address of the `asset` whose params should be returned\n   * @return assetData `targetLiquidity` and `lastUpdatedTimestamp` inside struct\n   * @return rewardsData All data about rewards including addresses and `RewardData`\n   */\n  function getAssetAndRewardsData(\n    address asset\n  )\n    external\n    view\n    returns (AssetDataExternal memory assetData, RewardDataExternal[] memory rewardsData);\n\n  /**\n   * @notice Returns data about the asset.\n   * @dev Return zero data if asset isn't set.\n   * @param asset Address of the `asset` whose params should be returned\n   * @return assetData `targetLiquidity` and `lastUpdatedTimestamp` inside struct\n   */\n  function getAssetData(address asset) external view returns (AssetDataExternal memory assetData);\n\n  /**\n   * @notice Returns data about the reward.\n   * @dev Return zero data if asset or rewards aren't set.\n   * If the emission has ended at the time of the call (i.e., block.timestamp >= distributionEnd), the function will return a zero emission,\n   * even though there may still be remaining rewards.\n   * Note that the actual reward data will be updated the next time someone manually refreshes the data or interacts with the `StakeToken`.\n   * @param asset Address of the `asset` whose `reward` params should be returned\n   * @param reward Address of the `reward` whose params should be returned\n   * @return rewardData `index`, `maxEmissionPerSecond` and `distributionEnd` and address inside struct, address is duplicated from external one\n   */\n  function getRewardData(\n    address asset,\n    address reward\n  ) external view returns (RewardDataExternal memory rewardData);\n\n  /**\n   * @notice Returns data about the reward emission.\n   * @dev Return zero data if asset or rewards aren't set.\n   * If `maxEmissionPerSecond` is equal to 1 wei, then `flatEmission` will be 0, although in fact it is not 0 and emission is taken into account correctly inside the code.\n   * Here this calculation is made specifically to simplify the function behaviour.\n   * If the emission has ended at the time of the call (i.e., block.timestamp >= distributionEnd), the function will return a zero max and flat emissions,\n   * even though there may still be remaining rewards.\n   * Note that the actual reward data will be updated the next time someone manually refreshes the data or interacts with the `StakeToken`.\n   * @param asset Address of the `asset` whose `reward` emission params should be returned\n   * @param reward Address of the `reward` whose emission params should be returned\n   * @return emissionData `targetLiquidity`, `targetLiquidityExcess`, `maxEmission` and `flatEmission` inside struct\n   */\n  function getEmissionData(\n    address asset,\n    address reward\n  ) external view returns (EmissionData memory emissionData);\n\n  /**\n   * @notice Returns `user` `index` and `accrued` for all rewards for certain `asset` at the time of the last user update.\n   * If you want to get current `accrued` of all rewards, see `calculateCurrentUserRewards`.\n   * @dev Return zero data if asset or rewards aren't set.\n   * @param asset Address of the `asset` for which the rewards are accumulated\n   * @param user Address of `user` accumulating rewards\n   * @return rewards Array of `reward` addresses\n   * @return userData `index` and `accrued` inside structs\n   */\n  function getUserDataByAsset(\n    address asset,\n    address user\n  ) external view returns (address[] memory rewards, UserDataExternal[] memory userData);\n\n  /**\n   * @notice Returns `user` `index` and `accrued` for certain `asset` and `reward` at the time of the last user update.\n   * If you want to calculate current `accrued` of the `reward`, see `calculateCurrentUserReward`.\n   * @dev Return zero data if asset or rewards aren't set.\n   * @param asset Address of the `asset` for which the `reward` is accumulated\n   * @param reward Address of the accumulating `reward`\n   * @param user Address of `user` accumulating rewards\n   * @return data `index` and `accrued` inside struct\n   */\n  function getUserDataByReward(\n    address asset,\n    address reward,\n    address user\n  ) external view returns (UserDataExternal memory data);\n\n  /**\n   * @notice Returns current `reward` indexes for `asset`.\n   * @dev Return zero if asset or rewards aren't set.\n   * Function made without some gas optimizations, so it's recommended to avoid calling it often from non-view method or inside batch.\n   * @param asset Address of the `asset` whose indexes of rewards should be calculated\n   * @return rewards Array of `reward` addresses\n   * @return indexes Current indexes\n   */\n  function calculateRewardIndexes(\n    address asset\n  ) external view returns (address[] memory rewards, uint256[] memory indexes);\n\n  /**\n   * @notice Returns current `index` for certain `asset` and `reward`.\n   * @dev Return zero if asset or rewards aren't set.\n   * @param asset Address of the `asset` whose `index` of `reward` should be calculated\n   * @param reward Address of the accumulating `reward`\n   * @return index Current `index`\n   */\n  function calculateRewardIndex(\n    address asset,\n    address reward\n  ) external view returns (uint256 index);\n\n  /**\n   * @notice Returns `emissionPerSecondScaled` for certain `asset` and `reward`. Returned value scaled to 18 decimals.\n   * @dev Return zero if asset or rewards aren't set.\n   * @param asset Address of the `asset` which current emission of `reward` should be returned\n   * @param reward Address of the `reward` which `emissionPerSecond` should be returned\n   * @return emissionPerSecondScaled Current amount of rewards distributed every second (scaled to 18 decimals)\n   */\n  function calculateCurrentEmissionScaled(\n    address asset,\n    address reward\n  ) external view returns (uint256 emissionPerSecondScaled);\n\n  /**\n   * @notice  Returns `emissionPerSecond` for certain `asset` and `reward`.\n   * @dev Return zero if asset or rewards aren't set.\n   * An integer quantity is returned, although the accuracy of the calculations in reality is higher.\n   * @param asset Address of the `asset` which current emission of `reward` should be returned\n   * @param reward Address of the `reward` which `emissionPerSecond` should be returned\n   * @return emissionPerSecond Current amount of rewards distributed every second\n   */\n  function calculateCurrentEmission(\n    address asset,\n    address reward\n  ) external view returns (uint256 emissionPerSecond);\n\n  /**\n   * @notice Calculates and returns `user` `accrued` amounts for all rewards for certain `asset`.\n   * @dev Return zero data if asset or rewards aren't set.\n   * Function made without some gas optimizations, so it's recommended to avoid calling it often from non-view method or inside batch.\n   * @param asset Address of the `asset` whose rewards are accumulated\n   * @param user Address of `user` accumulating rewards\n   * @return rewards Array of `reward` addresses\n   * @return rewardsAccrued Array of current calculated `accrued` amounts\n   */\n  function calculateCurrentUserRewards(\n    address asset,\n    address user\n  ) external view returns (address[] memory rewards, uint256[] memory rewardsAccrued);\n\n  /**\n   * @notice Calculates and returns `user` `accrued` amount for certain `reward` and `asset`.\n   * @dev Return zero if asset or rewards aren't set.\n   * @param asset Address of the `asset` whose reward is accumulated\n   * @param reward Address of the `reward` that accumulates for the user\n   * @param user Address of `user` accumulating rewards\n   * @return rewardAccrued Amount of current calculated `accrued` amount\n   */\n  function calculateCurrentUserReward(\n    address asset,\n    address reward,\n    address user\n  ) external view returns (uint256 rewardAccrued);\n}\n"
    },
    "lib/aave-umbrella/src/contracts/stakeToken/interfaces/IStakeToken.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {IERC20Permit} from 'openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Permit.sol';\n\nimport {IERC4626StakeToken} from './IERC4626StakeToken.sol';\n\ninterface IStakeToken is IERC4626StakeToken, IERC20Permit {}\n"
    },
    "lib/aave-umbrella/src/contracts/umbrella/interfaces/IUmbrella.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.27;\n\nimport {IUmbrellaStkManager} from './IUmbrellaStkManager.sol';\n\ninterface IUmbrella is IUmbrellaStkManager {\n  /**\n   * @notice Event is emitted whenever the `deficitOffset` is covered on some amount.\n   * @param reserve Reserve which `deficitOffset` is covered\n   * @param amount Amount of covered `deficitOffset`\n   */\n  event DeficitOffsetCovered(address indexed reserve, uint256 amount);\n\n  /**\n   * @notice Event is emitted whenever the `pendingDeficit` is covered on some amount.\n   * @param reserve Reserve which `pendingDeficit` is covered\n   * @param amount Amount of covered `pendingDeficit`\n   */\n  event PendingDeficitCovered(address indexed reserve, uint256 amount);\n\n  /**\n   * @notice Event is emitted whenever the deficit for untuned inside `Umbrella` reserve is covered on some amount.\n   * @param reserve Reserve which `reserve.deficit` is covered\n   * @param amount Amount of covered `reserve.deficit`\n   */\n  event ReserveDeficitCovered(address indexed reserve, uint256 amount);\n\n  /**\n   * @notice Event is emitted when funds are slashed from a `umbrellaStake` to cover a reserve deficit.\n   * @param reserve Reserve address for which funds are slashed\n   * @param umbrellaStake Address of the `UmbrellaStakeToken` from which funds are transferred\n   * @param amount Amount of funds slashed for future deficit elimination\n   * @param fee Additional fee amount slashed on top of the amount\n   */\n  event StakeTokenSlashed(\n    address indexed reserve,\n    address indexed umbrellaStake,\n    uint256 amount,\n    uint256 fee\n  );\n\n  /**\n   * @dev Attempted to change `deficitOffset` for a reserve that does not have a slashing configuration.\n   */\n  error ReserveCoverageNotSetup();\n\n  /**\n   * @dev Attempted to set `deficitOffset` less than possible to avoid immediate slashing.\n   */\n  error TooMuchDeficitOffsetReduction();\n\n  /**\n   * @dev Attempted to cover zero deficit.\n   */\n  error ZeroDeficitToCover();\n\n  /**\n   * @dev Attempted to slash for reserve with zero new deficit or without `SlashingConfig` setup.\n   */\n  error CannotSlash();\n\n  /**\n   * @dev Attempted to slash a basket of `StakeToken`s. Unreachable error in the current version.\n   */\n  error NotImplemented();\n\n  /**\n   * @dev Attempted to call `coverReserveDeficit()` of reserve, which has some configuration.\n   * In this case functions `coverPendingDeficit` or `coverDeficitOffset` should be used instead.\n   */\n  error ReserveIsConfigured();\n\n  // DEFAULT_ADMIN_ROLE\n  /////////////////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @notice Sets a new `deficitOffset` value for this `reserve`.\n   * @dev `deficitOffset` can be increased arbitrarily by a value exceeding `poolDeficit - pendingDeficit`.\n   * It can also be decreased, but not less than the same value `poolDeficit - pendingDeficit`.\n   * `deficitOffset` can only be changed for reserves that have at least 1 `SlashingConfig` setup.\n   * @param reserve Reserve address\n   * @param newDeficitOffset New amount of `deficitOffset` to set for this reserve\n   */\n  function setDeficitOffset(address reserve, uint256 newDeficitOffset) external;\n\n  // COVERAGE_MANAGER_ROLE\n  /////////////////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @notice Pulls funds to resolve `pendingDeficit` **up to** specified amount.\n   * @dev If the amount exceeds the existing `pendingDeficit`, only the `pendingDeficit` will be eliminated.\n   * @param reserve Reserve address\n   * @param amount Amount of `aToken`s (or reserve) to be eliminated\n   * @return The amount of `pendingDeficit` eliminated\n   */\n  function coverPendingDeficit(address reserve, uint256 amount) external returns (uint256);\n\n  /**\n   * @notice Pulls funds to resolve `deficitOffset` **up to** specified amount.\n   * @dev If the amount exceeds the existing `deficitOffset`, only the `deficitOffset` will be eliminated.\n   * @param reserve Reserve address\n   * @param amount Amount of `aToken`s (or reserve) to be eliminated\n   * @return The amount of `deficitOffset` eliminated\n   */\n  function coverDeficitOffset(address reserve, uint256 amount) external returns (uint256);\n\n  /**\n   * @notice Pulls funds to resolve `reserve.deficit` **up to** specified amount.\n   * @dev If the amount exceeds the existing `reserve.deficit`, only the `reserve.deficit` will be eliminated.\n   * Can only be called if this reserve is not configured within `Umbrella`.\n   * (If the reserve has uncovered `deficitOffset`, `pendingDeficit` or at least one `SlashingConfig` is set, then the function will revert.\n   * In this case, to call this function you must first cover `pendingDeficit` and `deficitOffset`, along with removing all `SlashingConfig`s\n   * or use `coverPendingDeficit/coverDeficitOffset` instead.)\n   * @param reserve Reserve address\n   * @param amount Amount of `aToken`s (or reserve) to be eliminated\n   * @return The amount of `reserve.deficit` eliminated\n   */\n  function coverReserveDeficit(address reserve, uint256 amount) external returns (uint256);\n\n  /////////////////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @notice Performs a slashing to cover **up to** the `Pool.getReserveDeficit(reserve) - (pendingDeficit + deficitOffset)`.\n   * @param reserve Reserve address\n   * @return New added and covered deficit\n   */\n  function slash(address reserve) external returns (uint256);\n\n  /**\n   * @notice Returns an address of token, which should be used to cover reserve deficit.\n   * @param reserve Reserve address\n   * @return Address of token to use for deficit coverage\n   */\n  function tokenForDeficitCoverage(address reserve) external view returns (address);\n}\n"
    },
    "lib/aave-umbrella/lib/aave-v3-origin/lib/solidity-utils/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "lib/aave-umbrella/lib/aave-v3-origin/lib/solidity-utils/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC1363} from \"../../../interfaces/IERC1363.sol\";\nimport {Address} from \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC-20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    /**\n     * @dev An operation with an ERC-20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     *\n     * NOTE: If the token implements ERC-7674, this function will not modify any temporary allowance. This function\n     * only sets the \"standard\" allowance. Any temporary allowance will remain active, in addition to the value being\n     * set here.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferAndCall, with a fallback to the simple {ERC20} transfer if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            safeTransfer(token, to, value);\n        } else if (!token.transferAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferFromAndCall, with a fallback to the simple {ERC20} transferFrom if the target\n     * has no code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferFromAndCallRelaxed(\n        IERC1363 token,\n        address from,\n        address to,\n        uint256 value,\n        bytes memory data\n    ) internal {\n        if (to.code.length == 0) {\n            safeTransferFrom(token, from, to, value);\n        } else if (!token.transferFromAndCall(from, to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} approveAndCall, with a fallback to the simple {ERC20} approve if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * NOTE: When the recipient address (`to`) has no code (i.e. is an EOA), this function behaves as {forceApprove}.\n     * Opposedly, when the recipient address (`to`) has code, this function only attempts to call {ERC1363-approveAndCall}\n     * once without retrying, and relies on the returned value to be true.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function approveAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            forceApprove(token, to, value);\n        } else if (!token.approveAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturnBool} that reverts if call fails to meet the requirements.\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            let success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            // bubble errors\n            if iszero(success) {\n                let ptr := mload(0x40)\n                returndatacopy(ptr, 0, returndatasize())\n                revert(ptr, returndatasize())\n            }\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n\n        if (returnSize == 0 ? address(token).code.length == 0 : returnValue != 1) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silently catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n        return success && (returnSize == 0 ? address(token).code.length > 0 : returnValue == 1);\n    }\n}\n"
    },
    "lib/aave-umbrella/lib/aave-v3-origin/lib/solidity-utils/src/contracts/utils/interfaces/IRescuableBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.8;\n\n/**\n * @title IRescuableBase\n * @author BGD Labs\n * @notice interface containing the objects, events and methods definitions of the RescuableBase contract\n */\ninterface IRescuableBase {\n  error EthTransferFailed();\n  /**\n   * @notice emitted when erc20 tokens get rescued\n   * @param caller address that triggers the rescue\n   * @param token address of the rescued token\n   * @param to address that will receive the rescued tokens\n   * @param amount quantity of tokens rescued\n   */\n  event ERC20Rescued(\n    address indexed caller,\n    address indexed token,\n    address indexed to,\n    uint256 amount\n  );\n\n  /**\n   * @notice emitted when native tokens get rescued\n   * @param caller address that triggers the rescue\n   * @param to address that will receive the rescued tokens\n   * @param amount quantity of tokens rescued\n   */\n  event NativeTokensRescued(address indexed caller, address indexed to, uint256 amount);\n\n  /**\n   * @notice method that defined the maximum amount rescuable for any given asset.\n   * @dev there's currently no way to limit the rescuable \"native asset\", as we assume erc20s as intended underlying.\n   * @return the maximum amount of\n   */\n  function maxRescue(address erc20Token) external view returns (uint256);\n}\n"
    },
    "lib/aave-umbrella/lib/aave-v3-origin/lib/solidity-utils/src/contracts/utils/interfaces/IRescuable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.8;\n\nimport {IRescuableBase} from './IRescuableBase.sol';\n\n/**\n * @title IRescuable\n * @author BGD Labs\n * @notice interface containing the objects, events and methods definitions of the Rescuable contract\n */\ninterface IRescuable is IRescuableBase {\n  error OnlyRescueGuardian();\n\n  /**\n   * @notice method called to rescue tokens sent erroneously to the contract. Only callable by owner\n   * @param erc20Token address of the token to rescue\n   * @param to address to send the tokens\n   * @param amount of tokens to rescue\n   */\n  function emergencyTokenTransfer(address erc20Token, address to, uint256 amount) external;\n\n  /**\n   * @notice method called to rescue ether sent erroneously to the contract. Only callable by owner\n   * @param to address to send the eth\n   * @param amount of eth to rescue\n   */\n  function emergencyEtherTransfer(address to, uint256 amount) external;\n}\n"
    },
    "lib/aave-umbrella/lib/aave-v3-origin/src/contracts/interfaces/IPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IPoolAddressesProvider} from './IPoolAddressesProvider.sol';\nimport {DataTypes} from '../protocol/libraries/types/DataTypes.sol';\n\n/**\n * @title IPool\n * @author Aave\n * @notice Defines the basic interface for an Aave Pool.\n */\ninterface IPool {\n  /**\n   * @dev Emitted on mintUnbacked()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address initiating the supply\n   * @param onBehalfOf The beneficiary of the supplied assets, receiving the aTokens\n   * @param amount The amount of supplied assets\n   * @param referralCode The referral code used\n   */\n  event MintUnbacked(\n    address indexed reserve,\n    address user,\n    address indexed onBehalfOf,\n    uint256 amount,\n    uint16 indexed referralCode\n  );\n\n  /**\n   * @dev Emitted on backUnbacked()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param backer The address paying for the backing\n   * @param amount The amount added as backing\n   * @param fee The amount paid in fees\n   */\n  event BackUnbacked(address indexed reserve, address indexed backer, uint256 amount, uint256 fee);\n\n  /**\n   * @dev Emitted on supply()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address initiating the supply\n   * @param onBehalfOf The beneficiary of the supply, receiving the aTokens\n   * @param amount The amount supplied\n   * @param referralCode The referral code used\n   */\n  event Supply(\n    address indexed reserve,\n    address user,\n    address indexed onBehalfOf,\n    uint256 amount,\n    uint16 indexed referralCode\n  );\n\n  /**\n   * @dev Emitted on withdraw()\n   * @param reserve The address of the underlying asset being withdrawn\n   * @param user The address initiating the withdrawal, owner of aTokens\n   * @param to The address that will receive the underlying\n   * @param amount The amount to be withdrawn\n   */\n  event Withdraw(address indexed reserve, address indexed user, address indexed to, uint256 amount);\n\n  /**\n   * @dev Emitted on borrow() and flashLoan() when debt needs to be opened\n   * @param reserve The address of the underlying asset being borrowed\n   * @param user The address of the user initiating the borrow(), receiving the funds on borrow() or just\n   * initiator of the transaction on flashLoan()\n   * @param onBehalfOf The address that will be getting the debt\n   * @param amount The amount borrowed out\n   * @param interestRateMode The rate mode: 2 for Variable, 1 is deprecated (changed on v3.2.0)\n   * @param borrowRate The numeric rate at which the user has borrowed, expressed in ray\n   * @param referralCode The referral code used\n   */\n  event Borrow(\n    address indexed reserve,\n    address user,\n    address indexed onBehalfOf,\n    uint256 amount,\n    DataTypes.InterestRateMode interestRateMode,\n    uint256 borrowRate,\n    uint16 indexed referralCode\n  );\n\n  /**\n   * @dev Emitted on repay()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The beneficiary of the repayment, getting his debt reduced\n   * @param repayer The address of the user initiating the repay(), providing the funds\n   * @param amount The amount repaid\n   * @param useATokens True if the repayment is done using aTokens, `false` if done with underlying asset directly\n   */\n  event Repay(\n    address indexed reserve,\n    address indexed user,\n    address indexed repayer,\n    uint256 amount,\n    bool useATokens\n  );\n\n  /**\n   * @dev Emitted on borrow(), repay() and liquidationCall() when using isolated assets\n   * @param asset The address of the underlying asset of the reserve\n   * @param totalDebt The total isolation mode debt for the reserve\n   */\n  event IsolationModeTotalDebtUpdated(address indexed asset, uint256 totalDebt);\n\n  /**\n   * @dev Emitted when the user selects a certain asset category for eMode\n   * @param user The address of the user\n   * @param categoryId The category id\n   */\n  event UserEModeSet(address indexed user, uint8 categoryId);\n\n  /**\n   * @dev Emitted on setUserUseReserveAsCollateral()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user enabling the usage as collateral\n   */\n  event ReserveUsedAsCollateralEnabled(address indexed reserve, address indexed user);\n\n  /**\n   * @dev Emitted on setUserUseReserveAsCollateral()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user enabling the usage as collateral\n   */\n  event ReserveUsedAsCollateralDisabled(address indexed reserve, address indexed user);\n\n  /**\n   * @dev Emitted on flashLoan()\n   * @param target The address of the flash loan receiver contract\n   * @param initiator The address initiating the flash loan\n   * @param asset The address of the asset being flash borrowed\n   * @param amount The amount flash borrowed\n   * @param interestRateMode The flashloan mode: 0 for regular flashloan,\n   *        1 for Stable (Deprecated on v3.2.0), 2 for Variable\n   * @param premium The fee flash borrowed\n   * @param referralCode The referral code used\n   */\n  event FlashLoan(\n    address indexed target,\n    address initiator,\n    address indexed asset,\n    uint256 amount,\n    DataTypes.InterestRateMode interestRateMode,\n    uint256 premium,\n    uint16 indexed referralCode\n  );\n\n  /**\n   * @dev Emitted when a borrower is liquidated.\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n   * @param user The address of the borrower getting liquidated\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n   * @param liquidatedCollateralAmount The amount of collateral received by the liquidator\n   * @param liquidator The address of the liquidator\n   * @param receiveAToken True if the liquidators wants to receive the collateral aTokens, `false` if he wants\n   * to receive the underlying collateral asset directly\n   */\n  event LiquidationCall(\n    address indexed collateralAsset,\n    address indexed debtAsset,\n    address indexed user,\n    uint256 debtToCover,\n    uint256 liquidatedCollateralAmount,\n    address liquidator,\n    bool receiveAToken\n  );\n\n  /**\n   * @dev Emitted when the state of a reserve is updated.\n   * @param reserve The address of the underlying asset of the reserve\n   * @param liquidityRate The next liquidity rate\n   * @param stableBorrowRate The next stable borrow rate @note deprecated on v3.2.0\n   * @param variableBorrowRate The next variable borrow rate\n   * @param liquidityIndex The next liquidity index\n   * @param variableBorrowIndex The next variable borrow index\n   */\n  event ReserveDataUpdated(\n    address indexed reserve,\n    uint256 liquidityRate,\n    uint256 stableBorrowRate,\n    uint256 variableBorrowRate,\n    uint256 liquidityIndex,\n    uint256 variableBorrowIndex\n  );\n\n  /**\n   * @dev Emitted when the deficit of a reserve is covered.\n   * @param reserve The address of the underlying asset of the reserve\n   * @param caller The caller that triggered the DeficitCovered event\n   * @param amountCovered The amount of deficit covered\n   */\n  event DeficitCovered(address indexed reserve, address caller, uint256 amountCovered);\n\n  /**\n   * @dev Emitted when the protocol treasury receives minted aTokens from the accrued interest.\n   * @param reserve The address of the reserve\n   * @param amountMinted The amount minted to the treasury\n   */\n  event MintedToTreasury(address indexed reserve, uint256 amountMinted);\n\n  /**\n   * @dev Emitted when deficit is realized on a liquidation.\n   * @param user The user address where the bad debt will be burned\n   * @param debtAsset The address of the underlying borrowed asset to be burned\n   * @param amountCreated The amount of deficit created\n   */\n  event DeficitCreated(address indexed user, address indexed debtAsset, uint256 amountCreated);\n\n  /**\n   * @notice Mints an `amount` of aTokens to the `onBehalfOf`\n   * @param asset The address of the underlying asset to mint\n   * @param amount The amount to mint\n   * @param onBehalfOf The address that will receive the aTokens\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   */\n  function mintUnbacked(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external;\n\n  /**\n   * @notice Back the current unbacked underlying with `amount` and pay `fee`.\n   * @param asset The address of the underlying asset to back\n   * @param amount The amount to back\n   * @param fee The amount paid in fees\n   * @return The backed amount\n   */\n  function backUnbacked(address asset, uint256 amount, uint256 fee) external returns (uint256);\n\n  /**\n   * @notice Supplies an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\n   * - E.g. User supplies 100 USDC and gets in return 100 aUSDC\n   * @param asset The address of the underlying asset to supply\n   * @param amount The amount to be supplied\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n   *   is a different wallet\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   */\n  function supply(address asset, uint256 amount, address onBehalfOf, uint16 referralCode) external;\n\n  /**\n   * @notice Supply with transfer approval of asset to be supplied done via permit function\n   * see: https://eips.ethereum.org/EIPS/eip-2612 and https://eips.ethereum.org/EIPS/eip-713\n   * @param asset The address of the underlying asset to supply\n   * @param amount The amount to be supplied\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n   *   is a different wallet\n   * @param deadline The deadline timestamp that the permit is valid\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   * @param permitV The V parameter of ERC712 permit sig\n   * @param permitR The R parameter of ERC712 permit sig\n   * @param permitS The S parameter of ERC712 permit sig\n   */\n  function supplyWithPermit(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode,\n    uint256 deadline,\n    uint8 permitV,\n    bytes32 permitR,\n    bytes32 permitS\n  ) external;\n\n  /**\n   * @notice Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\n   * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\n   * @param asset The address of the underlying asset to withdraw\n   * @param amount The underlying amount to be withdrawn\n   *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\n   * @param to The address that will receive the underlying, same as msg.sender if the user\n   *   wants to receive it on his own wallet, or a different address if the beneficiary is a\n   *   different wallet\n   * @return The final amount withdrawn\n   */\n  function withdraw(address asset, uint256 amount, address to) external returns (uint256);\n\n  /**\n   * @notice Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower\n   * already supplied enough collateral, or he was given enough allowance by a credit delegator on the VariableDebtToken\n   * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet\n   *   and 100 variable debt tokens\n   * @param asset The address of the underlying asset to borrow\n   * @param amount The amount to be borrowed\n   * @param interestRateMode 2 for Variable, 1 is deprecated on v3.2.0\n   * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   * @param onBehalfOf The address of the user who will receive the debt. Should be the address of the borrower itself\n   * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator\n   * if he has been given credit delegation allowance\n   */\n  function borrow(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode,\n    uint16 referralCode,\n    address onBehalfOf\n  ) external;\n\n  /**\n   * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned\n   * - E.g. User repays 100 USDC, burning 100 variable debt tokens of the `onBehalfOf` address\n   * @param asset The address of the borrowed underlying asset previously borrowed\n   * @param amount The amount to repay\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n   * @param interestRateMode 2 for Variable, 1 is deprecated on v3.2.0\n   * @param onBehalfOf The address of the user who will get his debt reduced/removed. Should be the address of the\n   * user calling the function if he wants to reduce/remove his own debt, or the address of any other\n   * other borrower whose debt should be removed\n   * @return The final amount repaid\n   */\n  function repay(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode,\n    address onBehalfOf\n  ) external returns (uint256);\n\n  /**\n   * @notice Repay with transfer approval of asset to be repaid done via permit function\n   * see: https://eips.ethereum.org/EIPS/eip-2612 and https://eips.ethereum.org/EIPS/eip-713\n   * @param asset The address of the borrowed underlying asset previously borrowed\n   * @param amount The amount to repay\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n   * @param interestRateMode 2 for Variable, 1 is deprecated on v3.2.0\n   * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the\n   * user calling the function if he wants to reduce/remove his own debt, or the address of any other\n   * other borrower whose debt should be removed\n   * @param deadline The deadline timestamp that the permit is valid\n   * @param permitV The V parameter of ERC712 permit sig\n   * @param permitR The R parameter of ERC712 permit sig\n   * @param permitS The S parameter of ERC712 permit sig\n   * @return The final amount repaid\n   */\n  function repayWithPermit(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode,\n    address onBehalfOf,\n    uint256 deadline,\n    uint8 permitV,\n    bytes32 permitR,\n    bytes32 permitS\n  ) external returns (uint256);\n\n  /**\n   * @notice Repays a borrowed `amount` on a specific reserve using the reserve aTokens, burning the\n   * equivalent debt tokens\n   * - E.g. User repays 100 USDC using 100 aUSDC, burning 100 variable debt tokens\n   * @dev  Passing uint256.max as amount will clean up any residual aToken dust balance, if the user aToken\n   * balance is not enough to cover the whole debt\n   * @param asset The address of the borrowed underlying asset previously borrowed\n   * @param amount The amount to repay\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n   * @param interestRateMode DEPRECATED in v3.2.0\n   * @return The final amount repaid\n   */\n  function repayWithATokens(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode\n  ) external returns (uint256);\n\n  /**\n   * @notice Allows suppliers to enable/disable a specific supplied asset as collateral\n   * @param asset The address of the underlying asset supplied\n   * @param useAsCollateral True if the user wants to use the supply as collateral, false otherwise\n   */\n  function setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external;\n\n  /**\n   * @notice Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1\n   * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives\n   *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n   * @param user The address of the borrower getting liquidated\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n   * @param receiveAToken True if the liquidators wants to receive the collateral aTokens, `false` if he wants\n   * to receive the underlying collateral asset directly\n   */\n  function liquidationCall(\n    address collateralAsset,\n    address debtAsset,\n    address user,\n    uint256 debtToCover,\n    bool receiveAToken\n  ) external;\n\n  /**\n   * @notice Allows smartcontracts to access the liquidity of the pool within one transaction,\n   * as long as the amount taken plus a fee is returned.\n   * @dev IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept\n   * into consideration. For further details please visit https://docs.aave.com/developers/\n   * @param receiverAddress The address of the contract receiving the funds, implementing IFlashLoanReceiver interface\n   * @param assets The addresses of the assets being flash-borrowed\n   * @param amounts The amounts of the assets being flash-borrowed\n   * @param interestRateModes Types of the debt to open if the flash loan is not returned:\n   *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver\n   *   1 -> Deprecated on v3.2.0\n   *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n   * @param onBehalfOf The address  that will receive the debt in the case of using 2 on `modes`\n   * @param params Variadic packed params to pass to the receiver as extra information\n   * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   */\n  function flashLoan(\n    address receiverAddress,\n    address[] calldata assets,\n    uint256[] calldata amounts,\n    uint256[] calldata interestRateModes,\n    address onBehalfOf,\n    bytes calldata params,\n    uint16 referralCode\n  ) external;\n\n  /**\n   * @notice Allows smartcontracts to access the liquidity of the pool within one transaction,\n   * as long as the amount taken plus a fee is returned.\n   * @dev IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept\n   * into consideration. For further details please visit https://docs.aave.com/developers/\n   * @param receiverAddress The address of the contract receiving the funds, implementing IFlashLoanSimpleReceiver interface\n   * @param asset The address of the asset being flash-borrowed\n   * @param amount The amount of the asset being flash-borrowed\n   * @param params Variadic packed params to pass to the receiver as extra information\n   * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   */\n  function flashLoanSimple(\n    address receiverAddress,\n    address asset,\n    uint256 amount,\n    bytes calldata params,\n    uint16 referralCode\n  ) external;\n\n  /**\n   * @notice Returns the user account data across all the reserves\n   * @param user The address of the user\n   * @return totalCollateralBase The total collateral of the user in the base currency used by the price feed\n   * @return totalDebtBase The total debt of the user in the base currency used by the price feed\n   * @return availableBorrowsBase The borrowing power left of the user in the base currency used by the price feed\n   * @return currentLiquidationThreshold The liquidation threshold of the user\n   * @return ltv The loan to value of The user\n   * @return healthFactor The current health factor of the user\n   */\n  function getUserAccountData(\n    address user\n  )\n    external\n    view\n    returns (\n      uint256 totalCollateralBase,\n      uint256 totalDebtBase,\n      uint256 availableBorrowsBase,\n      uint256 currentLiquidationThreshold,\n      uint256 ltv,\n      uint256 healthFactor\n    );\n\n  /**\n   * @notice Initializes a reserve, activating it, assigning an aToken and debt tokens and an\n   * interest rate strategy\n   * @dev Only callable by the PoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param aTokenAddress The address of the aToken that will be assigned to the reserve\n   * @param variableDebtAddress The address of the VariableDebtToken that will be assigned to the reserve\n   * @param interestRateStrategyAddress The address of the interest rate strategy contract\n   */\n  function initReserve(\n    address asset,\n    address aTokenAddress,\n    address variableDebtAddress,\n    address interestRateStrategyAddress\n  ) external;\n\n  /**\n   * @notice Drop a reserve\n   * @dev Only callable by the PoolConfigurator contract\n   * @dev Does not reset eMode flags, which must be considered when reusing the same reserve id for a different reserve.\n   * @param asset The address of the underlying asset of the reserve\n   */\n  function dropReserve(address asset) external;\n\n  /**\n   * @notice Updates the address of the interest rate strategy contract\n   * @dev Only callable by the PoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param rateStrategyAddress The address of the interest rate strategy contract\n   */\n  function setReserveInterestRateStrategyAddress(\n    address asset,\n    address rateStrategyAddress\n  ) external;\n\n  /**\n   * @notice Accumulates interest to all indexes of the reserve\n   * @dev Only callable by the PoolConfigurator contract\n   * @dev To be used when required by the configurator, for example when updating interest rates strategy data\n   * @param asset The address of the underlying asset of the reserve\n   */\n  function syncIndexesState(address asset) external;\n\n  /**\n   * @notice Updates interest rates on the reserve data\n   * @dev Only callable by the PoolConfigurator contract\n   * @dev To be used when required by the configurator, for example when updating interest rates strategy data\n   * @param asset The address of the underlying asset of the reserve\n   */\n  function syncRatesState(address asset) external;\n\n  /**\n   * @notice Sets the configuration bitmap of the reserve as a whole\n   * @dev Only callable by the PoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param configuration The new configuration bitmap\n   */\n  function setConfiguration(\n    address asset,\n    DataTypes.ReserveConfigurationMap calldata configuration\n  ) external;\n\n  /**\n   * @notice Returns the configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The configuration of the reserve\n   */\n  function getConfiguration(\n    address asset\n  ) external view returns (DataTypes.ReserveConfigurationMap memory);\n\n  /**\n   * @notice Returns the configuration of the user across all the reserves\n   * @param user The user address\n   * @return The configuration of the user\n   */\n  function getUserConfiguration(\n    address user\n  ) external view returns (DataTypes.UserConfigurationMap memory);\n\n  /**\n   * @notice Returns the normalized income of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve's normalized income\n   */\n  function getReserveNormalizedIncome(address asset) external view returns (uint256);\n\n  /**\n   * @notice Returns the normalized variable debt per unit of asset\n   * @dev WARNING: This function is intended to be used primarily by the protocol itself to get a\n   * \"dynamic\" variable index based on time, current stored index and virtual rate at the current\n   * moment (approx. a borrower would get if opening a position). This means that is always used in\n   * combination with variable debt supply/balances.\n   * If using this function externally, consider that is possible to have an increasing normalized\n   * variable debt that is not equivalent to how the variable debt index would be updated in storage\n   * (e.g. only updates with non-zero variable debt supply)\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve normalized variable debt\n   */\n  function getReserveNormalizedVariableDebt(address asset) external view returns (uint256);\n\n  /**\n   * @notice Returns the state and configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The state and configuration data of the reserve\n   */\n  function getReserveData(address asset) external view returns (DataTypes.ReserveDataLegacy memory);\n\n  /**\n   * @notice Returns the virtual underlying balance of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve virtual underlying balance\n   */\n  function getVirtualUnderlyingBalance(address asset) external view returns (uint128);\n\n  /**\n   * @notice Validates and finalizes an aToken transfer\n   * @dev Only callable by the overlying aToken of the `asset`\n   * @param asset The address of the underlying asset of the aToken\n   * @param from The user from which the aTokens are transferred\n   * @param to The user receiving the aTokens\n   * @param amount The amount being transferred/withdrawn\n   * @param balanceFromBefore The aToken balance of the `from` user before the transfer\n   * @param balanceToBefore The aToken balance of the `to` user before the transfer\n   */\n  function finalizeTransfer(\n    address asset,\n    address from,\n    address to,\n    uint256 amount,\n    uint256 balanceFromBefore,\n    uint256 balanceToBefore\n  ) external;\n\n  /**\n   * @notice Returns the list of the underlying assets of all the initialized reserves\n   * @dev It does not include dropped reserves\n   * @return The addresses of the underlying assets of the initialized reserves\n   */\n  function getReservesList() external view returns (address[] memory);\n\n  /**\n   * @notice Returns the number of initialized reserves\n   * @dev It includes dropped reserves\n   * @return The count\n   */\n  function getReservesCount() external view returns (uint256);\n\n  /**\n   * @notice Returns the address of the underlying asset of a reserve by the reserve id as stored in the DataTypes.ReserveData struct\n   * @param id The id of the reserve as stored in the DataTypes.ReserveData struct\n   * @return The address of the reserve associated with id\n   */\n  function getReserveAddressById(uint16 id) external view returns (address);\n\n  /**\n   * @notice Returns the PoolAddressesProvider connected to this contract\n   * @return The address of the PoolAddressesProvider\n   */\n  function ADDRESSES_PROVIDER() external view returns (IPoolAddressesProvider);\n\n  /**\n   * @notice Updates the protocol fee on the bridging\n   * @param bridgeProtocolFee The part of the premium sent to the protocol treasury\n   */\n  function updateBridgeProtocolFee(uint256 bridgeProtocolFee) external;\n\n  /**\n   * @notice Updates flash loan premiums. Flash loan premium consists of two parts:\n   * - A part is sent to aToken holders as extra, one time accumulated interest\n   * - A part is collected by the protocol treasury\n   * @dev The total premium is calculated on the total borrowed amount\n   * @dev The premium to protocol is calculated on the total premium, being a percentage of `flashLoanPremiumTotal`\n   * @dev Only callable by the PoolConfigurator contract\n   * @param flashLoanPremiumTotal The total premium, expressed in bps\n   * @param flashLoanPremiumToProtocol The part of the premium sent to the protocol treasury, expressed in bps\n   */\n  function updateFlashloanPremiums(\n    uint128 flashLoanPremiumTotal,\n    uint128 flashLoanPremiumToProtocol\n  ) external;\n\n  /**\n   * @notice Configures a new or alters an existing collateral configuration of an eMode.\n   * @dev In eMode, the protocol allows very high borrowing power to borrow assets of the same category.\n   * The category 0 is reserved as it's the default for volatile assets\n   * @param id The id of the category\n   * @param config The configuration of the category\n   */\n  function configureEModeCategory(\n    uint8 id,\n    DataTypes.EModeCategoryBaseConfiguration memory config\n  ) external;\n\n  /**\n   * @notice Replaces the current eMode collateralBitmap.\n   * @param id The id of the category\n   * @param collateralBitmap The collateralBitmap of the category\n   */\n  function configureEModeCategoryCollateralBitmap(uint8 id, uint128 collateralBitmap) external;\n\n  /**\n   * @notice Replaces the current eMode borrowableBitmap.\n   * @param id The id of the category\n   * @param borrowableBitmap The borrowableBitmap of the category\n   */\n  function configureEModeCategoryBorrowableBitmap(uint8 id, uint128 borrowableBitmap) external;\n\n  /**\n   * @notice Returns the data of an eMode category\n   * @dev DEPRECATED use independent getters instead\n   * @param id The id of the category\n   * @return The configuration data of the category\n   */\n  function getEModeCategoryData(\n    uint8 id\n  ) external view returns (DataTypes.EModeCategoryLegacy memory);\n\n  /**\n   * @notice Returns the label of an eMode category\n   * @param id The id of the category\n   * @return The label of the category\n   */\n  function getEModeCategoryLabel(uint8 id) external view returns (string memory);\n\n  /**\n   * @notice Returns the collateral config of an eMode category\n   * @param id The id of the category\n   * @return The ltv,lt,lb of the category\n   */\n  function getEModeCategoryCollateralConfig(\n    uint8 id\n  ) external view returns (DataTypes.CollateralConfig memory);\n\n  /**\n   * @notice Returns the collateralBitmap of an eMode category\n   * @param id The id of the category\n   * @return The collateralBitmap of the category\n   */\n  function getEModeCategoryCollateralBitmap(uint8 id) external view returns (uint128);\n\n  /**\n   * @notice Returns the borrowableBitmap of an eMode category\n   * @param id The id of the category\n   * @return The borrowableBitmap of the category\n   */\n  function getEModeCategoryBorrowableBitmap(uint8 id) external view returns (uint128);\n\n  /**\n   * @notice Allows a user to use the protocol in eMode\n   * @param categoryId The id of the category\n   */\n  function setUserEMode(uint8 categoryId) external;\n\n  /**\n   * @notice Returns the eMode the user is using\n   * @param user The address of the user\n   * @return The eMode id\n   */\n  function getUserEMode(address user) external view returns (uint256);\n\n  /**\n   * @notice Resets the isolation mode total debt of the given asset to zero\n   * @dev It requires the given asset has zero debt ceiling\n   * @param asset The address of the underlying asset to reset the isolationModeTotalDebt\n   */\n  function resetIsolationModeTotalDebt(address asset) external;\n\n  /**\n   * @notice Sets the liquidation grace period of the given asset\n   * @dev To enable a liquidation grace period, a timestamp in the future should be set,\n   *      To disable a liquidation grace period, any timestamp in the past works, like 0\n   * @param asset The address of the underlying asset to set the liquidationGracePeriod\n   * @param until Timestamp when the liquidation grace period will end\n   **/\n  function setLiquidationGracePeriod(address asset, uint40 until) external;\n\n  /**\n   * @notice Returns the liquidation grace period of the given asset\n   * @param asset The address of the underlying asset\n   * @return Timestamp when the liquidation grace period will end\n   **/\n  function getLiquidationGracePeriod(address asset) external view returns (uint40);\n\n  /**\n   * @notice Returns the total fee on flash loans\n   * @return The total fee on flashloans\n   */\n  function FLASHLOAN_PREMIUM_TOTAL() external view returns (uint128);\n\n  /**\n   * @notice Returns the part of the bridge fees sent to protocol\n   * @return The bridge fee sent to the protocol treasury\n   */\n  function BRIDGE_PROTOCOL_FEE() external view returns (uint256);\n\n  /**\n   * @notice Returns the part of the flashloan fees sent to protocol\n   * @return The flashloan fee sent to the protocol treasury\n   */\n  function FLASHLOAN_PREMIUM_TO_PROTOCOL() external view returns (uint128);\n\n  /**\n   * @notice Returns the maximum number of reserves supported to be listed in this Pool\n   * @return The maximum number of reserves supported\n   */\n  function MAX_NUMBER_RESERVES() external view returns (uint16);\n\n  /**\n   * @notice Mints the assets accrued through the reserve factor to the treasury in the form of aTokens\n   * @param assets The list of reserves for which the minting needs to be executed\n   */\n  function mintToTreasury(address[] calldata assets) external;\n\n  /**\n   * @notice Rescue and transfer tokens locked in this contract\n   * @param token The address of the token\n   * @param to The address of the recipient\n   * @param amount The amount of token to transfer\n   */\n  function rescueTokens(address token, address to, uint256 amount) external;\n\n  /**\n   * @notice Supplies an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\n   * - E.g. User supplies 100 USDC and gets in return 100 aUSDC\n   * @dev Deprecated: Use the `supply` function instead\n   * @param asset The address of the underlying asset to supply\n   * @param amount The amount to be supplied\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n   *   is a different wallet\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   */\n  function deposit(address asset, uint256 amount, address onBehalfOf, uint16 referralCode) external;\n\n  /**\n   * @notice It covers the deficit of a specified reserve by burning:\n   * - the equivalent aToken `amount` for assets with virtual accounting enabled\n   * - the equivalent `amount` of underlying for assets with virtual accounting disabled (e.g. GHO)\n   * @dev The deficit of a reserve can occur due to situations where borrowed assets are not repaid, leading to bad debt.\n   * @param asset The address of the underlying asset to cover the deficit.\n   * @param amount The amount to be covered, in aToken or underlying on non-virtual accounted assets\n   */\n  function eliminateReserveDeficit(address asset, uint256 amount) external;\n\n  /**\n   * @notice Returns the current deficit of a reserve.\n   * @param asset The address of the underlying asset of the reserve\n   * @return The current deficit of the reserve\n   */\n  function getReserveDeficit(address asset) external view returns (uint256);\n\n  /**\n   * @notice Returns the aToken address of a reserve.\n   * @param asset The address of the underlying asset of the reserve\n   * @return The address of the aToken\n   */\n  function getReserveAToken(address asset) external view returns (address);\n\n  /**\n   * @notice Returns the variableDebtToken address of a reserve.\n   * @param asset The address of the underlying asset of the reserve\n   * @return The address of the variableDebtToken\n   */\n  function getReserveVariableDebtToken(address asset) external view returns (address);\n\n  /**\n   * @notice Gets the address of the external FlashLoanLogic\n   */\n  function getFlashLoanLogic() external view returns (address);\n\n  /**\n   * @notice Gets the address of the external BorrowLogic\n   */\n  function getBorrowLogic() external view returns (address);\n\n  /**\n   * @notice Gets the address of the external BridgeLogic\n   */\n  function getBridgeLogic() external view returns (address);\n\n  /**\n   * @notice Gets the address of the external EModeLogic\n   */\n  function getEModeLogic() external view returns (address);\n\n  /**\n   * @notice Gets the address of the external LiquidationLogic\n   */\n  function getLiquidationLogic() external view returns (address);\n\n  /**\n   * @notice Gets the address of the external PoolLogic\n   */\n  function getPoolLogic() external view returns (address);\n\n  /**\n   * @notice Gets the address of the external SupplyLogic\n   */\n  function getSupplyLogic() external view returns (address);\n}\n"
    },
    "lib/aave-umbrella/lib/aave-v3-origin/lib/solidity-utils/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/interfaces/IERC4626.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (interfaces/IERC4626.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../token/ERC20/IERC20.sol\";\nimport {IERC20Metadata} from \"../token/ERC20/extensions/IERC20Metadata.sol\";\n\n/**\n * @dev Interface of the ERC-4626 \"Tokenized Vault Standard\", as defined in\n * https://eips.ethereum.org/EIPS/eip-4626[ERC-4626].\n */\ninterface IERC4626 is IERC20, IERC20Metadata {\n    event Deposit(address indexed sender, address indexed owner, uint256 assets, uint256 shares);\n\n    event Withdraw(\n        address indexed sender,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /**\n     * @dev Returns the address of the underlying token used for the Vault for accounting, depositing, and withdrawing.\n     *\n     * - MUST be an ERC-20 token contract.\n     * - MUST NOT revert.\n     */\n    function asset() external view returns (address assetTokenAddress);\n\n    /**\n     * @dev Returns the total amount of the underlying asset that is managed by Vault.\n     *\n     * - SHOULD include any compounding that occurs from yield.\n     * - MUST be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT revert.\n     */\n    function totalAssets() external view returns (uint256 totalManagedAssets);\n\n    /**\n     * @dev Returns the amount of shares that the Vault would exchange for the amount of assets provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert.\n     *\n     * NOTE: This calculation MAY NOT reflect the per-user price-per-share, and instead should reflect the\n     * average-users price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n    function convertToShares(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Returns the amount of assets that the Vault would exchange for the amount of shares provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert.\n     *\n     * NOTE: This calculation MAY NOT reflect the per-user price-per-share, and instead should reflect the\n     * average-users price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n    function convertToAssets(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Returns the maximum amount of the underlying asset that can be deposited into the Vault for the receiver,\n     * through a deposit call.\n     *\n     * - MUST return a limited value if receiver is subject to some deposit limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of assets that may be deposited.\n     * - MUST NOT revert.\n     */\n    function maxDeposit(address receiver) external view returns (uint256 maxAssets);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their deposit at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of Vault shares that would be minted in a deposit\n     *   call in the same transaction. I.e. deposit should return the same or more shares as previewDeposit if called\n     *   in the same transaction.\n     * - MUST NOT account for deposit limits like those returned from maxDeposit and should always act as though the\n     *   deposit would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewDeposit SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n    function previewDeposit(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Mints shares Vault shares to receiver by depositing exactly amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   deposit execution, and are accounted for during deposit.\n     * - MUST revert if all of assets cannot be deposited (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vaults underlying asset token.\n     */\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\n\n    /**\n     * @dev Returns the maximum amount of the Vault shares that can be minted for the receiver, through a mint call.\n     * - MUST return a limited value if receiver is subject to some mint limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of shares that may be minted.\n     * - MUST NOT revert.\n     */\n    function maxMint(address receiver) external view returns (uint256 maxShares);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their mint at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of assets that would be deposited in a mint call\n     *   in the same transaction. I.e. mint should return the same or fewer assets as previewMint if called in the\n     *   same transaction.\n     * - MUST NOT account for mint limits like those returned from maxMint and should always act as though the mint\n     *   would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewMint SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by minting.\n     */\n    function previewMint(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the mint\n     *   execution, and are accounted for during mint.\n     * - MUST revert if all of shares cannot be minted (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vaults underlying asset token.\n     */\n    function mint(uint256 shares, address receiver) external returns (uint256 assets);\n\n    /**\n     * @dev Returns the maximum amount of the underlying asset that can be withdrawn from the owner balance in the\n     * Vault, through a withdraw call.\n     *\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n    function maxWithdraw(address owner) external view returns (uint256 maxAssets);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their withdrawal at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of Vault shares that would be burned in a withdraw\n     *   call in the same transaction. I.e. withdraw should return the same or fewer shares as previewWithdraw if\n     *   called\n     *   in the same transaction.\n     * - MUST NOT account for withdrawal limits like those returned from maxWithdraw and should always act as though\n     *   the withdrawal would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewWithdraw SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n    function previewWithdraw(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Burns shares from owner and sends exactly assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   withdraw execution, and are accounted for during withdraw.\n     * - MUST revert if all of assets cannot be withdrawn (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * Note that some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n    function withdraw(uint256 assets, address receiver, address owner) external returns (uint256 shares);\n\n    /**\n     * @dev Returns the maximum amount of Vault shares that can be redeemed from the owner balance in the Vault,\n     * through a redeem call.\n     *\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST return balanceOf(owner) if owner is not subject to any withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n    function maxRedeem(address owner) external view returns (uint256 maxShares);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their redeemption at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of assets that would be withdrawn in a redeem call\n     *   in the same transaction. I.e. redeem should return the same or more assets as previewRedeem if called in the\n     *   same transaction.\n     * - MUST NOT account for redemption limits like those returned from maxRedeem and should always act as though the\n     *   redemption would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewRedeem SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by redeeming.\n     */\n    function previewRedeem(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Burns exactly shares from owner and sends assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   redeem execution, and are accounted for during redeem.\n     * - MUST revert if all of shares cannot be redeemed (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * NOTE: some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n    function redeem(uint256 shares, address receiver, address owner) external returns (uint256 assets);\n}\n"
    },
    "lib/aave-umbrella/lib/aave-v3-origin/lib/solidity-utils/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[ERC-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC-20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "lib/aave-umbrella/lib/aave-v3-origin/src/contracts/extensions/stata-token/interfaces/IERC20AaveLM.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\ninterface IERC20AaveLM {\n  struct UserRewardsData {\n    uint128 rewardsIndexOnLastInteraction;\n    uint128 unclaimedRewards;\n  }\n\n  struct RewardIndexCache {\n    bool isRegistered;\n    uint248 lastUpdatedIndex;\n  }\n\n  error ZeroIncentivesControllerIsForbidden();\n  error InvalidClaimer(address claimer);\n  error RewardNotInitialized(address reward);\n\n  event RewardTokenRegistered(address indexed reward, uint256 startIndex);\n\n  /**\n   * @notice Claims rewards from `INCENTIVES_CONTROLLER` and updates internal accounting of rewards.\n   * @param reward The reward to claim\n   * @return uint256 Amount collected\n   */\n  function collectAndUpdateRewards(address reward) external returns (uint256);\n\n  /**\n   * @notice Claim rewards on behalf of a user and send them to a receiver\n   * @dev Only callable by if sender is onBehalfOf or sender is approved claimer\n   * @param onBehalfOf The address to claim on behalf of\n   * @param receiver The address to receive the rewards\n   * @param rewards The rewards to claim\n   */\n  function claimRewardsOnBehalf(\n    address onBehalfOf,\n    address receiver,\n    address[] memory rewards\n  ) external;\n\n  /**\n   * @notice Claim rewards and send them to a receiver\n   * @param receiver The address to receive the rewards\n   * @param rewards The rewards to claim\n   */\n  function claimRewards(address receiver, address[] memory rewards) external;\n\n  /**\n   * @notice Claim rewards\n   * @param rewards The rewards to claim\n   */\n  function claimRewardsToSelf(address[] memory rewards) external;\n\n  /**\n   * @notice Get the total claimable rewards of the contract.\n   * @param reward The reward to claim\n   * @return uint256 The current balance + pending rewards from the `_incentivesController`\n   */\n  function getTotalClaimableRewards(address reward) external view returns (uint256);\n\n  /**\n   * @notice Get the total claimable rewards for a user in asset decimals\n   * @param user The address of the user\n   * @param reward The reward to claim\n   * @return uint256 The claimable amount of rewards in asset decimals\n   */\n  function getClaimableRewards(address user, address reward) external view returns (uint256);\n\n  /**\n   * @notice The unclaimed rewards for a user in asset decimals\n   * @param user The address of the user\n   * @param reward The reward to claim\n   * @return uint256 The unclaimed amount of rewards in asset decimals\n   */\n  function getUnclaimedRewards(address user, address reward) external view returns (uint256);\n\n  /**\n   * @notice The underlying asset reward index in RAY\n   * @param reward The reward to claim\n   * @return uint256 The underlying asset reward index in RAY\n   */\n  function getCurrentRewardsIndex(address reward) external view returns (uint256);\n\n  /**\n   * @notice Returns reference a/v token address used on INCENTIVES_CONTROLLER for tracking\n   * @return address of reference token\n   */\n  function getReferenceAsset() external view returns (address);\n\n  /**\n   * @notice The IERC20s that are currently rewarded to addresses of the vault via LM on incentivescontroller.\n   * @return IERC20 The IERC20s of the rewards.\n   */\n  function rewardTokens() external view returns (address[] memory);\n\n  /**\n   * @notice Fetches all rewardTokens from the incentivecontroller and registers the missing ones.\n   */\n  function refreshRewardTokens() external;\n\n  /**\n   * @notice Checks if the passed token is a registered reward.\n   * @param reward The reward to claim\n   * @return bool signaling if token is a registered reward.\n   */\n  function isRegisteredRewardToken(address reward) external view returns (bool);\n}\n"
    },
    "lib/aave-umbrella/lib/aave-v3-origin/src/contracts/interfaces/IPriceOracleGetter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title IPriceOracleGetter\n * @author Aave\n * @notice Interface for the Aave price oracle.\n */\ninterface IPriceOracleGetter {\n  /**\n   * @notice Returns the base currency address\n   * @dev Address 0x0 is reserved for USD as base currency.\n   * @return Returns the base currency address.\n   */\n  function BASE_CURRENCY() external view returns (address);\n\n  /**\n   * @notice Returns the base currency unit\n   * @dev 1 ether for ETH, 1e8 for USD.\n   * @return Returns the base currency unit.\n   */\n  function BASE_CURRENCY_UNIT() external view returns (uint256);\n\n  /**\n   * @notice Returns the asset price in the base currency\n   * @param asset The address of the asset\n   * @return The price of the asset\n   */\n  function getAssetPrice(address asset) external view returns (uint256);\n}\n"
    },
    "lib/aave-umbrella/lib/aave-v3-origin/src/contracts/interfaces/IPoolAddressesProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title IPoolAddressesProvider\n * @author Aave\n * @notice Defines the basic interface for a Pool Addresses Provider.\n */\ninterface IPoolAddressesProvider {\n  /**\n   * @dev Emitted when the market identifier is updated.\n   * @param oldMarketId The old id of the market\n   * @param newMarketId The new id of the market\n   */\n  event MarketIdSet(string indexed oldMarketId, string indexed newMarketId);\n\n  /**\n   * @dev Emitted when the pool is updated.\n   * @param oldAddress The old address of the Pool\n   * @param newAddress The new address of the Pool\n   */\n  event PoolUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the pool configurator is updated.\n   * @param oldAddress The old address of the PoolConfigurator\n   * @param newAddress The new address of the PoolConfigurator\n   */\n  event PoolConfiguratorUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the price oracle is updated.\n   * @param oldAddress The old address of the PriceOracle\n   * @param newAddress The new address of the PriceOracle\n   */\n  event PriceOracleUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the ACL manager is updated.\n   * @param oldAddress The old address of the ACLManager\n   * @param newAddress The new address of the ACLManager\n   */\n  event ACLManagerUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the ACL admin is updated.\n   * @param oldAddress The old address of the ACLAdmin\n   * @param newAddress The new address of the ACLAdmin\n   */\n  event ACLAdminUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the price oracle sentinel is updated.\n   * @param oldAddress The old address of the PriceOracleSentinel\n   * @param newAddress The new address of the PriceOracleSentinel\n   */\n  event PriceOracleSentinelUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the pool data provider is updated.\n   * @param oldAddress The old address of the PoolDataProvider\n   * @param newAddress The new address of the PoolDataProvider\n   */\n  event PoolDataProviderUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when a new proxy is created.\n   * @param id The identifier of the proxy\n   * @param proxyAddress The address of the created proxy contract\n   * @param implementationAddress The address of the implementation contract\n   */\n  event ProxyCreated(\n    bytes32 indexed id,\n    address indexed proxyAddress,\n    address indexed implementationAddress\n  );\n\n  /**\n   * @dev Emitted when a new non-proxied contract address is registered.\n   * @param id The identifier of the contract\n   * @param oldAddress The address of the old contract\n   * @param newAddress The address of the new contract\n   */\n  event AddressSet(bytes32 indexed id, address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the implementation of the proxy registered with id is updated\n   * @param id The identifier of the contract\n   * @param proxyAddress The address of the proxy contract\n   * @param oldImplementationAddress The address of the old implementation contract\n   * @param newImplementationAddress The address of the new implementation contract\n   */\n  event AddressSetAsProxy(\n    bytes32 indexed id,\n    address indexed proxyAddress,\n    address oldImplementationAddress,\n    address indexed newImplementationAddress\n  );\n\n  /**\n   * @notice Returns the id of the Aave market to which this contract points to.\n   * @return The market id\n   */\n  function getMarketId() external view returns (string memory);\n\n  /**\n   * @notice Associates an id with a specific PoolAddressesProvider.\n   * @dev This can be used to create an onchain registry of PoolAddressesProviders to\n   * identify and validate multiple Aave markets.\n   * @param newMarketId The market id\n   */\n  function setMarketId(string calldata newMarketId) external;\n\n  /**\n   * @notice Returns an address by its identifier.\n   * @dev The returned address might be an EOA or a contract, potentially proxied\n   * @dev It returns ZERO if there is no registered address with the given id\n   * @param id The id\n   * @return The address of the registered for the specified id\n   */\n  function getAddress(bytes32 id) external view returns (address);\n\n  /**\n   * @notice General function to update the implementation of a proxy registered with\n   * certain `id`. If there is no proxy registered, it will instantiate one and\n   * set as implementation the `newImplementationAddress`.\n   * @dev IMPORTANT Use this function carefully, only for ids that don't have an explicit\n   * setter function, in order to avoid unexpected consequences\n   * @param id The id\n   * @param newImplementationAddress The address of the new implementation\n   */\n  function setAddressAsProxy(bytes32 id, address newImplementationAddress) external;\n\n  /**\n   * @notice Sets an address for an id replacing the address saved in the addresses map.\n   * @dev IMPORTANT Use this function carefully, as it will do a hard replacement\n   * @param id The id\n   * @param newAddress The address to set\n   */\n  function setAddress(bytes32 id, address newAddress) external;\n\n  /**\n   * @notice Returns the address of the Pool proxy.\n   * @return The Pool proxy address\n   */\n  function getPool() external view returns (address);\n\n  /**\n   * @notice Updates the implementation of the Pool, or creates a proxy\n   * setting the new `pool` implementation when the function is called for the first time.\n   * @param newPoolImpl The new Pool implementation\n   */\n  function setPoolImpl(address newPoolImpl) external;\n\n  /**\n   * @notice Returns the address of the PoolConfigurator proxy.\n   * @return The PoolConfigurator proxy address\n   */\n  function getPoolConfigurator() external view returns (address);\n\n  /**\n   * @notice Updates the implementation of the PoolConfigurator, or creates a proxy\n   * setting the new `PoolConfigurator` implementation when the function is called for the first time.\n   * @param newPoolConfiguratorImpl The new PoolConfigurator implementation\n   */\n  function setPoolConfiguratorImpl(address newPoolConfiguratorImpl) external;\n\n  /**\n   * @notice Returns the address of the price oracle.\n   * @return The address of the PriceOracle\n   */\n  function getPriceOracle() external view returns (address);\n\n  /**\n   * @notice Updates the address of the price oracle.\n   * @param newPriceOracle The address of the new PriceOracle\n   */\n  function setPriceOracle(address newPriceOracle) external;\n\n  /**\n   * @notice Returns the address of the ACL manager.\n   * @return The address of the ACLManager\n   */\n  function getACLManager() external view returns (address);\n\n  /**\n   * @notice Updates the address of the ACL manager.\n   * @param newAclManager The address of the new ACLManager\n   */\n  function setACLManager(address newAclManager) external;\n\n  /**\n   * @notice Returns the address of the ACL admin.\n   * @return The address of the ACL admin\n   */\n  function getACLAdmin() external view returns (address);\n\n  /**\n   * @notice Updates the address of the ACL admin.\n   * @param newAclAdmin The address of the new ACL admin\n   */\n  function setACLAdmin(address newAclAdmin) external;\n\n  /**\n   * @notice Returns the address of the price oracle sentinel.\n   * @return The address of the PriceOracleSentinel\n   */\n  function getPriceOracleSentinel() external view returns (address);\n\n  /**\n   * @notice Updates the address of the price oracle sentinel.\n   * @param newPriceOracleSentinel The address of the new PriceOracleSentinel\n   */\n  function setPriceOracleSentinel(address newPriceOracleSentinel) external;\n\n  /**\n   * @notice Returns the address of the data provider.\n   * @return The address of the DataProvider\n   */\n  function getPoolDataProvider() external view returns (address);\n\n  /**\n   * @notice Updates the address of the data provider.\n   * @param newDataProvider The address of the new DataProvider\n   */\n  function setPoolDataProvider(address newDataProvider) external;\n}\n"
    },
    "lib/aave-umbrella/lib/aave-v3-origin/src/contracts/dependencies/openzeppelin/contracts/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n  /**\n   * @dev Returns the amount of tokens in existence.\n   */\n  function totalSupply() external view returns (uint256);\n\n  /**\n   * @dev Returns the amount of tokens owned by `account`.\n   */\n  function balanceOf(address account) external view returns (uint256);\n\n  /**\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transfer(address recipient, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Returns the remaining number of tokens that `spender` will be\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\n   * zero by default.\n   *\n   * This value changes when {approve} or {transferFrom} are called.\n   */\n  function allowance(address owner, address spender) external view returns (uint256);\n\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\n   * that someone may use both the old and the new allowance by unfortunate\n   * transaction ordering. One possible solution to mitigate this race\n   * condition is to first reduce the spender's allowance to 0 and set the\n   * desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   *\n   * Emits an {Approval} event.\n   */\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\n   * allowance mechanism. `amount` is then deducted from the caller's\n   * allowance.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\n   * another (`to`).\n   *\n   * Note that `value` may be zero.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  /**\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n   * a call to {approve}. `value` is the new allowance.\n   */\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "lib/aave-umbrella/lib/aave-v3-origin/src/contracts/interfaces/IScaledBalanceToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title IScaledBalanceToken\n * @author Aave\n * @notice Defines the basic interface for a scaled-balance token.\n */\ninterface IScaledBalanceToken {\n  /**\n   * @dev Emitted after the mint action\n   * @param caller The address performing the mint\n   * @param onBehalfOf The address of the user that will receive the minted tokens\n   * @param value The scaled-up amount being minted (based on user entered amount and balance increase from interest)\n   * @param balanceIncrease The increase in scaled-up balance since the last action of 'onBehalfOf'\n   * @param index The next liquidity index of the reserve\n   */\n  event Mint(\n    address indexed caller,\n    address indexed onBehalfOf,\n    uint256 value,\n    uint256 balanceIncrease,\n    uint256 index\n  );\n\n  /**\n   * @dev Emitted after the burn action\n   * @dev If the burn function does not involve a transfer of the underlying asset, the target defaults to zero address\n   * @param from The address from which the tokens will be burned\n   * @param target The address that will receive the underlying, if any\n   * @param value The scaled-up amount being burned (user entered amount - balance increase from interest)\n   * @param balanceIncrease The increase in scaled-up balance since the last action of 'from'\n   * @param index The next liquidity index of the reserve\n   */\n  event Burn(\n    address indexed from,\n    address indexed target,\n    uint256 value,\n    uint256 balanceIncrease,\n    uint256 index\n  );\n\n  /**\n   * @notice Returns the scaled balance of the user.\n   * @dev The scaled balance is the sum of all the updated stored balance divided by the reserve's liquidity index\n   * at the moment of the update\n   * @param user The user whose balance is calculated\n   * @return The scaled balance of the user\n   */\n  function scaledBalanceOf(address user) external view returns (uint256);\n\n  /**\n   * @notice Returns the scaled balance of the user and the scaled total supply.\n   * @param user The address of the user\n   * @return The scaled balance of the user\n   * @return The scaled total supply\n   */\n  function getScaledUserBalanceAndSupply(address user) external view returns (uint256, uint256);\n\n  /**\n   * @notice Returns the scaled total supply of the scaled balance token. Represents sum(debt/index)\n   * @return The scaled total supply\n   */\n  function scaledTotalSupply() external view returns (uint256);\n\n  /**\n   * @notice Returns last index interest was accrued to the user's balance\n   * @param user The address of the user\n   * @return The last index interest was accrued to the user's balance, expressed in ray\n   */\n  function getPreviousIndex(address user) external view returns (uint256);\n}\n"
    },
    "lib/aave-umbrella/lib/aave-v3-origin/src/contracts/interfaces/IInitializableAToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IAaveIncentivesController} from './IAaveIncentivesController.sol';\nimport {IPool} from './IPool.sol';\n\n/**\n * @title IInitializableAToken\n * @author Aave\n * @notice Interface for the initialize function on AToken\n */\ninterface IInitializableAToken {\n  /**\n   * @dev Emitted when an aToken is initialized\n   * @param underlyingAsset The address of the underlying asset\n   * @param pool The address of the associated pool\n   * @param treasury The address of the treasury\n   * @param incentivesController The address of the incentives controller for this aToken\n   * @param aTokenDecimals The decimals of the underlying\n   * @param aTokenName The name of the aToken\n   * @param aTokenSymbol The symbol of the aToken\n   * @param params A set of encoded parameters for additional initialization\n   */\n  event Initialized(\n    address indexed underlyingAsset,\n    address indexed pool,\n    address treasury,\n    address incentivesController,\n    uint8 aTokenDecimals,\n    string aTokenName,\n    string aTokenSymbol,\n    bytes params\n  );\n\n  /**\n   * @notice Initializes the aToken\n   * @param pool The pool contract that is initializing this contract\n   * @param treasury The address of the Aave treasury, receiving the fees on this aToken\n   * @param underlyingAsset The address of the underlying asset of this aToken (E.g. WETH for aWETH)\n   * @param incentivesController The smart contract managing potential incentives distribution\n   * @param aTokenDecimals The decimals of the aToken, same as the underlying asset's\n   * @param aTokenName The name of the aToken\n   * @param aTokenSymbol The symbol of the aToken\n   * @param params A set of encoded parameters for additional initialization\n   */\n  function initialize(\n    IPool pool,\n    address treasury,\n    address underlyingAsset,\n    IAaveIncentivesController incentivesController,\n    uint8 aTokenDecimals,\n    string calldata aTokenName,\n    string calldata aTokenSymbol,\n    bytes calldata params\n  ) external;\n}\n"
    },
    "lib/aave-umbrella/src/contracts/stakeToken/interfaces/IOracleToken.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\ninterface IOracleToken {\n  /**\n   * @notice Returns the current asset price of the `UmbrellaStakeToken`.\n   * @dev The price is calculated as `underlyingPrice * exchangeRate`.\n   *\n   * This function is not functional immediately after the creation of an `UmbrellaStakeToken`,\n   * but after the creation of a `SlashingConfig` for this token within `Umbrella`.\n   * The function will remain operational even after the removal of `SlashingConfig`,\n   * as the `Umbrella` contract retains information about the last installed oracle.\n   *\n   * The function may result in a revert if the asset to shares exchange rate leads to overflow.\n   *\n   * This function is intended solely for off-chain calculations and is not a critical component of `Umbrella`.\n   * It should not be relied upon by other systems as a primary source of price information.\n   *\n   * @return Current asset price\n   */\n  function latestAnswer() external view returns (int256);\n}\n"
    },
    "lib/aave-umbrella/src/contracts/rewards/interfaces/IRewardsDistributor.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {IRewardsStructs} from './IRewardsStructs.sol';\n\ninterface IRewardsDistributor is IRewardsStructs {\n  /**\n   * @notice Event is emitted when a `user` or admin installs/disables `claimer` for claiming user rewards.\n   * @param user Address of the `user`\n   * @param claimer Address of the `claimer` to install/disable\n   * @param caller Address of the `msg.sender` who changes claimer\n   * @param flag Flag responsible for setting/disabling `claimer`\n   */\n  event ClaimerSet(\n    address indexed user,\n    address indexed claimer,\n    address indexed caller,\n    bool flag\n  );\n\n  /**\n   * @dev Attempted to use signature with expired deadline.\n   */\n  error ExpiredSignature(uint256 deadline);\n\n  /**\n   * @dev Mismatched signature.\n   */\n  error InvalidSigner(address signer, address owner);\n\n  /**\n   * @dev Attempted to claim `reward` without authorization.\n   */\n  error ClaimerNotAuthorized(address claimer, address user);\n\n  /**\n   * @dev Attempted to claim rewards for assets while arrays lengths don't match.\n   */\n  error LengthsDontMatch();\n\n  /**\n   * @dev Attempted to set zero address.\n   */\n  error ZeroAddress();\n\n  // DEFAULT_ADMIN_ROLE\n  /////////////////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @notice Installs/disables `claimer` for claiming `user` rewards.\n   * @param user Address of the `user`\n   * @param claimer Address of the `claimer` to install/disable\n   * @param flag Flag responsible for setting/disabling `claimer`\n   */\n  function setClaimer(address user, address claimer, bool flag) external;\n\n  /////////////////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @notice Installs/disables `claimer` for claiming `msg.sender` rewards.\n   * @param claimer Address of the `claimer` to install/disable\n   * @param flag Flag responsible for setting/disabling `claimer`\n   */\n  function setClaimer(address claimer, bool flag) external;\n\n  /**\n   * @notice Claims all existing `rewards` for a certain `asset` on behalf of `msg.sender`.\n   * Makes an update and calculates new `index` and `accrued` `rewards` before claim.\n   * @dev Always claims all `rewards`.\n   * @param asset Address of the `asset` whose `rewards` should be claimed\n   * @param receiver Address of the funds receiver\n   * @return rewards Array containing the addresses of all `reward` tokens claimed\n   * @return amounts Array containing the corresponding `amounts` of each `reward` claimed\n   */\n  function claimAllRewards(\n    address asset,\n    address receiver\n  ) external returns (address[] memory rewards, uint256[] memory amounts);\n\n  /**\n   * @notice Claims all existing `rewards` on behalf of `user` for a certain `asset` by `msg.sender`.\n   * Makes an update and calculates new `index` and `accrued` `rewards` before claim.\n   * @dev Always claims all `rewards`.\n   * @param asset Address of the `asset` whose `rewards` should be claimed\n   * @param user Address of user, which accrued `rewards` should be claimed\n   * @param receiver Address of the funds receiver\n   * @return rewards Array containing the addresses of all `reward` tokens claimed\n   * @return amounts Array containing the corresponding `amounts` of each `reward` claimed\n   */\n  function claimAllRewardsOnBehalf(\n    address asset,\n    address user,\n    address receiver\n  ) external returns (address[] memory rewards, uint256[] memory amounts);\n\n  /**\n   * @notice Claims all existing `rewards` on behalf of `user` for a certain `asset` using signature.\n   * Makes an update and calculates new `index` and `accrued` `rewards` before claim.\n   * @dev Always claims all `rewards`.\n   * @param asset Address of the `asset` whose `rewards` should be claimed\n   * @param user Address of user, which accrued `rewards` should be claimed\n   * @param receiver Address of the funds receiver\n   * @param deadline Signature deadline for claiming\n   * @param sig Signature parameters\n   * @return rewards Array containing the addresses of all `reward` tokens claimed\n   * @return amounts Array containing the corresponding `amounts` of each `reward` claimed\n   */\n  function claimAllRewardsPermit(\n    address asset,\n    address user,\n    address receiver,\n    uint256 deadline,\n    SignatureParams calldata sig\n  ) external returns (address[] memory rewards, uint256[] memory amounts);\n\n  /**\n   * @notice Claims selected `rewards` of `msg.sender` for a certain `asset`.\n   * Makes an update and calculates new `index` and `accrued` `rewards` before claim.\n   * @param asset Address of the `asset` whose `rewards` should be claimed\n   * @param rewards Array of `reward` addresses, which should be claimed\n   * @param receiver Address of the funds receiver\n   * @return amounts Array containing the corresponding `amounts` of each `reward` claimed\n   */\n  function claimSelectedRewards(\n    address asset,\n    address[] calldata rewards,\n    address receiver\n  ) external returns (uint256[] memory amounts);\n\n  /**\n   * @notice Claims selected `rewards` on behalf of `user` for a certain `asset` by `msg.sender`.\n   * Makes an update and calculates new `index` and `accrued` `rewards` before claim.\n   * @param asset Address of the `asset` whose `rewards` should be claimed\n   * @param rewards Array of `reward` addresses, which should be claimed\n   * @param user Address of user, which accrued `rewards` should be claimed\n   * @param receiver Address of the funds receiver\n   * @return amounts Array containing the corresponding `amounts` of each `reward` claimed\n   */\n  function claimSelectedRewardsOnBehalf(\n    address asset,\n    address[] calldata rewards,\n    address user,\n    address receiver\n  ) external returns (uint256[] memory amounts);\n\n  /**\n   * @notice Claims selected `rewards` on behalf of `user` for a certain `asset` using signature.\n   * Makes an update and calculates new `index` and `accrued` `rewards` before claim.\n   * @param asset Address of the `asset` whose `rewards` should be claimed\n   * @param rewards Array of `reward` addresses, which should be claimed\n   * @param user Address of user, which accrued `rewards` should be claimed\n   * @param receiver Address of the funds receiver\n   * @param deadline Signature deadline for claiming\n   * @param sig Signature parameters\n   * @return amounts Array containing the corresponding `amounts` of each `reward` claimed\n   */\n  function claimSelectedRewardsPermit(\n    address asset,\n    address[] calldata rewards,\n    address user,\n    address receiver,\n    uint256 deadline,\n    SignatureParams calldata sig\n  ) external returns (uint256[] memory amounts);\n\n  /**\n   * @notice Claims all existing `rewards` of `msg.sender` across multiple `assets`.\n   * Makes an update and calculates new `index` and `accrued` `rewards` before claim.\n   * @dev Always claims all `rewards`.\n   * @param assets Array of addresses representing the `assets`, whose `rewards` should be claimed\n   * @param receiver Address of the funds receiver\n   * @return rewards Two-dimensional array where each inner array contains the addresses of `reward` tokens for a specific `asset`\n   * @return amounts Two-dimensional array where each inner array contains the amounts of each `reward` claimed for a specific `asset`\n   */\n  function claimAllRewards(\n    address[] calldata assets,\n    address receiver\n  ) external returns (address[][] memory rewards, uint256[][] memory amounts);\n\n  /**\n   * @notice Claims all existing `rewards` on behalf of `user` across multiple `assets` by `msg.sender`.\n   * Makes an update and calculates new `index` and `accrued` `rewards` before claim.\n   * @dev Always claims all `rewards`.\n   * @param assets Array of addresses representing the `assets`, whose `rewards` should be claimed\n   * @param user Address of user, which accrued `rewards` should be claimed\n   * @param receiver Address of the funds receiver\n   * @return rewards Two-dimensional array where each inner array contains the addresses of `reward` tokens for a specific `asset`\n   * @return amounts Two-dimensional array where each inner array contains the amounts of each `reward` claimed for a specific `asset`\n   */\n  function claimAllRewardsOnBehalf(\n    address[] calldata assets,\n    address user,\n    address receiver\n  ) external returns (address[][] memory rewards, uint256[][] memory amounts);\n\n  /**\n   * @notice Claims selected `rewards` of `msg.sender` across multiple `assets`.\n   * Makes an update and calculates new `index` and `accrued` `rewards` before claim.\n   * @param assets Array of addresses representing the `assets`, whose `rewards` should be claimed\n   * @param rewards Two-dimensional array where each inner array contains the addresses of `rewards` for a specific `asset`\n   * @param receiver Address of the funds receiver\n   * @return amounts Two-dimensional array where each inner array contains the amounts of each `reward` claimed for a specific `asset`\n   */\n  function claimSelectedRewards(\n    address[] calldata assets,\n    address[][] calldata rewards,\n    address receiver\n  ) external returns (uint256[][] memory);\n\n  /**\n   * @notice Claims selected `rewards` on behalf of `user` across multiple `assets` by `msg.sender`.\n   * Makes an update and calculates new `index` and `accrued` `rewards` before claim.\n   * @param assets Array of addresses representing the `assets`, whose `rewards` should be claimed\n   * @param rewards Two-dimensional array where each inner array contains the addresses of `rewards` for a specific `asset`\n   * @param user Address of user, which accrued `rewards` should be claimed\n   * @param receiver Address of the funds receiver\n   * @return amounts Two-dimensional array where each inner array contains the amounts of each `reward` claimed for a specific `asset`\n   */\n  function claimSelectedRewardsOnBehalf(\n    address[] calldata assets,\n    address[][] calldata rewards,\n    address user,\n    address receiver\n  ) external returns (uint256[][] memory);\n}\n"
    },
    "lib/aave-umbrella/src/contracts/stakeToken/interfaces/IERC4626StakeToken.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {IERC4626} from 'openzeppelin-contracts/contracts/interfaces/IERC4626.sol';\n\ninterface IERC4626StakeToken is IERC4626 {\n  struct CooldownSnapshot {\n    /// @notice Amount of shares available to redeem\n    uint192 amount;\n    /// @notice Timestamp after which funds will be unlocked for withdrawal\n    uint32 endOfCooldown;\n    /// @notice Period of time to withdraw funds after end of cooldown\n    uint32 withdrawalWindow;\n  }\n\n  struct SignatureParams {\n    uint8 v;\n    bytes32 r;\n    bytes32 s;\n  }\n\n  /**\n   * @notice Event is emitted when a cooldown of staker is changed.\n   * @param user Staker address\n   * @param amount Amount of shares on the time cooldown is changed\n   * @param endOfCooldown Future timestamp, from which funds can be withdrawn\n   * @param unstakeWindow Duration of time to withdraw funds\n   */\n  event StakerCooldownUpdated(\n    address indexed user,\n    uint256 amount,\n    uint256 endOfCooldown,\n    uint256 unstakeWindow\n  );\n\n  /**\n   * @notice Event is emitted when a user installs/disables the operator for cooldown.\n   * @param user User address\n   * @param operator Address of operator to install/disable\n   * @param flag Flag responsible for setting/disabling operator\n   */\n  event CooldownOperatorSet(address indexed user, address indexed operator, bool flag);\n\n  /**\n   * @notice Event is emitted when a successful slash occurs\n   * @param destination Address, where funds transferred to\n   * @param amount Amount of funds transferred\n   */\n  event Slashed(address indexed destination, uint256 amount);\n\n  /**\n   * @notice Event is emitted when `cooldown` is changed to the new one\n   * @param oldCooldown Old `cooldown` duration\n   * @param newCooldown New `cooldown` duration\n   */\n  event CooldownChanged(uint256 oldCooldown, uint256 newCooldown);\n\n  /**\n   * @notice Event is emitted when `unstakeWindow` is changed to the new one\n   * @param oldUnstakeWindow Old `unstakeWindow` duration\n   * @param newUnstakeWindow new `unstakeWindow` duration\n   */\n  event UnstakeWindowChanged(uint256 oldUnstakeWindow, uint256 newUnstakeWindow);\n\n  /**\n   * @dev Attempted to set zero address as a variable.\n   */\n  error ZeroAddress();\n\n  /**\n   * @dev Attempted to call cooldown without locked liquidity.\n   */\n  error ZeroBalanceInStaking();\n\n  /**\n   * @dev Attempted to slash for zero amount of assets.\n   */\n  error ZeroAmountSlashing();\n\n  /**\n   * @dev Attempted to slash with insufficient funds in staking.\n   */\n  error ZeroFundsAvailable();\n\n  /**\n   * @dev Attempted to call cooldown without approval for `cooldownOnBehalf`.\n   * @param owner Address of user, which cooldown wasn't triggered\n   * @param spender Address of `msg.sender`\n   */\n  error NotApprovedForCooldown(address owner, address spender);\n\n  /**\n   * @notice Deposits by issuing approval for the required number of tokens (if `asset` supports the `permit` function).\n   * Emits a {Deposit} event.\n   * @param assets Amount of assets to be deposited\n   * @param receiver Receiver of shares\n   * @param deadline Signature deadline for issuing approve\n   * @param sig Signature parameters\n   * @return Amount of shares received\n   */\n  function depositWithPermit(\n    uint256 assets,\n    address receiver,\n    uint256 deadline,\n    SignatureParams calldata sig\n  ) external returns (uint256);\n\n  /**\n   * @notice Triggers user's `cooldown` using signature.\n   * Emits a {StakerCooldownUpdated} event.\n   * @param user The address, which `cooldown` will be triggered\n   * @param deadline Signature deadline for issuing approve\n   * @param sig Signature parameters\n   */\n  function cooldownWithPermit(\n    address user,\n    uint256 deadline,\n    SignatureParams calldata sig\n  ) external;\n\n  /**\n   * @notice Activates the cooldown period to unstake for `msg.sender`.\n   * It can't be called if the user is not staking.\n   * Emits a {StakerCooldownUpdated} event.\n   */\n  function cooldown() external;\n\n  /**\n   * @notice Activates the cooldown period to unstake for a certain user.\n   * It can't be called if the user is not staking.\n   * `from` must set as `cooldownOperator` for `msg.sender` so that he can activate the cooldown on his behalf.\n   * Emits a {StakerCooldownUpdated} event.\n   * @param from Address at which the `cooldown` will be activated\n   */\n  function cooldownOnBehalfOf(address from) external;\n\n  /**\n   * @notice Sets the ability to call `cooldownOnBehalf` for `msg.sender` by specified `operator` to `true` or `false`.\n   * Doesn't revert if the new `flag` value is the same as the old one.\n   * Emits a {CooldownOnBehalfChanged} event.\n   * @param operator The address that the ability to call `cooldownOnBehalf` for `msg.sender` can be changed\n   * @param flag True - to activate this ability, false - to deactivate\n   */\n  function setCooldownOperator(address operator, bool flag) external;\n\n  /**\n   * @notice Executes a slashing of the asset of a certain amount, transferring the seized funds\n   * to destination. Decreasing the amount of underlying will automatically adjust the exchange rate.\n   * If the amount exceeds maxSlashableAmount then the second one is taken.\n   * Can only be called by the `owner`.\n   * Emits a {Slashed} event.\n   * @param destination Address where seized funds will be transferred\n   * @param amount Amount to be slashed\n   * @return amount Amount slashed\n   */\n  function slash(address destination, uint256 amount) external returns (uint256);\n\n  /**\n   * @notice Pauses the contract, can be called by `owner`.\n   * Emits a {Paused} event.\n   */\n  function pause() external;\n\n  /**\n   * @notice Unpauses the contract, can be called by `owner`.\n   * Emits a {Unpaused} event.\n   */\n  function unpause() external;\n\n  /**\n   * @notice Sets a new `cooldown` duration.\n   * Can only be called by the `owner`.\n   * Emits a {CooldownChanged} event.\n   * @param cooldown Amount of seconds users have to wait between starting the `cooldown` and being able to withdraw funds\n   */\n  function setCooldown(uint256 cooldown) external;\n\n  /**\n   * @notice Sets a new `unstakeWindow` duration.\n   * Can only be called by the `owner`.\n   * Emits a {UnstakeWindowChanged} event.\n   * @param newUnstakeWindow Amount of seconds users have to withdraw after `cooldown`\n   */\n  function setUnstakeWindow(uint256 newUnstakeWindow) external;\n\n  /**\n   * @notice Returns current `cooldown` duration.\n   * @return _cooldown duration\n   */\n  function getCooldown() external view returns (uint256);\n\n  /**\n   * @notice Returns current `unstakeWindow` duration.\n   * @return _unstakeWindow duration\n   */\n  function getUnstakeWindow() external view returns (uint256);\n\n  /**\n   * @notice Returns the last activated user `cooldown`. Contains the amount of tokens and timestamp.\n   * May return zero values if all funds have been withdrawn or transferred.\n   * @param user Address of user\n   * @return User's cooldown snapshot\n   */\n  function getStakerCooldown(address user) external view returns (CooldownSnapshot memory);\n\n  /**\n   * @notice Returns true if the user's cooldown can be triggered by an operator, false - otherwise.\n   * @param user Address of the user.\n   * @param operator Address of an operator.\n   * @return Is operator set for `cooldownOnBehalf`\n   */\n  function isCooldownOperator(address user, address operator) external view returns (bool);\n\n  /**\n   * @notice Returns the next unused nonce for an address, which could be used inside signature for `cooldownWithPermit()` function.\n   * @param owner Address for which unused `cooldown` nonce will be returned\n   * @return The next unused `cooldown` nonce\n   */\n  function cooldownNonces(address owner) external view returns (uint256);\n\n  /**\n   * @notice Returns the maximum slashable assets available for now.\n   * @return Maximum assets available for slash\n   */\n  function getMaxSlashableAssets() external view returns (uint256);\n\n  /**\n   * @notice Returns the minimum amount of assets, which can't be slashed.\n   * @return Minimum assets value that cannot be slashed\n   */\n  function MIN_ASSETS_REMAINING() external view returns (uint256);\n}\n"
    },
    "lib/aave-umbrella/src/contracts/umbrella/interfaces/IUmbrellaStkManager.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.27;\n\nimport {ITransparentProxyFactory} from 'solidity-utils/contracts/transparent-proxy/interfaces/ITransparentProxyFactory.sol';\n\nimport {IUmbrellaConfiguration} from './IUmbrellaConfiguration.sol';\n\ninterface IUmbrellaStkManager is IUmbrellaConfiguration {\n  struct StakeTokenSetup {\n    /// @notice Address of the underlying token for which the `UmbrellaStakeToken` will be created\n    address underlying;\n    /// @notice Cooldown duration of the `UmbrellaStakeToken`\n    uint256 cooldown;\n    /// @notice Time period during which funds can be withdrawn from the `UmbrellaStakeToken`\n    uint256 unstakeWindow;\n    /// @notice Suffix to be added in the end to name and symbol (optional, can be empty)\n    string suffix;\n  }\n\n  struct CooldownConfig {\n    /// @notice `UmbrellaStakeToken` address\n    address umbrellaStake;\n    /// @notice Amount of seconds users have to wait between triggering the `cooldown()` and being able to withdraw funds\n    uint256 newCooldown;\n  }\n\n  struct UnstakeWindowConfig {\n    /// @notice `UmbrellaStakeToken` address\n    address umbrellaStake;\n    /// @notice Amount of seconds users have to withdraw after `cooldown`\n    uint256 newUnstakeWindow;\n  }\n\n  /**\n   * @notice Event is emitted when a new `UmbrellaStakeToken` is created.\n   * @param umbrellaStake Address of the new `UmbrellaStakeToken`\n   * @param underlying Address of the underlying token it is created for\n   * @param name Name of the new `UmbrellaStakeToken`\n   * @param symbol Symbol of the new `UmbrellaStakeToken`\n   */\n  event UmbrellaStakeTokenCreated(\n    address indexed umbrellaStake,\n    address indexed underlying,\n    string name,\n    string symbol\n  );\n\n  // DEFAULT_ADMIN_ROLE\n  /////////////////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @notice Creates new `UmbrellaStakeToken`s.\n   * @param stakeTokenSetups Array of `UmbrellaStakeToken`s setup configs\n   * @return stakeTokens Array of new `UmbrellaStakeToken`s addresses\n   */\n  function createStakeTokens(\n    StakeTokenSetup[] calldata stakeTokenSetups\n  ) external returns (address[] memory stakeTokens);\n\n  /**\n   * @notice Sets a new `cooldown`s (in seconds) for the specified `UmbrellaStakeToken`s.\n   * @param cooldownConfigs Array of new `cooldown` configs\n   */\n  function setCooldownStk(CooldownConfig[] calldata cooldownConfigs) external;\n\n  /**\n   * @notice Sets a new `unstakeWindow`s (in seconds) for the specified `UmbrellaStakeToken`s.\n   * @param unstakeWindowConfigs Array of new `unstakeWindow` configs\n   */\n  function setUnstakeWindowStk(UnstakeWindowConfig[] calldata unstakeWindowConfigs) external;\n\n  // RESCUE_GUARDIAN_ROLE\n  /////////////////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @notice Rescue tokens sent erroneously to the contract.\n   * @param stk Address of the `UmbrellaStakeToken` to rescue from\n   * @param erc20Token Address of the token to rescue\n   * @param to Address of the tokens receiver\n   * @param amount Amount of tokens to rescue\n   */\n  function emergencyTokenTransferStk(\n    address stk,\n    address erc20Token,\n    address to,\n    uint256 amount\n  ) external;\n\n  /**\n   * @notice Rescue native currency (e.g. Ethereum) sent erroneously to the contract.\n   * @param stk Address of the `UmbrellaStakeToken` to rescue from\n   * @param to Address of the tokens receiver\n   * @param amount Amount of tokens to rescue\n   */\n  function emergencyEtherTransferStk(address stk, address to, uint256 amount) external;\n\n  // PAUSE_GUARDIAN_ROLE\n  /////////////////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @notice Pauses `UmbrellaStakeToken`.\n   * @param stk Address of the `UmbrellaStakeToken` to turn pause on\n   */\n  function pauseStk(address stk) external;\n\n  /**\n   * @notice Unpauses `UmbrellaStakeToken`.\n   * @param stk Address of the `UmbrellaStakeToken` to turn pause off\n   */\n  function unpauseStk(address stk) external;\n\n  /////////////////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @notice Predicts new `UmbrellaStakeToken`s addresses.\n   * @dev Should be used only to predict new `UmbrellaStakeToken` addresses and not to calculate already deployed ones.\n   * @param stakeSetups Array of `UmbrellaStakeToken`s setup configs\n   * @return stakeTokens Array of new `UmbrellaStakeToken`s predicted addresses\n   */\n  function predictStakeTokensAddresses(\n    StakeTokenSetup[] calldata stakeSetups\n  ) external view returns (address[] memory);\n\n  /**\n   * @notice Returns a list of all the `UmbrellaStakeToken`s created via this `Umbrella` instance.\n   * @return Array of addresses containing all the `UmbrellaStakeToken`s\n   */\n  function getStkTokens() external view returns (address[] memory);\n\n  /**\n   * @notice Returns true if the provided address is a `UmbrellaStakeToken` belonging to this `Umbrella` instance.\n   * @return True if the token is part of this `Umbrella`, false otherwise\n   */\n  function isUmbrellaStkToken(address stakeToken) external view returns (bool);\n\n  /**\n   * @notice Returns the `TransparentProxyFactory` contract used to create `UmbrellaStakeToken`s.\n   * @return `TransparentProxyFactory` address\n   */\n  function TRANSPARENT_PROXY_FACTORY() external view returns (ITransparentProxyFactory);\n\n  /**\n   * @notice Returns the `UmbrellaStakeToken` implementation used to instantiate new umbrella stake tokens.\n   * @return `UmbrellaStakeToken` implementation address\n   */\n  function UMBRELLA_STAKE_TOKEN_IMPL() external view returns (address);\n\n  /**\n   * @notice Returns the `SUPER_ADMIN` address, which has `DEFAULT_ADMIN_ROLE` and is used to manage `UmbrellaStakeToken`s upgradability.\n   * @return `SUPER_ADMIN` address\n   */\n  function SUPER_ADMIN() external view returns (address);\n}\n"
    },
    "lib/aave-umbrella/lib/aave-v3-origin/lib/solidity-utils/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/interfaces/IERC1363.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (interfaces/IERC1363.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @title IERC1363\n * @dev Interface of the ERC-1363 standard as defined in the https://eips.ethereum.org/EIPS/eip-1363[ERC-1363].\n *\n * Defines an extension interface for ERC-20 tokens that supports executing code on a recipient contract\n * after `transfer` or `transferFrom`, or code on a spender contract after `approve`, in a single transaction.\n */\ninterface IERC1363 is IERC20, IERC165 {\n    /*\n     * Note: the ERC-165 identifier for this interface is 0xb0202a11.\n     * 0xb0202a11 ===\n     *   bytes4(keccak256('transferAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))\n     */\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @param data Additional data with no specified format, sent in call to `spender`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value, bytes calldata data) external returns (bool);\n}\n"
    },
    "lib/aave-umbrella/lib/aave-v3-origin/lib/solidity-utils/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Address.sol)\n\npragma solidity ^0.8.20;\n\nimport {Errors} from \"./Errors.sol\";\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert Errors.InsufficientBalance(address(this).balance, amount);\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert Errors.FailedCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {Errors.FailedCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert Errors.InsufficientBalance(address(this).balance, value);\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {Errors.FailedCall}) in case\n     * of an unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {Errors.FailedCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {Errors.FailedCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            assembly (\"memory-safe\") {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert Errors.FailedCall();\n        }\n    }\n}\n"
    },
    "lib/aave-umbrella/lib/aave-v3-origin/src/contracts/protocol/libraries/types/DataTypes.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nlibrary DataTypes {\n  /**\n   * This exists specifically to maintain the `getReserveData()` interface, since the new, internal\n   * `ReserveData` struct includes the reserve's `virtualUnderlyingBalance`.\n   */\n  struct ReserveDataLegacy {\n    //stores the reserve configuration\n    ReserveConfigurationMap configuration;\n    //the liquidity index. Expressed in ray\n    uint128 liquidityIndex;\n    //the current supply rate. Expressed in ray\n    uint128 currentLiquidityRate;\n    //variable borrow index. Expressed in ray\n    uint128 variableBorrowIndex;\n    //the current variable borrow rate. Expressed in ray\n    uint128 currentVariableBorrowRate;\n    // DEPRECATED on v3.2.0\n    uint128 currentStableBorrowRate;\n    //timestamp of last update\n    uint40 lastUpdateTimestamp;\n    //the id of the reserve. Represents the position in the list of the active reserves\n    uint16 id;\n    //aToken address\n    address aTokenAddress;\n    // DEPRECATED on v3.2.0\n    address stableDebtTokenAddress;\n    //variableDebtToken address\n    address variableDebtTokenAddress;\n    //address of the interest rate strategy\n    address interestRateStrategyAddress;\n    //the current treasury balance, scaled\n    uint128 accruedToTreasury;\n    //the outstanding unbacked aTokens minted through the bridging feature\n    uint128 unbacked;\n    //the outstanding debt borrowed against this asset in isolation mode\n    uint128 isolationModeTotalDebt;\n  }\n\n  struct ReserveData {\n    //stores the reserve configuration\n    ReserveConfigurationMap configuration;\n    //the liquidity index. Expressed in ray\n    uint128 liquidityIndex;\n    //the current supply rate. Expressed in ray\n    uint128 currentLiquidityRate;\n    //variable borrow index. Expressed in ray\n    uint128 variableBorrowIndex;\n    //the current variable borrow rate. Expressed in ray\n    uint128 currentVariableBorrowRate;\n    /// @notice reused `__deprecatedStableBorrowRate` storage from pre 3.2\n    // the current accumulate deficit in underlying tokens\n    uint128 deficit;\n    //timestamp of last update\n    uint40 lastUpdateTimestamp;\n    //the id of the reserve. Represents the position in the list of the active reserves\n    uint16 id;\n    //timestamp until when liquidations are not allowed on the reserve, if set to past liquidations will be allowed\n    uint40 liquidationGracePeriodUntil;\n    //aToken address\n    address aTokenAddress;\n    // DEPRECATED on v3.2.0\n    address __deprecatedStableDebtTokenAddress;\n    //variableDebtToken address\n    address variableDebtTokenAddress;\n    //address of the interest rate strategy\n    address interestRateStrategyAddress;\n    //the current treasury balance, scaled\n    uint128 accruedToTreasury;\n    //the outstanding unbacked aTokens minted through the bridging feature\n    uint128 unbacked;\n    //the outstanding debt borrowed against this asset in isolation mode\n    uint128 isolationModeTotalDebt;\n    //the amount of underlying accounted for by the protocol\n    uint128 virtualUnderlyingBalance;\n  }\n\n  struct ReserveConfigurationMap {\n    //bit 0-15: LTV\n    //bit 16-31: Liq. threshold\n    //bit 32-47: Liq. bonus\n    //bit 48-55: Decimals\n    //bit 56: reserve is active\n    //bit 57: reserve is frozen\n    //bit 58: borrowing is enabled\n    //bit 59: DEPRECATED: stable rate borrowing enabled\n    //bit 60: asset is paused\n    //bit 61: borrowing in isolation mode is enabled\n    //bit 62: siloed borrowing enabled\n    //bit 63: flashloaning enabled\n    //bit 64-79: reserve factor\n    //bit 80-115: borrow cap in whole tokens, borrowCap == 0 => no cap\n    //bit 116-151: supply cap in whole tokens, supplyCap == 0 => no cap\n    //bit 152-167: liquidation protocol fee\n    //bit 168-175: DEPRECATED: eMode category\n    //bit 176-211: unbacked mint cap in whole tokens, unbackedMintCap == 0 => minting disabled\n    //bit 212-251: debt ceiling for isolation mode with (ReserveConfiguration::DEBT_CEILING_DECIMALS) decimals\n    //bit 252: virtual accounting is enabled for the reserve\n    //bit 253-255 unused\n\n    uint256 data;\n  }\n\n  struct UserConfigurationMap {\n    /**\n     * @dev Bitmap of the users collaterals and borrows. It is divided in pairs of bits, one pair per asset.\n     * The first bit indicates if an asset is used as collateral by the user, the second whether an\n     * asset is borrowed by the user.\n     */\n    uint256 data;\n  }\n\n  // DEPRECATED: kept for backwards compatibility, might be removed in a future version\n  struct EModeCategoryLegacy {\n    // each eMode category has a custom ltv and liquidation threshold\n    uint16 ltv;\n    uint16 liquidationThreshold;\n    uint16 liquidationBonus;\n    // DEPRECATED\n    address priceSource;\n    string label;\n  }\n\n  struct CollateralConfig {\n    uint16 ltv;\n    uint16 liquidationThreshold;\n    uint16 liquidationBonus;\n  }\n\n  struct EModeCategoryBaseConfiguration {\n    uint16 ltv;\n    uint16 liquidationThreshold;\n    uint16 liquidationBonus;\n    string label;\n  }\n\n  struct EModeCategory {\n    // each eMode category has a custom ltv and liquidation threshold\n    uint16 ltv;\n    uint16 liquidationThreshold;\n    uint16 liquidationBonus;\n    uint128 collateralBitmap;\n    string label;\n    uint128 borrowableBitmap;\n  }\n\n  enum InterestRateMode {\n    NONE,\n    __DEPRECATED,\n    VARIABLE\n  }\n\n  struct ReserveCache {\n    uint256 currScaledVariableDebt;\n    uint256 nextScaledVariableDebt;\n    uint256 currLiquidityIndex;\n    uint256 nextLiquidityIndex;\n    uint256 currVariableBorrowIndex;\n    uint256 nextVariableBorrowIndex;\n    uint256 currLiquidityRate;\n    uint256 currVariableBorrowRate;\n    uint256 reserveFactor;\n    ReserveConfigurationMap reserveConfiguration;\n    address aTokenAddress;\n    address variableDebtTokenAddress;\n    uint40 reserveLastUpdateTimestamp;\n  }\n\n  struct ExecuteLiquidationCallParams {\n    uint256 reservesCount;\n    uint256 debtToCover;\n    address collateralAsset;\n    address debtAsset;\n    address user;\n    bool receiveAToken;\n    address priceOracle;\n    uint8 userEModeCategory;\n    address priceOracleSentinel;\n  }\n\n  struct ExecuteSupplyParams {\n    address asset;\n    uint256 amount;\n    address onBehalfOf;\n    uint16 referralCode;\n  }\n\n  struct ExecuteBorrowParams {\n    address asset;\n    address user;\n    address onBehalfOf;\n    uint256 amount;\n    InterestRateMode interestRateMode;\n    uint16 referralCode;\n    bool releaseUnderlying;\n    uint256 reservesCount;\n    address oracle;\n    uint8 userEModeCategory;\n    address priceOracleSentinel;\n  }\n\n  struct ExecuteRepayParams {\n    address asset;\n    uint256 amount;\n    InterestRateMode interestRateMode;\n    address onBehalfOf;\n    bool useATokens;\n  }\n\n  struct ExecuteWithdrawParams {\n    address asset;\n    uint256 amount;\n    address to;\n    uint256 reservesCount;\n    address oracle;\n    uint8 userEModeCategory;\n  }\n\n  struct ExecuteEliminateDeficitParams {\n    address asset;\n    uint256 amount;\n  }\n\n  struct ExecuteSetUserEModeParams {\n    uint256 reservesCount;\n    address oracle;\n    uint8 categoryId;\n  }\n\n  struct FinalizeTransferParams {\n    address asset;\n    address from;\n    address to;\n    uint256 amount;\n    uint256 balanceFromBefore;\n    uint256 balanceToBefore;\n    uint256 reservesCount;\n    address oracle;\n    uint8 fromEModeCategory;\n  }\n\n  struct FlashloanParams {\n    address receiverAddress;\n    address[] assets;\n    uint256[] amounts;\n    uint256[] interestRateModes;\n    address onBehalfOf;\n    bytes params;\n    uint16 referralCode;\n    uint256 flashLoanPremiumToProtocol;\n    uint256 flashLoanPremiumTotal;\n    uint256 reservesCount;\n    address addressesProvider;\n    address pool;\n    uint8 userEModeCategory;\n    bool isAuthorizedFlashBorrower;\n  }\n\n  struct FlashloanSimpleParams {\n    address receiverAddress;\n    address asset;\n    uint256 amount;\n    bytes params;\n    uint16 referralCode;\n    uint256 flashLoanPremiumToProtocol;\n    uint256 flashLoanPremiumTotal;\n  }\n\n  struct FlashLoanRepaymentParams {\n    uint256 amount;\n    uint256 totalPremium;\n    uint256 flashLoanPremiumToProtocol;\n    address asset;\n    address receiverAddress;\n    uint16 referralCode;\n  }\n\n  struct CalculateUserAccountDataParams {\n    UserConfigurationMap userConfig;\n    uint256 reservesCount;\n    address user;\n    address oracle;\n    uint8 userEModeCategory;\n  }\n\n  struct ValidateBorrowParams {\n    ReserveCache reserveCache;\n    UserConfigurationMap userConfig;\n    address asset;\n    address userAddress;\n    uint256 amount;\n    InterestRateMode interestRateMode;\n    uint256 reservesCount;\n    address oracle;\n    uint8 userEModeCategory;\n    address priceOracleSentinel;\n    bool isolationModeActive;\n    address isolationModeCollateralAddress;\n    uint256 isolationModeDebtCeiling;\n  }\n\n  struct ValidateLiquidationCallParams {\n    ReserveCache debtReserveCache;\n    uint256 totalDebt;\n    uint256 healthFactor;\n    address priceOracleSentinel;\n  }\n\n  struct CalculateInterestRatesParams {\n    uint256 unbacked;\n    uint256 liquidityAdded;\n    uint256 liquidityTaken;\n    uint256 totalDebt;\n    uint256 reserveFactor;\n    address reserve;\n    bool usingVirtualBalance;\n    uint256 virtualUnderlyingBalance;\n  }\n\n  struct InitReserveParams {\n    address asset;\n    address aTokenAddress;\n    address variableDebtAddress;\n    address interestRateStrategyAddress;\n    uint16 reservesCount;\n    uint16 maxNumberReserves;\n  }\n}\n"
    },
    "lib/aave-umbrella/lib/aave-v3-origin/src/contracts/interfaces/IAaveIncentivesController.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title IAaveIncentivesController\n * @author Aave\n * @notice Defines the basic interface for an Aave Incentives Controller.\n * @dev It only contains one single function, needed as a hook on aToken and debtToken transfers.\n */\ninterface IAaveIncentivesController {\n  /**\n   * @dev Called by the corresponding asset on transfer hook in order to update the rewards distribution.\n   * @dev The units of `totalSupply` and `userBalance` should be the same.\n   * @param user The address of the user whose asset balance has changed\n   * @param totalSupply The total supply of the asset prior to user balance change\n   * @param userBalance The previous user balance prior to balance change\n   */\n  function handleAction(address user, uint256 totalSupply, uint256 userBalance) external;\n}\n"
    },
    "lib/aave-umbrella/src/contracts/rewards/interfaces/IRewardsStructs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title IRewardsStructs interface\n * @notice An interface containing structures that can be used externally.\n * @author BGD labs\n */\ninterface IRewardsStructs {\n  struct RewardSetupConfig {\n    /// @notice Reward address\n    address reward;\n    /// @notice Address, from which this reward will be transferred (should give approval to this address)\n    address rewardPayer;\n    /// @notice Maximum possible emission rate of rewards per second\n    uint256 maxEmissionPerSecond;\n    /// @notice End of the rewards distribution\n    uint256 distributionEnd;\n  }\n\n  struct AssetDataExternal {\n    /// @notice Liquidity value at which there will be maximum emission per second (expected amount of asset to be deposited into `StakeToken`)\n    uint256 targetLiquidity;\n    /// @notice Timestamp of the last update\n    uint256 lastUpdateTimestamp;\n  }\n\n  struct RewardDataExternal {\n    /// @notice Reward address\n    address addr;\n    /// @notice Liquidity index of the reward set during the last update\n    uint256 index;\n    /// @notice Maximum possible emission rate of rewards per second\n    uint256 maxEmissionPerSecond;\n    /// @notice End of the reward distribution\n    uint256 distributionEnd;\n  }\n\n  struct EmissionData {\n    /// @notice Liquidity value at which there will be maximum emission per second applied\n    uint256 targetLiquidity;\n    /// @notice Liquidity value after which emission per second will be flat\n    uint256 targetLiquidityExcess;\n    /// @notice Maximum possible emission rate of rewards per second (can be with or without scaling to 18 decimals, depending on usage in code)\n    uint256 maxEmission;\n    /// @notice Flat emission value per second (can be with or without scaling, depending on usage in code)\n    uint256 flatEmission;\n  }\n\n  struct UserDataExternal {\n    /// @notice Liquidity index of the user reward set during the last update\n    uint256 index;\n    /// @notice Amount of accrued rewards that the user earned at the time of his last index update (pending to claim)\n    uint256 accrued;\n  }\n\n  struct SignatureParams {\n    uint8 v;\n    bytes32 r;\n    bytes32 s;\n  }\n}\n"
    },
    "lib/aave-umbrella/lib/aave-v3-origin/lib/solidity-utils/src/contracts/transparent-proxy/interfaces/ITransparentProxyFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\ninterface ITransparentProxyFactory {\n  event ProxyCreated(address proxy, address indexed logic, address indexed initialOwner);\n  event ProxyAdminCreated(address proxyAdmin, address indexed initialOwner);\n  event ProxyDeterministicCreated(\n    address proxy,\n    address indexed logic,\n    address indexed initialOwner,\n    bytes32 indexed salt\n  );\n  event ProxyAdminDeterministicCreated(\n    address proxyAdmin,\n    address indexed initialOwner,\n    bytes32 indexed salt\n  );\n\n  /**\n   * @notice Creates a transparent proxy instance, doing the first initialization in construction\n   * @dev Version using CREATE\n   * @param logic The address of the implementation contract\n   * @param initialOwner The initial owner of the admin of the proxy.\n   * @param data abi encoded call to the function with `initializer` (or `reinitializer`) modifier.\n   *             E.g. `abi.encodeWithSelector(mockImpl.initialize.selector, 2)`\n   *             for an `initialize` function being `function initialize(uint256 foo) external initializer;`\n   * @return address The address of the proxy deployed\n   **/\n  function create(\n    address logic,\n    address initialOwner,\n    bytes memory data\n  ) external returns (address);\n\n  /**\n   * @notice Creates a proxyAdmin instance, and transfers ownership to provided owner\n   * @dev Version using CREATE\n   * @param initialOwner The initial owner of the proxyAdmin deployed.\n   * @return address The address of the proxyAdmin deployed\n   **/\n  function createProxyAdmin(address initialOwner) external returns (address);\n\n  /**\n   * @notice Creates a transparent proxy instance, doing the first initialization in construction\n   * @dev Version using CREATE2, so deterministic\n   * @param logic The address of the implementation contract\n   * @param initialOwner The initial owner of the admin of the proxy.\n   * @param data abi encoded call to the function with `initializer` (or `reinitializer`) modifier.\n   *             E.g. `abi.encodeWithSelector(mockImpl.initialize.selector, 2)`\n   *             for an `initialize` function being `function initialize(uint256 foo) external initializer;`\n   * @param salt Value to be used in the address calculation, to be chosen by the account calling this function\n   * @return address The address of the proxy deployed\n   **/\n  function createDeterministic(\n    address logic,\n    address initialOwner,\n    bytes memory data,\n    bytes32 salt\n  ) external returns (address);\n\n  /**\n   * @notice Deterministically create a proxy admin instance and transfers ownership to provided owner.\n   * @dev Version using CREATE2, so deterministic\n   * @param adminOwner The owner of the ProxyAdmin deployed.\n   * @param salt Value to be used in the address calculation, to be chosen by the account calling this function\n   * @return address The address of the proxy admin deployed\n   **/\n  function createDeterministicProxyAdmin(\n    address adminOwner,\n    bytes32 salt\n  ) external returns (address);\n\n  /**\n   * @notice Pre-calculates and return the address on which `createDeterministic` will deploy a proxy\n   * @param logic The address of the implementation contract\n   * @param initialOwner The initial owner of the admin of the proxy.\n   * @param data abi encoded call to the function with `initializer` (or `reinitializer`) modifier.\n   *             E.g. `abi.encodeWithSelector(mockImpl.initialize.selector, 2)`\n   *             for an `initialize` function being `function initialize(uint256 foo) external initializer;`\n   * @param salt Value to be used in the address calculation, to be chosen by the account calling this function\n   * @return address The pre-calculated address\n   **/\n  function predictCreateDeterministic(\n    address logic,\n    address initialOwner,\n    bytes calldata data,\n    bytes32 salt\n  ) external view returns (address);\n\n  /**\n   * @notice Pre-calculates and return the address on which `createDeterministic` will deploy the proxyAdmin\n   * @param salt Value to be used in the address calculation, to be chosen by the account calling this function\n   * @return address The pre-calculated address\n   **/\n  function predictCreateDeterministicProxyAdmin(\n    bytes32 salt,\n    address initialOwner\n  ) external view returns (address);\n\n  /**\n   * @notice Returns the address of the `ProxyAdmin` associated with a given transparent proxy.\n   * @param proxy Address of the transparent proxy\n   * @return address Address of the `ProxyAdmin` that was deployed when the proxy was created\n   */\n  function getProxyAdmin(address proxy) external view returns (address);\n}\n"
    },
    "lib/aave-umbrella/lib/aave-v3-origin/lib/solidity-utils/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../token/ERC20/IERC20.sol\";\n"
    },
    "lib/aave-umbrella/lib/aave-v3-origin/lib/solidity-utils/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../utils/introspection/IERC165.sol\";\n"
    },
    "lib/aave-umbrella/lib/aave-v3-origin/lib/solidity-utils/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/utils/Errors.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Errors.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of common custom errors used in multiple contracts\n *\n * IMPORTANT: Backwards compatibility is not guaranteed in future versions of the library.\n * It is recommended to avoid relying on the error API for critical functionality.\n *\n * _Available since v5.1._\n */\nlibrary Errors {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error InsufficientBalance(uint256 balance, uint256 needed);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedCall();\n\n    /**\n     * @dev The deployment failed.\n     */\n    error FailedDeployment();\n\n    /**\n     * @dev A necessary precompile is missing.\n     */\n    error MissingPrecompile(address);\n}\n"
    },
    "lib/aave-umbrella/lib/aave-v3-origin/lib/solidity-utils/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    }
  },
  "settings": {
    "remappings": [
      "forge-std/=lib/aave-umbrella/lib/forge-std/src/",
      "@openzeppelin/contracts-upgradeable/=lib/aave-umbrella/lib/aave-v3-origin/lib/solidity-utils/lib/openzeppelin-contracts-upgradeable/contracts/",
      "@openzeppelin/contracts/=lib/aave-umbrella/lib/aave-v3-origin/lib/solidity-utils/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/",
      "openzeppelin-contracts-upgradeable/=lib/aave-umbrella/lib/aave-v3-origin/lib/solidity-utils/lib/openzeppelin-contracts-upgradeable/",
      "openzeppelin-contracts/=lib/aave-umbrella/lib/aave-v3-origin/lib/solidity-utils/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/",
      "aave-v3-core/=lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/core/",
      "aave-v3-origin-tests/=lib/aave-umbrella/lib/aave-v3-origin/tests/",
      "aave-v3-origin/=lib/aave-umbrella/lib/aave-v3-origin/src/",
      "aave-v3-periphery/=lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/periphery/",
      "solidity-utils/=lib/aave-umbrella/lib/aave-v3-origin/lib/solidity-utils/src/",
      "aave-address-book/=lib/aave-helpers/lib/aave-address-book/src/",
      "aave-helpers/=lib/aave-helpers/src/",
      "aave-umbrella/=lib/aave-umbrella/",
      "ds-test/=lib/aave-umbrella/lib/aave-v3-origin/lib/forge-std/lib/ds-test/src/",
      "erc4626-tests/=lib/aave-umbrella/lib/erc4626-tests/",
      "halmos-cheatcodes/=lib/aave-umbrella/lib/aave-v3-origin/lib/solidity-utils/lib/openzeppelin-contracts-upgradeable/lib/halmos-cheatcodes/src/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "metadata": {
      "useLiteralContent": false,
      "bytecodeHash": "ipfs",
      "appendCBOR": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "evmVersion": "shanghai",
    "viaIR": false,
    "libraries": {}
  }
}}