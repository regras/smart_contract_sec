{{
  "language": "Solidity",
  "sources": {
    "permit2/src/interfaces/IAllowanceTransfer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {IEIP712} from \"./IEIP712.sol\";\n\n/// @title AllowanceTransfer\n/// @notice Handles ERC20 token permissions through signature based allowance setting and ERC20 token transfers by checking allowed amounts\n/// @dev Requires user's token approval on the Permit2 contract\ninterface IAllowanceTransfer is IEIP712 {\n    /// @notice Thrown when an allowance on a token has expired.\n    /// @param deadline The timestamp at which the allowed amount is no longer valid\n    error AllowanceExpired(uint256 deadline);\n\n    /// @notice Thrown when an allowance on a token has been depleted.\n    /// @param amount The maximum amount allowed\n    error InsufficientAllowance(uint256 amount);\n\n    /// @notice Thrown when too many nonces are invalidated.\n    error ExcessiveInvalidation();\n\n    /// @notice Emits an event when the owner successfully invalidates an ordered nonce.\n    event NonceInvalidation(\n        address indexed owner, address indexed token, address indexed spender, uint48 newNonce, uint48 oldNonce\n    );\n\n    /// @notice Emits an event when the owner successfully sets permissions on a token for the spender.\n    event Approval(\n        address indexed owner, address indexed token, address indexed spender, uint160 amount, uint48 expiration\n    );\n\n    /// @notice Emits an event when the owner successfully sets permissions using a permit signature on a token for the spender.\n    event Permit(\n        address indexed owner,\n        address indexed token,\n        address indexed spender,\n        uint160 amount,\n        uint48 expiration,\n        uint48 nonce\n    );\n\n    /// @notice Emits an event when the owner sets the allowance back to 0 with the lockdown function.\n    event Lockdown(address indexed owner, address token, address spender);\n\n    /// @notice The permit data for a token\n    struct PermitDetails {\n        // ERC20 token address\n        address token;\n        // the maximum amount allowed to spend\n        uint160 amount;\n        // timestamp at which a spender's token allowances become invalid\n        uint48 expiration;\n        // an incrementing value indexed per owner,token,and spender for each signature\n        uint48 nonce;\n    }\n\n    /// @notice The permit message signed for a single token allownce\n    struct PermitSingle {\n        // the permit data for a single token alownce\n        PermitDetails details;\n        // address permissioned on the allowed tokens\n        address spender;\n        // deadline on the permit signature\n        uint256 sigDeadline;\n    }\n\n    /// @notice The permit message signed for multiple token allowances\n    struct PermitBatch {\n        // the permit data for multiple token allowances\n        PermitDetails[] details;\n        // address permissioned on the allowed tokens\n        address spender;\n        // deadline on the permit signature\n        uint256 sigDeadline;\n    }\n\n    /// @notice The saved permissions\n    /// @dev This info is saved per owner, per token, per spender and all signed over in the permit message\n    /// @dev Setting amount to type(uint160).max sets an unlimited approval\n    struct PackedAllowance {\n        // amount allowed\n        uint160 amount;\n        // permission expiry\n        uint48 expiration;\n        // an incrementing value indexed per owner,token,and spender for each signature\n        uint48 nonce;\n    }\n\n    /// @notice A token spender pair.\n    struct TokenSpenderPair {\n        // the token the spender is approved\n        address token;\n        // the spender address\n        address spender;\n    }\n\n    /// @notice Details for a token transfer.\n    struct AllowanceTransferDetails {\n        // the owner of the token\n        address from;\n        // the recipient of the token\n        address to;\n        // the amount of the token\n        uint160 amount;\n        // the token to be transferred\n        address token;\n    }\n\n    /// @notice A mapping from owner address to token address to spender address to PackedAllowance struct, which contains details and conditions of the approval.\n    /// @notice The mapping is indexed in the above order see: allowance[ownerAddress][tokenAddress][spenderAddress]\n    /// @dev The packed slot holds the allowed amount, expiration at which the allowed amount is no longer valid, and current nonce thats updated on any signature based approvals.\n    function allowance(address user, address token, address spender)\n        external\n        view\n        returns (uint160 amount, uint48 expiration, uint48 nonce);\n\n    /// @notice Approves the spender to use up to amount of the specified token up until the expiration\n    /// @param token The token to approve\n    /// @param spender The spender address to approve\n    /// @param amount The approved amount of the token\n    /// @param expiration The timestamp at which the approval is no longer valid\n    /// @dev The packed allowance also holds a nonce, which will stay unchanged in approve\n    /// @dev Setting amount to type(uint160).max sets an unlimited approval\n    function approve(address token, address spender, uint160 amount, uint48 expiration) external;\n\n    /// @notice Permit a spender to a given amount of the owners token via the owner's EIP-712 signature\n    /// @dev May fail if the owner's nonce was invalidated in-flight by invalidateNonce\n    /// @param owner The owner of the tokens being approved\n    /// @param permitSingle Data signed over by the owner specifying the terms of approval\n    /// @param signature The owner's signature over the permit data\n    function permit(address owner, PermitSingle memory permitSingle, bytes calldata signature) external;\n\n    /// @notice Permit a spender to the signed amounts of the owners tokens via the owner's EIP-712 signature\n    /// @dev May fail if the owner's nonce was invalidated in-flight by invalidateNonce\n    /// @param owner The owner of the tokens being approved\n    /// @param permitBatch Data signed over by the owner specifying the terms of approval\n    /// @param signature The owner's signature over the permit data\n    function permit(address owner, PermitBatch memory permitBatch, bytes calldata signature) external;\n\n    /// @notice Transfer approved tokens from one address to another\n    /// @param from The address to transfer from\n    /// @param to The address of the recipient\n    /// @param amount The amount of the token to transfer\n    /// @param token The token address to transfer\n    /// @dev Requires the from address to have approved at least the desired amount\n    /// of tokens to msg.sender.\n    function transferFrom(address from, address to, uint160 amount, address token) external;\n\n    /// @notice Transfer approved tokens in a batch\n    /// @param transferDetails Array of owners, recipients, amounts, and tokens for the transfers\n    /// @dev Requires the from addresses to have approved at least the desired amount\n    /// of tokens to msg.sender.\n    function transferFrom(AllowanceTransferDetails[] calldata transferDetails) external;\n\n    /// @notice Enables performing a \"lockdown\" of the sender's Permit2 identity\n    /// by batch revoking approvals\n    /// @param approvals Array of approvals to revoke.\n    function lockdown(TokenSpenderPair[] calldata approvals) external;\n\n    /// @notice Invalidate nonces for a given (token, spender) pair\n    /// @param token The token to invalidate nonces for\n    /// @param spender The spender to invalidate nonces for\n    /// @param newNonce The new nonce to set. Invalidates all nonces less than it.\n    /// @dev Can't invalidate more than 2**16 nonces per transaction.\n    function invalidateNonces(address token, address spender, uint48 newNonce) external;\n}\n"
    },
    "permit2/src/interfaces/IEIP712.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ninterface IEIP712 {\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "permit2/src/interfaces/IPermit2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {ISignatureTransfer} from \"./ISignatureTransfer.sol\";\nimport {IAllowanceTransfer} from \"./IAllowanceTransfer.sol\";\n\n/// @notice Permit2 handles signature-based transfers in SignatureTransfer and allowance-based transfers in AllowanceTransfer.\n/// @dev Users must approve Permit2 before calling any of the transfer functions.\ninterface IPermit2 is ISignatureTransfer, IAllowanceTransfer {\n// IPermit2 unifies the two interfaces so users have maximal flexibility with their approval.\n}\n"
    },
    "permit2/src/interfaces/ISignatureTransfer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {IEIP712} from \"./IEIP712.sol\";\n\n/// @title SignatureTransfer\n/// @notice Handles ERC20 token transfers through signature based actions\n/// @dev Requires user's token approval on the Permit2 contract\ninterface ISignatureTransfer is IEIP712 {\n    /// @notice Thrown when the requested amount for a transfer is larger than the permissioned amount\n    /// @param maxAmount The maximum amount a spender can request to transfer\n    error InvalidAmount(uint256 maxAmount);\n\n    /// @notice Thrown when the number of tokens permissioned to a spender does not match the number of tokens being transferred\n    /// @dev If the spender does not need to transfer the number of tokens permitted, the spender can request amount 0 to be transferred\n    error LengthMismatch();\n\n    /// @notice Emits an event when the owner successfully invalidates an unordered nonce.\n    event UnorderedNonceInvalidation(address indexed owner, uint256 word, uint256 mask);\n\n    /// @notice The token and amount details for a transfer signed in the permit transfer signature\n    struct TokenPermissions {\n        // ERC20 token address\n        address token;\n        // the maximum amount that can be spent\n        uint256 amount;\n    }\n\n    /// @notice The signed permit message for a single token transfer\n    struct PermitTransferFrom {\n        TokenPermissions permitted;\n        // a unique value for every token owner's signature to prevent signature replays\n        uint256 nonce;\n        // deadline on the permit signature\n        uint256 deadline;\n    }\n\n    /// @notice Specifies the recipient address and amount for batched transfers.\n    /// @dev Recipients and amounts correspond to the index of the signed token permissions array.\n    /// @dev Reverts if the requested amount is greater than the permitted signed amount.\n    struct SignatureTransferDetails {\n        // recipient address\n        address to;\n        // spender requested amount\n        uint256 requestedAmount;\n    }\n\n    /// @notice Used to reconstruct the signed permit message for multiple token transfers\n    /// @dev Do not need to pass in spender address as it is required that it is msg.sender\n    /// @dev Note that a user still signs over a spender address\n    struct PermitBatchTransferFrom {\n        // the tokens and corresponding amounts permitted for a transfer\n        TokenPermissions[] permitted;\n        // a unique value for every token owner's signature to prevent signature replays\n        uint256 nonce;\n        // deadline on the permit signature\n        uint256 deadline;\n    }\n\n    /// @notice A map from token owner address and a caller specified word index to a bitmap. Used to set bits in the bitmap to prevent against signature replay protection\n    /// @dev Uses unordered nonces so that permit messages do not need to be spent in a certain order\n    /// @dev The mapping is indexed first by the token owner, then by an index specified in the nonce\n    /// @dev It returns a uint256 bitmap\n    /// @dev The index, or wordPosition is capped at type(uint248).max\n    function nonceBitmap(address, uint256) external view returns (uint256);\n\n    /// @notice Transfers a token using a signed permit message\n    /// @dev Reverts if the requested amount is greater than the permitted signed amount\n    /// @param permit The permit data signed over by the owner\n    /// @param owner The owner of the tokens to transfer\n    /// @param transferDetails The spender's requested transfer details for the permitted token\n    /// @param signature The signature to verify\n    function permitTransferFrom(\n        PermitTransferFrom memory permit,\n        SignatureTransferDetails calldata transferDetails,\n        address owner,\n        bytes calldata signature\n    ) external;\n\n    /// @notice Transfers a token using a signed permit message\n    /// @notice Includes extra data provided by the caller to verify signature over\n    /// @dev The witness type string must follow EIP712 ordering of nested structs and must include the TokenPermissions type definition\n    /// @dev Reverts if the requested amount is greater than the permitted signed amount\n    /// @param permit The permit data signed over by the owner\n    /// @param owner The owner of the tokens to transfer\n    /// @param transferDetails The spender's requested transfer details for the permitted token\n    /// @param witness Extra data to include when checking the user signature\n    /// @param witnessTypeString The EIP-712 type definition for remaining string stub of the typehash\n    /// @param signature The signature to verify\n    function permitWitnessTransferFrom(\n        PermitTransferFrom memory permit,\n        SignatureTransferDetails calldata transferDetails,\n        address owner,\n        bytes32 witness,\n        string calldata witnessTypeString,\n        bytes calldata signature\n    ) external;\n\n    /// @notice Transfers multiple tokens using a signed permit message\n    /// @param permit The permit data signed over by the owner\n    /// @param owner The owner of the tokens to transfer\n    /// @param transferDetails Specifies the recipient and requested amount for the token transfer\n    /// @param signature The signature to verify\n    function permitTransferFrom(\n        PermitBatchTransferFrom memory permit,\n        SignatureTransferDetails[] calldata transferDetails,\n        address owner,\n        bytes calldata signature\n    ) external;\n\n    /// @notice Transfers multiple tokens using a signed permit message\n    /// @dev The witness type string must follow EIP712 ordering of nested structs and must include the TokenPermissions type definition\n    /// @notice Includes extra data provided by the caller to verify signature over\n    /// @param permit The permit data signed over by the owner\n    /// @param owner The owner of the tokens to transfer\n    /// @param transferDetails Specifies the recipient and requested amount for the token transfer\n    /// @param witness Extra data to include when checking the user signature\n    /// @param witnessTypeString The EIP-712 type definition for remaining string stub of the typehash\n    /// @param signature The signature to verify\n    function permitWitnessTransferFrom(\n        PermitBatchTransferFrom memory permit,\n        SignatureTransferDetails[] calldata transferDetails,\n        address owner,\n        bytes32 witness,\n        string calldata witnessTypeString,\n        bytes calldata signature\n    ) external;\n\n    /// @notice Invalidates the bits specified in mask for the bitmap at the word position\n    /// @dev The wordPos is maxed at type(uint248).max\n    /// @param wordPos A number to index the nonceBitmap at\n    /// @param mask A bitmap masked against msg.sender's current bitmap at the word position\n    function invalidateUnorderedNonces(uint256 wordPos, uint256 mask) external;\n}\n"
    },
    "solady/src/tokens/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Simple ERC20 + EIP-2612 implementation.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol)\n///\n/// @dev Note:\n/// - The ERC20 standard allows minting and transferring to and from the zero address,\n///   minting and transferring zero tokens, as well as self-approvals.\n///   For performance, this implementation WILL NOT revert for such actions.\n///   Please add any checks with overrides if desired.\n/// - The `permit` function uses the ecrecover precompile (0x1).\n///\n/// If you are overriding:\n/// - NEVER violate the ERC20 invariant:\n///   the total sum of all balances must be equal to `totalSupply()`.\n/// - Check that the overridden function is actually used in the function you want to\n///   change the behavior of. Much of the code has been manually inlined for performance.\nabstract contract ERC20 {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The total supply has overflowed.\n    error TotalSupplyOverflow();\n\n    /// @dev The allowance has overflowed.\n    error AllowanceOverflow();\n\n    /// @dev The allowance has underflowed.\n    error AllowanceUnderflow();\n\n    /// @dev Insufficient balance.\n    error InsufficientBalance();\n\n    /// @dev Insufficient allowance.\n    error InsufficientAllowance();\n\n    /// @dev The permit is invalid.\n    error InvalidPermit();\n\n    /// @dev The permit has expired.\n    error PermitExpired();\n\n    /// @dev The allowance of Permit2 is fixed at infinity.\n    error Permit2AllowanceIsFixedAtInfinity();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                           EVENTS                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Emitted when `amount` tokens is transferred from `from` to `to`.\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    /// @dev Emitted when `amount` tokens is approved by `owner` to be used by `spender`.\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /// @dev `keccak256(bytes(\"Transfer(address,address,uint256)\"))`.\n    uint256 private constant _TRANSFER_EVENT_SIGNATURE =\n        0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;\n\n    /// @dev `keccak256(bytes(\"Approval(address,address,uint256)\"))`.\n    uint256 private constant _APPROVAL_EVENT_SIGNATURE =\n        0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                          STORAGE                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The storage slot for the total supply.\n    uint256 private constant _TOTAL_SUPPLY_SLOT = 0x05345cdf77eb68f44c;\n\n    /// @dev The balance slot of `owner` is given by:\n    /// ```\n    ///     mstore(0x0c, _BALANCE_SLOT_SEED)\n    ///     mstore(0x00, owner)\n    ///     let balanceSlot := keccak256(0x0c, 0x20)\n    /// ```\n    uint256 private constant _BALANCE_SLOT_SEED = 0x87a211a2;\n\n    /// @dev The allowance slot of (`owner`, `spender`) is given by:\n    /// ```\n    ///     mstore(0x20, spender)\n    ///     mstore(0x0c, _ALLOWANCE_SLOT_SEED)\n    ///     mstore(0x00, owner)\n    ///     let allowanceSlot := keccak256(0x0c, 0x34)\n    /// ```\n    uint256 private constant _ALLOWANCE_SLOT_SEED = 0x7f5e9f20;\n\n    /// @dev The nonce slot of `owner` is given by:\n    /// ```\n    ///     mstore(0x0c, _NONCES_SLOT_SEED)\n    ///     mstore(0x00, owner)\n    ///     let nonceSlot := keccak256(0x0c, 0x20)\n    /// ```\n    uint256 private constant _NONCES_SLOT_SEED = 0x38377508;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         CONSTANTS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev `(_NONCES_SLOT_SEED << 16) | 0x1901`.\n    uint256 private constant _NONCES_SLOT_SEED_WITH_SIGNATURE_PREFIX = 0x383775081901;\n\n    /// @dev `keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\")`.\n    bytes32 private constant _DOMAIN_TYPEHASH =\n        0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\n\n    /// @dev `keccak256(\"1\")`.\n    /// If you need to use a different version, override `_versionHash`.\n    bytes32 private constant _DEFAULT_VERSION_HASH =\n        0xc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6;\n\n    /// @dev `keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\")`.\n    bytes32 private constant _PERMIT_TYPEHASH =\n        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n\n    /// @dev The canonical Permit2 address.\n    /// For signature-based allowance granting for single transaction ERC20 `transferFrom`.\n    /// To enable, override `_givePermit2InfiniteAllowance()`.\n    /// [Github](https://github.com/Uniswap/permit2)\n    /// [Etherscan](https://etherscan.io/address/0x000000000022D473030F116dDEE9F6B43aC78BA3)\n    address internal constant _PERMIT2 = 0x000000000022D473030F116dDEE9F6B43aC78BA3;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       ERC20 METADATA                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the name of the token.\n    function name() public view virtual returns (string memory);\n\n    /// @dev Returns the symbol of the token.\n    function symbol() public view virtual returns (string memory);\n\n    /// @dev Returns the decimals places of the token.\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                           ERC20                            */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the amount of tokens in existence.\n    function totalSupply() public view virtual returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := sload(_TOTAL_SUPPLY_SLOT)\n        }\n    }\n\n    /// @dev Returns the amount of tokens owned by `owner`.\n    function balanceOf(address owner) public view virtual returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x0c, _BALANCE_SLOT_SEED)\n            mstore(0x00, owner)\n            result := sload(keccak256(0x0c, 0x20))\n        }\n    }\n\n    /// @dev Returns the amount of tokens that `spender` can spend on behalf of `owner`.\n    function allowance(address owner, address spender)\n        public\n        view\n        virtual\n        returns (uint256 result)\n    {\n        if (_givePermit2InfiniteAllowance()) {\n            if (spender == _PERMIT2) return type(uint256).max;\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, spender)\n            mstore(0x0c, _ALLOWANCE_SLOT_SEED)\n            mstore(0x00, owner)\n            result := sload(keccak256(0x0c, 0x34))\n        }\n    }\n\n    /// @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n    ///\n    /// Emits a {Approval} event.\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        if (_givePermit2InfiniteAllowance()) {\n            /// @solidity memory-safe-assembly\n            assembly {\n                // If `spender == _PERMIT2 && amount != type(uint256).max`.\n                if iszero(or(xor(shr(96, shl(96, spender)), _PERMIT2), iszero(not(amount)))) {\n                    mstore(0x00, 0x3f68539a) // `Permit2AllowanceIsFixedAtInfinity()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the allowance slot and store the amount.\n            mstore(0x20, spender)\n            mstore(0x0c, _ALLOWANCE_SLOT_SEED)\n            mstore(0x00, caller())\n            sstore(keccak256(0x0c, 0x34), amount)\n            // Emit the {Approval} event.\n            mstore(0x00, amount)\n            log3(0x00, 0x20, _APPROVAL_EVENT_SIGNATURE, caller(), shr(96, mload(0x2c)))\n        }\n        return true;\n    }\n\n    /// @dev Transfer `amount` tokens from the caller to `to`.\n    ///\n    /// Requirements:\n    /// - `from` must at least have `amount`.\n    ///\n    /// Emits a {Transfer} event.\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        _beforeTokenTransfer(msg.sender, to, amount);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the balance slot and load its value.\n            mstore(0x0c, _BALANCE_SLOT_SEED)\n            mstore(0x00, caller())\n            let fromBalanceSlot := keccak256(0x0c, 0x20)\n            let fromBalance := sload(fromBalanceSlot)\n            // Revert if insufficient balance.\n            if gt(amount, fromBalance) {\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                revert(0x1c, 0x04)\n            }\n            // Subtract and store the updated balance.\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\n            // Compute the balance slot of `to`.\n            mstore(0x00, to)\n            let toBalanceSlot := keccak256(0x0c, 0x20)\n            // Add and store the updated balance of `to`.\n            // Will not overflow because the sum of all user balances\n            // cannot exceed the maximum uint256 value.\n            sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\n            // Emit the {Transfer} event.\n            mstore(0x20, amount)\n            log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, caller(), shr(96, mload(0x0c)))\n        }\n        _afterTokenTransfer(msg.sender, to, amount);\n        return true;\n    }\n\n    /// @dev Transfers `amount` tokens from `from` to `to`.\n    ///\n    /// Note: Does not update the allowance if it is the maximum uint256 value.\n    ///\n    /// Requirements:\n    /// - `from` must at least have `amount`.\n    /// - The caller must have at least `amount` of allowance to transfer the tokens of `from`.\n    ///\n    /// Emits a {Transfer} event.\n    function transferFrom(address from, address to, uint256 amount) public virtual returns (bool) {\n        _beforeTokenTransfer(from, to, amount);\n        // Code duplication is for zero-cost abstraction if possible.\n        if (_givePermit2InfiniteAllowance()) {\n            /// @solidity memory-safe-assembly\n            assembly {\n                let from_ := shl(96, from)\n                if iszero(eq(caller(), _PERMIT2)) {\n                    // Compute the allowance slot and load its value.\n                    mstore(0x20, caller())\n                    mstore(0x0c, or(from_, _ALLOWANCE_SLOT_SEED))\n                    let allowanceSlot := keccak256(0x0c, 0x34)\n                    let allowance_ := sload(allowanceSlot)\n                    // If the allowance is not the maximum uint256 value.\n                    if not(allowance_) {\n                        // Revert if the amount to be transferred exceeds the allowance.\n                        if gt(amount, allowance_) {\n                            mstore(0x00, 0x13be252b) // `InsufficientAllowance()`.\n                            revert(0x1c, 0x04)\n                        }\n                        // Subtract and store the updated allowance.\n                        sstore(allowanceSlot, sub(allowance_, amount))\n                    }\n                }\n                // Compute the balance slot and load its value.\n                mstore(0x0c, or(from_, _BALANCE_SLOT_SEED))\n                let fromBalanceSlot := keccak256(0x0c, 0x20)\n                let fromBalance := sload(fromBalanceSlot)\n                // Revert if insufficient balance.\n                if gt(amount, fromBalance) {\n                    mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                    revert(0x1c, 0x04)\n                }\n                // Subtract and store the updated balance.\n                sstore(fromBalanceSlot, sub(fromBalance, amount))\n                // Compute the balance slot of `to`.\n                mstore(0x00, to)\n                let toBalanceSlot := keccak256(0x0c, 0x20)\n                // Add and store the updated balance of `to`.\n                // Will not overflow because the sum of all user balances\n                // cannot exceed the maximum uint256 value.\n                sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\n                // Emit the {Transfer} event.\n                mstore(0x20, amount)\n                log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, from_), shr(96, mload(0x0c)))\n            }\n        } else {\n            /// @solidity memory-safe-assembly\n            assembly {\n                let from_ := shl(96, from)\n                // Compute the allowance slot and load its value.\n                mstore(0x20, caller())\n                mstore(0x0c, or(from_, _ALLOWANCE_SLOT_SEED))\n                let allowanceSlot := keccak256(0x0c, 0x34)\n                let allowance_ := sload(allowanceSlot)\n                // If the allowance is not the maximum uint256 value.\n                if not(allowance_) {\n                    // Revert if the amount to be transferred exceeds the allowance.\n                    if gt(amount, allowance_) {\n                        mstore(0x00, 0x13be252b) // `InsufficientAllowance()`.\n                        revert(0x1c, 0x04)\n                    }\n                    // Subtract and store the updated allowance.\n                    sstore(allowanceSlot, sub(allowance_, amount))\n                }\n                // Compute the balance slot and load its value.\n                mstore(0x0c, or(from_, _BALANCE_SLOT_SEED))\n                let fromBalanceSlot := keccak256(0x0c, 0x20)\n                let fromBalance := sload(fromBalanceSlot)\n                // Revert if insufficient balance.\n                if gt(amount, fromBalance) {\n                    mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                    revert(0x1c, 0x04)\n                }\n                // Subtract and store the updated balance.\n                sstore(fromBalanceSlot, sub(fromBalance, amount))\n                // Compute the balance slot of `to`.\n                mstore(0x00, to)\n                let toBalanceSlot := keccak256(0x0c, 0x20)\n                // Add and store the updated balance of `to`.\n                // Will not overflow because the sum of all user balances\n                // cannot exceed the maximum uint256 value.\n                sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\n                // Emit the {Transfer} event.\n                mstore(0x20, amount)\n                log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, from_), shr(96, mload(0x0c)))\n            }\n        }\n        _afterTokenTransfer(from, to, amount);\n        return true;\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                          EIP-2612                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev For more performance, override to return the constant value\n    /// of `keccak256(bytes(name()))` if `name()` will never change.\n    function _constantNameHash() internal view virtual returns (bytes32 result) {}\n\n    /// @dev If you need a different value, override this function.\n    function _versionHash() internal view virtual returns (bytes32 result) {\n        result = _DEFAULT_VERSION_HASH;\n    }\n\n    /// @dev For inheriting contracts to increment the nonce.\n    function _incrementNonce(address owner) internal virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x0c, _NONCES_SLOT_SEED)\n            mstore(0x00, owner)\n            let nonceSlot := keccak256(0x0c, 0x20)\n            sstore(nonceSlot, add(1, sload(nonceSlot)))\n        }\n    }\n\n    /// @dev Returns the current nonce for `owner`.\n    /// This value is used to compute the signature for EIP-2612 permit.\n    function nonces(address owner) public view virtual returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the nonce slot and load its value.\n            mstore(0x0c, _NONCES_SLOT_SEED)\n            mstore(0x00, owner)\n            result := sload(keccak256(0x0c, 0x20))\n        }\n    }\n\n    /// @dev Sets `value` as the allowance of `spender` over the tokens of `owner`,\n    /// authorized by a signed approval by `owner`.\n    ///\n    /// Emits a {Approval} event.\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        if (_givePermit2InfiniteAllowance()) {\n            /// @solidity memory-safe-assembly\n            assembly {\n                // If `spender == _PERMIT2 && value != type(uint256).max`.\n                if iszero(or(xor(shr(96, shl(96, spender)), _PERMIT2), iszero(not(value)))) {\n                    mstore(0x00, 0x3f68539a) // `Permit2AllowanceIsFixedAtInfinity()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n        }\n        bytes32 nameHash = _constantNameHash();\n        //  We simply calculate it on-the-fly to allow for cases where the `name` may change.\n        if (nameHash == bytes32(0)) nameHash = keccak256(bytes(name()));\n        bytes32 versionHash = _versionHash();\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Revert if the block timestamp is greater than `deadline`.\n            if gt(timestamp(), deadline) {\n                mstore(0x00, 0x1a15a3cc) // `PermitExpired()`.\n                revert(0x1c, 0x04)\n            }\n            let m := mload(0x40) // Grab the free memory pointer.\n            // Clean the upper 96 bits.\n            owner := shr(96, shl(96, owner))\n            spender := shr(96, shl(96, spender))\n            // Compute the nonce slot and load its value.\n            mstore(0x0e, _NONCES_SLOT_SEED_WITH_SIGNATURE_PREFIX)\n            mstore(0x00, owner)\n            let nonceSlot := keccak256(0x0c, 0x20)\n            let nonceValue := sload(nonceSlot)\n            // Prepare the domain separator.\n            mstore(m, _DOMAIN_TYPEHASH)\n            mstore(add(m, 0x20), nameHash)\n            mstore(add(m, 0x40), versionHash)\n            mstore(add(m, 0x60), chainid())\n            mstore(add(m, 0x80), address())\n            mstore(0x2e, keccak256(m, 0xa0))\n            // Prepare the struct hash.\n            mstore(m, _PERMIT_TYPEHASH)\n            mstore(add(m, 0x20), owner)\n            mstore(add(m, 0x40), spender)\n            mstore(add(m, 0x60), value)\n            mstore(add(m, 0x80), nonceValue)\n            mstore(add(m, 0xa0), deadline)\n            mstore(0x4e, keccak256(m, 0xc0))\n            // Prepare the ecrecover calldata.\n            mstore(0x00, keccak256(0x2c, 0x42))\n            mstore(0x20, and(0xff, v))\n            mstore(0x40, r)\n            mstore(0x60, s)\n            let t := staticcall(gas(), 1, 0x00, 0x80, 0x20, 0x20)\n            // If the ecrecover fails, the returndatasize will be 0x00,\n            // `owner` will be checked if it equals the hash at 0x00,\n            // which evaluates to false (i.e. 0), and we will revert.\n            // If the ecrecover succeeds, the returndatasize will be 0x20,\n            // `owner` will be compared against the returned address at 0x20.\n            if iszero(eq(mload(returndatasize()), owner)) {\n                mstore(0x00, 0xddafbaef) // `InvalidPermit()`.\n                revert(0x1c, 0x04)\n            }\n            // Increment and store the updated nonce.\n            sstore(nonceSlot, add(nonceValue, t)) // `t` is 1 if ecrecover succeeds.\n            // Compute the allowance slot and store the value.\n            // The `owner` is already at slot 0x20.\n            mstore(0x40, or(shl(160, _ALLOWANCE_SLOT_SEED), spender))\n            sstore(keccak256(0x2c, 0x34), value)\n            // Emit the {Approval} event.\n            log3(add(m, 0x60), 0x20, _APPROVAL_EVENT_SIGNATURE, owner, spender)\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero pointer.\n        }\n    }\n\n    /// @dev Returns the EIP-712 domain separator for the EIP-2612 permit.\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32 result) {\n        bytes32 nameHash = _constantNameHash();\n        //  We simply calculate it on-the-fly to allow for cases where the `name` may change.\n        if (nameHash == bytes32(0)) nameHash = keccak256(bytes(name()));\n        bytes32 versionHash = _versionHash();\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Grab the free memory pointer.\n            mstore(m, _DOMAIN_TYPEHASH)\n            mstore(add(m, 0x20), nameHash)\n            mstore(add(m, 0x40), versionHash)\n            mstore(add(m, 0x60), chainid())\n            mstore(add(m, 0x80), address())\n            result := keccak256(m, 0xa0)\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                  INTERNAL MINT FUNCTIONS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Mints `amount` tokens to `to`, increasing the total supply.\n    ///\n    /// Emits a {Transfer} event.\n    function _mint(address to, uint256 amount) internal virtual {\n        _beforeTokenTransfer(address(0), to, amount);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let totalSupplyBefore := sload(_TOTAL_SUPPLY_SLOT)\n            let totalSupplyAfter := add(totalSupplyBefore, amount)\n            // Revert if the total supply overflows.\n            if lt(totalSupplyAfter, totalSupplyBefore) {\n                mstore(0x00, 0xe5cfe957) // `TotalSupplyOverflow()`.\n                revert(0x1c, 0x04)\n            }\n            // Store the updated total supply.\n            sstore(_TOTAL_SUPPLY_SLOT, totalSupplyAfter)\n            // Compute the balance slot and load its value.\n            mstore(0x0c, _BALANCE_SLOT_SEED)\n            mstore(0x00, to)\n            let toBalanceSlot := keccak256(0x0c, 0x20)\n            // Add and store the updated balance.\n            sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\n            // Emit the {Transfer} event.\n            mstore(0x20, amount)\n            log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, 0, shr(96, mload(0x0c)))\n        }\n        _afterTokenTransfer(address(0), to, amount);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                  INTERNAL BURN FUNCTIONS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Burns `amount` tokens from `from`, reducing the total supply.\n    ///\n    /// Emits a {Transfer} event.\n    function _burn(address from, uint256 amount) internal virtual {\n        _beforeTokenTransfer(from, address(0), amount);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the balance slot and load its value.\n            mstore(0x0c, _BALANCE_SLOT_SEED)\n            mstore(0x00, from)\n            let fromBalanceSlot := keccak256(0x0c, 0x20)\n            let fromBalance := sload(fromBalanceSlot)\n            // Revert if insufficient balance.\n            if gt(amount, fromBalance) {\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                revert(0x1c, 0x04)\n            }\n            // Subtract and store the updated balance.\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\n            // Subtract and store the updated total supply.\n            sstore(_TOTAL_SUPPLY_SLOT, sub(sload(_TOTAL_SUPPLY_SLOT), amount))\n            // Emit the {Transfer} event.\n            mstore(0x00, amount)\n            log3(0x00, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, shl(96, from)), 0)\n        }\n        _afterTokenTransfer(from, address(0), amount);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                INTERNAL TRANSFER FUNCTIONS                 */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Moves `amount` of tokens from `from` to `to`.\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        _beforeTokenTransfer(from, to, amount);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let from_ := shl(96, from)\n            // Compute the balance slot and load its value.\n            mstore(0x0c, or(from_, _BALANCE_SLOT_SEED))\n            let fromBalanceSlot := keccak256(0x0c, 0x20)\n            let fromBalance := sload(fromBalanceSlot)\n            // Revert if insufficient balance.\n            if gt(amount, fromBalance) {\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                revert(0x1c, 0x04)\n            }\n            // Subtract and store the updated balance.\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\n            // Compute the balance slot of `to`.\n            mstore(0x00, to)\n            let toBalanceSlot := keccak256(0x0c, 0x20)\n            // Add and store the updated balance of `to`.\n            // Will not overflow because the sum of all user balances\n            // cannot exceed the maximum uint256 value.\n            sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\n            // Emit the {Transfer} event.\n            mstore(0x20, amount)\n            log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, from_), shr(96, mload(0x0c)))\n        }\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                INTERNAL ALLOWANCE FUNCTIONS                */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Updates the allowance of `owner` for `spender` based on spent `amount`.\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        if (_givePermit2InfiniteAllowance()) {\n            if (spender == _PERMIT2) return; // Do nothing, as allowance is infinite.\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the allowance slot and load its value.\n            mstore(0x20, spender)\n            mstore(0x0c, _ALLOWANCE_SLOT_SEED)\n            mstore(0x00, owner)\n            let allowanceSlot := keccak256(0x0c, 0x34)\n            let allowance_ := sload(allowanceSlot)\n            // If the allowance is not the maximum uint256 value.\n            if not(allowance_) {\n                // Revert if the amount to be transferred exceeds the allowance.\n                if gt(amount, allowance_) {\n                    mstore(0x00, 0x13be252b) // `InsufficientAllowance()`.\n                    revert(0x1c, 0x04)\n                }\n                // Subtract and store the updated allowance.\n                sstore(allowanceSlot, sub(allowance_, amount))\n            }\n        }\n    }\n\n    /// @dev Sets `amount` as the allowance of `spender` over the tokens of `owner`.\n    ///\n    /// Emits a {Approval} event.\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        if (_givePermit2InfiniteAllowance()) {\n            /// @solidity memory-safe-assembly\n            assembly {\n                // If `spender == _PERMIT2 && amount != type(uint256).max`.\n                if iszero(or(xor(shr(96, shl(96, spender)), _PERMIT2), iszero(not(amount)))) {\n                    mstore(0x00, 0x3f68539a) // `Permit2AllowanceIsFixedAtInfinity()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            let owner_ := shl(96, owner)\n            // Compute the allowance slot and store the amount.\n            mstore(0x20, spender)\n            mstore(0x0c, or(owner_, _ALLOWANCE_SLOT_SEED))\n            sstore(keccak256(0x0c, 0x34), amount)\n            // Emit the {Approval} event.\n            mstore(0x00, amount)\n            log3(0x00, 0x20, _APPROVAL_EVENT_SIGNATURE, shr(96, owner_), shr(96, mload(0x2c)))\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                     HOOKS TO OVERRIDE                      */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Hook that is called before any transfer of tokens.\n    /// This includes minting and burning.\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /// @dev Hook that is called after any transfer of tokens.\n    /// This includes minting and burning.\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                          PERMIT2                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns whether to fix the Permit2 contract's allowance at infinity.\n    ///\n    /// This value should be kept constant after contract initialization,\n    /// or else the actual allowance values may not match with the {Approval} events.\n    /// For best performance, return a compile-time constant for zero-cost abstraction.\n    function _givePermit2InfiniteAllowance() internal view virtual returns (bool) {\n        return false;\n    }\n}\n"
    },
    "solady/src/utils/SafeTransferLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SafeTransferLib.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\n/// @author Permit2 operations from (https://github.com/Uniswap/permit2/blob/main/src/libraries/Permit2Lib.sol)\n///\n/// @dev Note:\n/// - For ETH transfers, please use `forceSafeTransferETH` for DoS protection.\nlibrary SafeTransferLib {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The ETH transfer has failed.\n    error ETHTransferFailed();\n\n    /// @dev The ERC20 `transferFrom` has failed.\n    error TransferFromFailed();\n\n    /// @dev The ERC20 `transfer` has failed.\n    error TransferFailed();\n\n    /// @dev The ERC20 `approve` has failed.\n    error ApproveFailed();\n\n    /// @dev The ERC20 `totalSupply` query has failed.\n    error TotalSupplyQueryFailed();\n\n    /// @dev The Permit2 operation has failed.\n    error Permit2Failed();\n\n    /// @dev The Permit2 amount must be less than `2**160 - 1`.\n    error Permit2AmountOverflow();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         CONSTANTS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Suggested gas stipend for contract receiving ETH that disallows any storage writes.\n    uint256 internal constant GAS_STIPEND_NO_STORAGE_WRITES = 2300;\n\n    /// @dev Suggested gas stipend for contract receiving ETH to perform a few\n    /// storage reads and writes, but low enough to prevent griefing.\n    uint256 internal constant GAS_STIPEND_NO_GRIEF = 100000;\n\n    /// @dev The unique EIP-712 domain domain separator for the DAI token contract.\n    bytes32 internal constant DAI_DOMAIN_SEPARATOR =\n        0xdbb8cf42e1ecb028be3f3dbc922e1d878b963f411dc388ced501601c60f7c6f7;\n\n    /// @dev The address for the WETH9 contract on Ethereum mainnet.\n    address internal constant WETH9 = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n    /// @dev The canonical Permit2 address.\n    /// [Github](https://github.com/Uniswap/permit2)\n    /// [Etherscan](https://etherscan.io/address/0x000000000022D473030F116dDEE9F6B43aC78BA3)\n    address internal constant PERMIT2 = 0x000000000022D473030F116dDEE9F6B43aC78BA3;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       ETH OPERATIONS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // If the ETH transfer MUST succeed with a reasonable gas budget, use the force variants.\n    //\n    // The regular variants:\n    // - Forwards all remaining gas to the target.\n    // - Reverts if the target reverts.\n    // - Reverts if the current contract has insufficient balance.\n    //\n    // The force variants:\n    // - Forwards with an optional gas stipend\n    //   (defaults to `GAS_STIPEND_NO_GRIEF`, which is sufficient for most cases).\n    // - If the target reverts, or if the gas stipend is exhausted,\n    //   creates a temporary contract to force send the ETH via `SELFDESTRUCT`.\n    //   Future compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758.\n    // - Reverts if the current contract has insufficient balance.\n    //\n    // The try variants:\n    // - Forwards with a mandatory gas stipend.\n    // - Instead of reverting, returns whether the transfer succeeded.\n\n    /// @dev Sends `amount` (in wei) ETH to `to`.\n    function safeTransferETH(address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(call(gas(), to, amount, codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Sends all the ETH in the current contract to `to`.\n    function safeTransferAllETH(address to) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Transfer all the ETH and check if it succeeded or not.\n            if iszero(call(gas(), to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\n    function forceSafeTransferETH(address to, uint256 amount, uint256 gasStipend) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if lt(selfbalance(), amount) {\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n            if iszero(call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, to) // Store the address in scratch space.\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\n            }\n        }\n    }\n\n    /// @dev Force sends all the ETH in the current contract to `to`, with a `gasStipend`.\n    function forceSafeTransferAllETH(address to, uint256 gasStipend) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, to) // Store the address in scratch space.\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\n            }\n        }\n    }\n\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with `GAS_STIPEND_NO_GRIEF`.\n    function forceSafeTransferETH(address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if lt(selfbalance(), amount) {\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, amount, codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, to) // Store the address in scratch space.\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\n            }\n        }\n    }\n\n    /// @dev Force sends all the ETH in the current contract to `to`, with `GAS_STIPEND_NO_GRIEF`.\n    function forceSafeTransferAllETH(address to) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // forgefmt: disable-next-item\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, to) // Store the address in scratch space.\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\n            }\n        }\n    }\n\n    /// @dev Sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\n    function trySafeTransferETH(address to, uint256 amount, uint256 gasStipend)\n        internal\n        returns (bool success)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            success := call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)\n        }\n    }\n\n    /// @dev Sends all the ETH in the current contract to `to`, with a `gasStipend`.\n    function trySafeTransferAllETH(address to, uint256 gasStipend)\n        internal\n        returns (bool success)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            success := call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      ERC20 OPERATIONS                      */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\n    /// Reverts upon failure.\n    ///\n    /// The `from` account must have at least `amount` approved for\n    /// the current contract to manage.\n    function safeTransferFrom(address token, address from, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, amount) // Store the `amount` argument.\n            mstore(0x40, to) // Store the `to` argument.\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\n            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.\n            let success := call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\n            if iszero(and(eq(mload(0x00), 1), success)) {\n                if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\n                    mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            mstore(0x60, 0) // Restore the zero slot to zero.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\n    ///\n    /// The `from` account must have at least `amount` approved for the current contract to manage.\n    function trySafeTransferFrom(address token, address from, address to, uint256 amount)\n        internal\n        returns (bool success)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, amount) // Store the `amount` argument.\n            mstore(0x40, to) // Store the `to` argument.\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\n            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.\n            success := call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\n            if iszero(and(eq(mload(0x00), 1), success)) {\n                success := lt(or(iszero(extcodesize(token)), returndatasize()), success)\n            }\n            mstore(0x60, 0) // Restore the zero slot to zero.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /// @dev Sends all of ERC20 `token` from `from` to `to`.\n    /// Reverts upon failure.\n    ///\n    /// The `from` account must have their entire balance approved for the current contract to manage.\n    function safeTransferAllFrom(address token, address from, address to)\n        internal\n        returns (uint256 amount)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x40, to) // Store the `to` argument.\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\n            mstore(0x0c, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\n            // Read the balance, reverting upon failure.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\n                    staticcall(gas(), token, 0x1c, 0x24, 0x60, 0x20)\n                )\n            ) {\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x00, 0x23b872dd) // `transferFrom(address,address,uint256)`.\n            amount := mload(0x60) // The `amount` is already at 0x60. We'll need to return it.\n            // Perform the transfer, reverting upon failure.\n            let success := call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\n            if iszero(and(eq(mload(0x00), 1), success)) {\n                if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\n                    mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            mstore(0x60, 0) // Restore the zero slot to zero.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /// @dev Sends `amount` of ERC20 `token` from the current contract to `to`.\n    /// Reverts upon failure.\n    function safeTransfer(address token, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, to) // Store the `to` argument.\n            mstore(0x34, amount) // Store the `amount` argument.\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\n            // Perform the transfer, reverting upon failure.\n            let success := call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n            if iszero(and(eq(mload(0x00), 1), success)) {\n                if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\n                    mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n        }\n    }\n\n    /// @dev Sends all of ERC20 `token` from the current contract to `to`.\n    /// Reverts upon failure.\n    function safeTransferAll(address token, address to) internal returns (uint256 amount) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, 0x70a08231) // Store the function selector of `balanceOf(address)`.\n            mstore(0x20, address()) // Store the address of the current contract.\n            // Read the balance, reverting upon failure.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\n                    staticcall(gas(), token, 0x1c, 0x24, 0x34, 0x20)\n                )\n            ) {\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x14, to) // Store the `to` argument.\n            amount := mload(0x34) // The `amount` is already at 0x34. We'll need to return it.\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\n            // Perform the transfer, reverting upon failure.\n            let success := call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n            if iszero(and(eq(mload(0x00), 1), success)) {\n                if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\n                    mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n        }\n    }\n\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\n    /// Reverts upon failure.\n    function safeApprove(address token, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, to) // Store the `to` argument.\n            mstore(0x34, amount) // Store the `amount` argument.\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\n            let success := call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n            if iszero(and(eq(mload(0x00), 1), success)) {\n                if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\n                    mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n        }\n    }\n\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\n    /// If the initial attempt to approve fails, attempts to reset the approved amount to zero,\n    /// then retries the approval again (some tokens, e.g. USDT, requires this).\n    /// Reverts upon failure.\n    function safeApproveWithRetry(address token, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, to) // Store the `to` argument.\n            mstore(0x34, amount) // Store the `amount` argument.\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\n            // Perform the approval, retrying upon failure.\n            let success := call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n            if iszero(and(eq(mload(0x00), 1), success)) {\n                if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\n                    mstore(0x34, 0) // Store 0 for the `amount`.\n                    mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\n                    pop(call(gas(), token, 0, 0x10, 0x44, codesize(), 0x00)) // Reset the approval.\n                    mstore(0x34, amount) // Store back the original `amount`.\n                    // Retry the approval, reverting upon failure.\n                    success := call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n                    if iszero(and(eq(mload(0x00), 1), success)) {\n                        // Check the `extcodesize` again just in case the token selfdestructs lol.\n                        if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\n                            mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\n                            revert(0x1c, 0x04)\n                        }\n                    }\n                }\n            }\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n        }\n    }\n\n    /// @dev Returns the amount of ERC20 `token` owned by `account`.\n    /// Returns zero if the `token` does not exist.\n    function balanceOf(address token, address account) internal view returns (uint256 amount) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, account) // Store the `account` argument.\n            mstore(0x00, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\n            amount :=\n                mul( // The arguments of `mul` are evaluated from right to left.\n                    mload(0x20),\n                    and( // The arguments of `and` are evaluated from right to left.\n                        gt(returndatasize(), 0x1f), // At least 32 bytes returned.\n                        staticcall(gas(), token, 0x10, 0x24, 0x20, 0x20)\n                    )\n                )\n        }\n    }\n\n    /// @dev Returns the total supply of the `token`.\n    /// Reverts if the token does not exist or does not implement `totalSupply()`.\n    function totalSupply(address token) internal view returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, 0x18160ddd) // `totalSupply()`.\n            if iszero(\n                and(gt(returndatasize(), 0x1f), staticcall(gas(), token, 0x1c, 0x04, 0x00, 0x20))\n            ) {\n                mstore(0x00, 0x54cd9435) // `TotalSupplyQueryFailed()`.\n                revert(0x1c, 0x04)\n            }\n            result := mload(0x00)\n        }\n    }\n\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\n    /// If the initial attempt fails, try to use Permit2 to transfer the token.\n    /// Reverts upon failure.\n    ///\n    /// The `from` account must have at least `amount` approved for the current contract to manage.\n    function safeTransferFrom2(address token, address from, address to, uint256 amount) internal {\n        if (!trySafeTransferFrom(token, from, to, amount)) {\n            permit2TransferFrom(token, from, to, amount);\n        }\n    }\n\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to` via Permit2.\n    /// Reverts upon failure.\n    function permit2TransferFrom(address token, address from, address to, uint256 amount)\n        internal\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(add(m, 0x74), shr(96, shl(96, token)))\n            mstore(add(m, 0x54), amount)\n            mstore(add(m, 0x34), to)\n            mstore(add(m, 0x20), shl(96, from))\n            // `transferFrom(address,address,uint160,address)`.\n            mstore(m, 0x36c78516000000000000000000000000)\n            let p := PERMIT2\n            let exists := eq(chainid(), 1)\n            if iszero(exists) { exists := iszero(iszero(extcodesize(p))) }\n            if iszero(\n                and(\n                    call(gas(), p, 0, add(m, 0x10), 0x84, codesize(), 0x00),\n                    lt(iszero(extcodesize(token)), exists) // Token has code and Permit2 exists.\n                )\n            ) {\n                mstore(0x00, 0x7939f4248757f0fd) // `TransferFromFailed()` or `Permit2AmountOverflow()`.\n                revert(add(0x18, shl(2, iszero(iszero(shr(160, amount))))), 0x04)\n            }\n        }\n    }\n\n    /// @dev Permit a user to spend a given amount of\n    /// another user's tokens via native EIP-2612 permit if possible, falling\n    /// back to Permit2 if native permit fails or is not implemented on the token.\n    function permit2(\n        address token,\n        address owner,\n        address spender,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        bool success;\n        /// @solidity memory-safe-assembly\n        assembly {\n            for {} shl(96, xor(token, WETH9)) {} {\n                mstore(0x00, 0x3644e515) // `DOMAIN_SEPARATOR()`.\n                if iszero(\n                    and( // The arguments of `and` are evaluated from right to left.\n                        lt(iszero(mload(0x00)), eq(returndatasize(), 0x20)), // Returns 1 non-zero word.\n                        // Gas stipend to limit gas burn for tokens that don't refund gas when\n                        // an non-existing function is called. 5K should be enough for a SLOAD.\n                        staticcall(5000, token, 0x1c, 0x04, 0x00, 0x20)\n                    )\n                ) { break }\n                // After here, we can be sure that token is a contract.\n                let m := mload(0x40)\n                mstore(add(m, 0x34), spender)\n                mstore(add(m, 0x20), shl(96, owner))\n                mstore(add(m, 0x74), deadline)\n                if eq(mload(0x00), DAI_DOMAIN_SEPARATOR) {\n                    mstore(0x14, owner)\n                    mstore(0x00, 0x7ecebe00000000000000000000000000) // `nonces(address)`.\n                    mstore(add(m, 0x94), staticcall(gas(), token, 0x10, 0x24, add(m, 0x54), 0x20))\n                    mstore(m, 0x8fcbaf0c000000000000000000000000) // `IDAIPermit.permit`.\n                    // `nonces` is already at `add(m, 0x54)`.\n                    // `1` is already stored at `add(m, 0x94)`.\n                    mstore(add(m, 0xb4), and(0xff, v))\n                    mstore(add(m, 0xd4), r)\n                    mstore(add(m, 0xf4), s)\n                    success := call(gas(), token, 0, add(m, 0x10), 0x104, codesize(), 0x00)\n                    break\n                }\n                mstore(m, 0xd505accf000000000000000000000000) // `IERC20Permit.permit`.\n                mstore(add(m, 0x54), amount)\n                mstore(add(m, 0x94), and(0xff, v))\n                mstore(add(m, 0xb4), r)\n                mstore(add(m, 0xd4), s)\n                success := call(gas(), token, 0, add(m, 0x10), 0xe4, codesize(), 0x00)\n                break\n            }\n        }\n        if (!success) simplePermit2(token, owner, spender, amount, deadline, v, r, s);\n    }\n\n    /// @dev Simple permit on the Permit2 contract.\n    function simplePermit2(\n        address token,\n        address owner,\n        address spender,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, 0x927da105) // `allowance(address,address,address)`.\n            {\n                let addressMask := shr(96, not(0))\n                mstore(add(m, 0x20), and(addressMask, owner))\n                mstore(add(m, 0x40), and(addressMask, token))\n                mstore(add(m, 0x60), and(addressMask, spender))\n                mstore(add(m, 0xc0), and(addressMask, spender))\n            }\n            let p := mul(PERMIT2, iszero(shr(160, amount)))\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    gt(returndatasize(), 0x5f), // Returns 3 words: `amount`, `expiration`, `nonce`.\n                    staticcall(gas(), p, add(m, 0x1c), 0x64, add(m, 0x60), 0x60)\n                )\n            ) {\n                mstore(0x00, 0x6b836e6b8757f0fd) // `Permit2Failed()` or `Permit2AmountOverflow()`.\n                revert(add(0x18, shl(2, iszero(p))), 0x04)\n            }\n            mstore(m, 0x2b67b570) // `Permit2.permit` (PermitSingle variant).\n            // `owner` is already `add(m, 0x20)`.\n            // `token` is already at `add(m, 0x40)`.\n            mstore(add(m, 0x60), amount)\n            mstore(add(m, 0x80), 0xffffffffffff) // `expiration = type(uint48).max`.\n            // `nonce` is already at `add(m, 0xa0)`.\n            // `spender` is already at `add(m, 0xc0)`.\n            mstore(add(m, 0xe0), deadline)\n            mstore(add(m, 0x100), 0x100) // `signature` offset.\n            mstore(add(m, 0x120), 0x41) // `signature` length.\n            mstore(add(m, 0x140), r)\n            mstore(add(m, 0x160), s)\n            mstore(add(m, 0x180), shl(248, v))\n            if iszero( // Revert if token does not have code, or if the call fails.\n            mul(extcodesize(token), call(gas(), p, 0, add(m, 0x1c), 0x184, codesize(), 0x00))) {\n                mstore(0x00, 0x6b836e6b) // `Permit2Failed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n}\n"
    },
    "src/common/AccessRoles.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.19;\n\n/// @dev used to rescue funds\nbytes32 constant RESCUE_ROLE = keccak256(\"RESCUE_ROLE\");\n\n/// @dev used to update configs on protocol contracts\nbytes32 constant CONFIG_ROLE = keccak256(\"CONFIG_ROLE\");\n\n/// @dev used to update Socket DL configs\nbytes32 constant SOCKET_CONFIG_ROLE = keccak256(\"SOCKET_CONFIG_ROLE\");\n\n/// @dev used to allow cancellation of requests\nbytes32 constant CANCEL_ROLE = keccak256(\"CANCEL_ROLE\");\n"
    },
    "src/common/Errors.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n/*//////////////////////////////////////////////////////////////\n                         BUNGEE ERRORS\n//////////////////////////////////////////////////////////////*/\n\nerror MofaSignatureInvalid();\nerror InsufficientNativeAmount();\nerror UnsupportedRequest();\nerror RouterNotRegistered();\nerror CallerNotBungeeGateway();\nerror CallerNotEntrypoint();\nerror SwapOutputInsufficient();\nerror MinOutputNotMet();\nerror InvalidRequest();\nerror FulfilmentDeadlineNotMet();\nerror CallerNotDelegate();\nerror InvalidMsg();\nerror RequestProcessed();\nerror RequestNotProcessed();\nerror InvalidSwitchboard();\nerror PromisedAmountNotMet();\nerror MsgReceiveFailed();\nerror RouterAlreadyRegistered();\nerror InvalidFulfil();\nerror NotImplemented();\nerror OnlyOwner();\nerror OnlyNominee();\nerror InvalidReceiver();\nerror ImplAlreadyRegistered();\nerror InvalidAddress();\n\n/*//////////////////////////////////////////////////////////////\n                       SWITCHBOARD ERRORS\n//////////////////////////////////////////////////////////////*/\n\nerror NotSiblingBungeeGateway();\nerror NotSocket();\nerror NotSwitchboardRouter();\nerror NotSwitchboardPlug();\nerror SwitchboardPlugZero();\nerror ConnectionAlreadyInitialised();\nerror IncorrectSwitchboard();\n"
    },
    "src/common/SingleOutputStructs.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.19;\n\n// Basic details in the request\nstruct BasicRequest {\n    // src chain id\n    uint256 originChainId;\n    // dest chain id\n    uint256 destinationChainId;\n    // deadline of the request\n    uint256 deadline;\n    // nonce used for uniqueness in signature\n    uint256 nonce;\n    // address of the user placing the request.\n    address sender;\n    // address of the receiver on destination chain\n    address receiver;\n    // delegate address that has some rights over the request signed eg. cancellation\n    address delegate;\n    // address of bungee gateway, this address will have access to pull funds from the sender.\n    address bungeeGateway;\n    // id of the switchboard for settlement\n    uint32 switchboardId;\n    // address of the input token\n    address inputToken;\n    // amount of the input token\n    uint256 inputAmount;\n    // output token to be received on the destination.\n    address outputToken;\n    // minimum amount of output token to be received on the destination\n    uint256 minOutputAmount;\n    // native token refuel amount on the destination chain\n    uint256 refuelAmount;\n}\n\n// The Request which user signs\nstruct Request {\n    // basic details in the request.\n    BasicRequest basicReq;\n    // swap output token that the user is permitting to swap input token to.\n    address swapOutputToken;\n    // minimum swap output the user is okay with swapping the input token to.\n    // Transmitter can choose or not choose to swap tokens.\n    uint256 minSwapOutput;\n    // any sort of metadata to be passed with the request\n    bytes32 metadata;\n    // fees of the affiliate if any\n    bytes affiliateFees;\n    // calldata execution parameter. Only to be used when execution is required on destination.\n    // minimum dest gas limit to execute calldata on destination\n    uint256 minDestGas;\n    // calldata to be executed on the destination\n    // calldata can only be executed on the receiver in the request.\n    bytes destinationPayload;\n    /// @dev address of the only transmitter that is permitted to execute the request.\n    /// If the transmitter is not set, anyone can execute the request.\n    /// This validation would be done off-chain by the auction house.\n    address exclusiveTransmitter;\n}\n\n// Transmitter's origin chain execution details for a request\nstruct ExtractExec {\n    // User signed Request\n    Request request;\n    // address of the router being used for executing the request\n    address router;\n    // amount of output token promised by transmitter on the destination\n    uint256 promisedAmount;\n    // encoded data to be used by router: RouterPayload + RouterValue (value required by the router) etc.\n    bytes routerData;\n    // encoded calldata to be used for swap 0x00 if no swap is involved.\n    bytes swapPayload;\n    // contract address to execute swap on\n    address swapRouter;\n    // user signature against the request\n    bytes userSignature;\n    // address of the beneficiary submitted by the transmitter.\n    // the beneficiary will be the one receiving locked tokens when a request is settled.\n    address beneficiary;\n    // stake related information for the request used off-chain but emitted on-chain.\n    // can include info like address stakeToken, uint256 lockedStake etc.\n    bytes stakeData;\n}\n\n// Transmitter's destination chain execution details with fulfil amounts.\nstruct FulfilExec {\n    // User Signed Request\n    Request request;\n    // address of the router being used for fulfilling the request\n    address fulfilRouter;\n    // amount of output token to be sent to the receiver\n    uint256 fulfilAmount;\n    // encoded data to be used by router: RouterPayload + RouterValue (value required by the router) etc.\n    bytes routerData;\n    // total msg.value to be sent to fulfil native token output token + refuel amount\n    uint256 msgValue;\n}\n\nstruct ExtractedRequest {\n    // address of the router being used for executing the request\n    address router;\n    // address of the user placing the request.\n    address sender;\n    // delegate address that has some rights over the request signed eg. cancellation\n    address delegate;\n    // id of the switchboard for settlement\n    uint32 switchboardId;\n    // final input token used on the src chain. can be the intermediate swap output token\n    address token;\n    // address of the transmitter\n    address transmitter;\n    // address of the beneficiary submitted by the transmitter.\n    address beneficiary;\n    // final input token amount used on the src chain. can be the intermediate swap output token amount\n    uint256 amount;\n    // amount of output token promised by transmitter on the destination\n    uint256 promisedAmount;\n}\n\n/* enum FulfilmentStatus {\n    Pending, = 0\n    Cancelled, = 1\n    WithdrawnOnDestination = 2\n    Fulfilled, = 3\n} */\n\nstruct FulfilledRequest {\n    // amount of output token fulfilled by transmitter on the destination\n    uint256 fulfilledAmount;\n    // flag indicating if the request has been processed - fulfilled or cancelled\n    uint256 status;\n}\n"
    },
    "src/core/BungeeGatewayStorage.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.19;\n\nimport {ISignatureTransfer} from \"permit2/src/interfaces/ISignatureTransfer.sol\";\n\nimport {IEntrypoint} from \"../interfaces/IEntrypoint.sol\";\nimport {AccessControl} from \"../utils/AccessControl.sol\";\nimport {ISwapExecutor} from \"../interfaces/ISwapExecutor.sol\";\nimport {ICalldataExecutor} from \"../interfaces/ICalldataExecutor.sol\";\nimport {ISwitchboardRouter} from \"../interfaces/ISwitchboardRouter.sol\";\nimport {IFeeCollector} from \"../interfaces/IFeeCollector.sol\";\n\n/**\n * @notice WithdrawnRequest struct\n * @dev This struct is used to store info about withdrawn requests on the origin chain\n */\nstruct WithdrawnRequest {\n    address token;\n    uint256 amount;\n    address receiver;\n}\n\nabstract contract BungeeGatewayStorage is AccessControl {\n    /// @dev address used to identify native token\n    address public constant NATIVE_TOKEN_ADDRESS = address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\n\n    /// @notice address of the permit 2 contract\n    ISignatureTransfer public immutable PERMIT2;\n\n    /// @notice address of the Entrypoint\n    /// @dev Entrypoint for Bungee, all extraction requests are sent to this contract.\n    IEntrypoint public ENTRYPOINT;\n\n    /// @notice address of the SwitchboardRouter\n    /// @dev BungeeGateway uses this contract to handle cross-chain messages via Socket\n    ISwitchboardRouter public SWITCHBOARD_ROUTER;\n\n    /// @notice address of the SwapExecutor\n    /// @dev BungeeGateway delegates swap executions to this contract.\n    ISwapExecutor public SWAP_EXECUTOR;\n\n    /// @notice address of the CalldataExecutor\n    /// @dev BungeeGateway delegates calldata execution at destination chain to this contract.\n    ICalldataExecutor public CALLDATA_EXECUTOR;\n\n    /// @notice address of the FeeCollector\n    /// @dev BungeeGateway collects affiliate fees from the users and transfers them to this contract.\n    IFeeCollector public FEE_COLLECTOR;\n\n    /// @notice this mapping holds all implementation contract addresses against their implId\n    mapping(uint8 implId => address impl) internal _impls;\n\n    /// @notice this mapping tracks whether an implId has been used & removed\n    /// @dev used to prevent reusing an implId\n    mapping(uint8 implId => bool removed) internal _removedImpls;\n\n    /// @notice this mapping holds all the receiver contracts, these contracts will receive funds on the destination chain.\n    /// @dev bridged funds would reach receiver contracts first and then transmitter uses these funds to fulfil order.\n    mapping(address router => mapping(uint256 toChainId => address whitelistedReceiver)) internal whitelistedReceivers;\n\n    /// @notice this mapping holds all the addresses that are routers.\n    /// @dev bungee sends funds from the users to these routers.\n    /// @dev bungee calls these when fulfilment happens on the destination.\n    mapping(address routers => bool supported) internal bungeeRouters;\n\n    /// @notice this mapping stores orders that have been withdrawn on the originChain\n    /// @dev Requests are deleted from the extractedRequests mapping when withdrawn on the origin chain\n    /// @dev Can be used by external contracts to track & use withdrawal info about requests\n    mapping(bytes32 requestHash => WithdrawnRequest request) internal _withdrawnRequests;\n\n    /// @notice this mapping stores the settlement amounts collected for the beneficiaries\n    /// @dev not all routers would have settlement, so these amounts may not be cleared for some routers\n    mapping(address beneficiary => mapping(address router => mapping(address token => uint256 amount)))\n        public beneficiarySettlements;\n\n    /**\n     * @notice Constructor.\n     * @dev Defines all immutable variables & owner\n     * @param _owner owner of the contract.\n     * @param _permit2 address of the permit 2 contract.\n     */\n    constructor(address _owner, address _permit2) AccessControl(_owner) {\n        PERMIT2 = ISignatureTransfer(_permit2);\n    }\n}\n"
    },
    "src/interfaces/IBaseRouter.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.19;\n\ninterface IBaseRouter {\n    function releaseFunds(address token, uint256 amount, address recipient) external;\n}\n"
    },
    "src/interfaces/IBaseRouterSingleOutput.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.19;\nimport {IBaseRouter} from \"./IBaseRouter.sol\";\nimport {FulfilExec, ExtractExec, Request} from \"../common/SingleOutputStructs.sol\";\n\ninterface IBaseRouterSingleOutput is IBaseRouter {\n    function execute(\n        bytes32 requestHash,\n        address receiverContract,\n        ExtractExec memory exec\n    ) external returns (uint256 extractedAmount, address extractedToken);\n\n    function fulfil(bytes32 requestHash, FulfilExec calldata fulfilExec, address transmitter) external payable;\n\n    function withdrawRequestOnDestination(Request calldata request, bytes calldata withdrawRequestData) external;\n}\n"
    },
    "src/interfaces/IBungeeGateway.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.19;\n\nimport {WithdrawnRequest} from \"../core/BungeeGatewayStorage.sol\";\n\ninterface IBungeeGateway {\n    function setWhitelistedReceiver(address receiver, uint256 destinationChainId, address router) external;\n\n    function getWhitelistedReceiver(address router, uint256 destinationChainId) external view returns (address);\n\n    function inboundMsgFromSwitchboard(uint8 msgId, uint32 switchboardId, bytes calldata payload) external;\n\n    function isBungeeRouter(address router) external view returns (bool);\n\n    function withdrawnRequests(bytes32 requestHash) external view returns (WithdrawnRequest memory);\n\n    function executeImpl(uint8 implId, bytes calldata data) external payable returns (bytes memory);\n}\n"
    },
    "src/interfaces/ICalldataExecutor.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.19;\n\ninterface ICalldataExecutor {\n    function executeCalldata(address to, bytes memory encodedData, uint256 msgGasLimit) external returns (bool);\n}\n"
    },
    "src/interfaces/ICCTPV2.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.19;\n\ninterface ITokenMessengerV2 {\n    function depositForBurnWithHook(\n        uint256 amount,\n        uint32 destinationDomain,\n        bytes32 mintRecipient,\n        address burnToken,\n        bytes32 destinationCaller,\n        uint256 maxFee,\n        uint32 minFinalityThreshold,\n        bytes calldata hookData\n    ) external;\n}\n\ninterface IMessageTransmitterV2 {\n    function sendMessage(\n        uint32 destinationDomain,\n        bytes32 recipient,\n        bytes32 destinationCaller,\n        uint32 minFinalityThreshold,\n        bytes calldata messageBody\n    ) external;\n\n    function receiveMessage(bytes calldata message, bytes calldata attestation) external returns (bool success);\n\n    function usedNonces(bytes32) external view returns (uint256);\n}\n\ninterface IMessageHandlerV2 {\n    /**\n     * @notice Handles an incoming finalized message from an IReceiverV2\n     * @dev Finalized messages have finality threshold values greater than or equal to 2000\n     * @param sourceDomain The source domain of the message\n     * @param sender The sender of the message\n     * @param finalityThresholdExecuted the finality threshold at which the message was attested to\n     * @param messageBody The raw bytes of the message body\n     * @return success True, if successful; false, if not.\n     */\n    function handleReceiveFinalizedMessage(\n        uint32 sourceDomain,\n        bytes32 sender,\n        uint32 finalityThresholdExecuted,\n        bytes calldata messageBody\n    ) external returns (bool);\n\n    /**\n     * @notice Handles an incoming unfinalized message from an IReceiverV2\n     * @dev Unfinalized messages have finality threshold values less than 2000\n     * @param sourceDomain The source domain of the message\n     * @param sender The sender of the message\n     * @param finalityThresholdExecuted The finality threshold at which the message was attested to\n     * @param messageBody The raw bytes of the message body\n     * @return success True, if successful; false, if not.\n     */\n    function handleReceiveUnfinalizedMessage(\n        uint32 sourceDomain,\n        bytes32 sender,\n        uint32 finalityThresholdExecuted,\n        bytes calldata messageBody\n    ) external returns (bool);\n}\n"
    },
    "src/interfaces/IEntrypoint.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.19;\n\ninterface IEntrypoint {\n    function executeSOR(bytes calldata data, bytes calldata mofaSignature) external payable returns (bytes memory);\n    function executeSR(bytes calldata data, bytes calldata mofaSignature) external payable returns (bytes memory);\n}\n"
    },
    "src/interfaces/IFeeCollector.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.19;\n\ninterface IFeeCollector {\n    function registerFee(address feeTaker, uint256 feeAmount, address feeToken) external;\n    function registerLockedFee(address feeTaker, uint256 feeAmount, address feeToken, bytes32 requestHash) external;\n    function settleFee(bytes32 requestHash) external;\n    function refundFee(bytes32 requestHash, address to) external;\n}\n"
    },
    "src/interfaces/ISwapExecutor.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.19;\n\ninterface ISwapExecutor {\n    function executeSwap(address token, uint256 amount, address swapRouter, bytes memory swapPayload) external payable;\n}\n"
    },
    "src/interfaces/ISwitchboardRouter.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.19;\n\ninterface ISwitchboardRouter {\n    function sendOutboundMsg(\n        uint32 originChainId,\n        uint32 switchboardId,\n        uint8 msgId,\n        uint256 destGasLimit,\n        bytes calldata payload\n    ) external payable;\n\n    function receiveAndDeliverMsg(uint32 switchboardId, uint32 siblingChainId, bytes calldata payload) external;\n}\n"
    },
    "src/lib/AffiliateFeesLib.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.19;\n\nimport {BytesLib} from \"./BytesLib.sol\";\n\n/// @notice helpers for AffiliateFees struct\nlibrary AffiliateFeesLib {\n    /// @notice SafeTransferLib - library for safe and optimized operations on ERC20 tokens\n\n    /// @notice error when affiliate fee length is wrong\n    error WrongAffiliateFeeLength();\n\n    /// @notice event emitted when affiliate fee is deducted\n    event AffiliateFeeDeducted(address feeToken, address feeTakerAddress, uint256 feeAmount);\n\n    // Precision used for affiliate fee calculation\n    uint256 internal constant PRECISION = 10000000000000000;\n\n    /**\n     * @dev calculates & transfers fee to feeTakerAddress\n     * @param bridgingAmount amount to be bridged\n     * @param affiliateFees packed bytes containing feeTakerAddress and feeInBps\n     *                      ensure the affiliateFees is packed as follows:\n     *                      address feeTakerAddress (20 bytes) + uint56 feeInBps (7 bytes) = 27 bytes\n     * @return bridgingAmount after deducting affiliate fees\n     */\n    function getAffiliateFees(\n        uint256 bridgingAmount,\n        bytes memory affiliateFees\n    ) internal pure returns (uint256, uint256, address) {\n        address feeTakerAddress;\n        uint256 feeAmount = 0;\n        if (affiliateFees.length > 0) {\n            uint56 feeInBps;\n\n            if (affiliateFees.length != 27) revert WrongAffiliateFeeLength();\n\n            feeInBps = BytesLib.toUint56(affiliateFees, 20);\n            feeTakerAddress = BytesLib.toAddress(affiliateFees, 0);\n\n            if (feeInBps > 0) {\n                // calculate fee\n                feeAmount = ((bridgingAmount * feeInBps) / PRECISION);\n                bridgingAmount -= feeAmount;\n            }\n        }\n\n        return (bridgingAmount, feeAmount, feeTakerAddress);\n    }\n\n    /// @notice calculates the total amount from the bridged amount and the affiliate fees\n    function calculateTotalAmount(uint256 bridgedAmount, bytes memory affiliateFees) internal pure returns (uint256) {\n        if (affiliateFees.length > 0) {\n            if (affiliateFees.length != 27) revert WrongAffiliateFeeLength();\n            uint56 feeInBps = BytesLib.toUint56(affiliateFees, 20);\n\n            // totalAmount = bridgedAmount / (1 - feeInBps / PRECISION)\n            uint256 totalAmount = (bridgedAmount * PRECISION) / (PRECISION - feeInBps);\n            return totalAmount;\n        }\n        return bridgedAmount;\n    }\n}\n"
    },
    "src/lib/BytesLib.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\n/*\n * @title Solidity Bytes Arrays Utils\n * @author Gonçalo Sá <goncalo.sa@consensys.net>\n *\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\n */\npragma solidity ^0.8.19;\n\nlibrary BytesLib {\n    function concat(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bytes memory) {\n        bytes memory tempBytes;\n\n        assembly {\n            // Get a location of some free memory and store it in tempBytes as\n            // Solidity does for memory variables.\n            tempBytes := mload(0x40)\n\n            // Store the length of the first bytes array at the beginning of\n            // the memory for tempBytes.\n            let length := mload(_preBytes)\n            mstore(tempBytes, length)\n\n            // Maintain a memory counter for the current write location in the\n            // temp bytes array by adding the 32 bytes for the array length to\n            // the starting location.\n            let mc := add(tempBytes, 0x20)\n            // Stop copying when the memory counter reaches the length of the\n            // first bytes array.\n            let end := add(mc, length)\n\n            for {\n                // Initialize a copy counter to the start of the _preBytes data,\n                // 32 bytes into its memory.\n                let cc := add(_preBytes, 0x20)\n            } lt(mc, end) {\n                // Increase both counters by 32 bytes each iteration.\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                // Write the _preBytes data into the tempBytes memory 32 bytes\n                // at a time.\n                mstore(mc, mload(cc))\n            }\n\n            // Add the length of _postBytes to the current length of tempBytes\n            // and store it as the new length in the first 32 bytes of the\n            // tempBytes memory.\n            length := mload(_postBytes)\n            mstore(tempBytes, add(length, mload(tempBytes)))\n\n            // Move the memory counter back from a multiple of 0x20 to the\n            // actual end of the _preBytes data.\n            mc := end\n            // Stop copying when the memory counter reaches the new combined\n            // length of the arrays.\n            end := add(mc, length)\n\n            for {\n                let cc := add(_postBytes, 0x20)\n            } lt(mc, end) {\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                mstore(mc, mload(cc))\n            }\n\n            // Update the free-memory pointer by padding our last write location\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\n            // next 32 byte block, then round down to the nearest multiple of\n            // 32. If the sum of the length of the two arrays is zero then add\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\n            mstore(\n                0x40,\n                and(\n                    add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n                    not(31) // Round down to the nearest 32 bytes.\n                )\n            )\n        }\n\n        return tempBytes;\n    }\n\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\n        assembly {\n            // Read the first 32 bytes of _preBytes storage, which is the length\n            // of the array. (We don't need to use the offset into the slot\n            // because arrays use the entire slot.)\n            let fslot := sload(_preBytes.slot)\n            // Arrays of 31 bytes or less have an even value in their slot,\n            // while longer arrays have an odd value. The actual length is\n            // the slot divided by two for odd values, and the lowest order\n            // byte divided by two for even values.\n            // If the slot is even, bitwise and the slot with 255 and divide by\n            // two to get the length. If the slot is odd, bitwise and the slot\n            // with -1 and divide by two.\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n            let newlength := add(slength, mlength)\n            // slength can contain both the length and contents of the array\n            // if length < 32 bytes so let's prepare for that\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n            switch add(lt(slength, 32), lt(newlength, 32))\n            case 2 {\n                // Since the new array still fits in the slot, we just need to\n                // update the contents of the slot.\n                // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\n                sstore(\n                    _preBytes.slot,\n                    // all the modifications to the slot are inside this\n                    // next block\n                    add(\n                        // we can just add to the slot contents because the\n                        // bytes we want to change are the LSBs\n                        fslot,\n                        add(\n                            mul(\n                                div(\n                                    // load the bytes from memory\n                                    mload(add(_postBytes, 0x20)),\n                                    // zero all bytes to the right\n                                    exp(0x100, sub(32, mlength))\n                                ),\n                                // and now shift left the number of bytes to\n                                // leave space for the length in the slot\n                                exp(0x100, sub(32, newlength))\n                            ),\n                            // increase length by the double of the memory\n                            // bytes length\n                            mul(mlength, 2)\n                        )\n                    )\n                )\n            }\n            case 1 {\n                // The stored value fits in the slot, but the combined value\n                // will exceed it.\n                // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes.slot)\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n                // save new length\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n                // The contents of the _postBytes array start 32 bytes into\n                // the structure. Our first read should obtain the `submod`\n                // bytes that can fit into the unused space in the last word\n                // of the stored array. To get this, we read 32 bytes starting\n                // from `submod`, so the data we read overlaps with the array\n                // contents by `submod` bytes. Masking the lowest-order\n                // `submod` bytes allows us to add that value directly to the\n                // stored value.\n\n                let submod := sub(32, slength)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(\n                    sc,\n                    add(\n                        and(fslot, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00),\n                        and(mload(mc), mask)\n                    )\n                )\n\n                for {\n                    mc := add(mc, 0x20)\n                    sc := add(sc, 1)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n            default {\n                // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes.slot)\n                // Start copying to the last used word of the stored array.\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n                // save new length\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n                // Copy over the first `submod` bytes of the new data as in\n                // case 1 above.\n                let slengthmod := mod(slength, 32)\n                let mlengthmod := mod(mlength, 32)\n                let submod := sub(32, slengthmod)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\n\n                for {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n        }\n    }\n\n    function slice(bytes memory _bytes, uint256 _start, uint256 _length) internal pure returns (bytes memory) {\n        require(_length + 31 >= _length, \"slice_overflow\");\n        require(_bytes.length >= _start + _length, \"slice_outOfBounds\");\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n                // Get a location of some free memory and store it in tempBytes as\n                // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n                // The first word of the slice result is potentially a partial\n                // word read from the original array. To read it, we calculate\n                // the length of that partial word and start copying that many\n                // bytes into the array. The first word we copy will start with\n                // data we don't care about, but the last `lengthmod` bytes will\n                // land at the beginning of the contents of the new array. When\n                // we're done copying, we overwrite the full first word with\n                // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n                // The multiplication in the next line is necessary\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n                // the following copy loop was copying the origin's length\n                // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                    // The multiplication in the next line has the same exact purpose\n                    // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n                //update free-memory pointer\n                //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n                //zero out the 32 bytes slice we are about to return\n                //we need to do it because Solidity does not garbage collect\n                mstore(tempBytes, 0)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\n        require(_bytes.length >= _start + 20, \"toAddress_outOfBounds\");\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n        }\n\n        return tempAddress;\n    }\n\n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\n        require(_bytes.length >= _start + 1, \"toUint8_outOfBounds\");\n        uint8 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x1), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint16(bytes memory _bytes, uint256 _start) internal pure returns (uint16) {\n        require(_bytes.length >= _start + 2, \"toUint16_outOfBounds\");\n        uint16 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x2), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32) {\n        require(_bytes.length >= _start + 4, \"toUint32_outOfBounds\");\n        uint32 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x4), _start))\n        }\n\n        return tempUint;\n    }\n\n    // @audit this function was not originally present in the library\n    // we added it to support the uint56 type used in AffiliateFeesLib\n    function toUint56(bytes memory _bytes, uint256 _start) internal pure returns (uint56) {\n        require(_bytes.length >= _start + 7, \"toUint56_outOfBounds\");\n        uint56 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x7), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint64(bytes memory _bytes, uint256 _start) internal pure returns (uint64) {\n        require(_bytes.length >= _start + 8, \"toUint64_outOfBounds\");\n        uint64 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x8), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint96(bytes memory _bytes, uint256 _start) internal pure returns (uint96) {\n        require(_bytes.length >= _start + 12, \"toUint96_outOfBounds\");\n        uint96 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0xc), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint128(bytes memory _bytes, uint256 _start) internal pure returns (uint128) {\n        require(_bytes.length >= _start + 16, \"toUint128_outOfBounds\");\n        uint128 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x10), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\n        require(_bytes.length >= _start + 32, \"toUint256_outOfBounds\");\n        uint256 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {\n        require(_bytes.length >= _start + 32, \"toBytes32_outOfBounds\");\n        bytes32 tempBytes32;\n\n        assembly {\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempBytes32;\n    }\n\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\n        bool success = true;\n\n        assembly {\n            let length := mload(_preBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(length, mload(_postBytes))\n            case 1 {\n                // cb is a circuit breaker in the for loop since there's\n                //  no said feature for inline assembly loops\n                // cb = 1 - don't breaker\n                // cb = 0 - break\n                let cb := 1\n\n                let mc := add(_preBytes, 0x20)\n                let end := add(mc, length)\n\n                for {\n                    let cc := add(_postBytes, 0x20)\n                    // the next line is the loop condition:\n                    // while(uint256(mc < end) + cb == 2)\n                } eq(add(lt(mc, end), cb), 2) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    // if any of these checks fails then arrays are not equal\n                    if iszero(eq(mload(mc), mload(cc))) {\n                        // unsuccess:\n                        success := 0\n                        cb := 0\n                    }\n                }\n            }\n            default {\n                // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n\n    function equal_nonAligned(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\n        bool success = true;\n\n        assembly {\n            let length := mload(_preBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(length, mload(_postBytes))\n            case 1 {\n                // cb is a circuit breaker in the for loop since there's\n                //  no said feature for inline assembly loops\n                // cb = 1 - don't breaker\n                // cb = 0 - break\n                let cb := 1\n\n                let endMinusWord := add(_preBytes, length)\n                let mc := add(_preBytes, 0x20)\n                let cc := add(_postBytes, 0x20)\n\n                for {\n                    // the next line is the loop condition:\n                    // while(uint256(mc < endWord) + cb == 2)\n                } eq(add(lt(mc, endMinusWord), cb), 2) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    // if any of these checks fails then arrays are not equal\n                    if iszero(eq(mload(mc), mload(cc))) {\n                        // unsuccess:\n                        success := 0\n                        cb := 0\n                    }\n                }\n\n                // Only if still successful\n                // For <1 word tail bytes\n                if gt(success, 0) {\n                    // Get the remainder of length/32\n                    // length % 32 = AND(length, 32 - 1)\n                    let numTailBytes := and(length, 0x1f)\n                    let mcRem := mload(mc)\n                    let ccRem := mload(cc)\n                    for {\n                        let i := 0\n                        // the next line is the loop condition:\n                        // while(uint256(i < numTailBytes) + cb == 2)\n                    } eq(add(lt(i, numTailBytes), cb), 2) {\n                        i := add(i, 1)\n                    } {\n                        if iszero(eq(byte(i, mcRem), byte(i, ccRem))) {\n                            // unsuccess:\n                            success := 0\n                            cb := 0\n                        }\n                    }\n                }\n            }\n            default {\n                // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n\n    function equalStorage(bytes storage _preBytes, bytes memory _postBytes) internal view returns (bool) {\n        bool success = true;\n\n        assembly {\n            // we know _preBytes_offset is 0\n            let fslot := sload(_preBytes.slot)\n            // Decode the length of the stored array like in concatStorage().\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(slength, mlength)\n            case 1 {\n                // slength can contain both the length and contents of the array\n                // if length < 32 bytes so let's prepare for that\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n                if iszero(iszero(slength)) {\n                    switch lt(slength, 32)\n                    case 1 {\n                        // blank the last byte which is the length\n                        fslot := mul(div(fslot, 0x100), 0x100)\n\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\n                            // unsuccess:\n                            success := 0\n                        }\n                    }\n                    default {\n                        // cb is a circuit breaker in the for loop since there's\n                        //  no said feature for inline assembly loops\n                        // cb = 1 - don't breaker\n                        // cb = 0 - break\n                        let cb := 1\n\n                        // get the keccak hash to get the contents of the array\n                        mstore(0x0, _preBytes.slot)\n                        let sc := keccak256(0x0, 0x20)\n\n                        let mc := add(_postBytes, 0x20)\n                        let end := add(mc, mlength)\n\n                        // the next line is the loop condition:\n                        // while(uint256(mc < end) + cb == 2)\n                        for {\n\n                        } eq(add(lt(mc, end), cb), 2) {\n                            sc := add(sc, 1)\n                            mc := add(mc, 0x20)\n                        } {\n                            if iszero(eq(sload(sc), mload(mc))) {\n                                // unsuccess:\n                                success := 0\n                                cb := 0\n                            }\n                        }\n                    }\n                }\n            }\n            default {\n                // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n}\n"
    },
    "src/lib/CurrencyLib.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.19;\n\n// @audit need to check if Solady usage is correct across the codebase\nimport {ERC20} from \"solady/src/tokens/ERC20.sol\";\nimport {SafeTransferLib} from \"solady/src/utils/SafeTransferLib.sol\";\n\nerror TransferFailed();\n\nlibrary CurrencyLib {\n    /// @dev address used to identify native token\n    address public constant NATIVE_TOKEN_ADDRESS = address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\n\n    function balanceOf(address token, address addr) internal view returns (uint256 balance) {\n        if (token == NATIVE_TOKEN_ADDRESS) {\n            balance = addr.balance;\n        } else {\n            balance = ERC20(token).balanceOf(addr);\n        }\n    }\n\n    function transferFrom(address from, address token, address recipient, uint256 amount) internal {\n        if (token == NATIVE_TOKEN_ADDRESS) {\n            _transferNative(recipient, amount);\n        } else {\n            SafeTransferLib.safeTransferFrom(token, from, recipient, amount);\n        }\n    }\n\n    function transfer(address token, address recipient, uint256 amount) internal {\n        if (token == NATIVE_TOKEN_ADDRESS) {\n            _transferNative(recipient, amount);\n        } else {\n            SafeTransferLib.safeTransfer(token, recipient, amount);\n        }\n    }\n\n    function _transferNative(address recipient, uint256 amount) internal {\n        // @audit Does setting gas to 5000 for native token transfer here potentially cause issues in case of smart contracts?\n        (bool success, ) = recipient.call{value: amount, gas: 5000}(\"\");\n        if (!success) revert TransferFailed();\n    }\n}\n"
    },
    "src/lib/Permit2Lib.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.19;\nimport {ISignatureTransfer} from \"permit2/src/interfaces/ISignatureTransfer.sol\";\nimport {IPermit2} from \"permit2/src/interfaces/IPermit2.sol\";\n\n// Library to get Permit 2 related data.\nlibrary Permit2Lib {\n    string public constant TOKEN_PERMISSIONS_TYPE = \"TokenPermissions(address token,uint256 amount)\";\n\n    function toPermit(\n        address inputToken,\n        uint256 inputAmount,\n        uint256 nonce,\n        uint256 deadline\n    ) internal pure returns (ISignatureTransfer.PermitTransferFrom memory) {\n        return\n            ISignatureTransfer.PermitTransferFrom({\n                permitted: ISignatureTransfer.TokenPermissions({token: inputToken, amount: inputAmount}),\n                nonce: nonce,\n                deadline: deadline\n            });\n    }\n\n    function transferDetails(\n        uint256 amount,\n        address spender\n    ) internal pure returns (ISignatureTransfer.SignatureTransferDetails memory) {\n        return ISignatureTransfer.SignatureTransferDetails({to: spender, requestedAmount: amount});\n    }\n\n    /// @notice Checks if the unordered nonce has been used on Permit2\n    /// @param nonce nonce value on Permit2 whose validity is to be checked\n    function isNonceValid(IPermit2 PERMIT2, uint256 nonce) internal view returns (bool) {\n        (uint256 wordPos, uint256 bitPos) = _bitmapPositions(nonce);\n\n        // fetches the nonceBitmap value from PERMIT2\n        uint256 bitmap = PERMIT2.nonceBitmap(address(this), wordPos);\n\n        uint256 bit = 1 << bitPos;\n        uint256 flipped = bitmap ^ bit;\n\n        // checks if the nonce has been used\n        if (flipped & bit == 0) return false;\n        return true;\n    }\n\n    /// @notice Bit shifts nonce and returns wordPos and bitPos\n    /// @param nonce nonce value\n    function _bitmapPositions(uint256 nonce) private pure returns (uint256 wordPos, uint256 bitPos) {\n        wordPos = uint248(nonce >> 8);\n        bitPos = uint8(nonce);\n    }\n}\n"
    },
    "src/lib/RescueFundsLib.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.19;\n\n// @audit Audited before by Zellic: https://github.com/SocketDotTech/audits/blob/main/Socket-DL/07-2023%20-%20Data%20Layer%20-%20Zellic.pdf\nimport {SafeTransferLib} from \"solady/src/utils/SafeTransferLib.sol\";\n\nerror ZeroAddress();\n\n/**\n * @title RescueFundsLib\n * @dev A library that provides a function to rescue funds from a contract.\n */\n\nlibrary RescueFundsLib {\n    /**\n     * @dev The address used to identify ETH.\n     */\n    address public constant ETH_ADDRESS = address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\n\n    /**\n     * @dev thrown when the given token address don't have any code\n     */\n    error InvalidTokenAddress();\n\n    /**\n     * @dev Rescues funds from a contract.\n     * @param token_ The address of the token contract.\n     * @param rescueTo_ The address of the user.\n     * @param amount_ The amount of tokens to be rescued.\n     */\n    function rescueFunds(address token_, address rescueTo_, uint256 amount_) internal {\n        if (rescueTo_ == address(0)) revert ZeroAddress();\n\n        if (token_ == ETH_ADDRESS) {\n            SafeTransferLib.safeTransferETH(rescueTo_, amount_);\n        } else {\n            if (token_.code.length == 0) revert InvalidTokenAddress();\n            SafeTransferLib.safeTransfer(token_, rescueTo_, amount_);\n        }\n    }\n}\n"
    },
    "src/lib/SingleOutputRequestLib.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.19;\n\nimport {BasicRequest, Request, ExtractExec} from \"../common/SingleOutputStructs.sol\";\nimport {Permit2Lib} from \"./Permit2Lib.sol\";\nimport {ISignatureTransfer} from \"permit2/src/interfaces/ISignatureTransfer.sol\";\n\n/// @notice helpers for handling BasicRequest\nlibrary BasicRequestLib {\n    bytes internal constant BASIC_REQUEST_TYPE =\n        abi.encodePacked(\n            \"BasicRequest(\",\n            \"uint256 originChainId,\",\n            \"uint256 destinationChainId,\",\n            \"uint256 deadline,\",\n            \"uint256 nonce,\",\n            \"address sender,\",\n            \"address receiver,\",\n            \"address delegate,\",\n            \"address bungeeGateway,\",\n            \"uint32 switchboardId,\",\n            \"address inputToken,\",\n            \"uint256 inputAmount,\",\n            \"address outputToken,\",\n            \"uint256 minOutputAmount,\"\n            \"uint256 refuelAmount)\"\n        );\n    bytes32 internal constant BASIC_REQUEST_TYPE_HASH = keccak256(BASIC_REQUEST_TYPE);\n\n    /// @notice Hash of BasicRequest struct on the origin chain\n    /// @dev enforces originChainId to be the current chainId. Resulting hash would be the same on all chains.\n    /// @dev helps avoid extra checking of chainId in the contract\n    /// @param basicReq BasicRequest object to be hashed\n    function originHash(BasicRequest memory basicReq) internal view returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(\n                    BASIC_REQUEST_TYPE_HASH,\n                    abi.encode(\n                        block.chainid,\n                        basicReq.destinationChainId,\n                        basicReq.deadline,\n                        basicReq.nonce,\n                        basicReq.sender,\n                        basicReq.receiver,\n                        basicReq.delegate,\n                        basicReq.bungeeGateway,\n                        basicReq.switchboardId,\n                        basicReq.inputToken,\n                        basicReq.inputAmount,\n                        basicReq.outputToken,\n                        basicReq.minOutputAmount,\n                        basicReq.refuelAmount\n                    )\n                )\n            );\n    }\n\n    /// @notice Hash of BasicRequest struct on the destination chain\n    /// @dev enforces destinationChain to be the current chainId. Resulting hash would be the same on all chains.\n    /// @dev helps avoid extra checking of chainId in the contract\n    /// @param basicReq BasicRequest object to be hashed\n    function destinationHash(BasicRequest memory basicReq) internal view returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(\n                    BASIC_REQUEST_TYPE_HASH,\n                    abi.encode(\n                        basicReq.originChainId,\n                        block.chainid,\n                        basicReq.deadline,\n                        basicReq.nonce,\n                        basicReq.sender,\n                        basicReq.receiver,\n                        basicReq.delegate,\n                        basicReq.bungeeGateway,\n                        basicReq.switchboardId,\n                        basicReq.inputToken,\n                        basicReq.inputAmount,\n                        basicReq.outputToken,\n                        basicReq.minOutputAmount,\n                        basicReq.refuelAmount\n                    )\n                )\n            );\n    }\n}\n\n/// @title Bungee Request Library.\n/// @author bungee protocol\n/// @notice This library is responsible for all the hashing related to Request object.\nlibrary RequestLib {\n    using BasicRequestLib for BasicRequest;\n\n    // Permit 2 Witness Order Type.\n    string internal constant PERMIT2_ORDER_TYPE =\n        string(\n            abi.encodePacked(\n                \"Request witness)\",\n                abi.encodePacked(BasicRequestLib.BASIC_REQUEST_TYPE, REQUEST_TYPE),\n                Permit2Lib.TOKEN_PERMISSIONS_TYPE\n            )\n        );\n\n    // REQUEST TYPE encode packed\n    bytes internal constant REQUEST_TYPE =\n        abi.encodePacked(\n            \"Request(\",\n            \"BasicRequest basicReq,\",\n            \"address swapOutputToken,\",\n            \"uint256 minSwapOutput,\",\n            \"bytes32 metadata,\",\n            \"bytes affiliateFees,\",\n            \"uint256 minDestGas,\",\n            \"bytes destinationPayload,\",\n            \"address exclusiveTransmitter)\"\n        );\n\n    // EXTRACT EXEC TYPE.\n    bytes internal constant EXTRACT_EXEC_TYPE =\n        abi.encodePacked(\n            \"ExtractExec(\",\n            \"Request request,\",\n            \"address router,\",\n            \"uint256 promisedAmount,\",\n            \"bytes routerData,\",\n            \"bytes swapPayload,\",\n            \"address swapRouter,\",\n            \"bytes userSignature,\",\n            \"address beneficiary,\",\n            \"bytes stakeData)\"\n        );\n\n    // BUNGEE_REQUEST_TYPE\n    bytes internal constant BUNGEE_REQUEST_TYPE = abi.encodePacked(REQUEST_TYPE, BasicRequestLib.BASIC_REQUEST_TYPE);\n\n    // Keccak Hash of BUNGEE_REQUEST_TYPE\n    bytes32 internal constant BUNGEE_REQUEST_TYPE_HASH = keccak256(BUNGEE_REQUEST_TYPE);\n\n    // Exec Type.\n    bytes internal constant EXEC_TYPE = abi.encodePacked(EXTRACT_EXEC_TYPE, REQUEST_TYPE);\n\n    // Keccak Hash of Exec Type.\n    bytes32 internal constant EXTRACT_EXEC_TYPE_HASH = keccak256(EXEC_TYPE);\n\n    /// @notice Hash of request on the origin chain\n    /// @param request request that is signe by the user\n    function hashOriginRequest(Request memory request) internal view returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    BUNGEE_REQUEST_TYPE_HASH,\n                    request.basicReq.originHash(),\n                    request.swapOutputToken,\n                    request.minSwapOutput,\n                    request.metadata,\n                    keccak256(request.affiliateFees),\n                    request.minDestGas,\n                    keccak256(request.destinationPayload),\n                    request.exclusiveTransmitter\n                )\n            );\n    }\n\n    /// @notice Hash of request on the destination chain\n    /// @param request request signed by the user\n    function hashDestinationRequest(Request memory request) internal view returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    BUNGEE_REQUEST_TYPE_HASH,\n                    request.basicReq.destinationHash(),\n                    request.swapOutputToken,\n                    request.minSwapOutput,\n                    request.metadata,\n                    keccak256(request.affiliateFees),\n                    request.minDestGas,\n                    keccak256(request.destinationPayload),\n                    request.exclusiveTransmitter\n                )\n            );\n    }\n\n    /// @notice Hash of Extract Exec on the origin chain\n    /// @param execution Transmitter submitted extract exec object\n    function hashOriginExtractExec(ExtractExec memory execution) internal view returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    EXTRACT_EXEC_TYPE_HASH,\n                    hashOriginRequest(execution.request),\n                    execution.router,\n                    execution.promisedAmount,\n                    keccak256(execution.routerData),\n                    keccak256(execution.swapPayload),\n                    execution.swapRouter,\n                    keccak256(execution.userSignature),\n                    execution.beneficiary,\n                    keccak256(execution.stakeData)\n                )\n            );\n    }\n\n    /// @notice hash a batch of extract execs\n    /// @param extractExecs batch of extract execs to be hashed\n    function hashOriginBatch(ExtractExec[] memory extractExecs) internal view returns (bytes32) {\n        unchecked {\n            bytes32 outputHash = keccak256(\"BUNGEE_EXTRACT_EXEC\");\n            // Hash all of the extract execs present in the batch.\n            for (uint256 i = 0; i < extractExecs.length; i++) {\n                outputHash = keccak256(abi.encode(outputHash, hashOriginExtractExec(extractExecs[i])));\n            }\n\n            return outputHash;\n        }\n    }\n}\n\nlibrary Permit2TransferLib {\n    function permitWitnessTransferFrom(\n        ISignatureTransfer PERMIT2,\n        bytes32 requestHash,\n        ExtractExec memory extractExec,\n        address to\n    ) internal {\n        // Calls Permit2 to transfer funds from user to swap executor.\n        PERMIT2.permitWitnessTransferFrom(\n            Permit2Lib.toPermit(\n                extractExec.request.basicReq.inputToken,\n                extractExec.request.basicReq.inputAmount,\n                extractExec.request.basicReq.nonce,\n                extractExec.request.basicReq.deadline\n            ),\n            /// @dev transfer tokens to SwapExecutor\n            Permit2Lib.transferDetails(extractExec.request.basicReq.inputAmount, to),\n            extractExec.request.basicReq.sender,\n            requestHash,\n            RequestLib.PERMIT2_ORDER_TYPE,\n            extractExec.userSignature\n        );\n    }\n}\n"
    },
    "src/routers/BaseRouterSingleOutput.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.19;\n\nimport {Request, FulfilExec, ExtractExec} from \"../common/SingleOutputStructs.sol\";\nimport {IBaseRouter} from \"../interfaces/IBaseRouterSingleOutput.sol\";\nimport {IBungeeGateway} from \"../interfaces/IBungeeGateway.sol\";\nimport {ISwapExecutor} from \"../interfaces/ISwapExecutor.sol\";\nimport {IFeeCollector} from \"../interfaces/IFeeCollector.sol\";\nimport {CallerNotBungeeGateway, SwapOutputInsufficient} from \"../common/Errors.sol\";\nimport {AffiliateFeesLib} from \"../lib/AffiliateFeesLib.sol\";\nimport {CurrencyLib} from \"../lib/CurrencyLib.sol\";\n\n/// @dev Abstract Contract to be implemented by Routers\nabstract contract BaseRouter is IBaseRouter {\n    /// @notice Emitted on the destinationChain when a request is withdrawn on destination if transmitter fails to fulfil\n    /// @param requestHash hash of the request\n    /// @param token token being withdrawn\n    /// @param amount amount being withdrawn\n    /// @param to address of the recipient\n    event WithdrawOnDestination(bytes32 indexed requestHash, address token, uint256 amount, address to);\n\n    /// @notice BungeeGateway Contract\n    IBungeeGateway public immutable BUNGEE_GATEWAY;\n\n    /// @notice SwapExecutor Contract\n    ISwapExecutor public immutable SWAP_EXECUTOR;\n\n    /// @notice address to identify the native token\n    address public constant NATIVE_TOKEN_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @dev id used to identify single output implementation\n    uint8 public constant SINGLE_OUTPUT_IMPL_ID = 1;\n\n    /// @notice address of the FeeCollector\n    /// @dev BungeeGateway collects fees from the users and transfers them to this contract.\n    /// @dev there is not setter for this variable, it is set during the deployment of the router\n    /// @dev but a setter can be added on each router implementation if needed and if it allows ownership of the contract\n    IFeeCollector public FEE_COLLECTOR;\n\n    constructor(address _bungeeGateway, address _swapExecutor, address _feeCollector) {\n        BUNGEE_GATEWAY = IBungeeGateway(_bungeeGateway);\n        SWAP_EXECUTOR = ISwapExecutor(_swapExecutor);\n        FEE_COLLECTOR = IFeeCollector(_feeCollector);\n    }\n\n    /// @notice extract the user requests using this router\n    /// @dev collects fee via FEE_COLLECTOR if affiliate fees are present\n    /// @dev performs swap via SWAP_EXECUTOR if swapPayload is present\n    /// @dev delegates rest of the implementation to the router\n    /// @dev can only be called by BungeeGateway\n    function execute(\n        bytes32 requestHash,\n        address receiverContract,\n        ExtractExec calldata exec\n    ) external returns (uint256 extractedAmount, address extractedToken) {\n        // Should only be called by Bungee contract\n        if (msg.sender != address(BUNGEE_GATEWAY)) revert CallerNotBungeeGateway();\n\n        // swap if swapPayload is present\n        if (exec.swapPayload.length > 0) {\n            // Get the initial balance of the router for the swap output token\n            uint256 initialBalance = CurrencyLib.balanceOf(exec.request.swapOutputToken, address(this));\n\n            /// @dev transfer tokens to SwapExecutor\n            CurrencyLib.transfer({\n                token: exec.request.basicReq.inputToken,\n                recipient: address(SWAP_EXECUTOR),\n                amount: exec.request.basicReq.inputAmount\n            });\n\n            // Call the swap executor to execute the swap.\n            /// @dev swap output tokens are expected to be sent back to the router\n            SWAP_EXECUTOR.executeSwap(\n                exec.request.basicReq.inputToken,\n                exec.request.basicReq.inputAmount,\n                exec.swapRouter,\n                exec.swapPayload\n            );\n\n            // Get the final balance of the swap output token on the router\n            uint256 swappedAmount = CurrencyLib.balanceOf(exec.request.swapOutputToken, exec.router) - initialBalance;\n\n            // Check if the minimum swap output is sufficed after the swap. If not revert.\n            if (swappedAmount < exec.request.minSwapOutput) revert SwapOutputInsufficient();\n\n            // Collect fee in the swap output token\n            (uint256 bridgeAmount, uint256 feeAmount, address feeTaker) = AffiliateFeesLib.getAffiliateFees(\n                swappedAmount,\n                exec.request.affiliateFees\n            );\n            if (feeAmount > 0) {\n                _collectFee(exec.request.swapOutputToken, feeAmount, feeTaker, requestHash);\n            }\n\n            // execute with swapOutputToken\n            _execute(bridgeAmount, exec.request.swapOutputToken, requestHash, receiverContract, exec);\n\n            return (bridgeAmount, exec.request.swapOutputToken);\n        } else {\n            // Collect fee in the input token\n            (uint256 bridgeAmount, uint256 feeAmount, address feeTaker) = AffiliateFeesLib.getAffiliateFees(\n                exec.request.basicReq.inputAmount,\n                exec.request.affiliateFees\n            );\n            if (feeAmount > 0) {\n                _collectFee(exec.request.basicReq.inputToken, feeAmount, feeTaker, requestHash);\n            }\n\n            // execute with inputToken\n            _execute(bridgeAmount, exec.request.basicReq.inputToken, requestHash, receiverContract, exec);\n\n            return (bridgeAmount, exec.request.basicReq.inputToken);\n        }\n    }\n\n    /// @notice Perform the fulfilment of a request\n    /// @dev delegates the fulfilment to the router\n    /// @dev can only be called by BungeeGateway\n    function fulfil(bytes32 requestHash, FulfilExec calldata fulfilExec, address transmitter) external payable {\n        // Should only be called by Bungee contract\n        if (msg.sender != address(BUNGEE_GATEWAY)) revert CallerNotBungeeGateway();\n\n        _fulfil(requestHash, fulfilExec, transmitter);\n    }\n\n    /// @notice Called by Bungee on the destination chain to withdraw requests\n    /// @dev delegates the withdraw to the router\n    function withdrawRequestOnDestination(Request calldata request, bytes calldata withdrawRequestData) external {\n        // Should only be called by Bungee contract\n        if (msg.sender != address(BUNGEE_GATEWAY)) revert CallerNotBungeeGateway();\n\n        _withdrawRequestOnDestination(request, withdrawRequestData);\n    }\n\n    /// @notice Release funds on the router to the receiver\n    /// @dev delegates the release to the router. Routers may or may not support this\n    /// @dev can only be called by BungeeGateways\n    function releaseFunds(address token, uint256 amount, address recipient) external {\n        // Should only be called by Bungee contract\n        if (msg.sender != address(BUNGEE_GATEWAY)) revert CallerNotBungeeGateway();\n        // Send the tokens in the exec to the receiver.\n        _releaseFunds(token, amount, recipient);\n    }\n\n    /// @dev internal function for fulfil that every router needs to implement\n    function _fulfil(bytes32 requestHash, FulfilExec calldata fulfilExec, address transmitter) internal virtual {}\n\n    /// @dev internal function for executing the route every router needs to implement\n    function _execute(\n        uint256 amount,\n        address inputToken,\n        bytes32 requestHash,\n        address receiverContract,\n        ExtractExec calldata exec\n    ) internal virtual {}\n\n    /// @dev internal function for releasing funds every router needs to implement\n    function _releaseFunds(address token, uint256 amount, address recipient) internal virtual {}\n\n    /// @dev internal function for collecting fee every router needs to implement\n    function _collectFee(address token, uint256 amount, address feeTaker, bytes32 requestHash) internal virtual {}\n\n    /// @dev internal function for withdrawing request on destination every router needs to implement\n    function _withdrawRequestOnDestination(\n        Request calldata request,\n        bytes calldata withdrawRequestData\n    ) internal virtual {}\n}\n"
    },
    "src/routers/CCTPV2RouterSingleOutput.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.19;\nimport {BaseRouter} from \"./BaseRouterSingleOutput.sol\";\nimport {Request, FulfilExec, ExtractExec} from \"../common/SingleOutputStructs.sol\";\nimport {\n    InvalidMsg,\n    MsgReceiveFailed,\n    InvalidFulfil,\n    FulfilmentDeadlineNotMet,\n    UnsupportedRequest\n} from \"../common/Errors.sol\";\nimport {NotImplemented, InvalidReceiver} from \"../common/Errors.sol\";\nimport {AccessControl} from \"../utils/AccessControl.sol\";\nimport {RESCUE_ROLE, CONFIG_ROLE} from \"../common/AccessRoles.sol\";\nimport {ITokenMessengerV2, IMessageTransmitterV2} from \"../interfaces/ICCTPV2.sol\";\nimport {ERC20} from \"solady/src/tokens/ERC20.sol\";\nimport {SafeTransferLib} from \"solady/src/utils/SafeTransferLib.sol\";\nimport {RequestLib} from \"../lib/SingleOutputRequestLib.sol\";\nimport {CurrencyLib} from \"../lib/CurrencyLib.sol\";\nimport {RescueFundsLib} from \"../lib/RescueFundsLib.sol\";\nimport {BytesLib} from \"../lib/BytesLib.sol\";\n\n/// @notice struct to store the message params received from CCTP\nstruct CCTPMessage {\n    uint256 receivedAmount;\n    bytes32 msgNonce;\n    uint32 sourceDomain;\n    address beneficiary;\n    uint256 promisedAmount;\n    uint256 expiry;\n}\n\n/// @title CCTPV2Router\n/// @notice Bungee Protocol Router to route funds via CCTP V2\ncontract CCTPV2Router is BaseRouter, AccessControl {\n    using RequestLib for Request;\n    using BytesLib for bytes;\n\n    uint256 internal constant CCTPV2_SOURCE_DOMAIN_INDEX = 4;\n    uint256 internal constant CCTPV2_DESTINATION_DOMAIN_INDEX = 8;\n    uint256 internal constant CCTPV2_NONCE_INDEX = 12;\n    uint256 internal constant CCTPV2_MESSAGE_BODY_INDEX = 148;\n    uint256 internal constant CCTPV2_MINT_RECIPIENT_INDEX = CCTPV2_MESSAGE_BODY_INDEX + 36;\n    uint256 internal constant CCTPV2_MESSAGE_SENDER_INDEX = CCTPV2_MESSAGE_BODY_INDEX + 100;\n    uint256 internal constant CCTPV2_FEE_EXECUTED_INDEX = CCTPV2_MESSAGE_BODY_INDEX + 164;\n    uint256 internal constant CCTPV2_HOOK_DATA_INDEX = CCTPV2_MESSAGE_BODY_INDEX + 228;\n\n    /// @notice CCTP Token Messenger\n    ITokenMessengerV2 public immutable tokenMessengerV2;\n\n    /// @notice CCTP Message Transmitter\n    IMessageTransmitterV2 public immutable msgTransmitterV2;\n\n    /// @notice CCTP USDC token address\n    ERC20 public immutable CIRCLE_USDC;\n\n    /// @notice expiry time for the request to be fulfilled for a CCTP request\n    uint256 public expiry = 3600; // 1 hour\n\n    /// @notice Mapping of chain ids destination domains.\n    /// @dev integrations should always use getDestinationDomain to get the domain\n    /// @dev public because getDestinationDomain might revert if a chain is not configured\n    mapping(uint256 => uint32) public _chainIdToDomainMap;\n\n    /// @notice Mapping of domain to chainId map.\n    mapping(uint32 => uint256) public domainToChainIdMap;\n\n    constructor(\n        address _bungeeGateway,\n        address _tokenMessengerV2,\n        address _msgTransmitterV2,\n        address _circleUsdc,\n        address _swapExecutor,\n        address _feeCollector,\n        address _owner\n    ) AccessControl(_owner) BaseRouter(_bungeeGateway, _swapExecutor, _feeCollector) {\n        _grantRole(RESCUE_ROLE, _owner);\n        _grantRole(CONFIG_ROLE, _owner);\n\n        tokenMessengerV2 = ITokenMessengerV2(_tokenMessengerV2);\n        msgTransmitterV2 = IMessageTransmitterV2(_msgTransmitterV2);\n        CIRCLE_USDC = ERC20(_circleUsdc);\n    }\n\n    /// @notice Add config for a destination chain to support\n    /// @dev destination domain of ethereum is 0. Thus we add 1 to the actual destination domain.\n    /// @dev Callable only by CONFIG_ROLE\n    function addDestinationChainSupport(uint256 toChainId, uint32 domain) external onlyRole(CONFIG_ROLE) {\n        _chainIdToDomainMap[toChainId] = domain + 1;\n    }\n\n    /// @dev remove destination chain support\n    /// @dev Callable only by CONFIG_ROLE\n    function removeDestinationChainSupport(uint256 toChainId) external onlyRole(CONFIG_ROLE) {\n        delete _chainIdToDomainMap[toChainId];\n    }\n\n    /// @notice Add domain to chainId map\n    /// @dev Callable only by CONFIG_ROLE\n    function addDomainToChainIdMap(uint256 chainId, uint32 domain) external onlyRole(CONFIG_ROLE) {\n        domainToChainIdMap[domain] = chainId;\n    }\n\n    /// @notice Remove domain to chainId map\n    /// @dev Callable only by CONFIG_ROLE\n    function removeDomainToChainIdMap(uint32 domain) external onlyRole(CONFIG_ROLE) {\n        delete domainToChainIdMap[domain];\n    }\n\n    /// @notice returns the destination domain for a given chain id\n    /// @dev We deduct 1 since we add 1 to the domain when we add a destination chain to support.\n    /// @dev Will revert with underflow if a chain is not configured\n    function getDestinationDomain(uint256 toChainId) public view returns (uint32) {\n        return _chainIdToDomainMap[toChainId] - 1;\n    }\n\n    /// @notice Set expiry time for the request to be fulfilled for a CCTP request\n    /// @dev Callable only by CONFIG_ROLE\n    function setExpiry(uint256 _expiry) external onlyRole(CONFIG_ROLE) {\n        expiry = _expiry;\n    }\n\n    /**\n     * @notice this function is responsible for routing funds to the CCTP bridge.\n     * @dev funds would have been sent to this router from Bungee Gateway\n     * @dev routerData contains all relevant details required by the CCTP bridge.\n     * @param amount execution submitted by the transmitter for the request.\n        When a request is settled beneficiary will receive funds.\n     * @param requestHash hash of the request.\n     * @param receiverContract address of the receiver contract.\n     * @param exec ExtractExec sent by the solver.\n     */\n    function _execute(\n        uint256 amount,\n        address /* inputToken */,\n        bytes32 requestHash,\n        address receiverContract,\n        ExtractExec calldata exec\n    ) internal override {\n        // Check if the toChainId has a relevant destination domain\n        uint32 destinationDomain = getDestinationDomain(exec.request.basicReq.destinationChainId);\n\n        // decode maxFee and minFinalityThreshold from the exec\n        (uint256 maxFee, uint32 minFinalityThreshold) = abi.decode(exec.routerData, (uint256, uint32));\n\n        if (receiverContract == address(0)) revert InvalidReceiver();\n\n        // Bridge Via CCTP\n        bytes32 destinationReceiver = bytes32(uint256(uint160(receiverContract)));\n        // Approve the token messenger to pull funds from here.\n        SafeTransferLib.safeApprove(address(CIRCLE_USDC), address(tokenMessengerV2), amount);\n\n        // amount received on the other side, request hash, transmitter address that will fulfil the order\n        // promised amount, expiry time for the request.\n        bytes memory bungeeMsg = abi.encode(\n            amount,\n            requestHash,\n            exec.beneficiary,\n            exec.promisedAmount,\n            block.timestamp + expiry // fulfilment deadline for withdrawal would be 1 hour from extraction\n        );\n\n        // Send Message via CCTP to the destination receiver.\n        tokenMessengerV2.depositForBurnWithHook(\n            amount,\n            destinationDomain,\n            destinationReceiver,\n            address(CIRCLE_USDC),\n            destinationReceiver,\n            maxFee,\n            minFinalityThreshold,\n            bungeeMsg\n        );\n    }\n\n    /// @notice Performs fulfilment of a request\n    /// @dev Called by BungeeGateway on the destination chain\n    /// @dev Submits CCTP Attestations to receive USDC and message sent from Bungee Gateway\n    /// @dev Performs a swap if needed and sends funds to the receiver\n    /// @dev Sends any remaining funds back to the transmitter\n    function _fulfil(bytes32 requestHash, FulfilExec calldata fulfilExec, address /* transmitter */) internal override {\n        // Decode the message and attestations needed for claiming funds from the cctp bridge.\n        (\n            uint256 swapInputAmount,\n            address swapRouter,\n            bytes memory swapData,\n            bytes memory cctpMessage,\n            bytes memory cctpMsgAttestation\n        ) = abi.decode(fulfilExec.routerData, (uint256, address, bytes, bytes, bytes));\n\n        // Submit attestation\n        _submitAttestation(cctpMessage, cctpMsgAttestation);\n\n        // validation\n        _validateMessage(cctpMessage);\n\n        // Decode hook data to bungeeMsg\n        CCTPMessage memory msgReceived = decodeBungeeMessage(cctpMessage);\n        // Revert if the message is empty i.e, not set.\n        require(msgReceived.expiry > 0);\n\n        // Check if the nonce was used for an appropriate msg.\n        if (msgTransmitterV2.usedNonces(msgReceived.msgNonce) == 0) revert InvalidFulfil();\n\n        // Fulfil\n        // Get the initial balance of USDC on the contract.\n        uint256 initialBalance = CIRCLE_USDC.balanceOf(address(this));\n\n        // If a swap needs to happen, do a swap\n        // Assumption is that the funds would be received on this address directly.\n        // Call the swap executor to execute the swap.\n        if (swapInputAmount > 0) {\n            CurrencyLib.transfer({\n                token: address(CIRCLE_USDC),\n                recipient: address(SWAP_EXECUTOR),\n                amount: swapInputAmount\n            });\n            SWAP_EXECUTOR.executeSwap(address(CIRCLE_USDC), swapInputAmount, swapRouter, swapData);\n        }\n\n        // Send funds to the receiver of the request.\n        // Here we need to check if the fulfilAmount is greater than promised amounts.\n        if (fulfilExec.fulfilAmount < msgReceived.promisedAmount) revert InvalidFulfil();\n\n        // if the output token is native token\n        if (fulfilExec.request.basicReq.outputToken == NATIVE_TOKEN_ADDRESS) {\n            // prevent refuel amount\n            if (fulfilExec.request.basicReq.refuelAmount > 0) revert UnsupportedRequest();\n        }\n\n        // Send the tokens in the exec to the receiver.\n        CurrencyLib.transfer({\n            token: fulfilExec.request.basicReq.outputToken,\n            recipient: fulfilExec.request.basicReq.receiver,\n            amount: fulfilExec.fulfilAmount\n        });\n\n        if (fulfilExec.request.basicReq.refuelAmount > 0) {\n            // Send refuel amount to the receiver.\n            CurrencyLib.transfer({\n                token: NATIVE_TOKEN_ADDRESS,\n                recipient: fulfilExec.request.basicReq.receiver,\n                amount: fulfilExec.request.basicReq.refuelAmount\n            });\n        }\n\n        // Get the final balance and check if the right amount of USDC was used to swap.\n        // Send the leftover funds to the transmitter\n        uint256 amountUsed = initialBalance - CIRCLE_USDC.balanceOf(address(this));\n        // Reduce CCTP Fast Transfer fee if any\n        uint256 feeExecuted = cctpMessage.toUint256(CCTPV2_FEE_EXECUTED_INDEX);\n        uint256 remainingAmount = msgReceived.receivedAmount - feeExecuted - amountUsed;\n        if (remainingAmount > 0) {\n            CurrencyLib.transfer({\n                token: address(CIRCLE_USDC),\n                recipient: msgReceived.beneficiary,\n                amount: remainingAmount\n            });\n        }\n    }\n\n    /// @dev Decode bungee message from cctp message\n    function decodeBungeeMessage(bytes memory cctpMsg) public pure returns (CCTPMessage memory) {\n        // decode bungeeMsg from CCTP\n        (uint256 amount, bytes32 requestHash, address beneficiary, uint256 promisedAmount, uint256 _expiry) = abi\n            .decode(cctpMsg.slice(CCTPV2_HOOK_DATA_INDEX, 160), (uint256, bytes32, address, uint256, uint256));\n\n        return\n            CCTPMessage({\n                receivedAmount: amount,\n                msgNonce: cctpMsg.toBytes32(CCTPV2_NONCE_INDEX),\n                sourceDomain: cctpMsg.toUint32(CCTPV2_SOURCE_DOMAIN_INDEX),\n                promisedAmount: promisedAmount,\n                beneficiary: beneficiary,\n                expiry: _expiry\n            });\n    }\n\n    /// @dev Called by Bungee on the destination chain to withdraw requests\n    /// @dev User can withdraw the funds if the fulfilment deadline is met.\n    /// @dev Submits attestation to CCTP to receive the bridged USDC and transfers it to the receiver.\n    /// @dev Will not perform any swap if was present in the request.\n    function _withdrawRequestOnDestination(\n        Request calldata request,\n        bytes calldata withdrawRequestData\n    ) internal override {\n        (bytes memory cctpMessage, bytes memory cctpMsgAttestation) = abi.decode(withdrawRequestData, (bytes, bytes));\n\n        /// @dev should revert if the order was already fulfilled\n        _submitAttestation(cctpMessage, cctpMsgAttestation);\n\n        bytes32 requestHash = request.hashDestinationRequest();\n\n        // validation\n        _validateMessage(cctpMessage);\n\n        // Decode hook data to bungeeMsg\n        CCTPMessage memory msgReceived = decodeBungeeMessage(cctpMessage);\n        // Revert if the message is empty i.e, not set.\n        require(msgReceived.expiry > 0);\n\n        // check if fulfilment deadline is passed\n        if (block.timestamp < msgReceived.expiry) revert FulfilmentDeadlineNotMet();\n\n        // Check if the nonce was used for an appropriate msg.\n        if (msgTransmitterV2.usedNonces(msgReceived.msgNonce) == 0) revert InvalidFulfil();\n\n        // Reduce CCTP Fast Transfer fee if any\n        uint256 feeExecuted = cctpMessage.toUint256(CCTPV2_FEE_EXECUTED_INDEX);\n        uint256 amountToReceiver = msgReceived.receivedAmount - feeExecuted;\n\n        CurrencyLib.transfer({\n            token: address(CIRCLE_USDC),\n            recipient: request.basicReq.receiver,\n            amount: amountToReceiver\n        });\n\n        // Emits Withdraw event\n        emit WithdrawOnDestination(requestHash, address(CIRCLE_USDC), amountToReceiver, request.basicReq.receiver);\n    }\n\n    /// @dev Submit the attestations for the CCTP message\n    function _submitAttestation(bytes memory cctpMessage, bytes memory cctpMsgAttestation) internal {\n        bool a = msgTransmitterV2.receiveMessage(cctpMessage, cctpMsgAttestation);\n\n        if (!a) revert MsgReceiveFailed();\n    }\n\n    /// @dev Validate the message received from CCTP\n    /// @dev uses CCTP message format to decode the message\n    function _validateMessage(bytes memory cctpMessage) internal view {\n        bytes32 sender = cctpMessage.toBytes32(CCTPV2_MESSAGE_SENDER_INDEX);\n        uint32 sourceDomain = cctpMessage.toUint32(CCTPV2_SOURCE_DOMAIN_INDEX);\n        bytes32 recipient = cctpMessage.toBytes32(CCTPV2_MINT_RECIPIENT_INDEX);\n\n        if (\n            // Check if the sender is the CCTP router on source.\n            address(uint160(uint256(sender))) !=\n            BUNGEE_GATEWAY.getWhitelistedReceiver(address(this), domainToChainIdMap[sourceDomain]) ||\n            // Check if the recipient is the CCTP router on destination.\n            address(uint160(uint256(recipient))) != address(this)\n        ) revert InvalidMsg();\n    }\n\n    /// @dev can only be called by BungeeGateways\n    function _releaseFunds(address /* token */, uint256 /* amount */, address /* recipient */) internal pure override {\n        // Revert to avoid funds being sent or any subsequent actions.\n        revert NotImplemented();\n    }\n\n    /// @dev Registers unlocked affiliate fees on FeeCollector during extraction\n    function _collectFee(address token, uint256 amount, address feeTaker, bytes32 /* requestHash */) internal override {\n        CurrencyLib.transfer({token: token, recipient: address(FEE_COLLECTOR), amount: amount});\n        FEE_COLLECTOR.registerFee(feeTaker, amount, token);\n    }\n\n    /**\n     * @notice send funds to the provided address if stuck, can be called only by owner.\n     * @param token address of the token\n     * @param amount amount to be rescued\n     * @param to address, funds will be transferred to this address.\n     */\n    function rescue(address token, address to, uint256 amount) external onlyRole(RESCUE_ROLE) {\n        RescueFundsLib.rescueFunds(token, to, amount);\n    }\n\n    receive() external payable {}\n}\n"
    },
    "src/utils/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.19;\n\nimport {Ownable} from \"./Ownable.sol\";\n\n/**\n * @title AccessControl\n * @dev This abstract contract implements access control mechanism based on roles.\n * Each role can have one or more addresses associated with it, which are granted\n * permission to execute functions with the onlyRole modifier.\n */\nabstract contract AccessControl is Ownable {\n    /**\n     * @dev A mapping of roles to a mapping of addresses to boolean values indicating whether or not they have the role.\n     */\n    mapping(bytes32 => mapping(address => bool)) private _permits;\n\n    /**\n     * @dev Emitted when a role is granted to an address.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed grantee);\n\n    /**\n     * @dev Emitted when a role is revoked from an address.\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed revokee);\n\n    /**\n     * @dev Error message thrown when an address does not have permission to execute a function with onlyRole modifier.\n     */\n    error NoPermit(bytes32 role);\n\n    /**\n     * @dev Constructor that sets the owner of the contract.\n     */\n    constructor(address owner_) Ownable(owner_) {}\n\n    /**\n     * @dev Modifier that restricts access to addresses having roles\n     * Throws an error if the caller do not have permit\n     */\n    modifier onlyRole(bytes32 role) {\n        if (!_permits[role][msg.sender]) revert NoPermit(role);\n        _;\n    }\n\n    /**\n     * @dev Checks and reverts if an address do not have a specific role.\n     * @param role_ The role to check.\n     * @param address_ The address to check.\n     */\n    function _checkRole(bytes32 role_, address address_) internal virtual {\n        if (!_hasRole(role_, address_)) revert NoPermit(role_);\n    }\n\n    /**\n     * @dev Grants a role to a given address.\n     * @param role_ The role to grant.\n     * @param grantee_ The address to grant the role to.\n     * Emits a RoleGranted event.\n     * Can only be called by the owner of the contract.\n     */\n    function grantRole(bytes32 role_, address grantee_) external virtual onlyOwner {\n        _grantRole(role_, grantee_);\n    }\n\n    /**\n     * @dev Revokes a role from a given address.\n     * @param role_ The role to revoke.\n     * @param revokee_ The address to revoke the role from.\n     * Emits a RoleRevoked event.\n     * Can only be called by the owner of the contract.\n     */\n    function revokeRole(bytes32 role_, address revokee_) external virtual onlyOwner {\n        _revokeRole(role_, revokee_);\n    }\n\n    /**\n     * @dev Internal function to grant a role to a given address.\n     * @param role_ The role to grant.\n     * @param grantee_ The address to grant the role to.\n     * Emits a RoleGranted event.\n     */\n    function _grantRole(bytes32 role_, address grantee_) internal {\n        _permits[role_][grantee_] = true;\n        emit RoleGranted(role_, grantee_);\n    }\n\n    /**\n     * @dev Internal function to revoke a role from a given address.\n     * @param role_ The role to revoke.\n     * @param revokee_ The address to revoke the role from.\n     * Emits a RoleRevoked event.\n     */\n    function _revokeRole(bytes32 role_, address revokee_) internal {\n        _permits[role_][revokee_] = false;\n        emit RoleRevoked(role_, revokee_);\n    }\n\n    /**\n     * @dev Checks whether an address has a specific role.\n     * @param role_ The role to check.\n     * @param address_ The address to check.\n     * @return A boolean value indicating whether or not the address has the role.\n     */\n    function hasRole(bytes32 role_, address address_) public view returns (bool) {\n        return _hasRole(role_, address_);\n    }\n\n    function _hasRole(bytes32 role_, address address_) internal view returns (bool) {\n        return _permits[role_][address_];\n    }\n}\n"
    },
    "src/utils/Ownable.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.19;\n\nimport {OnlyOwner, OnlyNominee} from \"../common/Errors.sol\";\n\n// @audit Audited before by Zellic: https://github.com/SocketDotTech/audits/blob/main/Socket-DL/07-2023%20-%20Data%20Layer%20-%20Zellic.pdf\nabstract contract Ownable {\n    address private _owner;\n    address private _nominee;\n\n    event OwnerNominated(address indexed nominee);\n    event OwnerClaimed(address indexed claimer);\n\n    constructor(address owner_) {\n        _claimOwner(owner_);\n    }\n\n    modifier onlyOwner() {\n        if (msg.sender != _owner) {\n            revert OnlyOwner();\n        }\n        _;\n    }\n\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    function nominee() public view returns (address) {\n        return _nominee;\n    }\n\n    function nominateOwner(address nominee_) external {\n        if (msg.sender != _owner) {\n            revert OnlyOwner();\n        }\n        _nominee = nominee_;\n        emit OwnerNominated(_nominee);\n    }\n\n    function claimOwner() external {\n        if (msg.sender != _nominee) {\n            revert OnlyNominee();\n        }\n        _claimOwner(msg.sender);\n    }\n\n    function _claimOwner(address claimer_) internal {\n        _owner = claimer_;\n        _nominee = address(0);\n        emit OwnerClaimed(claimer_);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}