{{
  "language": "Solidity",
  "sources": {
    "@layerzerolabs/lz-evm-messagelib-v2/contracts/libs/ExecutorOptions.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport \"@layerzerolabs/lz-evm-protocol-v2/contracts/libs/CalldataBytesLib.sol\";\n\nlibrary ExecutorOptions {\n    using CalldataBytesLib for bytes;\n\n    uint8 internal constant WORKER_ID = 1;\n\n    uint8 internal constant OPTION_TYPE_LZRECEIVE = 1;\n    uint8 internal constant OPTION_TYPE_NATIVE_DROP = 2;\n    uint8 internal constant OPTION_TYPE_LZCOMPOSE = 3;\n    uint8 internal constant OPTION_TYPE_ORDERED_EXECUTION = 4;\n    uint8 internal constant OPTION_TYPE_LZREAD = 5;\n\n    error Executor_InvalidLzReceiveOption();\n    error Executor_InvalidNativeDropOption();\n    error Executor_InvalidLzComposeOption();\n    error Executor_InvalidLzReadOption();\n\n    /// @dev decode the next executor option from the options starting from the specified cursor\n    /// @param _options [executor_id][executor_option][executor_id][executor_option]...\n    ///        executor_option = [option_size][option_type][option]\n    ///        option_size = len(option_type) + len(option)\n    ///        executor_id: uint8, option_size: uint16, option_type: uint8, option: bytes\n    /// @param _cursor the cursor to start decoding from\n    /// @return optionType the type of the option\n    /// @return option the option of the executor\n    /// @return cursor the cursor to start decoding the next executor option\n    function nextExecutorOption(\n        bytes calldata _options,\n        uint256 _cursor\n    ) internal pure returns (uint8 optionType, bytes calldata option, uint256 cursor) {\n        unchecked {\n            // skip worker id\n            cursor = _cursor + 1;\n\n            // read option size\n            uint16 size = _options.toU16(cursor);\n            cursor += 2;\n\n            // read option type\n            optionType = _options.toU8(cursor);\n\n            // startCursor and endCursor are used to slice the option from _options\n            uint256 startCursor = cursor + 1; // skip option type\n            uint256 endCursor = cursor + size;\n            option = _options[startCursor:endCursor];\n            cursor += size;\n        }\n    }\n\n    function decodeLzReceiveOption(bytes calldata _option) internal pure returns (uint128 gas, uint128 value) {\n        if (_option.length != 16 && _option.length != 32) revert Executor_InvalidLzReceiveOption();\n        gas = _option.toU128(0);\n        value = _option.length == 32 ? _option.toU128(16) : 0;\n    }\n\n    function decodeNativeDropOption(bytes calldata _option) internal pure returns (uint128 amount, bytes32 receiver) {\n        if (_option.length != 48) revert Executor_InvalidNativeDropOption();\n        amount = _option.toU128(0);\n        receiver = _option.toB32(16);\n    }\n\n    function decodeLzComposeOption(\n        bytes calldata _option\n    ) internal pure returns (uint16 index, uint128 gas, uint128 value) {\n        if (_option.length != 18 && _option.length != 34) revert Executor_InvalidLzComposeOption();\n        index = _option.toU16(0);\n        gas = _option.toU128(2);\n        value = _option.length == 34 ? _option.toU128(18) : 0;\n    }\n\n    function decodeLzReadOption(\n        bytes calldata _option\n    ) internal pure returns (uint128 gas, uint32 calldataSize, uint128 value) {\n        if (_option.length != 20 && _option.length != 36) revert Executor_InvalidLzReadOption();\n        gas = _option.toU128(0);\n        calldataSize = _option.toU32(16);\n        value = _option.length == 36 ? _option.toU128(20) : 0;\n    }\n\n    function encodeLzReceiveOption(uint128 _gas, uint128 _value) internal pure returns (bytes memory) {\n        return _value == 0 ? abi.encodePacked(_gas) : abi.encodePacked(_gas, _value);\n    }\n\n    function encodeNativeDropOption(uint128 _amount, bytes32 _receiver) internal pure returns (bytes memory) {\n        return abi.encodePacked(_amount, _receiver);\n    }\n\n    function encodeLzComposeOption(uint16 _index, uint128 _gas, uint128 _value) internal pure returns (bytes memory) {\n        return _value == 0 ? abi.encodePacked(_index, _gas) : abi.encodePacked(_index, _gas, _value);\n    }\n\n    function encodeLzReadOption(\n        uint128 _gas,\n        uint32 _calldataSize,\n        uint128 _value\n    ) internal pure returns (bytes memory) {\n        return _value == 0 ? abi.encodePacked(_gas, _calldataSize) : abi.encodePacked(_gas, _calldataSize, _value);\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-messagelib-v2/contracts/uln/libs/DVNOptions.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { BytesLib } from \"solidity-bytes-utils/contracts/BytesLib.sol\";\n\nimport { BitMap256 } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/BitMaps.sol\";\nimport { CalldataBytesLib } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/libs/CalldataBytesLib.sol\";\n\nlibrary DVNOptions {\n    using CalldataBytesLib for bytes;\n    using BytesLib for bytes;\n\n    uint8 internal constant WORKER_ID = 2;\n    uint8 internal constant OPTION_TYPE_PRECRIME = 1;\n\n    error DVN_InvalidDVNIdx();\n    error DVN_InvalidDVNOptions(uint256 cursor);\n\n    /// @dev group dvn options by its idx\n    /// @param _options [dvn_id][dvn_option][dvn_id][dvn_option]...\n    ///        dvn_option = [option_size][dvn_idx][option_type][option]\n    ///        option_size = len(dvn_idx) + len(option_type) + len(option)\n    ///        dvn_id: uint8, dvn_idx: uint8, option_size: uint16, option_type: uint8, option: bytes\n    /// @return dvnOptions the grouped options, still share the same format of _options\n    /// @return dvnIndices the dvn indices\n    function groupDVNOptionsByIdx(\n        bytes memory _options\n    ) internal pure returns (bytes[] memory dvnOptions, uint8[] memory dvnIndices) {\n        if (_options.length == 0) return (dvnOptions, dvnIndices);\n\n        uint8 numDVNs = getNumDVNs(_options);\n\n        // if there is only 1 dvn, we can just return the whole options\n        if (numDVNs == 1) {\n            dvnOptions = new bytes[](1);\n            dvnOptions[0] = _options;\n\n            dvnIndices = new uint8[](1);\n            dvnIndices[0] = _options.toUint8(3); // dvn idx\n            return (dvnOptions, dvnIndices);\n        }\n\n        // otherwise, we need to group the options by dvn_idx\n        dvnIndices = new uint8[](numDVNs);\n        dvnOptions = new bytes[](numDVNs);\n        unchecked {\n            uint256 cursor = 0;\n            uint256 start = 0;\n            uint8 lastDVNIdx = 255; // 255 is an invalid dvn_idx\n\n            while (cursor < _options.length) {\n                ++cursor; // skip worker_id\n\n                // optionLength asserted in getNumDVNs (skip check)\n                uint16 optionLength = _options.toUint16(cursor);\n                cursor += 2;\n\n                // dvnIdx asserted in getNumDVNs (skip check)\n                uint8 dvnIdx = _options.toUint8(cursor);\n\n                // dvnIdx must equal to the lastDVNIdx for the first option\n                // so it is always skipped in the first option\n                // this operation slices out options whenever the scan finds a different lastDVNIdx\n                if (lastDVNIdx == 255) {\n                    lastDVNIdx = dvnIdx;\n                } else if (dvnIdx != lastDVNIdx) {\n                    uint256 len = cursor - start - 3; // 3 is for worker_id and option_length\n                    bytes memory opt = _options.slice(start, len);\n                    _insertDVNOptions(dvnOptions, dvnIndices, lastDVNIdx, opt);\n\n                    // reset the start and lastDVNIdx\n                    start += len;\n                    lastDVNIdx = dvnIdx;\n                }\n\n                cursor += optionLength;\n            }\n\n            // skip check the cursor here because the cursor is asserted in getNumDVNs\n            // if we have reached the end of the options, we need to process the last dvn\n            uint256 size = cursor - start;\n            bytes memory op = _options.slice(start, size);\n            _insertDVNOptions(dvnOptions, dvnIndices, lastDVNIdx, op);\n\n            // revert dvnIndices to start from 0\n            for (uint8 i = 0; i < numDVNs; ++i) {\n                --dvnIndices[i];\n            }\n        }\n    }\n\n    function _insertDVNOptions(\n        bytes[] memory _dvnOptions,\n        uint8[] memory _dvnIndices,\n        uint8 _dvnIdx,\n        bytes memory _newOptions\n    ) internal pure {\n        // dvnIdx starts from 0 but default value of dvnIndices is 0,\n        // so we tell if the slot is empty by adding 1 to dvnIdx\n        if (_dvnIdx == 255) revert DVN_InvalidDVNIdx();\n        uint8 dvnIdxAdj = _dvnIdx + 1;\n\n        for (uint256 j = 0; j < _dvnIndices.length; ++j) {\n            uint8 index = _dvnIndices[j];\n            if (dvnIdxAdj == index) {\n                _dvnOptions[j] = abi.encodePacked(_dvnOptions[j], _newOptions);\n                break;\n            } else if (index == 0) {\n                // empty slot, that means it is the first time we see this dvn\n                _dvnIndices[j] = dvnIdxAdj;\n                _dvnOptions[j] = _newOptions;\n                break;\n            }\n        }\n    }\n\n    /// @dev get the number of unique dvns\n    /// @param _options the format is the same as groupDVNOptionsByIdx\n    function getNumDVNs(bytes memory _options) internal pure returns (uint8 numDVNs) {\n        uint256 cursor = 0;\n        BitMap256 bitmap;\n\n        // find number of unique dvn_idx\n        unchecked {\n            while (cursor < _options.length) {\n                ++cursor; // skip worker_id\n\n                uint16 optionLength = _options.toUint16(cursor);\n                cursor += 2;\n                if (optionLength < 2) revert DVN_InvalidDVNOptions(cursor); // at least 1 byte for dvn_idx and 1 byte for option_type\n\n                uint8 dvnIdx = _options.toUint8(cursor);\n\n                // if dvnIdx is not set, increment numDVNs\n                // max num of dvns is 255, 255 is an invalid dvn_idx\n                // The order of the dvnIdx is not required to be sequential, as enforcing the order may weaken\n                // the composability of the options. e.g. if we refrain from enforcing the order, an OApp that has\n                // already enforced certain options can append additional options to the end of the enforced\n                // ones without restrictions.\n                if (dvnIdx == 255) revert DVN_InvalidDVNIdx();\n                if (!bitmap.get(dvnIdx)) {\n                    ++numDVNs;\n                    bitmap = bitmap.set(dvnIdx);\n                }\n\n                cursor += optionLength;\n            }\n        }\n        if (cursor != _options.length) revert DVN_InvalidDVNOptions(cursor);\n    }\n\n    /// @dev decode the next dvn option from _options starting from the specified cursor\n    /// @param _options the format is the same as groupDVNOptionsByIdx\n    /// @param _cursor the cursor to start decoding\n    /// @return optionType the type of the option\n    /// @return option the option\n    /// @return cursor the cursor to start decoding the next option\n    function nextDVNOption(\n        bytes calldata _options,\n        uint256 _cursor\n    ) internal pure returns (uint8 optionType, bytes calldata option, uint256 cursor) {\n        unchecked {\n            // skip worker id\n            cursor = _cursor + 1;\n\n            // read option size\n            uint16 size = _options.toU16(cursor);\n            cursor += 2;\n\n            // read option type\n            optionType = _options.toU8(cursor + 1); // skip dvn_idx\n\n            // startCursor and endCursor are used to slice the option from _options\n            uint256 startCursor = cursor + 2; // skip option type and dvn_idx\n            uint256 endCursor = cursor + size;\n            option = _options[startCursor:endCursor];\n            cursor += size;\n        }\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/interfaces/IOAppComputerMap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\ninterface IOAppComputerMap {\n    function lzMap(bytes calldata _request, bytes calldata _response) external view returns (bytes memory);\n}\n"
    },
    "@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/interfaces/IOAppComputerReduce.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\ninterface IOAppComputerReduce {\n    function lzReduce(bytes calldata _cmd, bytes[] calldata _responses) external view returns (bytes memory);\n}\n"
    },
    "@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/interfaces/IOAppCore.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { ILayerZeroEndpointV2 } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol\";\n\n/**\n * @title IOAppCore\n */\ninterface IOAppCore {\n    // Custom error messages\n    error OnlyPeer(uint32 eid, bytes32 sender);\n    error NoPeer(uint32 eid);\n    error InvalidEndpointCall();\n    error InvalidDelegate();\n\n    // Event emitted when a peer (OApp) is set for a corresponding endpoint\n    event PeerSet(uint32 eid, bytes32 peer);\n\n    /**\n     * @notice Retrieves the OApp version information.\n     * @return senderVersion The version of the OAppSender.sol contract.\n     * @return receiverVersion The version of the OAppReceiver.sol contract.\n     */\n    function oAppVersion() external view returns (uint64 senderVersion, uint64 receiverVersion);\n\n    /**\n     * @notice Retrieves the LayerZero endpoint associated with the OApp.\n     * @return iEndpoint The LayerZero endpoint as an interface.\n     */\n    function endpoint() external view returns (ILayerZeroEndpointV2 iEndpoint);\n\n    /**\n     * @notice Retrieves the peer (OApp) associated with a corresponding endpoint.\n     * @param _eid The endpoint ID.\n     * @return peer The peer address (OApp instance) associated with the corresponding endpoint.\n     */\n    function peers(uint32 _eid) external view returns (bytes32 peer);\n\n    /**\n     * @notice Sets the peer address (OApp instance) for a corresponding endpoint.\n     * @param _eid The endpoint ID.\n     * @param _peer The address of the peer to be associated with the corresponding endpoint.\n     */\n    function setPeer(uint32 _eid, bytes32 _peer) external;\n\n    /**\n     * @notice Sets the delegate address for the OApp Core.\n     * @param _delegate The address of the delegate to be set.\n     */\n    function setDelegate(address _delegate) external;\n}\n"
    },
    "@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/interfaces/IOAppOptionsType3.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Struct representing enforced option parameters.\n */\nstruct EnforcedOptionParam {\n    uint32 eid; // Endpoint ID\n    uint16 msgType; // Message Type\n    bytes options; // Additional options\n}\n\n/**\n * @title IOAppOptionsType3\n * @dev Interface for the OApp with Type 3 Options, allowing the setting and combining of enforced options.\n */\ninterface IOAppOptionsType3 {\n    // Custom error message for invalid options\n    error InvalidOptions(bytes options);\n\n    // Event emitted when enforced options are set\n    event EnforcedOptionSet(EnforcedOptionParam[] _enforcedOptions);\n\n    /**\n     * @notice Sets enforced options for specific endpoint and message type combinations.\n     * @param _enforcedOptions An array of EnforcedOptionParam structures specifying enforced options.\n     */\n    function setEnforcedOptions(EnforcedOptionParam[] calldata _enforcedOptions) external;\n\n    /**\n     * @notice Combines options for a given endpoint and message type.\n     * @param _eid The endpoint ID.\n     * @param _msgType The OApp message type.\n     * @param _extraOptions Additional options passed by the caller.\n     * @return options The combination of caller specified options AND enforced options.\n     */\n    function combineOptions(\n        uint32 _eid,\n        uint16 _msgType,\n        bytes calldata _extraOptions\n    ) external view returns (bytes memory options);\n}\n"
    },
    "@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/interfaces/IOAppReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { ILayerZeroReceiver, Origin } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroReceiver.sol\";\n\ninterface IOAppReceiver is ILayerZeroReceiver {\n    /**\n     * @notice Indicates whether an address is an approved composeMsg sender to the Endpoint.\n     * @param _origin The origin information containing the source endpoint and sender address.\n     *  - srcEid: The source chain endpoint ID.\n     *  - sender: The sender address on the src chain.\n     *  - nonce: The nonce of the message.\n     * @param _message The lzReceive payload.\n     * @param _sender The sender address.\n     * @return isSender Is a valid sender.\n     *\n     * @dev Applications can optionally choose to implement a separate composeMsg sender that is NOT the bridging layer.\n     * @dev The default sender IS the OAppReceiver implementer.\n     */\n    function isComposeMsgSender(\n        Origin calldata _origin,\n        bytes calldata _message,\n        address _sender\n    ) external view returns (bool isSender);\n}\n"
    },
    "@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/libs/OAppOptionsType3.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { IOAppOptionsType3, EnforcedOptionParam } from \"../interfaces/IOAppOptionsType3.sol\";\n\n/**\n * @title OAppOptionsType3\n * @dev Abstract contract implementing the IOAppOptionsType3 interface with type 3 options.\n */\nabstract contract OAppOptionsType3 is IOAppOptionsType3, Ownable {\n    uint16 internal constant OPTION_TYPE_3 = 3;\n\n    // @dev The \"msgType\" should be defined in the child contract.\n    mapping(uint32 eid => mapping(uint16 msgType => bytes enforcedOption)) public enforcedOptions;\n\n    /**\n     * @dev Sets the enforced options for specific endpoint and message type combinations.\n     * @param _enforcedOptions An array of EnforcedOptionParam structures specifying enforced options.\n     *\n     * @dev Only the owner/admin of the OApp can call this function.\n     * @dev Provides a way for the OApp to enforce things like paying for PreCrime, AND/OR minimum dst lzReceive gas amounts etc.\n     * @dev These enforced options can vary as the potential options/execution on the remote may differ as per the msgType.\n     * eg. Amount of lzReceive() gas necessary to deliver a lzCompose() message adds overhead you dont want to pay\n     * if you are only making a standard LayerZero message ie. lzReceive() WITHOUT sendCompose().\n     */\n    function setEnforcedOptions(EnforcedOptionParam[] calldata _enforcedOptions) public virtual onlyOwner {\n        _setEnforcedOptions(_enforcedOptions);\n    }\n\n    /**\n     * @dev Sets the enforced options for specific endpoint and message type combinations.\n     * @param _enforcedOptions An array of EnforcedOptionParam structures specifying enforced options.\n     *\n     * @dev Provides a way for the OApp to enforce things like paying for PreCrime, AND/OR minimum dst lzReceive gas amounts etc.\n     * @dev These enforced options can vary as the potential options/execution on the remote may differ as per the msgType.\n     * eg. Amount of lzReceive() gas necessary to deliver a lzCompose() message adds overhead you dont want to pay\n     * if you are only making a standard LayerZero message ie. lzReceive() WITHOUT sendCompose().\n     */\n    function _setEnforcedOptions(EnforcedOptionParam[] memory _enforcedOptions) internal virtual {\n        for (uint256 i = 0; i < _enforcedOptions.length; i++) {\n            // @dev Enforced options are only available for optionType 3, as type 1 and 2 dont support combining.\n            _assertOptionsType3(_enforcedOptions[i].options);\n            enforcedOptions[_enforcedOptions[i].eid][_enforcedOptions[i].msgType] = _enforcedOptions[i].options;\n        }\n\n        emit EnforcedOptionSet(_enforcedOptions);\n    }\n\n    /**\n     * @notice Combines options for a given endpoint and message type.\n     * @param _eid The endpoint ID.\n     * @param _msgType The OAPP message type.\n     * @param _extraOptions Additional options passed by the caller.\n     * @return options The combination of caller specified options AND enforced options.\n     *\n     * @dev If there is an enforced lzReceive option:\n     * - {gasLimit: 200k, msg.value: 1 ether} AND a caller supplies a lzReceive option: {gasLimit: 100k, msg.value: 0.5 ether}\n     * - The resulting options will be {gasLimit: 300k, msg.value: 1.5 ether} when the message is executed on the remote lzReceive() function.\n     * @dev This presence of duplicated options is handled off-chain in the verifier/executor.\n     */\n    function combineOptions(\n        uint32 _eid,\n        uint16 _msgType,\n        bytes calldata _extraOptions\n    ) public view virtual returns (bytes memory) {\n        bytes memory enforced = enforcedOptions[_eid][_msgType];\n\n        // No enforced options, pass whatever the caller supplied, even if it's empty or legacy type 1/2 options.\n        if (enforced.length == 0) return _extraOptions;\n\n        // No caller options, return enforced\n        if (_extraOptions.length == 0) return enforced;\n\n        // @dev If caller provided _extraOptions, must be type 3 as its the ONLY type that can be combined.\n        if (_extraOptions.length >= 2) {\n            _assertOptionsType3(_extraOptions);\n            // @dev Remove the first 2 bytes containing the type from the _extraOptions and combine with enforced.\n            return bytes.concat(enforced, _extraOptions[2:]);\n        }\n\n        // No valid set of options was found.\n        revert InvalidOptions(_extraOptions);\n    }\n\n    /**\n     * @dev Internal function to assert that options are of type 3.\n     * @param _options The options to be checked.\n     */\n    function _assertOptionsType3(bytes memory _options) internal pure virtual {\n        uint16 optionsType;\n        assembly {\n            optionsType := mload(add(_options, 2))\n        }\n        if (optionsType != OPTION_TYPE_3) revert InvalidOptions(_options);\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/libs/OptionsBuilder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { BytesLib } from \"solidity-bytes-utils/contracts/BytesLib.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport { ExecutorOptions } from \"@layerzerolabs/lz-evm-messagelib-v2/contracts/libs/ExecutorOptions.sol\";\nimport { DVNOptions } from \"@layerzerolabs/lz-evm-messagelib-v2/contracts/uln/libs/DVNOptions.sol\";\n\n/**\n * @title OptionsBuilder\n * @dev Library for building and encoding various message options.\n */\nlibrary OptionsBuilder {\n    using SafeCast for uint256;\n    using BytesLib for bytes;\n\n    // Constants for options types\n    uint16 internal constant TYPE_1 = 1; // legacy options type 1\n    uint16 internal constant TYPE_2 = 2; // legacy options type 2\n    uint16 internal constant TYPE_3 = 3;\n\n    // Custom error message\n    error InvalidSize(uint256 max, uint256 actual);\n    error InvalidOptionType(uint16 optionType);\n\n    // Modifier to ensure only options of type 3 are used\n    modifier onlyType3(bytes memory _options) {\n        if (_options.toUint16(0) != TYPE_3) revert InvalidOptionType(_options.toUint16(0));\n        _;\n    }\n\n    /**\n     * @dev Creates a new options container with type 3.\n     * @return options The newly created options container.\n     */\n    function newOptions() internal pure returns (bytes memory) {\n        return abi.encodePacked(TYPE_3);\n    }\n\n    /**\n     * @dev Adds an executor LZ receive option to the existing options.\n     * @param _options The existing options container.\n     * @param _gas The gasLimit used on the lzReceive() function in the OApp.\n     * @param _value The msg.value passed to the lzReceive() function in the OApp.\n     * @return options The updated options container.\n     *\n     * @dev When multiples of this option are added, they are summed by the executor\n     * eg. if (_gas: 200k, and _value: 1 ether) AND (_gas: 100k, _value: 0.5 ether) are sent in an option to the LayerZeroEndpoint,\n     * that becomes (300k, 1.5 ether) when the message is executed on the remote lzReceive() function.\n     */\n    function addExecutorLzReceiveOption(\n        bytes memory _options,\n        uint128 _gas,\n        uint128 _value\n    ) internal pure onlyType3(_options) returns (bytes memory) {\n        bytes memory option = ExecutorOptions.encodeLzReceiveOption(_gas, _value);\n        return addExecutorOption(_options, ExecutorOptions.OPTION_TYPE_LZRECEIVE, option);\n    }\n\n    /**\n     * @dev Adds an executor LZ read option to the existing options.\n     * @param _options The existing options container.\n     * @param _gas The gas limit used for the lzReceive() function in the ReadOApp.\n     * @param _calldataSize The size of the payload for lzReceive() function in the ReadOApp.\n     * @param _value The msg.value passed to the lzReceive() function in the ReadOApp.\n     * @return options The updated options container.\n     */\n    function addExecutorLzReadOption(\n        bytes memory _options,\n        uint128 _gas,\n        uint32 _calldataSize,\n        uint128 _value\n    ) internal pure onlyType3(_options) returns (bytes memory) {\n        bytes memory option = ExecutorOptions.encodeLzReadOption(_gas, _calldataSize, _value);\n        return addExecutorOption(_options, ExecutorOptions.OPTION_TYPE_LZREAD, option);\n    }\n\n    /**\n     * @dev Adds an executor native drop option to the existing options.\n     * @param _options The existing options container.\n     * @param _amount The amount for the native value that is airdropped to the 'receiver'.\n     * @param _receiver The receiver address for the native drop option.\n     * @return options The updated options container.\n     *\n     * @dev When multiples of this option are added, they are summed by the executor on the remote chain.\n     */\n    function addExecutorNativeDropOption(\n        bytes memory _options,\n        uint128 _amount,\n        bytes32 _receiver\n    ) internal pure onlyType3(_options) returns (bytes memory) {\n        bytes memory option = ExecutorOptions.encodeNativeDropOption(_amount, _receiver);\n        return addExecutorOption(_options, ExecutorOptions.OPTION_TYPE_NATIVE_DROP, option);\n    }\n\n    /**\n     * @dev Adds an executor LZ compose option to the existing options.\n     * @param _options The existing options container.\n     * @param _index The index for the lzCompose() function call.\n     * @param _gas The gasLimit for the lzCompose() function call.\n     * @param _value The msg.value for the lzCompose() function call.\n     * @return options The updated options container.\n     *\n     * @dev When multiples of this option are added, they are summed PER index by the executor on the remote chain.\n     * @dev If the OApp sends N lzCompose calls on the remote, you must provide N incremented indexes starting with 0.\n     * ie. When your remote OApp composes (N = 3) messages, you must set this option for index 0,1,2\n     */\n    function addExecutorLzComposeOption(\n        bytes memory _options,\n        uint16 _index,\n        uint128 _gas,\n        uint128 _value\n    ) internal pure onlyType3(_options) returns (bytes memory) {\n        bytes memory option = ExecutorOptions.encodeLzComposeOption(_index, _gas, _value);\n        return addExecutorOption(_options, ExecutorOptions.OPTION_TYPE_LZCOMPOSE, option);\n    }\n\n    /**\n     * @dev Adds an executor ordered execution option to the existing options.\n     * @param _options The existing options container.\n     * @return options The updated options container.\n     */\n    function addExecutorOrderedExecutionOption(\n        bytes memory _options\n    ) internal pure onlyType3(_options) returns (bytes memory) {\n        return addExecutorOption(_options, ExecutorOptions.OPTION_TYPE_ORDERED_EXECUTION, bytes(\"\"));\n    }\n\n    /**\n     * @dev Adds a DVN pre-crime option to the existing options.\n     * @param _options The existing options container.\n     * @param _dvnIdx The DVN index for the pre-crime option.\n     * @return options The updated options container.\n     */\n    function addDVNPreCrimeOption(\n        bytes memory _options,\n        uint8 _dvnIdx\n    ) internal pure onlyType3(_options) returns (bytes memory) {\n        return addDVNOption(_options, _dvnIdx, DVNOptions.OPTION_TYPE_PRECRIME, bytes(\"\"));\n    }\n\n    /**\n     * @dev Adds an executor option to the existing options.\n     * @param _options The existing options container.\n     * @param _optionType The type of the executor option.\n     * @param _option The encoded data for the executor option.\n     * @return options The updated options container.\n     */\n    function addExecutorOption(\n        bytes memory _options,\n        uint8 _optionType,\n        bytes memory _option\n    ) internal pure onlyType3(_options) returns (bytes memory) {\n        return\n            abi.encodePacked(\n                _options,\n                ExecutorOptions.WORKER_ID,\n                _option.length.toUint16() + 1, // +1 for optionType\n                _optionType,\n                _option\n            );\n    }\n\n    /**\n     * @dev Adds a DVN option to the existing options.\n     * @param _options The existing options container.\n     * @param _dvnIdx The DVN index for the DVN option.\n     * @param _optionType The type of the DVN option.\n     * @param _option The encoded data for the DVN option.\n     * @return options The updated options container.\n     */\n    function addDVNOption(\n        bytes memory _options,\n        uint8 _dvnIdx,\n        uint8 _optionType,\n        bytes memory _option\n    ) internal pure onlyType3(_options) returns (bytes memory) {\n        return\n            abi.encodePacked(\n                _options,\n                DVNOptions.WORKER_ID,\n                _option.length.toUint16() + 2, // +2 for optionType and dvnIdx\n                _dvnIdx,\n                _optionType,\n                _option\n            );\n    }\n\n    /**\n     * @dev Encodes legacy options of type 1.\n     * @param _executionGas The gasLimit value passed to lzReceive().\n     * @return legacyOptions The encoded legacy options.\n     */\n    function encodeLegacyOptionsType1(uint256 _executionGas) internal pure returns (bytes memory) {\n        if (_executionGas > type(uint128).max) revert InvalidSize(type(uint128).max, _executionGas);\n        return abi.encodePacked(TYPE_1, _executionGas);\n    }\n\n    /**\n     * @dev Encodes legacy options of type 2.\n     * @param _executionGas The gasLimit value passed to lzReceive().\n     * @param _nativeForDst The amount of native air dropped to the receiver.\n     * @param _receiver The _nativeForDst receiver address.\n     * @return legacyOptions The encoded legacy options of type 2.\n     */\n    function encodeLegacyOptionsType2(\n        uint256 _executionGas,\n        uint256 _nativeForDst,\n        bytes memory _receiver // @dev Use bytes instead of bytes32 in legacy type 2 for _receiver.\n    ) internal pure returns (bytes memory) {\n        if (_executionGas > type(uint128).max) revert InvalidSize(type(uint128).max, _executionGas);\n        if (_nativeForDst > type(uint128).max) revert InvalidSize(type(uint128).max, _nativeForDst);\n        if (_receiver.length > 32) revert InvalidSize(32, _receiver.length);\n        return abi.encodePacked(TYPE_2, _executionGas, _nativeForDst, _receiver);\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/libs/ReadCmdCodecV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nstruct EVMCallRequestV1 {\n    uint16 appRequestLabel; // Label identifying the application or type of request (can be use in lzCompute)\n    uint32 targetEid; // Target endpoint ID (representing a target blockchain)\n    bool isBlockNum; // True if the request = block number, false if timestamp\n    uint64 blockNumOrTimestamp; // Block number or timestamp to use in the request\n    uint16 confirmations; // Number of block confirmations on top of the requested block number or timestamp before the view function can be called\n    address to; // Address of the target contract on the target chain\n    bytes callData; // Calldata for the contract call\n}\n\nstruct EVMCallComputeV1 {\n    uint8 computeSetting; // Compute setting (0 = map only, 1 = reduce only, 2 = map reduce)\n    uint32 targetEid; // Target endpoint ID (representing a target blockchain)\n    bool isBlockNum; // True if the request = block number, false if timestamp\n    uint64 blockNumOrTimestamp; // Block number or timestamp to use in the request\n    uint16 confirmations; // Number of block confirmations on top of the requested block number or timestamp before the view function can be called\n    address to; // Address of the target contract on the target chain\n}\n\nlibrary ReadCmdCodecV1 {\n    using SafeCast for uint256;\n\n    uint16 internal constant CMD_VERSION = 1;\n\n    uint8 internal constant REQUEST_VERSION = 1;\n    uint16 internal constant RESOLVER_TYPE_SINGLE_VIEW_EVM_CALL = 1;\n\n    uint8 internal constant COMPUTE_VERSION = 1;\n    uint16 internal constant COMPUTE_TYPE_SINGLE_VIEW_EVM_CALL = 1;\n\n    error InvalidVersion();\n    error InvalidType();\n\n    function decode(\n        bytes calldata _cmd\n    )\n        internal\n        pure\n        returns (uint16 appCmdLabel, EVMCallRequestV1[] memory evmCallRequests, EVMCallComputeV1 memory compute)\n    {\n        uint256 offset = 0;\n        uint16 cmdVersion = uint16(bytes2(_cmd[offset:offset + 2]));\n        offset += 2;\n        if (cmdVersion != CMD_VERSION) revert InvalidVersion();\n\n        appCmdLabel = uint16(bytes2(_cmd[offset:offset + 2]));\n        offset += 2;\n\n        (evmCallRequests, offset) = decodeRequestsV1(_cmd, offset);\n\n        // decode the compute if it exists\n        if (offset < _cmd.length) {\n            (compute, ) = decodeEVMCallComputeV1(_cmd, offset);\n        }\n    }\n\n    function decodeRequestsV1(\n        bytes calldata _cmd,\n        uint256 _offset\n    ) internal pure returns (EVMCallRequestV1[] memory evmCallRequests, uint256 newOffset) {\n        newOffset = _offset;\n        uint16 requestCount = uint16(bytes2(_cmd[newOffset:newOffset + 2]));\n        newOffset += 2;\n\n        evmCallRequests = new EVMCallRequestV1[](requestCount);\n        for (uint16 i = 0; i < requestCount; i++) {\n            uint8 requestVersion = uint8(_cmd[newOffset]);\n            newOffset += 1;\n            if (requestVersion != REQUEST_VERSION) revert InvalidVersion();\n\n            uint16 appRequestLabel = uint16(bytes2(_cmd[newOffset:newOffset + 2]));\n            newOffset += 2;\n\n            uint16 resolverType = uint16(bytes2(_cmd[newOffset:newOffset + 2]));\n            newOffset += 2;\n\n            if (resolverType == RESOLVER_TYPE_SINGLE_VIEW_EVM_CALL) {\n                (EVMCallRequestV1 memory request, uint256 nextOffset) = decodeEVMCallRequestV1(\n                    _cmd,\n                    newOffset,\n                    appRequestLabel\n                );\n                newOffset = nextOffset;\n                evmCallRequests[i] = request;\n            } else {\n                revert InvalidType();\n            }\n        }\n    }\n\n    function decodeEVMCallRequestV1(\n        bytes calldata _cmd,\n        uint256 _offset,\n        uint16 _appRequestLabel\n    ) internal pure returns (EVMCallRequestV1 memory request, uint256 newOffset) {\n        newOffset = _offset;\n        request.appRequestLabel = _appRequestLabel;\n\n        uint16 requestSize = uint16(bytes2(_cmd[newOffset:newOffset + 2]));\n        newOffset += 2;\n        request.targetEid = uint32(bytes4(_cmd[newOffset:newOffset + 4]));\n        newOffset += 4;\n        request.isBlockNum = uint8(_cmd[newOffset]) == 1;\n        newOffset += 1;\n        request.blockNumOrTimestamp = uint64(bytes8(_cmd[newOffset:newOffset + 8]));\n        newOffset += 8;\n        request.confirmations = uint16(bytes2(_cmd[newOffset:newOffset + 2]));\n        newOffset += 2;\n        request.to = address(bytes20(_cmd[newOffset:newOffset + 20]));\n        newOffset += 20;\n        uint16 callDataSize = requestSize - 35;\n        request.callData = _cmd[newOffset:newOffset + callDataSize];\n        newOffset += callDataSize;\n    }\n\n    function decodeEVMCallComputeV1(\n        bytes calldata _cmd,\n        uint256 _offset\n    ) internal pure returns (EVMCallComputeV1 memory compute, uint256 newOffset) {\n        newOffset = _offset;\n        uint8 computeVersion = uint8(_cmd[newOffset]);\n        newOffset += 1;\n        if (computeVersion != COMPUTE_VERSION) revert InvalidVersion();\n        uint16 computeType = uint16(bytes2(_cmd[newOffset:newOffset + 2]));\n        newOffset += 2;\n        if (computeType != COMPUTE_TYPE_SINGLE_VIEW_EVM_CALL) revert InvalidType();\n\n        compute.computeSetting = uint8(_cmd[newOffset]);\n        newOffset += 1;\n        compute.targetEid = uint32(bytes4(_cmd[newOffset:newOffset + 4]));\n        newOffset += 4;\n        compute.isBlockNum = uint8(_cmd[newOffset]) == 1;\n        newOffset += 1;\n        compute.blockNumOrTimestamp = uint64(bytes8(_cmd[newOffset:newOffset + 8]));\n        newOffset += 8;\n        compute.confirmations = uint16(bytes2(_cmd[newOffset:newOffset + 2]));\n        newOffset += 2;\n        compute.to = address(bytes20(_cmd[newOffset:newOffset + 20]));\n        newOffset += 20;\n    }\n\n    function decodeCmdAppLabel(bytes calldata _cmd) internal pure returns (uint16) {\n        uint256 offset = 0;\n        uint16 cmdVersion = uint16(bytes2(_cmd[offset:offset + 2]));\n        offset += 2;\n        if (cmdVersion != CMD_VERSION) revert InvalidVersion();\n\n        return uint16(bytes2(_cmd[offset:offset + 2]));\n    }\n\n    function decodeRequestV1AppRequestLabel(bytes calldata _request) internal pure returns (uint16) {\n        uint256 offset = 0;\n        uint8 requestVersion = uint8(_request[offset]);\n        offset += 1;\n        if (requestVersion != REQUEST_VERSION) revert InvalidVersion();\n\n        return uint16(bytes2(_request[offset:offset + 2]));\n    }\n\n    function encode(\n        uint16 _appCmdLabel,\n        EVMCallRequestV1[] memory _evmCallRequests,\n        EVMCallComputeV1 memory _evmCallCompute\n    ) internal pure returns (bytes memory) {\n        bytes memory cmd = encode(_appCmdLabel, _evmCallRequests);\n        if (_evmCallCompute.targetEid != 0) {\n            // if eid is 0, it means no compute\n            cmd = appendEVMCallComputeV1(cmd, _evmCallCompute);\n        }\n        return cmd;\n    }\n\n    function encode(\n        uint16 _appCmdLabel,\n        EVMCallRequestV1[] memory _evmCallRequests\n    ) internal pure returns (bytes memory) {\n        bytes memory cmd = abi.encodePacked(CMD_VERSION, _appCmdLabel, _evmCallRequests.length.toUint16());\n        for (uint256 i = 0; i < _evmCallRequests.length; i++) {\n            cmd = appendEVMCallRequestV1(cmd, _evmCallRequests[i]);\n        }\n        return cmd;\n    }\n\n    // todo: optimize this with Buffer\n    function appendEVMCallRequestV1(\n        bytes memory _cmd,\n        EVMCallRequestV1 memory _request\n    ) internal pure returns (bytes memory) {\n        bytes memory newCmd = abi.encodePacked(\n            _cmd,\n            REQUEST_VERSION,\n            _request.appRequestLabel,\n            RESOLVER_TYPE_SINGLE_VIEW_EVM_CALL,\n            (_request.callData.length + 35).toUint16(),\n            _request.targetEid\n        );\n        return\n            abi.encodePacked(\n                newCmd,\n                _request.isBlockNum,\n                _request.blockNumOrTimestamp,\n                _request.confirmations,\n                _request.to,\n                _request.callData\n            );\n    }\n\n    function appendEVMCallComputeV1(\n        bytes memory _cmd,\n        EVMCallComputeV1 memory _compute\n    ) internal pure returns (bytes memory) {\n        return\n            abi.encodePacked(\n                _cmd,\n                COMPUTE_VERSION,\n                COMPUTE_TYPE_SINGLE_VIEW_EVM_CALL,\n                _compute.computeSetting,\n                _compute.targetEid,\n                _compute.isBlockNum,\n                _compute.blockNumOrTimestamp,\n                _compute.confirmations,\n                _compute.to\n            );\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/OApp.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\n// @dev Import the 'MessagingFee' and 'MessagingReceipt' so it's exposed to OApp implementers\n// solhint-disable-next-line no-unused-import\nimport { OAppSender, MessagingFee, MessagingReceipt } from \"./OAppSender.sol\";\n// @dev Import the 'Origin' so it's exposed to OApp implementers\n// solhint-disable-next-line no-unused-import\nimport { OAppReceiver, Origin } from \"./OAppReceiver.sol\";\nimport { OAppCore } from \"./OAppCore.sol\";\n\n/**\n * @title OApp\n * @dev Abstract contract serving as the base for OApp implementation, combining OAppSender and OAppReceiver functionality.\n */\nabstract contract OApp is OAppSender, OAppReceiver {\n    /**\n     * @dev Constructor to initialize the OApp with the provided endpoint and owner.\n     * @param _endpoint The address of the LOCAL LayerZero endpoint.\n     * @param _delegate The delegate capable of making OApp configurations inside of the endpoint.\n     */\n    constructor(address _endpoint, address _delegate) OAppCore(_endpoint, _delegate) {}\n\n    /**\n     * @notice Retrieves the OApp version information.\n     * @return senderVersion The version of the OAppSender.sol implementation.\n     * @return receiverVersion The version of the OAppReceiver.sol implementation.\n     */\n    function oAppVersion()\n        public\n        pure\n        virtual\n        override(OAppSender, OAppReceiver)\n        returns (uint64 senderVersion, uint64 receiverVersion)\n    {\n        return (SENDER_VERSION, RECEIVER_VERSION);\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/OAppCore.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { IOAppCore, ILayerZeroEndpointV2 } from \"./interfaces/IOAppCore.sol\";\n\n/**\n * @title OAppCore\n * @dev Abstract contract implementing the IOAppCore interface with basic OApp configurations.\n */\nabstract contract OAppCore is IOAppCore, Ownable {\n    // The LayerZero endpoint associated with the given OApp\n    ILayerZeroEndpointV2 public immutable endpoint;\n\n    // Mapping to store peers associated with corresponding endpoints\n    mapping(uint32 eid => bytes32 peer) public peers;\n\n    /**\n     * @dev Constructor to initialize the OAppCore with the provided endpoint and delegate.\n     * @param _endpoint The address of the LOCAL Layer Zero endpoint.\n     * @param _delegate The delegate capable of making OApp configurations inside of the endpoint.\n     *\n     * @dev The delegate typically should be set as the owner of the contract.\n     */\n    constructor(address _endpoint, address _delegate) {\n        endpoint = ILayerZeroEndpointV2(_endpoint);\n\n        if (_delegate == address(0)) revert InvalidDelegate();\n        endpoint.setDelegate(_delegate);\n    }\n\n    /**\n     * @notice Sets the peer address (OApp instance) for a corresponding endpoint.\n     * @param _eid The endpoint ID.\n     * @param _peer The address of the peer to be associated with the corresponding endpoint.\n     *\n     * @dev Only the owner/admin of the OApp can call this function.\n     * @dev Indicates that the peer is trusted to send LayerZero messages to this OApp.\n     * @dev Set this to bytes32(0) to remove the peer address.\n     * @dev Peer is a bytes32 to accommodate non-evm chains.\n     */\n    function setPeer(uint32 _eid, bytes32 _peer) public virtual onlyOwner {\n        _setPeer(_eid, _peer);\n    }\n\n    /**\n     * @notice Sets the peer address (OApp instance) for a corresponding endpoint.\n     * @param _eid The endpoint ID.\n     * @param _peer The address of the peer to be associated with the corresponding endpoint.\n     *\n     * @dev Indicates that the peer is trusted to send LayerZero messages to this OApp.\n     * @dev Set this to bytes32(0) to remove the peer address.\n     * @dev Peer is a bytes32 to accommodate non-evm chains.\n     */\n    function _setPeer(uint32 _eid, bytes32 _peer) internal virtual {\n        peers[_eid] = _peer;\n        emit PeerSet(_eid, _peer);\n    }\n\n    /**\n     * @notice Internal function to get the peer address associated with a specific endpoint; reverts if NOT set.\n     * ie. the peer is set to bytes32(0).\n     * @param _eid The endpoint ID.\n     * @return peer The address of the peer associated with the specified endpoint.\n     */\n    function _getPeerOrRevert(uint32 _eid) internal view virtual returns (bytes32) {\n        bytes32 peer = peers[_eid];\n        if (peer == bytes32(0)) revert NoPeer(_eid);\n        return peer;\n    }\n\n    /**\n     * @notice Sets the delegate address for the OApp.\n     * @param _delegate The address of the delegate to be set.\n     *\n     * @dev Only the owner/admin of the OApp can call this function.\n     * @dev Provides the ability for a delegate to set configs, on behalf of the OApp, directly on the Endpoint contract.\n     */\n    function setDelegate(address _delegate) public onlyOwner {\n        endpoint.setDelegate(_delegate);\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/OAppRead.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { AddressCast } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/libs/AddressCast.sol\";\n\nimport { OApp } from \"./OApp.sol\";\n\nabstract contract OAppRead is OApp {\n\n    constructor(address _endpoint, address _delegate) OApp(_endpoint, _delegate) {}\n\n    // -------------------------------\n    // Only Owner\n    function setReadChannel(uint32 _channelId, bool _active) public virtual onlyOwner {\n        _setPeer(_channelId, _active ? AddressCast.toBytes32(address(this)) : bytes32(0));\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/OAppReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { IOAppReceiver, Origin } from \"./interfaces/IOAppReceiver.sol\";\nimport { OAppCore } from \"./OAppCore.sol\";\n\n/**\n * @title OAppReceiver\n * @dev Abstract contract implementing the ILayerZeroReceiver interface and extending OAppCore for OApp receivers.\n */\nabstract contract OAppReceiver is IOAppReceiver, OAppCore {\n    // Custom error message for when the caller is not the registered endpoint/\n    error OnlyEndpoint(address addr);\n\n    // @dev The version of the OAppReceiver implementation.\n    // @dev Version is bumped when changes are made to this contract.\n    uint64 internal constant RECEIVER_VERSION = 2;\n\n    /**\n     * @notice Retrieves the OApp version information.\n     * @return senderVersion The version of the OAppSender.sol contract.\n     * @return receiverVersion The version of the OAppReceiver.sol contract.\n     *\n     * @dev Providing 0 as the default for OAppSender version. Indicates that the OAppSender is not implemented.\n     * ie. this is a RECEIVE only OApp.\n     * @dev If the OApp uses both OAppSender and OAppReceiver, then this needs to be override returning the correct versions.\n     */\n    function oAppVersion() public view virtual returns (uint64 senderVersion, uint64 receiverVersion) {\n        return (0, RECEIVER_VERSION);\n    }\n\n    /**\n     * @notice Indicates whether an address is an approved composeMsg sender to the Endpoint.\n     * @dev _origin The origin information containing the source endpoint and sender address.\n     *  - srcEid: The source chain endpoint ID.\n     *  - sender: The sender address on the src chain.\n     *  - nonce: The nonce of the message.\n     * @dev _message The lzReceive payload.\n     * @param _sender The sender address.\n     * @return isSender Is a valid sender.\n     *\n     * @dev Applications can optionally choose to implement separate composeMsg senders that are NOT the bridging layer.\n     * @dev The default sender IS the OAppReceiver implementer.\n     */\n    function isComposeMsgSender(\n        Origin calldata /*_origin*/,\n        bytes calldata /*_message*/,\n        address _sender\n    ) public view virtual returns (bool) {\n        return _sender == address(this);\n    }\n\n    /**\n     * @notice Checks if the path initialization is allowed based on the provided origin.\n     * @param origin The origin information containing the source endpoint and sender address.\n     * @return Whether the path has been initialized.\n     *\n     * @dev This indicates to the endpoint that the OApp has enabled msgs for this particular path to be received.\n     * @dev This defaults to assuming if a peer has been set, its initialized.\n     * Can be overridden by the OApp if there is other logic to determine this.\n     */\n    function allowInitializePath(Origin calldata origin) public view virtual returns (bool) {\n        return peers[origin.srcEid] == origin.sender;\n    }\n\n    /**\n     * @notice Retrieves the next nonce for a given source endpoint and sender address.\n     * @dev _srcEid The source endpoint ID.\n     * @dev _sender The sender address.\n     * @return nonce The next nonce.\n     *\n     * @dev The path nonce starts from 1. If 0 is returned it means that there is NO nonce ordered enforcement.\n     * @dev Is required by the off-chain executor to determine the OApp expects msg execution is ordered.\n     * @dev This is also enforced by the OApp.\n     * @dev By default this is NOT enabled. ie. nextNonce is hardcoded to return 0.\n     */\n    function nextNonce(uint32 /*_srcEid*/, bytes32 /*_sender*/) public view virtual returns (uint64 nonce) {\n        return 0;\n    }\n\n    /**\n     * @dev Entry point for receiving messages or packets from the endpoint.\n     * @param _origin The origin information containing the source endpoint and sender address.\n     *  - srcEid: The source chain endpoint ID.\n     *  - sender: The sender address on the src chain.\n     *  - nonce: The nonce of the message.\n     * @param _guid The unique identifier for the received LayerZero message.\n     * @param _message The payload of the received message.\n     * @param _executor The address of the executor for the received message.\n     * @param _extraData Additional arbitrary data provided by the corresponding executor.\n     *\n     * @dev Entry point for receiving msg/packet from the LayerZero endpoint.\n     */\n    function lzReceive(\n        Origin calldata _origin,\n        bytes32 _guid,\n        bytes calldata _message,\n        address _executor,\n        bytes calldata _extraData\n    ) public payable virtual {\n        // Ensures that only the endpoint can attempt to lzReceive() messages to this OApp.\n        if (address(endpoint) != msg.sender) revert OnlyEndpoint(msg.sender);\n\n        // Ensure that the sender matches the expected peer for the source endpoint.\n        if (_getPeerOrRevert(_origin.srcEid) != _origin.sender) revert OnlyPeer(_origin.srcEid, _origin.sender);\n\n        // Call the internal OApp implementation of lzReceive.\n        _lzReceive(_origin, _guid, _message, _executor, _extraData);\n    }\n\n    /**\n     * @dev Internal function to implement lzReceive logic without needing to copy the basic parameter validation.\n     */\n    function _lzReceive(\n        Origin calldata _origin,\n        bytes32 _guid,\n        bytes calldata _message,\n        address _executor,\n        bytes calldata _extraData\n    ) internal virtual;\n}\n"
    },
    "@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/OAppSender.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { SafeERC20, IERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { MessagingParams, MessagingFee, MessagingReceipt } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol\";\nimport { OAppCore } from \"./OAppCore.sol\";\n\n/**\n * @title OAppSender\n * @dev Abstract contract implementing the OAppSender functionality for sending messages to a LayerZero endpoint.\n */\nabstract contract OAppSender is OAppCore {\n    using SafeERC20 for IERC20;\n\n    // Custom error messages\n    error NotEnoughNative(uint256 msgValue);\n    error LzTokenUnavailable();\n\n    // @dev The version of the OAppSender implementation.\n    // @dev Version is bumped when changes are made to this contract.\n    uint64 internal constant SENDER_VERSION = 1;\n\n    /**\n     * @notice Retrieves the OApp version information.\n     * @return senderVersion The version of the OAppSender.sol contract.\n     * @return receiverVersion The version of the OAppReceiver.sol contract.\n     *\n     * @dev Providing 0 as the default for OAppReceiver version. Indicates that the OAppReceiver is not implemented.\n     * ie. this is a SEND only OApp.\n     * @dev If the OApp uses both OAppSender and OAppReceiver, then this needs to be override returning the correct versions\n     */\n    function oAppVersion() public view virtual returns (uint64 senderVersion, uint64 receiverVersion) {\n        return (SENDER_VERSION, 0);\n    }\n\n    /**\n     * @dev Internal function to interact with the LayerZero EndpointV2.quote() for fee calculation.\n     * @param _dstEid The destination endpoint ID.\n     * @param _message The message payload.\n     * @param _options Additional options for the message.\n     * @param _payInLzToken Flag indicating whether to pay the fee in LZ tokens.\n     * @return fee The calculated MessagingFee for the message.\n     *      - nativeFee: The native fee for the message.\n     *      - lzTokenFee: The LZ token fee for the message.\n     */\n    function _quote(\n        uint32 _dstEid,\n        bytes memory _message,\n        bytes memory _options,\n        bool _payInLzToken\n    ) internal view virtual returns (MessagingFee memory fee) {\n        return\n            endpoint.quote(\n                MessagingParams(_dstEid, _getPeerOrRevert(_dstEid), _message, _options, _payInLzToken),\n                address(this)\n            );\n    }\n\n    /**\n     * @dev Internal function to interact with the LayerZero EndpointV2.send() for sending a message.\n     * @param _dstEid The destination endpoint ID.\n     * @param _message The message payload.\n     * @param _options Additional options for the message.\n     * @param _fee The calculated LayerZero fee for the message.\n     *      - nativeFee: The native fee.\n     *      - lzTokenFee: The lzToken fee.\n     * @param _refundAddress The address to receive any excess fee values sent to the endpoint.\n     * @return receipt The receipt for the sent message.\n     *      - guid: The unique identifier for the sent message.\n     *      - nonce: The nonce of the sent message.\n     *      - fee: The LayerZero fee incurred for the message.\n     */\n    function _lzSend(\n        uint32 _dstEid,\n        bytes memory _message,\n        bytes memory _options,\n        MessagingFee memory _fee,\n        address _refundAddress\n    ) internal virtual returns (MessagingReceipt memory receipt) {\n        // @dev Push corresponding fees to the endpoint, any excess is sent back to the _refundAddress from the endpoint.\n        uint256 messageValue = _payNative(_fee.nativeFee);\n        if (_fee.lzTokenFee > 0) _payLzToken(_fee.lzTokenFee);\n\n        return\n            // solhint-disable-next-line check-send-result\n            endpoint.send{ value: messageValue }(\n                MessagingParams(_dstEid, _getPeerOrRevert(_dstEid), _message, _options, _fee.lzTokenFee > 0),\n                _refundAddress\n            );\n    }\n\n    /**\n     * @dev Internal function to pay the native fee associated with the message.\n     * @param _nativeFee The native fee to be paid.\n     * @return nativeFee The amount of native currency paid.\n     *\n     * @dev If the OApp needs to initiate MULTIPLE LayerZero messages in a single transaction,\n     * this will need to be overridden because msg.value would contain multiple lzFees.\n     * @dev Should be overridden in the event the LayerZero endpoint requires a different native currency.\n     * @dev Some EVMs use an ERC20 as a method for paying transactions/gasFees.\n     * @dev The endpoint is EITHER/OR, ie. it will NOT support both types of native payment at a time.\n     */\n    function _payNative(uint256 _nativeFee) internal virtual returns (uint256 nativeFee) {\n        if (msg.value != _nativeFee) revert NotEnoughNative(msg.value);\n        return _nativeFee;\n    }\n\n    /**\n     * @dev Internal function to pay the LZ token fee associated with the message.\n     * @param _lzTokenFee The LZ token fee to be paid.\n     *\n     * @dev If the caller is trying to pay in the specified lzToken, then the lzTokenFee is passed to the endpoint.\n     * @dev Any excess sent, is passed back to the specified _refundAddress in the _lzSend().\n     */\n    function _payLzToken(uint256 _lzTokenFee) internal virtual {\n        // @dev Cannot cache the token because it is not immutable in the endpoint.\n        address lzToken = endpoint.lzToken();\n        if (lzToken == address(0)) revert LzTokenUnavailable();\n\n        // Pay LZ token fee by sending tokens to the endpoint.\n        IERC20(lzToken).safeTransferFrom(msg.sender, address(endpoint), _lzTokenFee);\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nimport { IMessageLibManager } from \"./IMessageLibManager.sol\";\nimport { IMessagingComposer } from \"./IMessagingComposer.sol\";\nimport { IMessagingChannel } from \"./IMessagingChannel.sol\";\nimport { IMessagingContext } from \"./IMessagingContext.sol\";\n\nstruct MessagingParams {\n    uint32 dstEid;\n    bytes32 receiver;\n    bytes message;\n    bytes options;\n    bool payInLzToken;\n}\n\nstruct MessagingReceipt {\n    bytes32 guid;\n    uint64 nonce;\n    MessagingFee fee;\n}\n\nstruct MessagingFee {\n    uint256 nativeFee;\n    uint256 lzTokenFee;\n}\n\nstruct Origin {\n    uint32 srcEid;\n    bytes32 sender;\n    uint64 nonce;\n}\n\ninterface ILayerZeroEndpointV2 is IMessageLibManager, IMessagingComposer, IMessagingChannel, IMessagingContext {\n    event PacketSent(bytes encodedPayload, bytes options, address sendLibrary);\n\n    event PacketVerified(Origin origin, address receiver, bytes32 payloadHash);\n\n    event PacketDelivered(Origin origin, address receiver);\n\n    event LzReceiveAlert(\n        address indexed receiver,\n        address indexed executor,\n        Origin origin,\n        bytes32 guid,\n        uint256 gas,\n        uint256 value,\n        bytes message,\n        bytes extraData,\n        bytes reason\n    );\n\n    event LzTokenSet(address token);\n\n    event DelegateSet(address sender, address delegate);\n\n    function quote(MessagingParams calldata _params, address _sender) external view returns (MessagingFee memory);\n\n    function send(\n        MessagingParams calldata _params,\n        address _refundAddress\n    ) external payable returns (MessagingReceipt memory);\n\n    function verify(Origin calldata _origin, address _receiver, bytes32 _payloadHash) external;\n\n    function verifiable(Origin calldata _origin, address _receiver) external view returns (bool);\n\n    function initializable(Origin calldata _origin, address _receiver) external view returns (bool);\n\n    function lzReceive(\n        Origin calldata _origin,\n        address _receiver,\n        bytes32 _guid,\n        bytes calldata _message,\n        bytes calldata _extraData\n    ) external payable;\n\n    // oapp can burn messages partially by calling this function with its own business logic if messages are verified in order\n    function clear(address _oapp, Origin calldata _origin, bytes32 _guid, bytes calldata _message) external;\n\n    function setLzToken(address _lzToken) external;\n\n    function lzToken() external view returns (address);\n\n    function nativeToken() external view returns (address);\n\n    function setDelegate(address _delegate) external;\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nimport { Origin } from \"./ILayerZeroEndpointV2.sol\";\n\ninterface ILayerZeroReceiver {\n    function allowInitializePath(Origin calldata _origin) external view returns (bool);\n\n    function nextNonce(uint32 _eid, bytes32 _sender) external view returns (uint64);\n\n    function lzReceive(\n        Origin calldata _origin,\n        bytes32 _guid,\n        bytes calldata _message,\n        address _executor,\n        bytes calldata _extraData\n    ) external payable;\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessageLibManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nstruct SetConfigParam {\n    uint32 eid;\n    uint32 configType;\n    bytes config;\n}\n\ninterface IMessageLibManager {\n    struct Timeout {\n        address lib;\n        uint256 expiry;\n    }\n\n    event LibraryRegistered(address newLib);\n    event DefaultSendLibrarySet(uint32 eid, address newLib);\n    event DefaultReceiveLibrarySet(uint32 eid, address newLib);\n    event DefaultReceiveLibraryTimeoutSet(uint32 eid, address oldLib, uint256 expiry);\n    event SendLibrarySet(address sender, uint32 eid, address newLib);\n    event ReceiveLibrarySet(address receiver, uint32 eid, address newLib);\n    event ReceiveLibraryTimeoutSet(address receiver, uint32 eid, address oldLib, uint256 timeout);\n\n    function registerLibrary(address _lib) external;\n\n    function isRegisteredLibrary(address _lib) external view returns (bool);\n\n    function getRegisteredLibraries() external view returns (address[] memory);\n\n    function setDefaultSendLibrary(uint32 _eid, address _newLib) external;\n\n    function defaultSendLibrary(uint32 _eid) external view returns (address);\n\n    function setDefaultReceiveLibrary(uint32 _eid, address _newLib, uint256 _gracePeriod) external;\n\n    function defaultReceiveLibrary(uint32 _eid) external view returns (address);\n\n    function setDefaultReceiveLibraryTimeout(uint32 _eid, address _lib, uint256 _expiry) external;\n\n    function defaultReceiveLibraryTimeout(uint32 _eid) external view returns (address lib, uint256 expiry);\n\n    function isSupportedEid(uint32 _eid) external view returns (bool);\n\n    function isValidReceiveLibrary(address _receiver, uint32 _eid, address _lib) external view returns (bool);\n\n    /// ------------------- OApp interfaces -------------------\n    function setSendLibrary(address _oapp, uint32 _eid, address _newLib) external;\n\n    function getSendLibrary(address _sender, uint32 _eid) external view returns (address lib);\n\n    function isDefaultSendLibrary(address _sender, uint32 _eid) external view returns (bool);\n\n    function setReceiveLibrary(address _oapp, uint32 _eid, address _newLib, uint256 _gracePeriod) external;\n\n    function getReceiveLibrary(address _receiver, uint32 _eid) external view returns (address lib, bool isDefault);\n\n    function setReceiveLibraryTimeout(address _oapp, uint32 _eid, address _lib, uint256 _expiry) external;\n\n    function receiveLibraryTimeout(address _receiver, uint32 _eid) external view returns (address lib, uint256 expiry);\n\n    function setConfig(address _oapp, address _lib, SetConfigParam[] calldata _params) external;\n\n    function getConfig(\n        address _oapp,\n        address _lib,\n        uint32 _eid,\n        uint32 _configType\n    ) external view returns (bytes memory config);\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessagingChannel.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\ninterface IMessagingChannel {\n    event InboundNonceSkipped(uint32 srcEid, bytes32 sender, address receiver, uint64 nonce);\n    event PacketNilified(uint32 srcEid, bytes32 sender, address receiver, uint64 nonce, bytes32 payloadHash);\n    event PacketBurnt(uint32 srcEid, bytes32 sender, address receiver, uint64 nonce, bytes32 payloadHash);\n\n    function eid() external view returns (uint32);\n\n    // this is an emergency function if a message cannot be verified for some reasons\n    // required to provide _nextNonce to avoid race condition\n    function skip(address _oapp, uint32 _srcEid, bytes32 _sender, uint64 _nonce) external;\n\n    function nilify(address _oapp, uint32 _srcEid, bytes32 _sender, uint64 _nonce, bytes32 _payloadHash) external;\n\n    function burn(address _oapp, uint32 _srcEid, bytes32 _sender, uint64 _nonce, bytes32 _payloadHash) external;\n\n    function nextGuid(address _sender, uint32 _dstEid, bytes32 _receiver) external view returns (bytes32);\n\n    function inboundNonce(address _receiver, uint32 _srcEid, bytes32 _sender) external view returns (uint64);\n\n    function outboundNonce(address _sender, uint32 _dstEid, bytes32 _receiver) external view returns (uint64);\n\n    function inboundPayloadHash(\n        address _receiver,\n        uint32 _srcEid,\n        bytes32 _sender,\n        uint64 _nonce\n    ) external view returns (bytes32);\n\n    function lazyInboundNonce(address _receiver, uint32 _srcEid, bytes32 _sender) external view returns (uint64);\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessagingComposer.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\ninterface IMessagingComposer {\n    event ComposeSent(address from, address to, bytes32 guid, uint16 index, bytes message);\n    event ComposeDelivered(address from, address to, bytes32 guid, uint16 index);\n    event LzComposeAlert(\n        address indexed from,\n        address indexed to,\n        address indexed executor,\n        bytes32 guid,\n        uint16 index,\n        uint256 gas,\n        uint256 value,\n        bytes message,\n        bytes extraData,\n        bytes reason\n    );\n\n    function composeQueue(\n        address _from,\n        address _to,\n        bytes32 _guid,\n        uint16 _index\n    ) external view returns (bytes32 messageHash);\n\n    function sendCompose(address _to, bytes32 _guid, uint16 _index, bytes calldata _message) external;\n\n    function lzCompose(\n        address _from,\n        address _to,\n        bytes32 _guid,\n        uint16 _index,\n        bytes calldata _message,\n        bytes calldata _extraData\n    ) external payable;\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessagingContext.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\ninterface IMessagingContext {\n    function isSendingMessage() external view returns (bool);\n\n    function getSendContext() external view returns (uint32 dstEid, address sender);\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/libs/AddressCast.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nlibrary AddressCast {\n    error AddressCast_InvalidSizeForAddress();\n    error AddressCast_InvalidAddress();\n\n    function toBytes32(bytes calldata _addressBytes) internal pure returns (bytes32 result) {\n        if (_addressBytes.length > 32) revert AddressCast_InvalidAddress();\n        result = bytes32(_addressBytes);\n        unchecked {\n            uint256 offset = 32 - _addressBytes.length;\n            result = result >> (offset * 8);\n        }\n    }\n\n    function toBytes32(address _address) internal pure returns (bytes32 result) {\n        result = bytes32(uint256(uint160(_address)));\n    }\n\n    function toBytes(bytes32 _addressBytes32, uint256 _size) internal pure returns (bytes memory result) {\n        if (_size == 0 || _size > 32) revert AddressCast_InvalidSizeForAddress();\n        result = new bytes(_size);\n        unchecked {\n            uint256 offset = 256 - _size * 8;\n            assembly {\n                mstore(add(result, 32), shl(offset, _addressBytes32))\n            }\n        }\n    }\n\n    function toAddress(bytes32 _addressBytes32) internal pure returns (address result) {\n        result = address(uint160(uint256(_addressBytes32)));\n    }\n\n    function toAddress(bytes calldata _addressBytes) internal pure returns (address result) {\n        if (_addressBytes.length != 20) revert AddressCast_InvalidAddress();\n        result = address(bytes20(_addressBytes));\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/libs/CalldataBytesLib.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nlibrary CalldataBytesLib {\n    function toU8(bytes calldata _bytes, uint256 _start) internal pure returns (uint8) {\n        return uint8(_bytes[_start]);\n    }\n\n    function toU16(bytes calldata _bytes, uint256 _start) internal pure returns (uint16) {\n        unchecked {\n            uint256 end = _start + 2;\n            return uint16(bytes2(_bytes[_start:end]));\n        }\n    }\n\n    function toU32(bytes calldata _bytes, uint256 _start) internal pure returns (uint32) {\n        unchecked {\n            uint256 end = _start + 4;\n            return uint32(bytes4(_bytes[_start:end]));\n        }\n    }\n\n    function toU64(bytes calldata _bytes, uint256 _start) internal pure returns (uint64) {\n        unchecked {\n            uint256 end = _start + 8;\n            return uint64(bytes8(_bytes[_start:end]));\n        }\n    }\n\n    function toU128(bytes calldata _bytes, uint256 _start) internal pure returns (uint128) {\n        unchecked {\n            uint256 end = _start + 16;\n            return uint128(bytes16(_bytes[_start:end]));\n        }\n    }\n\n    function toU256(bytes calldata _bytes, uint256 _start) internal pure returns (uint256) {\n        unchecked {\n            uint256 end = _start + 32;\n            return uint256(bytes32(_bytes[_start:end]));\n        }\n    }\n\n    function toAddr(bytes calldata _bytes, uint256 _start) internal pure returns (address) {\n        unchecked {\n            uint256 end = _start + 20;\n            return address(bytes20(_bytes[_start:end]));\n        }\n    }\n\n    function toB32(bytes calldata _bytes, uint256 _start) internal pure returns (bytes32) {\n        unchecked {\n            uint256 end = _start + 32;\n            return bytes32(_bytes[_start:end]);\n        }\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/BitMaps.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// modified from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/structs/BitMaps.sol\npragma solidity ^0.8.20;\n\ntype BitMap256 is uint256;\n\nusing BitMaps for BitMap256 global;\n\nlibrary BitMaps {\n    /**\n     * @dev Returns whether the bit at `index` is set.\n     */\n    function get(BitMap256 bitmap, uint8 index) internal pure returns (bool) {\n        uint256 mask = 1 << index;\n        return BitMap256.unwrap(bitmap) & mask != 0;\n    }\n\n    /**\n     * @dev Sets the bit at `index`.\n     */\n    function set(BitMap256 bitmap, uint8 index) internal pure returns (BitMap256) {\n        uint256 mask = 1 << index;\n        return BitMap256.wrap(BitMap256.unwrap(bitmap) | mask);\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.20;\n\nimport {IAccessControl} from \"./IAccessControl.sol\";\nimport {Context} from \"../utils/Context.sol\";\nimport {ERC165} from \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 role => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        return _roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (!hasRole(role, account)) {\n            _roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` from `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (hasRole(role, account)) {\n            _roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (access/IAccessControl.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev External interface of AccessControl declared to support ERC-165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted to signal this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call. This account bears the admin role (for the granted role).\n     * Expected in cases where the role was granted using the internal {AccessControl-_grantRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC1363.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (interfaces/IERC1363.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @title IERC1363\n * @dev Interface of the ERC-1363 standard as defined in the https://eips.ethereum.org/EIPS/eip-1363[ERC-1363].\n *\n * Defines an extension interface for ERC-20 tokens that supports executing code on a recipient contract\n * after `transfer` or `transferFrom`, or code on a spender contract after `approve`, in a single transaction.\n */\ninterface IERC1363 is IERC20, IERC165 {\n    /*\n     * Note: the ERC-165 identifier for this interface is 0xb0202a11.\n     * 0xb0202a11 ===\n     *   bytes4(keccak256('transferAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))\n     */\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @param data Additional data with no specified format, sent in call to `spender`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value, bytes calldata data) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../utils/introspection/IERC165.sol\";\n"
    },
    "@openzeppelin/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../token/ERC20/IERC20.sol\";\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC1363} from \"../../../interfaces/IERC1363.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC-20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    /**\n     * @dev An operation with an ERC-20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Variant of {safeTransfer} that returns a bool instead of reverting if the operation is not successful.\n     */\n    function trySafeTransfer(IERC20 token, address to, uint256 value) internal returns (bool) {\n        return _callOptionalReturnBool(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Variant of {safeTransferFrom} that returns a bool instead of reverting if the operation is not successful.\n     */\n    function trySafeTransferFrom(IERC20 token, address from, address to, uint256 value) internal returns (bool) {\n        return _callOptionalReturnBool(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     *\n     * NOTE: If the token implements ERC-7674, this function will not modify any temporary allowance. This function\n     * only sets the \"standard\" allowance. Any temporary allowance will remain active, in addition to the value being\n     * set here.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferAndCall, with a fallback to the simple {ERC20} transfer if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            safeTransfer(token, to, value);\n        } else if (!token.transferAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferFromAndCall, with a fallback to the simple {ERC20} transferFrom if the target\n     * has no code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferFromAndCallRelaxed(\n        IERC1363 token,\n        address from,\n        address to,\n        uint256 value,\n        bytes memory data\n    ) internal {\n        if (to.code.length == 0) {\n            safeTransferFrom(token, from, to, value);\n        } else if (!token.transferFromAndCall(from, to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} approveAndCall, with a fallback to the simple {ERC20} approve if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * NOTE: When the recipient address (`to`) has no code (i.e. is an EOA), this function behaves as {forceApprove}.\n     * Opposedly, when the recipient address (`to`) has code, this function only attempts to call {ERC1363-approveAndCall}\n     * once without retrying, and relies on the returned value to be true.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function approveAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            forceApprove(token, to, value);\n        } else if (!token.approveAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturnBool} that reverts if call fails to meet the requirements.\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            let success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            // bubble errors\n            if iszero(success) {\n                let ptr := mload(0x40)\n                returndatacopy(ptr, 0, returndatasize())\n                revert(ptr, returndatasize())\n            }\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n\n        if (returnSize == 0 ? address(token).code.length == 0 : returnValue != 1) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silently catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n        return success && (returnSize == 0 ? address(token).code.length > 0 : returnValue == 1);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC-721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC-721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or\n     *   {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC-721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the address zero.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC-165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX/bool casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value > type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value > type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value > type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value > type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value > type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value > type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value > type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value > type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value > type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value > type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value > type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value > type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value > type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value > type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value > type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value > type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value > type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value > type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value > type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value > type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value > type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value > type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value > type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value > type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value > type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value > type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value > type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value > type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value > type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value > type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value > type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value < 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value > uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n\n    /**\n     * @dev Cast a boolean (false or true) to a uint256 (0 or 1) with no jump.\n     */\n    function toUint(bool b) internal pure returns (uint256 u) {\n        assembly (\"memory-safe\") {\n            u := iszero(iszero(b))\n        }\n    }\n}\n"
    },
    "contracts/apechain/Beacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.29;\n\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {\n    ILayerZeroEndpointV2,\n    MessagingFee,\n    MessagingReceipt,\n    Origin\n} from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol\";\nimport {\n    ReadCmdCodecV1,\n    EVMCallComputeV1,\n    EVMCallRequestV1\n} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/libs/ReadCmdCodecV1.sol\";\nimport {OAppRead} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/OAppRead.sol\";\nimport {OAppOptionsType3} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/libs/OAppOptionsType3.sol\";\nimport {OptionsBuilder} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/libs/OptionsBuilder.sol\";\nimport {AddressCast} from \"@layerzerolabs/lz-evm-protocol-v2/contracts/libs/AddressCast.sol\";\n\nimport {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {LibMap} from \"solady/src/utils/LibMap.sol\";\n\nimport {IExclusiveDelegateResolver} from \"./interfaces/IExclusiveDelegateResolver.sol\";\nimport {IDelegateRegistry} from \"./interfaces/IDelegateRegistry.sol\";\n\nimport {INFTShadow} from \"./interfaces/INFTShadow.sol\";\n\nimport {IOAppComputerMap} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/interfaces/IOAppComputerMap.sol\";\nimport {IOAppComputerReduce} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/interfaces/IOAppComputerReduce.sol\";\n\nimport {SafeCall} from \"./utils/SafeCall.sol\";\n\nimport {CollectionConfig} from \"./structs/CollectionConfig.sol\";\n\nimport {ILayerZeroEndpointLocator} from \"./interfaces/ILayerZeroEndpointLocator.sol\";\n\n/**\n * @notice The Beacon contract is responsible for managing the ownership of NFTs across multiple chains.\n * It uses LayerZero's OApp protocol to send messages between chains and maintain ownership records.\n * \n * @dev This contract is based on the implementation at:\n *      https://apescan.io/address/0x00000000000087c6dbaDC090d39BC10316f20658\n * \n * @dev Uses interfaces from the original implementation:\n *      - IDelegateRegistry (CC0-1.0) by foobar (0xfoobar)\n *      - IExclusiveDelegateResolver (MIT)\n *      - ILayerZeroEndpointLocator (MIT)\n *      - INFTShadow (MIT)\n */\ncontract Beacon is OAppRead, OAppOptionsType3, IOAppComputerMap, IOAppComputerReduce, AccessControl {\n    using OptionsBuilder for bytes;\n    using AddressCast for bytes32;\n    using AddressCast for address;\n    using SafeCall for address;\n    using LibMap for LibMap.Uint32Map;\n\n    // The provided contract address is not configured\n    error ContractNotConfigured();\n\n    // The shadow contract has already been deployed\n    error CollectionAlreadyRegistered();\n\n    // The provided endpoint ID matches this contract's eid\n    error InvalidEid();\n\n    // The caller is not the shadow contract\n    error InvalidCaller();\n\n    // The caller is not the contract itself\n    error OnlyInternalCalls();\n\n    // The payload hash does not match the expected hash\n    error InvalidPayloadHash();\n\n    // The beneficiary is the zero address\n    error BeneficiaryZeroAddress();\n\n    // The read channel is under the threshold\n    error InvalidReadChannel();\n\n    // The chain ID is invalid (zero)\n    error InvalidChain();\n\n    // The collection address is zero\n    error ZeroAddress();\n\n    // The array is empty\n    error ZeroLengthArray();\n\n    // The collection address and base collection address do not match\n    error MismatchedCollectionAddress();\n\n    // The maximum gas allocation for lzReceive has been exceeded\n    error MaxLzReceiveGasAllocationExceeded();\n\n    // lzRead returned an invalid state\n    error InvalidOwner();\n\n    // The executor is not allowed\n    error UnauthorizedExecutor();\n\n    // The read request has timed out\n    error StaleReadRequest();\n\n    // The transfer failed\n    error TransferFailed();\n\n    // The burn failed\n    error BurnFailed();\n\n    // The mint failed\n    error MintFailed();\n\n    // The unlock failed\n    error UnlockFailed();\n\n    // The collection is not in shadow mode\n    error CollectionNotInShadowMode();\n\n    // Emitted each time a collection is registered on this Beacon\n    event Sent(\n        uint32 indexed eid,\n        address indexed baseCollectionAddress,\n        address indexed collection,\n        uint256[] tokenIds,\n        address beneficiary\n    );\n\n    // Emitted each time an ownership update is triggered\n    event ReadTriggered(\n        address indexed baseCollectionAddress,\n        address indexed shadowCollectionAddress,\n        uint32[] eids,\n        uint256[] tokenIds\n    );\n\n    // Emitted once for each collection registered on this Beacon\n    event CollectionRegistered(\n        address indexed collectionAddress, address indexed baseCollectionAddress, uint32 indexed baseCollectionEid\n    );\n\n    // Emitted when a message fails and ends up in the cache\n    event MessageCached(uint32 indexed srcEid, bytes32 indexed sender, uint64 nonce, bytes reason);\n\n    // Emitted when a cached message is executed\n    event CachedMessageExecuted(uint32 indexed srcEid, bytes32 indexed sender, uint64 nonce);\n\n    // Emitted when the execution enforcement is set\n    event EnforceExecutionSet(bool enforceExecutors);\n\n    // Emitted when an executor is allowed or disallowed\n    event AllowedExecutorSet(address executor, bool allowed);\n\n    // Emitted when the required confirmations for an EID are set\n    event RequiredConfirmationsSet(uint32 eid, uint16 confirmations);\n\n    // Emitted when the read channel is set\n    event ReadChannelSet(uint32 readChannel);\n\n    // Constants for SafeCall\n    uint256 private constant _SAFE_CALL_BUFFER = 50_000;\n\n    // costs used for generating LZRead options\n    uint128 private constant _DELEGATION_UPDATE_COST = 203_911; // worst case cost of delegateERC721\n    uint128 private constant _BASE_OWNERSHIP_UPDATE_COST = 60_000; // worst case cost of transferFrom\n    uint128 private constant _INCREMENTAL_OWNERSHIP_UPDATE_COST = 50_000; // incremental cost of transferFrom\n    uint32 private constant _BASE_READ_RETURN_DATA_SIZE = 224; // 32 bytes for collection address, 64 bytes for each array\n    uint32 private constant _READ_SIZE_INCREMENT_PER_UPDATE = 96; // One element in each of three arrays (staleOwner, newOwner, tokenId)\n    uint32 private constant _EXT_CALL_GAS = 2_600;\n    uint256 private constant _READ_TIMEOUT = 30 minutes;\n\n    // Limit the gas allocation for lzReceive to prevent DOS issues\n    uint128 private constant _LZ_RECEIVE_MAX_GAS_ALLOCATION = 8_000_000;\n\n    // The role for the collection registrar\n    bytes32 public constant COLLECTION_REGISTRAR_ROLE = keccak256(\"COLLECTION_REGISTRAR_ROLE\");\n\n    // The necessary delegate rights for the shadow token\n    bytes32 private constant _GLOBAL_RIGHTS_WITH_MAX_EXPIRY = bytes32(uint256(type(uint40).max));\n    bytes24 public immutable SHADOW_TOKEN_RIGHTS;\n\n    // The endpoint ID of this contract\n    uint32 public immutable THIS_CONTRACT_EID;\n\n    // The address of the exclusive delegate resolver\n    address public immutable EXCLUSIVE_DELEGATE_RESOLVER_ADDRESS;\n\n    // the address of the delegate registry\n    address public immutable DELEGATE_REGISTRY_ADDRESS;\n\n    // The read channel ID\n    uint32 public readChannel;\n\n    // Single mapping for all collection configuration\n    mapping(address baseCollectionAddress => CollectionConfig) public collectionConfigs;\n    mapping(address shadowCollectionAddress => address baseCollectionAddress) private _shadowToBase;\n\n    // Tracks delegated ownership for native collections\n    mapping(address collection => mapping(uint256 tokenId => address delegatedOwner)) public delegatedOwners;\n\n    // Store the hash of messages that failed to execute\n    mapping(uint32 => mapping(bytes32 => mapping(uint64 => bytes32))) public payloadHashes;\n\n    // Mapping of allowed executors, enforced if enforceExecutors is true\n    mapping(address executor => bool allowed) public allowedExecutors;\n\n    // Mapping of init timestamps for each read request\n    mapping(bytes32 guid => uint256 timestamp) public initTimestamps;\n\n    // Enforce executors if true\n    bool public enforceExecutors;\n\n    // LZ static variables\n    uint8 private constant _MAP_AND_REDUCE = 2;\n    uint16 private constant _MSG_TYPE = 1;\n    uint32 private constant _READ_CHANNEL_EID_THRESHOLD = 4294965694;\n\n    // Mapping of required confirmations per EID\n    LibMap.Uint32Map private _requiredConfirmations;\n\n    /**\n     * @notice Initializes the Beacon contract.\n     * @param _endpointLocator The address of the LayerZero endpoint locator.\n     * @param _delegate The address allowed to set LZ configuration for this contract.\n     * @param _readChannel The ID of the read channel.\n     * @param _delegatexyz The address of the delegate registry.\n     * @param _exclusiveDelegateResolver The address of the exclusive delegate resolver.\n     */\n    constructor(\n        address _endpointLocator,\n        address _delegate,\n        uint32 _readChannel,\n        address _delegatexyz,\n        address _exclusiveDelegateResolver,\n        address _initialAdmin\n    ) OAppRead(ILayerZeroEndpointLocator(_endpointLocator).endpoint(), _delegate) Ownable(_initialAdmin) {\n        if (_readChannel <= _READ_CHANNEL_EID_THRESHOLD) revert InvalidReadChannel();\n\n        EXCLUSIVE_DELEGATE_RESOLVER_ADDRESS = _exclusiveDelegateResolver;\n        DELEGATE_REGISTRY_ADDRESS = _delegatexyz;\n\n        SHADOW_TOKEN_RIGHTS = bytes24(keccak256(abi.encode(block.chainid)));\n        THIS_CONTRACT_EID = ILayerZeroEndpointV2(ILayerZeroEndpointLocator(_endpointLocator).endpoint()).eid();\n        readChannel = _readChannel;\n        _grantRole(COLLECTION_REGISTRAR_ROLE, _initialAdmin);\n        _grantRole(DEFAULT_ADMIN_ROLE, _initialAdmin);\n\n        _setPeer(readChannel, address(this).toBytes32());\n    }\n\n    /**\n     * @notice Register a collection (either native or shadow).\n     * @param shadowCollectionAddress The address of the collection to register.\n     * @param baseCollectionChainId The chain ID of the base collection.\n     * @param baseCollectionAddress The address of the base collection.\n     * @param baseCollectionEid The endpoint ID of the base collection.\n     * @param baseCollectionPerNftOwnershipUpdateCost The cost of updating the ownership of an NFT. Set to 0 to use Beacon's default.\n     * @dev If the collection is native:\n     * - baseCollectionChainId must match block.chainid\n     * - baseCollectionEid must match THIS_CONTRACT_EID\n     * - baseCollectionAddress must match shadowCollectionAddress\n     */\n    function registerCollection(\n        address shadowCollectionAddress,\n        uint32 baseCollectionChainId,\n        address baseCollectionAddress,\n        uint32 baseCollectionEid,\n        uint32 baseCollectionPerNftOwnershipUpdateCost\n    ) external onlyRole(COLLECTION_REGISTRAR_ROLE) {\n        _validateCollectionConfiguration(\n            shadowCollectionAddress,\n            baseCollectionAddress,\n            baseCollectionChainId,\n            baseCollectionEid,\n            baseCollectionPerNftOwnershipUpdateCost\n        );\n\n        _shadowToBase[shadowCollectionAddress] = baseCollectionAddress;\n        collectionConfigs[baseCollectionAddress] = CollectionConfig({\n            baseCollectionChainId: baseCollectionChainId,\n            baseCollectionEid: baseCollectionEid,\n            shadowAddress: shadowCollectionAddress,\n            baseCollectionPerNftOwnershipUpdateCost: baseCollectionPerNftOwnershipUpdateCost\n        });\n\n        emit CollectionRegistered(shadowCollectionAddress, baseCollectionAddress, baseCollectionEid);\n    }\n\n    /**\n     * @notice Trigger an ownership update for a collection.\n     * @param baseCollectionAddress The address on this chain of the collection to update.\n     * @param eids The array of endpoint IDs to try reading ownership from. At max, one will return a valid response.\n     * @param tokenIds The array of token IDs to update ownership for.\n     * @param refundRecipient The address to refund the excess LZ fee to, if any exists.\n     * @param supplementalGasLimit The gas limit for the callback.\n     */\n    function read(\n        address baseCollectionAddress,\n        uint256[] calldata tokenIds,\n        uint32[] calldata eids,\n        address refundRecipient,\n        uint128 supplementalGasLimit\n    ) external payable returns (bytes32) {\n        if (tokenIds.length == 0 || eids.length == 0) revert ZeroLengthArray();\n\n        CollectionConfig storage config = collectionConfigs[baseCollectionAddress];\n        address shadowCollectionAddress = config.shadowAddress;\n        if (shadowCollectionAddress == address(0)) revert ContractNotConfigured();\n\n        if (!_collectionIsNative(config) && !INFTShadow(shadowCollectionAddress).shadowModeEnabled()) {\n            revert CollectionNotInShadowMode();\n        }\n\n        bytes memory cmd = _buildCmd(baseCollectionAddress, eids, tokenIds);\n\n        bytes memory options = this.combineOptions(\n            readChannel, _MSG_TYPE, getReadOptions(baseCollectionAddress, tokenIds, supplementalGasLimit)\n        );\n\n        MessagingReceipt memory receipt = _lzSend(\n            readChannel, cmd, options, MessagingFee({nativeFee: msg.value, lzTokenFee: 0}), payable(refundRecipient)\n        );\n\n        bytes32 guid = receipt.guid;\n        initTimestamps[guid] = block.timestamp;\n\n        emit ReadTriggered(baseCollectionAddress, shadowCollectionAddress, eids, tokenIds);\n\n        return guid;\n    }\n\n    /**\n     * @notice Releases tokens on a specific eid.\n     * @param dstEid The endpoint ID to release the tokens on.\n     * @param baseCollectionAddress The address of the base collection to release the tokens for.\n     * @param tokenIds The array of token IDs to release.\n     * @param beneficiary The address to receive the tokens.\n     * @param refundRecipient The address to refund the excess LZ fee to, if any exists.\n     * @notice should be triggered by the shadow contract, calls from EOAs for contracts that are not configured will revert\n     */\n    function send(\n        uint32 dstEid,\n        address baseCollectionAddress,\n        uint256[] calldata tokenIds,\n        address beneficiary,\n        address refundRecipient,\n        uint128 supplementalGasLimit\n    ) external payable {\n        if (beneficiary == address(0)) revert BeneficiaryZeroAddress();\n        if (dstEid == THIS_CONTRACT_EID || dstEid > _READ_CHANNEL_EID_THRESHOLD) revert InvalidEid();\n        if (tokenIds.length == 0) revert ZeroLengthArray();\n\n        CollectionConfig storage config = collectionConfigs[baseCollectionAddress];\n        address shadowCollectionAddress = config.shadowAddress;\n        bool isNative = _collectionIsNative(config);\n\n        if (isNative) {\n            for (uint256 i = 0; i < tokenIds.length; i++) {\n                uint256 tokenId = tokenIds[i];\n                // if the collection is native, the caller must be the owner (enforced by transferring from msg.sender)\n                IERC721(shadowCollectionAddress).transferFrom(msg.sender, address(this), tokenId);\n            }\n        } else {\n            // if the collection is not native, the Shadow must be the caller (Shadow should enforce that the caller is approved or the owner)\n            if (msg.sender != shadowCollectionAddress) revert InvalidCaller();\n        }\n\n        bytes memory payload = abi.encode(baseCollectionAddress, beneficiary, tokenIds);\n\n        bytes memory options = this.combineOptions(\n            dstEid, _MSG_TYPE, getSendOptions(dstEid, baseCollectionAddress, tokenIds, supplementalGasLimit)\n        );\n        _lzSend(dstEid, payload, options, MessagingFee({nativeFee: msg.value, lzTokenFee: 0}), payable(refundRecipient));\n\n        emit Sent(dstEid, baseCollectionAddress, shadowCollectionAddress, tokenIds, beneficiary);\n    }\n\n    function executeMessage(Origin calldata _origin, bytes32 guid, bytes calldata _message) external {\n        if (msg.sender != address(this)) revert OnlyInternalCalls();\n        _executeMessage(_origin, guid, _message);\n    }\n\n    /**\n     * @notice Set whether to enforce executors.\n     * @param _enforceExecutors Whether to enforce executors.\n     */\n    function setEnforceExecutors(bool _enforceExecutors) external onlyOwner {\n        enforceExecutors = _enforceExecutors;\n\n        emit EnforceExecutionSet(_enforceExecutors);\n    }\n\n    /**\n     * @notice Set whether an executor is allowed.\n     * @param executor The address of the executor.\n     * @param allowed Whether the executor is allowed.\n     */\n    function setAllowedExecutor(address executor, bool allowed) external onlyOwner {\n        allowedExecutors[executor] = allowed;\n\n        emit AllowedExecutorSet(executor, allowed);\n    }\n\n    /**\n     * @notice Set the required confirmations for a read request on an EID.\n     * @param eid The endpoint ID to set the required confirmations for.\n     * @param confirmations The required confirmations.\n     */\n    function setRequiredConfirmations(uint32 eid, uint16 confirmations) external onlyOwner {\n        _requiredConfirmations.set(eid, confirmations);\n\n        emit RequiredConfirmationsSet(eid, confirmations);\n    }\n\n    /**\n     * @notice sets the base collection per nft ownership update cost\n     * @param baseCollectionAddress The address of the base collection.\n     * @param cost The cost of updating the ownership of an NFT.\n     */\n    function setBaseCollectionPerNftOwnershipUpdateCost(address baseCollectionAddress, uint32 cost)\n        external\n        onlyOwner\n    {\n        collectionConfigs[baseCollectionAddress].baseCollectionPerNftOwnershipUpdateCost = cost;\n    }\n\n    /**\n     * @notice Set the read channel for the Beacon.\n     * @param _readChannel The new read channel.\n     */\n    function setReadChannel(uint32 _readChannel) external onlyOwner {\n        if (_readChannel <= _READ_CHANNEL_EID_THRESHOLD) revert InvalidReadChannel();\n        readChannel = _readChannel;\n        emit ReadChannelSet(_readChannel);\n    }\n\n    /**\n     * @notice Get the required confirmations for a read request on an EID.\n     * @param eid The endpoint ID to get the required confirmations for.\n     * @return uint32 The required confirmations.\n     */\n    function requiredConfirmations(uint32 eid) external view returns (uint16) {\n        return uint16(_requiredConfirmations.get(eid));\n    }\n\n    /**\n     * @notice Get the base collection address for a given shadow collection address.\n     * @param shadowCollectionAddress The address of the shadow collection.\n     * @return address the base collection address.\n     */\n    function shadowToBase(address shadowCollectionAddress) external view returns (address) {\n        return _shadowToBase[shadowCollectionAddress];\n    }\n\n    /**\n     * @notice Get the shadow collection address for a given base collection address.\n     * @param baseCollectionAddress The address of the base collection.\n     * @return address the shadow collection address.\n     */\n    function baseToShadow(address baseCollectionAddress) external view returns (address) {\n        return collectionConfigs[baseCollectionAddress].shadowAddress;\n    }\n\n    /**\n     * @notice Calculate fees for sending a read request for an array of token IDs.\n     * @param baseCollectionAddress The address of the collection to calculate fees for.\n     * @param tokenIds The array of token IDs to calculate fees for.\n     * @param dstEids The array of endpoint IDs to calculate fees for.\n     * @param supplementalGasLimit The gas limit for the callback.\n     * @return nativeFee The native fee for the message.\n     * @return lzTokenFee The LZ token fee for the message.\n     * @dev the shadow contract has a variant with built in options to simplify.\n     */\n    function quoteRead(\n        address baseCollectionAddress,\n        uint256[] calldata tokenIds,\n        uint32[] calldata dstEids,\n        uint128 supplementalGasLimit\n    ) external view returns (uint256 nativeFee, uint256 lzTokenFee) {\n        CollectionConfig storage config = collectionConfigs[baseCollectionAddress];\n        address shadowCollectionAddress = config.shadowAddress;\n        if (shadowCollectionAddress == address(0)) revert ContractNotConfigured();\n\n        bytes memory cmd = _buildCmd(shadowCollectionAddress, dstEids, tokenIds);\n        bytes memory options = this.combineOptions(\n            readChannel, _MSG_TYPE, getReadOptions(baseCollectionAddress, tokenIds, supplementalGasLimit)\n        );\n\n        MessagingFee memory fee = _quote(readChannel, cmd, options, false);\n        return (fee.nativeFee, fee.lzTokenFee);\n    }\n\n    /**\n     * @notice Calculate fees for sending a message to the shadow contract.\n     * @param dstEid The endpoint ID to send the message to.\n     * @param baseCollectionAddress The address of the collection to calculate fees for.\n     * @param tokenIds The array of token IDs to calculate fees for.\n     * @return nativeFee The native fee for the message.\n     * @return lzTokenFee The LZ token fee for the message.\n     * @dev the shadow contract has a variant with built in options to simplify.\n     */\n    function quoteSend(\n        uint32 dstEid,\n        address baseCollectionAddress,\n        uint256[] calldata tokenIds,\n        uint128 supplementalGasLimit\n    ) external view returns (uint256 nativeFee, uint256 lzTokenFee) {\n        CollectionConfig storage config = collectionConfigs[baseCollectionAddress];\n        address shadowCollectionAddress = config.shadowAddress;\n        if (shadowCollectionAddress == address(0)) revert ContractNotConfigured();\n\n        bytes memory payload = abi.encode(baseCollectionAddress, address(0), tokenIds);\n\n        bytes memory options = this.combineOptions(\n            dstEid, _MSG_TYPE, getSendOptions(dstEid, baseCollectionAddress, tokenIds, supplementalGasLimit)\n        );\n        MessagingFee memory fee = _quote(dstEid, payload, options, false);\n        return (fee.nativeFee, fee.lzTokenFee);\n    }\n\n    /**\n     * @notice Fetch the owner of a token from the delegate resolver.\n     * @param baseCollectionAddress The address of the collection to fetch the owner for.\n     * @param tokenId The ID of the token to fetch the owner for.\n     * @return _owner the owner of the token.\n     * @return _isLocked true if the token is locked, false otherwise.\n     * @dev reverts if the contract is not configured or the token is locked.\n     */\n    function unlockedExclusiveOwnerByRights(address baseCollectionAddress, uint256 tokenId, bytes24 rightsIdentifier)\n        external\n        view\n        returns (address _owner, bool _isLocked)\n    {\n        CollectionConfig memory config = collectionConfigs[baseCollectionAddress];\n\n        if (config.baseCollectionEid == 0) return (address(0), true);\n\n        bool isNative = config.baseCollectionChainId == block.chainid;\n        address shadowCollectionAddress = config.shadowAddress;\n        address _baseOwner;\n\n        if (isNative) {\n            try IERC721(shadowCollectionAddress).ownerOf(tokenId) returns (address owner) {\n                if (owner == address(this)) {\n                    return (address(this), true);\n                } else {\n                    _baseOwner = owner;\n                }\n            } catch {\n                // if the token does not exist in a native collection, we can preemptively return address(0) as the owner\n                return (address(0), false);\n            }\n        } else {\n            // if collection is not configured or the token is locked, return _isLocked = true to render it a no-op\n            if (shadowCollectionAddress == address(0) || INFTShadow(shadowCollectionAddress).locked(tokenId)) {\n                return (address(0), true);\n            } else {\n                try INFTShadow(shadowCollectionAddress).ownerOf(tokenId) returns (address owner) {\n                    _baseOwner = owner;\n                } catch {\n                    // if the token does not exist for an unlocked shadow, the token was burned\n                    _baseOwner = address(0);\n                }\n            }\n        }\n\n        // otherwise, we return the exclusive owner by rights according to the delegate resolver\n        try IExclusiveDelegateResolver(EXCLUSIVE_DELEGATE_RESOLVER_ADDRESS).exclusiveOwnerByRights(\n            shadowCollectionAddress, tokenId, rightsIdentifier\n        ) returns (address owner) {\n            return (owner, false);\n        } catch {\n            return (_baseOwner, false);\n        }\n    }\n\n    /**\n     * @notice Processes individual NFT ownership responses for consumption by lzReduce.\n     * @param _request The original read request data.\n     * @param _response The response from the ownership query (encoded address, bool)\n     * @return bytes memory encoded (staleOwner, newOwner, tokenId)\n     */\n    function lzMap(bytes calldata _request, bytes calldata _response) external view override returns (bytes memory) {\n        (address collectionAddress, uint256 tokenId) = abi.decode(_request[46:110], (address, uint256));\n\n        address staleOwner;\n        (address newOwner, bool isLocked) = abi.decode(_response, (address, bool));\n\n        if (isLocked) return new bytes(0);\n\n        CollectionConfig memory config = collectionConfigs[collectionAddress];\n\n        if (_collectionIsNative(config)) {\n            // For native collections, read from delegation mapping\n            staleOwner = delegatedOwners[collectionAddress][tokenId];\n        } else {\n            // For shadow collections, read from the shadow contract\n            try INFTShadow(config.shadowAddress).ownerOf(tokenId) returns (address owner) {\n                staleOwner = owner;\n            } catch {\n                // ownerOf reverts if the token does not exist\n                staleOwner = address(0);\n            }\n        }\n\n        return abi.encode(staleOwner, newOwner, tokenId);\n    }\n\n    /**\n     * @notice Reduces the response from the ownership query post lzMap\n     * @param _responses An array of abi encoded (staleOwner, newOwner, tokenId)\n     * @return bytes memory encoded (collectionAddress, staleOwners, newOwners, tokenIds)\n     */\n    function lzReduce(bytes calldata _request, bytes[] calldata _responses)\n        external\n        view\n        override\n        returns (bytes memory)\n    {\n        address collectionAddress = address(bytes20(_request[64:84]));\n        CollectionConfig memory config = collectionConfigs[collectionAddress];\n\n        address targetAddress = config.shadowAddress;\n\n        address[] memory staleOwners = new address[](_responses.length);\n        address[] memory newOwners = new address[](_responses.length);\n        uint256[] memory tokenIds = new uint256[](_responses.length);\n\n        uint256 updateCount = 0;\n        for (uint256 i = 0; i < _responses.length; i++) {\n            if (_responses[i].length == 0) {\n                // lzMap returns empty bytes if ownership data is not available\n                continue;\n            }\n\n            (staleOwners[i], newOwners[i], tokenIds[i]) = abi.decode(_responses[i], (address, address, uint256));\n\n            if (staleOwners[i] != newOwners[i]) {\n                tokenIds[updateCount] = tokenIds[i];\n                staleOwners[updateCount] = staleOwners[i];\n                newOwners[updateCount] = newOwners[i];\n\n                unchecked {\n                    ++updateCount;\n                }\n            }\n        }\n\n        // if updateCount is less than the length of the tokenIds array, we need to resize the arrays\n        if (updateCount < tokenIds.length) {\n            address[] memory resizedStaleOwners = new address[](updateCount);\n            address[] memory resizedNewOwners = new address[](updateCount);\n            uint256[] memory resizedTokenIds = new uint256[](updateCount);\n\n            for (uint256 i = 0; i < updateCount; i++) {\n                resizedStaleOwners[i] = staleOwners[i];\n                resizedNewOwners[i] = newOwners[i];\n                resizedTokenIds[i] = tokenIds[i];\n            }\n\n            return abi.encode(targetAddress, resizedStaleOwners, resizedNewOwners, resizedTokenIds);\n        }\n\n        return abi.encode(targetAddress, staleOwners, newOwners, tokenIds);\n    }\n\n    /**\n     * @notice Generates options for a send operation.\n     * @param dstEid The endpoint ID to send the message to.\n     * @param baseCollectionAddress The address of the base collection.\n     * @param tokenIds The array of token IDs.\n     * @param supplementalGasLimit The gas limit for the send operation.\n     * @return options The options bytes.\n     */\n    function getSendOptions(\n        uint32 dstEid,\n        address baseCollectionAddress,\n        uint256[] calldata tokenIds,\n        uint128 supplementalGasLimit\n    ) public view returns (bytes memory) {\n        CollectionConfig memory config = collectionConfigs[baseCollectionAddress];\n        bool targetIsNative = config.baseCollectionEid == dstEid;\n\n        uint128 totalGasRequired = _calculateLzReceiveGasAllocation(\n            config.baseCollectionPerNftOwnershipUpdateCost, supplementalGasLimit, tokenIds.length, targetIsNative, false\n        );\n\n        return OptionsBuilder.newOptions().addExecutorLzReceiveOption(totalGasRequired, 0);\n    }\n\n    /**\n     * @notice Generates options for a read operation.\n     * @param baseCollectionAddress The address of the base collection.\n     * @param tokenIds The array of token IDs.\n     * @return options The options bytes.\n     */\n    function getReadOptions(address baseCollectionAddress, uint256[] calldata tokenIds, uint128 supplementalGasLimit)\n        public\n        view\n        returns (bytes memory)\n    {\n        CollectionConfig memory config = collectionConfigs[baseCollectionAddress];\n        bool isNative = config.baseCollectionChainId == block.chainid;\n\n        uint128 totalGasRequired = _calculateLzReceiveGasAllocation(\n            config.baseCollectionPerNftOwnershipUpdateCost, supplementalGasLimit, tokenIds.length, isNative, true\n        );\n        uint32 totalReturnDataSize =\n            _BASE_READ_RETURN_DATA_SIZE + (_READ_SIZE_INCREMENT_PER_UPDATE * uint32(tokenIds.length));\n\n        bytes memory options =\n            OptionsBuilder.newOptions().addExecutorLzReadOption(totalGasRequired, totalReturnDataSize, 0);\n\n        return options;\n    }\n\n    /**\n     * @notice Handle incoming messages from LayerZero.\n     * @dev the message type is determined by the srcEid.\n     * @dev read responses will update the ownership of the tokens.\n     * @dev traditional LZ messages will update the lock state of the tokens.\n     */\n    function _lzReceive(\n        Origin calldata _origin,\n        bytes32 guid,\n        bytes calldata _message,\n        address executor,\n        bytes calldata /* _extraData */\n    ) internal override {\n        if (enforceExecutors && !allowedExecutors[executor]) revert UnauthorizedExecutor();\n\n        // Prepare the execution calldata\n        bytes memory callData = abi.encodeWithSelector(this.executeMessage.selector, _origin, guid, _message);\n\n        // Calculate gas to forward, leaving some in reserve\n        uint256 externalGas = gasleft() - _SAFE_CALL_BUFFER;\n\n        // Use SafeCall to execute with gas limit and capture return data\n        (bool success, bytes memory reason) = address(this).safeCall(externalGas, 0, 4, callData);\n\n        if (!success) {\n            // Cache failed message hash\n            bytes32 payloadHash = keccak256(abi.encodePacked(address(this), callData, block.chainid));\n            payloadHashes[_origin.srcEid][_origin.sender][_origin.nonce] = payloadHash;\n            emit MessageCached(_origin.srcEid, _origin.sender, _origin.nonce, reason);\n        }\n    }\n\n    /**\n     * @notice Retry a failed message.\n     * @param srcEid The source endpoint ID.\n     * @param sender The sender of the message.\n     * @param nonce The nonce of the message.\n     * @param origin The original origin of the message.\n     * @param message The message to retry.\n     * @dev only allow retries for EIDs under the read channel threshold\n     * @dev the consequence for failed reads is low enough that we can just retry\n     */\n    function retryFailedMessage(\n        uint32 srcEid,\n        bytes32 sender,\n        uint64 nonce,\n        Origin calldata origin,\n        bytes32 guid,\n        bytes calldata message\n    ) external {\n        // only allow retries for EIDs under the read channel threshold\n        if (srcEid > _READ_CHANNEL_EID_THRESHOLD) revert InvalidEid();\n\n        // Prepare calldata and verify hash\n        bytes memory callData = abi.encodeWithSelector(this.executeMessage.selector, origin, guid, message);\n        bytes32 payloadHash = keccak256(abi.encodePacked(address(this), callData, block.chainid));\n\n        if (payloadHashes[srcEid][sender][nonce] != payloadHash) revert InvalidPayloadHash();\n\n        // Clear cache before execution\n        delete payloadHashes[srcEid][sender][nonce];\n\n        // Execute with SafeCall, using all remaining gas\n        // limit return data to 4 bytes, it will either be a custom error with no data, or nothing\n        (bool success, bytes memory reason) = address(this).safeCall(gasleft(), 0, 4, callData);\n\n        if (!success) {\n            // If retry fails, revert with the reason\n            assembly {\n                revert(add(32, reason), mload(reason))\n            }\n        }\n\n        emit CachedMessageExecuted(srcEid, sender, nonce);\n    }\n\n    function _executeMessage(Origin calldata _origin, bytes32 guid, bytes calldata _message) internal {\n        if (_origin.srcEid > _READ_CHANNEL_EID_THRESHOLD) {\n            if (block.timestamp - initTimestamps[guid] > _READ_TIMEOUT) revert StaleReadRequest();\n\n            // Handle lzRead responses\n            _updateOwnership(_message, guid);\n        } else {\n            // Handle standard LayerZero messages.\n            _updateLockState(_message);\n        }\n    }\n\n    function _updateOwnership(bytes calldata _message, bytes32 guid) internal {\n        (address shadowAddress, address[] memory staleOwners, address[] memory newOwners, uint256[] memory tokenIds) =\n            abi.decode(_message, (address, address[], address[], uint256[]));\n\n        address baseCollectionAddress = _shadowToBase[shadowAddress];\n\n        CollectionConfig memory config = collectionConfigs[baseCollectionAddress];\n        bool isNative = _collectionIsNative(config);\n\n        // For shadow collections, use the shadow contract\n        INFTShadow _shadow = INFTShadow(shadowAddress);\n\n        if (isNative) {\n            // For native collections, update the delegated ownership\n            _updateDelegations(baseCollectionAddress, newOwners, tokenIds);\n        } else {\n            for (uint256 i = 0; i < tokenIds.length; i++) {\n                address staleOwner = staleOwners[i];\n                address newOwner = newOwners[i];\n                uint256 tokenId = tokenIds[i];\n\n                if (staleOwner == address(0)) {\n                    (bool success,) =\n                        address(_shadow).call(abi.encodeWithSignature(\"mint(address,uint256)\", newOwner, tokenId));\n                    if (!success) revert MintFailed();\n                } else if (newOwner == address(0)) {\n                    (bool success,) = address(_shadow).call(abi.encodeWithSignature(\"burn(uint256)\", tokenId));\n                    if (!success) revert BurnFailed();\n                } else {\n                    (bool success,) = address(_shadow).call(\n                        abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", staleOwner, newOwner, tokenId)\n                    );\n                    if (!success) revert TransferFailed();\n                }\n            }\n\n            _shadow.executeCallback(guid);\n        }\n    }\n\n    function _updateLockState(bytes calldata _message) internal {\n        (address collectionAddress, address beneficiary, uint256[] memory tokenIds) =\n            abi.decode(_message, (address, address, uint256[]));\n\n        CollectionConfig storage config = collectionConfigs[collectionAddress];\n        if (config.shadowAddress == address(0)) revert ContractNotConfigured();\n\n        bool isNative = config.baseCollectionChainId == block.chainid;\n        if (isNative) {\n            // Handle standard LayerZero messages.\n            _clearDelegationsAndReleaseTokens(collectionAddress, beneficiary, tokenIds);\n        } else {\n            // For shadow collections, unlock tokens in the shadow contract\n            (bool success,) = address(INFTShadow(config.shadowAddress)).call(\n                abi.encodeWithSignature(\"unlockTokens(uint256[],address)\", tokenIds, beneficiary)\n            );\n            if (!success) revert UnlockFailed();\n        }\n    }\n\n    /**\n     * @notice Build the command for a read request.\n     * @param targetCollectionAddress The address on the target chain to read from.\n     * @param eids The array of endpoint IDs to build the command for.\n     * @param tokenIds The array of token IDs to build the command for.\n     * @return bytes memory The built command.\n     */\n    function _buildCmd(address targetCollectionAddress, uint32[] calldata eids, uint256[] calldata tokenIds)\n        internal\n        view\n        returns (bytes memory)\n    {\n        // Construct the call to the beacon on peer eid to fetch ownership from that eid's exclusive delegate resolver\n        EVMCallRequestV1[] memory readRequests = new EVMCallRequestV1[](tokenIds.length * eids.length);\n\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            for (uint256 j = 0; j < eids.length; j++) {\n                uint32 confirmations = _requiredConfirmations.get(eids[j]);\n                if (confirmations == 0) revert InvalidEid();\n\n                readRequests[i * eids.length + j] = EVMCallRequestV1({\n                    appRequestLabel: uint16(i + 1 + j * tokenIds.length),\n                    targetEid: eids[j],\n                    isBlockNum: false,\n                    blockNumOrTimestamp: uint64(block.timestamp),\n                    confirmations: uint16(confirmations),\n                    to: _getPeerOrRevert(eids[j]).toAddress(),\n                    callData: abi.encodeWithSelector(\n                        this.unlockedExclusiveOwnerByRights.selector,\n                        targetCollectionAddress,\n                        tokenIds[i],\n                        SHADOW_TOKEN_RIGHTS\n                    )\n                });\n            }\n        }\n\n        EVMCallComputeV1 memory computeSettings =\n            EVMCallComputeV1(_MAP_AND_REDUCE, THIS_CONTRACT_EID, false, uint64(block.timestamp), 0, address(this));\n\n        return ReadCmdCodecV1.encode(0, readRequests, computeSettings);\n    }\n\n    /**\n     * @notice Updates the delegations based on the received message.\n     * @param collectionAddress The address of the collection.\n     * @param newOwners The array of new owners.\n     * @param tokenIds The array of token IDs.\n     */\n    function _updateDelegations(address collectionAddress, address[] memory newOwners, uint256[] memory tokenIds)\n        internal\n    {\n        bytes[] memory multicallRawData = new bytes[](tokenIds.length * 2);\n        uint256 multicallDataLength = 0;\n\n        address nftContractToDelegate = collectionAddress;\n\n        for (uint256 i = 0; i < tokenIds.length; ++i) {\n            address newOwner = newOwners[i];\n            uint256 tokenId = tokenIds[i];\n            address staleOwner = delegatedOwners[collectionAddress][tokenId];\n\n            if (IERC721(collectionAddress).ownerOf(tokenId) != address(this)) {\n                revert InvalidOwner();\n            }\n\n            if (staleOwner != address(0)) {\n                multicallRawData[multicallDataLength] = abi.encodeWithSelector(\n                    IDelegateRegistry.delegateERC721.selector,\n                    staleOwner,\n                    nftContractToDelegate,\n                    tokenId,\n                    _GLOBAL_RIGHTS_WITH_MAX_EXPIRY,\n                    false\n                );\n\n                unchecked {\n                    ++multicallDataLength;\n                }\n            }\n\n            if (newOwner != address(0)) {\n                multicallRawData[multicallDataLength] = abi.encodeWithSelector(\n                    IDelegateRegistry.delegateERC721.selector,\n                    newOwner,\n                    nftContractToDelegate,\n                    tokenId,\n                    _GLOBAL_RIGHTS_WITH_MAX_EXPIRY,\n                    true\n                );\n\n                unchecked {\n                    ++multicallDataLength;\n                }\n\n                delegatedOwners[collectionAddress][tokenId] = newOwner;\n            }\n        }\n\n        bytes[] memory multicallData = new bytes[](multicallDataLength);\n        for (uint256 i = 0; i < multicallDataLength; ++i) {\n            multicallData[i] = multicallRawData[i];\n        }\n\n        if (multicallDataLength > 0) {\n            IDelegateRegistry(DELEGATE_REGISTRY_ADDRESS).multicall(multicallData);\n        }\n    }\n\n    /**\n     * @notice Clears the delegations and releases the tokens.\n     * @param collectionAddress The address of the collection.\n     * @param beneficiary The address of the beneficiary.\n     * @param tokenIds The array of token IDs.\n     */\n    function _clearDelegationsAndReleaseTokens(\n        address collectionAddress,\n        address beneficiary,\n        uint256[] memory tokenIds\n    ) internal {\n        for (uint256 i = 0; i < tokenIds.length; ++i) {\n            IERC721(collectionAddress).transferFrom(address(this), beneficiary, tokenIds[i]);\n        }\n\n        _clearDelegations(collectionAddress, tokenIds);\n    }\n\n    /**\n     * @notice Clears the delegations.\n     * @param collectionAddress The address of the collection.\n     * @param tokenIds The array of token IDs.\n     */\n    function _clearDelegations(address collectionAddress, uint256[] memory tokenIds) internal {\n        bytes[] memory multicallDataRaw = new bytes[](tokenIds.length);\n        address nftContractToDelegate = collectionAddress;\n\n        uint256 multicallDataLength = 0;\n        for (uint256 i = 0; i < tokenIds.length; ++i) {\n            uint256 tokenId = tokenIds[i];\n\n            address delegatedOwner = delegatedOwners[collectionAddress][tokenId];\n            if (delegatedOwner == address(0)) continue;\n\n            multicallDataRaw[i] = abi.encodeWithSelector(\n                IDelegateRegistry.delegateERC721.selector,\n                delegatedOwner,\n                nftContractToDelegate,\n                tokenId,\n                _GLOBAL_RIGHTS_WITH_MAX_EXPIRY,\n                false\n            );\n\n            unchecked {\n                ++multicallDataLength;\n            }\n\n            delegatedOwners[collectionAddress][tokenId] = address(0);\n        }\n\n        bytes[] memory multicallData = new bytes[](multicallDataLength);\n        for (uint256 i = 0; i < multicallDataLength; ++i) {\n            multicallData[i] = multicallDataRaw[i];\n        }\n\n        if (multicallDataLength > 0) {\n            IDelegateRegistry(DELEGATE_REGISTRY_ADDRESS).multicall(multicallData);\n        }\n    }\n\n    function _collectionIsNative(CollectionConfig memory config) internal view returns (bool) {\n        if (config.baseCollectionChainId == 0) revert ContractNotConfigured();\n\n        return config.baseCollectionChainId == block.chainid;\n    }\n\n    function _validateCollectionConfiguration(\n        address shadowCollectionAddress,\n        address baseCollectionAddress,\n        uint256 baseCollectionChainId,\n        uint32 baseCollectionEid,\n        uint128 baseCollectionPerNftOwnershipUpdateCost\n    ) internal view {\n        if (baseCollectionChainId == 0) revert InvalidChain();\n        if (baseCollectionEid == 0) revert InvalidEid();\n        if (baseCollectionAddress == address(0)) revert ZeroAddress();\n        if (shadowCollectionAddress == address(0)) revert ZeroAddress();\n        if (baseCollectionPerNftOwnershipUpdateCost > _LZ_RECEIVE_MAX_GAS_ALLOCATION) {\n            revert MaxLzReceiveGasAllocationExceeded();\n        }\n\n        bool isNative = baseCollectionChainId == block.chainid;\n        if (isNative) {\n            if (baseCollectionEid != THIS_CONTRACT_EID) revert InvalidEid();\n            if (shadowCollectionAddress != baseCollectionAddress) revert MismatchedCollectionAddress();\n        } else {\n            if (baseCollectionEid == THIS_CONTRACT_EID) revert InvalidEid();\n        }\n\n        if (collectionConfigs[baseCollectionAddress].shadowAddress != address(0)) revert CollectionAlreadyRegistered();\n    }\n\n    function _calculateLzReceiveGasAllocation(\n        uint128 baseCollectionPerNftOwnershipUpdateCost,\n        uint128 supplementalGasLimit,\n        uint256 tokenIdsLength,\n        bool isNative,\n        bool isRead\n    ) internal pure returns (uint128 totalGasRequired) {\n        if (isRead) {\n            unchecked {\n                uint128 baseUpdateCost = isNative\n                    ? uint128(_SAFE_CALL_BUFFER + _BASE_OWNERSHIP_UPDATE_COST)\n                    : _EXT_CALL_GAS + uint128(_SAFE_CALL_BUFFER + _BASE_OWNERSHIP_UPDATE_COST);\n                uint128 incrementalUpdateCost =\n                    isNative ? _DELEGATION_UPDATE_COST * 2 : _INCREMENTAL_OWNERSHIP_UPDATE_COST;\n\n                totalGasRequired = baseUpdateCost + incrementalUpdateCost * uint128(tokenIdsLength);\n            }\n        } else {\n            unchecked {\n                uint128 nftOwnershipUpdateCost = isNative && baseCollectionPerNftOwnershipUpdateCost != 0\n                    ? baseCollectionPerNftOwnershipUpdateCost\n                    : _INCREMENTAL_OWNERSHIP_UPDATE_COST;\n\n                uint128 perNftCost =\n                    isNative ? nftOwnershipUpdateCost + _DELEGATION_UPDATE_COST : nftOwnershipUpdateCost;\n                totalGasRequired =\n                    uint128(_SAFE_CALL_BUFFER + _BASE_OWNERSHIP_UPDATE_COST + perNftCost * tokenIdsLength);\n            }\n        }\n\n        totalGasRequired += supplementalGasLimit;\n\n        if (totalGasRequired > _LZ_RECEIVE_MAX_GAS_ALLOCATION) revert MaxLzReceiveGasAllocationExceeded();\n    }\n}"
    },
    "contracts/apechain/interfaces/IDelegateRegistry.sol": {
      "content": "// SPDX-License-Identifier: CC0-1.0\npragma solidity >=0.8.13;\n\n/**\n * @title IDelegateRegistry\n * @custom:version 2.0\n * @custom:author foobar (0xfoobar)\n * @notice A standalone immutable registry storing delegated permissions from one address to another\n */\ninterface IDelegateRegistry {\n    /// @notice Delegation type, NONE is used when a delegation does not exist or is revoked\n    enum DelegationType {\n        NONE,\n        ALL,\n        CONTRACT,\n        ERC721,\n        ERC20,\n        ERC1155\n    }\n\n    /// @notice Struct for returning delegations\n    struct Delegation {\n        DelegationType type_;\n        address to;\n        address from;\n        bytes32 rights;\n        address contract_;\n        uint256 tokenId;\n        uint256 amount;\n    }\n\n    /// @notice Emitted when an address delegates or revokes rights for their entire wallet\n    event DelegateAll(address indexed from, address indexed to, bytes32 rights, bool enable);\n\n    /// @notice Emitted when an address delegates or revokes rights for a contract address\n    event DelegateContract(\n        address indexed from, address indexed to, address indexed contract_, bytes32 rights, bool enable\n    );\n\n    /// @notice Emitted when an address delegates or revokes rights for an ERC721 tokenId\n    event DelegateERC721(\n        address indexed from,\n        address indexed to,\n        address indexed contract_,\n        uint256 tokenId,\n        bytes32 rights,\n        bool enable\n    );\n\n    /// @notice Emitted when an address delegates or revokes rights for an amount of ERC20 tokens\n    event DelegateERC20(\n        address indexed from, address indexed to, address indexed contract_, bytes32 rights, uint256 amount\n    );\n\n    /// @notice Emitted when an address delegates or revokes rights for an amount of an ERC1155 tokenId\n    event DelegateERC1155(\n        address indexed from,\n        address indexed to,\n        address indexed contract_,\n        uint256 tokenId,\n        bytes32 rights,\n        uint256 amount\n    );\n\n    /// @notice Thrown if multicall calldata is malformed\n    error MulticallFailed();\n\n    /**\n     * -----------  WRITE -----------\n     */\n\n    /**\n     * @notice Call multiple functions in the current contract and return the data from all of them if they all succeed\n     * @param data The encoded function data for each of the calls to make to this contract\n     * @return results The results from each of the calls passed in via data\n     */\n    function multicall(bytes[] calldata data) external payable returns (bytes[] memory results);\n\n    /**\n     * @notice Allow the delegate to act on behalf of `msg.sender` for all contracts\n     * @param to The address to act as delegate\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\n     * @param enable Whether to enable or disable this delegation, true delegates and false revokes\n     * @return delegationHash The unique identifier of the delegation\n     */\n    function delegateAll(address to, bytes32 rights, bool enable) external payable returns (bytes32 delegationHash);\n\n    /**\n     * @notice Allow the delegate to act on behalf of `msg.sender` for a specific contract\n     * @param to The address to act as delegate\n     * @param contract_ The contract whose rights are being delegated\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\n     * @param enable Whether to enable or disable this delegation, true delegates and false revokes\n     * @return delegationHash The unique identifier of the delegation\n     */\n    function delegateContract(address to, address contract_, bytes32 rights, bool enable)\n        external\n        payable\n        returns (bytes32 delegationHash);\n\n    /**\n     * @notice Allow the delegate to act on behalf of `msg.sender` for a specific ERC721 token\n     * @param to The address to act as delegate\n     * @param contract_ The contract whose rights are being delegated\n     * @param tokenId The token id to delegate\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\n     * @param enable Whether to enable or disable this delegation, true delegates and false revokes\n     * @return delegationHash The unique identifier of the delegation\n     */\n    function delegateERC721(address to, address contract_, uint256 tokenId, bytes32 rights, bool enable)\n        external\n        payable\n        returns (bytes32 delegationHash);\n\n    /**\n     * @notice Allow the delegate to act on behalf of `msg.sender` for a specific amount of ERC20 tokens\n     * @dev The actual amount is not encoded in the hash, just the existence of a amount (since it is an upper bound)\n     * @param to The address to act as delegate\n     * @param contract_ The address for the fungible token contract\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\n     * @param amount The amount to delegate, > 0 delegates and 0 revokes\n     * @return delegationHash The unique identifier of the delegation\n     */\n    function delegateERC20(address to, address contract_, bytes32 rights, uint256 amount)\n        external\n        payable\n        returns (bytes32 delegationHash);\n\n    /**\n     * @notice Allow the delegate to act on behalf of `msg.sender` for a specific amount of ERC1155 tokens\n     * @dev The actual amount is not encoded in the hash, just the existence of a amount (since it is an upper bound)\n     * @param to The address to act as delegate\n     * @param contract_ The address of the contract that holds the token\n     * @param tokenId The token id to delegate\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\n     * @param amount The amount of that token id to delegate, > 0 delegates and 0 revokes\n     * @return delegationHash The unique identifier of the delegation\n     */\n    function delegateERC1155(address to, address contract_, uint256 tokenId, bytes32 rights, uint256 amount)\n        external\n        payable\n        returns (bytes32 delegationHash);\n\n    /**\n     * ----------- CHECKS -----------\n     */\n\n    /**\n     * @notice Check if `to` is a delegate of `from` for the entire wallet\n     * @param to The potential delegate address\n     * @param from The potential address who delegated rights\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\n     * @return valid Whether delegate is granted to act on the from's behalf\n     */\n    function checkDelegateForAll(address to, address from, bytes32 rights) external view returns (bool);\n\n    /**\n     * @notice Check if `to` is a delegate of `from` for the specified `contract_` or the entire wallet\n     * @param to The delegated address to check\n     * @param contract_ The specific contract address being checked\n     * @param from The cold wallet who issued the delegation\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\n     * @return valid Whether delegate is granted to act on from's behalf for entire wallet or that specific contract\n     */\n    function checkDelegateForContract(address to, address from, address contract_, bytes32 rights)\n        external\n        view\n        returns (bool);\n\n    /**\n     * @notice Check if `to` is a delegate of `from` for the specific `contract` and `tokenId`, the entire `contract_`, or the entire wallet\n     * @param to The delegated address to check\n     * @param contract_ The specific contract address being checked\n     * @param tokenId The token id for the token to delegating\n     * @param from The wallet that issued the delegation\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\n     * @return valid Whether delegate is granted to act on from's behalf for entire wallet, that contract, or that specific tokenId\n     */\n    function checkDelegateForERC721(address to, address from, address contract_, uint256 tokenId, bytes32 rights)\n        external\n        view\n        returns (bool);\n\n    /**\n     * @notice Returns the amount of ERC20 tokens the delegate is granted rights to act on the behalf of\n     * @param to The delegated address to check\n     * @param contract_ The address of the token contract\n     * @param from The cold wallet who issued the delegation\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\n     * @return balance The delegated balance, which will be 0 if the delegation does not exist\n     */\n    function checkDelegateForERC20(address to, address from, address contract_, bytes32 rights)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @notice Returns the amount of a ERC1155 tokens the delegate is granted rights to act on the behalf of\n     * @param to The delegated address to check\n     * @param contract_ The address of the token contract\n     * @param tokenId The token id to check the delegated amount of\n     * @param from The cold wallet who issued the delegation\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\n     * @return balance The delegated balance, which will be 0 if the delegation does not exist\n     */\n    function checkDelegateForERC1155(address to, address from, address contract_, uint256 tokenId, bytes32 rights)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * ----------- ENUMERATIONS -----------\n     */\n\n    /**\n     * @notice Returns all enabled delegations a given delegate has received\n     * @param to The address to retrieve delegations for\n     * @return delegations Array of Delegation structs\n     */\n    function getIncomingDelegations(address to) external view returns (Delegation[] memory delegations);\n\n    /**\n     * @notice Returns all enabled delegations an address has given out\n     * @param from The address to retrieve delegations for\n     * @return delegations Array of Delegation structs\n     */\n    function getOutgoingDelegations(address from) external view returns (Delegation[] memory delegations);\n\n    /**\n     * @notice Returns all hashes associated with enabled delegations an address has received\n     * @param to The address to retrieve incoming delegation hashes for\n     * @return delegationHashes Array of delegation hashes\n     */\n    function getIncomingDelegationHashes(address to) external view returns (bytes32[] memory delegationHashes);\n\n    /**\n     * @notice Returns all hashes associated with enabled delegations an address has given out\n     * @param from The address to retrieve outgoing delegation hashes for\n     * @return delegationHashes Array of delegation hashes\n     */\n    function getOutgoingDelegationHashes(address from) external view returns (bytes32[] memory delegationHashes);\n\n    /**\n     * @notice Returns the delegations for a given array of delegation hashes\n     * @param delegationHashes is an array of hashes that correspond to delegations\n     * @return delegations Array of Delegation structs, return empty structs for nonexistent or revoked delegations\n     */\n    function getDelegationsFromHashes(bytes32[] calldata delegationHashes)\n        external\n        view\n        returns (Delegation[] memory delegations);\n\n    /**\n     * ----------- STORAGE ACCESS -----------\n     */\n\n    /**\n     * @notice Allows external contracts to read arbitrary storage slots\n     */\n    function readSlot(bytes32 location) external view returns (bytes32);\n\n    /**\n     * @notice Allows external contracts to read an arbitrary array of storage slots\n     */\n    function readSlots(bytes32[] calldata locations) external view returns (bytes32[] memory);\n}"
    },
    "contracts/apechain/interfaces/IExclusiveDelegateResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\ninterface IExclusiveDelegateResolver {\n    function exclusiveOwnerByRights(address contractAddress, uint256 tokenId, bytes24 rights)\n        external\n        view\n        returns (address);\n\n    function generateRightsWithExpiration(bytes24 rightsIdentifier, uint40 expiration)\n        external\n        view\n        returns (bytes32);\n}"
    },
    "contracts/apechain/interfaces/ILayerZeroEndpointLocator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\n\ninterface ILayerZeroEndpointLocator {\n    function endpoint() external view returns (address);\n}"
    },
    "contracts/apechain/interfaces/INFTShadow.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\n\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n\ninterface INFTShadow is IERC721 {\n    function read(uint256[] calldata tokenIds, uint32[] calldata eids) external payable returns (bytes32);\n\n    function readWithCallback(uint256[] calldata tokenIds, uint32[] calldata eids, uint128 callbackGasLimit)\n        external\n        payable\n        returns (bytes32);\n\n    function burn(uint256 tokenId) external;\n\n    function send(\n        uint32 eid,\n        uint256[] calldata tokenIds,\n        address beneficiary,\n        address refundRecipient,\n        uint128 supplementalGasLimit\n    ) external payable;\n\n    function executeCallback(bytes32 guid) external;\n\n    function locked(uint256 tokenId) external view returns (bool);\n\n    function shadowModeEnabled() external view returns (bool);\n}"
    },
    "contracts/apechain/structs/CollectionConfig.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.29;\n\nstruct CollectionConfig {\n    uint32 baseCollectionChainId;\n    uint32 baseCollectionEid;\n    uint32 baseCollectionPerNftOwnershipUpdateCost; // cost of transferring an NFT from the base collection. If 0, default of 100_000 is used\n    address shadowAddress; // Local shadow address for this chain\n}"
    },
    "contracts/apechain/utils/SafeCall.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.29;\n\nlibrary SafeCall {\n    /// @notice calls a contract with a specified gas limit and value and captures the return data\n    /// @dev copied from https://github.com/nomad-xyz/ExcessivelySafeCall/blob/main/src/ExcessivelySafeCall.sol.\n    /// @param _target The address to call\n    /// @param _gas The amount of gas to forward to the remote contract\n    /// @param _value The value in wei to send to the remote contract\n    /// @param _maxCopy The maximum number of bytes of returndata to copy\n    /// to memory.\n    /// @param _calldata The data to send to the remote contract\n    /// @return success and returndata, as `.call()`. Returndata is capped to\n    /// `_maxCopy` bytes.\n    function safeCall(address _target, uint256 _gas, uint256 _value, uint16 _maxCopy, bytes memory _calldata)\n        internal\n        returns (bool, bytes memory)\n    {\n        // set up for assembly call\n        uint256 _toCopy;\n        bool _success;\n        bytes memory _returnData = new bytes(_maxCopy);\n        // dispatch message to recipient\n        // by assembly calling \"handle\" function\n        // we call via assembly to avoid memcopying a very large returndata\n        // returned by a malicious contract\n        assembly {\n            _success :=\n                call(\n                    _gas, // gas\n                    _target, // recipient\n                    _value, // ether value\n                    add(_calldata, 0x20), // inloc\n                    mload(_calldata), // inlen\n                    0, // outloc\n                    0 // outlen\n                )\n            // limit our copy to 256 bytes\n            _toCopy := returndatasize()\n            if gt(_toCopy, _maxCopy) { _toCopy := _maxCopy }\n            // Store the length of the copied bytes\n            mstore(_returnData, _toCopy)\n            // copy the bytes from returndata[0:_toCopy]\n            returndatacopy(add(_returnData, 0x20), 0, _toCopy)\n        }\n        return (_success, _returnData);\n    }\n}"
    },
    "solady/src/utils/LibMap.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Library for storage of packed unsigned integers.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibMap.sol)\nlibrary LibMap {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                          STRUCTS                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev A uint8 map in storage.\n    struct Uint8Map {\n        mapping(uint256 => uint256) map;\n    }\n\n    /// @dev A uint16 map in storage.\n    struct Uint16Map {\n        mapping(uint256 => uint256) map;\n    }\n\n    /// @dev A uint32 map in storage.\n    struct Uint32Map {\n        mapping(uint256 => uint256) map;\n    }\n\n    /// @dev A uint40 map in storage. Useful for storing timestamps up to 34841 A.D.\n    struct Uint40Map {\n        mapping(uint256 => uint256) map;\n    }\n\n    /// @dev A uint64 map in storage.\n    struct Uint64Map {\n        mapping(uint256 => uint256) map;\n    }\n\n    /// @dev A uint128 map in storage.\n    struct Uint128Map {\n        mapping(uint256 => uint256) map;\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                     GETTERS / SETTERS                      */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the uint8 value at `index` in `map`.\n    function get(Uint8Map storage map, uint256 index) internal view returns (uint8 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, map.slot)\n            mstore(0x00, shr(5, index))\n            result := byte(and(31, not(index)), sload(keccak256(0x00, 0x40)))\n        }\n    }\n\n    /// @dev Updates the uint8 value at `index` in `map`.\n    function set(Uint8Map storage map, uint256 index, uint8 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, map.slot)\n            mstore(0x00, shr(5, index))\n            let s := keccak256(0x00, 0x40) // Storage slot.\n            mstore(0x00, sload(s))\n            mstore8(and(31, not(index)), value)\n            sstore(s, mload(0x00))\n        }\n    }\n\n    /// @dev Returns the uint16 value at `index` in `map`.\n    function get(Uint16Map storage map, uint256 index) internal view returns (uint16 result) {\n        result = uint16(map.map[index >> 4] >> ((index & 15) << 4));\n    }\n\n    /// @dev Updates the uint16 value at `index` in `map`.\n    function set(Uint16Map storage map, uint256 index, uint16 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, map.slot)\n            mstore(0x00, shr(4, index))\n            let s := keccak256(0x00, 0x40) // Storage slot.\n            let o := shl(4, and(index, 15)) // Storage slot offset (bits).\n            let v := sload(s) // Storage slot value.\n            let m := 0xffff // Value mask.\n            sstore(s, xor(v, shl(o, and(m, xor(shr(o, v), value)))))\n        }\n    }\n\n    /// @dev Returns the uint32 value at `index` in `map`.\n    function get(Uint32Map storage map, uint256 index) internal view returns (uint32 result) {\n        result = uint32(map.map[index >> 3] >> ((index & 7) << 5));\n    }\n\n    /// @dev Updates the uint32 value at `index` in `map`.\n    function set(Uint32Map storage map, uint256 index, uint32 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, map.slot)\n            mstore(0x00, shr(3, index))\n            let s := keccak256(0x00, 0x40) // Storage slot.\n            let o := shl(5, and(index, 7)) // Storage slot offset (bits).\n            let v := sload(s) // Storage slot value.\n            let m := 0xffffffff // Value mask.\n            sstore(s, xor(v, shl(o, and(m, xor(shr(o, v), value)))))\n        }\n    }\n\n    /// @dev Returns the uint40 value at `index` in `map`.\n    function get(Uint40Map storage map, uint256 index) internal view returns (uint40 result) {\n        unchecked {\n            result = uint40(map.map[index / 6] >> ((index % 6) * 40));\n        }\n    }\n\n    /// @dev Updates the uint40 value at `index` in `map`.\n    function set(Uint40Map storage map, uint256 index, uint40 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, map.slot)\n            mstore(0x00, div(index, 6))\n            let s := keccak256(0x00, 0x40) // Storage slot.\n            let o := mul(40, mod(index, 6)) // Storage slot offset (bits).\n            let v := sload(s) // Storage slot value.\n            let m := 0xffffffffff // Value mask.\n            sstore(s, xor(v, shl(o, and(m, xor(shr(o, v), value)))))\n        }\n    }\n\n    /// @dev Returns the uint64 value at `index` in `map`.\n    function get(Uint64Map storage map, uint256 index) internal view returns (uint64 result) {\n        result = uint64(map.map[index >> 2] >> ((index & 3) << 6));\n    }\n\n    /// @dev Updates the uint64 value at `index` in `map`.\n    function set(Uint64Map storage map, uint256 index, uint64 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, map.slot)\n            mstore(0x00, shr(2, index))\n            let s := keccak256(0x00, 0x40) // Storage slot.\n            let o := shl(6, and(index, 3)) // Storage slot offset (bits).\n            let v := sload(s) // Storage slot value.\n            let m := 0xffffffffffffffff // Value mask.\n            sstore(s, xor(v, shl(o, and(m, xor(shr(o, v), value)))))\n        }\n    }\n\n    /// @dev Returns the uint128 value at `index` in `map`.\n    function get(Uint128Map storage map, uint256 index) internal view returns (uint128 result) {\n        result = uint128(map.map[index >> 1] >> ((index & 1) << 7));\n    }\n\n    /// @dev Updates the uint128 value at `index` in `map`.\n    function set(Uint128Map storage map, uint256 index, uint128 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, map.slot)\n            mstore(0x00, shr(1, index))\n            let s := keccak256(0x00, 0x40) // Storage slot.\n            let o := shl(7, and(index, 1)) // Storage slot offset (bits).\n            let v := sload(s) // Storage slot value.\n            let m := 0xffffffffffffffffffffffffffffffff // Value mask.\n            sstore(s, xor(v, shl(o, and(m, xor(shr(o, v), value)))))\n        }\n    }\n\n    /// @dev Returns the value at `index` in `map`.\n    function get(mapping(uint256 => uint256) storage map, uint256 index, uint256 bitWidth)\n        internal\n        view\n        returns (uint256 result)\n    {\n        unchecked {\n            uint256 d = _rawDiv(256, bitWidth); // Bucket size.\n            uint256 m = (1 << bitWidth) - 1; // Value mask.\n            result = (map[_rawDiv(index, d)] >> (_rawMod(index, d) * bitWidth)) & m;\n        }\n    }\n\n    /// @dev Updates the value at `index` in `map`.\n    function set(\n        mapping(uint256 => uint256) storage map,\n        uint256 index,\n        uint256 value,\n        uint256 bitWidth\n    ) internal {\n        unchecked {\n            uint256 d = _rawDiv(256, bitWidth); // Bucket size.\n            uint256 m = (1 << bitWidth) - 1; // Value mask.\n            uint256 o = _rawMod(index, d) * bitWidth; // Storage slot offset (bits).\n            map[_rawDiv(index, d)] ^= (((map[_rawDiv(index, d)] >> o) ^ value) & m) << o;\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       BINARY SEARCH                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // The following functions search in the range of [`start`, `end`)\n    // (i.e. `start <= index < end`).\n    // The range must be sorted in ascending order.\n    // `index` precedence: equal to > nearest before > nearest after.\n    // An invalid search range will simply return `(found = false, index = start)`.\n\n    /// @dev Returns whether `map` contains `needle`, and the index of `needle`.\n    function searchSorted(Uint8Map storage map, uint8 needle, uint256 start, uint256 end)\n        internal\n        view\n        returns (bool found, uint256 index)\n    {\n        return searchSorted(map.map, needle, start, end, 8);\n    }\n\n    /// @dev Returns whether `map` contains `needle`, and the index of `needle`.\n    function searchSorted(Uint16Map storage map, uint16 needle, uint256 start, uint256 end)\n        internal\n        view\n        returns (bool found, uint256 index)\n    {\n        return searchSorted(map.map, needle, start, end, 16);\n    }\n\n    /// @dev Returns whether `map` contains `needle`, and the index of `needle`.\n    function searchSorted(Uint32Map storage map, uint32 needle, uint256 start, uint256 end)\n        internal\n        view\n        returns (bool found, uint256 index)\n    {\n        return searchSorted(map.map, needle, start, end, 32);\n    }\n\n    /// @dev Returns whether `map` contains `needle`, and the index of `needle`.\n    function searchSorted(Uint40Map storage map, uint40 needle, uint256 start, uint256 end)\n        internal\n        view\n        returns (bool found, uint256 index)\n    {\n        return searchSorted(map.map, needle, start, end, 40);\n    }\n\n    /// @dev Returns whether `map` contains `needle`, and the index of `needle`.\n    function searchSorted(Uint64Map storage map, uint64 needle, uint256 start, uint256 end)\n        internal\n        view\n        returns (bool found, uint256 index)\n    {\n        return searchSorted(map.map, needle, start, end, 64);\n    }\n\n    /// @dev Returns whether `map` contains `needle`, and the index of `needle`.\n    function searchSorted(Uint128Map storage map, uint128 needle, uint256 start, uint256 end)\n        internal\n        view\n        returns (bool found, uint256 index)\n    {\n        return searchSorted(map.map, needle, start, end, 128);\n    }\n\n    /// @dev Returns whether `map` contains `needle`, and the index of `needle`.\n    function searchSorted(\n        mapping(uint256 => uint256) storage map,\n        uint256 needle,\n        uint256 start,\n        uint256 end,\n        uint256 bitWidth\n    ) internal view returns (bool found, uint256 index) {\n        unchecked {\n            if (start >= end) end = start;\n            uint256 t;\n            uint256 o = start - 1; // Offset to derive the actual index.\n            uint256 l = 1; // Low.\n            uint256 d = _rawDiv(256, bitWidth); // Bucket size.\n            uint256 m = (1 << bitWidth) - 1; // Value mask.\n            uint256 h = end - start; // High.\n            while (true) {\n                index = (l & h) + ((l ^ h) >> 1);\n                if (l > h) break;\n                t = (map[_rawDiv(index + o, d)] >> (_rawMod(index + o, d) * bitWidth)) & m;\n                if (t == needle) break;\n                if (needle <= t) h = index - 1;\n                else l = index + 1;\n            }\n            /// @solidity memory-safe-assembly\n            assembly {\n                m := or(iszero(index), iszero(bitWidth))\n                found := iszero(or(xor(t, needle), m))\n                index := add(o, xor(index, mul(xor(index, 1), m)))\n            }\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      PRIVATE HELPERS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns `x / y`, returning 0 if `y` is zero.\n    function _rawDiv(uint256 x, uint256 y) private pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := div(x, y)\n        }\n    }\n\n    /// @dev Returns `x % y`, returning 0 if `y` is zero.\n    function _rawMod(uint256 x, uint256 y) private pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mod(x, y)\n        }\n    }\n}\n"
    },
    "solidity-bytes-utils/contracts/BytesLib.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\n/*\n * @title Solidity Bytes Arrays Utils\n * @author Gonçalo Sá <goncalo.sa@consensys.net>\n *\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\n */\npragma solidity >=0.8.0 <0.9.0;\n\n\nlibrary BytesLib {\n    function concat(\n        bytes memory _preBytes,\n        bytes memory _postBytes\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        bytes memory tempBytes;\n\n        assembly {\n            // Get a location of some free memory and store it in tempBytes as\n            // Solidity does for memory variables.\n            tempBytes := mload(0x40)\n\n            // Store the length of the first bytes array at the beginning of\n            // the memory for tempBytes.\n            let length := mload(_preBytes)\n            mstore(tempBytes, length)\n\n            // Maintain a memory counter for the current write location in the\n            // temp bytes array by adding the 32 bytes for the array length to\n            // the starting location.\n            let mc := add(tempBytes, 0x20)\n            // Stop copying when the memory counter reaches the length of the\n            // first bytes array.\n            let end := add(mc, length)\n\n            for {\n                // Initialize a copy counter to the start of the _preBytes data,\n                // 32 bytes into its memory.\n                let cc := add(_preBytes, 0x20)\n            } lt(mc, end) {\n                // Increase both counters by 32 bytes each iteration.\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                // Write the _preBytes data into the tempBytes memory 32 bytes\n                // at a time.\n                mstore(mc, mload(cc))\n            }\n\n            // Add the length of _postBytes to the current length of tempBytes\n            // and store it as the new length in the first 32 bytes of the\n            // tempBytes memory.\n            length := mload(_postBytes)\n            mstore(tempBytes, add(length, mload(tempBytes)))\n\n            // Move the memory counter back from a multiple of 0x20 to the\n            // actual end of the _preBytes data.\n            mc := end\n            // Stop copying when the memory counter reaches the new combined\n            // length of the arrays.\n            end := add(mc, length)\n\n            for {\n                let cc := add(_postBytes, 0x20)\n            } lt(mc, end) {\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                mstore(mc, mload(cc))\n            }\n\n            // Update the free-memory pointer by padding our last write location\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\n            // next 32 byte block, then round down to the nearest multiple of\n            // 32. If the sum of the length of the two arrays is zero then add\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\n            mstore(0x40, and(\n              add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n              not(31) // Round down to the nearest 32 bytes.\n            ))\n        }\n\n        return tempBytes;\n    }\n\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\n        assembly {\n            // Read the first 32 bytes of _preBytes storage, which is the length\n            // of the array. (We don't need to use the offset into the slot\n            // because arrays use the entire slot.)\n            let fslot := sload(_preBytes.slot)\n            // Arrays of 31 bytes or less have an even value in their slot,\n            // while longer arrays have an odd value. The actual length is\n            // the slot divided by two for odd values, and the lowest order\n            // byte divided by two for even values.\n            // If the slot is even, bitwise and the slot with 255 and divide by\n            // two to get the length. If the slot is odd, bitwise and the slot\n            // with -1 and divide by two.\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n            let newlength := add(slength, mlength)\n            // slength can contain both the length and contents of the array\n            // if length < 32 bytes so let's prepare for that\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n            switch add(lt(slength, 32), lt(newlength, 32))\n            case 2 {\n                // Since the new array still fits in the slot, we just need to\n                // update the contents of the slot.\n                // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\n                sstore(\n                    _preBytes.slot,\n                    // all the modifications to the slot are inside this\n                    // next block\n                    add(\n                        // we can just add to the slot contents because the\n                        // bytes we want to change are the LSBs\n                        fslot,\n                        add(\n                            mul(\n                                div(\n                                    // load the bytes from memory\n                                    mload(add(_postBytes, 0x20)),\n                                    // zero all bytes to the right\n                                    exp(0x100, sub(32, mlength))\n                                ),\n                                // and now shift left the number of bytes to\n                                // leave space for the length in the slot\n                                exp(0x100, sub(32, newlength))\n                            ),\n                            // increase length by the double of the memory\n                            // bytes length\n                            mul(mlength, 2)\n                        )\n                    )\n                )\n            }\n            case 1 {\n                // The stored value fits in the slot, but the combined value\n                // will exceed it.\n                // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes.slot)\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n                // save new length\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n                // The contents of the _postBytes array start 32 bytes into\n                // the structure. Our first read should obtain the `submod`\n                // bytes that can fit into the unused space in the last word\n                // of the stored array. To get this, we read 32 bytes starting\n                // from `submod`, so the data we read overlaps with the array\n                // contents by `submod` bytes. Masking the lowest-order\n                // `submod` bytes allows us to add that value directly to the\n                // stored value.\n\n                let submod := sub(32, slength)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(\n                    sc,\n                    add(\n                        and(\n                            fslot,\n                            0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\n                        ),\n                        and(mload(mc), mask)\n                    )\n                )\n\n                for {\n                    mc := add(mc, 0x20)\n                    sc := add(sc, 1)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n            default {\n                // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes.slot)\n                // Start copying to the last used word of the stored array.\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n                // save new length\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n                // Copy over the first `submod` bytes of the new data as in\n                // case 1 above.\n                let slengthmod := mod(slength, 32)\n                let mlengthmod := mod(mlength, 32)\n                let submod := sub(32, slengthmod)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\n\n                for {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n        }\n    }\n\n    function slice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        require(_length + 31 >= _length, \"slice_overflow\");\n        require(_bytes.length >= _start + _length, \"slice_outOfBounds\");\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n                // Get a location of some free memory and store it in tempBytes as\n                // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n                // The first word of the slice result is potentially a partial\n                // word read from the original array. To read it, we calculate\n                // the length of that partial word and start copying that many\n                // bytes into the array. The first word we copy will start with\n                // data we don't care about, but the last `lengthmod` bytes will\n                // land at the beginning of the contents of the new array. When\n                // we're done copying, we overwrite the full first word with\n                // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n                // The multiplication in the next line is necessary\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n                // the following copy loop was copying the origin's length\n                // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                    // The multiplication in the next line has the same exact purpose\n                    // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n                //update free-memory pointer\n                //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n                //zero out the 32 bytes slice we are about to return\n                //we need to do it because Solidity does not garbage collect\n                mstore(tempBytes, 0)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\n        require(_bytes.length >= _start + 20, \"toAddress_outOfBounds\");\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n        }\n\n        return tempAddress;\n    }\n\n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\n        require(_bytes.length >= _start + 1 , \"toUint8_outOfBounds\");\n        uint8 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x1), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint16(bytes memory _bytes, uint256 _start) internal pure returns (uint16) {\n        require(_bytes.length >= _start + 2, \"toUint16_outOfBounds\");\n        uint16 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x2), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32) {\n        require(_bytes.length >= _start + 4, \"toUint32_outOfBounds\");\n        uint32 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x4), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint64(bytes memory _bytes, uint256 _start) internal pure returns (uint64) {\n        require(_bytes.length >= _start + 8, \"toUint64_outOfBounds\");\n        uint64 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x8), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint96(bytes memory _bytes, uint256 _start) internal pure returns (uint96) {\n        require(_bytes.length >= _start + 12, \"toUint96_outOfBounds\");\n        uint96 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0xc), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint128(bytes memory _bytes, uint256 _start) internal pure returns (uint128) {\n        require(_bytes.length >= _start + 16, \"toUint128_outOfBounds\");\n        uint128 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x10), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\n        require(_bytes.length >= _start + 32, \"toUint256_outOfBounds\");\n        uint256 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {\n        require(_bytes.length >= _start + 32, \"toBytes32_outOfBounds\");\n        bytes32 tempBytes32;\n\n        assembly {\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempBytes32;\n    }\n\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\n        bool success = true;\n\n        assembly {\n            let length := mload(_preBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(length, mload(_postBytes))\n            case 1 {\n                // cb is a circuit breaker in the for loop since there's\n                //  no said feature for inline assembly loops\n                // cb = 1 - don't breaker\n                // cb = 0 - break\n                let cb := 1\n\n                let mc := add(_preBytes, 0x20)\n                let end := add(mc, length)\n\n                for {\n                    let cc := add(_postBytes, 0x20)\n                // the next line is the loop condition:\n                // while(uint256(mc < end) + cb == 2)\n                } eq(add(lt(mc, end), cb), 2) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    // if any of these checks fails then arrays are not equal\n                    if iszero(eq(mload(mc), mload(cc))) {\n                        // unsuccess:\n                        success := 0\n                        cb := 0\n                    }\n                }\n            }\n            default {\n                // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n\n    function equalStorage(\n        bytes storage _preBytes,\n        bytes memory _postBytes\n    )\n        internal\n        view\n        returns (bool)\n    {\n        bool success = true;\n\n        assembly {\n            // we know _preBytes_offset is 0\n            let fslot := sload(_preBytes.slot)\n            // Decode the length of the stored array like in concatStorage().\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(slength, mlength)\n            case 1 {\n                // slength can contain both the length and contents of the array\n                // if length < 32 bytes so let's prepare for that\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n                if iszero(iszero(slength)) {\n                    switch lt(slength, 32)\n                    case 1 {\n                        // blank the last byte which is the length\n                        fslot := mul(div(fslot, 0x100), 0x100)\n\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\n                            // unsuccess:\n                            success := 0\n                        }\n                    }\n                    default {\n                        // cb is a circuit breaker in the for loop since there's\n                        //  no said feature for inline assembly loops\n                        // cb = 1 - don't breaker\n                        // cb = 0 - break\n                        let cb := 1\n\n                        // get the keccak hash to get the contents of the array\n                        mstore(0x0, _preBytes.slot)\n                        let sc := keccak256(0x0, 0x20)\n\n                        let mc := add(_postBytes, 0x20)\n                        let end := add(mc, mlength)\n\n                        // the next line is the loop condition:\n                        // while(uint256(mc < end) + cb == 2)\n                        for {} eq(add(lt(mc, end), cb), 2) {\n                            sc := add(sc, 1)\n                            mc := add(mc, 0x20)\n                        } {\n                            if iszero(eq(sload(sc), mload(mc))) {\n                                // unsuccess:\n                                success := 0\n                                cb := 0\n                            }\n                        }\n                    }\n                }\n            }\n            default {\n                // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "viaIR": true,
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}