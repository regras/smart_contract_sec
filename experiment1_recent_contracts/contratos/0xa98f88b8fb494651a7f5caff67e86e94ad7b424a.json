{{
  "language": "Solidity",
  "sources": {
    "src/CompoundV3Helper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Based on https://github.com/compound-developers/compound-3-developer-faq\npragma solidity 0.8.28;\n\n\nlibrary CometStructs {\n  struct AssetInfo {\n    uint8 offset;\n    address asset;\n    address priceFeed;\n    uint64 scale;\n    uint64 borrowCollateralFactor;\n    uint64 liquidateCollateralFactor;\n    uint64 liquidationFactor;\n    uint128 supplyCap;\n  }\n\n  struct UserBasic {\n    int104 principal;\n    uint64 baseTrackingIndex;\n    uint64 baseTrackingAccrued;\n    uint16 assetsIn;\n    uint8 _reserved;\n  }\n\n  struct TotalsBasic {\n    uint64 baseSupplyIndex;\n    uint64 baseBorrowIndex;\n    uint64 trackingSupplyIndex;\n    uint64 trackingBorrowIndex;\n    uint104 totalSupplyBase;\n    uint104 totalBorrowBase;\n    uint40 lastAccrualTime;\n    uint8 pauseFlags;\n  }\n\n  struct UserCollateral {\n    uint128 balance;\n    uint128 _reserved;\n  }\n\n  struct RewardOwed {\n    address token;\n    uint owed;\n  }\n\n  struct TotalsCollateral {\n    uint128 totalSupplyAsset;\n    uint128 _reserved;\n  }\n\n  \n\n}\n\ninterface Comet {\n  \n  function baseScale() external view returns (uint);\n  function supply(address asset, uint amount) external;\n  function withdraw(address asset, uint amount) external;\n\n  function getSupplyRate(uint utilization) external view returns (uint);\n  function getBorrowRate(uint utilization) external view returns (uint);\n\n  function getAssetInfoByAddress(address asset) external view returns (CometStructs.AssetInfo memory);\n  function getAssetInfo(uint8 i) external view returns (CometStructs.AssetInfo memory);\n\n\n  function getPrice(address priceFeed) external view returns (uint128);\n\n  function userBasic(address) external view returns (CometStructs.UserBasic memory);\n  function totalsBasic() external view returns (CometStructs.TotalsBasic memory);\n  function userCollateral(address, address) external view returns (CometStructs.UserCollateral memory);\n\n  function baseTokenPriceFeed() external view returns (address);\n\n  function numAssets() external view returns (uint8);\n\n  function getUtilization() external view returns (uint);\n\n  function baseTrackingSupplySpeed() external view returns (uint);\n  function baseTrackingBorrowSpeed() external view returns (uint);\n\n  function totalSupply() external view returns (uint256);\n  function totalBorrow() external view returns (uint256);\n\n  function baseIndexScale() external pure returns (uint64);\n\n  function totalsCollateral(address asset) external view returns (CometStructs.TotalsCollateral memory);\n\n  function baseMinForRewards() external view returns (uint256);\n  function baseToken() external view returns (address);\n}\n\ninterface CometRewards {\n  function getRewardOwed(address comet, address account) external returns (CometStructs.RewardOwed memory);\n  function claim(address comet, address src, bool shouldAccrue) external;\n}\n\ninterface ERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address to, uint256 value) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 value) external returns (bool);\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n    function decimals() external view returns(uint8);\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n}\n\ncontract CompoundV3Helper {\n\n    struct SupplyRate {\n    uint256 baseAPR;\n    uint256 rewardAPR;\n    uint256 blockHeight;\n  }\n  //address public cometAddress;\n  uint constant public DAYS_PER_YEAR = 365;\n  uint constant public SECONDS_PER_DAY = 60 * 60 * 24;\n  uint constant public SECONDS_PER_YEAR = SECONDS_PER_DAY * DAYS_PER_YEAR;\n  //uint public BASE_MANTISSA;\n  //uint public BASE_INDEX_SCALE;\n  uint constant public MAX_UINT = type(uint).max;\n  address immutable public REWARD_PRICE_FEED;\n\n\n  constructor(address _rewardPriceFeed) {\n    REWARD_PRICE_FEED = _rewardPriceFeed;\n  }\n\n\n  function BASE_MANTISSA(address _cometAddress) public view returns(uint256) {\n    return Comet(_cometAddress).baseScale();\n\n  }\n\n  function BASE_INDEX_SCALE(address _cometAddress) public view returns(uint256) {\n    return Comet(_cometAddress).baseIndexScale();\n  }\n\n\n  /*\n   * Get the current borrow APR in Compound III\n   */\n  function getBorrowApr(address _cometAddress) public view returns (uint) {\n    Comet comet = Comet(_cometAddress);\n    uint utilization = comet.getUtilization();\n    return comet.getBorrowRate(utilization) * SECONDS_PER_YEAR * 100;\n  }\n\n  function getSupplyRateAndTvl(address _cometAddress) external view returns(SupplyRate memory rate, uint256 baseTokenTvl) {\n    rate.blockHeight = block.number;\n    rate.baseAPR = getSupplyApr(_cometAddress);\n    rate.rewardAPR = getRewardAprForSupplyBase(_cometAddress, REWARD_PRICE_FEED); \n    baseTokenTvl = getBaseTokenTvl(_cometAddress);\n  }\n\n  /*\n   * Get the current supply APR in Compound III\n   */\n  function getSupplyApr(address _cometAddress) public view returns (uint) {\n    Comet comet = Comet(_cometAddress);\n    uint utilization = comet.getUtilization();\n    return comet.getSupplyRate(utilization) * SECONDS_PER_YEAR * 100;\n  }\n\n  /*\n   * Get the current reward for supplying APR in Compound III\n   * @param rewardTokenPriceFeed The address of the reward token (e.g. COMP) price feed\n   * @return The reward APR in USD as a decimal scaled up by 1e18\n   */\n  function getRewardAprForSupplyBase(address _cometAddress, address rewardTokenPriceFeed) public view returns (uint) {\n    Comet comet = Comet(_cometAddress);\n    uint rewardTokenPriceInUsd = getCompoundPrice(_cometAddress, rewardTokenPriceFeed);\n    uint usdcPriceInUsd = getCompoundPrice(_cometAddress, comet.baseTokenPriceFeed());\n    uint usdcTotalSupply = comet.totalSupply();\n    uint baseTrackingSupplySpeed = comet.baseTrackingSupplySpeed();\n    uint rewardToSuppliersPerDay = baseTrackingSupplySpeed * SECONDS_PER_DAY * BASE_INDEX_SCALE(_cometAddress) / BASE_MANTISSA(_cometAddress);\n    \n    // this is tech multiplyer\n    uint256 scale;\n    if (comet.baseScale() == 1e18 ) {\n        scale = 24;\n    }\n    uint supplyBaseRewardApr = rewardTokenPriceInUsd * rewardToSuppliersPerDay * DAYS_PER_YEAR * 10**scale \n        / (usdcTotalSupply * usdcPriceInUsd);\n    return supplyBaseRewardApr;\n  }\n\n  \n\n  /*\n   * Get the current reward for borrowing APR in Compound III\n   * @param rewardTokenPriceFeed The address of the reward token (e.g. COMP) price feed\n   * @return The reward APR in USD as a decimal scaled up by 1e18\n   */\n  function getRewardAprForBorrowBase(address _cometAddress, address rewardTokenPriceFeed) public view returns (uint) {\n    Comet comet = Comet(_cometAddress);\n    uint rewardTokenPriceInUsd = getCompoundPrice(_cometAddress, rewardTokenPriceFeed);\n    uint usdcPriceInUsd = getCompoundPrice(_cometAddress, comet.baseTokenPriceFeed());\n    uint usdcTotalBorrow = comet.totalBorrow();\n    uint baseTrackingBorrowSpeed = comet.baseTrackingBorrowSpeed();\n    uint rewardToSuppliersPerDay = baseTrackingBorrowSpeed * SECONDS_PER_DAY * (BASE_INDEX_SCALE(_cometAddress) / BASE_MANTISSA(_cometAddress));\n    uint borrowBaseRewardApr = (rewardTokenPriceInUsd * rewardToSuppliersPerDay / (usdcTotalBorrow * usdcPriceInUsd)) * DAYS_PER_YEAR;\n    return borrowBaseRewardApr;\n  }\n\n\n\n  \n\n  /*\n   * Get the price feed address for an asset\n   */\n  function getPriceFeedAddress(address _cometAddress, address asset) public view returns (address) {\n    Comet comet = Comet(_cometAddress);\n    return comet.getAssetInfoByAddress(asset).priceFeed;\n  }\n\n  /*\n   * Get the price feed address for the base token\n   */\n  function getBaseTokenPriceFeed(address _cometAddress) public view returns (address) {\n    Comet comet = Comet(_cometAddress);\n    return comet.baseTokenPriceFeed();\n  }\n\n  /*\n   * Get the current price of an asset from the protocol's persepctive\n   */\n  function getCompoundPrice(address _cometAddress, address singleAssetPriceFeed) public view returns (uint) {\n    Comet comet = Comet(_cometAddress);\n    return comet.getPrice(singleAssetPriceFeed);\n  }\n\n  /*\n   * Gets the amount of reward tokens due to this contract address\n   */\n  function getRewardsOwed(address _cometAddress, address rewardsContract) public returns (uint) {\n    return CometRewards(rewardsContract).getRewardOwed(_cometAddress, address(this)).owed;\n  }\n\n\n\n  /*\n   * Gets the Compound III TVL in USD scaled up by 1e8\n   */\n  function getTvl(address _cometAddress) public view returns (uint) {\n    Comet comet = Comet(_cometAddress);\n\n    uint baseScale = 10 ** ERC20(_cometAddress).decimals();\n    uint basePrice = getCompoundPrice(_cometAddress, comet.baseTokenPriceFeed());\n    uint totalSupplyBase = comet.totalSupply();\n\n    uint tvlUsd = totalSupplyBase * basePrice / baseScale;\n\n    uint8 numAssets = comet.numAssets();\n    for (uint8 i = 0; i < numAssets; i++) {\n      CometStructs.AssetInfo memory asset = comet.getAssetInfo(i);\n      CometStructs.TotalsCollateral memory tc = comet.totalsCollateral(asset.asset);\n      uint price = getCompoundPrice(_cometAddress, asset.priceFeed);\n      uint scale = 10 ** ERC20(asset.asset).decimals();\n\n      tvlUsd += tc.totalSupplyAsset * price / scale;\n    }\n\n    return tvlUsd;\n  }\n  \n\n  /*\n   * Gets the Compound III TVL  of Base market token in USD scaled up by 1e8\n   */\n  function getBaseTokenTvl(address _cometAddress) public view returns (uint tvlUsd) {\n        Comet comet = Comet(_cometAddress);\n        //address baseTokenAddress = comet.baseToken();\n        uint baseScale = 10 ** ERC20(_cometAddress).decimals();\n        uint basePrice = getCompoundPrice(_cometAddress, comet.baseTokenPriceFeed());\n        uint totalSupplyBase = comet.totalSupply();\n        //uint256 totalSupplyBase = ERC20(baseTokenAddress).balanceOf(_cometAddress);\n        tvlUsd = totalSupplyBase * basePrice / baseScale;\n   }\n  \n}"
    }
  },
  "settings": {
    "remappings": [
      "@openzeppelin/=lib/openzeppelin-contracts/",
      "@Uopenzeppelin/=lib/openzeppelin-contracts-upgradeable.git/",
      "forge-std/=lib/forge-std/src/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "metadata": {
      "useLiteralContent": false,
      "bytecodeHash": "ipfs",
      "appendCBOR": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "evmVersion": "cancun",
    "viaIR": false,
    "libraries": {}
  }
}}