{{
  "language": "Solidity",
  "sources": {
    "contracts/WolfAMMToken.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.24;\n\n\n/*\n *\t\tWolf AMM Token\n *\n *  Manages liquidity with impermanent\n *  loss protection and smart re-entry\n *  to make fast gains on volatile\n *  tokens.\n *\n *  The contract allows one to mint\n *  tokens with ethereum or burn\n *  tokens to get ethereum back.\n *\n*/\n\n\nabstract contract Context {\n\tfunction _msgSender() internal view virtual returns (address) {\n\t\treturn msg.sender;\n\t}\n\n\tfunction _msgData() internal view virtual returns (bytes calldata) {\n\t\treturn msg.data;\n\t}\n}\n\n\ninterface IERC20 {\n\tfunction totalSupply() external view returns (uint256);\n\n\tfunction balanceOf(address account) external view returns (uint256);\n\n\tfunction transfer(address recipient, uint256 amount) external returns (bool);\n\n\tfunction decimals() external view returns (uint8);\n\n\tfunction allowance(\n\t\taddress owner,\n\t\taddress spender\n\t) external view returns (uint256);\n\n\tfunction approve(address spender, uint256 amount) external returns (bool);\n\n\tfunction transferFrom(\n\t\taddress sender,\n\t\taddress recipient,\n\t\tuint256 amount\n\t) external returns (bool);\n\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\n\tevent Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\nabstract contract Ownable is Context {\n\taddress private _owner;\n\n\tevent OwnershipTransferred(\n\t\taddress indexed previousOwner,\n\t\taddress indexed newOwner\n\t);\n\n\tconstructor() {\n\t\t_transferOwnership(_msgSender());\n\t}\n\n\tmodifier onlyOwner() {\n\t\t_checkOwner();\n\t\t_;\n\t}\n\n\tfunction owner() public view virtual returns (address) {\n\t\treturn _owner;\n\t}\n\n\tfunction _checkOwner() internal view virtual {\n\t\trequire(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n\t}\n\n\tfunction renounceOwnership() public virtual onlyOwner {\n\t\t_transferOwnership(address(0));\n\t}\n\n\tfunction transferOwnership(address newOwner) public virtual onlyOwner {\n\t\trequire(newOwner != address(0), \"Ownable: new owner is the zero address\");\n\t\t_transferOwnership(newOwner);\n\t}\n\n\tfunction _transferOwnership(address newOwner) internal virtual {\n\t\taddress oldOwner = _owner;\n\t\t_owner = newOwner;\n\t\temit OwnershipTransferred(oldOwner, newOwner);\n\t}\n}\n\n\n// Abridged to contain only what we need\nabstract contract IHoldingContractUtils {\n\t// PRICE DATA\n\n\tfunction getTwapPriceP12(int8 decimalDiff, address base, address quote, uint32 duration) public virtual view returns (uint80 price12);\n\tfunction getTwapPricePX96(address poolAddress, address base, address quote, uint32 duration) public virtual view returns (uint256 priceX96);\n\tfunction safeGetPriceUSDC12Of(address token) public virtual view returns (uint80 price12);\n\tfunction safeGetPrice12Of(address base, address quote) public virtual view returns (uint80 price12);\n\tfunction value12OfTokensAgainst(address token, address quote, uint256 quantity) external virtual view returns (uint128 value12);\n\n\t// Primary should either be USDC or address(0), indicating Eth.  This will save the contract address\n\t// for the pool this contract can use later. \n\tfunction findV3PoolFor(address base, address quote, uint128 minValueUSDC12) public virtual returns (address bestPool);\n}\n\n\nabstract contract IAssetHolder {\n\n\tfunction getTotalValueUsd12() public virtual view returns (uint128 valueUsd12);\n\tfunction getTotalValueEth12() public virtual view returns (uint128 valueEth12);\n\tfunction getUsd12ValueIn(address token) public virtual view returns (uint128 valueUsd12);\n\n}\n\ninterface RunnableTask {\n\tfunction execute(uint256 handle) external;\n}\n\n\ninterface RunnableChecker {\n\tfunction shouldExecute(uint256 handle) external view returns (bool);\n}\n\n\n// Abridged: Just what we need\nabstract contract ITaskEngine is Ownable, RunnableChecker {\n\n\t// Ticking and Execution functions\n\tfunction piggybackTick() external virtual;\n}\n\n\ninterface IAutomationToken is IERC20 {\n\tfunction getTaskEngine() external view returns (ITaskEngine taskEngine);\n}\n\n\nabstract contract BasicPurchasableERC20 is IERC20 {\n\t// Returns in units of eth per token, scaled to 1e12.\n\t// Note that it is eth vs your token, not counting decimals, so if your token\n\t// has 18 decimals then to get the raw uint256 token amount you \n\tfunction getBuyPrice() public virtual view returns (uint80);\n\tfunction getSellPrice() public virtual view returns (uint80);\n\n\t// This will revert if you do not send enough.\n\tfunction buyTokens(uint256 tokens, address receiver) public virtual payable;\n\t// This requires that your balance is high enough AND that you've\n\t// approved this contract to spend your balance.\n\tfunction sellTokens(uint256 tokens, address receiver) external virtual;\n\n\tevent TokensBought(uint256 tokens, uint256 cost, uint80 priceEth12, uint80 priceUsd12, uint256 totalSupply);\n\tevent TokensSold(uint256 tokens, uint256 cost, uint80 priceEth12, uint80 priceUsd12, uint256 totalSupply);\n\n\n\taddress constant DEAD = 0x000000000000000000000000000000000000dEaD;\n\taddress constant ZERO = 0x0000000000000000000000000000000000000000;\n\n\n\tstring _name;\n\tstring _symbol;\n\tuint8 immutable _decimals;\n\n\tuint256 _totalSupply = 0;\n\n\tmapping(address => uint256) _balances;\n\tmapping(address => mapping(address => uint256)) _allowances;\n\n\tconstructor(string memory initName, string memory initSymbol, uint8 initDecimals) {\n\t\t_name = initName;\n\t\t_symbol = initSymbol;\n\t\t_decimals = initDecimals;\n\t}\n\n\n\tfunction totalSupply() external view override returns (uint256) {\n\t\treturn _totalSupply;\n\t}\n\n\tfunction decimals() external view returns (uint8) {\n\t\treturn _decimals;\n\t}\n\n\tfunction symbol() external view returns (string memory) {\n\t\treturn _symbol;\n\t}\n\n\tfunction name() external view returns (string memory) {\n\t\treturn _name;\n\t}\n\n\tfunction balanceOf(address account) public view override returns (uint256) {\n\t\treturn _balances[account];\n\t}\n\n\tfunction transfer(address to, uint tokens) public virtual override returns (bool success) {\n\t\trequire(to != address(0), \"Invalid address\");\n\t\trequire(tokens <= _balances[msg.sender], \"Insufficient funds\");\n\n\t\t_transfer(to, msg.sender, tokens);\n\n\t\treturn true;\n\t}\n\n\tfunction approve(address spender, uint tokens) public virtual override returns (bool success) {\n\t\t_allowances[msg.sender][spender] = tokens;\n\t\temit Approval(msg.sender, spender, tokens);\n\n\t\treturn true;\n\t}\n\n\tfunction allowance(address holder, address spender) external view override returns (uint256) {\n\t\treturn _allowances[holder][spender];\n\t}\n\n\tfunction transferFrom(address from, address to, uint tokens) public virtual override returns (bool success) {\n\t\trequire(to != address(0x0), \"Invalid address\");\n\t\trequire(tokens <= _allowances[from][msg.sender], \"Allowance exceeded\");\n\t\t_allowances[from][msg.sender] = _allowances[from][msg.sender] - tokens;\n\t\t_transfer(to, from, tokens);\n\n\t\treturn true;\n\t}\n\n\tfunction _transfer(address to, address from, uint256 tokens) internal {\n\t\trequire(_balances[from] >= tokens || from == address(0), \"Insufficient funds\");\n\n\t\tif (from != address(0x0))\n\t\t\t_balances[from] -= tokens;\n\t\telse\n\t\t\t_totalSupply += tokens;\n\n\t\tif (to != address(0x0))\n\t\t\t_balances[to] += tokens;\n\t\telse\n\t\t\t_totalSupply -= tokens;\n\n\t\temit Transfer(from, to, uint(tokens));\n\t}\n\n\tfunction approveMaxAmount(address spender) external returns (bool) {\n\t\treturn approve(spender, type(uint256).max);\n\t}\n\n\tfunction getCirculatingSupply() public view returns (uint256) {\n\t\treturn _totalSupply - (balanceOf(DEAD) + balanceOf(ZERO));\n\t}\n}\n\n\ninterface IWolfAMMControllerV0 {\n\tfunction prepareWithdraw(uint256 amtEth) external;\n\tfunction prepareWithdrawAll() external;\n\tfunction onDeposit(uint256 howMuch) external;\n\n\tevent TradeExecuted(address targetToken, uint80 price);\n\tevent AutomationStarted(uint80 price);\n\tevent SawBetterPrice(uint80 price);\n}\n\n\nabstract contract IDepositable is IAssetHolder {\n\n\t// ADMINISTRATION\n\n\tfunction getFunder() external virtual view returns (address _funder);\n\tfunction setFunder(address newFunder) external virtual;\n\n\t// DEPOSITS\n\n\tfunction depositToken(address token, uint256 amount) external virtual;\n\tfunction depositEth() external virtual payable;\n\n\t// WITHDRAWS\n\n\tfunction withdrawEth(address destination, uint256 amount) external virtual;\n\tfunction withdrawToken(address token, address destination, uint256 amount) external virtual;\n\n\t// EVENTS\n\n\tevent FunderSet(address newController, address oldController);\n\tevent Deposited(address token, uint256 amount);\n\tevent Withdrawn(address token, uint256 amount);\n}\n\ncontract WolfAMMToken is Ownable, BasicPurchasableERC20 {\n\n\taddress internal immutable WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n\tuint80 public lastPriceUsd12 = 1e12;\n\n\t// Automation stuff\n\tIAutomationToken public automator = IAutomationToken(0xaAa000e1b72bf8DFA74C958e19E925C0bFAE9dEd);\n\n\t// External contracts\n\tIHoldingContractUtils public utils;\n\tIWolfAMMControllerV0 public bot;\n\tIDepositable public holdingContract;\n\n\tmapping(address => bool) isWhitelistedForMint;\n\tbool isMintWhitelistEnabled = true;\n\n\n\tconstructor(address utilsAdr, address holdingAdr, IERC20 oldContract, address botAdr, address[] memory recipients) BasicPurchasableERC20(\"Wolf AMM\", \"WAMM\", 6) {\n\t\tisWhitelistedForMint[msg.sender] = true;\n\n\t\t// Set up contract addresses\n\t\tholdingContract = IDepositable(holdingAdr);\n\t\tutils = IHoldingContractUtils(utilsAdr);\n\t\tbot = IWolfAMMControllerV0(botAdr);\n\n\t\tfor (uint8 i = 0; i < recipients.length; ++i) {\n\t\t\t_transfer(recipients[i], address(0), oldContract.balanceOf(recipients[i]));\n\t\t}\n\t}\n\n\n\t// ADMINISTRATION\n\n\t// Only trusted addresses will mint/burn in the beginning just in case of security issues\n\n\tfunction setAdrCanMint(address adr, bool canOrNot) external onlyOwner {\n\t\tisWhitelistedForMint[adr] = canOrNot;\n\t}\n\n\tfunction setMintWhitelist(bool enabled) external onlyOwner {\n\t\tisMintWhitelistEnabled = enabled;\n\t}//0x7D02c1C43a188c6cEbAfD2A59919F9b936289673\n\n\tfunction setBot(address botAdr) external onlyOwner {\n\t\tbot = IWolfAMMControllerV0(botAdr);\n\t}\n\n\tfunction migrateHoldingContract(address holdingAdr) external onlyOwner {\n\t\t// Withdraw everything from the previous contract first\n\n\t\tif (address(bot) != address(0)) {\n\t\t\tbot.prepareWithdrawAll();\n\t\t\tholdingContract.withdrawEth(address(this), address(holdingContract).balance);\n\t\t}\n\t\tholdingContract = IDepositable(holdingAdr);\n\t\tif (address(this).balance >= 1000)\n\t\t\tholdingContract.depositEth{value: address(this).balance}();\n\t}\n\n\tfunction setHoldingContract(address holdingAdr) external onlyOwner {\n\t\tholdingContract = IDepositable(holdingAdr);\n\t}\n\n\tfallback() external payable {\n\t\t// Allows holdingContract to send us eth\n\t}\n\n\treceive () external payable {\n\t\t// Allows holdingContract to send us eth\n\t}\n\n\n\t// MINTING AND BURNING FUNCTIONS\n\n\tfunction getBuyPrice() public override view returns (uint80) {\n\t\tif (_totalSupply == 0)\n\t\t\treturn uint80((uint256(lastPriceUsd12) * 101e10) / utils.safeGetPriceUSDC12Of(WETH));\n\t\telse\n\t\t\treturn uint80((uint256(holdingContract.getTotalValueEth12()) * (10**_decimals) * 129) / (_totalSupply << 7));\n\t}\n\n\tfunction getSellPrice() public override view returns (uint80) {\n\t\tif (_totalSupply == 0)\n\t\t\treturn uint80((uint256(lastPriceUsd12) * 99e10) / utils.safeGetPriceUSDC12Of(WETH));\n\t\telse\n\t\t\treturn uint80((uint256(holdingContract.getTotalValueEth12()) * (10**_decimals) * 127) / (_totalSupply << 7));\n\t}\n\n\t// This will revert if you do not send enough.\n\tfunction buyTokens(uint256 tokens, address receiver) public override payable {\n\t\tif (tokens == 0)\n\t\t\treturn;\n\n\t\trequire(isWhitelistedForMint[msg.sender] || !isMintWhitelistEnabled, \"Not whitelisted for minting.\");\n\n\t\tuint80 priceEth12 = getBuyPrice();\n\t\tuint256 transactionValue = (1 ether * uint256(priceEth12) * tokens) / (1e12 * (10**_decimals));\n\n\t\trequire(msg.value >= transactionValue, \"Not enough ethereum was sent\");\n\t\tpayable(msg.sender).transfer(msg.value - transactionValue);\n\n\t\t_transfer(receiver, address(0), tokens);\n\t\tholdingContract.depositEth{value: transactionValue}();\n\t\tbot.onDeposit(transactionValue);\n\n\t\tlastPriceUsd12 = uint80((uint256(priceEth12) * utils.safeGetPriceUSDC12Of(WETH)) / 1e12);\n\t}\n\n\tfunction sellTokens(uint256 tokens, address receiver) external override {\n\t\tif (tokens == 0)\n\t\t\treturn;\n\t\trequire(isWhitelistedForMint[msg.sender] || !isMintWhitelistEnabled, \"Not whitelisted for burning.\");\n\n\t\tuint80 priceEth12;\n\n        // Send eth\n\t\tif (_totalSupply > 500) {\n\t\t\tpriceEth12 = getSellPrice();\n\t\t\tuint256 transactionValue = (1 ether * uint256(priceEth12) * tokens) / (1e12 * (10**_decimals));\n\n\t\t\tbot.prepareWithdraw(transactionValue);\n\t\t\tholdingContract.withdrawEth(receiver, transactionValue);\n\n\t\t} else {\n\t\t\tuint256 balance = address(holdingContract).balance;\n\n\t\t\tbot.prepareWithdrawAll();\n\t\t\tholdingContract.withdrawEth(receiver, balance);\n\n\t\t\tpriceEth12 = uint80((balance * (10**_decimals)) / (tokens * 1e6));\n\t\t}\n\n\t\t// Burn the user's tokens\n        // We have to do this last because it alters totalSupply, which changes the price calculations.\n\t\t_transfer(address(0), msg.sender, tokens);\n\n\t\tlastPriceUsd12 = uint80((uint160(priceEth12) * utils.safeGetPriceUSDC12Of(WETH)) / 1e12);\n\t}\n\n\n\t// ADMINISTRATION FUNCTIONS\n\n\t// In case eth gets stuck in the contract (that should never happen but whatever)\n\tfunction rescueEth() external onlyOwner {\n\t\tpayable(owner()).transfer(address(this).balance);\n\t}\n\n\tfunction rescueTokens(address token) external onlyOwner {\n\t\tIERC20(token).transfer(owner(), IERC20(token).balanceOf(address(this)));\n\t}\n\n\tfunction transfer(address to, uint tokens) public override returns (bool success) {\n\t\tautomator.getTaskEngine().piggybackTick();\n\t\treturn super.transfer(to, tokens);\n\t}\n\n\tfunction approve(address spender, uint tokens) public override returns (bool success) {\n\t\tautomator.getTaskEngine().piggybackTick();\n\t\treturn super.approve(spender, tokens);\n\t}\n\n\tfunction transferFrom(address from, address to, uint tokens) public override returns (bool success) {\n\t\tautomator.getTaskEngine().piggybackTick();\n\t\treturn super.transferFrom(from, to, tokens);\n\t}\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 7770
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "remappings": []
  }
}}