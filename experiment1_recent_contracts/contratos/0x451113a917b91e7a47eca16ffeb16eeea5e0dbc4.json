{{
  "language": "Solidity",
  "sources": {
    "src/factory/FactorySNG.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.20;\n\nimport \"openzeppelin-math/Math.sol\";\nimport \"openzeppelin-contracts/access/manager/IAccessManager.sol\";\nimport \"openzeppelin-contracts-upgradeable/access/manager/AccessManagedUpgradeable.sol\";\nimport \"openzeppelin-contracts/proxy/beacon/BeaconProxy.sol\";\nimport \"openzeppelin-contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../interfaces/IFactorySNG.sol\";\nimport \"../interfaces/IStableSwapNGFactory.sol\";\nimport \"../interfaces/IRateAdjustmentOracle.sol\";\nimport \"../interfaces/IPrincipalToken.sol\";\nimport \"../interfaces/IRegistry.sol\";\nimport \"../interfaces/IStableSwapNG.sol\";\nimport \"../interfaces/IRateOracleRegistry.sol\";\nimport \"../libraries/CurvePoolUtil.sol\";\nimport \"../libraries/Roles.sol\";\n\n/**\n * @title Factory SNG\n * @author Spectra Finance\n * @notice Factory used to deploy Spectra core with Curve Stable Swap NG integration.\n */\ncontract FactorySNG is IFactorySNG, AccessManagedUpgradeable {\n    using SafeERC20 for IERC20;\n    using Math for uint256;\n\n    // Curve constants\n    uint256 constant IMPLEMENTATION_ID = 0;\n    uint8 constant PT_ASSET_TYPE = 1; // @dev: using an exchange rate oracle for PTs\n    uint8 constant IBT_ASSET_TYPE = 3; // @dev: no exchange rate oracle for IBTs\n\n    // hash of the first four bytes of the rate oracle exchange rate method\n    bytes4 constant RATE_ADJUSTMENT_ORACLE_METHOD_SIG = bytes4(keccak256(\"value()\"));\n\n    // selectors\n    bytes4 constant SET_INIT_PRICE_SELECTOR =\n        IRateAdjustmentOracle(address(0)).setInitialPrice.selector;\n\n    bytes4 constant PAUSE_SELECTOR = IPrincipalToken(address(0)).pause.selector;\n    bytes4 constant UNPAUSE_SELECTOR = IPrincipalToken(address(0)).unPause.selector;\n    bytes4 constant SET_REWARDS_PROXY_SELECTOR =\n        IPrincipalToken(address(0)).setRewardsProxy.selector;\n    bytes4 constant CLAIM_REWARDS_SELECTOR = IPrincipalToken(address(0)).claimRewards.selector;\n\n    /* State\n     *****************************************************************************************************************/\n\n    /** @notice Factory of Curve protocol, used to deploy pools */\n    address private curveFactory;\n    /** @notice registry of the protocol */\n    address private immutable registry;\n    /** @notice rate oracle registry implementation*/\n    address private immutable rateOracleRegistry;\n\n    /* Events\n     *****************************************************************************************************************/\n\n    event PTDeployed(address indexed pt, address indexed poolCreator);\n    event RateAdjustmentOracleDeployed(\n        address indexed rateAdjustmentOracle,\n        address indexed poolCreator\n    );\n    event CurvePoolDeployed(address indexed poolAddress, address indexed ibt, address indexed pt);\n    event RegistryChange(address indexed previousRegistry, address indexed newRegistry);\n    event CurveFactoryChange(address indexed previousFactory, address indexed newFactory);\n\n    /**\n     * @notice Constructor of the contract. Separate registry used for Spectra core contracts and rate\n     * oracle contracts.\n     * @param _registry The address of the registry.\n     * @param _rateOracleRegistry The address of the registry.\n     */\n    constructor(address _registry, address _rateOracleRegistry) {\n        if (_registry == address(0) || _rateOracleRegistry == address(0)) {\n            revert AddressError();\n        }\n        registry = _registry;\n        rateOracleRegistry = _rateOracleRegistry;\n        _disableInitializers(); // using this so that the deployed logic contract later cannot be initialized.\n    }\n\n    /**\n     * @notice Initializer of the contract\n     * @param _initialAuthority The address of the access manager.\n     */\n    function initialize(address _initialAuthority, address _curveFactory) external initializer {\n        __AccessManaged_init(_initialAuthority);\n        _setCurveFactory(_curveFactory);\n    }\n\n    /** @dev See {IFactory-deployAll}. */\n    function deployAll(\n        address _ibt,\n        uint256 _duration,\n        CurvePoolParams memory _curvePoolParams,\n        uint256 _initialLiquidityInIBT,\n        uint256 _minPTShares\n    ) public returns (address pt, address rateAdjustmentOracle, address curvePool) {\n        // deploy PT\n        address ptBeacon = IRegistry(registry).getPTBeacon();\n        if (ptBeacon == address(0)) {\n            revert BeaconNotSet();\n        }\n        address accessManager = authority();\n        bytes memory _encodedData = abi.encodeWithSelector(\n            IPrincipalToken(address(0)).initialize.selector,\n            _ibt,\n            _duration,\n            accessManager\n        );\n\n        pt = address(new BeaconProxy(ptBeacon, _encodedData));\n        emit PTDeployed(pt, msg.sender);\n        IRegistry(registry).addPT(pt);\n        IAccessManager(accessManager).setTargetFunctionRole(pt, getPauserSigs(), Roles.PAUSER_ROLE);\n        IAccessManager(accessManager).setTargetFunctionRole(\n            pt,\n            getClaimRewardsProxySelectors(),\n            Roles.REWARDS_HARVESTER_ROLE\n        );\n\n        IAccessManager(accessManager).setTargetFunctionRole(\n            pt,\n            getSetRewardsProxySelectors(),\n            Roles.REWARDS_PROXY_SETTER_ROLE\n        );\n\n        // Deploy the rate oracle\n        address rateOracleBeacon = IRateOracleRegistry(rateOracleRegistry).getRateOracleBeacon();\n        if (rateOracleBeacon == address(0)) {\n            revert BeaconNotSet();\n        }\n\n        _encodedData = abi.encodeWithSelector(\n            IRateAdjustmentOracle(address(0)).initialize.selector,\n            accessManager\n        );\n\n        rateAdjustmentOracle = address(new BeaconProxy(rateOracleBeacon, _encodedData));\n        emit RateAdjustmentOracleDeployed(rateAdjustmentOracle, msg.sender);\n        IRateOracleRegistry(rateOracleRegistry).addRateOracle(pt, rateAdjustmentOracle);\n        IAccessManager(accessManager).setTargetFunctionRole(\n            rateAdjustmentOracle,\n            getSetRateOracleInitialPriceSelectors(),\n            Roles.RATE_ADJUSTMENT_ORACLE_SETTER_ROLE\n        );\n\n        // deploy Curve Pool\n        address[] memory coins = new address[](2);\n        coins[0] = _ibt;\n        coins[1] = pt;\n\n        _curvePoolParams.rate_adjustment_oracle = rateAdjustmentOracle;\n\n        curvePool = _deployCurvePool(coins, _curvePoolParams);\n        emit CurvePoolDeployed(curvePool, _ibt, pt);\n\n        // initialise rate adjutment oracle\n\n        IRateAdjustmentOracle(rateAdjustmentOracle).post_initialize(\n            block.timestamp,\n            IPrincipalToken(pt).maturity(),\n            _curvePoolParams.initial_price,\n            curvePool\n        );\n\n        if (_initialLiquidityInIBT != 0) {\n            _addInitialLiquidity(\n                curvePool,\n                _initialLiquidityInIBT,\n                _minPTShares,\n                _curvePoolParams.initial_price\n            );\n        }\n    }\n\n    /* GETTERS\n     *****************************************************************************************************************/\n\n    /** @dev See {IFactory-getRegistry}. */\n    function getRegistry() external view override returns (address) {\n        return registry;\n    }\n\n    /** @dev See {IFactory-getRateOracleRegistry}. */\n    function getRateOracleRegistry() external view override returns (address) {\n        return rateOracleRegistry;\n    }\n\n    /** @dev See {IFactory-getCurveFactory}. */\n    function getCurveFactory() external view override returns (address) {\n        return curveFactory;\n    }\n\n    /**\n     * @notice Getter for pause and unpause selectors, used for access management\n     */\n    function getPauserSigs() internal pure returns (bytes4[] memory) {\n        bytes4[] memory selectors = new bytes4[](2);\n        selectors[0] = PAUSE_SELECTOR;\n        selectors[1] = UNPAUSE_SELECTOR;\n        return selectors;\n    }\n\n    /**\n     * @notice Getter for the reward proxy setter selector, used for access management\n     */\n    function getSetRewardsProxySelectors() internal pure returns (bytes4[] memory) {\n        bytes4[] memory selectors = new bytes4[](1);\n        selectors[0] = SET_REWARDS_PROXY_SELECTOR;\n        return selectors;\n    }\n\n    /**\n     * @notice Getter for the claim rewards selector, used for access management\n     */\n    function getClaimRewardsProxySelectors() internal pure returns (bytes4[] memory) {\n        bytes4[] memory selectors = new bytes4[](1);\n        selectors[0] = CLAIM_REWARDS_SELECTOR;\n        return selectors;\n    }\n\n    /**\n     * @notice Getter for the set initial price selector in the rate adjustment oracle, used for access management\n     */\n    function getSetRateOracleInitialPriceSelectors() internal pure returns (bytes4[] memory) {\n        bytes4[] memory selectors = new bytes4[](1);\n        selectors[0] = SET_INIT_PRICE_SELECTOR;\n        return selectors;\n    }\n\n    /* SETTERS\n     *****************************************************************************************************************/\n\n    /** @dev See {IFactory-setCurveFactory}. */\n    function setCurveFactory(address _curveFactory) public override restricted {\n        _setCurveFactory(_curveFactory);\n    }\n\n    /**\n     * @dev Splits the given IBT amount into IBT and PT based on pool initial price, and adds liquidity to the pool.\n     * @param _curvePool The address of the Curve Pool in which the user adds initial liquidity to\n     * @param _initialLiquidityInIBT The initial liquidity to seed the Curve Pool with (in IBT)\n     * @param _minPTShares The minimum allowed shares from deposit in PT\n     * @param _initialPrice The initial price of the Curve Pool\n     */\n    function _addInitialLiquidity(\n        address _curvePool,\n        uint256 _initialLiquidityInIBT,\n        uint256 _minPTShares,\n        uint256 _initialPrice\n    ) internal {\n        address ibt = IStableSwapNG(_curvePool).coins(0);\n        address pt = IStableSwapNG(_curvePool).coins(1);\n\n        {\n            // support for fee-on-transfer tokens\n            uint256 balBefore = IERC20(ibt).balanceOf(address(this));\n            IERC20(ibt).safeTransferFrom(msg.sender, address(this), _initialLiquidityInIBT);\n            _initialLiquidityInIBT = IERC20(ibt).balanceOf(address(this)) - balBefore;\n        }\n\n        // using fictive pool balances, the user is adding liquidity in a ratio that (closely) matches the empty pool's initial price\n        // with ptBalance = IBT_UNIT for having a fictive PT balance reference, ibtBalance = IBT_UNIT x initialPrice\n        uint256 ptBalance = 10 ** IERC20Metadata(ibt).decimals();\n        uint256 ibtBalance = ptBalance.mulDiv(_initialPrice, CurvePoolUtil.CURVE_UNIT);\n        // compute the worth of the fictive IBT balance in the pool in PT\n        uint256 ibtBalanceInPT = IPrincipalToken(pt).previewDepositIBT(ibtBalance);\n        // compute the portion of IBT to deposit in PT\n        uint256 ibtsToTokenize = _initialLiquidityInIBT.mulDiv(\n            ptBalance,\n            ibtBalanceInPT + ptBalance\n        );\n\n        // IBT amount to deposit in the Curve Pool\n        uint256 amount0 = _initialLiquidityInIBT - ibtsToTokenize;\n        uint256 allowancePT = IERC20(ibt).allowance(address(this), pt);\n\n        if (allowancePT < ibtsToTokenize) {\n            IERC20(ibt).forceApprove(pt, type(uint256).max);\n        }\n\n        // PT amount to deposit in Curve Pool\n        uint256 amount1 = IPrincipalToken(pt).depositIBT(\n            ibtsToTokenize,\n            address(this),\n            msg.sender,\n            _minPTShares\n        );\n\n        IERC20(ibt).safeIncreaseAllowance(_curvePool, amount0);\n        IERC20(pt).safeIncreaseAllowance(_curvePool, amount1);\n        uint256[] memory amounts = new uint256[](2);\n        amounts[0] = amount0;\n        amounts[1] = amount1;\n        IStableSwapNG(_curvePool).add_liquidity(amounts, 0, msg.sender);\n    }\n\n    /**\n     * @dev Calls the Curve factory and deploys a new Curve v2 crypto pool\n     */\n    function _deployCurvePool(\n        address[] memory _coins,\n        CurvePoolParams memory _p\n    ) internal returns (address curvePoolAddr) {\n        if (curveFactory == address(0)) {\n            revert CurveFactoryNotSet();\n        }\n\n        uint8[] memory assetTypes = new uint8[](2);\n        assetTypes[0] = IBT_ASSET_TYPE;\n        assetTypes[1] = PT_ASSET_TYPE;\n\n        bytes4[] memory oracleMethodSigs = new bytes4[](2);\n        oracleMethodSigs[0] = bytes4(0x0);\n        oracleMethodSigs[1] = RATE_ADJUSTMENT_ORACLE_METHOD_SIG;\n\n        address[] memory oracleAddresses = new address[](2);\n        oracleAddresses[0] = address(0);\n        oracleAddresses[1] = _p.rate_adjustment_oracle;\n\n        curvePoolAddr = IStableSwapNGFactory(curveFactory).deploy_plain_pool(\n            \"Spectra-PT/IBT\",\n            \"SPT-PT/IBT\",\n            _coins,\n            _p.A,\n            _p.fee,\n            _p.fee_mul,\n            _p.ma_exp_time,\n            IMPLEMENTATION_ID,\n            assetTypes,\n            oracleMethodSigs,\n            oracleAddresses\n        );\n    }\n\n    function _setCurveFactory(address _curveFactory) internal {\n        if (_curveFactory == address(0)) {\n            revert AddressError();\n        }\n        emit CurveFactoryChange(curveFactory, _curveFactory);\n        curveFactory = _curveFactory;\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Muldiv operation overflow.\n     */\n    error MathOverflowedMulDiv();\n\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            return a / b;\n        }\n\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/access/manager/IAccessManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/manager/IAccessManager.sol)\n\npragma solidity ^0.8.20;\n\nimport {IAccessManaged} from \"./IAccessManaged.sol\";\nimport {Time} from \"../../utils/types/Time.sol\";\n\ninterface IAccessManager {\n    /**\n     * @dev A delayed operation was scheduled.\n     */\n    event OperationScheduled(\n        bytes32 indexed operationId,\n        uint32 indexed nonce,\n        uint48 schedule,\n        address caller,\n        address target,\n        bytes data\n    );\n\n    /**\n     * @dev A scheduled operation was executed.\n     */\n    event OperationExecuted(bytes32 indexed operationId, uint32 indexed nonce);\n\n    /**\n     * @dev A scheduled operation was canceled.\n     */\n    event OperationCanceled(bytes32 indexed operationId, uint32 indexed nonce);\n\n    /**\n     * @dev Informational labelling for a roleId.\n     */\n    event RoleLabel(uint64 indexed roleId, string label);\n\n    /**\n     * @dev Emitted when `account` is granted `roleId`.\n     *\n     * NOTE: The meaning of the `since` argument depends on the `newMember` argument.\n     * If the role is granted to a new member, the `since` argument indicates when the account becomes a member of the role,\n     * otherwise it indicates the execution delay for this account and roleId is updated.\n     */\n    event RoleGranted(uint64 indexed roleId, address indexed account, uint32 delay, uint48 since, bool newMember);\n\n    /**\n     * @dev Emitted when `account` membership or `roleId` is revoked. Unlike granting, revoking is instantaneous.\n     */\n    event RoleRevoked(uint64 indexed roleId, address indexed account);\n\n    /**\n     * @dev Role acting as admin over a given `roleId` is updated.\n     */\n    event RoleAdminChanged(uint64 indexed roleId, uint64 indexed admin);\n\n    /**\n     * @dev Role acting as guardian over a given `roleId` is updated.\n     */\n    event RoleGuardianChanged(uint64 indexed roleId, uint64 indexed guardian);\n\n    /**\n     * @dev Grant delay for a given `roleId` will be updated to `delay` when `since` is reached.\n     */\n    event RoleGrantDelayChanged(uint64 indexed roleId, uint32 delay, uint48 since);\n\n    /**\n     * @dev Target mode is updated (true = closed, false = open).\n     */\n    event TargetClosed(address indexed target, bool closed);\n\n    /**\n     * @dev Role required to invoke `selector` on `target` is updated to `roleId`.\n     */\n    event TargetFunctionRoleUpdated(address indexed target, bytes4 selector, uint64 indexed roleId);\n\n    /**\n     * @dev Admin delay for a given `target` will be updated to `delay` when `since` is reached.\n     */\n    event TargetAdminDelayUpdated(address indexed target, uint32 delay, uint48 since);\n\n    error AccessManagerAlreadyScheduled(bytes32 operationId);\n    error AccessManagerNotScheduled(bytes32 operationId);\n    error AccessManagerNotReady(bytes32 operationId);\n    error AccessManagerExpired(bytes32 operationId);\n    error AccessManagerLockedAccount(address account);\n    error AccessManagerLockedRole(uint64 roleId);\n    error AccessManagerBadConfirmation();\n    error AccessManagerUnauthorizedAccount(address msgsender, uint64 roleId);\n    error AccessManagerUnauthorizedCall(address caller, address target, bytes4 selector);\n    error AccessManagerUnauthorizedConsume(address target);\n    error AccessManagerUnauthorizedCancel(address msgsender, address caller, address target, bytes4 selector);\n    error AccessManagerInvalidInitialAdmin(address initialAdmin);\n\n    /**\n     * @dev Check if an address (`caller`) is authorised to call a given function on a given contract directly (with\n     * no restriction). Additionally, it returns the delay needed to perform the call indirectly through the {schedule}\n     * & {execute} workflow.\n     *\n     * This function is usually called by the targeted contract to control immediate execution of restricted functions.\n     * Therefore we only return true if the call can be performed without any delay. If the call is subject to a\n     * previously set delay (not zero), then the function should return false and the caller should schedule the operation\n     * for future execution.\n     *\n     * If `immediate` is true, the delay can be disregarded and the operation can be immediately executed, otherwise\n     * the operation can be executed if and only if delay is greater than 0.\n     *\n     * NOTE: The IAuthority interface does not include the `uint32` delay. This is an extension of that interface that\n     * is backward compatible. Some contracts may thus ignore the second return argument. In that case they will fail\n     * to identify the indirect workflow, and will consider calls that require a delay to be forbidden.\n     *\n     * NOTE: This function does not report the permissions of this manager itself. These are defined by the\n     * {_canCallSelf} function instead.\n     */\n    function canCall(\n        address caller,\n        address target,\n        bytes4 selector\n    ) external view returns (bool allowed, uint32 delay);\n\n    /**\n     * @dev Expiration delay for scheduled proposals. Defaults to 1 week.\n     *\n     * IMPORTANT: Avoid overriding the expiration with 0. Otherwise every contract proposal will be expired immediately,\n     * disabling any scheduling usage.\n     */\n    function expiration() external view returns (uint32);\n\n    /**\n     * @dev Minimum setback for all delay updates, with the exception of execution delays. It\n     * can be increased without setback (and reset via {revokeRole} in the case event of an\n     * accidental increase). Defaults to 5 days.\n     */\n    function minSetback() external view returns (uint32);\n\n    /**\n     * @dev Get whether the contract is closed disabling any access. Otherwise role permissions are applied.\n     */\n    function isTargetClosed(address target) external view returns (bool);\n\n    /**\n     * @dev Get the role required to call a function.\n     */\n    function getTargetFunctionRole(address target, bytes4 selector) external view returns (uint64);\n\n    /**\n     * @dev Get the admin delay for a target contract. Changes to contract configuration are subject to this delay.\n     */\n    function getTargetAdminDelay(address target) external view returns (uint32);\n\n    /**\n     * @dev Get the id of the role that acts as an admin for the given role.\n     *\n     * The admin permission is required to grant the role, revoke the role and update the execution delay to execute\n     * an operation that is restricted to this role.\n     */\n    function getRoleAdmin(uint64 roleId) external view returns (uint64);\n\n    /**\n     * @dev Get the role that acts as a guardian for a given role.\n     *\n     * The guardian permission allows canceling operations that have been scheduled under the role.\n     */\n    function getRoleGuardian(uint64 roleId) external view returns (uint64);\n\n    /**\n     * @dev Get the role current grant delay.\n     *\n     * Its value may change at any point without an event emitted following a call to {setGrantDelay}.\n     * Changes to this value, including effect timepoint are notified in advance by the {RoleGrantDelayChanged} event.\n     */\n    function getRoleGrantDelay(uint64 roleId) external view returns (uint32);\n\n    /**\n     * @dev Get the access details for a given account for a given role. These details include the timepoint at which\n     * membership becomes active, and the delay applied to all operation by this user that requires this permission\n     * level.\n     *\n     * Returns:\n     * [0] Timestamp at which the account membership becomes valid. 0 means role is not granted.\n     * [1] Current execution delay for the account.\n     * [2] Pending execution delay for the account.\n     * [3] Timestamp at which the pending execution delay will become active. 0 means no delay update is scheduled.\n     */\n    function getAccess(uint64 roleId, address account) external view returns (uint48, uint32, uint32, uint48);\n\n    /**\n     * @dev Check if a given account currently has the permission level corresponding to a given role. Note that this\n     * permission might be associated with an execution delay. {getAccess} can provide more details.\n     */\n    function hasRole(uint64 roleId, address account) external view returns (bool, uint32);\n\n    /**\n     * @dev Give a label to a role, for improved role discoverability by UIs.\n     *\n     * Requirements:\n     *\n     * - the caller must be a global admin\n     *\n     * Emits a {RoleLabel} event.\n     */\n    function labelRole(uint64 roleId, string calldata label) external;\n\n    /**\n     * @dev Add `account` to `roleId`, or change its execution delay.\n     *\n     * This gives the account the authorization to call any function that is restricted to this role. An optional\n     * execution delay (in seconds) can be set. If that delay is non 0, the user is required to schedule any operation\n     * that is restricted to members of this role. The user will only be able to execute the operation after the delay has\n     * passed, before it has expired. During this period, admin and guardians can cancel the operation (see {cancel}).\n     *\n     * If the account has already been granted this role, the execution delay will be updated. This update is not\n     * immediate and follows the delay rules. For example, if a user currently has a delay of 3 hours, and this is\n     * called to reduce that delay to 1 hour, the new delay will take some time to take effect, enforcing that any\n     * operation executed in the 3 hours that follows this update was indeed scheduled before this update.\n     *\n     * Requirements:\n     *\n     * - the caller must be an admin for the role (see {getRoleAdmin})\n     * - granted role must not be the `PUBLIC_ROLE`\n     *\n     * Emits a {RoleGranted} event.\n     */\n    function grantRole(uint64 roleId, address account, uint32 executionDelay) external;\n\n    /**\n     * @dev Remove an account from a role, with immediate effect. If the account does not have the role, this call has\n     * no effect.\n     *\n     * Requirements:\n     *\n     * - the caller must be an admin for the role (see {getRoleAdmin})\n     * - revoked role must not be the `PUBLIC_ROLE`\n     *\n     * Emits a {RoleRevoked} event if the account had the role.\n     */\n    function revokeRole(uint64 roleId, address account) external;\n\n    /**\n     * @dev Renounce role permissions for the calling account with immediate effect. If the sender is not in\n     * the role this call has no effect.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * Emits a {RoleRevoked} event if the account had the role.\n     */\n    function renounceRole(uint64 roleId, address callerConfirmation) external;\n\n    /**\n     * @dev Change admin role for a given role.\n     *\n     * Requirements:\n     *\n     * - the caller must be a global admin\n     *\n     * Emits a {RoleAdminChanged} event\n     */\n    function setRoleAdmin(uint64 roleId, uint64 admin) external;\n\n    /**\n     * @dev Change guardian role for a given role.\n     *\n     * Requirements:\n     *\n     * - the caller must be a global admin\n     *\n     * Emits a {RoleGuardianChanged} event\n     */\n    function setRoleGuardian(uint64 roleId, uint64 guardian) external;\n\n    /**\n     * @dev Update the delay for granting a `roleId`.\n     *\n     * Requirements:\n     *\n     * - the caller must be a global admin\n     *\n     * Emits a {RoleGrantDelayChanged} event.\n     */\n    function setGrantDelay(uint64 roleId, uint32 newDelay) external;\n\n    /**\n     * @dev Set the role required to call functions identified by the `selectors` in the `target` contract.\n     *\n     * Requirements:\n     *\n     * - the caller must be a global admin\n     *\n     * Emits a {TargetFunctionRoleUpdated} event per selector.\n     */\n    function setTargetFunctionRole(address target, bytes4[] calldata selectors, uint64 roleId) external;\n\n    /**\n     * @dev Set the delay for changing the configuration of a given target contract.\n     *\n     * Requirements:\n     *\n     * - the caller must be a global admin\n     *\n     * Emits a {TargetAdminDelayUpdated} event.\n     */\n    function setTargetAdminDelay(address target, uint32 newDelay) external;\n\n    /**\n     * @dev Set the closed flag for a contract.\n     *\n     * Requirements:\n     *\n     * - the caller must be a global admin\n     *\n     * Emits a {TargetClosed} event.\n     */\n    function setTargetClosed(address target, bool closed) external;\n\n    /**\n     * @dev Return the timepoint at which a scheduled operation will be ready for execution. This returns 0 if the\n     * operation is not yet scheduled, has expired, was executed, or was canceled.\n     */\n    function getSchedule(bytes32 id) external view returns (uint48);\n\n    /**\n     * @dev Return the nonce for the latest scheduled operation with a given id. Returns 0 if the operation has never\n     * been scheduled.\n     */\n    function getNonce(bytes32 id) external view returns (uint32);\n\n    /**\n     * @dev Schedule a delayed operation for future execution, and return the operation identifier. It is possible to\n     * choose the timestamp at which the operation becomes executable as long as it satisfies the execution delays\n     * required for the caller. The special value zero will automatically set the earliest possible time.\n     *\n     * Returns the `operationId` that was scheduled. Since this value is a hash of the parameters, it can reoccur when\n     * the same parameters are used; if this is relevant, the returned `nonce` can be used to uniquely identify this\n     * scheduled operation from other occurrences of the same `operationId` in invocations of {execute} and {cancel}.\n     *\n     * Emits a {OperationScheduled} event.\n     *\n     * NOTE: It is not possible to concurrently schedule more than one operation with the same `target` and `data`. If\n     * this is necessary, a random byte can be appended to `data` to act as a salt that will be ignored by the target\n     * contract if it is using standard Solidity ABI encoding.\n     */\n    function schedule(address target, bytes calldata data, uint48 when) external returns (bytes32, uint32);\n\n    /**\n     * @dev Execute a function that is delay restricted, provided it was properly scheduled beforehand, or the\n     * execution delay is 0.\n     *\n     * Returns the nonce that identifies the previously scheduled operation that is executed, or 0 if the\n     * operation wasn't previously scheduled (if the caller doesn't have an execution delay).\n     *\n     * Emits an {OperationExecuted} event only if the call was scheduled and delayed.\n     */\n    function execute(address target, bytes calldata data) external payable returns (uint32);\n\n    /**\n     * @dev Cancel a scheduled (delayed) operation. Returns the nonce that identifies the previously scheduled\n     * operation that is cancelled.\n     *\n     * Requirements:\n     *\n     * - the caller must be the proposer, a guardian of the targeted function, or a global admin\n     *\n     * Emits a {OperationCanceled} event.\n     */\n    function cancel(address caller, address target, bytes calldata data) external returns (uint32);\n\n    /**\n     * @dev Consume a scheduled operation targeting the caller. If such an operation exists, mark it as consumed\n     * (emit an {OperationExecuted} event and clean the state). Otherwise, throw an error.\n     *\n     * This is useful for contract that want to enforce that calls targeting them were scheduled on the manager,\n     * with all the verifications that it implies.\n     *\n     * Emit a {OperationExecuted} event.\n     */\n    function consumeScheduledOp(address caller, bytes calldata data) external;\n\n    /**\n     * @dev Hashing function for delayed operations.\n     */\n    function hashOperation(address caller, address target, bytes calldata data) external view returns (bytes32);\n\n    /**\n     * @dev Changes the authority of a target managed by this manager instance.\n     *\n     * Requirements:\n     *\n     * - the caller must be a global admin\n     */\n    function updateAuthority(address target, address newAuthority) external;\n}\n"
    },
    "lib/openzeppelin-contracts-upgradeable/contracts/access/manager/AccessManagedUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/manager/AccessManaged.sol)\n\npragma solidity ^0.8.20;\n\nimport {IAuthority} from \"@openzeppelin/contracts/access/manager/IAuthority.sol\";\nimport {AuthorityUtils} from \"@openzeppelin/contracts/access/manager/AuthorityUtils.sol\";\nimport {IAccessManager} from \"@openzeppelin/contracts/access/manager/IAccessManager.sol\";\nimport {IAccessManaged} from \"@openzeppelin/contracts/access/manager/IAccessManaged.sol\";\nimport {ContextUpgradeable} from \"../../utils/ContextUpgradeable.sol\";\nimport {Initializable} from \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev This contract module makes available a {restricted} modifier. Functions decorated with this modifier will be\n * permissioned according to an \"authority\": a contract like {AccessManager} that follows the {IAuthority} interface,\n * implementing a policy that allows certain callers to access certain functions.\n *\n * IMPORTANT: The `restricted` modifier should never be used on `internal` functions, judiciously used in `public`\n * functions, and ideally only used in `external` functions. See {restricted}.\n */\nabstract contract AccessManagedUpgradeable is Initializable, ContextUpgradeable, IAccessManaged {\n    /// @custom:storage-location erc7201:openzeppelin.storage.AccessManaged\n    struct AccessManagedStorage {\n        address _authority;\n\n        bool _consumingSchedule;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.AccessManaged\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant AccessManagedStorageLocation = 0xf3177357ab46d8af007ab3fdb9af81da189e1068fefdc0073dca88a2cab40a00;\n\n    function _getAccessManagedStorage() private pure returns (AccessManagedStorage storage $) {\n        assembly {\n            $.slot := AccessManagedStorageLocation\n        }\n    }\n\n    /**\n     * @dev Initializes the contract connected to an initial authority.\n     */\n    function __AccessManaged_init(address initialAuthority) internal onlyInitializing {\n        __AccessManaged_init_unchained(initialAuthority);\n    }\n\n    function __AccessManaged_init_unchained(address initialAuthority) internal onlyInitializing {\n        _setAuthority(initialAuthority);\n    }\n\n    /**\n     * @dev Restricts access to a function as defined by the connected Authority for this contract and the\n     * caller and selector of the function that entered the contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * In general, this modifier should only be used on `external` functions. It is okay to use it on `public`\n     * functions that are used as external entry points and are not called internally. Unless you know what you're\n     * doing, it should never be used on `internal` functions. Failure to follow these rules can have critical security\n     * implications! This is because the permissions are determined by the function that entered the contract, i.e. the\n     * function at the bottom of the call stack, and not the function where the modifier is visible in the source code.\n     * ====\n     *\n     * [WARNING]\n     * ====\n     * Avoid adding this modifier to the https://docs.soliditylang.org/en/v0.8.20/contracts.html#receive-ether-function[`receive()`]\n     * function or the https://docs.soliditylang.org/en/v0.8.20/contracts.html#fallback-function[`fallback()`]. These\n     * functions are the only execution paths where a function selector cannot be unambiguosly determined from the calldata\n     * since the selector defaults to `0x00000000` in the `receive()` function and similarly in the `fallback()` function\n     * if no calldata is provided. (See {_checkCanCall}).\n     *\n     * The `receive()` function will always panic whereas the `fallback()` may panic depending on the calldata length.\n     * ====\n     */\n    modifier restricted() {\n        _checkCanCall(_msgSender(), _msgData());\n        _;\n    }\n\n    /// @inheritdoc IAccessManaged\n    function authority() public view virtual returns (address) {\n        AccessManagedStorage storage $ = _getAccessManagedStorage();\n        return $._authority;\n    }\n\n    /// @inheritdoc IAccessManaged\n    function setAuthority(address newAuthority) public virtual {\n        address caller = _msgSender();\n        if (caller != authority()) {\n            revert AccessManagedUnauthorized(caller);\n        }\n        if (newAuthority.code.length == 0) {\n            revert AccessManagedInvalidAuthority(newAuthority);\n        }\n        _setAuthority(newAuthority);\n    }\n\n    /// @inheritdoc IAccessManaged\n    function isConsumingScheduledOp() public view returns (bytes4) {\n        AccessManagedStorage storage $ = _getAccessManagedStorage();\n        return $._consumingSchedule ? this.isConsumingScheduledOp.selector : bytes4(0);\n    }\n\n    /**\n     * @dev Transfers control to a new authority. Internal function with no access restriction. Allows bypassing the\n     * permissions set by the current authority.\n     */\n    function _setAuthority(address newAuthority) internal virtual {\n        AccessManagedStorage storage $ = _getAccessManagedStorage();\n        $._authority = newAuthority;\n        emit AuthorityUpdated(newAuthority);\n    }\n\n    /**\n     * @dev Reverts if the caller is not allowed to call the function identified by a selector. Panics if the calldata\n     * is less than 4 bytes long.\n     */\n    function _checkCanCall(address caller, bytes calldata data) internal virtual {\n        AccessManagedStorage storage $ = _getAccessManagedStorage();\n        (bool immediate, uint32 delay) = AuthorityUtils.canCallWithDelay(\n            authority(),\n            caller,\n            address(this),\n            bytes4(data[0:4])\n        );\n        if (!immediate) {\n            if (delay > 0) {\n                $._consumingSchedule = true;\n                IAccessManager(authority()).consumeScheduledOp(caller, data);\n                $._consumingSchedule = false;\n            } else {\n                revert AccessManagedUnauthorized(caller);\n            }\n        }\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/proxy/beacon/BeaconProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/beacon/BeaconProxy.sol)\n\npragma solidity ^0.8.20;\n\nimport {IBeacon} from \"./IBeacon.sol\";\nimport {Proxy} from \"../Proxy.sol\";\nimport {ERC1967Utils} from \"../ERC1967/ERC1967Utils.sol\";\n\n/**\n * @dev This contract implements a proxy that gets the implementation address for each call from an {UpgradeableBeacon}.\n *\n * The beacon address can only be set once during construction, and cannot be changed afterwards. It is stored in an\n * immutable variable to avoid unnecessary storage reads, and also in the beacon storage slot specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] so that it can be accessed externally.\n *\n * CAUTION: Since the beacon address can never be changed, you must ensure that you either control the beacon, or trust\n * the beacon to not upgrade the implementation maliciously.\n *\n * IMPORTANT: Do not use the implementation logic to modify the beacon storage slot. Doing so would leave the proxy in\n * an inconsistent state where the beacon storage slot does not match the beacon address.\n */\ncontract BeaconProxy is Proxy {\n    // An immutable address for the beacon to avoid unnecessary SLOADs before each delegate call.\n    address private immutable _beacon;\n\n    /**\n     * @dev Initializes the proxy with `beacon`.\n     *\n     * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon. This\n     * will typically be an encoded function call, and allows initializing the storage of the proxy like a Solidity\n     * constructor.\n     *\n     * Requirements:\n     *\n     * - `beacon` must be a contract with the interface {IBeacon}.\n     * - If `data` is empty, `msg.value` must be zero.\n     */\n    constructor(address beacon, bytes memory data) payable {\n        ERC1967Utils.upgradeBeaconToAndCall(beacon, data);\n        _beacon = beacon;\n    }\n\n    /**\n     * @dev Returns the current implementation address of the associated beacon.\n     */\n    function _implementation() internal view virtual override returns (address) {\n        return IBeacon(_getBeacon()).implementation();\n    }\n\n    /**\n     * @dev Returns the beacon.\n     */\n    function _getBeacon() internal view virtual returns (address) {\n        return _beacon;\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC20Permit} from \"../extensions/IERC20Permit.sol\";\nimport {Address} from \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev An operation with an ERC20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}\n"
    },
    "src/interfaces/IFactorySNG.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.20;\n\ninterface IFactorySNG {\n    /* Errors\n     *****************************************************************************************************************/\n    error BeaconNotSet();\n    error CurveFactoryNotSet();\n    error DeploymentFailed();\n    error AddressError();\n    error FailedToFetchCurveFactoryAddress();\n    error UnregisteredPT();\n    error CurvePoolCoinError();\n    error ExpiredPT();\n\n    struct CurvePoolParams {\n        uint256 A;\n        uint256 fee;\n        uint256 fee_mul;\n        uint256 ma_exp_time;\n        uint256 initial_price;\n        address rate_adjustment_oracle;\n    }\n\n    /**\n     * @notice Deploys associated PT and Curve Pool.\n     * @param _ibt The address of the ibt that will be associated with the pool.\n     * @param curvePoolParams The curve pool parameters to be used in the deployment.\n     * For example, the Curve Factory will deploy a pool like so:\n     * abi.encodeWithSelector(initialize.selector, params)\n     * List of parameters: name, symbol, coins [ibt,pt], A, gamma, mid_fee, out_fee,\n     * allowed_extra_profit, fee_gamma, adjustment_step, admin_fee, ma_half_time, initial_price\n     * @param _initialLiquidityInIBT The initial IBT liquidity (to be split between IBT/PT) to be added to pool after deployment.\n     * @param _minPTShares The minimum allowed shares from deposit in PT. Ignored if _initialLiquidityInIBT is 0.\n     * @return pt The address of the deployed PT.\n     * @return rateAdjustmentOracle The address of the deployed rate adjustment oracle.\n     * @return curvePoolAddr The address of the deployed curve pool.\n     */\n    function deployAll(\n        address _ibt,\n        uint256 _duration,\n        CurvePoolParams calldata curvePoolParams,\n        uint256 _initialLiquidityInIBT,\n        uint256 _minPTShares\n    ) external returns (address pt, address rateAdjustmentOracle, address curvePoolAddr);\n\n    /* GETTERS\n     *****************************************************************************************************************/\n\n    /**\n     * @notice Getter for the registry address.\n     * @return The address of the registry\n     */\n    function getRegistry() external view returns (address);\n\n    /**\n     * @notice Getter for the rate oracle registry address.\n     * @return The address of the rate oracle registry\n     */\n    function getRateOracleRegistry() external view returns (address);\n\n    /**\n     * @notice Getter for the Curve Factory address\n     * @return The address of the Curve Factory\n     */\n    function getCurveFactory() external view returns (address);\n\n    /* SETTERS\n     *****************************************************************************************************************/\n\n    /**\n     * @notice Setter for the Curve factory address used for deploying curve pools.\n     * Can only be called by admin.\n     * @param _curveFactory The address of the Curve Factory.\n     */\n    function setCurveFactory(address _curveFactory) external;\n}\n"
    },
    "src/interfaces/IStableSwapNGFactory.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.20;\n\ninterface IStableSwapNGFactory {\n    function deploy_plain_pool(\n        string calldata _name,\n        string calldata _symbol,\n        address[] calldata _coins,\n        uint256 A,\n        uint256 fee,\n        uint256 fee_mul,\n        uint256 ma_exp_time,\n        uint256 implementation_idx,\n        uint8[] calldata asset_types,\n        bytes4[] calldata method_ids,\n        address[] calldata oracles\n    ) external returns (address);\n}\n"
    },
    "src/interfaces/IRateAdjustmentOracle.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.20;\n\ninterface IRateAdjustmentOracle {\n    /* ERRORS\n     *****************************************************************************************************************/\n\n    error AddressError();\n    error AddressesNotSet();\n    error PostInitCalledBeforeInit();\n\n    /* Functions\n     *****************************************************************************************************************/\n\n    /**\n     * @notice First function called after contract depoyment, sets the contract authority\n     * @param _initialAuthority Initial authority of the rate oracle\n     */\n    function initialize(address _initialAuthority) external;\n\n    /**\n     * @dev Function called after deployment of the associated Curve Pool to initialize the remaining state.\n     * @dev Deployment of the Curve Pool requires the address of the rate adjustment oracle, while the rate adjustment\n     * @dev oracle needs the address of the Curve Pool to make function calls. Therefore, initialization is done in two steps.\n     * @param _startTimestamp The PT deployment time\n     * @param _expiry The PT expiry\n     * @param _initialPrice The initial PT/IBT exchange rate\n     * @param _curvePoolAddress Address of the curve pool\n     */\n    function post_initialize(\n        uint256 _startTimestamp,\n        uint256 _expiry,\n        uint256 _initialPrice,\n        address _curvePoolAddress\n    ) external;\n\n    /**\n     * @notice Function reporting the oracle value used in curve stableswap pool\n     * @return Multiplicative adjustment factor for last_prices in between each two trades\n     */\n    function value() external view returns (uint256);\n\n    /**\n     * @notice Function to change the current initial price\n     * @param _newInitialPrice new initial price we want to set\n     */\n    function setInitialPrice(uint256 _newInitialPrice) external;\n\n    /**\n     * @notice Getter for the current initial price\n     * @return current initial price\n     */\n    function getInitialPrice() external view returns (uint256);\n\n    /**\n     * @notice Getter for the curve pool address of the rate adjustment oracle\n     * @return curve pool address\n     */\n    function getCurvePoolAddress() external view returns (address);\n\n    /**\n     * Getter for the start time of the pt\n     * @return start time of the pt\n     */\n    function getStartTime() external view returns (uint256);\n\n    /**\n     * @notice Getter for the expiry of the pt\n     * @return expiry of the pt\n     */\n    function getExpiry() external view returns (uint256);\n}\n"
    },
    "src/interfaces/IPrincipalToken.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.20;\n\nimport \"openzeppelin-contracts/interfaces/IERC20.sol\";\nimport \"openzeppelin-contracts/interfaces/IERC20Metadata.sol\";\nimport \"openzeppelin-contracts/interfaces/IERC3156FlashLender.sol\";\n\ninterface IPrincipalToken is IERC20, IERC20Metadata, IERC3156FlashLender {\n    /* ERRORS\n     *****************************************************************************************************************/\n\n    error InvalidDecimals();\n    error BeaconNotSet();\n    error PTExpired();\n    error PTNotExpired();\n    error RateError();\n    error AddressError();\n    error UnauthorizedCaller();\n    error RatesAtExpiryAlreadyStored();\n    error ERC5143SlippageProtectionFailed();\n    error InsufficientBalance();\n    error FlashLoanExceedsMaxAmount();\n    error FlashLoanCallbackFailed();\n    error NoRewardsProxy();\n    error ClaimRewardsFailed();\n\n    /* Functions\n     *****************************************************************************************************************/\n\n    function initialize(address _ibt, uint256 _duration, address initialAuthority) external;\n\n    /**\n     * @notice Toggle Pause\n     * @dev Should only be called in extraordinary situations by the admin of the contract\n     */\n    function pause() external;\n\n    /**\n     * @notice Toggle UnPause\n     * @dev Should only be called in extraordinary situations by the admin of the contract\n     */\n    function unPause() external;\n\n    /**\n     * @notice Deposits amount of assets in the PT vault\n     * @param assets The amount of assets being deposited\n     * @param receiver The receiver address of the shares\n     * @return shares The amount of shares minted (same amount for PT & yt)\n     */\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\n\n    /**\n     * @notice Deposits amount of assets in the PT vault\n     * @param assets The amount of assets being deposited\n     * @param ptReceiver The receiver address of the PTs\n     * @param ytReceiver the receiver address of the YTs\n     * @return shares The amount of shares minted (same amount for PT & yt)\n     */\n    function deposit(\n        uint256 assets,\n        address ptReceiver,\n        address ytReceiver\n    ) external returns (uint256 shares);\n\n    /**\n     * @notice Deposits amount of assets with a lower bound on shares received\n     * @param assets The amount of assets being deposited\n     * @param ptReceiver The receiver address of the PTs\n     * @param ytReceiver The receiver address of the YTs\n     * @param minShares The minimum allowed shares from this deposit\n     * @return shares The amount of shares actually minted to the receiver\n     */\n    function deposit(\n        uint256 assets,\n        address ptReceiver,\n        address ytReceiver,\n        uint256 minShares\n    ) external returns (uint256 shares);\n\n    /**\n     * @notice Same as normal deposit but with IBTs\n     * @param ibts The amount of IBT being deposited\n     * @param receiver The receiver address of the shares\n     * @return shares The amount of shares minted to the receiver\n     */\n    function depositIBT(uint256 ibts, address receiver) external returns (uint256 shares);\n\n    /**\n     * @notice Same as normal deposit but with IBTs\n     * @param ibts The amount of IBT being deposited\n     * @param ptReceiver The receiver address of the PTs\n     * @param ytReceiver the receiver address of the YTs\n     * @return shares The amount of shares minted to the receiver\n     */\n    function depositIBT(\n        uint256 ibts,\n        address ptReceiver,\n        address ytReceiver\n    ) external returns (uint256 shares);\n\n    /**\n     * @notice Same as normal deposit but with IBTs\n     * @param ibts The amount of IBT being deposited\n     * @param ptReceiver The receiver address of the PTs\n     * @param ytReceiver The receiver address of the YTs\n     * @param minShares The minimum allowed shares from this deposit\n     * @return shares The amount of shares minted to the receiver\n     */\n    function depositIBT(\n        uint256 ibts,\n        address ptReceiver,\n        address ytReceiver,\n        uint256 minShares\n    ) external returns (uint256 shares);\n\n    /**\n     * @notice Burns owner's shares (PTs and YTs before expiry, PTs after expiry)\n     * and sends assets to receiver\n     * @param shares The amount of shares to burn\n     * @param receiver The address that will receive the assets\n     * @param owner The owner of the shares\n     * @return assets The actual amount of assets received for burning the shares\n     */\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) external returns (uint256 assets);\n\n    /**\n     * @notice Burns owner's shares (PTs and YTs before expiry, PTs after expiry)\n     * and sends assets to receiver\n     * @param shares The amount of shares to burn\n     * @param receiver The address that will receive the assets\n     * @param owner The owner of the shares\n     * @param minAssets The minimum assets that should be returned to user\n     * @return assets The actual amount of assets received for burning the shares\n     */\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner,\n        uint256 minAssets\n    ) external returns (uint256 assets);\n\n    /**\n     * @notice Burns owner's shares (PTs and YTs before expiry, PTs after expiry)\n     * and sends IBTs to receiver\n     * @param shares The amount of shares to burn\n     * @param receiver The address that will receive the IBTs\n     * @param owner The owner of the shares\n     * @return ibts The actual amount of IBT received for burning the shares\n     */\n    function redeemForIBT(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) external returns (uint256 ibts);\n\n    /**\n     * @notice Burns owner's shares (PTs and YTs before expiry, PTs after expiry)\n     * and sends IBTs to receiver\n     * @param shares The amount of shares to burn\n     * @param receiver The address that will receive the IBTs\n     * @param owner The owner of the shares\n     * @param minIbts The minimum IBTs that should be returned to user\n     * @return ibts The actual amount of IBT received for burning the shares\n     */\n    function redeemForIBT(\n        uint256 shares,\n        address receiver,\n        address owner,\n        uint256 minIbts\n    ) external returns (uint256 ibts);\n\n    /**\n     * @notice Burns owner's shares (before expiry : PTs and YTs) and sends assets to receiver\n     * @param assets The amount of assets to be received\n     * @param receiver The address that will receive the assets\n     * @param owner The owner of the shares (PTs and YTs)\n     * @return shares The actual amount of shares burnt for receiving the assets\n     */\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) external returns (uint256 shares);\n\n    /**\n     * @notice Burns owner's shares (before expiry : PTs and YTs) and sends assets to receiver\n     * @param assets The amount of assets to be received\n     * @param receiver The address that will receive the assets\n     * @param owner The owner of the shares (PTs and YTs)\n     * @param maxShares The maximum shares allowed to be burnt\n     * @return shares The actual amount of shares burnt for receiving the assets\n     */\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner,\n        uint256 maxShares\n    ) external returns (uint256 shares);\n\n    /**\n     * @notice Burns owner's shares (before expiry : PTs and YTs) and sends IBTs to receiver\n     * @param ibts The amount of IBT to be received\n     * @param receiver The address that will receive the IBTs\n     * @param owner The owner of the shares (PTs and YTs)\n     * @return shares The actual amount of shares burnt for receiving the IBTs\n     */\n    function withdrawIBT(\n        uint256 ibts,\n        address receiver,\n        address owner\n    ) external returns (uint256 shares);\n\n    /**\n     * @notice Burns owner's shares (before expiry : PTs and YTs) and sends IBTs to receiver\n     * @param ibts The amount of IBT to be received\n     * @param receiver The address that will receive the IBTs\n     * @param owner The owner of the shares (PTs and YTs)\n     * @param maxShares The maximum shares allowed to be burnt\n     * @return shares The actual amount of shares burnt for receiving the IBTs\n     */\n    function withdrawIBT(\n        uint256 ibts,\n        address receiver,\n        address owner,\n        uint256 maxShares\n    ) external returns (uint256 shares);\n\n    /**\n     * @notice Updates _user's yield since last update\n     * @param _user The user whose yield will be updated\n     * @return updatedUserYieldInIBT The unclaimed yield of the user in IBT (not just the updated yield)\n     */\n    function updateYield(address _user) external returns (uint256 updatedUserYieldInIBT);\n\n    /**\n     * @notice Claims caller's unclaimed yield in asset\n     * @param _receiver The receiver of yield\n     * @param _minAssets The minimum amount of assets that should be received\n     * @return yieldInAsset The amount of yield claimed in asset\n     */\n    function claimYield(\n        address _receiver,\n        uint256 _minAssets\n    ) external returns (uint256 yieldInAsset);\n\n    /**\n     * @notice Claims caller's unclaimed yield in IBT\n     * @param _receiver The receiver of yield\n     * @param _minIBT The minimum amount of IBT that should be received\n     * @return yieldInIBT The amount of yield claimed in IBT\n     */\n    function claimYieldInIBT(\n        address _receiver,\n        uint256 _minIBT\n    ) external returns (uint256 yieldInIBT);\n\n    /**\n     * @notice Claims the collected ibt fees and redeems them to the fee collector\n     * @param _minAssets The minimum amount of assets that should be received\n     * @return assets The amount of assets sent to the fee collector\n     */\n    function claimFees(uint256 _minAssets) external returns (uint256 assets);\n\n    /**\n     * @notice Updates yield of both sender and receiver of YTs\n     * @param _from the sender of YTs\n     * @param _to the receiver of YTs\n     */\n    function beforeYtTransfer(address _from, address _to) external;\n\n    /**\n     * Call the claimRewards function of the rewards contract\n     * @param data The optional data to be passed to the rewards contract\n     */\n    function claimRewards(bytes memory data) external;\n\n    /* SETTERS\n     *****************************************************************************************************************/\n\n    /**\n     * @notice Stores PT and IBT rates at expiry. Ideally, it should be called the day of expiry\n     */\n    function storeRatesAtExpiry() external;\n\n    /** Set a new Rewards Proxy\n     * @param _rewardsProxy The address of the new reward proxy\n     */\n    function setRewardsProxy(address _rewardsProxy) external;\n\n    /* GETTERS\n     *****************************************************************************************************************/\n\n    /**\n     * @notice Returns the amount of shares minted for the theorical deposited amount of assets\n     * @param assets The amount of assets deposited\n     * @return The amount of shares minted\n     */\n    function previewDeposit(uint256 assets) external view returns (uint256);\n\n    /**\n     * @notice Returns the amount of shares minted for the theorical deposited amount of IBT\n     * @param ibts The amount of IBT deposited\n     * @return The amount of shares minted\n     */\n    function previewDepositIBT(uint256 ibts) external view returns (uint256);\n\n    /**\n     * @notice Returns the maximum amount of the underlying asset that can be deposited into the Vault for the receiver,\n     * through a deposit call.\n     * @param receiver The receiver of the shares\n     * @return The maximum amount of assets that can be deposited\n     */\n    function maxDeposit(address receiver) external view returns (uint256);\n\n    /**\n     * @notice Returns the theorical amount of shares that need to be burnt to receive assets of underlying\n     * @param assets The amount of assets to receive\n     * @return The amount of shares burnt\n     */\n    function previewWithdraw(uint256 assets) external view returns (uint256);\n\n    /**\n     * @notice Returns the theorical amount of shares that need to be burnt to receive amount of IBT\n     * @param ibts The amount of IBT to receive\n     * @return The amount of shares burnt\n     */\n    function previewWithdrawIBT(uint256 ibts) external view returns (uint256);\n\n    /**\n     * @notice Returns the maximum amount of the underlying asset that can be withdrawn from the owner balance in the\n     * Vault, through a withdraw call.\n     * @param owner The owner of the Vault shares\n     * @return The maximum amount of assets that can be withdrawn\n     */\n    function maxWithdraw(address owner) external view returns (uint256);\n\n    /**\n     * @notice Returns the maximum amount of the IBT that can be withdrawn from the owner balance in the\n     * Vault, through a withdraw call.\n     * @param owner The owner of the Vault shares\n     * @return The maximum amount of IBT that can be withdrawn\n     */\n    function maxWithdrawIBT(address owner) external view returns (uint256);\n\n    /**\n     * @notice Returns the amount of assets received for the theorical amount of burnt shares\n     * @param shares The amount of shares to burn\n     * @return The amount of assets received\n     */\n    function previewRedeem(uint256 shares) external view returns (uint256);\n\n    /**\n     * @notice Returns the amount of IBT received for the theorical amount of burnt shares\n     * @param shares The amount of shares to burn\n     * @return The amount of IBT received\n     */\n    function previewRedeemForIBT(uint256 shares) external view returns (uint256);\n\n    /**\n     * @notice Returns the maximum amount of Vault shares that can be redeemed by the owner\n     * @notice This function behaves differently before and after expiry. Before expiry an equal amount of PT and YT\n     * needs to be burnt, while after expiry only PTs are burnt.\n     * @param owner The owner of the shares\n     * @return The maximum amount of shares that can be redeemed\n     */\n    function maxRedeem(address owner) external view returns (uint256);\n\n    /**\n     * Returns the total amount of the underlying asset that is owned by the Vault in the form of IBT.\n     */\n    function totalAssets() external view returns (uint256);\n\n    /**\n     * @notice Converts an underlying amount in principal. Equivalent to ERC-4626's convertToShares method.\n     * @param underlyingAmount The amount of underlying (or assets) to convert\n     * @return The resulting amount of principal (or shares)\n     */\n    function convertToPrincipal(uint256 underlyingAmount) external view returns (uint256);\n\n    /**\n     * @notice Converts a principal amount in underlying. Equivalent to ERC-4626's convertToAssets method.\n     * @param principalAmount The amount of principal (or shares) to convert\n     * @return The resulting amount of underlying (or assets)\n     */\n    function convertToUnderlying(uint256 principalAmount) external view returns (uint256);\n\n    /**\n     * @notice Returns whether or not the contract is paused.\n     * @return true if the contract is paused, and false otherwise\n     */\n    function paused() external view returns (bool);\n\n    /**\n     * @notice Returns the unix timestamp (uint256) at which the PT contract expires\n     * @return The unix timestamp (uint256) when PTs become redeemable\n     */\n    function maturity() external view returns (uint256);\n\n    /**\n     * @notice Returns the duration of the PT contract\n     * @return The duration (in s) to expiry/maturity of the PT contract\n     */\n    function getDuration() external view returns (uint256);\n\n    /**\n     * @notice Returns the address of the underlying token (or asset). Equivalent to ERC-4626's asset method.\n     * @return The address of the underlying token (or asset)\n     */\n    function underlying() external view returns (address);\n\n    /**\n     * @notice Returns the IBT address of the PT contract\n     * @return ibt The address of the IBT\n     */\n    function getIBT() external view returns (address ibt);\n\n    /**\n     * @notice Returns the yt address of the PT contract\n     * @return yt The address of the yt\n     */\n    function getYT() external view returns (address yt);\n\n    /**\n     * @notice Returns the current ibtRate\n     * @return The current ibtRate\n     */\n    function getIBTRate() external view returns (uint256);\n\n    /**\n     * @notice Returns the current ptRate\n     * @return The current ptRate\n     */\n    function getPTRate() external view returns (uint256);\n\n    /**\n     * @notice Returns 1 unit of IBT\n     * @return The IBT unit\n     */\n    function getIBTUnit() external view returns (uint256);\n\n    /**\n     * @notice Get the unclaimed fees in IBT\n     * @return The unclaimed fees in IBT\n     */\n    function getUnclaimedFeesInIBT() external view returns (uint256);\n\n    /**\n     * @notice Get the total collected fees in IBT (claimed and unclaimed)\n     * @return The total fees in IBT\n     */\n    function getTotalFeesInIBT() external view returns (uint256);\n\n    /**\n     * @notice Get the tokenization fee of the PT\n     * @return The tokenization fee\n     */\n    function getTokenizationFee() external view returns (uint256);\n\n    /**\n     * @notice Get the current IBT yield of the user\n     * @param _user The address of the user to get the current yield from\n     * @return The yield of the user in IBT\n     */\n    function getCurrentYieldOfUserInIBT(address _user) external view returns (uint256);\n}\n"
    },
    "src/interfaces/IRegistry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.20;\n\ninterface IRegistry {\n    /* Errors\n     *****************************************************************************************************************/\n    error FeeGreaterThanMaxValue();\n    error PTListUpdateFailed();\n    error ReductionTooBig();\n    error AddressError();\n\n    /* GETTERS\n     *****************************************************************************************************************/\n\n    /**\n     * @notice Getter for the factory address\n     * @return The address of token factory\n     */\n    function getFactory() external view returns (address);\n\n    /**\n     * @notice Get the address of the router\n     * @return The address of the router\n     */\n    function getRouter() external view returns (address);\n\n    /**\n     * @notice Get the address of the routerUtil\n     * @return The address of the routerUtil\n     */\n    function getRouterUtil() external view returns (address);\n\n    /**\n     * @notice Get the address of the pt beacon\n     * @return The address of PT beacon\n     */\n    function getPTBeacon() external view returns (address);\n\n    /**\n     * @notice Get the address of the yt beacon\n     * @return The address of yt beacon\n     */\n    function getYTBeacon() external view returns (address);\n\n    /**\n     * @notice Get the value of tokenization fee\n     * @return The value of tokenization fee\n     */\n    function getTokenizationFee() external view returns (uint256);\n\n    /**\n     * @notice Get the value of yield fee\n     * @return The value of yield fee\n     */\n    function getYieldFee() external view returns (uint256);\n\n    /**\n     * @notice Get the value of PT flash loan fee\n     * @return The value of PT flash loan fee\n     */\n    function getPTFlashLoanFee() external view returns (uint256);\n\n    /**\n     * @notice Get the address of the fee collector\n     * @return The address of fee collector\n     */\n    function getFeeCollector() external view returns (address);\n\n    /**\n     * @notice Get the fee reduction of the given user for the given pt\n     * @param _pt The address of the pt\n     * @param _user The address of the user\n     * @return The fee reduction of the given user for the given pt\n     */\n    function getFeeReduction(address _pt, address _user) external view returns (uint256);\n\n    /**\n     * @notice Getter to check if a pt is registered\n     * @param _pt the address of the pt to check the registration of\n     * @return true if it is, false otherwise\n     */\n    function isRegisteredPT(address _pt) external view returns (bool);\n\n    /**\n     * @notice Getter for the pt registered at an index\n     * @param _index the index of the pt to return\n     * @return The address of the corresponding pt\n     */\n    function getPTAt(uint256 _index) external view returns (address);\n\n    /**\n     * @notice Getter for number of PT registered\n     * @return The number of PT registered\n     */\n    function pTCount() external view returns (uint256);\n\n    /* SETTERS\n     *****************************************************************************************************************/\n\n    /**\n     * @notice Setter for the tokens factory address\n     * @param _newFactory The address of the new factory\n     */\n    function setFactory(address _newFactory) external;\n\n    /**\n     * @notice set the router\n     * @param _router The address of the router\n     */\n    function setRouter(address _router) external;\n\n    /**\n     * @notice set the routerUtil\n     * @param _routerUtil The address of the routerUtil\n     */\n    function setRouterUtil(address _routerUtil) external;\n\n    /**\n     * @notice set the tokenization fee\n     * @param _tokenizationFee The value of tokenization fee\n     */\n    function setTokenizationFee(uint256 _tokenizationFee) external;\n\n    /**\n     * @notice set the yield fee\n     * @param _yieldFee The value of yield fee\n     */\n    function setYieldFee(uint256 _yieldFee) external;\n\n    /**\n     * @notice set the PT flash loan fee\n     * @param _ptFlashLoanFee The value of PT flash loan fee\n     */\n    function setPTFlashLoanFee(uint256 _ptFlashLoanFee) external;\n\n    /**\n     * @notice set the fee collector\n     * @param _feeCollector The address of fee collector\n     */\n    function setFeeCollector(address _feeCollector) external;\n\n    /**\n     * @notice Set the fee reduction of the given pt for the given user\n     * @param _pt The address of the pt\n     * @param _user The address of the user\n     * @param _reduction The fee reduction\n     */\n    function reduceFee(address _pt, address _user, uint256 _reduction) external;\n\n    /**\n     * @notice set the pt beacon\n     * @param _ptBeacon The address of PT beacon\n     */\n    function setPTBeacon(address _ptBeacon) external;\n\n    /**\n     * @notice set the yt beacon\n     * @param _ytBeacon The address of yt beacon\n     */\n    function setYTBeacon(address _ytBeacon) external;\n\n    /**\n     * @notice Add a pt to the registry\n     * @param _pt The address of the pt to add to the registry\n     */\n    function addPT(address _pt) external;\n\n    /**\n     * @notice Remove a pt from the registry\n     * @param _pt The address of the pt to remove from the registry\n     */\n    function removePT(address _pt) external;\n}\n"
    },
    "src/interfaces/IStableSwapNG.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.4;\n\ninterface IStableSwapNG {\n    function A() external view returns (uint256);\n    function A_precise() external view returns (uint256);\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function D_ma_time() external view returns (uint256);\n    function D_oracle() external view returns (uint256);\n    function N_COINS() external view returns (uint256);\n    function add_liquidity(\n        uint256[] memory _amounts,\n        uint256 _min_mint_amount,\n        address _receiver\n    ) external returns (uint256);\n    function admin_balances(uint256 arg0) external view returns (uint256);\n    function admin_fee() external view returns (uint256);\n    function allowance(address arg0, address arg1) external view returns (uint256);\n    function approve(address _spender, uint256 _value) external returns (bool);\n    function balanceOf(address arg0) external view returns (uint256);\n    function balances(uint256 i) external view returns (uint256);\n    function calc_token_amount(\n        uint256[] memory _amounts,\n        bool _is_deposit\n    ) external view returns (uint256);\n    function calc_withdraw_one_coin(uint256 _burn_amount, int128 i) external view returns (uint256);\n    function coins(uint256 arg0) external view returns (address);\n    function decimals() external view returns (uint8);\n    function dynamic_fee(int128 i, int128 j) external view returns (uint256);\n    function ema_price(uint256 i) external view returns (uint256);\n    function exchange(int128 i, int128 j, uint256 _dx, uint256 _min_dy) external returns (uint256);\n    function exchange(\n        int128 i,\n        int128 j,\n        uint256 _dx,\n        uint256 _min_dy,\n        address _receiver\n    ) external returns (uint256);\n    function exchange_received(\n        int128 i,\n        int128 j,\n        uint256 _dx,\n        uint256 _min_dy\n    ) external returns (uint256);\n    function exchange_received(\n        int128 i,\n        int128 j,\n        uint256 _dx,\n        uint256 _min_dy,\n        address _receiver\n    ) external returns (uint256);\n    function fee() external view returns (uint256);\n    function future_A() external view returns (uint256);\n    function future_A_time() external view returns (uint256);\n    function get_balances() external view returns (uint256[] memory);\n    function get_dx(int128 i, int128 j, uint256 dy) external view returns (uint256);\n    function get_dy(int128 i, int128 j, uint256 dx) external view returns (uint256);\n    function get_p(uint256 i) external view returns (uint256);\n    function get_virtual_price() external view returns (uint256);\n    function initial_A() external view returns (uint256);\n    function initial_A_time() external view returns (uint256);\n    function last_price(uint256 i) external view returns (uint256);\n    function ma_exp_time() external view returns (uint256);\n    function ma_last_time() external view returns (uint256);\n    function name() external view returns (string memory);\n    function nonces(address arg0) external view returns (uint256);\n    function offpeg_fee_multiplier() external view returns (uint256);\n    function permit(\n        address _owner,\n        address _spender,\n        uint256 _value,\n        uint256 _deadline,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external returns (bool);\n    function price_oracle(uint256 i) external view returns (uint256);\n    function ramp_A(uint256 _future_A, uint256 _future_time) external;\n    function remove_liquidity(\n        uint256 _burn_amount,\n        uint256[] memory _min_amounts\n    ) external returns (uint256[] memory);\n    function remove_liquidity(\n        uint256 _burn_amount,\n        uint256[] memory _min_amounts,\n        address _receiver\n    ) external returns (uint256[] memory);\n    function remove_liquidity(\n        uint256 _burn_amount,\n        uint256[] memory _min_amounts,\n        address _receiver,\n        bool _claim_admin_fees\n    ) external returns (uint256[] memory);\n    function remove_liquidity_imbalance(\n        uint256[] memory _amounts,\n        uint256 _max_burn_amount\n    ) external returns (uint256);\n    function remove_liquidity_imbalance(\n        uint256[] memory _amounts,\n        uint256 _max_burn_amount,\n        address _receiver\n    ) external returns (uint256);\n    function remove_liquidity_one_coin(\n        uint256 _burn_amount,\n        int128 i,\n        uint256 _min_received\n    ) external returns (uint256);\n    function remove_liquidity_one_coin(\n        uint256 _burn_amount,\n        int128 i,\n        uint256 _min_received,\n        address _receiver\n    ) external returns (uint256);\n    function salt() external view returns (bytes32);\n    function set_ma_exp_time(uint256 _ma_exp_time, uint256 _D_ma_time) external;\n    function set_new_fee(uint256 _new_fee, uint256 _new_offpeg_fee_multiplier) external;\n    function stop_ramp_A() external;\n    function stored_rates() external view returns (uint256[] memory);\n    function symbol() external view returns (string memory);\n    function totalSupply() external view returns (uint256);\n    function transfer(address _to, uint256 _value) external returns (bool);\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\n    function version() external view returns (string memory);\n    function withdraw_admin_fees() external;\n}\n"
    },
    "src/interfaces/IRateOracleRegistry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.20;\n\ninterface IRateOracleRegistry {\n    /* Errors\n     *****************************************************************************************************************/\n    error AddressError();\n    error PTRateOracleMismatch();\n    error RegistryOverwriteAttempt(address _pt, address _rateOracleRegistry);\n\n    /* GETTERS\n     *****************************************************************************************************************/\n\n    function getFactorySNG() external view returns (address);\n\n    function getRateOracleBeacon() external view returns (address);\n\n    function getRateOracle(address _pt) external view returns (address);\n\n    /* SETTERS\n     *****************************************************************************************************************/\n\n    /**\n     * @notice set the factory with rate oracle pool\n     * @param _factorySNG address of the factory\n     */\n    function setFactorySNG(address _factorySNG) external;\n\n    /**\n     * @notice set the rate oracle beacon\n     * @param _rateOracleBeacon The address of yt beacon\n     */\n    function setRateOracleBeacon(address _rateOracleBeacon) external;\n\n    /**\n     * @notice Add a rate oracle to the registry\n     * @param _pt The address of the pt in the pool using the rate oracle\n     * @param _rateOracle The address of the rate oracle to add to the registry\n     */\n    function addRateOracle(address _pt, address _rateOracle) external;\n\n    /**\n     * @notice Remove a rate oracle from the registry\n     * @param _pt The address of the pt in the pool using the rate oracle\n     * @param _rateOracle The address of the rate oracle to remove from the registry\n     */\n    function removeRateOracle(address _pt, address _rateOracle) external;\n}\n"
    },
    "src/libraries/CurvePoolUtil.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.20;\n\nimport \"../interfaces/ICurvePool.sol\";\nimport \"../interfaces/ICurveNGPool.sol\";\nimport \"../interfaces/IStableSwapNG.sol\";\nimport \"../interfaces/IPrincipalToken.sol\";\nimport \"./RayMath.sol\";\nimport \"openzeppelin-math/Math.sol\";\n\n/**\n * @title CurvePoolUtil library\n * @author Spectra Finance\n * @notice Provides miscellaneous utils for computations related to Curve CryptoSwap pools.\n */\nlibrary CurvePoolUtil {\n    using Math for uint256;\n    using RayMath for uint256;\n\n    error SolutionNotFound();\n    error FailedToFetchExpectedLPTokenAmount();\n    error FailedToFetchExpectedCoinAmount();\n\n    /// @notice Decimal precision used internally in the Curve AMM\n    uint256 public constant CURVE_DECIMALS = 18;\n    /// @notice Base unit for Curve AMM calculations\n    uint256 public constant CURVE_UNIT = 1e18;\n    /// @notice Make rounding errors favoring other LPs a tiny bit\n    uint256 private constant APPROXIMATION_DECREMENT = 1;\n    /// @notice Maximal number of iterations in the binary search algorithm\n    uint256 private constant MAX_ITERATIONS_BINSEARCH = 255;\n\n    /**\n     * @notice Returns the expected LP token amount received for depositing given amounts of IBT and PT\n     * @notice Method to be used with legacy Curve Cryptoswap pools\n     * @param _curvePool The address of the Curve Pool in which liquidity will be deposited\n     * @param _amounts Array containing the amounts of IBT and PT to deposit in the Curve Pool\n     * @return minMintAmount The amount of expected LP tokens received for depositing the liquidity in the pool\n     */\n    function previewAddLiquidity(\n        address _curvePool,\n        uint256[2] memory _amounts\n    ) external view returns (uint256 minMintAmount) {\n        (bool success, bytes memory responseData) = _curvePool.staticcall(\n            abi.encodeCall(ICurvePool(address(0)).calc_token_amount, (_amounts))\n        );\n        if (!success) {\n            revert FailedToFetchExpectedLPTokenAmount();\n        }\n        minMintAmount = abi.decode(responseData, (uint256));\n    }\n\n    /**\n     * @notice Returns the expected LP token amount received for depositing given amounts of IBT and PT\n     * @notice Method to be used with legacy Curve Cryptoswap NG pools\n     * @param _curvePool The address of the Curve Pool in which liquidity will be deposited\n     * @param _amounts Array containing the amounts of IBT and PT to deposit in the Curve Pool\n     * @return minMintAmount The amount of expected LP tokens received for depositing the liquidity in the pool\n     */\n    function previewAddLiquidityNG(\n        address _curvePool,\n        uint256[2] memory _amounts\n    ) external view returns (uint256 minMintAmount) {\n        (bool success, bytes memory responseData) = _curvePool.staticcall(\n            abi.encodeCall(ICurveNGPool(address(0)).calc_token_amount, (_amounts, true))\n        );\n        if (!success) {\n            revert FailedToFetchExpectedLPTokenAmount();\n        }\n        minMintAmount = abi.decode(responseData, (uint256));\n    }\n\n    /**\n     * @notice Returns the expected LP token amount received for depositing given amounts of IBT and PT\n     * @notice Method to be used with StableSwap NG pools\n     * @param _curvePool The address of the Curve Pool in which liquidity will be deposited\n     * @param _amounts Array containing the amounts of IBT and PT to deposit in the Curve Pool\n     * @return minMintAmount The amount of expected LP tokens received for depositing the liquidity in the pool\n     */\n    function previewAddLiquiditySNG(\n        address _curvePool,\n        uint256[] memory _amounts\n    ) external view returns (uint256 minMintAmount) {\n        // @dev set the is_deposit to true\n        (bool success, bytes memory responseData) = _curvePool.staticcall(\n            abi.encodeCall(IStableSwapNG(address(0)).calc_token_amount, (_amounts, true))\n        );\n        if (!success) {\n            revert FailedToFetchExpectedLPTokenAmount();\n        }\n        minMintAmount = abi.decode(responseData, (uint256));\n    }\n\n    /**\n     * @notice Returns the IBT and PT amounts received for burning a given amount of LP tokens\n     * @notice Method to be used with legacy Curve Cryptoswap pools\n     * @param _curvePool The address of the curve pool\n     * @param _lpTokenAmount The amount of the lp token to burn\n     * @return minAmounts The expected respective amounts of IBT and PT withdrawn from the curve pool\n     */\n    function previewRemoveLiquidity(\n        address _curvePool,\n        uint256 _lpTokenAmount\n    ) external view returns (uint256[2] memory minAmounts) {\n        address lpToken = ICurvePool(_curvePool).token();\n        uint256 totalSupply = IERC20(lpToken).totalSupply();\n        (uint256 ibtBalance, uint256 ptBalance) = _getCurvePoolBalances(_curvePool);\n        // decrement following what Curve is doing\n        if (_lpTokenAmount > APPROXIMATION_DECREMENT && totalSupply != 0) {\n            _lpTokenAmount -= APPROXIMATION_DECREMENT;\n            minAmounts = [\n                (ibtBalance * _lpTokenAmount) / totalSupply,\n                (ptBalance * _lpTokenAmount) / totalSupply\n            ];\n        } else {\n            minAmounts = [uint256(0), uint256(0)];\n        }\n    }\n\n    /**\n     * @notice Returns the IBT and PT amounts received for burning a given amount of LP tokens\n     * @notice Method to be used with Curve Cryptoswap NG pools\n     * @param _curvePool The address of the curve pool\n     * @param _lpTokenAmount The amount of the lp token to burn\n     * @return minAmounts The expected respective amounts of IBT and PT withdrawn from the curve pool\n     */\n    function previewRemoveLiquidityNG(\n        address _curvePool,\n        uint256 _lpTokenAmount\n    ) external view returns (uint256[2] memory minAmounts) {\n        uint256 totalSupply = ICurveNGPool(_curvePool).totalSupply();\n        (uint256 ibtBalance, uint256 ptBalance) = _getCurvePoolBalances(_curvePool);\n        // reproduces Curve implementation\n        if (_lpTokenAmount == totalSupply) {\n            minAmounts = [ibtBalance, ptBalance];\n        } else if (_lpTokenAmount > APPROXIMATION_DECREMENT && totalSupply != 0) {\n            _lpTokenAmount -= APPROXIMATION_DECREMENT;\n            minAmounts = [\n                ibtBalance.mulDiv(_lpTokenAmount, totalSupply),\n                ptBalance.mulDiv(_lpTokenAmount, totalSupply)\n            ];\n        } else {\n            minAmounts = [uint256(0), uint256(0)];\n        }\n    }\n\n    /**\n     * @notice Returns the IBT and PT amounts received for burning a given amount of LP tokens\n     * @notice Method to be used with StableSwap NG pools\n     * @param _curvePool The address of the curve pool\n     * @param _lpTokenAmount The amount of the lp token to burn\n     * @return minAmounts The expected respective amounts of IBT and PT withdrawn from the curve pool\n     */\n    function previewRemoveLiquiditySNG(\n        address _curvePool,\n        uint256 _lpTokenAmount\n    ) external view returns (uint256[] memory) {\n        uint256 totalSupply = IERC20(_curvePool).totalSupply();\n        (uint256 ibtBalance, uint256 ptBalance) = _getCurvePoolBalances(_curvePool);\n        // decrement following what Curve is doing\n        uint256[] memory minAmounts = new uint256[](2);\n        if (_lpTokenAmount > APPROXIMATION_DECREMENT && totalSupply != 0) {\n            _lpTokenAmount -= APPROXIMATION_DECREMENT;\n            minAmounts[0] = (ibtBalance * _lpTokenAmount) / totalSupply;\n            minAmounts[1] = (ptBalance * _lpTokenAmount) / totalSupply;\n        } else {\n            minAmounts[0] = 0;\n            minAmounts[1] = 0;\n        }\n        return minAmounts;\n    }\n\n    /**\n     * @notice Returns the amount of coin i received for burning a given amount of LP tokens\n     * @notice Method to be used with legacy Curve CryptoSwap pools\n     * @param _curvePool The address of the curve pool\n     * @param _lpTokenAmount The amount of the LP tokens to burn\n     * @param _i The index of the unique coin to withdraw\n     * @return minAmount The expected amount of coin i withdrawn from the curve pool\n     */\n    function previewRemoveLiquidityOneCoin(\n        address _curvePool,\n        uint256 _lpTokenAmount,\n        uint256 _i\n    ) external view returns (uint256 minAmount) {\n        (bool success, bytes memory responseData) = _curvePool.staticcall(\n            abi.encodeCall(ICurvePool(address(0)).calc_withdraw_one_coin, (_lpTokenAmount, _i))\n        );\n        if (!success) {\n            revert FailedToFetchExpectedCoinAmount();\n        }\n        minAmount = abi.decode(responseData, (uint256));\n    }\n\n    /**\n     * @notice Returns the amount of coin i received for burning a given amount of LP tokens\n     * @notice Method to be used with Curve NG pools\n     * @param _curvePool The address of the curve pool\n     * @param _lpTokenAmount The amount of the LP tokens to burn\n     * @param _i The index of the unique coin to withdraw\n     * @return minAmount The expected amount of coin i withdrawn from the curve pool\n     */\n    function previewRemoveLiquidityOneCoinNG(\n        address _curvePool,\n        uint256 _lpTokenAmount,\n        uint256 _i\n    ) external view returns (uint256 minAmount) {\n        (bool success, bytes memory responseData) = _curvePool.staticcall(\n            abi.encodeCall(ICurveNGPool(address(0)).calc_withdraw_one_coin, (_lpTokenAmount, _i))\n        );\n        if (!success) {\n            revert FailedToFetchExpectedCoinAmount();\n        }\n        minAmount = abi.decode(responseData, (uint256));\n    }\n\n    /**\n     * @notice Returns the amount of coin i received for burning a given amount of LP tokens\n     * @notice Method to be used with StableSwap NG pools\n     * @param _curvePool The address of the curve pool\n     * @param _lpTokenAmount The amount of the LP tokens to burn\n     * @param _i The index of the unique coin to withdraw\n     * @return minAmount The expected amount of coin i withdrawn from the curve pool\n     */\n    function previewRemoveLiquidityOneCoinSNG(\n        address _curvePool,\n        uint256 _lpTokenAmount,\n        int128 _i\n    ) external view returns (uint256 minAmount) {\n        (bool success, bytes memory responseData) = _curvePool.staticcall(\n            abi.encodeCall(IStableSwapNG(address(0)).calc_withdraw_one_coin, (_lpTokenAmount, _i))\n        );\n        if (!success) {\n            revert FailedToFetchExpectedCoinAmount();\n        }\n        minAmount = abi.decode(responseData, (uint256));\n    }\n\n    /**\n     * @notice Return the amount of IBT to deposit in the curve pool, given the total amount of IBT available for deposit\n     * @param _amount The total amount of IBT available for deposit\n     * @param _curvePool The address of the pool to deposit the amounts\n     * @param _pt The address of the PT\n     * @return ibts The amount of IBT which will be deposited in the curve pool\n     */\n    function calcIBTsToTokenizeForCurvePool(\n        uint256 _amount,\n        address _curvePool,\n        address _pt\n    ) external view returns (uint256 ibts) {\n        (uint256 ibtBalance, uint256 ptBalance) = _getCurvePoolBalances(_curvePool);\n        uint256 ibtBalanceInPT = IPrincipalToken(_pt).previewDepositIBT(ibtBalance);\n        // Liquidity added in a ratio that (closely) matches the existing pool's ratio\n        ibts = _amount.mulDiv(ptBalance, ibtBalanceInPT + ptBalance);\n    }\n\n    /**\n     * @notice Return the amount of IBT to deposit in the curve pool given the proportion in which we want to deposit, given the total amount of IBT available for deposit\n     * @param _amount The total amount of IBT available for deposit\n     * @param _prop The proportion in which we want to make the deposit: _prop = nIBT / (nIBT + nPT)\n     * @param _pt The address of the PT\n     * @return ibts The amount of IBT which will be deposited in the curve pool\n     */\n    function calcIBTsToTokenizeForCurvePoolCustomProp(\n        uint256 _amount,\n        uint256 _prop,\n        address _pt\n    ) external view returns (uint256 ibts) {\n        uint256 rate = IPrincipalToken(_pt).previewDepositIBT(_amount).mulDiv(CURVE_UNIT, _amount);\n        ibts = _amount.mulDiv(CURVE_UNIT, CURVE_UNIT + _prop.mulDiv(rate, CURVE_UNIT));\n    }\n\n    /**\n     * @param _curvePool : PT/IBT curve pool\n     * @param _i token index\n     * @param _j token index\n     * @param _targetDy amount out desired\n     * @return dx The amount of token to provide in order to obtain _targetDy after swap\n     */\n    function getDx(\n        address _curvePool,\n        uint256 _i,\n        uint256 _j,\n        uint256 _targetDy\n    ) external view returns (uint256 dx) {\n        // Initial guesses\n        uint256 _minGuess = type(uint256).max;\n        uint256 _maxGuess = type(uint256).max;\n        uint256 _factor100;\n        uint256 _guess = ICurvePool(_curvePool).get_dy(_i, _j, _targetDy);\n\n        if (_guess > _targetDy) {\n            _maxGuess = _targetDy;\n            _factor100 = 10;\n        } else {\n            _minGuess = _targetDy;\n            _factor100 = 1000;\n        }\n        uint256 loops;\n        _guess = _targetDy;\n        while (!_dxSolved(_curvePool, _i, _j, _guess, _targetDy, _minGuess, _maxGuess)) {\n            loops++;\n\n            (_minGuess, _maxGuess, _guess) = _runLoop(\n                _minGuess,\n                _maxGuess,\n                _factor100,\n                _guess,\n                _targetDy,\n                _curvePool,\n                _i,\n                _j\n            );\n\n            if (loops >= MAX_ITERATIONS_BINSEARCH) {\n                revert SolutionNotFound();\n            }\n        }\n        dx = _guess;\n    }\n\n    /**\n     * @dev Runs bisection search\n     * @param _minGuess lower bound on searched value\n     * @param _maxGuess upper bound on searched value\n     * @param _factor100 search interval scaling factor\n     * @param _guess The previous guess for the `dx` value that is being refined through the search process\n     * @param _targetDy The target output of the `get_dy` function, which the search aims to achieve by adjusting `dx`.\n     * @param _curvePool PT/IBT curve pool\n     * @param _i token index, either 0 or 1\n     * @param _j token index, either 0 or 1, must be different than _i\n     * @return The lower bound on _guess, upper bound on _guess and next _guess\n     */\n    function _runLoop(\n        uint256 _minGuess,\n        uint256 _maxGuess,\n        uint256 _factor100,\n        uint256 _guess,\n        uint256 _targetDy,\n        address _curvePool,\n        uint256 _i,\n        uint256 _j\n    ) internal view returns (uint256, uint256, uint256) {\n        if (_minGuess == type(uint256).max || _maxGuess == type(uint256).max) {\n            _guess = (_guess * _factor100) / 100;\n        } else {\n            _guess = (_maxGuess + _minGuess) >> 1;\n        }\n        uint256 dy = ICurvePool(_curvePool).get_dy(_i, _j, _guess);\n        if (dy < _targetDy) {\n            _minGuess = _guess;\n        } else if (dy > _targetDy) {\n            _maxGuess = _guess;\n        }\n        return (_minGuess, _maxGuess, _guess);\n    }\n\n    /**\n     * @dev Returns true if algorithm converged\n     * @param _curvePool PT/IBT curve pool\n     * @param _i token index, either 0 or 1\n     * @param _j token index, either 0 or 1, must be different than _i\n     * @param _dx The current guess for the `dx` value that is being refined through the search process.\n     * @param _targetDy The target output of the `get_dy` function, which the search aims to achieve by adjusting `dx`.\n     * @param _minGuess lower bound on searched value\n     * @param _maxGuess upper bound on searched value\n     * @return true if the solution to the search problem was found, false otherwise\n     */\n    function _dxSolved(\n        address _curvePool,\n        uint256 _i,\n        uint256 _j,\n        uint256 _dx,\n        uint256 _targetDy,\n        uint256 _minGuess,\n        uint256 _maxGuess\n    ) internal view returns (bool) {\n        if (_minGuess == type(uint256).max || _maxGuess == type(uint256).max) {\n            return false;\n        }\n        uint256 dy = ICurvePool(_curvePool).get_dy(_i, _j, _dx);\n        if (dy == _targetDy) {\n            return true;\n        }\n        uint256 dy1 = ICurvePool(_curvePool).get_dy(_i, _j, _dx + 1);\n        if (dy < _targetDy && _targetDy < dy1) {\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * @notice Returns the balances of the two tokens in provided curve pool\n     * @param _curvePool address of the curve pool\n     * @return The IBT and PT balances of the curve pool\n     */\n    function _getCurvePoolBalances(address _curvePool) internal view returns (uint256, uint256) {\n        return (ICurvePool(_curvePool).balances(0), ICurvePool(_curvePool).balances(1));\n    }\n}\n"
    },
    "src/libraries/Roles.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.20;\n\n/**\n * @title Roles library\n * @author Spectra Finance\n * @notice Identifiers for roles used in Spectra protocol.\n */\nlibrary Roles {\n    uint64 internal constant ADMIN_ROLE = 0;\n    uint64 internal constant UPGRADE_ROLE = 1;\n    uint64 internal constant PAUSER_ROLE = 2;\n    uint64 internal constant FEE_SETTER_ROLE = 3;\n    uint64 internal constant REGISTRY_ROLE = 4;\n    uint64 internal constant REWARDS_HARVESTER_ROLE = 5;\n    uint64 internal constant REWARDS_PROXY_SETTER_ROLE = 6;\n    uint64 internal constant VOTER_GOVERNOR_ROLE = 7;\n    uint64 internal constant VOTER_EMERGENCY_COUNCIL_ROLE = 8;\n    uint64 internal constant VOTER_ROLE = 9;\n    uint64 internal constant FEES_VOTING_REWARDS_DISTRIBUTOR_ROLE = 10;\n    uint64 internal constant MINTER_ROLE = 11;\n    uint64 internal constant MANAGED_DEPOSITS_ROLE = 12;\n    uint64 internal constant VOTING_ESCROW_MANAGER_ROLE = 13;\n    uint64 internal constant RATE_ADJUSTMENT_ORACLE_SETTER_ROLE = 14;\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/access/manager/IAccessManaged.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/manager/IAccessManaged.sol)\n\npragma solidity ^0.8.20;\n\ninterface IAccessManaged {\n    /**\n     * @dev Authority that manages this contract was updated.\n     */\n    event AuthorityUpdated(address authority);\n\n    error AccessManagedUnauthorized(address caller);\n    error AccessManagedRequiredDelay(address caller, uint32 delay);\n    error AccessManagedInvalidAuthority(address authority);\n\n    /**\n     * @dev Returns the current authority.\n     */\n    function authority() external view returns (address);\n\n    /**\n     * @dev Transfers control to a new authority. The caller must be the current authority.\n     */\n    function setAuthority(address) external;\n\n    /**\n     * @dev Returns true only in the context of a delayed restricted call, at the moment that the scheduled operation is\n     * being consumed. Prevents denial of service for delayed restricted calls in the case that the contract performs\n     * attacker controlled calls.\n     */\n    function isConsumingScheduledOp() external view returns (bytes4);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/types/Time.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/types/Time.sol)\n\npragma solidity ^0.8.20;\n\nimport {Math} from \"../math/Math.sol\";\nimport {SafeCast} from \"../math/SafeCast.sol\";\n\n/**\n * @dev This library provides helpers for manipulating time-related objects.\n *\n * It uses the following types:\n * - `uint48` for timepoints\n * - `uint32` for durations\n *\n * While the library doesn't provide specific types for timepoints and duration, it does provide:\n * - a `Delay` type to represent duration that can be programmed to change value automatically at a given point\n * - additional helper functions\n */\nlibrary Time {\n    using Time for *;\n\n    /**\n     * @dev Get the block timestamp as a Timepoint.\n     */\n    function timestamp() internal view returns (uint48) {\n        return SafeCast.toUint48(block.timestamp);\n    }\n\n    /**\n     * @dev Get the block number as a Timepoint.\n     */\n    function blockNumber() internal view returns (uint48) {\n        return SafeCast.toUint48(block.number);\n    }\n\n    // ==================================================== Delay =====================================================\n    /**\n     * @dev A `Delay` is a uint32 duration that can be programmed to change value automatically at a given point in the\n     * future. The \"effect\" timepoint describes when the transitions happens from the \"old\" value to the \"new\" value.\n     * This allows updating the delay applied to some operation while keeping some guarantees.\n     *\n     * In particular, the {update} function guarantees that if the delay is reduced, the old delay still applies for\n     * some time. For example if the delay is currently 7 days to do an upgrade, the admin should not be able to set\n     * the delay to 0 and upgrade immediately. If the admin wants to reduce the delay, the old delay (7 days) should\n     * still apply for some time.\n     *\n     *\n     * The `Delay` type is 112 bits long, and packs the following:\n     *\n     * ```\n     *   | [uint48]: effect date (timepoint)\n     *   |           | [uint32]: value before (duration)\n     *   ↓           ↓       ↓ [uint32]: value after (duration)\n     * 0xAAAAAAAAAAAABBBBBBBBCCCCCCCC\n     * ```\n     *\n     * NOTE: The {get} and {withUpdate} functions operate using timestamps. Block number based delays are not currently\n     * supported.\n     */\n    type Delay is uint112;\n\n    /**\n     * @dev Wrap a duration into a Delay to add the one-step \"update in the future\" feature\n     */\n    function toDelay(uint32 duration) internal pure returns (Delay) {\n        return Delay.wrap(duration);\n    }\n\n    /**\n     * @dev Get the value at a given timepoint plus the pending value and effect timepoint if there is a scheduled\n     * change after this timepoint. If the effect timepoint is 0, then the pending value should not be considered.\n     */\n    function _getFullAt(Delay self, uint48 timepoint) private pure returns (uint32, uint32, uint48) {\n        (uint32 valueBefore, uint32 valueAfter, uint48 effect) = self.unpack();\n        return effect <= timepoint ? (valueAfter, 0, 0) : (valueBefore, valueAfter, effect);\n    }\n\n    /**\n     * @dev Get the current value plus the pending value and effect timepoint if there is a scheduled change. If the\n     * effect timepoint is 0, then the pending value should not be considered.\n     */\n    function getFull(Delay self) internal view returns (uint32, uint32, uint48) {\n        return _getFullAt(self, timestamp());\n    }\n\n    /**\n     * @dev Get the current value.\n     */\n    function get(Delay self) internal view returns (uint32) {\n        (uint32 delay, , ) = self.getFull();\n        return delay;\n    }\n\n    /**\n     * @dev Update a Delay object so that it takes a new duration after a timepoint that is automatically computed to\n     * enforce the old delay at the moment of the update. Returns the updated Delay object and the timestamp when the\n     * new delay becomes effective.\n     */\n    function withUpdate(\n        Delay self,\n        uint32 newValue,\n        uint32 minSetback\n    ) internal view returns (Delay updatedDelay, uint48 effect) {\n        uint32 value = self.get();\n        uint32 setback = uint32(Math.max(minSetback, value > newValue ? value - newValue : 0));\n        effect = timestamp() + setback;\n        return (pack(value, newValue, effect), effect);\n    }\n\n    /**\n     * @dev Split a delay into its components: valueBefore, valueAfter and effect (transition timepoint).\n     */\n    function unpack(Delay self) internal pure returns (uint32 valueBefore, uint32 valueAfter, uint48 effect) {\n        uint112 raw = Delay.unwrap(self);\n\n        valueAfter = uint32(raw);\n        valueBefore = uint32(raw >> 32);\n        effect = uint48(raw >> 64);\n\n        return (valueBefore, valueAfter, effect);\n    }\n\n    /**\n     * @dev pack the components into a Delay object.\n     */\n    function pack(uint32 valueBefore, uint32 valueAfter, uint48 effect) internal pure returns (Delay) {\n        return Delay.wrap((uint112(effect) << 64) | (uint112(valueBefore) << 32) | uint112(valueAfter));\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/access/manager/IAuthority.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/manager/IAuthority.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard interface for permissioning originally defined in Dappsys.\n */\ninterface IAuthority {\n    /**\n     * @dev Returns true if the caller can invoke on a target the function identified by a function selector.\n     */\n    function canCall(address caller, address target, bytes4 selector) external view returns (bool allowed);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/access/manager/AuthorityUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/manager/AuthorityUtils.sol)\n\npragma solidity ^0.8.20;\n\nimport {IAuthority} from \"./IAuthority.sol\";\n\nlibrary AuthorityUtils {\n    /**\n     * @dev Since `AccessManager` implements an extended IAuthority interface, invoking `canCall` with backwards compatibility\n     * for the preexisting `IAuthority` interface requires special care to avoid reverting on insufficient return data.\n     * This helper function takes care of invoking `canCall` in a backwards compatible way without reverting.\n     */\n    function canCallWithDelay(\n        address authority,\n        address caller,\n        address target,\n        bytes4 selector\n    ) internal view returns (bool immediate, uint32 delay) {\n        (bool success, bytes memory data) = authority.staticcall(\n            abi.encodeCall(IAuthority.canCall, (caller, target, selector))\n        );\n        if (success) {\n            if (data.length >= 0x40) {\n                (immediate, delay) = abi.decode(data, (bool, uint32));\n            } else if (data.length >= 0x20) {\n                immediate = abi.decode(data, (bool));\n            }\n        }\n        return (immediate, delay);\n    }\n}\n"
    },
    "lib/openzeppelin-contracts-upgradeable/contracts/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Context.sol)\n\npragma solidity ^0.8.20;\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "lib/openzeppelin-contracts-upgradeable/contracts/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Storage of the initializable contract.\n     *\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n     * when using with upgradeable contracts.\n     *\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n     */\n    struct InitializableStorage {\n        /**\n         * @dev Indicates that the contract has been initialized.\n         */\n        uint64 _initialized;\n        /**\n         * @dev Indicates that the contract is in the process of being initialized.\n         */\n        bool _initializing;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Initializable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n\n    /**\n     * @dev The contract is already initialized.\n     */\n    error InvalidInitialization();\n\n    /**\n     * @dev The contract is not initializing.\n     */\n    error NotInitializing();\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint64 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n     * production.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        // Cache values to avoid duplicated sloads\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n\n        // Allowed calls:\n        // - initialSetup: the contract is not in the initializing state and no previous version was\n        //                 initialized\n        // - construction: the contract is initialized at version 1 (no reininitialization) and the\n        //                 current contract is just being deployed\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint64 version) {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n\n    /**\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n     */\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n\n    /**\n     * @dev Returns a pointer to the storage namespace.\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/proxy/beacon/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {UpgradeableBeacon} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/Proxy.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback\n     * function and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/proxy/ERC1967/ERC1967Utils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/ERC1967/ERC1967Utils.sol)\n\npragma solidity ^0.8.20;\n\nimport {IBeacon} from \"../beacon/IBeacon.sol\";\nimport {Address} from \"../../utils/Address.sol\";\nimport {StorageSlot} from \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n */\nlibrary ERC1967Utils {\n    // We re-declare ERC-1967 events here because they can't be used directly from IERC1967.\n    // This will be fixed in Solidity 0.8.21. At that point we should remove these events.\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Emitted when the beacon is changed.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev The `implementation` of the proxy is invalid.\n     */\n    error ERC1967InvalidImplementation(address implementation);\n\n    /**\n     * @dev The `admin` of the proxy is invalid.\n     */\n    error ERC1967InvalidAdmin(address admin);\n\n    /**\n     * @dev The `beacon` of the proxy is invalid.\n     */\n    error ERC1967InvalidBeacon(address beacon);\n\n    /**\n     * @dev An upgrade function sees `msg.value > 0` that may be lost.\n     */\n    error ERC1967NonPayable();\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        if (newImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(newImplementation);\n        }\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Performs implementation upgrade with additional setup call if data is nonempty.\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\n     * to avoid stuck value in the contract.\n     *\n     * Emits an {IERC1967-Upgraded} event.\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(newImplementation, data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using\n     * the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        if (newAdmin == address(0)) {\n            revert ERC1967InvalidAdmin(address(0));\n        }\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {IERC1967-AdminChanged} event.\n     */\n    function changeAdmin(address newAdmin) internal {\n        emit AdminChanged(getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is the keccak-256 hash of \"eip1967.proxy.beacon\" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        if (newBeacon.code.length == 0) {\n            revert ERC1967InvalidBeacon(newBeacon);\n        }\n\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\n\n        address beaconImplementation = IBeacon(newBeacon).implementation();\n        if (beaconImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(beaconImplementation);\n        }\n    }\n\n    /**\n     * @dev Change the beacon and trigger a setup call if data is nonempty.\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\n     * to avoid stuck value in the contract.\n     *\n     * Emits an {IERC1967-BeaconUpgraded} event.\n     *\n     * CAUTION: Invoking this function has no effect on an instance of {BeaconProxy} since v5, since\n     * it uses an immutable beacon without looking at the value of the ERC-1967 beacon slot for\n     * efficiency.\n     */\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n\n    /**\n     * @dev Reverts if `msg.value` is not zero. It can be used to avoid `msg.value` stuck in the contract\n     * if an upgrade doesn't perform an initialization call.\n     */\n    function _checkNonPayable() private {\n        if (msg.value > 0) {\n            revert ERC1967NonPayable();\n        }\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../token/ERC20/IERC20.sol\";\n"
    },
    "lib/openzeppelin-contracts/contracts/interfaces/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC20Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20Metadata} from \"../token/ERC20/extensions/IERC20Metadata.sol\";\n"
    },
    "lib/openzeppelin-contracts/contracts/interfaces/IERC3156FlashLender.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC3156FlashLender.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC3156FlashBorrower} from \"./IERC3156FlashBorrower.sol\";\n\n/**\n * @dev Interface of the ERC3156 FlashLender, as defined in\n * https://eips.ethereum.org/EIPS/eip-3156[ERC-3156].\n */\ninterface IERC3156FlashLender {\n    /**\n     * @dev The amount of currency available to be lended.\n     * @param token The loan currency.\n     * @return The amount of `token` that can be borrowed.\n     */\n    function maxFlashLoan(address token) external view returns (uint256);\n\n    /**\n     * @dev The fee to be charged for a given loan.\n     * @param token The loan currency.\n     * @param amount The amount of tokens lent.\n     * @return The amount of `token` to be charged for the loan, on top of the returned principal.\n     */\n    function flashFee(address token, uint256 amount) external view returns (uint256);\n\n    /**\n     * @dev Initiate a flash loan.\n     * @param receiver The receiver of the tokens in the loan, and the receiver of the callback.\n     * @param token The loan currency.\n     * @param amount The amount of tokens lent.\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\n     */\n    function flashLoan(\n        IERC3156FlashBorrower receiver,\n        address token,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (bool);\n}\n"
    },
    "src/interfaces/ICurvePool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface for Curve CryptoSwap pool\n */\ninterface ICurvePool {\n    function coins(uint256 index) external view returns (address);\n\n    function balances(uint256 index) external view returns (uint256);\n\n    function A() external view returns (uint256);\n\n    function gamma() external view returns (uint256);\n\n    function D() external view returns (uint256);\n\n    function token() external view returns (address);\n\n    function price_scale() external view returns (uint256);\n\n    function future_A_gamma_time() external view returns (uint256);\n\n    function future_A_gamma() external view returns (uint256);\n\n    function initial_A_gamma_time() external view returns (uint256);\n\n    function initial_A_gamma() external view returns (uint256);\n\n    function fee_gamma() external view returns (uint256);\n\n    function mid_fee() external view returns (uint256);\n\n    function out_fee() external view returns (uint256);\n\n    function allowed_extra_profit() external view returns (uint256);\n\n    function adjustment_step() external view returns (uint256);\n\n    function admin_fee() external view returns (uint256);\n\n    function ma_half_time() external view returns (uint256);\n\n    function get_virtual_price() external view returns (uint256);\n\n    function fee() external view returns (uint256);\n\n    function get_dy(uint256 i, uint256 j, uint256 dx) external view returns (uint256);\n\n    function last_prices() external view returns (uint256);\n\n    function calc_token_amount(uint256[2] calldata amounts) external view returns (uint256);\n\n    function calc_withdraw_one_coin(\n        uint256 _token_amount,\n        uint256 i\n    ) external view returns (uint256);\n\n    function exchange(\n        uint256 i,\n        uint256 j,\n        uint256 dx,\n        uint256 min_dy,\n        bool use_eth,\n        address receiver\n    ) external returns (uint256);\n\n    function add_liquidity(\n        uint256[2] calldata amounts,\n        uint256 min_mint_amount\n    ) external returns (uint256);\n\n    function add_liquidity(\n        uint256[2] calldata amounts,\n        uint256 min_mint_amount,\n        bool use_eth,\n        address receiver\n    ) external returns (uint256);\n\n    function remove_liquidity(uint256 amount, uint256[2] calldata min_amounts) external;\n\n    function remove_liquidity(\n        uint256 amount,\n        uint256[2] calldata min_amounts,\n        bool use_eth,\n        address receiver\n    ) external;\n\n    function remove_liquidity_one_coin(\n        uint256 token_amount,\n        uint256 i,\n        uint256 min_amount\n    ) external;\n\n    function remove_liquidity_one_coin(\n        uint256 token_amount,\n        uint256 i,\n        uint256 min_amount,\n        bool use_eth,\n        address receiver\n    ) external;\n}\n"
    },
    "src/interfaces/ICurveNGPool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.20;\n\nimport {IERC20Metadata} from \"openzeppelin-contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\n/**\n * @dev Interface for Curve TwoCrypto-NG pool\n */\ninterface ICurveNGPool is IERC20Metadata {\n    function coins(uint256 index) external view returns (address);\n\n    function balances(uint256 index) external view returns (uint256);\n\n    function A() external view returns (uint256);\n\n    function gamma() external view returns (uint256);\n\n    function D() external view returns (uint256);\n\n    function token() external view returns (address);\n\n    function price_scale() external view returns (uint256);\n\n    function price_oracle() external view returns (uint256);\n\n    function future_A_gamma_time() external view returns (uint256);\n\n    function future_A_gamma() external view returns (uint256);\n\n    function initial_A_gamma_time() external view returns (uint256);\n\n    function initial_A_gamma() external view returns (uint256);\n\n    function fee_gamma() external view returns (uint256);\n\n    function mid_fee() external view returns (uint256);\n\n    function out_fee() external view returns (uint256);\n\n    function allowed_extra_profit() external view returns (uint256);\n\n    function adjustment_step() external view returns (uint256);\n\n    function admin_fee() external view returns (uint256);\n\n    function ma_time() external view returns (uint256);\n\n    function get_virtual_price() external view returns (uint256);\n\n    function fee() external view returns (uint256);\n\n    function get_dy(uint256 i, uint256 j, uint256 dx) external view returns (uint256);\n\n    function get_dx(uint256 i, uint256 j, uint256 dy) external view returns (uint256);\n\n    function last_prices() external view returns (uint256);\n\n    function calc_token_amount(\n        uint256[2] calldata amounts,\n        bool deposit\n    ) external view returns (uint256);\n\n    function calc_withdraw_one_coin(\n        uint256 _token_amount,\n        uint256 i\n    ) external view returns (uint256);\n\n    function exchange(uint256 i, uint256 j, uint256 dx, uint256 min_dy) external returns (uint256);\n\n    function exchange(\n        uint256 i,\n        uint256 j,\n        uint256 dx,\n        uint256 min_dy,\n        address receiver\n    ) external returns (uint256);\n\n    function add_liquidity(\n        uint256[2] calldata amounts,\n        uint256 min_mint_amount\n    ) external returns (uint256);\n\n    function add_liquidity(\n        uint256[2] calldata amounts,\n        uint256 min_mint_amount,\n        address receiver\n    ) external returns (uint256);\n\n    function remove_liquidity(uint256 amount, uint256[2] calldata min_amounts) external;\n\n    function remove_liquidity(\n        uint256 amount,\n        uint256[2] calldata min_amounts,\n        address receiver\n    ) external;\n\n    function remove_liquidity_one_coin(\n        uint256 token_amount,\n        uint256 i,\n        uint256 min_amount\n    ) external;\n\n    function remove_liquidity_one_coin(\n        uint256 token_amount,\n        uint256 i,\n        uint256 min_amount,\n        address receiver\n    ) external;\n}\n"
    },
    "src/libraries/RayMath.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.20;\n\n/**\n * @title RayMath library\n * @author Spectra Finance\n * @notice Provides conversions for/to any decimal tokens to/from ray.\n * @dev Conversions from Ray are rounded down.\n */\nlibrary RayMath {\n    /// @dev 27 decimal unit\n    uint256 public constant RAY_UNIT = 1e27;\n    uint256 public constant RAY_DECIMALS = 27;\n\n    /**\n     * @dev Converts a value from Ray (27-decimal precision) to a representation with a specified number of decimals.\n     * @param _a The amount in Ray to be converted. Ray is a fixed-point representation with 27 decimals.\n     * @param _decimals The target decimal precision for the converted amount.\n     * @return b The amount converted from Ray to the specified decimal precision.\n     */\n    function fromRay(uint256 _a, uint256 _decimals) internal pure returns (uint256 b) {\n        uint256 decimals_ratio = 10 ** (RAY_DECIMALS - _decimals);\n        assembly {\n            b := div(_a, decimals_ratio)\n        }\n    }\n\n    /**\n     * @dev Converts a value from Ray (27-decimal precision) to a representation with a specified number of decimals.\n     * @param _a The amount in Ray to be converted. Ray is a fixed-point representation with 27 decimals.\n     * @param _decimals The target decimal precision for the converted amount.\n     * @param _roundUp If true, the function rounds up the result to the nearest integer value.\n     *                If false, it truncates (rounds down) to the nearest integer.\n     * @return b The amount converted from Ray to the specified decimal precision, rounded as specified.\n     */\n    function fromRay(\n        uint256 _a,\n        uint256 _decimals,\n        bool _roundUp\n    ) internal pure returns (uint256 b) {\n        uint256 decimals_ratio = 10 ** (RAY_DECIMALS - _decimals);\n        assembly {\n            b := div(_a, decimals_ratio)\n\n            if and(eq(_roundUp, 1), gt(mod(_a, decimals_ratio), 0)) {\n                b := add(b, 1)\n            }\n        }\n    }\n\n    /**\n     * @dev Converts a value with a specified number of decimals to Ray (27-decimal precision).\n     * @param _a The amount to be converted, specified in a decimal format.\n     * @param _decimals The number of decimals in the representation of 'a'.\n     * @return b The amount in Ray, converted from the specified decimal precision.\n     *           Ensures that the conversion maintains the value's integrity (no overflow).\n     */\n    function toRay(uint256 _a, uint256 _decimals) internal pure returns (uint256 b) {\n        uint256 decimals_ratio = 10 ** (RAY_DECIMALS - _decimals);\n        // to avoid overflow, b/decimals_ratio == _a\n        assembly {\n            b := mul(_a, decimals_ratio)\n\n            if iszero(eq(div(b, decimals_ratio), _a)) {\n                revert(0, 0)\n            }\n        }\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value > type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value > type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value > type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value > type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value > type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value > type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value > type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value > type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value > type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value > type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value > type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value > type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value > type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value > type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value > type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value > type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value > type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value > type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value > type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value > type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value > type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value > type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value > type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value > type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value > type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value > type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value > type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value > type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value > type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value > type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value > type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value < 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value > uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(newImplementation.code.length > 0);\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/interfaces/IERC3156FlashBorrower.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC3156FlashBorrower.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC3156 FlashBorrower, as defined in\n * https://eips.ethereum.org/EIPS/eip-3156[ERC-3156].\n */\ninterface IERC3156FlashBorrower {\n    /**\n     * @dev Receive a flash loan.\n     * @param initiator The initiator of the loan.\n     * @param token The loan currency.\n     * @param amount The amount of tokens lent.\n     * @param fee The additional amount of tokens to repay.\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\n     * @return The keccak256 hash of \"ERC3156FlashBorrower.onFlashLoan\"\n     */\n    function onFlashLoan(\n        address initiator,\n        address token,\n        uint256 amount,\n        uint256 fee,\n        bytes calldata data\n    ) external returns (bytes32);\n}\n"
    }
  },
  "settings": {
    "remappings": [
      "ds-test/=lib/forge-std/lib/ds-test/src/",
      "erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/",
      "forge-std/=lib/forge-std/src/",
      "openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/",
      "openzeppelin-contracts/=lib/openzeppelin-contracts/contracts/",
      "openzeppelin-erc20-basic/=lib/openzeppelin-contracts/contracts/token/ERC20/",
      "openzeppelin-erc20-extensions/=lib/openzeppelin-contracts-upgradeable/contracts/token/ERC20/extensions/",
      "openzeppelin-erc20/=lib/openzeppelin-contracts-upgradeable/contracts/token/ERC20/",
      "openzeppelin-math/=lib/openzeppelin-contracts/contracts/utils/math/",
      "openzeppelin-proxy/=lib/openzeppelin-contracts-upgradeable/contracts/proxy/utils/",
      "openzeppelin-utils/=lib/openzeppelin-contracts/contracts/utils/",
      "@openzeppelin/contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/",
      "@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "metadata": {
      "useLiteralContent": false,
      "bytecodeHash": "ipfs",
      "appendCBOR": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "evmVersion": "shanghai",
    "viaIR": false,
    "libraries": {}
  }
}}