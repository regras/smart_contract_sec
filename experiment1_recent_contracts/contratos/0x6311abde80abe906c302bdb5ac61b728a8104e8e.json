{{
  "language": "Solidity",
  "sources": {
    "src/PolicyViewer.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.28;\n\nimport {IPolicyViewer} from \"src/interfaces/IPolicyViewer.sol\";\nimport {IInstrumentRegistry} from \"src/interfaces/IInstrumentRegistry.sol\";\nimport {IInvestorRegistry} from \"src/interfaces/IInvestorRegistry.sol\";\nimport {IFundRegistry} from \"src/interfaces/IFundRegistry.sol\";\nimport {IEternalRegistryStorage} from \"src/interfaces/IEternalRegistryStorage.sol\";\nimport \"src/utils/Constant.sol\";\n\n/**\n * @title PolicyViewer\n * @author Libre\n * @notice This contract provides functions to retrieve policy and compliance rules for investors, instruments, and funds.\n * @dev Integrates with various registries to query data required for compliance and validation.\n */\ncontract PolicyViewer is IPolicyViewer {\n    IInstrumentRegistry public immutable instrumentRegistry;\n    IInvestorRegistry public immutable investorRegistry;\n    IFundRegistry public immutable fundRegistry;\n    IEternalRegistryStorage public immutable jurisdictionRegistry;\n\n    constructor(\n        IInstrumentRegistry _instrumentRegistry,\n        IInvestorRegistry _investorRegistry,\n        IEternalRegistryStorage _jurisdictionRegistry,\n        IFundRegistry _fundRegistry\n    ) {\n        instrumentRegistry = _instrumentRegistry;\n        investorRegistry = _investorRegistry;\n        jurisdictionRegistry = _jurisdictionRegistry;\n        fundRegistry = _fundRegistry;\n    }\n\n    function getInvestorRules(uint256 _investorJurisdiction)\n        external\n        view\n        returns (InvestorRules memory investorRules)\n    {\n        bytes32 jurisdictionId = keccak256(abi.encode(_investorJurisdiction));\n\n        bytes32[] memory ids = new bytes32[](3);\n        bytes32[] memory keys = new bytes32[](3);\n\n        // Set up batch query parameters\n        ids[0] = jurisdictionId;\n        ids[1] = jurisdictionId;\n        ids[2] = jurisdictionId;\n\n        keys[0] = JURISDICTION_ALLOWED;\n        keys[1] = SELF_CERTIFICATION_REQUIRED;\n        keys[2] = FITNESS_TEST_REQUIRED;\n\n        // Get all values in one call\n        (bool[] memory boolValues,,,,) = jurisdictionRegistry.getBatch(\n            ids,\n            keys,\n            3, // bool count\n            0, // uint count\n            0, // address count\n            0, // string count\n            0 // bytes count\n        );\n\n        // Map results to struct\n        investorRules.jurisdictionAllowed = boolValues[0];\n        investorRules.selfCertificationRequired = boolValues[1];\n        investorRules.fitnessTestRequired = boolValues[2];\n\n        investorRules.maxInvestorType = investorRegistry.getUint(GENERAL_DATA_ID, MAX_INVESTOR_TYPE);\n\n        return investorRules;\n    }\n\n    function getInstrumentRules(bytes32 _instrumentId, bytes32 _investorId, uint256 _investorJurisdiction)\n        external\n        view\n        returns (InstrumentRules memory instrumentRules)\n    {\n        bytes32 jurisdictionId = keccak256(abi.encode(_investorJurisdiction));\n\n        // Set up batch queries - one for jurisdiction registry and one for instrument registry\n        bytes32[] memory jurisdictionIds = new bytes32[](5);\n        bytes32[] memory jurisdictionKeys = new bytes32[](5);\n\n        jurisdictionIds[0] = jurisdictionId;\n        jurisdictionIds[1] = jurisdictionId;\n        jurisdictionIds[2] = jurisdictionId;\n        jurisdictionIds[3] = jurisdictionId;\n        jurisdictionIds[4] = jurisdictionId;\n\n        jurisdictionKeys[0] = INVESTOR_ALLOWLISTED_REQUIRED;\n        jurisdictionKeys[1] = LISTED_ON_REGULATED_VENUE_REQUIRED;\n        jurisdictionKeys[2] = LOCAL_AIFM_REQUIRED;\n        jurisdictionKeys[3] = NON_EU_AIFM_REQUIRED;\n        jurisdictionKeys[4] = DISCLOSURE_DOCUMENTS_REQUIRED;\n\n        // Get jurisdiction values\n        (bool[] memory jurisdictionBools, uint256[] memory jurisdictionUints,,,) = jurisdictionRegistry.getBatch(\n            jurisdictionIds,\n            jurisdictionKeys,\n            4, // bool count\n            1, // uint count\n            0, // address count\n            0, // string count\n            0 // bytes count\n        );\n\n        // Jurisdiction data\n        instrumentRules.investorAllowlistedRequired = jurisdictionBools[0];\n        instrumentRules.listedOnRegulatedVenueRequired = jurisdictionBools[1];\n        instrumentRules.localAifmRequired = jurisdictionBools[2];\n        instrumentRules.nonEuAifmRequired = jurisdictionBools[3];\n        instrumentRules.disclosureDocumentsRequired = jurisdictionUints[0];\n\n        bytes32[] memory instrumentIds = new bytes32[](4);\n        bytes32[] memory instrumentKeys = new bytes32[](4);\n\n        instrumentIds[0] = _instrumentId;\n        instrumentIds[1] = _instrumentId;\n        instrumentIds[2] = _instrumentId;\n        instrumentIds[3] = _instrumentId;\n\n        instrumentKeys[0] = keccak256(abi.encodePacked(IS_INVESTOR_ALLOWED, _investorId));\n        instrumentKeys[1] = NATIONALITIES_ALLOWED;\n        instrumentKeys[2] = INVESTOR_TYPES_ALLOWED;\n        instrumentKeys[3] = RESIDENCES_ALLOWED;\n\n        // Get instrument values\n        (bool[] memory instrumentBools, uint256[] memory instrumentUints,,,) = instrumentRegistry.getBatch(\n            instrumentIds,\n            instrumentKeys,\n            1, // bool count\n            3, // uint count\n            0, // address count\n            0, // string count\n            0 // bytes count\n        );\n\n        // Instrument data\n        instrumentRules.investorAllowlisted = instrumentBools[0];\n        instrumentRules.nationalitiesAllowed = instrumentUints[0];\n        instrumentRules.investorTypesAllowed = instrumentUints[1];\n        instrumentRules.residencesAllowed = instrumentUints[2];\n\n        // Get fund values\n        bytes32 fundId = instrumentRegistry.getBytes(_instrumentId, FUND_ID);\n\n        bytes32[] memory fundIds = new bytes32[](4);\n        bytes32[] memory fundKeys = new bytes32[](4);\n\n        fundIds[0] = fundId;\n        fundIds[1] = fundId;\n        fundIds[2] = fundId;\n        fundIds[3] = fundId;\n\n        fundKeys[0] = keccak256(abi.encodePacked(LISTED_ON_REGULATED_VENUE, jurisdictionId));\n        fundKeys[1] = keccak256(abi.encodePacked(LOCAL_AIFM, jurisdictionId));\n        fundKeys[2] = keccak256(abi.encodePacked(NON_EU_AIFM, jurisdictionId));\n        fundKeys[3] = DISCLOSURE_DOCUMENTS;\n\n        (bool[] memory fundBools, uint256[] memory fundUints,,,) = fundRegistry.getBatch(\n            fundIds,\n            fundKeys,\n            3, // bool count\n            1, // uint count\n            0, // address count\n            0, // string count\n            0 // bytes count\n        );\n\n        instrumentRules.listedOnRegulatedVenue = fundBools[0];\n        instrumentRules.localAifm = fundBools[1];\n        instrumentRules.nonEuAifm = fundBools[2];\n        instrumentRules.disclosureDocuments = fundUints[0];\n\n        return instrumentRules;\n    }\n\n    function getSubscriptionMinInvestment(uint256 _investorJurisdiction, uint256 _investorType)\n        external\n        view\n        returns (uint256 minInvestment)\n    {\n        bytes32 jurisdictionId = keccak256(abi.encode(_investorJurisdiction));\n\n        bytes32[] memory ids = new bytes32[](2);\n        bytes32[] memory keys = new bytes32[](2);\n\n        ids[0] = jurisdictionId;\n        ids[1] = jurisdictionId;\n\n        keys[0] = MINIMUM_INVESTMENT_REQUIRED;\n        bytes32 minimumInvestmentKey = keccak256(abi.encodePacked(MINIMUM_INVESTMENT, _investorType));\n        keys[1] = minimumInvestmentKey;\n\n        // Get all values in one call\n        (bool[] memory boolValues, uint256[] memory uintValues,,,) = jurisdictionRegistry.getBatch(\n            ids,\n            keys,\n            1, // bool count\n            1, // uint count\n            0, // address count\n            0, // string count\n            0 // bytes count\n        );\n\n        if (boolValues[0]) {\n            minInvestment = uintValues[0];\n        }\n\n        return minInvestment;\n    }\n}\n"
    },
    "src/interfaces/IPolicyViewer.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title IPolicyViewer\n * @author Libre\n * @notice Interface for viewing investor and instrument rules as well as subscription minimum investment requirements.\n */\ninterface IPolicyViewer {\n    /**\n     * @notice Structure defining the rules for investors.\n     * @param maxInvestorType The maximum allowed investor type.\n     * @param jurisdictionAllowed Whether the jurisdiction is allowed for the investor.\n     * @param selfCertificationRequired Whether self-certification is required for the investor.\n     * @param fitnessTestRequired Whether a fitness test is required for the investor.\n     */\n    struct InvestorRules {\n        uint256 maxInvestorType;\n        bool jurisdictionAllowed;\n        bool selfCertificationRequired;\n        bool fitnessTestRequired;\n    }\n\n    /**\n     * @notice Structure defining the rules for instruments.\n     * @param nationalitiesAllowed Bitmask representing the allowed nationalities for the instrument.\n     * @param investorTypesAllowed Bitmask representing the allowed investor types for the instrument.\n     * @param residencesAllowed Bitmask representing the allowed residences for the instrument.\n     * @param disclosureDocumentsRequired Bitmask representing required disclosure documents for the instrument.\n     * @param disclosureDocuments Bitmask representing the available disclosure documents for the instrument.\n     * @param listedOnRegulatedVenueRequired Whether listing on a regulated venue is required for the instrument.\n     * @param listedOnRegulatedVenue Whether the instrument is listed on a regulated venue.\n     * @param localAifmRequired Whether a local Alternative Investment Fund Manager (AIFM) is required for the instrument.\n     * @param localAifm Whether a local Alternative Investment Fund Manager (AIFM) is present for the instrument.\n     * @param nonEuAifmRequired Whether a non-EU AIFM is required for the instrument.\n     * @param nonEuAifm Whether a non-EU AIFM is present for the instrument.\n     * @param investorAllowlistedRequired Whether the investor must be on an allowlist.\n     * @param investorAllowlisted Whether the investor is on the allowlist.\n     */\n    struct InstrumentRules {\n        uint256 nationalitiesAllowed;\n        uint256 investorTypesAllowed;\n        uint256 residencesAllowed;\n        uint256 disclosureDocumentsRequired;\n        uint256 disclosureDocuments;\n        bool listedOnRegulatedVenueRequired;\n        bool listedOnRegulatedVenue;\n        bool localAifmRequired;\n        bool localAifm;\n        bool nonEuAifmRequired;\n        bool nonEuAifm;\n        bool investorAllowlistedRequired;\n        bool investorAllowlisted;\n    }\n\n    /**\n     * @notice Retrieves the rules applicable to an investor based on their jurisdiction.\n     * @param _investorJurisdiction The jurisdiction of the investor.\n     * @return A struct containing the rules for the investor.\n     */\n    function getInvestorRules(uint256 _investorJurisdiction) external view returns (InvestorRules memory);\n\n    /**\n     * @notice Retrieves the rules applicable to an instrument for a specific investor.\n     * @param _instrumentId The ID of the instrument.\n     * @param _investorId The ID of the investor.\n     * @param _investorJurisdiction The jurisdiction of the investor.\n     * @return A struct containing the rules for the instrument.\n     */\n    function getInstrumentRules(bytes32 _instrumentId, bytes32 _investorId, uint256 _investorJurisdiction)\n        external\n        view\n        returns (InstrumentRules memory);\n\n    /**\n     * @notice Retrieves the minimum investment amount required for subscription based on the investor's jurisdiction and type.\n     * @param _investorJurisdiction The jurisdiction of the investor.\n     * @param _investorType The type of the investor.\n     * @return minInvestment The minimum investment amount required.\n     */\n    function getSubscriptionMinInvestment(uint256 _investorJurisdiction, uint256 _investorType)\n        external\n        view\n        returns (uint256 minInvestment);\n}\n"
    },
    "src/interfaces/IInstrumentRegistry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {IERC20Metadata} from \"openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport {IBaseRegistry} from \"src/interfaces/IBaseRegistry.sol\";\nimport {IDealerRegistry} from \"src/interfaces/IDealerRegistry.sol\";\nimport {IFundRegistry} from \"src/interfaces/IFundRegistry.sol\";\nimport {IRoleRegistry} from \"src/interfaces/IRoleRegistry.sol\";\nimport {IInvestorRegistry} from \"src/interfaces/IInvestorRegistry.sol\";\nimport {IOperationsEngine} from \"src/interfaces/IOperationsEngine.sol\";\nimport {IEternalRegistryStorage} from \"src/interfaces/IEternalRegistryStorage.sol\";\n\n/**\n * @title IInstrumentRegistry\n * @author Libre\n * @notice Interface for managing instruments within a fund registry system.\n * Provides functionalities to initialize, add, and manage instruments, track their subscription and redemption periods,\n * update Net Asset Value (NAV) per share, and manage investor access.\n */\ninterface IInstrumentRegistry is IBaseRegistry {\n    /**\n     * @notice Thrown when attempting to add an instrument that already exists in the registry.\n     */\n    error IInstrumentRegistry_InstrumentAlreadyExists();\n\n    /**\n     * @notice Thrown when the specified instrument does not exist in the registry.\n     */\n    error IInstrumentRegistry_InstrumentDoesNotExist();\n\n    /**\n     * @notice Thrown when attempting to initialize an instrument that has already been initialized.\n     */\n    error IInstrumentRegistry_InstrumentAlreadyInitialized();\n\n    /**\n     * @notice Emited when a new instrument is added\n     * @param fundId Id of the fund where the instrument is added\n     * @param instrumentId Id of the new instrument\n     */\n    event NewFundInstrumentAdded(bytes32 indexed fundId, bytes32 indexed instrumentId);\n\n    /**\n     * @notice Emited when an instrument is initialized\n     * @param instrumentId Id of the new instrument\n     * @param settlementToken Address of the settlement token of the instrument\n     * @param securityToken Address of the deployed security token\n     * @param subscriptionBook Address of the deployed subscription book\n     * @param redemptionBook Address of the deployed redemption book\n     */\n    event FundInstrumentInitialized(\n        bytes32 indexed instrumentId,\n        address settlementToken,\n        address securityToken,\n        address subscriptionBook,\n        address redemptionBook\n    );\n\n    /**\n     * @notice Emited when an instrument is closed\n     * @param instrumentId Id of the instrument\n     */\n    event InstrumentClosed(bytes32 indexed instrumentId);\n\n    /**\n     * @notice Emited when an instrument is paused\n     * @param instrumentId Id of the instrument\n     * @param paused Y/N value indicating if the instrument is paused or not\n     */\n    event InstrumentPaused(bytes32 indexed instrumentId, bool paused);\n\n    /**\n     * @notice Emited when an investor's allowlist status is updated for an instrument\n     * @param instrumentId Id of the instrument\n     * @param investorId Id of the investor\n     * @param allowed Y/N value indicating if the investor is allowed or not\n     */\n    event InvestorAllowedUpdated(bytes32 indexed instrumentId, bytes32 indexed investorId, bool allowed);\n\n    /**\n     * @notice Initialize the registry\n     * @param _roleRegistry Address of the Role Registry\n     * @param _investorRegistry Address of the Investor Registry\n     * @param _dealerRegistry Address of the Dealer Registry\n     * @param _fundRegistry Address of the Fund Registry\n     * @param _jurisdictionRegistry Address of the Jurisdiction Registry\n     * @param _operationsEngine Address of the Rules Engine\n     */\n    function initialize(\n        IRoleRegistry _roleRegistry,\n        IInvestorRegistry _investorRegistry,\n        IDealerRegistry _dealerRegistry,\n        IFundRegistry _fundRegistry,\n        IEternalRegistryStorage _jurisdictionRegistry,\n        IOperationsEngine _operationsEngine\n    ) external;\n\n    /**\n     * @notice Adds a new fund instrument to the registry\n     * @dev _senderRole is ignored if the caller if the Fund Admin of the instrument\n     * @param _senderRole Role of the sender which allow the operation execution\n     * @param _instrumentId the instrument ID\n     * @param _fundId the fund ID\n     */\n    function addFundInstrument(bytes32 _senderRole, bytes32 _instrumentId, bytes32 _fundId) external;\n\n    /**\n     * @notice Adds a new instrument to the registry\n     * @dev _senderRole is ignored if the caller if the Fund Admin of the instrument\n     * @param _senderRole Role of the sender which allow the operation execution\n     * @param _instrumentId the instrument ID\n     * @param _settlementToken settlement token address\n     * @param _name the instrument token name\n     * @param _symbol the instrument token symbol\n     * @param _subscriptionBookImp The implementation of subscription book to be cloned\n     * @param _redemptionBookImp The implementation of redemption book to be cloned\n     * @param _stTokenImpl The implementation of security token implementation to be cloned\n     * @param _treasury The address of instrument treasury\n     * @param _policyViewerAddress The address of instrument policy viewer\n     */\n    function initializeFundInstrument(\n        bytes32 _senderRole,\n        bytes32 _fundId,\n        bytes32 _instrumentId,\n        address _settlementToken,\n        string memory _name,\n        string memory _symbol,\n        address _subscriptionBookImp,\n        address _redemptionBookImp,\n        address _stTokenImpl,\n        address _treasury,\n        address _policyViewerAddress\n    ) external;\n\n    /**\n     * @notice Close a fund instrument\n     * @param _senderRole Role of the sender which allow the operation execution\n     * @param _instrumentId The ID of the instrument\n     */\n    function closeFundInstrument(bytes32 _senderRole, bytes32 _instrumentId) external;\n\n    /**\n     * @notice Return the number of the current subscription period or\n     * 0 in case subscription is not started or infinite if subscriptions are done\n     * @dev Infinite is represented by type(uint256).max;\n     * @param _instrumentId Id of the instrument\n     * @return The current period of the subscription, the start & the end of it\n     */\n    function currentSubscriptionPeriod(bytes32 _instrumentId) external view returns (uint256, uint256, uint256);\n\n    /**\n     * @notice Return the number of the current redemption period or\n     * 0 in case redemption is not started or infinite if redemptions are done\n     * @param _instrumentId Id of the instrument\n     * @return The current period of the redemption, the start & the end of it\n     */\n    function currentRedemptionPeriod(bytes32 _instrumentId) external view returns (uint256, uint256, uint256);\n\n    /**\n     * @notice Sets a new value for the audited NAV per share of a fund\n     * @param _senderRole Role of the sender which allow the operation execution\n     * @param _instrumentId ID of the fund\n     * @param _newNavPerShare new value of the nav\n     * @dev Expressed with 6 decimals as it is in settlement tokens units\n     */\n    function updateAuditedNavPerShare(bytes32 _senderRole, bytes32 _instrumentId, uint256 _newNavPerShare) external;\n\n    /**\n     * @notice Allow investor for a specific instrument\n     * @param _instrumentId The ID of the instrument\n     * @param _investorId Id of the investor\n     * @param _allowed Y/N value indicating if the investor is allowed or not\n     * @param _senderRole Role of the sender\n     */\n    function allowInvestor(bytes32 _instrumentId, bytes32 _investorId, bool _allowed, bytes32 _senderRole) external;\n}\n"
    },
    "src/interfaces/IInvestorRegistry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {IERC20MetadataUpgradeable} from\n    \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\n\nimport {IEAS, AttestationRequestData} from \"eas-contracts/IEAS.sol\";\nimport {IRiscZeroVerifier} from \"risc0/IRiscZeroVerifier.sol\";\n\nimport {IBaseRegistry} from \"src/interfaces/IBaseRegistry.sol\";\nimport {IRoleRegistry} from \"src/interfaces/IRoleRegistry.sol\";\nimport {IInstrumentRegistry} from \"src/interfaces/IInstrumentRegistry.sol\";\nimport {IDealerRegistry} from \"src/interfaces/IDealerRegistry.sol\";\nimport {IOperationsEngine} from \"src/interfaces/IOperationsEngine.sol\";\nimport {IUserRegistry} from \"src/interfaces/IUserRegistry.sol\";\nimport {IGatewayManager} from \"src/interfaces/IGatewayManager.sol\";\nimport {IEternalRegistryStorage} from \"src/interfaces/IEternalRegistryStorage.sol\";\nimport {OrderProofData, SteelProofData, CredentialProofData} from \"src/utils/Types.sol\";\nimport {IRiscZeroVerifier} from \"risc0/IRiscZeroVerifier.sol\";\n\n/**\n * @title IInvestorRegistry\n * @author Libre\n * @notice Interface for managing investors, including adding new investors, managing credentials, and verifying subscriptions.\n * It integrates with Ethereum Attestation Service (EAS) and zk-verifiers to ensure security and compliance.\n */\ninterface IInvestorRegistry is IBaseRegistry, IUserRegistry {\n    /// @notice Thrown when an operation is not permitted due to insufficient privileges.\n    error IInvestorRegistry_OperationNotPermitted();\n\n    /// @notice Thrown when the sender is not the dealer associated with the specified investor.\n    error IInvestorRegistry_NotInvestorsDealer();\n\n    /// @notice Thrown when the caller is not the Operations Engine.\n    error IInvestorRegistry_NotOperationsEngine();\n\n    /// @notice Thrown when the caller is not the Jurisdiction Registry.\n    error IInvestorRegistry_NotJurisdictionRegistry();\n\n    /// @notice Thrown when attempting to add an investor who is already registered.\n    error IInvestorRegistry_AlreadyAnInvestor();\n\n    /// @notice Thrown when the sender does not have the Contract Manager role.\n    error IInvestorRegistry_NoContractManagerRole();\n\n    /// @notice Thrown when the Resolver Verifier address is empty or invalid.\n    error IInvestorRegistry_EmptyResolverVerifier();\n\n    /// @notice Thrown when the provided zk program image IDs are empty.\n    error IInvestorRegistry_EmptyImageIDs();\n\n    /// @notice Thrown when the sender does not have the Attester role.\n    error IInvestorRegistry_NoAttesterRole();\n\n    /// @notice Thrown when attempting to access a schema that has not been set.\n    error IInvestorRegistry_SchemaNotSet();\n\n    /// @notice Thrown when attempting to access a credential that does not exist.\n    error IInvestorRegistry_NonExistingCredential();\n\n    /// @notice Thrown when the credential is found to be invalid or revoked.\n    error IInvestorRegistry_CredentialInvalid();\n\n    /// @notice Thrown when the Investor Id doesn't match with the attestation's investor Id.\n    error IInvestorRegistry_MismatchInvestorId();\n\n    /// @notice Thrown when a credential does not grant access to the specified instrument.\n    error IInvestorRegistry_InstrumentCredentialInvalid();\n\n    /// @notice Thrown when attempting to revoke access to instruments that are not part of the credential.\n    error IInvestorRegistry_InstrumentsToRevokeNotInCredential();\n\n    /// @notice Thrown when there is a mismatch in the policy viewer proof.\n    error IInvestorRegistry_PolicyViewerProofMismatch();\n\n    /// @notice Thrown when an invalid dealer ID is provided.\n    error IInvestorRegistry_InvalidDealerId();\n\n    // Events\n    /**\n     * @notice Emitted when a new investor is added to the registry.\n     * @param investorId The unique identifier of the new investor.\n     * @param wallet The initial wallet address associated with the investor.\n     */\n    event NewInvestorAdded(bytes32 investorId, address wallet);\n\n    /**\n     * @notice Emitted when a credential is set for an investor.\n     * @param investorId The unique identifier of the investor.\n     * @param instrumentIds The list of instrument IDs included in the credential.\n     */\n    event InvestorRegistryCredentialSet(bytes32 investorId, bytes32[] instrumentIds);\n\n    /**\n     * @notice Emitted when a credential is revoked for an investor.\n     * @param investorId The unique identifier of the investor.\n     * @param instrumentIds The list of instrument IDs that have been revoked.\n     */\n    event InvestorRegistryCredentialRevoked(bytes32 investorId, bytes32[] instrumentIds);\n\n    /**\n     * @notice Emitted when the Resolver Verifier is updated.\n     * @param resolverVerifierAddress The address of the new Resolver Verifier.\n     */\n    event InvestorRegistryResolverVerifierChanged(address resolverVerifierAddress);\n\n    /**\n     * @notice Emitted when the zk program image IDs are updated.\n     * @param credentialImageID The new image ID for the credential zk program.\n     * @param subscriptionImageID The new image ID for the subscription zk program.\n     */\n    event InvestorRegistryImageIDsChanged(bytes32 credentialImageID, bytes32 subscriptionImageID);\n\n    /**\n     * @notice Initialize the registry\n     * @param _roleRegistry Address of the Role Registry\n     * @param _instrumentRegistry Address of the Instrument Registry\n     * @param _dealerRegistry Address of the Dealer Registry\n     * @param _jurisdictionRegistry Address of the Jurisdiction Registry\n     * @param _operationsEngine Address of the Operations Engine\n     * @param _eas Address of the Ethereum Attestation Service contract\n     * @param _gatewayManager Address of the gateway manager contract\n     * @param _resolverVerifier Address of the Resolver Verifier\n     * @param _policyViewer Address of the Policy Viewer\n     */\n    function initialize(\n        IRoleRegistry _roleRegistry,\n        IInstrumentRegistry _instrumentRegistry,\n        IDealerRegistry _dealerRegistry,\n        IEternalRegistryStorage _jurisdictionRegistry,\n        IOperationsEngine _operationsEngine,\n        IEAS _eas,\n        IGatewayManager _gatewayManager,\n        address _resolverVerifier,\n        address _policyViewer\n    ) external;\n\n    /**\n     * @notice Adds a new investor to the registry\n     * @param _senderRole Role the sender claims to have\n     * @param _investorId ID of the investor\n     * @param _wallet Default address of the investor\n     * @param _dealerId ID of the dealer\n     */\n    function addInvestor(bytes32 _senderRole, bytes32 _investorId, address _wallet, bytes32 _dealerId) external;\n\n    /**\n     * @notice Checks a subscription is allowed into the instrument\n     * @param _proof proof data for zk verifier\n     */\n    function checkSubscription(OrderProofData calldata _proof) external view;\n\n    /**\n     * @notice Replaces the ResolverVerifier contract with a new version, renewing the schema in the process\n     * @param _resolverVerifier address of new resolverVerifier\n     */\n    function configureResolverVerifier(address _resolverVerifier) external;\n\n    /**\n     * @notice Changes the zk program image IDs to use with the verifier\n     * @param _credentialImageID new image ID for the credential zk program\n     * @param _subscriptionImageID new image ID for the subscription zk program\n     */\n    function configureImageIDs(bytes32 _credentialImageID, bytes32 _subscriptionImageID) external;\n\n    /**\n     * @notice Creates a new investor credential or updates an existing/revoked one\n     * @param _proof contains data for setting the credential, including the zk-proof to verify\n     * @dev When updating credential, seal should contain the proof for new instruments, while\n     * the journal should include existing ones to be kept, bridge new credential via gateway manager\n     */\n    function setCredential(CredentialProofData calldata _proof) external;\n\n    /**\n     * @notice Revokes an investor credential, or access to certain instruments, bridge revoked credential via gateway manager\n     * @param _investorId Id of the investor\n     * @param _instrumentIds Instruments to revoke access from (entire credential revoked if left empty)\n     */\n    function revokeCredential(bytes32 _investorId, bytes32[] calldata _instrumentIds) external;\n\n    /**\n     * @notice Checks if the investor has a valid credential\n     * @param _investorId Id of the investor\n     */\n    function checkCredential(bytes32 _investorId) external view;\n\n    /**\n     * @notice Checks if the investor has a valid credential granting access to the instrument\n     * @param _investorId Id of the investor\n     * @param _instrumentId Id of the instrument\n     */\n    function checkCredentialInstrument(bytes32 _investorId, bytes32 _instrumentId) external view;\n\n    /**\n     * @notice Get dealer id of an investor\n     * @param _investorId The ID of the investor\n     * @return dealerId_ Id of the dealer associated to the investor\n     */\n    function getDealer(bytes32 _investorId) external view returns (bytes32 dealerId_);\n\n    /**\n     * Used by the ResolverVerifier to fetch the proof data for the current attestation\n     * @return Proof Data\n     */\n    function getTempSteelProofData() external view returns (SteelProofData memory);\n}\n"
    },
    "src/interfaces/IFundRegistry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {IBaseRegistry} from \"src/interfaces/IBaseRegistry.sol\";\nimport {IRoleRegistry} from \"src/interfaces/IRoleRegistry.sol\";\nimport {IOperationsEngine} from \"src/interfaces/IOperationsEngine.sol\";\n\n/**\n * @title IFundRegistry\n * @author Libre\n * @notice Interface for managing and storing information related to funds within a registry.\n * Provides functionality to initialize the registry, add new funds, and emit events for key actions.\n */\ninterface IFundRegistry is IBaseRegistry {\n    /// @notice Error raised when attempting to register a fund that is already registered.\n    error IFundRegistry_AlreadyRegistered();\n\n    /**\n     * @notice Emited when a new Fund is added\n     * @param fundId Id of the new fund\n     */\n    event NewFundAdded(bytes32 indexed fundId);\n\n    /**\n     * @notice Initialize the registry\n     * @param _roleRegistry Address of the role registry\n     */\n    function initialize(IRoleRegistry _roleRegistry, IOperationsEngine _operationsEngine) external;\n\n    /**\n     * @notice Adds a new fund to the registry\n     * @param _senderRole Role of the sender which allow the operation execution\n     * @param _fundId The ID of the fund\n     */\n    function addNewFund(bytes32 _senderRole, bytes32 _fundId) external;\n}\n"
    },
    "src/interfaces/IEternalRegistryStorage.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title IEternalRegistryStorage\n * @notice Interface for managing a flexible and extensible storage system, allowing various types of values to be\n * stored and retrieved for specific registry entries. Provides a robust and modular way to interact with registry data.\n * @dev Enables storage and retrieval of multiple data types (e.g., uint256, address, string, bool, bytes32) and\n * supports operations like batch updates, array manipulations, and role-based access control for data modifications.\n */\ninterface IEternalRegistryStorage {\n    /**\n     * @notice Thrown when attempting to modify a key that has been restricted.\n     */\n    error IEternalRegistryStorage_AttemptToSetARestrictedKey();\n\n    /**\n     * @notice Thrown when the length of the provided input arrays does not match.\n     */\n    error IEternalRegistryStorage_BatchLengthMismatch();\n\n    /**\n     * @notice Thrown when attempting to access an array index that is out of bounds.\n     */\n    error IEternalRegistryStorage_IndexShouldBeLessThanLengthOfTheArray();\n\n    /**\n     * @notice Emitted when a boolean value is added to the registry.\n     * @param id The identifier of the registry entry.\n     * @param key The key associated with the boolean value.\n     * @param value The boolean value added to the registry.\n     */\n    event AddedBool(bytes32 indexed id, bytes32 indexed key, bool value);\n\n    /**\n     * @notice Emitted when a uint256 value is added to the registry.\n     * @param id The identifier of the registry entry.\n     * @param key The key associated with the uint256 value.\n     * @param value The uint256 value added to the registry.\n     */\n    event AddedUint(bytes32 indexed id, bytes32 indexed key, uint256 value);\n\n    /**\n     * @notice Emitted when an address value is added to the registry.\n     * @param id The identifier of the registry entry.\n     * @param key The key associated with the address value.\n     * @param value The address value added to the registry.\n     */\n    event AddedAddress(bytes32 indexed id, bytes32 indexed key, address value);\n\n    /**\n     * @notice Emitted when a string value is added to the registry.\n     * @param id The identifier of the registry entry.\n     * @param key The key associated with the string value.\n     * @param value The string value added to the registry.\n     */\n    event AddedString(bytes32 indexed id, bytes32 indexed key, string value);\n\n    /**\n     * @notice Emitted when a bytes32 value is added to the registry.\n     * @param id The identifier of the registry entry.\n     * @param key The key associated with the bytes32 value.\n     * @param value The bytes32 value added to the registry.\n     */\n    event AddedBytes(bytes32 indexed id, bytes32 indexed key, bytes32 value);\n\n    /**\n     * @notice Emitted every time a key is restricted from being set\n     * for an specific entry\n     * @param _id Id of the entry where the key is restricted\n     * @param _key Key being restricted\n     */\n    event KeyRestricted(bytes32 indexed _id, bytes32 indexed _key);\n\n    /**\n     * @notice Get a boolean value from the storage\n     * @param _id Id of the registry entry to get the value from\n     * @param _key Key identifying the value to get\n     * @return bool value of the element associated to the key\n     * in the requested registry entry\n     */\n    function getBool(bytes32 _id, bytes32 _key) external view returns (bool);\n\n    /**\n     * @notice Get a uint256 value from the storage\n     * @param _id Id of the registry entry to get the value from\n     * @param _key Key identifying the value to get\n     * @return uint256 value of the element associated to the key\n     * in the requested registry entry\n     */\n    function getUint(bytes32 _id, bytes32 _key) external view returns (uint256);\n\n    /**\n     * @notice Get an address value from the storage\n     * @param _id Id of the registry entry to get the value from\n     * @param _key Key identifying the value to get\n     * @return address value of the element associated to the key\n     * in the requested registry entry\n     */\n    function getAddress(bytes32 _id, bytes32 _key) external view returns (address);\n\n    /**\n     * @notice Get a string value from the storage\n     * @param _id Id of the registry entry to get the value from\n     * @param _key Key identifying the value to get\n     * @return string value of the element associated to the key\n     * in the requested registry entry\n     */\n    function getString(bytes32 _id, bytes32 _key) external view returns (string memory);\n\n    /**\n     * @notice Get a bytes value from the storage\n     * @param _id Id of the registry entry to get the value from\n     * @param _key Key identifying the value to get\n     * @return bytes value of the element associated to the key\n     * in the requested registry entry\n     */\n    function getBytes(bytes32 _id, bytes32 _key) external view returns (bytes32);\n\n    /**\n     * @notice Set a boolean value on the storage\n     * @param _id Id of the registry entry to set the value on\n     * @param _key Key identifying the value to set\n     * @param _value Value to set\n     * @param _senderRole Role of the sender allowing the operation\n     */\n    function setBool(bytes32 _id, bytes32 _key, bool _value, bytes32 _senderRole) external;\n\n    /**\n     * @notice Set a uint256 value on the storage\n     * @param _id Id of the registry entry to set the value on\n     * @param _key Key identifying the value to set\n     * @param _value Value to set\n     * @param _senderRole Role of the sender allowing the operation\n     */\n    function setUint(bytes32 _id, bytes32 _key, uint256 _value, bytes32 _senderRole) external;\n\n    /**\n     * @notice Set an address value on the storage\n     * @param _id Id of the registry entry to set the value on\n     * @param _key Key identifying the value to set\n     * @param _value Value to set\n     * @param _senderRole Role of the sender allowing the operation\n     */\n    function setAddress(bytes32 _id, bytes32 _key, address _value, bytes32 _senderRole) external;\n\n    /**\n     * @notice Set a string value on the storage\n     * @param _id Id of the registry entry to set the value on\n     * @param _key Key identifying the value to set\n     * @param _value Value to set\n     * @param _senderRole Role of the sender allowing the operation\n     */\n    function setString(bytes32 _id, bytes32 _key, string calldata _value, bytes32 _senderRole) external;\n\n    /**\n     * @notice Set a bytes value on the storage\n     * @param _id Id of the registry entry to set the value on\n     * @param _key Key identifying the value to set\n     * @param _value Value to set\n     * @param _senderRole Role of the sender allowing the operation\n     */\n    function setBytes(bytes32 _id, bytes32 _key, bytes32 _value, bytes32 _senderRole) external;\n\n    /**\n     * @notice Set multiple values in one transaction\n     * @param _ids Ids associated to the values to set\n     * @param _keys Key associated to the values to set\n     * @param _boolValues Bool values to set\n     * @param _uintValues Uint256 values to set\n     * @param _addressValues Address values to set\n     * @param _stringValues String values to set\n     * @param _bytesValues Bytes32 values to set\n     * @param _senderRole Role of the sender allowing the operation\n     */\n    function setBatch(\n        bytes32[] memory _ids,\n        bytes32[] memory _keys,\n        bool[] memory _boolValues,\n        uint256[] memory _uintValues,\n        address[] memory _addressValues,\n        string[] memory _stringValues,\n        bytes32[] memory _bytesValues,\n        bytes32 _senderRole\n    ) external;\n\n    /**\n     * @notice Get multiple values in one transaction\n     * @param _ids Ids associated to the values to get\n     * @param _keys Keys associated to the values to get\n     * @param _boolCount Number of bool values to get\n     * @param _uintCount Number of uint256 values to get\n     * @param _addressCount Number of address values to get\n     * @param _stringCount Number of string values to get\n     * @param _bytesCount Number of bytes32 values to get\n     * @return _boolValues Bool values return array\n     * @return _uintValues Uint256 values return array\n     * @return _addressValues Address values return array\n     * @return _stringValues String values return array\n     * @return _bytesValues Bytes32 values return array\n     */\n    function getBatch(\n        bytes32[] memory _ids,\n        bytes32[] memory _keys,\n        uint256 _boolCount,\n        uint256 _uintCount,\n        uint256 _addressCount,\n        uint256 _stringCount,\n        uint256 _bytesCount\n    )\n        external\n        view\n        returns (\n            bool[] memory _boolValues,\n            uint256[] memory _uintValues,\n            address[] memory _addressValues,\n            string[] memory _stringValues,\n            bytes32[] memory _bytesValues\n        );\n}\n"
    },
    "src/utils/Constant.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.28;\n\nimport \"src/utils/JurisdictionEncodings.sol\";\nimport \"src/utils/Types.sol\";\n\n// General Config\nbytes32 constant TIMEZONE = keccak256(\"TIMEZONE\");\nbytes32 constant MAX_TIMEZONE = keccak256(\"MAX_TIMEZONE\");\n\n// Chain/Gateway Config\nuint16 constant NATIVE_CHAIN_SELECTOR = 101;\n\n// NAV\nbytes32 constant AUDITED_NAV_PER_SHARE = keccak256(\"AUDITED_NAV_PER_SHARE\");\nbytes32 constant INSTRUMENT_ALLOWED_ADDRESSES = keccak256(\"INSTRUMENT_ALLOWED_ADDRESSES\");\n\n// Volatility\nbytes32 constant ANNUALIZED_VOLATILITY = keccak256(\"ANNUALIZED_VOLATILITY\");\n\n// Subscription Config\nbytes32 constant SUBSCRIPTION_PHASES = keccak256(\"SUBSCRIPTION_PHASES\");\nbytes32 constant SUBSCRIPTION_START = keccak256(\"SUBSCRIPTION_START\");\nbytes32 constant SUBSCRIPTION_END = keccak256(\"SUBSCRIPTION_END\");\nbytes32 constant SUBSCRIPTION_FREQUENCY = keccak256(\"SUBSCRIPTION_FREQUENCY\");\nbytes32 constant SUBSCRIPTION_FREQUENCY_TIME_UNIT = keccak256(\"SUBSCRIPTION_FREQUENCY_TIME_UNIT\");\n\n// Redemption Config\nbytes32 constant REDEMPTION_START = keccak256(\"REDEMPTION_START\");\nbytes32 constant REDEMPTION_END = keccak256(\"REDEMPTION_END\");\nbytes32 constant REDEMPTION_FREQUENCY = keccak256(\"REDEMPTION_FREQUENCY\");\nbytes32 constant REDEMPTION_FREQUENCY_TIME_UNIT = keccak256(\"REDEMPTION_FREQUENCY_TIME_UNIT\");\n\n// Fund data\nbytes32 constant FUND_ID = keccak256(\"FUND_ID\");\nbytes32 constant DISCLOSURE_DOCUMENTS = keccak256(\"DISCLOSURE_DOCUMENTS\");\nbytes32 constant LISTED_ON_REGULATED_VENUE = keccak256(\"LISTED_ON_REGULATED_VENUE\");\nbytes32 constant LOCAL_AIFM = keccak256(\"LOCAL_AIFM\");\nbytes32 constant NON_EU_AIFM = keccak256(\"NON_EU_AIFM\");\n\n// Fund Instruments data\nbytes32 constant INSTRUMENT_TOKEN = keccak256(\"INSTRUMENT_TOKEN\");\nbytes32 constant LOCAL_INVESTOR_MINIMUM_HOLDING = keccak256(\"LOCAL_INVESTOR_MINIMUM_HOLDING\");\nbytes32 constant AGGREGATED_MINIMUM_REDEMPTION_VALUE = keccak256(\"AGGREGATED_MINIMUM_REDEMPTION_VALUE\");\nbytes32 constant AGGREGATED_MINIMUM_SUBSEQUENT_SUBSCRIPTION = keccak256(\"AGGREGATED_MINIMUM_SUBSEQUENT_SUBSCRIPTION\");\nbytes32 constant INVESTOR_MINIMUM_INITIAL_SUBSCRIPTION = keccak256(\"INVESTOR_MINIMUM_INITIAL_SUBSCRIPTION\");\nbytes32 constant INVESTOR_MINIMUM_SUBSEQUENT_SUBSCRIPTION = keccak256(\"INVESTOR_MINIMUM_SUBSEQUENT_SUBSCRIPTION\");\nbytes32 constant REDEMPTION_BOOK = keccak256(\"REDEMPTION_BOOK\");\nbytes32 constant SUBSCRIPTION_BOOK = keccak256(\"SUBSCRIPTION_BOOK\");\n\n// Subscription Cutoff\nbytes32 constant SUBSCRIPTION_CUT_OFF_CALENDAR_DAYS = keccak256(\"SUBSCRIPTION_CUT_OFF_CALENDAR_DAYS\");\nbytes32 constant SUBSCRIPTION_CUT_OFF_BUSINESS_DAYS = keccak256(\"SUBSCRIPTION_CUT_OFF_BUSINESS_DAYS\");\nbytes32 constant SUBSCRIPTION_CUT_OFF_TIME = keccak256(\"SUBSCRIPTION_CUT_OFF_TIME\");\nbytes32 constant SUBSCRIPTION_CUT_OFF_PERIOD = keccak256(\"SUBSCRIPTION_CUT_OFF_PERIOD\");\n\nbytes32 constant LOCAL_AGGREGATE_MINIMUM_HOLDING = keccak256(\"LOCAL_AGGREGATE_MINIMUM_HOLDING\");\nbytes32 constant SUBSCRIPTION_SIZE_MULTIPLE = keccak256(\"SUBSCRIPTION_SIZE_MULTIPLE\");\nbytes32 constant GLOBAL_AGGREGATE_MINIMUM_BREACH = keccak256(\"GLOBAL_AGGREGATE_MINIMUM_BREACH\");\nbytes32 constant FORCED_REDEMPTION_TOP_UP_PERIOD = keccak256(\"FORCED_REDEMPTION_TOP_UP_PERIOD\");\nbytes32 constant FORCED_REDEMPTION_TOP_UP_PERIOD_UNIT = keccak256(\"FORCED_REDEMPTION_TOP_UP_PERIOD_UNIT\");\nbytes32 constant REDEMPTION_VOLUME_LIMIT = keccak256(\"REDEMPTION_VOLUME_LIMIT\");\nbytes32 constant REDEMPTION_VOLUME_LIMIT_PER_INVESTOR = keccak256(\"REDEMPTION_VOLUME_LIMIT_PER_INVESTOR\");\nbytes32 constant REDEMPTION_VOLUME_LIMIT_PER_INVESTOR_FEE = keccak256(\"REDEMPTION_VOLUME_LIMIT_PER_INVESTOR_FEE\");\nbytes32 constant REDEMPTION_LOOKBACK_PERIOD = keccak256(\"REDEMPTION_LOOKBACK_PERIOD\");\nbytes32 constant REDEMPTION_LOOKBACK_PERIOD_UNIT = keccak256(\"REDEMPTION_LOOKBACK_PERIOD_UNIT\");\nbytes32 constant GATE_CRITERIA_1 = keccak256(\"GATE_CRITERIA_1\");\nbytes32 constant REDEMPTION_NOTICE_PERIOD = keccak256(\"REDEMPTION_NOTICE_PERIOD\");\nbytes32 constant REDEMPTION_NOTICE_PERIOD_UNIT = keccak256(\"REDEMPTION_NOTICE_PERIOD_UNIT\");\nbytes32 constant REDEMPTION_CUT_OFF_PERIOD = keccak256(\"REDEMPTION_CUT_OFF_PERIOD\");\n// Calendar\nbytes32 constant BUSINESS_DAY_BITMAP_PART_1 = keccak256(\"BUSINESS_DAY_BITMAP_PART_1\");\nbytes32 constant BUSINESS_DAY_BITMAP_PART_2 = keccak256(\"BUSINESS_DAY_BITMAP_PART_2\");\n\n// Redemption Cutoff\nbytes32 constant REDEMPTION_CUT_OFF_CALENDAR_DAYS = keccak256(\"REDEMPTION_CUT_OFF_CALENDAR_DAYS\");\nbytes32 constant REDEMPTION_CUT_OFF_BUSINESS_DAYS = keccak256(\"REDEMPTION_CUT_OFF_BUSINESS_DAYS\");\nbytes32 constant REDEMPTION_CUT_OFF_TIME = keccak256(\"REDEMPTION_CUT_OFF_TIME\");\n\n// Execution Date\nbytes32 constant SUBSCRIPTION_NOTICE_PERIOD_CALENDAR_MONTHS = keccak256(\"SUBSCRIPTION_NOTICE_PERIOD_CALENDAR_MONTHS\");\nbytes32 constant SUBSCRIPTION_NOTICE_PERIOD_CALENDAR_DAYS = keccak256(\"SUBSCRIPTION_NOTICE_PERIOD_CALENDAR_DAYS\");\nbytes32 constant SUBSCRIPTION_NOTICE_PERIOD_BUSINESS_DAYS = keccak256(\"SUBSCRIPTION_NOTICE_PERIOD_BUSINESS_DAYS\");\nbytes32 constant SUBSCRIPTION_CUTOFF_TIME = keccak256(\"SUBSCRIPTION_CUTOFF_TIME\");\nbytes32 constant WAIVE_SUBSCRIPTION_NOTICE_PERIOD = keccak256(\"WAIVE_SUBSCRIPTION_NOTICE_PERIOD\");\nbytes32 constant SUBSCRIPTION_PREADJUSTMENT_DEALING_DAY_OF_MONTH =\n    keccak256(\"SUBSCRIPTION_PREADJUSTMENT_DEALING_DAY_OF_MONTH\");\nbytes32 constant REDEMPTION_NOTICE_PERIOD_CALENDAR_MONTHS = keccak256(\"REDEMPTION_NOTICE_PERIOD_CALENDAR_MONTHS\");\nbytes32 constant REDEMPTION_NOTICE_PERIOD_CALENDAR_DAYS = keccak256(\"REDEMPTION_NOTICE_PERIOD_CALENDAR_DAYS\");\nbytes32 constant REDEMPTION_NOTICE_PERIOD_BUSINESS_DAYS = keccak256(\"REDEMPTION_NOTICE_PERIOD_BUSINESS_DAYS\");\nbytes32 constant REDEMPTION_CUTOFF_TIME = keccak256(\"REDEMPTION_CUTOFF_TIME\");\nbytes32 constant WAIVE_REDEMPTION_NOTICE_PERIOD = keccak256(\"WAIVE_REDEMPTION_NOTICE_PERIOD\");\nbytes32 constant REDEMPTION_PREADJUSTMENT_DEALING_DAY_OF_MONTH =\n    keccak256(\"REDEMPTION_PREADJUSTMENT_DEALING_DAY_OF_MONTH\");\n\n// Redemption Holding Intervals\nbytes32 constant REDEMPTION_FIRST_UNLOCK_PERIOD = keccak256(\"REDEMPTION_FIRST_UNLOCK_PERIOD\");\nbytes32 constant REDEMPTION_SECOND_UNLOCK_PERIOD = keccak256(\"REDEMPTION_SECOND_UNLOCK_PERIOD\");\n\nbytes32 constant CUMULATIVE_REDEMPTION_PERIOD = keccak256(\"CUMULATIVE_REDEMPTION_PERIOD\");\nbytes32 constant CUMULATIVE_REDEMPTION_PERIOD_UNIT = keccak256(\"CUMULATIVE_REDEMPTION_PERIOD_UNIT\");\nbytes32 constant CUMULATIVE_REDEMPTION_LIMIT_FEE = keccak256(\"CUMULATIVE_REDEMPTION_LIMIT_FEE\");\nbytes32 constant CUMULATIVE_REDEMPTION_LIMIT_ALLOWANCE = keccak256(\"CUMULATIVE_REDEMPTION_LIMIT_ALLOWANCE\");\nbytes32 constant CUMULATIVE_REDEMPTION_LIMIT_PER_INVESTOR_ALLOWANCE =\n    keccak256(\"CUMULATIVE_REDEMPTION_LIMIT_PER_INVESTOR_ALLOWANCE\");\nbytes32 constant CUMULATIVE_REDEMPTION_LIMIT_PER_INVESTOR_FEE =\n    keccak256(\"CUMULATIVE_REDEMPTION_LIMIT_PER_INVESTOR_FEE\");\nbytes32 constant INITIAL_REDEMPTION_RESTRICTED_PERIOD = keccak256(\"INITIAL_REDEMPTION_RESTRICTED_PERIOD\");\nbytes32 constant INITIAL_SUBSCRIPTION_RESTRICTED_PERIOD = keccak256(\"INITIAL_SUBSCRIPTION_RESTRICTED_PERIOD\");\nbytes32 constant INITIAL_SUBSCRIPTION_RESTRICTED_PERIOD_UNIT = keccak256(\"INITIAL_SUBSCRIPTION_RESTRICTED_PERIOD_UNIT\");\nbytes32 constant INITIAL_SUBSCRIPTION_RESTRICTED_PERIOD_ALLOWANCE =\n    keccak256(\"INITIAL_SUBSCRIPTION_RESTRICTED_PERIOD_ALLOWANCE\");\nbytes32 constant INITIAL_SUBSCRIPTION_RESTRICTED_PERIOD_FEE = keccak256(\"INITIAL_SUBSCRIPTION_RESTRICTED_PERIOD_FEE\");\nbytes32 constant INITIAL_REDEMPTION_RESTRICTED_PERIOD_ALLOWANCE =\n    keccak256(\"INITIAL_REDEMPTION_RESTRICTED_PERIOD_ALLOWANCE\");\nbytes32 constant POST_SUBSCRIPTION_RESTRICTED_PERIOD_ALLOWANCE =\n    keccak256(\"POST_SUBSCRIPTION_RESTRICTED_PERIOD_ALLOWANCE\");\nbytes32 constant POST_SUBSCRIPTION_RESTRICTED_PERIOD_FEE = keccak256(\"POST_SUBSCRIPTION_RESTRICTED_PERIOD_FEE\");\nbytes32 constant INITIAL_REDEMPTION_RESTRICTED_PERIOD_FEE = keccak256(\"INITIAL_REDEMPTION_RESTRICTED_PERIOD_FEE\");\nbytes32 constant POST_REDEMPTION_RESTRICTED_PERIOD_ALLOWANCE = keccak256(\"POST_REDEMPTION_RESTRICTED_PERIOD_ALLOWANCE\");\nbytes32 constant POST_REDEMPTION_RESTRICTED_PERIOD_FEE = keccak256(\"POST_REDEMPTION_RESTRICTED_PERIOD_FEE\");\nbytes32 constant GLOBAL_AGGREGATE_MINIMUM_HOLDING = keccak256(\"GLOBAL_AGGREGATE_MINIMUM_HOLDING\");\nbytes32 constant BLOCKED = keccak256(\"BLOCKED\");\nbytes32 constant RESIDENCES_ALLOWED = keccak256(\"RESIDENCES_ALLOWED\");\nbytes32 constant NATIONALITIES_ALLOWED = keccak256(\"NATIONALITIES_ALLOWED\");\nbytes32 constant INVESTOR_TYPES_ALLOWED = keccak256(\"INVESTOR_TYPES_ALLOWED\");\nbytes32 constant ESTIMATED_REDEMPTION_FEE = keccak256(\"ESTIMATED_REDEMPTION_FEE\");\nbytes32 constant IS_INVESTOR_ALLOWED = keccak256(\"IS_INVESTOR_ALLOWED\");\nbytes32 constant HOLDING_FEE = keccak256(\"HOLDING_FEE\");\nbytes32 constant HOLDING_FEE_PERIOD = keccak256(\"HOLDING_FEE_PERIOD\");\nbytes32 constant HOLDING_FEE_PERIOD_UNIT = keccak256(\"HOLDING_FEE_PERIOD_UNIT\");\n\n// Investors data\nbytes32 constant INVESTOR_TYPE = keccak256(\"INVESTOR_TYPE\");\nbytes32 constant MAX_INVESTOR_TYPE = keccak256(\"MAX_INVESTOR_TYPE\");\nbytes32 constant NATIONALITIES = keccak256(\"NATIONALITIES\");\nbytes32 constant REVIEW_DATE = keccak256(\"REVIEW_DATE\");\nbytes32 constant KYC_PASSED = keccak256(\"KYC_PASSED\");\nbytes32 constant AML_PASSED = keccak256(\"AML_PASSED\");\nbytes32 constant SANCTIONS_PASSED = keccak256(\"SANCTIONS_PASSED\");\nbytes32 constant SELF_CERTIFICATION = keccak256(\"SELF_CERTIFICATION\");\nbytes32 constant FITNESS_TEST = keccak256(\"FITNESS_TEST\");\nbytes32 constant FROZEN = keccak256(\"FROZEN\");\nbytes32 constant USA_STATE = keccak256(\"USA_STATE\");\nbytes32 constant ALLOWED_TO_INTERACT_DAY = keccak256(\"ALLOWED_TO_INTERACT_DAY\");\nbytes32 constant DEALER = keccak256(\"DEALER\");\nbytes32 constant REVERSE_ENQUIRY = keccak256(\"REVERSE_ENQUIRY\");\n\n// Jurisdictions data\nbytes32 constant JURISDICTION_ALLOWED = keccak256(\"JURISDICTION_ALLOWED\");\nbytes32 constant INVESTOR_ALLOWLISTED_REQUIRED = keccak256(\"INVESTOR_ALLOWLISTED_REQUIRED\");\nbytes32 constant SELF_CERTIFICATION_REQUIRED = keccak256(\"SELF_CERTIFICATION_REQUIRED\");\nbytes32 constant FITNESS_TEST_REQUIRED = keccak256(\"FITNESS_TEST_REQUIRED\");\nbytes32 constant DISCLOSURE_DOCUMENTS_REQUIRED = keccak256(\"DISCLOSURE_DOCUMENTS_REQUIRED\");\nbytes32 constant LISTED_ON_REGULATED_VENUE_REQUIRED = keccak256(\"LISTED_ON_REGULATED_VENUE_REQUIRED\");\nbytes32 constant LOCAL_AIFM_REQUIRED = keccak256(\"LOCAL_AIFM_REQUIRED\");\nbytes32 constant NON_EU_AIFM_REQUIRED = keccak256(\"NON_EU_AIFM_REQUIRED\");\nbytes32 constant MINIMUM_INVESTMENT_REQUIRED = keccak256(\"MINIMUM_INVESTMENT_REQUIRED\");\nbytes32 constant MINIMUM_INVESTMENT = keccak256(\"MINIMUM_INVESTMENT\");\nbytes32 constant NO_MINIMUM_INVESTMENT_HOLDER_NUMBER = keccak256(\"NO_MINIMUM_INVESTMENT_HOLDER_NUMBER\");\n\n// Registries\nbytes32 constant GENERAL_DATA_ID = bytes32(0);\nbytes32 constant ETERNAL_STORAGE_SLOT = keccak256(\"ETERNAL_STORAGE_SLOT\");\nbytes32 constant BLACKLISTED_WALLET = keccak256(\"BLACKLISTED_WALLET\");\n\n// Tracking\nbytes32 constant CURRENT_SUBSCRIPTIONS_AMOUNT = keccak256(\"CURRENT_SUBSCRIPTIONS_AMOUNT\");\nbytes32 constant INVESTOR_SUBSCRIPTION_AMOUNT = keccak256(\"INVESTOR_SUBSCRIPTION_AMOUNT\");\nbytes32 constant CURRENT_REDEMPTIONS_AMOUNT = keccak256(\"CURRENT_REDEMPTIONS_AMOUNT\");\nbytes32 constant INVESTOR_REDEMPTION_AMOUNT = keccak256(\"INVESTOR_REDEMPTION_AMOUNT\");\nbytes32 constant REDEMPTION_RECORDS = keccak256(\"REDEMPTION_RECORDS\");\nbytes32 constant REDEMPTION_RECORDS_COUNT = keccak256(\"REDEMPTION_RECORDS_COUNT\");\nbytes32 constant REDEMPTION_RECORDS_AGGREGATE = keccak256(\"REDEMPTION_RECORDS_AGGREGATE\");\nbytes32 constant REDEMPTION_RECORDS_TIMESTAMP = keccak256(\"REDEMPTION_RECORDS_TIMESTAMP\");\nbytes32 constant HOLDING_FEE_EXEMPTION_CREDITS = keccak256(\"HOLDING_FEE_EXEMPTION_CREDITS\");\nbytes32 constant HOLDING_FEE_EXEMPTION_CREDITS_START = keccak256(\"HOLDING_FEE_EXEMPTION_CREDITS_START\");\nbytes32 constant HOLDING_FEE_EXEMPTION_CREDITS_COUNT = keccak256(\"HOLDING_FEE_EXEMPTION_CREDITS_COUNT\");\nbytes32 constant HOLDING_FEE_EXEMPTION_CREDITS_AMOUNT = keccak256(\"HOLDING_FEE_EXEMPTION_CREDITS_AMOUNT\");\nbytes32 constant HOLDING_FEE_EXEMPTION_CREDITS_TIMESTAMP = keccak256(\"HOLDING_FEE_EXEMPTION_CREDITS_TIMESTAMP\");\n\n// Tracking (Holding Intervals)\nbytes32 constant HOLDING_TIME_CREDITS = keccak256(\"HOLDING_TIME_CREDITS\");\nbytes32 constant HOLDING_TIME_CREDITS_START = keccak256(\"HOLDING_TIME_CREDITS_START\");\nbytes32 constant HOLDING_TIME_CREDITS_COUNT = keccak256(\"HOLDING_TIME_CREDITS_COUNT\");\nbytes32 constant HOLDING_TIME_CREDITS_TIMESTAMP = keccak256(\"HOLDING_TIME_CREDITS_TIMESTAMP\");\n\nbytes32 constant HOLDING_CREDITS_FIRST_PERIOD = keccak256(\"HOLDING_CREDITS_FIRST_PERIOD\"); // related to REDEMPTION_FIRST_UNLOCK_PERIOD\nbytes32 constant HOLDING_CREDITS_SECOND_PERIOD = keccak256(\"HOLDING_CREDITS_SECOND_PERIOD\"); // related to REDEMPTION_SECOND_UNLOCK_PERIOD\n\nbytes32 constant HOLDING_PERCENTAGE_FIRST_PERIOD = keccak256(\"HOLDING_PERCENTAGE_FIRST_PERIOD\");\nbytes32 constant HOLDING_PERCENTAGE_SECOND_PERIOD = keccak256(\"HOLDING_PERCENTAGE_SECOND_PERIOD\");\n\n// Tracking (NAV Track Module)\nbytes32 constant NAV_NUM_CHECKPOINTS = keccak256(\"NAV_NUM_CHECKPOINTS\");\nbytes32 constant NAV_CHECKPOINT = keccak256(\"NAV_CHECKPOINT\");\nbytes32 constant NAV_CHECKPOINT_TIMESTAMP = keccak256(\"NAV_CHECKPOINT_TIMESTAMP\");\n\n// Security Token Track (Per investor)\nbytes32 constant SECURITY_TOKEN_NUM_CHECKPOINTS = keccak256(\"SECURITY_TOKEN_NUM_CHECKPOINTS\");\nbytes32 constant SECURITY_TOKEN_CHECKPOINT_TIMESTAMP = keccak256(\"SECURITY_TOKEN_CHECKPOINT_TIMESTAMP\");\nbytes32 constant SECURITY_TOKEN_CHECKPOINTS = keccak256(\"SECURITY_TOKEN_CHECKPOINTS\");\n\n// Investor Registry\nbytes32 constant IS_INVESTOR = keccak256(\"IS_INVESTOR\");\nbytes32 constant LAST_OPERATION_TIMESTAMP = keccak256(\"LAST_OPERATION_TIMESTAMP\");\nbytes32 constant CREDENTIAL_ID = keccak256(\"CREDENTIAL_ID\");\nbytes32 constant INVESTOR_CROSS_CHAIN_ADDRESSES = keccak256(\"INVESTOR_CROSS_CHAIN_ADDRESSES\");\n\n// Instrument Registry\nbytes32 constant IS_INSTRUMENT = keccak256(\"IS_INSTRUMENT\");\nbytes32 constant TRADING_DAYS_IN_YEAR = keccak256(\"TRADING_DAYS_IN_YEAR\");\nbytes32 constant INSTRUMENT_INITIALIZED = keccak256(\"INSTRUMENT_INITIALIZED\");\nbytes32 constant INSTRUMENT_CLOSED = keccak256(\"INSTRUMENT_CLOSED\");\nbytes32 constant INSTANT_SETTLEMENT = keccak256(\"INSTANT_SETTLEMENT\");\nbytes32 constant CAN_TRANSFER_SETTLEMENT_TOKEN = keccak256(\"CAN_TRANSFER_SETTLEMENT_TOKEN\");\nbytes32 constant CAN_TRANSFER_SECURITY_TOKEN = keccak256(\"CAN_TRANSFER_SECURITY_TOKEN\");\nbytes32 constant INSTRUMENT_PAUSED = keccak256(\"INSTRUMENT_PAUSED\");\n\n// Dealer Registry\nbytes32 constant IS_DEALER = keccak256(\"IS_DEALER\");\n\n// Fund Registry\nbytes32 constant IS_FUND = keccak256(\"IS_FUND\");\nbytes32 constant DEFAULT_FUND_MODULES = keccak256(\"DEFAULT_FUND_MODULES\");\n\n// Roles\nbytes32 constant DEFAULT_ADMIN_ROLE = bytes32(0);\nbytes32 constant DEALER_MANAGER_ROLE = keccak256(\"DEALER_MANAGER_ROLE\");\nbytes32 constant LIBRE_DEALER_ROLE = keccak256(\"LIBRE_DEALER_ROLE\");\nbytes32 constant INSTRUMENT_MANAGER_ROLE = keccak256(\"INSTRUMENT_MANAGER_ROLE\");\nbytes32 constant SETTLEMENT_TOKEN_MINTER_ROLE = keccak256(\"SETTLEMENT_TOKEN_MINTER_ROLE\");\nbytes32 constant SETTLEMENT_TOKEN_BURNER_ROLE = keccak256(\"SETTLEMENT_TOKEN_BURNER_ROLE\");\nbytes32 constant RELAYER_ROLE = keccak256(\"RELAYER_ROLE\");\nbytes32 constant CONTRACT_MANAGER_ROLE = keccak256(\"CONTRACT_MANAGER_ROLE\");\nbytes32 constant REGISTRY_WRITER_ROLE_ADMIN = keccak256(\"REGISTRY_WRITER_ROLE_ADMIN\");\nbytes32 constant REGISTRY_WRITER_ROLE = keccak256(\"REGISTRY_WRITER_ROLE\");\nbytes32 constant ATTESTER_ROLE = keccak256(\"ATTESTER_ROLE\");\nbytes32 constant GATEWAY_MANAGER_ROLE = keccak256(\"GATEWAY_MANAGER_ROLE\");\nbytes32 constant CORE_GATEWAY_ROLE = keccak256(\"CORE_GATEWAY_ROLE\");\nbytes32 constant BRIDGE_ROLE = keccak256(\"BRIDGE_ROLE\");\nbytes32 constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n\n// Hash of module names\nbytes32 constant TRANSFER_MODULE = keccak256(\"TransferModule\");\nbytes32 constant DAILY_EXECUTION_CALCULATOR_MODULE = keccak256(\"DailyExecutionCalculatorModule\");\nbytes32 constant EXECUTION_DATE_ENFORCEMENT_MODULE = keccak256(\"ExecutionDateEnforcementModule\");\nbytes32 constant HALT_MODULE = keccak256(\"HaltModule\");\nbytes32 constant HOLDINGS_MODULE = keccak256(\"HoldingsModule\");\nbytes32 constant MONTHLY_EXECUTION_CALCULATOR_MODULE = keccak256(\"MonthlyExecutionCalculatorModule\");\nbytes32 constant FORCED_REDEMPTION_MODULE = keccak256(\"ForcedRedemptionModule\");\nbytes32 constant GATE_1_MODULE = keccak256(\"Gate1Module\");\nbytes32 constant HOLDING_INTERVALS_MODULE = keccak256(\"HoldingIntervalsModule\");\nbytes32 constant REDEMPTIONS_AGGREGATION_LIMIT_MODULE = keccak256(\"RedemptionsAggregationLimitModule\");\nbytes32 constant SUBSCRIPTIONS_AGGREGATION_LIMIT_MODULE = keccak256(\"SubscriptionsAggregationLimitModule\");\nbytes32 constant HOLDING_FEE_MODULE = keccak256(\"HoldingFeeModule\");\nbytes32 constant REDEMPTION_VOLUME_LIMIT_PER_INVESTOR_FEE_MODULE =\n    keccak256(\"RedemptionVolumeLimitPerInvestorFeeModule\");\nbytes32 constant INVESTOR_LAST_OPERATION_TRACKING_MODULE = keccak256(\"InvestorLastOperationTrackingModule\");\nbytes32 constant NAV_TRACKING_MODULE = keccak256(\"NAVTrackingModule\");\nbytes32 constant REDEMPTIONS_RECORDS_MODULE = keccak256(\"RedemptionsRecordsModule\");\nbytes32 constant REDEMPTIONS_TOTAL_AMOUNT_MODULE = keccak256(\"RedemptionsTotalAmountModule\");\nbytes32 constant SECURITY_TOKEN_TRACKING_MODULE = keccak256(\"SecurityTokenTrackingModule\");\nbytes32 constant SUBSCRIPTIONS_TOTAL_AMOUNT_MODULE = keccak256(\"SubscriptionsTotalAmountModule\");\nbytes32 constant HOLDING_FEE_EXEMPTION_MODULE = keccak256(\"HoldingFeeExemptionModule\");\nbytes32 constant HOLDING_INTERVALS_TRACKING_MODULE = keccak256(\"HoldingIntervalsTrackingModule\");\n\n// Percentage calculations\nuint256 constant PERCENTAGE_BASE = 100_00;\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.19;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "src/interfaces/IBaseRegistry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {IEternalRegistryStorage} from \"src/interfaces/IEternalRegistryStorage.sol\";\n\n/**\n * @title IBaseRegistry\n * @notice Interface for the base registry, which provides functionality for tracking and retrieving data\n * specific to modules that interact with the registry.\n * @dev The tracked data can be queried via a delegatecall callback to the relevant module,\n * which implements the query logic.\n */\ninterface IBaseRegistry is IEternalRegistryStorage {\n    /**\n     * @notice Thrown when an unauthorized caller tries to access a restricted function or resource.\n     */\n    error IBaseRegistry_AccessDenied();\n\n    /**\n     * @notice Thrown when an action is attempted on a module that is not registered in the registry.\n     */\n    error IBaseRegistry_NotRegisteredModule();\n\n    /**\n     * @notice Thrown when an invalid or non-existent ID is provided for an operation.\n     */\n    error IBaseRegistry_NotAValidId();\n\n    /**\n     * @notice Thrown when the system fails to retrieve the tracked data for a specific operation or ID.\n     */\n    error IBaseRegistry_FailedToGetTrackedData();\n\n    /**\n     * @notice Get the tracked data of the registry\n     * @param _data Data to be used by the module to get the tracked data\n     * @return bytes memory of the tracked data\n     * @dev This function is used to get the tracked data from the registry\n     * by doing a delegatecall callback to the module requesting the data\n     * which can implement the query logic\n     */\n    function getTrackedData(bytes memory _data) external returns (bytes memory);\n}\n"
    },
    "src/interfaces/IDealerRegistry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {IBaseRegistry} from \"src/interfaces/IBaseRegistry.sol\";\nimport {IRoleRegistry} from \"src/interfaces/IRoleRegistry.sol\";\nimport {IInvestorRegistry} from \"src/interfaces/IInvestorRegistry.sol\";\nimport {IUserRegistry} from \"src/interfaces/IUserRegistry.sol\";\nimport {IOperationsEngine} from \"src/interfaces/IOperationsEngine.sol\";\nimport {IInstrumentRegistry} from \"src/interfaces/IInstrumentRegistry.sol\";\n\n/**\n * @title IDealerRegistry\n * @notice Interface for managing dealers within the registry, including adding new dealers,\n * allowing dealers for specific instruments, and checking dealer permissions.\n * @dev Extends both `IBaseRegistry` and `IUserRegistry` for core registry and user management functionality.\n */\ninterface IDealerRegistry is IBaseRegistry, IUserRegistry {\n    /**\n     * @notice Thrown when attempting to add a dealer who is already registered.\n     */\n    error IDealerRegistry_AlreadyADealer();\n\n    /**\n     * @notice Thrown when invalid input parameters are provided.\n     */\n    error IDealerRegistry_InvalidInput();\n\n    /**\n     * @notice Thrown when the specified instrument does not exist in the registry.\n     */\n    error IDealerRegistry_NonExistingInstrument();\n\n    /**\n     * @notice Thrown when the dealer is not allowed for the specified instrument.\n     */\n    error IDealerRegistry_DealerNotAllowed();\n\n    /**\n     * @notice Emited when a new dealer is added\n     * @param dealerId Id of the new dealer\n     * @param wallet Initial wallet of the dealer\n     */\n    event NewDealerAdded(bytes32 dealerId, address wallet);\n\n    /**\n     * @notice Emited when an dealer's allowed status is updated\n     * @param dealerId Id of the dealer updated\n     * @param allowed Y/N if dealer is allowed for the instrument\n     */\n    event dealerAllowedUpdated(bytes32 dealerId, bytes32 instrumentId, bool allowed);\n\n    /**\n     * @notice Initialize the registry\n     * @param _roleRegistry Address of the role registry\n     */\n    function initialize(\n        IRoleRegistry _roleRegistry,\n        IOperationsEngine _operationsEngine,\n        IInvestorRegistry _investorRegistry,\n        IInstrumentRegistry _instrumentRegistry\n    ) external;\n\n    /**\n     * @notice Adds a new dealer to the registry\n     * @param _senderRole Role of the sender which allows the operation execution\n     * @param _dealerId ID of the dealer\n     * @param _wallet Wallet of the dealer\n     */\n    function addDealer(bytes32 _senderRole, bytes32 _dealerId, address _wallet) external;\n\n    /**\n     * @notice Allows a dealer for a specific instrument\n     * @param _senderRole Role of the sender which allows the operation execution\n     * @param _dealerId ID of the dealer\n     * @param _instrumentId ID of the instrument\n     * @param _allowed Y/N if dealer is allowed for the instrument\n     */\n    function allowDealer(bytes32 _senderRole, bytes32 _dealerId, bytes32 _instrumentId, bool _allowed) external;\n\n    /**\n     * @notice Returns if the dealer is allowed for a specific instrument\n     * @param _dealerId ID of the dealer\n     * @param _instrumentId ID of the instrument\n     * @return Bool indicating if dealer if allowed\n     */\n    function isDealerAllowed(bytes32 _dealerId, bytes32 _instrumentId) external view returns (bool);\n\n    /**\n     * @notice Reverts if the dealer is not allowed for a specific instrument\n     * @param _dealerId ID of the dealer\n     * @param _instrumentId ID of the instrument\n     */\n    function checkDealerAllowed(bytes32 _dealerId, bytes32 _instrumentId) external view;\n}\n"
    },
    "src/interfaces/IRoleRegistry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {IAccessControlUpgradeable} from\n    \"openzeppelin-contracts-upgradeable/contracts/access/IAccessControlUpgradeable.sol\";\n\n/**\n * @title Roles Registry\n * @author Libre\n * @notice Store all the roles of the system as well as the permissions a user get by having each role.\n * @dev It is meant to be used for roles access validation in all the components of the system.\n */\ninterface IRoleRegistry is IAccessControlUpgradeable {\n    /**\n     * @notice Thrown when attempting to create a role that already exists.\n     */\n    error IRoleRegistry_RoleAlreadyExists();\n\n    /**\n     * @notice Thrown when attempting to grant a role that does not exist.\n     */\n    error IRoleRegistry_RoleDoesNotExist();\n\n    /**\n     * @notice Thrown when attempting to use a blacklisted wallet.\n     */\n    error IRoleRegistry_WalletBlacklisted();\n\n    /**\n     * @notice Used when a new role is created\n     * @param _role Parent role\n     * @param _subRole Newly created Role\n     */\n    event RoleCreated(bytes32 _role, bytes32 _subRole);\n\n    /**\n     * @notice Used when a contract manager is set\n     * @param _contract Contract managed\n     * @param _roleManager New contract manager role\n     */\n    event ContractManagerAdded(address _contract, bytes32 _roleManager);\n\n    /**\n     * @notice Used when a wallet is blacklisted\n     * @param _wallet Wallet blacklisted\n     */\n    event WalletBlacklisted(address _wallet);\n\n    /**\n     * @notice Used when a contract function access is granted\n     * @param _contract Contract managed\n     * @param _selector Selector of the funtion which access is modified\n     * @param _role Role getting access gratend\n     */\n    event AccessGranted(address _contract, bytes4 _selector, bytes32 _role);\n\n    /**\n     * @notice Used when a contract function access is revoked\n     * @param _contract Contract managed\n     * @param _selector Selector of the funtion which access is modified\n     * @param _role Role which access is revoked\n     */\n    event RevokedAccess(address _contract, bytes4 _selector, bytes32 _role);\n\n    /**\n     * @notice Used when a contract access is reset\n     * @param _contract Contract managed\n     * @param _timestamp Time when the reset is executed\n     */\n    event ResetedAccess(address _contract, uint256 _timestamp);\n\n    /**\n     * @notice Function to create subroles\n     * @param _role New role to create\n     * @param _adminRole Parent role of the newly created role\n     * @dev Caller needs to has role _adminRole\n     */\n    function createRole(bytes32 _role, bytes32 _adminRole) external;\n\n    /**\n     * @notice Set the role going to manage permissions in a specific contract\n     * @param _contract Address of the contract to where permissions are needed to be managed\n     * @param _roleManager Role in charge of managing the permissions\n     */\n    function setContractManager(address _contract, bytes32 _roleManager) external;\n\n    /**\n     * @notice Get the role that manages permissions in a specific contract\n     * @param _contract Address of the contract\n     */\n    function getContractManager(address _contract) external view returns (bytes32);\n\n    /**\n     * @notice Grant a role the right access a functionality of a contract\n     * @param _contract Contract where the access is granted\n     * @param _selector Functionality granted access for\n     * @param _role Role getting the access\n     */\n    function grantAccess(address _contract, bytes4 _selector, bytes32 _role) external;\n\n    /**\n     * @notice Prevent a role for having access to a functionality of a contract\n     * @param _contract Contract where the access is revoked\n     * @param _selector Functionality revoked access for\n     * @param _role Role losing the access\n     */\n    function revokeAccess(address _contract, bytes4 _selector, bytes32 _role) external;\n\n    /**\n     * @notice Revoke access to a functionality of a contract for all roles\n     * @param _contract Contract where the access is reset\n     * @param _selector Functionality reset access for\n     * @dev Cleans all the previously granted roles\n     */\n    function resetAccess(address _contract, bytes4 _selector) external;\n\n    /**\n     * @notice Blacklists a wallet.\n     * @param _wallet The wallet to blacklist.\n     */\n    function blacklistWallet(address _wallet) external;\n\n    /**\n     * @notice Check access of a role to a contract functionality\n     * @param _contract Contract where accessed\n     * @param _selector Functionality accessed\n     * @param _requestor Address attempting to access\n     * @param _role Role of the address attempting to access\n     */\n    function hasAccess(address _contract, bytes4 _selector, address _requestor, bytes32 _role)\n        external\n        view\n        returns (bool);\n\n    /**\n     * @notice Checks if a wallet is blacklisted.\n     * @param _wallet The wallet to check.\n     * @return Boolean indicating whether the wallet is blacklisted.\n     */\n    function isBlacklisted(address _wallet) external view returns (bool);\n}\n"
    },
    "src/interfaces/IOperationsEngine.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {IInvestorRegistry} from \"src/interfaces/IInvestorRegistry.sol\";\nimport {IFundRegistry} from \"src/interfaces/IFundRegistry.sol\";\nimport {IDealerRegistry} from \"src/interfaces/IDealerRegistry.sol\";\nimport {IInstrumentRegistry} from \"src/interfaces/IInstrumentRegistry.sol\";\nimport {IRoleRegistry} from \"src/interfaces/IRoleRegistry.sol\";\nimport {IEternalRegistryStorage} from \"src/interfaces/IEternalRegistryStorage.sol\";\nimport {OPERATIONS} from \"./operations/IOperationModule.sol\";\n\n/**\n * @title Operations Engine Interface\n * @author Libre\n * @notice Defines the interface for managing modules, operations, and dependencies in the system.\n * @dev Includes error definitions, events, and function signatures for interacting with the operations engine.\n */\ninterface IOperationsEngine {\n    // Enums\n    /**\n     * @notice Defines the type of ID for the module check, modules are either tracking ones or check ones.\n     */\n    enum IdType {\n        NULL,\n        INSTRUMENT_CHECK,\n        FEE,\n        TRACKING\n    }\n\n    /**\n     * @notice Defines the type of check a module performs.\n     */\n    enum CHECK_TYPE {\n        BOOLEAN,\n        NUMERIC_MIN,\n        NUMERIC_MAX\n    }\n\n    // Errors\n    /**\n     * @dev Revert when the tracking module reverts for any reason\n     */\n    error IOperationsEngine_TrackingModuleFailure();\n\n    /**\n     * @dev Revert when the fee module reverts for any reason\n     */\n    error IOperationsEngine_FeeModuleFailure();\n\n    /**\n     * @dev Revert when the module address provided is invalid.\n     */\n    error IOperationsEngine_InvalidModuleAddress();\n\n    /**\n     * @dev Revert when the module is not of the Libre type.\n     */\n    error IOperationsEngine_ModuleIsNotLibreType();\n\n    /**\n     * @dev Revert when a lending module cannot be disabled.\n     */\n    error IOperationsEngine_LendingModuleDisable();\n\n    /**\n     * @dev Revert when dependencies required for an operation are missing.\n     */\n    error IOperationsEngine_MissingDependencies();\n\n    /**\n     * @dev Revert when an invalid check type is used.\n     */\n    error IOperationsEngine_InvalidCheckType();\n\n    /**\n     * @dev Revert when the caller is not authorized to perform the action.\n     */\n    error IOperationsEngine_CallerNotAuthorized();\n\n    /**\n     * @dev Revert when adding a module that is already been added.\n     */\n    error IOperationsEngine_ModuleAlreadyAdded();\n\n    /**\n     * @dev Revert when module already enabled for the same instrument.\n     */\n    error IOperationsEngine_ModuleAlreadyEnabled();\n\n    /**\n     * @dev Revert when a module to be disabled for an instrument is not enabled\n     */\n    error IOperationsEngine_ModuleNotEnabled();\n\n    // Events\n    /**\n     * @notice Emitted when a module is added to the available modules library.\n     * @param moduleAddress Address of the module that was added.\n     */\n    event ModuleAdded(address indexed moduleAddress);\n\n    /**\n     * @notice Emitted when a module is removed from the available modules library.\n     * @param moduleAddress Address of the module that was removed.\n     */\n    event ModuleRemoved(address indexed moduleAddress);\n\n    /**\n     * @notice Emitted when a module is enabled for a specific instrument.\n     * @param moduleAddress Address of the module that was enabled.\n     * @param instrumentId Id of the instrument for which the module was enabled.\n     */\n    event ModuleEnabled(address indexed moduleAddress, bytes32 instrumentId);\n\n    /**\n     * @notice Emitted when a module is disabled for a specific instrument.\n     * @param moduleAddress Address of the module that was disabled.\n     * @param instrumentId Id of the instrument for which the module was disabled.\n     */\n    event ModuleDisabled(address indexed moduleAddress, bytes32 instrumentId);\n\n    /**\n     * @dev Event emitted when a fee is applied.\n     * @param instrumentId The ID of the instrument.\n     * @param orderId The ID of the order.\n     * @param feeModule The address of the fee module.\n     * @param feeAmount The amount of the fee applied.\n     */\n    event FeeApplied(bytes32 indexed instrumentId, uint256 orderId, address feeModule, uint256 feeAmount);\n\n    //functions\n\n    /**\n     * @notice Initializes the Rules Engine with necessary registries.\n     * @param _investorRegistry Address of the Investor Registry.\n     * @param _dealerRegistry Address of the Dealer Registry.\n     * @param _fundRegistry Address of the Fund Registry.\n     * @param _instrumentRegistry Address of the Instrument Registry.\n     * @param _roleRegistry Address of the Role Registry.\n     * @param _jurisdictionRegistry Address of the Jurisdiction Registry.\n     */\n    function initialize(\n        IInvestorRegistry _investorRegistry,\n        IDealerRegistry _dealerRegistry,\n        IFundRegistry _fundRegistry,\n        IInstrumentRegistry _instrumentRegistry,\n        IRoleRegistry _roleRegistry,\n        IEternalRegistryStorage _jurisdictionRegistry\n    ) external;\n\n    /**\n     * @notice Gets the addresses for registered check modules implementing the given operation.\n     * @param _id Id of the dealer or instrument the modules belong to.\n     * @param _operation Operation implemented in modules.\n     * @return An array of addresses of modules implementing the given operation.\n     */\n    function getCheckModules(bytes32 _id, OPERATIONS _operation) external view returns (address[] memory);\n\n    /**\n     * @notice Gets the addresses for registered fee modules implementing the given operation.\n     * @param _id Id of the dealer or instrument the modules belong to.\n     * @param _operation Operation implemented in modules.\n     * @return An array of addresses of modules implementing the given operation.\n     */\n    function getFeeModules(bytes32 _id, OPERATIONS _operation) external view returns (address[] memory);\n\n    /**\n     * @notice Gets the addresses for registered tracking modules implementing the given operation.\n     * @param _id Id of the dealer or instrument the modules belong to.\n     * @param _operation Operation implemented in modules.\n     * @return An array of addresses of modules implementing the given operation.\n     */\n    function getTrackingModules(bytes32 _id, OPERATIONS _operation) external view returns (address[] memory);\n\n    /**\n     * @notice Adds a module to the available modules library.\n     * @param _moduleAddress Address of the module to add.\n     * @param _role Role required to add the module.\n     * @param _idType Type of the module.\n     */\n    function addModule(address _moduleAddress, bytes32 _role, IdType _idType) external;\n\n    /**\n     * @notice Removes a module from the available modules library.\n     * @param _moduleAddress Address of the module to remove.\n     * @param _role Role required to remove the module.\n     */\n    function removeModule(address _moduleAddress, bytes32 _role) external;\n\n    /**\n     * @notice Enables a module for a specific instrument.\n     * @param _moduleAddress Address of the module to enable.\n     * @param _instrumentId Id of the instrument.\n     * @param _role Role required to enable the module.\n     */\n    function enableModule(address _moduleAddress, bytes32 _instrumentId, bytes32 _role) external;\n\n    /**\n     * @notice Disables a module for a specific instrument.\n     * @param _moduleAddress Address of the module to disable.\n     * @param _instrumentId Id of the instrument.\n     * @param _role Role required to disable the module.\n     * @dev Lending modules cannot be disabled, because at least one module must be enabled at all times.\n     * Instead, the lending module can be replaced with another lending module by enabling the new module.\n     */\n    function disableModule(address _moduleAddress, bytes32 _instrumentId, bytes32 _role) external;\n\n    /**\n     * @notice Checks if a module is available in the available modules library.\n     * @param _moduleAddress Address of the module to check.\n     * @return True if the module is available, false otherwise.\n     */\n    function isAvailableModule(address _moduleAddress) external view returns (bool);\n\n    /**\n     * @notice Checks if a module is enabled for a specific instrument.\n     * @param _id Id of the instrument.\n     * @param _moduleName Hash of the abi.encodePacked of the module name\n     * @return True if the module is enabled, false otherwise.\n     */\n    function hasModuleEnabled(bytes32 _id, bytes32 _moduleName) external view returns (bool);\n\n    /**\n     * @notice Function to be delegatecalled by the registry to perform the check\n     * @param _operation The operation to be checked\n     * @param _id The id of the operation\n     * @param _data Arbitrary data that can be used by the module to perform the check\n     * @return result memory Result of the check\n     */\n    function check(OPERATIONS _operation, bytes32 _id, bytes calldata _data) external returns (bytes memory result);\n\n    /**\n     * @notice Tracks the operation\n     * @param _operation The operation to track\n     * @param _id The id of the instrument or investor\n     * @param _data The data to track\n     * @return True if the tracking was successful, false otherwise\n     */\n    function track(OPERATIONS _operation, bytes32 _id, bytes memory _data) external returns (bool);\n\n    /**\n     * @notice Calculates the total fee amount to be deducted for a given operation and instrument.\n     * @dev Loops through all enabled fee modules for the given operation and instrument, calls them with the input data,\n     *      and sums up the returned fee amounts. Also emits `FeeApplied` events for each individual module fee.\n     *\n     * @param _operation The operation type (e.g., SETTLE_SUBSCRIPTION_PER_ORDER).\n     * @param _id The instrument ID for which the fees are being calculated.\n     * @param _data ABI-encoded parameters required for fee calculation. Must encode the following values in order:\n     *        - `uint256 _orderId`: Unique identifier of the order\n     *        - `bytes32 _investorId`: The ID of the investor associated with the order\n     *        - `uint256 _amountToSettle`: The current amount to be settled\n     *\n     * @return totalFee The total fee amount to be deducted across all enabled fee modules.\n     */\n    function calculateFees(OPERATIONS _operation, bytes32 _id, bytes memory _data)\n        external\n        returns (uint256 totalFee);\n}\n"
    },
    "lib/openzeppelin-contracts-upgradeable/contracts/token/ERC20/extensions/IERC20MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.19;\n\nimport \"../IERC20Upgradeable.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "lib/eas-contracts/contracts/IEAS.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { ISchemaRegistry } from \"./ISchemaRegistry.sol\";\nimport { ISemver } from \"./ISemver.sol\";\nimport { Attestation, Signature } from \"./Common.sol\";\n\n/// @notice A struct representing the arguments of the attestation request.\nstruct AttestationRequestData {\n    address recipient; // The recipient of the attestation.\n    uint64 expirationTime; // The time when the attestation expires (Unix timestamp).\n    bool revocable; // Whether the attestation is revocable.\n    bytes32 refUID; // The UID of the related attestation.\n    bytes data; // Custom attestation data.\n    uint256 value; // An explicit ETH amount to send to the resolver. This is important to prevent accidental user errors.\n}\n\n/// @notice A struct representing the full arguments of the attestation request.\nstruct AttestationRequest {\n    bytes32 schema; // The unique identifier of the schema.\n    AttestationRequestData data; // The arguments of the attestation request.\n}\n\n/// @notice A struct representing the full arguments of the full delegated attestation request.\nstruct DelegatedAttestationRequest {\n    bytes32 schema; // The unique identifier of the schema.\n    AttestationRequestData data; // The arguments of the attestation request.\n    Signature signature; // The ECDSA signature data.\n    address attester; // The attesting account.\n    uint64 deadline; // The deadline of the signature/request.\n}\n\n/// @notice A struct representing the full arguments of the multi attestation request.\nstruct MultiAttestationRequest {\n    bytes32 schema; // The unique identifier of the schema.\n    AttestationRequestData[] data; // The arguments of the attestation request.\n}\n\n/// @notice A struct representing the full arguments of the delegated multi attestation request.\nstruct MultiDelegatedAttestationRequest {\n    bytes32 schema; // The unique identifier of the schema.\n    AttestationRequestData[] data; // The arguments of the attestation requests.\n    Signature[] signatures; // The ECDSA signatures data. Please note that the signatures are assumed to be signed with increasing nonces.\n    address attester; // The attesting account.\n    uint64 deadline; // The deadline of the signature/request.\n}\n\n/// @notice A struct representing the arguments of the revocation request.\nstruct RevocationRequestData {\n    bytes32 uid; // The UID of the attestation to revoke.\n    uint256 value; // An explicit ETH amount to send to the resolver. This is important to prevent accidental user errors.\n}\n\n/// @notice A struct representing the full arguments of the revocation request.\nstruct RevocationRequest {\n    bytes32 schema; // The unique identifier of the schema.\n    RevocationRequestData data; // The arguments of the revocation request.\n}\n\n/// @notice A struct representing the arguments of the full delegated revocation request.\nstruct DelegatedRevocationRequest {\n    bytes32 schema; // The unique identifier of the schema.\n    RevocationRequestData data; // The arguments of the revocation request.\n    Signature signature; // The ECDSA signature data.\n    address revoker; // The revoking account.\n    uint64 deadline; // The deadline of the signature/request.\n}\n\n/// @notice A struct representing the full arguments of the multi revocation request.\nstruct MultiRevocationRequest {\n    bytes32 schema; // The unique identifier of the schema.\n    RevocationRequestData[] data; // The arguments of the revocation request.\n}\n\n/// @notice A struct representing the full arguments of the delegated multi revocation request.\nstruct MultiDelegatedRevocationRequest {\n    bytes32 schema; // The unique identifier of the schema.\n    RevocationRequestData[] data; // The arguments of the revocation requests.\n    Signature[] signatures; // The ECDSA signatures data. Please note that the signatures are assumed to be signed with increasing nonces.\n    address revoker; // The revoking account.\n    uint64 deadline; // The deadline of the signature/request.\n}\n\n/// @title IEAS\n/// @notice EAS - Ethereum Attestation Service interface.\ninterface IEAS is ISemver {\n    /// @notice Emitted when an attestation has been made.\n    /// @param recipient The recipient of the attestation.\n    /// @param attester The attesting account.\n    /// @param uid The UID of the new attestation.\n    /// @param schemaUID The UID of the schema.\n    event Attested(address indexed recipient, address indexed attester, bytes32 uid, bytes32 indexed schemaUID);\n\n    /// @notice Emitted when an attestation has been revoked.\n    /// @param recipient The recipient of the attestation.\n    /// @param attester The attesting account.\n    /// @param schemaUID The UID of the schema.\n    /// @param uid The UID the revoked attestation.\n    event Revoked(address indexed recipient, address indexed attester, bytes32 uid, bytes32 indexed schemaUID);\n\n    /// @notice Emitted when a data has been timestamped.\n    /// @param data The data.\n    /// @param timestamp The timestamp.\n    event Timestamped(bytes32 indexed data, uint64 indexed timestamp);\n\n    /// @notice Emitted when a data has been revoked.\n    /// @param revoker The address of the revoker.\n    /// @param data The data.\n    /// @param timestamp The timestamp.\n    event RevokedOffchain(address indexed revoker, bytes32 indexed data, uint64 indexed timestamp);\n\n    /// @notice Returns the address of the global schema registry.\n    /// @return The address of the global schema registry.\n    function getSchemaRegistry() external view returns (ISchemaRegistry);\n\n    /// @notice Attests to a specific schema.\n    /// @param request The arguments of the attestation request.\n    /// @return The UID of the new attestation.\n    ///\n    /// Example:\n    ///     attest({\n    ///         schema: \"0facc36681cbe2456019c1b0d1e7bedd6d1d40f6f324bf3dd3a4cef2999200a0\",\n    ///         data: {\n    ///             recipient: \"0xdEADBeAFdeAdbEafdeadbeafDeAdbEAFdeadbeaf\",\n    ///             expirationTime: 0,\n    ///             revocable: true,\n    ///             refUID: \"0x0000000000000000000000000000000000000000000000000000000000000000\",\n    ///             data: \"0xF00D\",\n    ///             value: 0\n    ///         }\n    ///     })\n    function attest(AttestationRequest calldata request) external payable returns (bytes32);\n\n    /// @notice Attests to a specific schema via the provided ECDSA signature.\n    /// @param delegatedRequest The arguments of the delegated attestation request.\n    /// @return The UID of the new attestation.\n    ///\n    /// Example:\n    ///     attestByDelegation({\n    ///         schema: '0x8e72f5bc0a8d4be6aa98360baa889040c50a0e51f32dbf0baa5199bd93472ebc',\n    ///         data: {\n    ///             recipient: '0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266',\n    ///             expirationTime: 1673891048,\n    ///             revocable: true,\n    ///             refUID: '0x0000000000000000000000000000000000000000000000000000000000000000',\n    ///             data: '0x1234',\n    ///             value: 0\n    ///         },\n    ///         signature: {\n    ///             v: 28,\n    ///             r: '0x148c...b25b',\n    ///             s: '0x5a72...be22'\n    ///         },\n    ///         attester: '0xc5E8740aD971409492b1A63Db8d83025e0Fc427e',\n    ///         deadline: 1673891048\n    ///     })\n    function attestByDelegation(\n        DelegatedAttestationRequest calldata delegatedRequest\n    ) external payable returns (bytes32);\n\n    /// @notice Attests to multiple schemas.\n    /// @param multiRequests The arguments of the multi attestation requests. The requests should be grouped by distinct\n    ///     schema ids to benefit from the best batching optimization.\n    /// @return The UIDs of the new attestations.\n    ///\n    /// Example:\n    ///     multiAttest([{\n    ///         schema: '0x33e9094830a5cba5554d1954310e4fbed2ef5f859ec1404619adea4207f391fd',\n    ///         data: [{\n    ///             recipient: '0xdEADBeAFdeAdbEafdeadbeafDeAdbEAFdeadbeaf',\n    ///             expirationTime: 1673891048,\n    ///             revocable: true,\n    ///             refUID: '0x0000000000000000000000000000000000000000000000000000000000000000',\n    ///             data: '0x1234',\n    ///             value: 1000\n    ///         },\n    ///         {\n    ///             recipient: '0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266',\n    ///             expirationTime: 0,\n    ///             revocable: false,\n    ///             refUID: '0x480df4a039efc31b11bfdf491b383ca138b6bde160988222a2a3509c02cee174',\n    ///             data: '0x00',\n    ///             value: 0\n    ///         }],\n    ///     },\n    ///     {\n    ///         schema: '0x5ac273ce41e3c8bfa383efe7c03e54c5f0bff29c9f11ef6ffa930fc84ca32425',\n    ///         data: [{\n    ///             recipient: '0xdEADBeAFdeAdbEafdeadbeafDeAdbEAFdeadbeaf',\n    ///             expirationTime: 0,\n    ///             revocable: true,\n    ///             refUID: '0x75bf2ed8dca25a8190c50c52db136664de25b2449535839008ccfdab469b214f',\n    ///             data: '0x12345678',\n    ///             value: 0\n    ///         },\n    ///     }])\n    function multiAttest(MultiAttestationRequest[] calldata multiRequests) external payable returns (bytes32[] memory);\n\n    /// @notice Attests to multiple schemas using via provided ECDSA signatures.\n    /// @param multiDelegatedRequests The arguments of the delegated multi attestation requests. The requests should be\n    ///     grouped by distinct schema ids to benefit from the best batching optimization.\n    /// @return The UIDs of the new attestations.\n    ///\n    /// Example:\n    ///     multiAttestByDelegation([{\n    ///         schema: '0x8e72f5bc0a8d4be6aa98360baa889040c50a0e51f32dbf0baa5199bd93472ebc',\n    ///         data: [{\n    ///             recipient: '0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266',\n    ///             expirationTime: 1673891048,\n    ///             revocable: true,\n    ///             refUID: '0x0000000000000000000000000000000000000000000000000000000000000000',\n    ///             data: '0x1234',\n    ///             value: 0\n    ///         },\n    ///         {\n    ///             recipient: '0xdEADBeAFdeAdbEafdeadbeafDeAdbEAFdeadbeaf',\n    ///             expirationTime: 0,\n    ///             revocable: false,\n    ///             refUID: '0x0000000000000000000000000000000000000000000000000000000000000000',\n    ///             data: '0x00',\n    ///             value: 0\n    ///         }],\n    ///         signatures: [{\n    ///             v: 28,\n    ///             r: '0x148c...b25b',\n    ///             s: '0x5a72...be22'\n    ///         },\n    ///         {\n    ///             v: 28,\n    ///             r: '0x487s...67bb',\n    ///             s: '0x12ad...2366'\n    ///         }],\n    ///         attester: '0x1D86495b2A7B524D747d2839b3C645Bed32e8CF4',\n    ///         deadline: 1673891048\n    ///     }])\n    function multiAttestByDelegation(\n        MultiDelegatedAttestationRequest[] calldata multiDelegatedRequests\n    ) external payable returns (bytes32[] memory);\n\n    /// @notice Revokes an existing attestation to a specific schema.\n    /// @param request The arguments of the revocation request.\n    ///\n    /// Example:\n    ///     revoke({\n    ///         schema: '0x8e72f5bc0a8d4be6aa98360baa889040c50a0e51f32dbf0baa5199bd93472ebc',\n    ///         data: {\n    ///             uid: '0x101032e487642ee04ee17049f99a70590c735b8614079fc9275f9dd57c00966d',\n    ///             value: 0\n    ///         }\n    ///     })\n    function revoke(RevocationRequest calldata request) external payable;\n\n    /// @notice Revokes an existing attestation to a specific schema via the provided ECDSA signature.\n    /// @param delegatedRequest The arguments of the delegated revocation request.\n    ///\n    /// Example:\n    ///     revokeByDelegation({\n    ///         schema: '0x8e72f5bc0a8d4be6aa98360baa889040c50a0e51f32dbf0baa5199bd93472ebc',\n    ///         data: {\n    ///             uid: '0xcbbc12102578c642a0f7b34fe7111e41afa25683b6cd7b5a14caf90fa14d24ba',\n    ///             value: 0\n    ///         },\n    ///         signature: {\n    ///             v: 27,\n    ///             r: '0xb593...7142',\n    ///             s: '0x0f5b...2cce'\n    ///         },\n    ///         revoker: '0x244934dd3e31bE2c81f84ECf0b3E6329F5381992',\n    ///         deadline: 1673891048\n    ///     })\n    function revokeByDelegation(DelegatedRevocationRequest calldata delegatedRequest) external payable;\n\n    /// @notice Revokes existing attestations to multiple schemas.\n    /// @param multiRequests The arguments of the multi revocation requests. The requests should be grouped by distinct\n    ///     schema ids to benefit from the best batching optimization.\n    ///\n    /// Example:\n    ///     multiRevoke([{\n    ///         schema: '0x8e72f5bc0a8d4be6aa98360baa889040c50a0e51f32dbf0baa5199bd93472ebc',\n    ///         data: [{\n    ///             uid: '0x211296a1ca0d7f9f2cfebf0daaa575bea9b20e968d81aef4e743d699c6ac4b25',\n    ///             value: 1000\n    ///         },\n    ///         {\n    ///             uid: '0xe160ac1bd3606a287b4d53d5d1d6da5895f65b4b4bab6d93aaf5046e48167ade',\n    ///             value: 0\n    ///         }],\n    ///     },\n    ///     {\n    ///         schema: '0x5ac273ce41e3c8bfa383efe7c03e54c5f0bff29c9f11ef6ffa930fc84ca32425',\n    ///         data: [{\n    ///             uid: '0x053d42abce1fd7c8fcddfae21845ad34dae287b2c326220b03ba241bc5a8f019',\n    ///             value: 0\n    ///         },\n    ///     }])\n    function multiRevoke(MultiRevocationRequest[] calldata multiRequests) external payable;\n\n    /// @notice Revokes existing attestations to multiple schemas via provided ECDSA signatures.\n    /// @param multiDelegatedRequests The arguments of the delegated multi revocation attestation requests. The requests\n    ///     should be grouped by distinct schema ids to benefit from the best batching optimization.\n    ///\n    /// Example:\n    ///     multiRevokeByDelegation([{\n    ///         schema: '0x8e72f5bc0a8d4be6aa98360baa889040c50a0e51f32dbf0baa5199bd93472ebc',\n    ///         data: [{\n    ///             uid: '0x211296a1ca0d7f9f2cfebf0daaa575bea9b20e968d81aef4e743d699c6ac4b25',\n    ///             value: 1000\n    ///         },\n    ///         {\n    ///             uid: '0xe160ac1bd3606a287b4d53d5d1d6da5895f65b4b4bab6d93aaf5046e48167ade',\n    ///             value: 0\n    ///         }],\n    ///         signatures: [{\n    ///             v: 28,\n    ///             r: '0x148c...b25b',\n    ///             s: '0x5a72...be22'\n    ///         },\n    ///         {\n    ///             v: 28,\n    ///             r: '0x487s...67bb',\n    ///             s: '0x12ad...2366'\n    ///         }],\n    ///         revoker: '0x244934dd3e31bE2c81f84ECf0b3E6329F5381992',\n    ///         deadline: 1673891048\n    ///     }])\n    function multiRevokeByDelegation(\n        MultiDelegatedRevocationRequest[] calldata multiDelegatedRequests\n    ) external payable;\n\n    /// @notice Timestamps the specified bytes32 data.\n    /// @param data The data to timestamp.\n    /// @return The timestamp the data was timestamped with.\n    function timestamp(bytes32 data) external returns (uint64);\n\n    /// @notice Timestamps the specified multiple bytes32 data.\n    /// @param data The data to timestamp.\n    /// @return The timestamp the data was timestamped with.\n    function multiTimestamp(bytes32[] calldata data) external returns (uint64);\n\n    /// @notice Revokes the specified bytes32 data.\n    /// @param data The data to timestamp.\n    /// @return The timestamp the data was revoked with.\n    function revokeOffchain(bytes32 data) external returns (uint64);\n\n    /// @notice Revokes the specified multiple bytes32 data.\n    /// @param data The data to timestamp.\n    /// @return The timestamp the data was revoked with.\n    function multiRevokeOffchain(bytes32[] calldata data) external returns (uint64);\n\n    /// @notice Returns an existing attestation by UID.\n    /// @param uid The UID of the attestation to retrieve.\n    /// @return The attestation data members.\n    function getAttestation(bytes32 uid) external view returns (Attestation memory);\n\n    /// @notice Checks whether an attestation exists.\n    /// @param uid The UID of the attestation to retrieve.\n    /// @return Whether an attestation exists.\n    function isAttestationValid(bytes32 uid) external view returns (bool);\n\n    /// @notice Returns the timestamp that the specified data was timestamped with.\n    /// @param data The data to query.\n    /// @return The timestamp the data was timestamped with.\n    function getTimestamp(bytes32 data) external view returns (uint64);\n\n    /// @notice Returns the timestamp that the specified data was timestamped with.\n    /// @param data The data to query.\n    /// @return The timestamp the data was timestamped with.\n    function getRevokeOffchain(address revoker, bytes32 data) external view returns (uint64);\n}\n"
    },
    "lib/risc0-ethereum/contracts/src/IRiscZeroVerifier.sol": {
      "content": "// Copyright 2024 RISC Zero, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n\npragma solidity ^0.8.9;\n\nimport {reverseByteOrderUint32} from \"./Util.sol\";\n\n/// @notice A receipt attesting to the execution of a guest program.\n/// @dev A receipt contains two parts: a seal and a claim. The seal is a zero-knowledge proof\n/// attesting to knowledge of a zkVM execution resulting in the claim. The claim is a set of public\n/// outputs for the execution. Crucially, the claim includes the journal and the image ID. The\n/// image ID identifies the program that was executed, and the journal is the public data written\n/// by the program. Note that this struct only contains the claim digest, as can be obtained with\n/// the `digest()` function on `ReceiptClaimLib`.\nstruct Receipt {\n    bytes seal;\n    bytes32 claimDigest;\n}\n\n/// @notice Public claims about a zkVM guest execution, such as the journal committed to by the guest.\n/// @dev Also includes important information such as the exit code and the starting and ending system\n/// state (i.e. the state of memory). `ReceiptClaim` is a \"Merkle-ized struct\" supporting\n/// partial openings of the underlying fields from a hash commitment to the full structure.\nstruct ReceiptClaim {\n    /// @notice Digest of the SystemState just before execution has begun.\n    bytes32 preStateDigest;\n    /// @notice Digest of the SystemState just after execution has completed.\n    bytes32 postStateDigest;\n    /// @notice The exit code for the execution.\n    ExitCode exitCode;\n    /// @notice A digest of the input to the guest.\n    /// @dev This field is currently unused and must be set to the zero digest.\n    bytes32 input;\n    /// @notice Digest of the Output of the guest, including the journal\n    /// and assumptions set during execution.\n    bytes32 output;\n}\n\nlibrary ReceiptClaimLib {\n    using OutputLib for Output;\n    using SystemStateLib for SystemState;\n\n    bytes32 constant TAG_DIGEST = sha256(\"risc0.ReceiptClaim\");\n\n    // Define a constant to ensure hashing is done at compile time. Can't use the\n    // SystemStateLib.digest method here because the Solidity compiler complains.\n    bytes32 constant SYSTEM_STATE_ZERO_DIGEST = 0xa3acc27117418996340b84e5a90f3ef4c49d22c79e44aad822ec9c313e1eb8e2;\n\n    /// @notice Construct a ReceiptClaim from the given imageId and journalDigest.\n    ///         Returned ReceiptClaim will represent a successful execution of the zkVM, running\n    ///         the program committed by imageId and resulting in the journal specified by\n    ///         journalDigest.\n    /// @param imageId The identifier for the guest program.\n    /// @param journalDigest The SHA-256 digest of the journal bytes.\n    /// @dev Input hash and postStateDigest are set to all-zeros (i.e. no committed input, or\n    ///      final memory state), the exit code is (Halted, 0), and there are no assumptions\n    ///      (i.e. the receipt is unconditional).\n    function ok(bytes32 imageId, bytes32 journalDigest) internal pure returns (ReceiptClaim memory) {\n        return ReceiptClaim(\n            imageId,\n            SYSTEM_STATE_ZERO_DIGEST,\n            ExitCode(SystemExitCode.Halted, 0),\n            bytes32(0),\n            Output(journalDigest, bytes32(0)).digest()\n        );\n    }\n\n    function digest(ReceiptClaim memory claim) internal pure returns (bytes32) {\n        return sha256(\n            abi.encodePacked(\n                TAG_DIGEST,\n                // down\n                claim.input,\n                claim.preStateDigest,\n                claim.postStateDigest,\n                claim.output,\n                // data\n                uint32(claim.exitCode.system) << 24,\n                uint32(claim.exitCode.user) << 24,\n                // down.length\n                uint16(4) << 8\n            )\n        );\n    }\n}\n\n/// @notice Commitment to the memory state and program counter (pc) of the zkVM.\n/// @dev The \"pre\" and \"post\" fields of the ReceiptClaim are digests of the system state at the\n///      start are stop of execution. Programs are loaded into the zkVM by creating a memory image\n///      of the loaded program, and creating a system state for initializing the zkVM. This is\n///      known as the \"image ID\".\nstruct SystemState {\n    /// @notice Program counter.\n    uint32 pc;\n    /// @notice Root hash of a merkle tree which confirms the integrity of the memory image.\n    bytes32 merkle_root;\n}\n\nlibrary SystemStateLib {\n    bytes32 constant TAG_DIGEST = sha256(\"risc0.SystemState\");\n\n    function digest(SystemState memory state) internal pure returns (bytes32) {\n        return sha256(\n            abi.encodePacked(\n                TAG_DIGEST,\n                // down\n                state.merkle_root,\n                // data\n                reverseByteOrderUint32(state.pc),\n                // down.length\n                uint16(1) << 8\n            )\n        );\n    }\n}\n\n/// @notice Exit condition indicated by the zkVM at the end of the guest execution.\n/// @dev Exit codes have a \"system\" part and a \"user\" part. Semantically, the system part is set to\n/// indicate the type of exit (e.g. halt, pause, or system split) and is directly controlled by the\n/// zkVM. The user part is an exit code, similar to exit codes used in Linux, chosen by the guest\n/// program to indicate additional information (e.g. 0 to indicate success or 1 to indicate an\n/// error).\nstruct ExitCode {\n    SystemExitCode system;\n    uint8 user;\n}\n\n/// @notice Exit condition indicated by the zkVM at the end of the execution covered by this proof.\n/// @dev\n/// `Halted` indicates normal termination of a program with an interior exit code returned from the\n/// guest program. A halted program cannot be resumed.\n///\n/// `Paused` indicates the execution ended in a paused state with an interior exit code set by the\n/// guest program. A paused program can be resumed such that execution picks up where it left\n/// of, with the same memory state.\n///\n/// `SystemSplit` indicates the execution ended on a host-initiated system split. System split is\n/// mechanism by which the host can temporarily stop execution of the execution ended in a system\n/// split has no output and no conclusions can be drawn about whether the program will eventually\n/// halt. System split is used in continuations to split execution into individually provable segments.\nenum SystemExitCode {\n    Halted,\n    Paused,\n    SystemSplit\n}\n\n/// @notice Output field in the `ReceiptClaim`, committing to a claimed journal and assumptions list.\nstruct Output {\n    /// @notice Digest of the journal committed to by the guest execution.\n    bytes32 journalDigest;\n    /// @notice Digest of the ordered list of `ReceiptClaim` digests corresponding to the\n    /// calls to `env::verify` and `env::verify_integrity`.\n    /// @dev Verifying the integrity of a `Receipt` corresponding to a `ReceiptClaim` with a\n    /// non-empty assumptions list does not guarantee unconditionally any of the claims over the\n    /// guest execution (i.e. if the assumptions list is non-empty, then the journal digest cannot\n    /// be trusted to correspond to a genuine execution). The claims can be checked by additional\n    /// verifying a `Receipt` for every digest in the assumptions list.\n    bytes32 assumptionsDigest;\n}\n\nlibrary OutputLib {\n    bytes32 constant TAG_DIGEST = sha256(\"risc0.Output\");\n\n    function digest(Output memory output) internal pure returns (bytes32) {\n        return sha256(\n            abi.encodePacked(\n                TAG_DIGEST,\n                // down\n                output.journalDigest,\n                output.assumptionsDigest,\n                // down.length\n                uint16(2) << 8\n            )\n        );\n    }\n}\n\n/// @notice Error raised when cryptographic verification of the zero-knowledge proof fails.\nerror VerificationFailed();\n\n/// @notice Verifier interface for RISC Zero receipts of execution.\ninterface IRiscZeroVerifier {\n    /// @notice Verify that the given seal is a valid RISC Zero proof of execution with the\n    ///     given image ID and journal digest. Reverts on failure.\n    /// @dev This method additionally ensures that the input hash is all-zeros (i.e. no\n    /// committed input), the exit code is (Halted, 0), and there are no assumptions (i.e. the\n    /// receipt is unconditional).\n    /// @param seal The encoded cryptographic proof (i.e. SNARK).\n    /// @param imageId The identifier for the guest program.\n    /// @param journalDigest The SHA-256 digest of the journal bytes.\n    function verify(bytes calldata seal, bytes32 imageId, bytes32 journalDigest) external view;\n\n    /// @notice Verify that the given receipt is a valid RISC Zero receipt, ensuring the `seal` is\n    /// valid a cryptographic proof of the execution with the given `claim`. Reverts on failure.\n    /// @param receipt The receipt to be verified.\n    function verifyIntegrity(Receipt calldata receipt) external view;\n}\n"
    },
    "src/interfaces/IUserRegistry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title IUserRegistry\n * @author Libre\n * @notice Interface for managing user wallets and their association with investor/dealer IDs.\n * @dev Provides functions for adding wallets, retrieving wallets, and mapping wallets to user IDs.\n */\ninterface IUserRegistry {\n    /**\n     * @notice Thrown when the wallet address being added is already associated with another user ID.\n     */\n    error IUserRegistry_WalletAlreadyClaimed();\n\n    /**\n     * @notice Thrown when the provided signature fails to verify ownership of the wallet address.\n     */\n    error IUserRegistry_WalletOwnershipVerificationFailure();\n\n    /**\n     * @notice Thrown when the provided wallet signature has expired.\n     */\n    error IUserRegistry_WalletSignatureExpired();\n\n    /**\n     * @notice Thrown when the provided wallet address to add is blacklisted.\n     */\n    error IUserRegistry_WalletBlacklisted();\n\n    /**\n     * @notice Emited when secondary wallet is removed\n     * @param wallet User wallet address\n     */\n    event WalletAdded(address indexed wallet);\n\n    /**\n     * @notice Emited when secondary wallet is removed\n     * @param wallet User wallet address\n     */\n    event WalletRemoved(address indexed wallet);\n\n    /**\n     * @notice Adds a new investor to the registry\n     * @param _userId The ID of the user.\n     * @param _wallet The wallet address to associate with the user ID.\n     * @param _role The role used by the caller.\n     */\n    function addWallet(bytes32 _userId, address _wallet, bytes32 _role) external;\n\n    /**\n     * @notice Removes a wallet from the registry\n     * @param _wallet The wallet address to remove.\n     * @param _role The role used by the caller.\n     * @return The user ID that the wallet was removed from\n     */\n    function removeWallet(address _wallet, bytes32 _role) external returns (bytes32);\n\n    /**\n     * @notice Get Investor/Dealer array of wallets\n     * @param _userId Investor/Dealer ID\n     */\n    function getWallets(bytes32 _userId) external view returns (address[] memory);\n\n    /**\n     * @notice Get Investor/Dealer ID\n     * @param _wallet Investor/Dealer address\n     */\n    function getIdFromWallet(address _wallet) external view returns (bytes32);\n}\n"
    },
    "src/interfaces/IGatewayManager.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {IInvestorRegistry} from \"src/interfaces/IInvestorRegistry.sol\";\nimport {IRoleRegistry} from \"src/interfaces/IRoleRegistry.sol\";\nimport {ILibreCoreGateway} from \"src/interfaces/ILibreCoreGateway.sol\";\nimport {IEAS} from \"eas-contracts/IEAS.sol\";\n\n/**\n * @title IGatewayManager Interface\n * @notice Interface for managing cross-chain addresses and investor chain preferences\n * @dev Coordinates with LibreCoreGateway for cross-chain operations\n */\ninterface IGatewayManager {\n    /**\n     * @notice Emitted when an investor's preferred chains are updated or set\n     * @param investorId The unique identifier of the investor\n     * @param chains Array of custom chain IDs that the investor prefers\n     * @param oldChains Previous array of chain IDs for the investor\n     */\n    event InvestorChainsUpdated(bytes32 investorId, uint16[] chains, uint16[] oldChains);\n\n    /**\n     * @notice Emitted when cross-chain addresses are updated for an investor\n     * @dev Each address change is encoded as: [1 byte action][2 bytes chainSelector][n bytes address]\n     * @param investorId The unique identifier of the investor\n     * @param addressChanges A list of concatenated bytes describing a change in multi-chain address\n     */\n    event InvestorAddressesUpdated(bytes32 investorId, bytes[] addressChanges);\n\n    /// @notice Thrown when an unsupported or invalid chain ID is provided\n    error GatewayManager_InvalidChain();\n\n    /// @notice Thrown when the investor ID doesn't exist or is invalid\n    error GatewayManager_InvalidInvestor();\n\n    /// @notice Thrown when input parameters are invalid or missing\n    error GatewayManager_InvalidInput();\n\n    /// @notice Thrown when a cross-chain address is already associated with another investor\n    error GatewayManager_AddressAlreadyUsed();\n\n    /**\n     * @notice Initializes the gateway manager\n     * @param _coreGateway Address of the LibreCoreGateway contract\n     * @param _eas Address of the Ethereum Attestation Service\n     * @param _investorRegistry Address of the InvestorRegistry contract\n     * @param _roleRegistry Address of the RoleRegistry contract\n     */\n    function initialize(\n        ILibreCoreGateway _coreGateway,\n        IEAS _eas,\n        IInvestorRegistry _investorRegistry,\n        IRoleRegistry _roleRegistry\n    ) external;\n\n    /**\n     * @notice Sets the preferred chains for an investor\n     * @param _senderRole Role of the transaction sender\n     * @param _investorId Unique identifier of the investor\n     * @param _chains Array of chain IDs to set as preferred\n     */\n    function setInvestorChains(bytes32 _senderRole, bytes32 _investorId, uint16[] calldata _chains) external;\n\n    /**\n     * @notice Updates investor's cross-chain addresses and propagates changes to other chains\n     * @dev Adds or removes addresses and bridges the updates to other chains\n     * @param _senderRole Role of the transaction sender\n     * @param _investorId Unique identifier of the investor\n     * @param _addressChanges A list of concatenated bytes describing a change in multi-chain address\n     */\n    function manageCrossChainAddresses(bytes32 _senderRole, bytes32 _investorId, bytes[] calldata _addressChanges)\n        external;\n\n    /**\n     * @notice Bridges a credential to all investor's preferred chains via core gateway.\n     * @param _attestationId The unique ID of the attestation to be bridged.\n     * @param _senderRole Role of the transaction sender.\n     * @param _chains Chains to bridge credential to (all investor chains if empty)\n     */\n    function bridgeCredential(bytes32 _attestationId, bytes32 _senderRole, uint16[] memory _chains) external;\n\n    /**\n     * @notice Validates if an address is a valid cross-chain address for an investor\n     * @param _investorId The investor ID to check\n     * @param _chainSelector The chain ID to check\n     * @param _address The address to validate\n     * @return bool True if the address is valid for the investor on the chain\n     */\n    function isValidCrossChainAddress(bytes32 _investorId, uint16 _chainSelector, bytes calldata _address)\n        external\n        view\n        returns (bool);\n\n    /**\n     * @notice Gets an investor's preferred chains\n     * @param _investorId The investor's unique identifier\n     * @return uint16[] Array of preferred chain IDs\n     */\n    function getInvestorChains(bytes32 _investorId) external view returns (uint16[] memory);\n\n    /**\n     * @notice Gets the owner of a cross-chain address\n     * @param _chainSelector The chain ID of the address\n     * @param _address The address to get the owner of\n     * @return bytes32 The owner of the address\n     */\n    function getAddressOwner(uint16 _chainSelector, bytes calldata _address) external view returns (bytes32);\n}\n"
    },
    "src/utils/Types.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {Steel} from \"risc0/steel/Steel.sol\";\n\nstruct SteelProofData {\n    //Block hash commitment for Steel\n    Steel.Commitment commitment;\n    //Seal for Steel\n    bytes seal;\n}\n\nstruct CredentialProofData {\n    //Journal Data for Steel\n    CredentialJournal journal;\n    //Seal for Steel\n    bytes seal;\n}\n\n// @notice Journal that is committed to for Credentials\nstruct CredentialJournal {\n    //Block hash commitment for Steel\n    Steel.Commitment commitment;\n    //Id of the investor\n    bytes32 investorId;\n    //Credential expiry timestamp\n    uint64 expiryTimestamp;\n    //Ids of instruments the investor is registered for\n    bytes32[] instrumentIds;\n    //Access expiry timestamps for instruments the investor is registered for\n    uint64[] instrumentExpiryTimestamps;\n    address policyViewer;\n}\n\nstruct OrderProofData {\n    //Journal Data for Steel\n    OrderJournal journal;\n    //Seal for Steel\n    bytes seal;\n}\n\n// @notice Journal that is committed to for Orders\nstruct OrderJournal {\n    //Block hash commitment for Steel\n    Steel.Commitment commitment;\n    //Id of the investor\n    bytes32 investorId;\n    //Id of the instrument the investor is subscribing or redeeming to\n    bytes32 instrumentId;\n    //Amount the investor is subscribing or redeeming with\n    uint256 amount;\n    address policyViewer;\n}\n"
    },
    "src/utils/JurisdictionEncodings.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n//The encodings used for jurisdictions are based and ordered after the ISO 3166 standard as of 2023/11/28\n//(https://en.wikipedia.org/wiki/List_of_ISO_3166_country_codes)\n//Any new additions after this date will be added at the end as to not modify existing encodings\n//allowed values are in the range of: 2^x, 0  x  255\nuint256 constant AF = 2 ** 0;\nuint256 constant AX = 2 ** 1;\nuint256 constant AL = 2 ** 2;\nuint256 constant DZ = 2 ** 3;\nuint256 constant AS = 2 ** 4;\nuint256 constant AD = 2 ** 5;\nuint256 constant AO = 2 ** 6;\nuint256 constant AI = 2 ** 7;\nuint256 constant AQ = 2 ** 8;\nuint256 constant AG = 2 ** 9;\nuint256 constant AR = 2 ** 10;\nuint256 constant AM = 2 ** 11;\nuint256 constant AW = 2 ** 12;\nuint256 constant AU = 2 ** 13;\nuint256 constant AT = 2 ** 14;\nuint256 constant AZ = 2 ** 15;\nuint256 constant BS = 2 ** 16;\nuint256 constant BH = 2 ** 17;\nuint256 constant BD = 2 ** 18;\nuint256 constant BB = 2 ** 19;\nuint256 constant BY = 2 ** 20;\nuint256 constant BE = 2 ** 21;\nuint256 constant BZ = 2 ** 22;\nuint256 constant BJ = 2 ** 23;\nuint256 constant BM = 2 ** 24;\nuint256 constant BT = 2 ** 25;\nuint256 constant BO = 2 ** 26;\nuint256 constant BQ = 2 ** 27;\nuint256 constant BA = 2 ** 28;\nuint256 constant BW = 2 ** 29;\nuint256 constant BV = 2 ** 30;\nuint256 constant BR = 2 ** 31;\nuint256 constant IO = 2 ** 32;\nuint256 constant BN = 2 ** 33;\nuint256 constant BG = 2 ** 34;\nuint256 constant BF = 2 ** 35;\nuint256 constant BI = 2 ** 36;\nuint256 constant CV = 2 ** 37;\nuint256 constant KH = 2 ** 38;\nuint256 constant CM = 2 ** 39;\nuint256 constant CA = 2 ** 40;\nuint256 constant KY = 2 ** 41;\nuint256 constant CF = 2 ** 42;\nuint256 constant TD = 2 ** 43;\nuint256 constant CL = 2 ** 44;\nuint256 constant CN = 2 ** 45;\nuint256 constant CX = 2 ** 46;\nuint256 constant CC = 2 ** 47;\nuint256 constant CO = 2 ** 48;\nuint256 constant KM = 2 ** 49;\nuint256 constant CD = 2 ** 50;\nuint256 constant CG = 2 ** 51;\nuint256 constant CK = 2 ** 52;\nuint256 constant CR = 2 ** 53;\nuint256 constant CI = 2 ** 54;\nuint256 constant HR = 2 ** 55;\nuint256 constant CU = 2 ** 56;\nuint256 constant CW = 2 ** 57;\nuint256 constant CY = 2 ** 58;\nuint256 constant CZ = 2 ** 59;\nuint256 constant DK = 2 ** 60;\nuint256 constant DJ = 2 ** 61;\nuint256 constant DM = 2 ** 62;\nuint256 constant DO = 2 ** 63;\nuint256 constant EC = 2 ** 64;\nuint256 constant EG = 2 ** 65;\nuint256 constant SV = 2 ** 66;\nuint256 constant GQ = 2 ** 67;\nuint256 constant ER = 2 ** 68;\nuint256 constant EE = 2 ** 69;\nuint256 constant SZ = 2 ** 70;\nuint256 constant ET = 2 ** 71;\nuint256 constant FK = 2 ** 72;\nuint256 constant FO = 2 ** 73;\nuint256 constant FJ = 2 ** 74;\nuint256 constant FI = 2 ** 75;\nuint256 constant FR = 2 ** 76;\nuint256 constant GF = 2 ** 77;\nuint256 constant PF = 2 ** 78;\nuint256 constant TF = 2 ** 79;\nuint256 constant GA = 2 ** 80;\nuint256 constant GM = 2 ** 81;\nuint256 constant GE = 2 ** 82;\nuint256 constant DE = 2 ** 83;\nuint256 constant GH = 2 ** 84;\nuint256 constant GI = 2 ** 85;\nuint256 constant GR = 2 ** 86;\nuint256 constant GL = 2 ** 87;\nuint256 constant GD = 2 ** 88;\nuint256 constant GP = 2 ** 89;\nuint256 constant GU = 2 ** 90;\nuint256 constant GT = 2 ** 91;\nuint256 constant GG = 2 ** 92;\nuint256 constant GN = 2 ** 93;\nuint256 constant GW = 2 ** 94;\nuint256 constant GY = 2 ** 95;\nuint256 constant HT = 2 ** 96;\nuint256 constant HM = 2 ** 97;\nuint256 constant VA = 2 ** 98;\nuint256 constant HN = 2 ** 99;\nuint256 constant HK = 2 ** 100;\nuint256 constant HU = 2 ** 101;\nuint256 constant IS = 2 ** 102;\nuint256 constant IN = 2 ** 103;\nuint256 constant ID = 2 ** 104;\nuint256 constant IR = 2 ** 105;\nuint256 constant IQ = 2 ** 106;\nuint256 constant IE = 2 ** 107;\nuint256 constant IM = 2 ** 108;\nuint256 constant IL = 2 ** 109;\nuint256 constant IT = 2 ** 110;\nuint256 constant JM = 2 ** 111;\nuint256 constant JP = 2 ** 112;\nuint256 constant JE = 2 ** 113;\nuint256 constant JO = 2 ** 114;\nuint256 constant KZ = 2 ** 115;\nuint256 constant KE = 2 ** 116;\nuint256 constant KI = 2 ** 117;\nuint256 constant KP = 2 ** 118;\nuint256 constant KR = 2 ** 119;\nuint256 constant KW = 2 ** 120;\nuint256 constant KG = 2 ** 121;\nuint256 constant LA = 2 ** 122;\nuint256 constant LV = 2 ** 123;\nuint256 constant LB = 2 ** 124;\nuint256 constant LS = 2 ** 125;\nuint256 constant LR = 2 ** 126;\nuint256 constant LY = 2 ** 127;\nuint256 constant LI = 2 ** 128;\nuint256 constant LT = 2 ** 129;\nuint256 constant LU = 2 ** 130;\nuint256 constant MO = 2 ** 131;\nuint256 constant MK = 2 ** 132;\nuint256 constant MG = 2 ** 133;\nuint256 constant MW = 2 ** 134;\nuint256 constant MY = 2 ** 135;\nuint256 constant MV = 2 ** 136;\nuint256 constant ML = 2 ** 137;\nuint256 constant MT = 2 ** 138;\nuint256 constant MH = 2 ** 139;\nuint256 constant MQ = 2 ** 140;\nuint256 constant MR = 2 ** 141;\nuint256 constant MU = 2 ** 142;\nuint256 constant YT = 2 ** 143;\nuint256 constant MX = 2 ** 144;\nuint256 constant FM = 2 ** 145;\nuint256 constant MD = 2 ** 146;\nuint256 constant MC = 2 ** 147;\nuint256 constant MN = 2 ** 148;\nuint256 constant ME = 2 ** 149;\nuint256 constant MS = 2 ** 150;\nuint256 constant MA = 2 ** 151;\nuint256 constant MZ = 2 ** 152;\nuint256 constant MM = 2 ** 153;\nuint256 constant NA = 2 ** 154;\nuint256 constant NR = 2 ** 155;\nuint256 constant NP = 2 ** 156;\nuint256 constant NL = 2 ** 157;\nuint256 constant NC = 2 ** 158;\nuint256 constant NZ = 2 ** 159;\nuint256 constant NI = 2 ** 160;\nuint256 constant NE = 2 ** 161;\nuint256 constant NG = 2 ** 162;\nuint256 constant NU = 2 ** 163;\nuint256 constant NF = 2 ** 164;\nuint256 constant MP = 2 ** 165;\nuint256 constant NO = 2 ** 166;\nuint256 constant OM = 2 ** 167;\nuint256 constant PK = 2 ** 168;\nuint256 constant PW = 2 ** 169;\nuint256 constant PS = 2 ** 170;\nuint256 constant PA = 2 ** 171;\nuint256 constant PG = 2 ** 172;\nuint256 constant PY = 2 ** 173;\nuint256 constant PE = 2 ** 174;\nuint256 constant PH = 2 ** 175;\nuint256 constant PN = 2 ** 176;\nuint256 constant PL = 2 ** 177;\nuint256 constant PT = 2 ** 178;\nuint256 constant PR = 2 ** 179;\nuint256 constant QA = 2 ** 180;\nuint256 constant RE = 2 ** 181;\nuint256 constant RO = 2 ** 182;\nuint256 constant RU = 2 ** 183;\nuint256 constant RW = 2 ** 184;\nuint256 constant BL = 2 ** 185;\nuint256 constant SH = 2 ** 186;\nuint256 constant KN = 2 ** 187;\nuint256 constant LC = 2 ** 188;\nuint256 constant MF = 2 ** 189;\nuint256 constant PM = 2 ** 190;\nuint256 constant VC = 2 ** 191;\nuint256 constant WS = 2 ** 192;\nuint256 constant SM = 2 ** 193;\nuint256 constant ST = 2 ** 194;\nuint256 constant SA = 2 ** 195;\nuint256 constant SN = 2 ** 196;\nuint256 constant RS = 2 ** 197;\nuint256 constant SC = 2 ** 198;\nuint256 constant SL = 2 ** 199;\nuint256 constant SG = 2 ** 200;\nuint256 constant SX = 2 ** 201;\nuint256 constant SK = 2 ** 202;\nuint256 constant SI = 2 ** 203;\nuint256 constant SB = 2 ** 204;\nuint256 constant SO = 2 ** 205;\nuint256 constant ZA = 2 ** 206;\nuint256 constant GS = 2 ** 207;\nuint256 constant SS = 2 ** 208;\nuint256 constant ES = 2 ** 209;\nuint256 constant LK = 2 ** 210;\nuint256 constant SD = 2 ** 211;\nuint256 constant SR = 2 ** 212;\nuint256 constant SJ = 2 ** 213;\nuint256 constant SE = 2 ** 214;\nuint256 constant CH = 2 ** 215;\nuint256 constant SY = 2 ** 216;\nuint256 constant TW = 2 ** 217;\nuint256 constant TJ = 2 ** 218;\nuint256 constant TZ = 2 ** 219;\nuint256 constant TH = 2 ** 220;\nuint256 constant TL = 2 ** 221;\nuint256 constant TG = 2 ** 222;\nuint256 constant TK = 2 ** 223;\nuint256 constant TO = 2 ** 224;\nuint256 constant TT = 2 ** 225;\nuint256 constant TN = 2 ** 226;\nuint256 constant TR = 2 ** 227;\nuint256 constant TM = 2 ** 228;\nuint256 constant TC = 2 ** 229;\nuint256 constant TV = 2 ** 230;\nuint256 constant UG = 2 ** 231;\nuint256 constant UA = 2 ** 232;\nuint256 constant AE = 2 ** 233;\nuint256 constant GB = 2 ** 234;\nuint256 constant UM = 2 ** 235;\nuint256 constant US = 2 ** 236;\nuint256 constant UY = 2 ** 237;\nuint256 constant UZ = 2 ** 238;\nuint256 constant VU = 2 ** 239;\nuint256 constant VE = 2 ** 240;\nuint256 constant VN = 2 ** 241;\nuint256 constant VG = 2 ** 242;\nuint256 constant VI = 2 ** 243;\nuint256 constant WF = 2 ** 244;\nuint256 constant EH = 2 ** 245;\nuint256 constant YE = 2 ** 246;\nuint256 constant ZM = 2 ** 247;\nuint256 constant ZW = 2 ** 248;\n//values 249-255 reserved for future additions\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.19;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "lib/openzeppelin-contracts-upgradeable/contracts/access/IAccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.19;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControlUpgradeable {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n"
    },
    "src/interfaces/operations/IOperationModule.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {IInvestorRegistry} from \"src/interfaces/IInvestorRegistry.sol\";\nimport {IFundRegistry} from \"src/interfaces/IFundRegistry.sol\";\nimport {IDealerRegistry} from \"src/interfaces/IDealerRegistry.sol\";\nimport {IInstrumentRegistry} from \"src/interfaces/IInstrumentRegistry.sol\";\nimport {IEternalRegistryStorage} from \"src/interfaces/IEternalRegistryStorage.sol\";\nimport {IRoleRegistry} from \"src/interfaces/IRoleRegistry.sol\";\n\nenum OPERATIONS {\n    // Transfer specific operations:\n    TRANSFER,\n    FORCED_TRANSFER,\n    RECEIVE,\n    SEND,\n    CLAWBACK,\n    // Subscription specific operations:\n    ADVISED_CREATE_SUBSCRIPTION,\n    CREATE_SUBSCRIPTION,\n    SUBSCRIPTION_EXECUTION_DATE_CALCULATION,\n    SETTLE_SUBSCRIPTIONS,\n    SETTLE_SUBSCRIPTION_PER_ORDER,\n    SUBSCRIPTION_CANCELLATION,\n    // Redemption specific operations:\n    ADVISED_CREATE_REDEMPTION,\n    CREATE_REDEMPTION,\n    REDEMPTION_EXECUTION_DATE_CALCULATION,\n    REDEMPTION_CANCELLATION,\n    SETTLE_REDEMPTIONS,\n    SETTLE_REDEMPTION_PER_ORDER,\n    FORCED_REDEMPTION,\n    REDEMPTION_FEE,\n    // Secondary Market specific operations:\n    FILL,\n    ORDER,\n    TRADE,\n    // NAV operations:\n    UPDATE_AUDITED_NAV_PER_SHARE\n}\n\ninterface IOperationModule {\n    /**\n     * @return The list of operations associated with a module\n     * @dev It should contains all the Operation ids of all\n     * the IOperations it implements\n     */\n    function getOperations() external pure returns (OPERATIONS[] memory);\n\n    /**\n     * @return Returns the name of the module\n     */\n    function name() external pure returns (string memory);\n\n    /**\n     * @return Returns the hash of the module name\n     */\n    function nameHash() external pure returns (bytes32);\n}\n"
    },
    "lib/openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.19;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "lib/eas-contracts/contracts/ISchemaRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { ISemver } from \"./ISemver.sol\";\n\nimport { ISchemaResolver } from \"./resolver/ISchemaResolver.sol\";\n\n/// @notice A struct representing a record for a submitted schema.\nstruct SchemaRecord {\n    bytes32 uid; // The unique identifier of the schema.\n    ISchemaResolver resolver; // Optional schema resolver.\n    bool revocable; // Whether the schema allows revocations explicitly.\n    string schema; // Custom specification of the schema (e.g., an ABI).\n}\n\n/// @title ISchemaRegistry\n/// @notice The interface of global attestation schemas for the Ethereum Attestation Service protocol.\ninterface ISchemaRegistry is ISemver {\n    /// @notice Emitted when a new schema has been registered\n    /// @param uid The schema UID.\n    /// @param registerer The address of the account used to register the schema.\n    /// @param schema The schema data.\n    event Registered(bytes32 indexed uid, address indexed registerer, SchemaRecord schema);\n\n    /// @notice Submits and reserves a new schema\n    /// @param schema The schema data schema.\n    /// @param resolver An optional schema resolver.\n    /// @param revocable Whether the schema allows revocations explicitly.\n    /// @return The UID of the new schema.\n    function register(string calldata schema, ISchemaResolver resolver, bool revocable) external returns (bytes32);\n\n    /// @notice Returns an existing schema by UID\n    /// @param uid The UID of the schema to retrieve.\n    /// @return The schema data members.\n    function getSchema(bytes32 uid) external view returns (SchemaRecord memory);\n}\n"
    },
    "lib/eas-contracts/contracts/ISemver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/// @title ISemver\n/// @notice A semver interface.\ninterface ISemver {\n    /// @notice Returns the full semver contract version.\n    /// @return Semver contract version as a string.\n    function version() external view returns (string memory);\n}\n"
    },
    "lib/eas-contracts/contracts/Common.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n// A representation of an empty/uninitialized UID.\nbytes32 constant EMPTY_UID = 0;\n\n// A zero expiration represents an non-expiring attestation.\nuint64 constant NO_EXPIRATION_TIME = 0;\n\nerror AccessDenied();\nerror DeadlineExpired();\nerror InvalidEAS();\nerror InvalidLength();\nerror InvalidSignature();\nerror NotFound();\n\n/// @notice A struct representing ECDSA signature data.\nstruct Signature {\n    uint8 v; // The recovery ID.\n    bytes32 r; // The x-coordinate of the nonce R.\n    bytes32 s; // The signature data.\n}\n\n/// @notice A struct representing a single attestation.\nstruct Attestation {\n    bytes32 uid; // A unique identifier of the attestation.\n    bytes32 schema; // The unique identifier of the schema.\n    uint64 time; // The time when the attestation was created (Unix timestamp).\n    uint64 expirationTime; // The time when the attestation expires (Unix timestamp).\n    uint64 revocationTime; // The time when the attestation was revoked (Unix timestamp).\n    bytes32 refUID; // The UID of the related attestation.\n    address recipient; // The recipient of the attestation.\n    address attester; // The attester/sender of the attestation.\n    bool revocable; // Whether the attestation is revocable.\n    bytes data; // Custom attestation data.\n}\n\n/// @notice A helper function to work with unchecked iterators in loops.\nfunction uncheckedInc(uint256 i) pure returns (uint256 j) {\n    unchecked {\n        j = i + 1;\n    }\n}\n"
    },
    "lib/risc0-ethereum/contracts/src/Util.sol": {
      "content": "// Copyright 2024 RISC Zero, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n\npragma solidity ^0.8.9;\n\n/// @notice reverse the byte order of the uint256 value.\n/// @dev Solidity uses a big-endian ABI encoding. Reversing the byte order before encoding\n/// ensure that the encoded value will be little-endian.\n/// Written by k06a. https://ethereum.stackexchange.com/a/83627\nfunction reverseByteOrderUint256(uint256 input) pure returns (uint256 v) {\n    v = input;\n\n    // swap bytes\n    v = ((v & 0xFF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00) >> 8)\n        | ((v & 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) << 8);\n\n    // swap 2-byte long pairs\n    v = ((v & 0xFFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000) >> 16)\n        | ((v & 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) << 16);\n\n    // swap 4-byte long pairs\n    v = ((v & 0xFFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000) >> 32)\n        | ((v & 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) << 32);\n\n    // swap 8-byte long pairs\n    v = ((v & 0xFFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF0000000000000000) >> 64)\n        | ((v & 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) << 64);\n\n    // swap 16-byte long pairs\n    v = (v >> 128) | (v << 128);\n}\n\n/// @notice reverse the byte order of the uint32 value.\n/// @dev Solidity uses a big-endian ABI encoding. Reversing the byte order before encoding\n/// ensure that the encoded value will be little-endian.\n/// Written by k06a. https://ethereum.stackexchange.com/a/83627\nfunction reverseByteOrderUint32(uint32 input) pure returns (uint32 v) {\n    v = input;\n\n    // swap bytes\n    v = ((v & 0xFF00FF00) >> 8) | ((v & 0x00FF00FF) << 8);\n\n    // swap 2-byte long pairs\n    v = (v >> 16) | (v << 16);\n}\n\n/// @notice reverse the byte order of the uint16 value.\n/// @dev Solidity uses a big-endian ABI encoding. Reversing the byte order before encoding\n/// ensure that the encoded value will be little-endian.\n/// Written by k06a. https://ethereum.stackexchange.com/a/83627\nfunction reverseByteOrderUint16(uint16 input) pure returns (uint16 v) {\n    v = input;\n\n    // swap bytes\n    v = (v >> 8) | ((v & 0x00FF) << 8);\n}\n"
    },
    "src/interfaces/ILibreCoreGateway.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {IInvestorRegistry} from \"src/interfaces/IInvestorRegistry.sol\";\nimport {IInstrumentRegistry} from \"src/interfaces/IInstrumentRegistry.sol\";\nimport {IRoleRegistry} from \"src/interfaces/IRoleRegistry.sol\";\nimport {IGatewayManager} from \"src/interfaces/IGatewayManager.sol\";\nimport {Attestation} from \"eas-contracts/IEAS.sol\";\n\n/**\n * @notice Structure representing token transfer details across chains\n * @dev Used for both locking and unlocking operations\n */\nstruct TokenTransfer {\n    uint16 chainSelector; // Unique 16-bit Custom Chain ID where the Token is transfered\n    bytes32 instrumentId; // Instrument ID associated with the security token\n    bytes32 investorId; // Investor ID associated with the sender\n    bytes receiver; // Recipient's address for minting/unlocking\n    uint256 amount; // Amount of the asset to transfer\n}\n\n/**\n * @notice Structure for managing investor addresses across specific chain\n * @dev Each address change is encoded as: [1 byte action][n bytes address]\n */\nstruct ChainInvestorAddresses {\n    // Unique investor ID\n    bytes32 investorId;\n    // Unique chain ID\n    uint16 chainSelector;\n    // Address size for that chain\n    uint8 addressSize;\n    // A list of concatenated bytes describing a change in addresses\n    // Format `addressChanges`` := bytes1 action ++ bytes accountAddress\n    // where `action`: 0b0 -> Add, 0b1 -> Remove\n    bytes[] addressChanges;\n}\n\n/// @notice Interface for the Libre Core Gateway.\ninterface ILibreCoreGateway {\n    // Events\n    /**\n     * @notice Emitted when tokens are locked on source chain\n     * @param encodedTransferDetails ABI-encoded TokenTransfer struct\n     */\n    event TokenLockedAndBridged(bytes encodedTransferDetails);\n\n    /**\n     * @notice Emitted when tokens are unlocked on destination chain\n     * @param encodedTransferDetails ABI-encoded TokenTransfer struct\n     */\n    event TokenUnlocked(bytes encodedTransferDetails);\n\n    /**\n     * @notice Emitted when a credential is bridged to other chains\n     * @param investorId Investor ID of the investor\n     * @param chainSelectors Array of investor preffered chains on which credential to be bridged\n     * @param credentialId Unique identifier of the bridged credential\n     */\n    event CredentialBridged(bytes32 investorId, uint16[] chainSelectors, bytes32 credentialId);\n\n    /**\n     * @notice Emitted when investor chain-specific addresses are bridged\n     * @param investorId Investor ID of the investor\n     * @param chainSelectors Array of investor preferred chains on which addresses updates to be bridged\n     * @param encodedChainInvestorAddresses ABI-encoded ChainInvestorAddresses struct\n     */\n    event ChainInvestorAddressesBridged(\n        bytes32 investorId, uint16[] chainSelectors, bytes encodedChainInvestorAddresses\n    );\n\n    /**\n     * @notice Emitted when chain support status is updated\n     * @param chainSelector Chain ID whose support status changed\n     * @param isSupported New support status\n     */\n    event ChainSupportUpdated(uint16 chainSelector, bool isSupported);\n\n    /**\n     * @notice Emitted when chain variable length address support status is updated\n     * @param _chainSelector Chain ID whose support status changed\n     * @param _isVariableLengthAddress New support status\n     */\n    event ChainVariableLengthAddressSupportUpdated(uint16 _chainSelector, bool _isVariableLengthAddress);\n\n    // Custom Errors\n    /// @notice Thrown when operation is attempted on an unsupported chain\n    /// @param chainSelector The unsupported chain ID\n    error CoreGateway_ChainNotSupported(uint16 chainSelector);\n\n    /// @notice Thrown when the chain selector (chain ID) not matches with Native chain ID for unlock requests\n    error CoreGateway_InvalidNativeChainSelector();\n\n    /// @notice Thrown when token address is not found or invalid\n    /// @param token The invalid token address\n    error CoreGateway_TokenAddressNotFound(address token);\n\n    /// @notice Thrown when attempting transfer with zero amount\n    error CoreGateway_ZeroAmount();\n\n    /// @notice Thrown when transfer validation fails\n    error CoreGateway_InvalidTransfer();\n\n    /// @notice Thrown when provided investor id is not found\n    error CoreGateway_InvalidInvestor();\n\n    /// @notice Thrown when wrong inputs are provided\n    error CoreGateway_InvalidInput();\n\n    /// @notice Thrown when credential to be bridged are not stored or mismatches with registry\n    error CoreGateway_InvalidCredential();\n\n    /// @notice Thrown when an attempted status update results in no actual change.\n    error CoreGateway_NoStatusChanged();\n\n    /**\n     * @notice Initializes the gateway contract\n     * @param _instrumentRegistry Address of the Instrument Registry\n     * @param _investorRegistry Address of the Investor Registry\n     * @param _gatewayManager Address of the Gateway Manager\n     * @param _roleRegistry Address of the Role Registry\n     * @param _nativeChainSelector Native Custom Chain ID\n     * @param _supportedChains Array of supported custom chain Ids\n     */\n    function initialize(\n        IInstrumentRegistry _instrumentRegistry,\n        IInvestorRegistry _investorRegistry,\n        IGatewayManager _gatewayManager,\n        IRoleRegistry _roleRegistry,\n        uint16 _nativeChainSelector,\n        uint16[] memory _supportedChains\n    ) external;\n\n    /**\n     * @notice Locks tokens for cross-chain transfer and emits event for minting\n     * @dev Validates investor credentials and cross-chain addresses before locking\n     * @param transferDetails The details of the token transfer.\n     */\n    function lockAndBridge(TokenTransfer calldata transferDetails) external;\n\n    /**\n     * @notice Unlocks tokens on the source chain\n     * @dev Called by bridge operators to release tokens to the recipient\n     * @param _senderRole The role of the caller\n     * @param encodedTransferDetails ABI-encoded transfer details.\n     */\n    function unlock(bytes32 _senderRole, bytes calldata encodedTransferDetails) external;\n\n    /**\n     * @notice Bridges a credential to one or more destination chains.\n     * @dev Perform below steps:\n     *      1. Verifies all destination chains are supported\n     *      2. Validates the attestation matches the stored credential for the investor\n     *      3. Emits CredentialBridged event for cross-chain communication\n     * @param _senderRole The role of the caller\n     * @param attestation The attestation details to bridge.\n     * @param destinationChainSelectors Array of destination chain IDs.\n     */\n    function bridgeCredential(\n        bytes32 _senderRole,\n        Attestation calldata attestation,\n        uint16[] calldata destinationChainSelectors\n    ) external;\n\n    /**\n     * @notice Bridges investor addresses updates.\n     * @dev Processes and broadcasts chain specific address changes across investor preferred chains\n     *         Emits `ChainInvestorAddressesBridged` event for each chain's address updates.\n     *\n     * @param _senderRole The role of the caller.\n     * @param _investorId The unique identifier of the investor whose addresses are being updated.\n     * @param _addressChanges ABI-encoded updates representing address changes per chain or context.\n     * @param chainSelectors Array of investor preferred chains on which addresses updates to be bridged\n     */\n    function bridgeInvestorAddresses(\n        bytes32 _senderRole,\n        bytes32 _investorId,\n        bytes[] calldata _addressChanges,\n        uint16[] calldata chainSelectors\n    ) external;\n\n    /**\n     * @notice Pauses all gateway operations\n     * @param _senderRole The role of the caller\n     */\n    function pause(bytes32 _senderRole) external;\n\n    /**\n     * @notice Unpauses gateway operations\n     * @param _senderRole The role of the caller\n     */\n    function unpause(bytes32 _senderRole) external;\n\n    /**\n     * @notice Enables or disables support for a specific chain.\n     * @param _senderRole The role of the caller\n     * @param chainSelector The Custom chain ID.\n     * @param isSupported Whether the chain is supported.\n     */\n    function setChainSupport(bytes32 _senderRole, uint16 chainSelector, bool isSupported) external;\n\n    /**\n     * @notice Enables or disables support for variable length addresses for a specific chain.\n     * @param _senderRole The role of the caller\n     * @param _chainSelector The Custom chain ID.\n     * @param _isVariableLengthAddress Whether variable length addresses for the chain are supported.\n     */\n    function setChainVariableLengthAddressSupport(\n        bytes32 _senderRole,\n        uint16 _chainSelector,\n        bool _isVariableLengthAddress\n    ) external;\n\n    /**\n     * @notice Retrieves the total amount of a specific instrument/token locked in the gateway.\n     * @param instrumentId The Instrument ID associated with the security token\n     * @return The total amount of the token locked in the gateway\n     */\n    function getLockedBalance(bytes32 instrumentId) external view returns (uint256);\n\n    /**\n     * @notice Checks if a chain is supported.\n     * @param chainSelector The ID of the chain to check.\n     * @return True if the chain is supported, false otherwise.\n     */\n    function isSupportedChain(uint16 chainSelector) external view returns (bool);\n\n    /**\n     * @notice Gets the list of supported chains\n     * @return uint16[] Array of supported chain IDs\n     */\n    function getSupportedChains() external view returns (uint16[] memory);\n}\n"
    },
    "lib/risc0-ethereum/contracts/src/steel/Steel.sol": {
      "content": "// Copyright 2024 RISC Zero, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n\npragma solidity ^0.8.9;\n\n/// @title Steel Library\n/// @notice This library provides a collection of utilities to work with Steel commitments in Solidity.\nlibrary Steel {\n    /// @notice Represents a commitment to a specific block in the blockchain.\n    /// @dev The `id` combines the version and the actual identifier of the claim, such as the block number.\n    /// @dev The `digest` represents the data being committed to, e.g. the hash of the execution block.\n    /// @dev The `configID` is the cryptographic digest of the network configuration.\n    struct Commitment {\n        uint256 id;\n        bytes32 digest;\n        bytes32 configID;\n    }\n\n    /// @notice The version of the Commitment is incorrect.\n    error InvalidCommitmentVersion();\n\n    /// @notice The Commitment is too old and can no longer be validated.\n    error CommitmentTooOld();\n\n    /// @notice Validates if the provided Commitment matches the block hash of the given block number.\n    /// @param commitment The Commitment struct to validate.\n    /// @return True if the commitment's block hash matches the block hash of the block number, false otherwise.\n    function validateCommitment(Commitment memory commitment) internal view returns (bool) {\n        (uint240 claimID, uint16 version) = Encoding.decodeVersionedID(commitment.id);\n        if (version == 0) {\n            return validateBlockCommitment(claimID, commitment.digest);\n        } else if (version == 1) {\n            return validateBeaconCommitment(claimID, commitment.digest);\n        } else {\n            revert InvalidCommitmentVersion();\n        }\n    }\n\n    /// @notice Validates if the provided block commitment matches the block hash of the given block number.\n    /// @param blockNumber The block number to compare against.\n    /// @param blockHash The block hash to validate.\n    /// @return True if the block's block hash matches the block hash, false otherwise.\n    function validateBlockCommitment(uint256 blockNumber, bytes32 blockHash) internal view returns (bool) {\n        if (block.number - blockNumber > 256) {\n            revert CommitmentTooOld();\n        }\n        return blockHash == blockhash(blockNumber);\n    }\n\n    /// @notice Validates if the provided beacon commitment matches the block root of the given timestamp.\n    /// @param timestamp The timestamp to compare against.\n    /// @param blockRoot The block root to validate.\n    /// @return True if the block's block root matches the block root, false otherwise.\n    function validateBeaconCommitment(uint256 timestamp, bytes32 blockRoot) internal view returns (bool) {\n        if (block.timestamp - timestamp > 12 * 8191) {\n            revert CommitmentTooOld();\n        }\n        return blockRoot == Beacon.parentBlockRoot(timestamp);\n    }\n}\n\n/// @title Beacon Library\nlibrary Beacon {\n    /// @notice The address of the Beacon roots contract.\n    /// @dev https://eips.ethereum.org/EIPS/eip-4788\n    address internal constant BEACON_ROOTS_ADDRESS = 0x000F3df6D732807Ef1319fB7B8bB8522d0Beac02;\n\n    /// @notice Find the root of the Beacon block corresponding to the parent of the execution block with the given timestamp.\n    /// @return root Returns the corresponding Beacon block root or null, if no such block exists.\n    function parentBlockRoot(uint256 timestamp) internal view returns (bytes32 root) {\n        (bool success, bytes memory result) = BEACON_ROOTS_ADDRESS.staticcall(abi.encode(timestamp));\n        if (success) {\n            return abi.decode(result, (bytes32));\n        }\n    }\n}\n\n/// @title Encoding Library\nlibrary Encoding {\n    /// @notice Encodes a version and ID into a single uint256 value.\n    /// @param id The base ID to be encoded, limited by 240 bits (or the maximum value of a uint240).\n    /// @param version The version number to be encoded, limited by 16 bits (or the maximum value of a uint16).\n    /// @return Returns a single uint256 value that contains both the `id` and the `version` encoded into it.\n    function encodeVersionedID(uint240 id, uint16 version) internal pure returns (uint256) {\n        uint256 encoded;\n        assembly {\n            encoded := or(shl(240, version), id)\n        }\n        return encoded;\n    }\n\n    /// @notice Decodes a version and ID from a single uint256 value.\n    /// @param id The single uint256 value to be decoded.\n    /// @return Returns two values: a uint240 for the original base ID and a uint16 for the version number encoded into it.\n    function decodeVersionedID(uint256 id) internal pure returns (uint240, uint16) {\n        uint240 decoded;\n        uint16 version;\n        assembly {\n            decoded := and(id, 0x0000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n            version := shr(240, id)\n        }\n        return (decoded, version);\n    }\n}\n"
    },
    "lib/eas-contracts/contracts/resolver/ISchemaResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { Attestation } from \"./../Common.sol\";\nimport { ISemver } from \"./../ISemver.sol\";\n\n/// @title ISchemaResolver\n/// @notice The interface of an optional schema resolver.\ninterface ISchemaResolver is ISemver {\n    /// @notice Checks if the resolver can be sent ETH.\n    /// @return Whether the resolver supports ETH transfers.\n    function isPayable() external pure returns (bool);\n\n    /// @notice Processes an attestation and verifies whether it's valid.\n    /// @param attestation The new attestation.\n    /// @return Whether the attestation is valid.\n    function attest(Attestation calldata attestation) external payable returns (bool);\n\n    /// @notice Processes multiple attestations and verifies whether they are valid.\n    /// @param attestations The new attestations.\n    /// @param values Explicit ETH amounts which were sent with each attestation.\n    /// @return Whether all the attestations are valid.\n    function multiAttest(\n        Attestation[] calldata attestations,\n        uint256[] calldata values\n    ) external payable returns (bool);\n\n    /// @notice Processes an attestation revocation and verifies if it can be revoked.\n    /// @param attestation The existing attestation to be revoked.\n    /// @return Whether the attestation can be revoked.\n    function revoke(Attestation calldata attestation) external payable returns (bool);\n\n    /// @notice Processes revocation of multiple attestation and verifies they can be revoked.\n    /// @param attestations The existing attestations to be revoked.\n    /// @param values Explicit ETH amounts which were sent with each revocation.\n    /// @return Whether the attestations can be revoked.\n    function multiRevoke(\n        Attestation[] calldata attestations,\n        uint256[] calldata values\n    ) external payable returns (bool);\n}\n"
    }
  },
  "settings": {
    "remappings": [
      "BokkyPooBahsDateTimeLibrary/=lib/BokkyPooBahsDateTimeLibrary/",
      "ds-test/=lib/forge-std/lib/ds-test/src/",
      "forge-std/=lib/forge-std/src/",
      "openzeppelin-contracts/=lib/openzeppelin-contracts/",
      "openzeppelin/=lib/openzeppelin-contracts/",
      "@openzeppelin/=lib/openzeppelin-contracts/",
      "openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/",
      "risc0/=lib/risc0-ethereum/contracts/src/",
      "eas-contracts/=lib/eas-contracts/contracts/",
      "safe-contracts/=lib/safe-contracts/contracts/",
      "erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/",
      "risc0-ethereum/=lib/risc0-ethereum/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "metadata": {
      "useLiteralContent": false,
      "bytecodeHash": "ipfs",
      "appendCBOR": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "evmVersion": "cancun",
    "viaIR": false,
    "libraries": {
      "src/lib/SortedLinkedList.sol": {
        "SortedLinkedList": "0x07B879C1bAaeeDe4dbC7383f6342556Ef144b27F"
      },
      "src/lib/TimeOperations.sol": {
        "TimeOperations": "0x852BE1E091189E68cD8721163286172d1e162a5a"
      },
      "src/utils/GatewayUtils.sol": {
        "GatewayUtils": "0xaB8b3a4CDdcf7B83C57880926Ba940F388897D11"
      }
    }
  }
}}